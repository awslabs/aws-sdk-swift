// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessControlAttribute: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(AccessControlAttributeValue.self, forKey: .value)
        value = valueDecoded
    }
}

extension AccessControlAttribute: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccessControlAttribute(key: \(String(describing: key)), value: \(String(describing: value)))"}
}

/// <p>These are AWS SSO identity store attributes that you can configure for use in attributes-based access control (ABAC). You can create permission policies that determine who can access your AWS resources based upon the configured attribute value(s). When you enable ABAC and specify AccessControlAttributes, AWS SSO passes the attribute(s) value of the authenticated user into IAM for use in policy evaluation.</p>
public struct AccessControlAttribute: Equatable {
    /// <p>The name of the attribute associated with your identities in your identity source. This is used to map a specified attribute in your identity source with an attribute in AWS SSO.</p>
    public let key: String?
    /// <p>The value used for mapping a specified attribute to an identity source.</p>
    public let value: AccessControlAttributeValue?

    public init (
        key: String? = nil,
        value: AccessControlAttributeValue? = nil
    )
    {
        self.key = key
        self.value = value
    }
}

extension AccessControlAttributeValue: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case source = "Source"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let source = source {
            var sourceContainer = encodeContainer.nestedUnkeyedContainer(forKey: .source)
            for accesscontrolattributevaluesourcelist0 in source {
                try sourceContainer.encode(accesscontrolattributevaluesourcelist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceContainer = try containerValues.decodeIfPresent([String?].self, forKey: .source)
        var sourceDecoded0:[String]? = nil
        if let sourceContainer = sourceContainer {
            sourceDecoded0 = [String]()
            for string0 in sourceContainer {
                if let string0 = string0 {
                    sourceDecoded0?.append(string0)
                }
            }
        }
        source = sourceDecoded0
    }
}

extension AccessControlAttributeValue: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccessControlAttributeValue(source: \(String(describing: source)))"}
}

/// <p>The value used for mapping a specified attribute to an identity source.</p>
public struct AccessControlAttributeValue: Equatable {
    /// <p>The identity source to use when mapping a specified attribute to AWS SSO.</p>
    public let source: [String]?

    public init (
        source: [String]? = nil
    )
    {
        self.source = source
    }
}

extension AccessDeniedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccessDeniedException(message: \(String(describing: message)))"}
}

extension AccessDeniedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You do not have sufficient access to perform this action.</p>
public struct AccessDeniedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Equatable {
    public let message: String?
}

extension AccessDeniedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AccountAssignment: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountId = "AccountId"
        case permissionSetArn = "PermissionSetArn"
        case principalId = "PrincipalId"
        case principalType = "PrincipalType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let permissionSetArn = permissionSetArn {
            try encodeContainer.encode(permissionSetArn, forKey: .permissionSetArn)
        }
        if let principalId = principalId {
            try encodeContainer.encode(principalId, forKey: .principalId)
        }
        if let principalType = principalType {
            try encodeContainer.encode(principalType.rawValue, forKey: .principalType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let permissionSetArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .permissionSetArn)
        permissionSetArn = permissionSetArnDecoded
        let principalTypeDecoded = try containerValues.decodeIfPresent(PrincipalType.self, forKey: .principalType)
        principalType = principalTypeDecoded
        let principalIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .principalId)
        principalId = principalIdDecoded
    }
}

extension AccountAssignment: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccountAssignment(accountId: \(String(describing: accountId)), permissionSetArn: \(String(describing: permissionSetArn)), principalId: \(String(describing: principalId)), principalType: \(String(describing: principalType)))"}
}

/// <p>The assignment that indicates a principal's limited access to a specified AWS account
///       with a specified permission set.</p>
///          <note>
///             <p>The term <i>principal</i> here refers to a user or group that is defined in AWS SSO.</p>
///          </note>
public struct AccountAssignment: Equatable {
    /// <p>The identifier of the AWS account.</p>
    public let accountId: String?
    /// <p>The ARN of the permission set. For more information about ARNs, see <a href="/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource
    /// Names (ARNs) and AWS Service Namespaces</a> in the <i>AWS General Reference</i>.</p>
    public let permissionSetArn: String?
    /// <p>An identifier for an object in AWS SSO, such as a user or group. PrincipalIds are GUIDs (For example, f81d4fae-7dec-11d0-a765-00a0c91e6bf6). For more information about PrincipalIds in AWS SSO, see the <a href="/singlesignon/latest/IdentityStoreAPIReference/welcome.html">AWS SSO Identity Store API Reference</a>.</p>
    public let principalId: String?
    /// <p>The entity type for which the assignment will be created.</p>
    public let principalType: PrincipalType?

    public init (
        accountId: String? = nil,
        permissionSetArn: String? = nil,
        principalId: String? = nil,
        principalType: PrincipalType? = nil
    )
    {
        self.accountId = accountId
        self.permissionSetArn = permissionSetArn
        self.principalId = principalId
        self.principalType = principalType
    }
}

extension AccountAssignmentOperationStatus: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case createdDate = "CreatedDate"
        case failureReason = "FailureReason"
        case permissionSetArn = "PermissionSetArn"
        case principalId = "PrincipalId"
        case principalType = "PrincipalType"
        case requestId = "RequestId"
        case status = "Status"
        case targetId = "TargetId"
        case targetType = "TargetType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdDate = createdDate {
            try encodeContainer.encode(createdDate.timeIntervalSince1970, forKey: .createdDate)
        }
        if let failureReason = failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let permissionSetArn = permissionSetArn {
            try encodeContainer.encode(permissionSetArn, forKey: .permissionSetArn)
        }
        if let principalId = principalId {
            try encodeContainer.encode(principalId, forKey: .principalId)
        }
        if let principalType = principalType {
            try encodeContainer.encode(principalType.rawValue, forKey: .principalType)
        }
        if let requestId = requestId {
            try encodeContainer.encode(requestId, forKey: .requestId)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let targetId = targetId {
            try encodeContainer.encode(targetId, forKey: .targetId)
        }
        if let targetType = targetType {
            try encodeContainer.encode(targetType.rawValue, forKey: .targetType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(StatusValues.self, forKey: .status)
        status = statusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let targetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .targetId)
        targetId = targetIdDecoded
        let targetTypeDecoded = try containerValues.decodeIfPresent(TargetType.self, forKey: .targetType)
        targetType = targetTypeDecoded
        let permissionSetArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .permissionSetArn)
        permissionSetArn = permissionSetArnDecoded
        let principalTypeDecoded = try containerValues.decodeIfPresent(PrincipalType.self, forKey: .principalType)
        principalType = principalTypeDecoded
        let principalIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .principalId)
        principalId = principalIdDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
    }
}

extension AccountAssignmentOperationStatus: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccountAssignmentOperationStatus(createdDate: \(String(describing: createdDate)), failureReason: \(String(describing: failureReason)), permissionSetArn: \(String(describing: permissionSetArn)), principalId: \(String(describing: principalId)), principalType: \(String(describing: principalType)), requestId: \(String(describing: requestId)), status: \(String(describing: status)), targetId: \(String(describing: targetId)), targetType: \(String(describing: targetType)))"}
}

/// <p>The status of the creation or deletion operation of an assignment that a principal needs
///       to access an account.</p>
public struct AccountAssignmentOperationStatus: Equatable {
    /// <p>The date that the permission set was created.</p>
    public let createdDate: Date?
    /// <p>The message that contains an error or exception in case of an operation failure.</p>
    public let failureReason: String?
    /// <p>The ARN of the permission set. For more information about ARNs, see <a href="/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource
    /// Names (ARNs) and AWS Service Namespaces</a> in the <i>AWS General Reference</i>.</p>
    public let permissionSetArn: String?
    /// <p>An identifier for an object in AWS SSO, such as a user or group. PrincipalIds are GUIDs (For example, f81d4fae-7dec-11d0-a765-00a0c91e6bf6). For more information about PrincipalIds in AWS SSO, see the <a href="/singlesignon/latest/IdentityStoreAPIReference/welcome.html">AWS SSO Identity Store API Reference</a>.</p>
    public let principalId: String?
    /// <p>The entity type for which the assignment will be created.</p>
    public let principalType: PrincipalType?
    /// <p>The identifier for tracking the request operation that is generated by the universally
    ///       unique identifier (UUID) workflow.</p>
    public let requestId: String?
    /// <p>The status of the permission set provisioning process.</p>
    public let status: StatusValues?
    /// <p>TargetID is an AWS account identifier, typically a 10-12 digit string (For example, 123456789012).</p>
    public let targetId: String?
    /// <p>The entity type for which the assignment will be created.</p>
    public let targetType: TargetType?

    public init (
        createdDate: Date? = nil,
        failureReason: String? = nil,
        permissionSetArn: String? = nil,
        principalId: String? = nil,
        principalType: PrincipalType? = nil,
        requestId: String? = nil,
        status: StatusValues? = nil,
        targetId: String? = nil,
        targetType: TargetType? = nil
    )
    {
        self.createdDate = createdDate
        self.failureReason = failureReason
        self.permissionSetArn = permissionSetArn
        self.principalId = principalId
        self.principalType = principalType
        self.requestId = requestId
        self.status = status
        self.targetId = targetId
        self.targetType = targetType
    }
}

extension AccountAssignmentOperationStatusMetadata: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case createdDate = "CreatedDate"
        case requestId = "RequestId"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdDate = createdDate {
            try encodeContainer.encode(createdDate.timeIntervalSince1970, forKey: .createdDate)
        }
        if let requestId = requestId {
            try encodeContainer.encode(requestId, forKey: .requestId)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(StatusValues.self, forKey: .status)
        status = statusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
    }
}

extension AccountAssignmentOperationStatusMetadata: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccountAssignmentOperationStatusMetadata(createdDate: \(String(describing: createdDate)), requestId: \(String(describing: requestId)), status: \(String(describing: status)))"}
}

/// <p>Provides information about the <a>AccountAssignment</a> creation
///       request.</p>
public struct AccountAssignmentOperationStatusMetadata: Equatable {
    /// <p>The date that the permission set was created.</p>
    public let createdDate: Date?
    /// <p>The identifier for tracking the request operation that is generated by the universally
    ///       unique identifier (UUID) workflow.</p>
    public let requestId: String?
    /// <p>The status of the permission set provisioning process.</p>
    public let status: StatusValues?

    public init (
        createdDate: Date? = nil,
        requestId: String? = nil,
        status: StatusValues? = nil
    )
    {
        self.createdDate = createdDate
        self.requestId = requestId
        self.status = status
    }
}

public struct AttachManagedPolicyToPermissionSetInputBodyMiddleware: Middleware {
    public let id: String = "AttachManagedPolicyToPermissionSetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AttachManagedPolicyToPermissionSetInput>,
                  next: H) -> Swift.Result<OperationOutput<AttachManagedPolicyToPermissionSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AttachManagedPolicyToPermissionSetInput>
    public typealias MOutput = OperationOutput<AttachManagedPolicyToPermissionSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AttachManagedPolicyToPermissionSetOutputError>
}

extension AttachManagedPolicyToPermissionSetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AttachManagedPolicyToPermissionSetInput(instanceArn: \(String(describing: instanceArn)), managedPolicyArn: \(String(describing: managedPolicyArn)), permissionSetArn: \(String(describing: permissionSetArn)))"}
}

extension AttachManagedPolicyToPermissionSetInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case instanceArn = "InstanceArn"
        case managedPolicyArn = "ManagedPolicyArn"
        case permissionSetArn = "PermissionSetArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceArn = instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
        if let managedPolicyArn = managedPolicyArn {
            try encodeContainer.encode(managedPolicyArn, forKey: .managedPolicyArn)
        }
        if let permissionSetArn = permissionSetArn {
            try encodeContainer.encode(permissionSetArn, forKey: .permissionSetArn)
        }
    }
}

public struct AttachManagedPolicyToPermissionSetInputHeadersMiddleware: Middleware {
    public let id: String = "AttachManagedPolicyToPermissionSetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AttachManagedPolicyToPermissionSetInput>,
                  next: H) -> Swift.Result<OperationOutput<AttachManagedPolicyToPermissionSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AttachManagedPolicyToPermissionSetInput>
    public typealias MOutput = OperationOutput<AttachManagedPolicyToPermissionSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AttachManagedPolicyToPermissionSetOutputError>
}

public struct AttachManagedPolicyToPermissionSetInputQueryItemMiddleware: Middleware {
    public let id: String = "AttachManagedPolicyToPermissionSetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AttachManagedPolicyToPermissionSetInput>,
                  next: H) -> Swift.Result<OperationOutput<AttachManagedPolicyToPermissionSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AttachManagedPolicyToPermissionSetInput>
    public typealias MOutput = OperationOutput<AttachManagedPolicyToPermissionSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AttachManagedPolicyToPermissionSetOutputError>
}

public struct AttachManagedPolicyToPermissionSetInput: Equatable {
    /// <p>The ARN of the SSO instance under which the operation will be executed.
    ///       For more information about ARNs, see <a href="/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource
    /// Names (ARNs) and AWS Service Namespaces</a> in the <i>AWS General Reference</i>.</p>
    public let instanceArn: String?
    /// <p>The IAM managed policy ARN to be attached to a permission set.</p>
    public let managedPolicyArn: String?
    /// <p>The ARN of the <a>PermissionSet</a> that the managed policy should be attached
    ///        to.</p>
    public let permissionSetArn: String?

    public init (
        instanceArn: String? = nil,
        managedPolicyArn: String? = nil,
        permissionSetArn: String? = nil
    )
    {
        self.instanceArn = instanceArn
        self.managedPolicyArn = managedPolicyArn
        self.permissionSetArn = permissionSetArn
    }
}

struct AttachManagedPolicyToPermissionSetInputBody: Equatable {
    public let instanceArn: String?
    public let permissionSetArn: String?
    public let managedPolicyArn: String?
}

extension AttachManagedPolicyToPermissionSetInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case instanceArn = "InstanceArn"
        case managedPolicyArn = "ManagedPolicyArn"
        case permissionSetArn = "PermissionSetArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let permissionSetArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .permissionSetArn)
        permissionSetArn = permissionSetArnDecoded
        let managedPolicyArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .managedPolicyArn)
        managedPolicyArn = managedPolicyArnDecoded
    }
}

extension AttachManagedPolicyToPermissionSetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AttachManagedPolicyToPermissionSetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AttachManagedPolicyToPermissionSetOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AttachManagedPolicyToPermissionSetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AttachManagedPolicyToPermissionSetOutputResponse()"}
}

extension AttachManagedPolicyToPermissionSetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct AttachManagedPolicyToPermissionSetOutputResponse: Equatable {

    public init() {}
}

struct AttachManagedPolicyToPermissionSetOutputResponseBody: Equatable {
}

extension AttachManagedPolicyToPermissionSetOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension AttachedManagedPolicy: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension AttachedManagedPolicy: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AttachedManagedPolicy(arn: \(String(describing: arn)), name: \(String(describing: name)))"}
}

/// <p>A structure that stores the details of the IAM managed policy.</p>
public struct AttachedManagedPolicy: Equatable {
    /// <p>The ARN of the IAM managed policy. For more information about ARNs, see <a href="/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource
    /// Names (ARNs) and AWS Service Namespaces</a> in the <i>AWS General Reference</i>.</p>
    public let arn: String?
    /// <p>The name of the IAM managed policy.</p>
    public let name: String?

    public init (
        arn: String? = nil,
        name: String? = nil
    )
    {
        self.arn = arn
        self.name = name
    }
}

extension ConflictException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConflictException(message: \(String(describing: message)))"}
}

extension ConflictException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Occurs when a conflict with a previous successful write is detected. This generally occurs when the previous write did not have time to propagate to the host serving the current request. A retry (with appropriate backoff logic) is the recommended response to this exception.</p>
public struct ConflictException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ConflictExceptionBody: Equatable {
    public let message: String?
}

extension ConflictExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct CreateAccountAssignmentInputBodyMiddleware: Middleware {
    public let id: String = "CreateAccountAssignmentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAccountAssignmentInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAccountAssignmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAccountAssignmentInput>
    public typealias MOutput = OperationOutput<CreateAccountAssignmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAccountAssignmentOutputError>
}

extension CreateAccountAssignmentInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateAccountAssignmentInput(instanceArn: \(String(describing: instanceArn)), permissionSetArn: \(String(describing: permissionSetArn)), principalId: \(String(describing: principalId)), principalType: \(String(describing: principalType)), targetId: \(String(describing: targetId)), targetType: \(String(describing: targetType)))"}
}

extension CreateAccountAssignmentInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case instanceArn = "InstanceArn"
        case permissionSetArn = "PermissionSetArn"
        case principalId = "PrincipalId"
        case principalType = "PrincipalType"
        case targetId = "TargetId"
        case targetType = "TargetType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceArn = instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
        if let permissionSetArn = permissionSetArn {
            try encodeContainer.encode(permissionSetArn, forKey: .permissionSetArn)
        }
        if let principalId = principalId {
            try encodeContainer.encode(principalId, forKey: .principalId)
        }
        if let principalType = principalType {
            try encodeContainer.encode(principalType.rawValue, forKey: .principalType)
        }
        if let targetId = targetId {
            try encodeContainer.encode(targetId, forKey: .targetId)
        }
        if let targetType = targetType {
            try encodeContainer.encode(targetType.rawValue, forKey: .targetType)
        }
    }
}

public struct CreateAccountAssignmentInputHeadersMiddleware: Middleware {
    public let id: String = "CreateAccountAssignmentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAccountAssignmentInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAccountAssignmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAccountAssignmentInput>
    public typealias MOutput = OperationOutput<CreateAccountAssignmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAccountAssignmentOutputError>
}

public struct CreateAccountAssignmentInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateAccountAssignmentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAccountAssignmentInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAccountAssignmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAccountAssignmentInput>
    public typealias MOutput = OperationOutput<CreateAccountAssignmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAccountAssignmentOutputError>
}

public struct CreateAccountAssignmentInput: Equatable {
    /// <p>The ARN of the SSO instance under which the operation will be executed.
    ///       For more information about ARNs, see <a href="/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource
    /// Names (ARNs) and AWS Service Namespaces</a> in the <i>AWS General Reference</i>.</p>
    public let instanceArn: String?
    /// <p>The ARN of the permission set that the admin wants to grant the principal access to.</p>
    public let permissionSetArn: String?
    /// <p>An identifier for an object in AWS SSO, such as a user or group. PrincipalIds are GUIDs (For example, f81d4fae-7dec-11d0-a765-00a0c91e6bf6). For more information about PrincipalIds in AWS SSO, see the <a href="/singlesignon/latest/IdentityStoreAPIReference/welcome.html">AWS SSO Identity Store API Reference</a>.</p>
    public let principalId: String?
    /// <p>The entity type for which the assignment will be created.</p>
    public let principalType: PrincipalType?
    /// <p>TargetID is an AWS account identifier, typically a 10-12 digit string (For example, 123456789012).</p>
    public let targetId: String?
    /// <p>The entity type for which the assignment will be created.</p>
    public let targetType: TargetType?

    public init (
        instanceArn: String? = nil,
        permissionSetArn: String? = nil,
        principalId: String? = nil,
        principalType: PrincipalType? = nil,
        targetId: String? = nil,
        targetType: TargetType? = nil
    )
    {
        self.instanceArn = instanceArn
        self.permissionSetArn = permissionSetArn
        self.principalId = principalId
        self.principalType = principalType
        self.targetId = targetId
        self.targetType = targetType
    }
}

struct CreateAccountAssignmentInputBody: Equatable {
    public let instanceArn: String?
    public let targetId: String?
    public let targetType: TargetType?
    public let permissionSetArn: String?
    public let principalType: PrincipalType?
    public let principalId: String?
}

extension CreateAccountAssignmentInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case instanceArn = "InstanceArn"
        case permissionSetArn = "PermissionSetArn"
        case principalId = "PrincipalId"
        case principalType = "PrincipalType"
        case targetId = "TargetId"
        case targetType = "TargetType"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let targetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .targetId)
        targetId = targetIdDecoded
        let targetTypeDecoded = try containerValues.decodeIfPresent(TargetType.self, forKey: .targetType)
        targetType = targetTypeDecoded
        let permissionSetArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .permissionSetArn)
        permissionSetArn = permissionSetArnDecoded
        let principalTypeDecoded = try containerValues.decodeIfPresent(PrincipalType.self, forKey: .principalType)
        principalType = principalTypeDecoded
        let principalIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .principalId)
        principalId = principalIdDecoded
    }
}

extension CreateAccountAssignmentOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateAccountAssignmentOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateAccountAssignmentOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAccountAssignmentOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateAccountAssignmentOutputResponse(accountAssignmentCreationStatus: \(String(describing: accountAssignmentCreationStatus)))"}
}

extension CreateAccountAssignmentOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateAccountAssignmentOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.accountAssignmentCreationStatus = output.accountAssignmentCreationStatus
        } else {
            self.accountAssignmentCreationStatus = nil
        }
    }
}

public struct CreateAccountAssignmentOutputResponse: Equatable {
    /// <p>The status object for the account assignment creation operation.</p>
    public let accountAssignmentCreationStatus: AccountAssignmentOperationStatus?

    public init (
        accountAssignmentCreationStatus: AccountAssignmentOperationStatus? = nil
    )
    {
        self.accountAssignmentCreationStatus = accountAssignmentCreationStatus
    }
}

struct CreateAccountAssignmentOutputResponseBody: Equatable {
    public let accountAssignmentCreationStatus: AccountAssignmentOperationStatus?
}

extension CreateAccountAssignmentOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accountAssignmentCreationStatus = "AccountAssignmentCreationStatus"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountAssignmentCreationStatusDecoded = try containerValues.decodeIfPresent(AccountAssignmentOperationStatus.self, forKey: .accountAssignmentCreationStatus)
        accountAssignmentCreationStatus = accountAssignmentCreationStatusDecoded
    }
}

public struct CreateInstanceAccessControlAttributeConfigurationInputBodyMiddleware: Middleware {
    public let id: String = "CreateInstanceAccessControlAttributeConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateInstanceAccessControlAttributeConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateInstanceAccessControlAttributeConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateInstanceAccessControlAttributeConfigurationInput>
    public typealias MOutput = OperationOutput<CreateInstanceAccessControlAttributeConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateInstanceAccessControlAttributeConfigurationOutputError>
}

extension CreateInstanceAccessControlAttributeConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateInstanceAccessControlAttributeConfigurationInput(instanceAccessControlAttributeConfiguration: \(String(describing: instanceAccessControlAttributeConfiguration)), instanceArn: \(String(describing: instanceArn)))"}
}

extension CreateInstanceAccessControlAttributeConfigurationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case instanceAccessControlAttributeConfiguration = "InstanceAccessControlAttributeConfiguration"
        case instanceArn = "InstanceArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceAccessControlAttributeConfiguration = instanceAccessControlAttributeConfiguration {
            try encodeContainer.encode(instanceAccessControlAttributeConfiguration, forKey: .instanceAccessControlAttributeConfiguration)
        }
        if let instanceArn = instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
    }
}

public struct CreateInstanceAccessControlAttributeConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "CreateInstanceAccessControlAttributeConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateInstanceAccessControlAttributeConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateInstanceAccessControlAttributeConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateInstanceAccessControlAttributeConfigurationInput>
    public typealias MOutput = OperationOutput<CreateInstanceAccessControlAttributeConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateInstanceAccessControlAttributeConfigurationOutputError>
}

public struct CreateInstanceAccessControlAttributeConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateInstanceAccessControlAttributeConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateInstanceAccessControlAttributeConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateInstanceAccessControlAttributeConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateInstanceAccessControlAttributeConfigurationInput>
    public typealias MOutput = OperationOutput<CreateInstanceAccessControlAttributeConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateInstanceAccessControlAttributeConfigurationOutputError>
}

public struct CreateInstanceAccessControlAttributeConfigurationInput: Equatable {
    /// <p>Specifies the AWS SSO identity store attributes to add to your ABAC configuration. When using an external identity provider as an identity source, you can pass attributes through the SAML assertion as an alternative to configuring attributes from the AWS SSO identity store. If a SAML assertion passes any of these attributes, AWS SSO will replace the attribute value with the value from the AWS SSO identity store.</p>
    public let instanceAccessControlAttributeConfiguration: InstanceAccessControlAttributeConfiguration?
    /// <p>The ARN of the SSO instance under which the operation will be executed.</p>
    public let instanceArn: String?

    public init (
        instanceAccessControlAttributeConfiguration: InstanceAccessControlAttributeConfiguration? = nil,
        instanceArn: String? = nil
    )
    {
        self.instanceAccessControlAttributeConfiguration = instanceAccessControlAttributeConfiguration
        self.instanceArn = instanceArn
    }
}

struct CreateInstanceAccessControlAttributeConfigurationInputBody: Equatable {
    public let instanceArn: String?
    public let instanceAccessControlAttributeConfiguration: InstanceAccessControlAttributeConfiguration?
}

extension CreateInstanceAccessControlAttributeConfigurationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case instanceAccessControlAttributeConfiguration = "InstanceAccessControlAttributeConfiguration"
        case instanceArn = "InstanceArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let instanceAccessControlAttributeConfigurationDecoded = try containerValues.decodeIfPresent(InstanceAccessControlAttributeConfiguration.self, forKey: .instanceAccessControlAttributeConfiguration)
        instanceAccessControlAttributeConfiguration = instanceAccessControlAttributeConfigurationDecoded
    }
}

extension CreateInstanceAccessControlAttributeConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateInstanceAccessControlAttributeConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateInstanceAccessControlAttributeConfigurationOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateInstanceAccessControlAttributeConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateInstanceAccessControlAttributeConfigurationOutputResponse()"}
}

extension CreateInstanceAccessControlAttributeConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct CreateInstanceAccessControlAttributeConfigurationOutputResponse: Equatable {

    public init() {}
}

struct CreateInstanceAccessControlAttributeConfigurationOutputResponseBody: Equatable {
}

extension CreateInstanceAccessControlAttributeConfigurationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct CreatePermissionSetInputBodyMiddleware: Middleware {
    public let id: String = "CreatePermissionSetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreatePermissionSetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreatePermissionSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreatePermissionSetInput>
    public typealias MOutput = OperationOutput<CreatePermissionSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreatePermissionSetOutputError>
}

extension CreatePermissionSetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreatePermissionSetInput(description: \(String(describing: description)), instanceArn: \(String(describing: instanceArn)), name: \(String(describing: name)), relayState: \(String(describing: relayState)), sessionDuration: \(String(describing: sessionDuration)), tags: \(String(describing: tags)))"}
}

extension CreatePermissionSetInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case instanceArn = "InstanceArn"
        case name = "Name"
        case relayState = "RelayState"
        case sessionDuration = "SessionDuration"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let instanceArn = instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let relayState = relayState {
            try encodeContainer.encode(relayState, forKey: .relayState)
        }
        if let sessionDuration = sessionDuration {
            try encodeContainer.encode(sessionDuration, forKey: .sessionDuration)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreatePermissionSetInputHeadersMiddleware: Middleware {
    public let id: String = "CreatePermissionSetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreatePermissionSetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreatePermissionSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreatePermissionSetInput>
    public typealias MOutput = OperationOutput<CreatePermissionSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreatePermissionSetOutputError>
}

public struct CreatePermissionSetInputQueryItemMiddleware: Middleware {
    public let id: String = "CreatePermissionSetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreatePermissionSetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreatePermissionSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreatePermissionSetInput>
    public typealias MOutput = OperationOutput<CreatePermissionSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreatePermissionSetOutputError>
}

public struct CreatePermissionSetInput: Equatable {
    /// <p>The description of the <a>PermissionSet</a>.</p>
    public let description: String?
    /// <p>The ARN of the SSO instance under which the operation will be executed.
    ///       For more information about ARNs, see <a href="/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource
    /// Names (ARNs) and AWS Service Namespaces</a> in the <i>AWS General Reference</i>.</p>
    public let instanceArn: String?
    /// <p>The name of the <a>PermissionSet</a>.</p>
    public let name: String?
    /// <p>Used to redirect users within the application during the federation authentication
    ///        process.</p>
    public let relayState: String?
    /// <p>The length of time that the application user sessions are valid in the ISO-8601
    ///       standard.</p>
    public let sessionDuration: String?
    /// <p>The tags to attach to the new <a>PermissionSet</a>.</p>
    public let tags: [Tag]?

    public init (
        description: String? = nil,
        instanceArn: String? = nil,
        name: String? = nil,
        relayState: String? = nil,
        sessionDuration: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.description = description
        self.instanceArn = instanceArn
        self.name = name
        self.relayState = relayState
        self.sessionDuration = sessionDuration
        self.tags = tags
    }
}

struct CreatePermissionSetInputBody: Equatable {
    public let name: String?
    public let description: String?
    public let instanceArn: String?
    public let sessionDuration: String?
    public let relayState: String?
    public let tags: [Tag]?
}

extension CreatePermissionSetInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case instanceArn = "InstanceArn"
        case name = "Name"
        case relayState = "RelayState"
        case sessionDuration = "SessionDuration"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let instanceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let sessionDurationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sessionDuration)
        sessionDuration = sessionDurationDecoded
        let relayStateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .relayState)
        relayState = relayStateDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreatePermissionSetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreatePermissionSetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreatePermissionSetOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreatePermissionSetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreatePermissionSetOutputResponse(permissionSet: \(String(describing: permissionSet)))"}
}

extension CreatePermissionSetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreatePermissionSetOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.permissionSet = output.permissionSet
        } else {
            self.permissionSet = nil
        }
    }
}

public struct CreatePermissionSetOutputResponse: Equatable {
    /// <p>Defines the level of access on an AWS account.</p>
    public let permissionSet: PermissionSet?

    public init (
        permissionSet: PermissionSet? = nil
    )
    {
        self.permissionSet = permissionSet
    }
}

struct CreatePermissionSetOutputResponseBody: Equatable {
    public let permissionSet: PermissionSet?
}

extension CreatePermissionSetOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case permissionSet = "PermissionSet"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let permissionSetDecoded = try containerValues.decodeIfPresent(PermissionSet.self, forKey: .permissionSet)
        permissionSet = permissionSetDecoded
    }
}

public struct DeleteAccountAssignmentInputBodyMiddleware: Middleware {
    public let id: String = "DeleteAccountAssignmentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAccountAssignmentInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAccountAssignmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAccountAssignmentInput>
    public typealias MOutput = OperationOutput<DeleteAccountAssignmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAccountAssignmentOutputError>
}

extension DeleteAccountAssignmentInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteAccountAssignmentInput(instanceArn: \(String(describing: instanceArn)), permissionSetArn: \(String(describing: permissionSetArn)), principalId: \(String(describing: principalId)), principalType: \(String(describing: principalType)), targetId: \(String(describing: targetId)), targetType: \(String(describing: targetType)))"}
}

extension DeleteAccountAssignmentInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case instanceArn = "InstanceArn"
        case permissionSetArn = "PermissionSetArn"
        case principalId = "PrincipalId"
        case principalType = "PrincipalType"
        case targetId = "TargetId"
        case targetType = "TargetType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceArn = instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
        if let permissionSetArn = permissionSetArn {
            try encodeContainer.encode(permissionSetArn, forKey: .permissionSetArn)
        }
        if let principalId = principalId {
            try encodeContainer.encode(principalId, forKey: .principalId)
        }
        if let principalType = principalType {
            try encodeContainer.encode(principalType.rawValue, forKey: .principalType)
        }
        if let targetId = targetId {
            try encodeContainer.encode(targetId, forKey: .targetId)
        }
        if let targetType = targetType {
            try encodeContainer.encode(targetType.rawValue, forKey: .targetType)
        }
    }
}

public struct DeleteAccountAssignmentInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteAccountAssignmentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAccountAssignmentInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAccountAssignmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAccountAssignmentInput>
    public typealias MOutput = OperationOutput<DeleteAccountAssignmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAccountAssignmentOutputError>
}

public struct DeleteAccountAssignmentInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteAccountAssignmentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAccountAssignmentInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAccountAssignmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAccountAssignmentInput>
    public typealias MOutput = OperationOutput<DeleteAccountAssignmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAccountAssignmentOutputError>
}

public struct DeleteAccountAssignmentInput: Equatable {
    /// <p>The ARN of the SSO instance under which the operation will be executed.
    ///       For more information about ARNs, see <a href="/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource
    /// Names (ARNs) and AWS Service Namespaces</a> in the <i>AWS General Reference</i>.</p>
    public let instanceArn: String?
    /// <p>The ARN of the permission set that will be used to remove access.</p>
    public let permissionSetArn: String?
    /// <p>An identifier for an object in AWS SSO, such as a user or group. PrincipalIds are GUIDs (For example, f81d4fae-7dec-11d0-a765-00a0c91e6bf6). For more information about PrincipalIds in AWS SSO, see the <a href="/singlesignon/latest/IdentityStoreAPIReference/welcome.html">AWS SSO Identity Store API Reference</a>.</p>
    public let principalId: String?
    /// <p>The entity type for which the assignment will be deleted.</p>
    public let principalType: PrincipalType?
    /// <p>TargetID is an AWS account identifier, typically a 10-12 digit string (For example, 123456789012).</p>
    public let targetId: String?
    /// <p>The entity type for which the assignment will be deleted.</p>
    public let targetType: TargetType?

    public init (
        instanceArn: String? = nil,
        permissionSetArn: String? = nil,
        principalId: String? = nil,
        principalType: PrincipalType? = nil,
        targetId: String? = nil,
        targetType: TargetType? = nil
    )
    {
        self.instanceArn = instanceArn
        self.permissionSetArn = permissionSetArn
        self.principalId = principalId
        self.principalType = principalType
        self.targetId = targetId
        self.targetType = targetType
    }
}

struct DeleteAccountAssignmentInputBody: Equatable {
    public let instanceArn: String?
    public let targetId: String?
    public let targetType: TargetType?
    public let permissionSetArn: String?
    public let principalType: PrincipalType?
    public let principalId: String?
}

extension DeleteAccountAssignmentInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case instanceArn = "InstanceArn"
        case permissionSetArn = "PermissionSetArn"
        case principalId = "PrincipalId"
        case principalType = "PrincipalType"
        case targetId = "TargetId"
        case targetType = "TargetType"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let targetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .targetId)
        targetId = targetIdDecoded
        let targetTypeDecoded = try containerValues.decodeIfPresent(TargetType.self, forKey: .targetType)
        targetType = targetTypeDecoded
        let permissionSetArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .permissionSetArn)
        permissionSetArn = permissionSetArnDecoded
        let principalTypeDecoded = try containerValues.decodeIfPresent(PrincipalType.self, forKey: .principalType)
        principalType = principalTypeDecoded
        let principalIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .principalId)
        principalId = principalIdDecoded
    }
}

extension DeleteAccountAssignmentOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAccountAssignmentOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteAccountAssignmentOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAccountAssignmentOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteAccountAssignmentOutputResponse(accountAssignmentDeletionStatus: \(String(describing: accountAssignmentDeletionStatus)))"}
}

extension DeleteAccountAssignmentOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteAccountAssignmentOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.accountAssignmentDeletionStatus = output.accountAssignmentDeletionStatus
        } else {
            self.accountAssignmentDeletionStatus = nil
        }
    }
}

public struct DeleteAccountAssignmentOutputResponse: Equatable {
    /// <p>The status object for the account assignment deletion operation.</p>
    public let accountAssignmentDeletionStatus: AccountAssignmentOperationStatus?

    public init (
        accountAssignmentDeletionStatus: AccountAssignmentOperationStatus? = nil
    )
    {
        self.accountAssignmentDeletionStatus = accountAssignmentDeletionStatus
    }
}

struct DeleteAccountAssignmentOutputResponseBody: Equatable {
    public let accountAssignmentDeletionStatus: AccountAssignmentOperationStatus?
}

extension DeleteAccountAssignmentOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accountAssignmentDeletionStatus = "AccountAssignmentDeletionStatus"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountAssignmentDeletionStatusDecoded = try containerValues.decodeIfPresent(AccountAssignmentOperationStatus.self, forKey: .accountAssignmentDeletionStatus)
        accountAssignmentDeletionStatus = accountAssignmentDeletionStatusDecoded
    }
}

public struct DeleteInlinePolicyFromPermissionSetInputBodyMiddleware: Middleware {
    public let id: String = "DeleteInlinePolicyFromPermissionSetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteInlinePolicyFromPermissionSetInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteInlinePolicyFromPermissionSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteInlinePolicyFromPermissionSetInput>
    public typealias MOutput = OperationOutput<DeleteInlinePolicyFromPermissionSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteInlinePolicyFromPermissionSetOutputError>
}

extension DeleteInlinePolicyFromPermissionSetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteInlinePolicyFromPermissionSetInput(instanceArn: \(String(describing: instanceArn)), permissionSetArn: \(String(describing: permissionSetArn)))"}
}

extension DeleteInlinePolicyFromPermissionSetInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case instanceArn = "InstanceArn"
        case permissionSetArn = "PermissionSetArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceArn = instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
        if let permissionSetArn = permissionSetArn {
            try encodeContainer.encode(permissionSetArn, forKey: .permissionSetArn)
        }
    }
}

public struct DeleteInlinePolicyFromPermissionSetInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteInlinePolicyFromPermissionSetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteInlinePolicyFromPermissionSetInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteInlinePolicyFromPermissionSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteInlinePolicyFromPermissionSetInput>
    public typealias MOutput = OperationOutput<DeleteInlinePolicyFromPermissionSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteInlinePolicyFromPermissionSetOutputError>
}

public struct DeleteInlinePolicyFromPermissionSetInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteInlinePolicyFromPermissionSetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteInlinePolicyFromPermissionSetInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteInlinePolicyFromPermissionSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteInlinePolicyFromPermissionSetInput>
    public typealias MOutput = OperationOutput<DeleteInlinePolicyFromPermissionSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteInlinePolicyFromPermissionSetOutputError>
}

public struct DeleteInlinePolicyFromPermissionSetInput: Equatable {
    /// <p>The ARN of the SSO instance under which the operation will be executed.
    ///       For more information about ARNs, see <a href="/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource
    /// Names (ARNs) and AWS Service Namespaces</a> in the <i>AWS General Reference</i>.</p>
    public let instanceArn: String?
    /// <p>The ARN of the permission set that will be used to remove access.</p>
    public let permissionSetArn: String?

    public init (
        instanceArn: String? = nil,
        permissionSetArn: String? = nil
    )
    {
        self.instanceArn = instanceArn
        self.permissionSetArn = permissionSetArn
    }
}

struct DeleteInlinePolicyFromPermissionSetInputBody: Equatable {
    public let instanceArn: String?
    public let permissionSetArn: String?
}

extension DeleteInlinePolicyFromPermissionSetInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case instanceArn = "InstanceArn"
        case permissionSetArn = "PermissionSetArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let permissionSetArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .permissionSetArn)
        permissionSetArn = permissionSetArnDecoded
    }
}

extension DeleteInlinePolicyFromPermissionSetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteInlinePolicyFromPermissionSetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteInlinePolicyFromPermissionSetOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteInlinePolicyFromPermissionSetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteInlinePolicyFromPermissionSetOutputResponse()"}
}

extension DeleteInlinePolicyFromPermissionSetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteInlinePolicyFromPermissionSetOutputResponse: Equatable {

    public init() {}
}

struct DeleteInlinePolicyFromPermissionSetOutputResponseBody: Equatable {
}

extension DeleteInlinePolicyFromPermissionSetOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteInstanceAccessControlAttributeConfigurationInputBodyMiddleware: Middleware {
    public let id: String = "DeleteInstanceAccessControlAttributeConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteInstanceAccessControlAttributeConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteInstanceAccessControlAttributeConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteInstanceAccessControlAttributeConfigurationInput>
    public typealias MOutput = OperationOutput<DeleteInstanceAccessControlAttributeConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteInstanceAccessControlAttributeConfigurationOutputError>
}

extension DeleteInstanceAccessControlAttributeConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteInstanceAccessControlAttributeConfigurationInput(instanceArn: \(String(describing: instanceArn)))"}
}

extension DeleteInstanceAccessControlAttributeConfigurationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case instanceArn = "InstanceArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceArn = instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
    }
}

public struct DeleteInstanceAccessControlAttributeConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteInstanceAccessControlAttributeConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteInstanceAccessControlAttributeConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteInstanceAccessControlAttributeConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteInstanceAccessControlAttributeConfigurationInput>
    public typealias MOutput = OperationOutput<DeleteInstanceAccessControlAttributeConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteInstanceAccessControlAttributeConfigurationOutputError>
}

public struct DeleteInstanceAccessControlAttributeConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteInstanceAccessControlAttributeConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteInstanceAccessControlAttributeConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteInstanceAccessControlAttributeConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteInstanceAccessControlAttributeConfigurationInput>
    public typealias MOutput = OperationOutput<DeleteInstanceAccessControlAttributeConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteInstanceAccessControlAttributeConfigurationOutputError>
}

public struct DeleteInstanceAccessControlAttributeConfigurationInput: Equatable {
    /// <p>The ARN of the SSO instance under which the operation will be executed.</p>
    public let instanceArn: String?

    public init (
        instanceArn: String? = nil
    )
    {
        self.instanceArn = instanceArn
    }
}

struct DeleteInstanceAccessControlAttributeConfigurationInputBody: Equatable {
    public let instanceArn: String?
}

extension DeleteInstanceAccessControlAttributeConfigurationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case instanceArn = "InstanceArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
    }
}

extension DeleteInstanceAccessControlAttributeConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteInstanceAccessControlAttributeConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteInstanceAccessControlAttributeConfigurationOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteInstanceAccessControlAttributeConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteInstanceAccessControlAttributeConfigurationOutputResponse()"}
}

extension DeleteInstanceAccessControlAttributeConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteInstanceAccessControlAttributeConfigurationOutputResponse: Equatable {

    public init() {}
}

struct DeleteInstanceAccessControlAttributeConfigurationOutputResponseBody: Equatable {
}

extension DeleteInstanceAccessControlAttributeConfigurationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeletePermissionSetInputBodyMiddleware: Middleware {
    public let id: String = "DeletePermissionSetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeletePermissionSetInput>,
                  next: H) -> Swift.Result<OperationOutput<DeletePermissionSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeletePermissionSetInput>
    public typealias MOutput = OperationOutput<DeletePermissionSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeletePermissionSetOutputError>
}

extension DeletePermissionSetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeletePermissionSetInput(instanceArn: \(String(describing: instanceArn)), permissionSetArn: \(String(describing: permissionSetArn)))"}
}

extension DeletePermissionSetInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case instanceArn = "InstanceArn"
        case permissionSetArn = "PermissionSetArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceArn = instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
        if let permissionSetArn = permissionSetArn {
            try encodeContainer.encode(permissionSetArn, forKey: .permissionSetArn)
        }
    }
}

public struct DeletePermissionSetInputHeadersMiddleware: Middleware {
    public let id: String = "DeletePermissionSetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeletePermissionSetInput>,
                  next: H) -> Swift.Result<OperationOutput<DeletePermissionSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeletePermissionSetInput>
    public typealias MOutput = OperationOutput<DeletePermissionSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeletePermissionSetOutputError>
}

public struct DeletePermissionSetInputQueryItemMiddleware: Middleware {
    public let id: String = "DeletePermissionSetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeletePermissionSetInput>,
                  next: H) -> Swift.Result<OperationOutput<DeletePermissionSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeletePermissionSetInput>
    public typealias MOutput = OperationOutput<DeletePermissionSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeletePermissionSetOutputError>
}

public struct DeletePermissionSetInput: Equatable {
    /// <p>The ARN of the SSO instance under which the operation will be executed.
    ///       For more information about ARNs, see <a href="/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource
    /// Names (ARNs) and AWS Service Namespaces</a> in the <i>AWS General Reference</i>.</p>
    public let instanceArn: String?
    /// <p>The ARN of the permission set that should be deleted.</p>
    public let permissionSetArn: String?

    public init (
        instanceArn: String? = nil,
        permissionSetArn: String? = nil
    )
    {
        self.instanceArn = instanceArn
        self.permissionSetArn = permissionSetArn
    }
}

struct DeletePermissionSetInputBody: Equatable {
    public let instanceArn: String?
    public let permissionSetArn: String?
}

extension DeletePermissionSetInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case instanceArn = "InstanceArn"
        case permissionSetArn = "PermissionSetArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let permissionSetArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .permissionSetArn)
        permissionSetArn = permissionSetArnDecoded
    }
}

extension DeletePermissionSetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeletePermissionSetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeletePermissionSetOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeletePermissionSetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeletePermissionSetOutputResponse()"}
}

extension DeletePermissionSetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeletePermissionSetOutputResponse: Equatable {

    public init() {}
}

struct DeletePermissionSetOutputResponseBody: Equatable {
}

extension DeletePermissionSetOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DescribeAccountAssignmentCreationStatusInputBodyMiddleware: Middleware {
    public let id: String = "DescribeAccountAssignmentCreationStatusInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAccountAssignmentCreationStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAccountAssignmentCreationStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAccountAssignmentCreationStatusInput>
    public typealias MOutput = OperationOutput<DescribeAccountAssignmentCreationStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAccountAssignmentCreationStatusOutputError>
}

extension DescribeAccountAssignmentCreationStatusInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAccountAssignmentCreationStatusInput(accountAssignmentCreationRequestId: \(String(describing: accountAssignmentCreationRequestId)), instanceArn: \(String(describing: instanceArn)))"}
}

extension DescribeAccountAssignmentCreationStatusInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountAssignmentCreationRequestId = "AccountAssignmentCreationRequestId"
        case instanceArn = "InstanceArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountAssignmentCreationRequestId = accountAssignmentCreationRequestId {
            try encodeContainer.encode(accountAssignmentCreationRequestId, forKey: .accountAssignmentCreationRequestId)
        }
        if let instanceArn = instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
    }
}

public struct DescribeAccountAssignmentCreationStatusInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeAccountAssignmentCreationStatusInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAccountAssignmentCreationStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAccountAssignmentCreationStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAccountAssignmentCreationStatusInput>
    public typealias MOutput = OperationOutput<DescribeAccountAssignmentCreationStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAccountAssignmentCreationStatusOutputError>
}

public struct DescribeAccountAssignmentCreationStatusInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeAccountAssignmentCreationStatusInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAccountAssignmentCreationStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAccountAssignmentCreationStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAccountAssignmentCreationStatusInput>
    public typealias MOutput = OperationOutput<DescribeAccountAssignmentCreationStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAccountAssignmentCreationStatusOutputError>
}

public struct DescribeAccountAssignmentCreationStatusInput: Equatable {
    /// <p>The identifier that is used to track the request operation progress.</p>
    public let accountAssignmentCreationRequestId: String?
    /// <p>The ARN of the SSO instance under which the operation will be executed.
    ///       For more information about ARNs, see <a href="/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource
    /// Names (ARNs) and AWS Service Namespaces</a> in the <i>AWS General Reference</i>.</p>
    public let instanceArn: String?

    public init (
        accountAssignmentCreationRequestId: String? = nil,
        instanceArn: String? = nil
    )
    {
        self.accountAssignmentCreationRequestId = accountAssignmentCreationRequestId
        self.instanceArn = instanceArn
    }
}

struct DescribeAccountAssignmentCreationStatusInputBody: Equatable {
    public let instanceArn: String?
    public let accountAssignmentCreationRequestId: String?
}

extension DescribeAccountAssignmentCreationStatusInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accountAssignmentCreationRequestId = "AccountAssignmentCreationRequestId"
        case instanceArn = "InstanceArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let accountAssignmentCreationRequestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountAssignmentCreationRequestId)
        accountAssignmentCreationRequestId = accountAssignmentCreationRequestIdDecoded
    }
}

extension DescribeAccountAssignmentCreationStatusOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAccountAssignmentCreationStatusOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAccountAssignmentCreationStatusOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAccountAssignmentCreationStatusOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAccountAssignmentCreationStatusOutputResponse(accountAssignmentCreationStatus: \(String(describing: accountAssignmentCreationStatus)))"}
}

extension DescribeAccountAssignmentCreationStatusOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeAccountAssignmentCreationStatusOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.accountAssignmentCreationStatus = output.accountAssignmentCreationStatus
        } else {
            self.accountAssignmentCreationStatus = nil
        }
    }
}

public struct DescribeAccountAssignmentCreationStatusOutputResponse: Equatable {
    /// <p>The status object for the account assignment creation operation.</p>
    public let accountAssignmentCreationStatus: AccountAssignmentOperationStatus?

    public init (
        accountAssignmentCreationStatus: AccountAssignmentOperationStatus? = nil
    )
    {
        self.accountAssignmentCreationStatus = accountAssignmentCreationStatus
    }
}

struct DescribeAccountAssignmentCreationStatusOutputResponseBody: Equatable {
    public let accountAssignmentCreationStatus: AccountAssignmentOperationStatus?
}

extension DescribeAccountAssignmentCreationStatusOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accountAssignmentCreationStatus = "AccountAssignmentCreationStatus"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountAssignmentCreationStatusDecoded = try containerValues.decodeIfPresent(AccountAssignmentOperationStatus.self, forKey: .accountAssignmentCreationStatus)
        accountAssignmentCreationStatus = accountAssignmentCreationStatusDecoded
    }
}

public struct DescribeAccountAssignmentDeletionStatusInputBodyMiddleware: Middleware {
    public let id: String = "DescribeAccountAssignmentDeletionStatusInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAccountAssignmentDeletionStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAccountAssignmentDeletionStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAccountAssignmentDeletionStatusInput>
    public typealias MOutput = OperationOutput<DescribeAccountAssignmentDeletionStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAccountAssignmentDeletionStatusOutputError>
}

extension DescribeAccountAssignmentDeletionStatusInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAccountAssignmentDeletionStatusInput(accountAssignmentDeletionRequestId: \(String(describing: accountAssignmentDeletionRequestId)), instanceArn: \(String(describing: instanceArn)))"}
}

extension DescribeAccountAssignmentDeletionStatusInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountAssignmentDeletionRequestId = "AccountAssignmentDeletionRequestId"
        case instanceArn = "InstanceArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountAssignmentDeletionRequestId = accountAssignmentDeletionRequestId {
            try encodeContainer.encode(accountAssignmentDeletionRequestId, forKey: .accountAssignmentDeletionRequestId)
        }
        if let instanceArn = instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
    }
}

public struct DescribeAccountAssignmentDeletionStatusInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeAccountAssignmentDeletionStatusInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAccountAssignmentDeletionStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAccountAssignmentDeletionStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAccountAssignmentDeletionStatusInput>
    public typealias MOutput = OperationOutput<DescribeAccountAssignmentDeletionStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAccountAssignmentDeletionStatusOutputError>
}

public struct DescribeAccountAssignmentDeletionStatusInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeAccountAssignmentDeletionStatusInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAccountAssignmentDeletionStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAccountAssignmentDeletionStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAccountAssignmentDeletionStatusInput>
    public typealias MOutput = OperationOutput<DescribeAccountAssignmentDeletionStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAccountAssignmentDeletionStatusOutputError>
}

public struct DescribeAccountAssignmentDeletionStatusInput: Equatable {
    /// <p>The identifier that is used to track the request operation progress.</p>
    public let accountAssignmentDeletionRequestId: String?
    /// <p>The ARN of the SSO instance under which the operation will be executed.
    ///       For more information about ARNs, see <a href="/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource
    /// Names (ARNs) and AWS Service Namespaces</a> in the <i>AWS General Reference</i>.</p>
    public let instanceArn: String?

    public init (
        accountAssignmentDeletionRequestId: String? = nil,
        instanceArn: String? = nil
    )
    {
        self.accountAssignmentDeletionRequestId = accountAssignmentDeletionRequestId
        self.instanceArn = instanceArn
    }
}

struct DescribeAccountAssignmentDeletionStatusInputBody: Equatable {
    public let instanceArn: String?
    public let accountAssignmentDeletionRequestId: String?
}

extension DescribeAccountAssignmentDeletionStatusInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accountAssignmentDeletionRequestId = "AccountAssignmentDeletionRequestId"
        case instanceArn = "InstanceArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let accountAssignmentDeletionRequestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountAssignmentDeletionRequestId)
        accountAssignmentDeletionRequestId = accountAssignmentDeletionRequestIdDecoded
    }
}

extension DescribeAccountAssignmentDeletionStatusOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAccountAssignmentDeletionStatusOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAccountAssignmentDeletionStatusOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAccountAssignmentDeletionStatusOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAccountAssignmentDeletionStatusOutputResponse(accountAssignmentDeletionStatus: \(String(describing: accountAssignmentDeletionStatus)))"}
}

extension DescribeAccountAssignmentDeletionStatusOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeAccountAssignmentDeletionStatusOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.accountAssignmentDeletionStatus = output.accountAssignmentDeletionStatus
        } else {
            self.accountAssignmentDeletionStatus = nil
        }
    }
}

public struct DescribeAccountAssignmentDeletionStatusOutputResponse: Equatable {
    /// <p>The status object for the account assignment deletion operation.</p>
    public let accountAssignmentDeletionStatus: AccountAssignmentOperationStatus?

    public init (
        accountAssignmentDeletionStatus: AccountAssignmentOperationStatus? = nil
    )
    {
        self.accountAssignmentDeletionStatus = accountAssignmentDeletionStatus
    }
}

struct DescribeAccountAssignmentDeletionStatusOutputResponseBody: Equatable {
    public let accountAssignmentDeletionStatus: AccountAssignmentOperationStatus?
}

extension DescribeAccountAssignmentDeletionStatusOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accountAssignmentDeletionStatus = "AccountAssignmentDeletionStatus"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountAssignmentDeletionStatusDecoded = try containerValues.decodeIfPresent(AccountAssignmentOperationStatus.self, forKey: .accountAssignmentDeletionStatus)
        accountAssignmentDeletionStatus = accountAssignmentDeletionStatusDecoded
    }
}

public struct DescribeInstanceAccessControlAttributeConfigurationInputBodyMiddleware: Middleware {
    public let id: String = "DescribeInstanceAccessControlAttributeConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeInstanceAccessControlAttributeConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeInstanceAccessControlAttributeConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeInstanceAccessControlAttributeConfigurationInput>
    public typealias MOutput = OperationOutput<DescribeInstanceAccessControlAttributeConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeInstanceAccessControlAttributeConfigurationOutputError>
}

extension DescribeInstanceAccessControlAttributeConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeInstanceAccessControlAttributeConfigurationInput(instanceArn: \(String(describing: instanceArn)))"}
}

extension DescribeInstanceAccessControlAttributeConfigurationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case instanceArn = "InstanceArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceArn = instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
    }
}

public struct DescribeInstanceAccessControlAttributeConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeInstanceAccessControlAttributeConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeInstanceAccessControlAttributeConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeInstanceAccessControlAttributeConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeInstanceAccessControlAttributeConfigurationInput>
    public typealias MOutput = OperationOutput<DescribeInstanceAccessControlAttributeConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeInstanceAccessControlAttributeConfigurationOutputError>
}

public struct DescribeInstanceAccessControlAttributeConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeInstanceAccessControlAttributeConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeInstanceAccessControlAttributeConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeInstanceAccessControlAttributeConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeInstanceAccessControlAttributeConfigurationInput>
    public typealias MOutput = OperationOutput<DescribeInstanceAccessControlAttributeConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeInstanceAccessControlAttributeConfigurationOutputError>
}

public struct DescribeInstanceAccessControlAttributeConfigurationInput: Equatable {
    /// <p>The ARN of the SSO instance under which the operation will be executed.</p>
    public let instanceArn: String?

    public init (
        instanceArn: String? = nil
    )
    {
        self.instanceArn = instanceArn
    }
}

struct DescribeInstanceAccessControlAttributeConfigurationInputBody: Equatable {
    public let instanceArn: String?
}

extension DescribeInstanceAccessControlAttributeConfigurationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case instanceArn = "InstanceArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
    }
}

extension DescribeInstanceAccessControlAttributeConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeInstanceAccessControlAttributeConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeInstanceAccessControlAttributeConfigurationOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeInstanceAccessControlAttributeConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeInstanceAccessControlAttributeConfigurationOutputResponse(instanceAccessControlAttributeConfiguration: \(String(describing: instanceAccessControlAttributeConfiguration)), status: \(String(describing: status)), statusReason: \(String(describing: statusReason)))"}
}

extension DescribeInstanceAccessControlAttributeConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeInstanceAccessControlAttributeConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.instanceAccessControlAttributeConfiguration = output.instanceAccessControlAttributeConfiguration
            self.status = output.status
            self.statusReason = output.statusReason
        } else {
            self.instanceAccessControlAttributeConfiguration = nil
            self.status = nil
            self.statusReason = nil
        }
    }
}

public struct DescribeInstanceAccessControlAttributeConfigurationOutputResponse: Equatable {
    /// <p>Gets the list of AWS SSO identity store attributes added to your ABAC configuration.</p>
    public let instanceAccessControlAttributeConfiguration: InstanceAccessControlAttributeConfiguration?
    /// <p>The status of the attribute configuration process.</p>
    public let status: InstanceAccessControlAttributeConfigurationStatus?
    /// <p>Provides more details about the current status of the specified attribute.</p>
    public let statusReason: String?

    public init (
        instanceAccessControlAttributeConfiguration: InstanceAccessControlAttributeConfiguration? = nil,
        status: InstanceAccessControlAttributeConfigurationStatus? = nil,
        statusReason: String? = nil
    )
    {
        self.instanceAccessControlAttributeConfiguration = instanceAccessControlAttributeConfiguration
        self.status = status
        self.statusReason = statusReason
    }
}

struct DescribeInstanceAccessControlAttributeConfigurationOutputResponseBody: Equatable {
    public let status: InstanceAccessControlAttributeConfigurationStatus?
    public let statusReason: String?
    public let instanceAccessControlAttributeConfiguration: InstanceAccessControlAttributeConfiguration?
}

extension DescribeInstanceAccessControlAttributeConfigurationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case instanceAccessControlAttributeConfiguration = "InstanceAccessControlAttributeConfiguration"
        case status = "Status"
        case statusReason = "StatusReason"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(InstanceAccessControlAttributeConfigurationStatus.self, forKey: .status)
        status = statusDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
        let instanceAccessControlAttributeConfigurationDecoded = try containerValues.decodeIfPresent(InstanceAccessControlAttributeConfiguration.self, forKey: .instanceAccessControlAttributeConfiguration)
        instanceAccessControlAttributeConfiguration = instanceAccessControlAttributeConfigurationDecoded
    }
}

public struct DescribePermissionSetInputBodyMiddleware: Middleware {
    public let id: String = "DescribePermissionSetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribePermissionSetInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribePermissionSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribePermissionSetInput>
    public typealias MOutput = OperationOutput<DescribePermissionSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribePermissionSetOutputError>
}

extension DescribePermissionSetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribePermissionSetInput(instanceArn: \(String(describing: instanceArn)), permissionSetArn: \(String(describing: permissionSetArn)))"}
}

extension DescribePermissionSetInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case instanceArn = "InstanceArn"
        case permissionSetArn = "PermissionSetArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceArn = instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
        if let permissionSetArn = permissionSetArn {
            try encodeContainer.encode(permissionSetArn, forKey: .permissionSetArn)
        }
    }
}

public struct DescribePermissionSetInputHeadersMiddleware: Middleware {
    public let id: String = "DescribePermissionSetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribePermissionSetInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribePermissionSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribePermissionSetInput>
    public typealias MOutput = OperationOutput<DescribePermissionSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribePermissionSetOutputError>
}

public struct DescribePermissionSetInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribePermissionSetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribePermissionSetInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribePermissionSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribePermissionSetInput>
    public typealias MOutput = OperationOutput<DescribePermissionSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribePermissionSetOutputError>
}

public struct DescribePermissionSetInput: Equatable {
    /// <p>The ARN of the SSO instance under which the operation will be executed.
    ///       For more information about ARNs, see <a href="/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource
    /// Names (ARNs) and AWS Service Namespaces</a> in the <i>AWS General Reference</i>.</p>
    public let instanceArn: String?
    /// <p>The ARN of the permission set.</p>
    public let permissionSetArn: String?

    public init (
        instanceArn: String? = nil,
        permissionSetArn: String? = nil
    )
    {
        self.instanceArn = instanceArn
        self.permissionSetArn = permissionSetArn
    }
}

struct DescribePermissionSetInputBody: Equatable {
    public let instanceArn: String?
    public let permissionSetArn: String?
}

extension DescribePermissionSetInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case instanceArn = "InstanceArn"
        case permissionSetArn = "PermissionSetArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let permissionSetArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .permissionSetArn)
        permissionSetArn = permissionSetArnDecoded
    }
}

extension DescribePermissionSetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribePermissionSetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribePermissionSetOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribePermissionSetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribePermissionSetOutputResponse(permissionSet: \(String(describing: permissionSet)))"}
}

extension DescribePermissionSetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribePermissionSetOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.permissionSet = output.permissionSet
        } else {
            self.permissionSet = nil
        }
    }
}

public struct DescribePermissionSetOutputResponse: Equatable {
    /// <p>Describes the level of access on an AWS account.</p>
    public let permissionSet: PermissionSet?

    public init (
        permissionSet: PermissionSet? = nil
    )
    {
        self.permissionSet = permissionSet
    }
}

struct DescribePermissionSetOutputResponseBody: Equatable {
    public let permissionSet: PermissionSet?
}

extension DescribePermissionSetOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case permissionSet = "PermissionSet"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let permissionSetDecoded = try containerValues.decodeIfPresent(PermissionSet.self, forKey: .permissionSet)
        permissionSet = permissionSetDecoded
    }
}

public struct DescribePermissionSetProvisioningStatusInputBodyMiddleware: Middleware {
    public let id: String = "DescribePermissionSetProvisioningStatusInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribePermissionSetProvisioningStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribePermissionSetProvisioningStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribePermissionSetProvisioningStatusInput>
    public typealias MOutput = OperationOutput<DescribePermissionSetProvisioningStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribePermissionSetProvisioningStatusOutputError>
}

extension DescribePermissionSetProvisioningStatusInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribePermissionSetProvisioningStatusInput(instanceArn: \(String(describing: instanceArn)), provisionPermissionSetRequestId: \(String(describing: provisionPermissionSetRequestId)))"}
}

extension DescribePermissionSetProvisioningStatusInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case instanceArn = "InstanceArn"
        case provisionPermissionSetRequestId = "ProvisionPermissionSetRequestId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceArn = instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
        if let provisionPermissionSetRequestId = provisionPermissionSetRequestId {
            try encodeContainer.encode(provisionPermissionSetRequestId, forKey: .provisionPermissionSetRequestId)
        }
    }
}

public struct DescribePermissionSetProvisioningStatusInputHeadersMiddleware: Middleware {
    public let id: String = "DescribePermissionSetProvisioningStatusInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribePermissionSetProvisioningStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribePermissionSetProvisioningStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribePermissionSetProvisioningStatusInput>
    public typealias MOutput = OperationOutput<DescribePermissionSetProvisioningStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribePermissionSetProvisioningStatusOutputError>
}

public struct DescribePermissionSetProvisioningStatusInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribePermissionSetProvisioningStatusInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribePermissionSetProvisioningStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribePermissionSetProvisioningStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribePermissionSetProvisioningStatusInput>
    public typealias MOutput = OperationOutput<DescribePermissionSetProvisioningStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribePermissionSetProvisioningStatusOutputError>
}

public struct DescribePermissionSetProvisioningStatusInput: Equatable {
    /// <p>The ARN of the SSO instance under which the operation will be executed.
    ///       For more information about ARNs, see <a href="/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource
    /// Names (ARNs) and AWS Service Namespaces</a> in the <i>AWS General Reference</i>.</p>
    public let instanceArn: String?
    /// <p>The identifier that is provided by the <a>ProvisionPermissionSet</a> call to
    ///        retrieve the current status of the provisioning workflow.</p>
    public let provisionPermissionSetRequestId: String?

    public init (
        instanceArn: String? = nil,
        provisionPermissionSetRequestId: String? = nil
    )
    {
        self.instanceArn = instanceArn
        self.provisionPermissionSetRequestId = provisionPermissionSetRequestId
    }
}

struct DescribePermissionSetProvisioningStatusInputBody: Equatable {
    public let instanceArn: String?
    public let provisionPermissionSetRequestId: String?
}

extension DescribePermissionSetProvisioningStatusInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case instanceArn = "InstanceArn"
        case provisionPermissionSetRequestId = "ProvisionPermissionSetRequestId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let provisionPermissionSetRequestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .provisionPermissionSetRequestId)
        provisionPermissionSetRequestId = provisionPermissionSetRequestIdDecoded
    }
}

extension DescribePermissionSetProvisioningStatusOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribePermissionSetProvisioningStatusOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribePermissionSetProvisioningStatusOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribePermissionSetProvisioningStatusOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribePermissionSetProvisioningStatusOutputResponse(permissionSetProvisioningStatus: \(String(describing: permissionSetProvisioningStatus)))"}
}

extension DescribePermissionSetProvisioningStatusOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribePermissionSetProvisioningStatusOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.permissionSetProvisioningStatus = output.permissionSetProvisioningStatus
        } else {
            self.permissionSetProvisioningStatus = nil
        }
    }
}

public struct DescribePermissionSetProvisioningStatusOutputResponse: Equatable {
    /// <p>The status object for the permission set provisioning operation.</p>
    public let permissionSetProvisioningStatus: PermissionSetProvisioningStatus?

    public init (
        permissionSetProvisioningStatus: PermissionSetProvisioningStatus? = nil
    )
    {
        self.permissionSetProvisioningStatus = permissionSetProvisioningStatus
    }
}

struct DescribePermissionSetProvisioningStatusOutputResponseBody: Equatable {
    public let permissionSetProvisioningStatus: PermissionSetProvisioningStatus?
}

extension DescribePermissionSetProvisioningStatusOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case permissionSetProvisioningStatus = "PermissionSetProvisioningStatus"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let permissionSetProvisioningStatusDecoded = try containerValues.decodeIfPresent(PermissionSetProvisioningStatus.self, forKey: .permissionSetProvisioningStatus)
        permissionSetProvisioningStatus = permissionSetProvisioningStatusDecoded
    }
}

public struct DetachManagedPolicyFromPermissionSetInputBodyMiddleware: Middleware {
    public let id: String = "DetachManagedPolicyFromPermissionSetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DetachManagedPolicyFromPermissionSetInput>,
                  next: H) -> Swift.Result<OperationOutput<DetachManagedPolicyFromPermissionSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DetachManagedPolicyFromPermissionSetInput>
    public typealias MOutput = OperationOutput<DetachManagedPolicyFromPermissionSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DetachManagedPolicyFromPermissionSetOutputError>
}

extension DetachManagedPolicyFromPermissionSetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DetachManagedPolicyFromPermissionSetInput(instanceArn: \(String(describing: instanceArn)), managedPolicyArn: \(String(describing: managedPolicyArn)), permissionSetArn: \(String(describing: permissionSetArn)))"}
}

extension DetachManagedPolicyFromPermissionSetInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case instanceArn = "InstanceArn"
        case managedPolicyArn = "ManagedPolicyArn"
        case permissionSetArn = "PermissionSetArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceArn = instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
        if let managedPolicyArn = managedPolicyArn {
            try encodeContainer.encode(managedPolicyArn, forKey: .managedPolicyArn)
        }
        if let permissionSetArn = permissionSetArn {
            try encodeContainer.encode(permissionSetArn, forKey: .permissionSetArn)
        }
    }
}

public struct DetachManagedPolicyFromPermissionSetInputHeadersMiddleware: Middleware {
    public let id: String = "DetachManagedPolicyFromPermissionSetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DetachManagedPolicyFromPermissionSetInput>,
                  next: H) -> Swift.Result<OperationOutput<DetachManagedPolicyFromPermissionSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DetachManagedPolicyFromPermissionSetInput>
    public typealias MOutput = OperationOutput<DetachManagedPolicyFromPermissionSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DetachManagedPolicyFromPermissionSetOutputError>
}

public struct DetachManagedPolicyFromPermissionSetInputQueryItemMiddleware: Middleware {
    public let id: String = "DetachManagedPolicyFromPermissionSetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DetachManagedPolicyFromPermissionSetInput>,
                  next: H) -> Swift.Result<OperationOutput<DetachManagedPolicyFromPermissionSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DetachManagedPolicyFromPermissionSetInput>
    public typealias MOutput = OperationOutput<DetachManagedPolicyFromPermissionSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DetachManagedPolicyFromPermissionSetOutputError>
}

public struct DetachManagedPolicyFromPermissionSetInput: Equatable {
    /// <p>The ARN of the SSO instance under which the operation will be executed.
    ///       For more information about ARNs, see <a href="/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource
    /// Names (ARNs) and AWS Service Namespaces</a> in the <i>AWS General Reference</i>.</p>
    public let instanceArn: String?
    /// <p>The IAM managed policy ARN to be attached to a permission set.</p>
    public let managedPolicyArn: String?
    /// <p>The ARN of the <a>PermissionSet</a> from which the policy should be detached.</p>
    public let permissionSetArn: String?

    public init (
        instanceArn: String? = nil,
        managedPolicyArn: String? = nil,
        permissionSetArn: String? = nil
    )
    {
        self.instanceArn = instanceArn
        self.managedPolicyArn = managedPolicyArn
        self.permissionSetArn = permissionSetArn
    }
}

struct DetachManagedPolicyFromPermissionSetInputBody: Equatable {
    public let instanceArn: String?
    public let permissionSetArn: String?
    public let managedPolicyArn: String?
}

extension DetachManagedPolicyFromPermissionSetInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case instanceArn = "InstanceArn"
        case managedPolicyArn = "ManagedPolicyArn"
        case permissionSetArn = "PermissionSetArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let permissionSetArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .permissionSetArn)
        permissionSetArn = permissionSetArnDecoded
        let managedPolicyArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .managedPolicyArn)
        managedPolicyArn = managedPolicyArnDecoded
    }
}

extension DetachManagedPolicyFromPermissionSetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DetachManagedPolicyFromPermissionSetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DetachManagedPolicyFromPermissionSetOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DetachManagedPolicyFromPermissionSetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DetachManagedPolicyFromPermissionSetOutputResponse()"}
}

extension DetachManagedPolicyFromPermissionSetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DetachManagedPolicyFromPermissionSetOutputResponse: Equatable {

    public init() {}
}

struct DetachManagedPolicyFromPermissionSetOutputResponseBody: Equatable {
}

extension DetachManagedPolicyFromPermissionSetOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct GetInlinePolicyForPermissionSetInputBodyMiddleware: Middleware {
    public let id: String = "GetInlinePolicyForPermissionSetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetInlinePolicyForPermissionSetInput>,
                  next: H) -> Swift.Result<OperationOutput<GetInlinePolicyForPermissionSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetInlinePolicyForPermissionSetInput>
    public typealias MOutput = OperationOutput<GetInlinePolicyForPermissionSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetInlinePolicyForPermissionSetOutputError>
}

extension GetInlinePolicyForPermissionSetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetInlinePolicyForPermissionSetInput(instanceArn: \(String(describing: instanceArn)), permissionSetArn: \(String(describing: permissionSetArn)))"}
}

extension GetInlinePolicyForPermissionSetInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case instanceArn = "InstanceArn"
        case permissionSetArn = "PermissionSetArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceArn = instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
        if let permissionSetArn = permissionSetArn {
            try encodeContainer.encode(permissionSetArn, forKey: .permissionSetArn)
        }
    }
}

public struct GetInlinePolicyForPermissionSetInputHeadersMiddleware: Middleware {
    public let id: String = "GetInlinePolicyForPermissionSetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetInlinePolicyForPermissionSetInput>,
                  next: H) -> Swift.Result<OperationOutput<GetInlinePolicyForPermissionSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetInlinePolicyForPermissionSetInput>
    public typealias MOutput = OperationOutput<GetInlinePolicyForPermissionSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetInlinePolicyForPermissionSetOutputError>
}

public struct GetInlinePolicyForPermissionSetInputQueryItemMiddleware: Middleware {
    public let id: String = "GetInlinePolicyForPermissionSetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetInlinePolicyForPermissionSetInput>,
                  next: H) -> Swift.Result<OperationOutput<GetInlinePolicyForPermissionSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetInlinePolicyForPermissionSetInput>
    public typealias MOutput = OperationOutput<GetInlinePolicyForPermissionSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetInlinePolicyForPermissionSetOutputError>
}

public struct GetInlinePolicyForPermissionSetInput: Equatable {
    /// <p>The ARN of the SSO instance under which the operation will be executed.
    ///       For more information about ARNs, see <a href="/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource
    /// Names (ARNs) and AWS Service Namespaces</a> in the <i>AWS General Reference</i>.</p>
    public let instanceArn: String?
    /// <p>The ARN of the permission set.</p>
    public let permissionSetArn: String?

    public init (
        instanceArn: String? = nil,
        permissionSetArn: String? = nil
    )
    {
        self.instanceArn = instanceArn
        self.permissionSetArn = permissionSetArn
    }
}

struct GetInlinePolicyForPermissionSetInputBody: Equatable {
    public let instanceArn: String?
    public let permissionSetArn: String?
}

extension GetInlinePolicyForPermissionSetInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case instanceArn = "InstanceArn"
        case permissionSetArn = "PermissionSetArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let permissionSetArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .permissionSetArn)
        permissionSetArn = permissionSetArnDecoded
    }
}

extension GetInlinePolicyForPermissionSetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetInlinePolicyForPermissionSetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetInlinePolicyForPermissionSetOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetInlinePolicyForPermissionSetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetInlinePolicyForPermissionSetOutputResponse(inlinePolicy: \(String(describing: inlinePolicy)))"}
}

extension GetInlinePolicyForPermissionSetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetInlinePolicyForPermissionSetOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.inlinePolicy = output.inlinePolicy
        } else {
            self.inlinePolicy = nil
        }
    }
}

public struct GetInlinePolicyForPermissionSetOutputResponse: Equatable {
    /// <p>The IAM inline policy that is attached to the permission set.</p>
    public let inlinePolicy: String?

    public init (
        inlinePolicy: String? = nil
    )
    {
        self.inlinePolicy = inlinePolicy
    }
}

struct GetInlinePolicyForPermissionSetOutputResponseBody: Equatable {
    public let inlinePolicy: String?
}

extension GetInlinePolicyForPermissionSetOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case inlinePolicy = "InlinePolicy"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inlinePolicyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .inlinePolicy)
        inlinePolicy = inlinePolicyDecoded
    }
}

extension InstanceAccessControlAttributeConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accessControlAttributes = "AccessControlAttributes"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessControlAttributes = accessControlAttributes {
            var accessControlAttributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accessControlAttributes)
            for accesscontrolattributelist0 in accessControlAttributes {
                try accessControlAttributesContainer.encode(accesscontrolattributelist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessControlAttributesContainer = try containerValues.decodeIfPresent([AccessControlAttribute?].self, forKey: .accessControlAttributes)
        var accessControlAttributesDecoded0:[AccessControlAttribute]? = nil
        if let accessControlAttributesContainer = accessControlAttributesContainer {
            accessControlAttributesDecoded0 = [AccessControlAttribute]()
            for structure0 in accessControlAttributesContainer {
                if let structure0 = structure0 {
                    accessControlAttributesDecoded0?.append(structure0)
                }
            }
        }
        accessControlAttributes = accessControlAttributesDecoded0
    }
}

extension InstanceAccessControlAttributeConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InstanceAccessControlAttributeConfiguration(accessControlAttributes: \(String(describing: accessControlAttributes)))"}
}

/// <p>Specifies the attributes to add to your attribute-based access control (ABAC) configuration.</p>
public struct InstanceAccessControlAttributeConfiguration: Equatable {
    /// <p>Lists the attributes that are configured for ABAC in the specified AWS SSO instance.</p>
    public let accessControlAttributes: [AccessControlAttribute]?

    public init (
        accessControlAttributes: [AccessControlAttribute]? = nil
    )
    {
        self.accessControlAttributes = accessControlAttributes
    }
}

public enum InstanceAccessControlAttributeConfigurationStatus {
    case creationFailed
    case creationInProgress
    case enabled
    case sdkUnknown(String)
}

extension InstanceAccessControlAttributeConfigurationStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [InstanceAccessControlAttributeConfigurationStatus] {
        return [
            .creationFailed,
            .creationInProgress,
            .enabled,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .creationFailed: return "CREATION_FAILED"
        case .creationInProgress: return "CREATION_IN_PROGRESS"
        case .enabled: return "ENABLED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = InstanceAccessControlAttributeConfigurationStatus(rawValue: rawValue) ?? InstanceAccessControlAttributeConfigurationStatus.sdkUnknown(rawValue)
    }
}

extension InstanceMetadata: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case identityStoreId = "IdentityStoreId"
        case instanceArn = "InstanceArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identityStoreId = identityStoreId {
            try encodeContainer.encode(identityStoreId, forKey: .identityStoreId)
        }
        if let instanceArn = instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let identityStoreIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .identityStoreId)
        identityStoreId = identityStoreIdDecoded
    }
}

extension InstanceMetadata: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InstanceMetadata(identityStoreId: \(String(describing: identityStoreId)), instanceArn: \(String(describing: instanceArn)))"}
}

/// <p>Provides information about the SSO instance.</p>
public struct InstanceMetadata: Equatable {
    /// <p>The identifier of the identity store that is connected to the SSO instance.</p>
    public let identityStoreId: String?
    /// <p>The ARN of the SSO instance under which the operation will be executed.
    ///       For more information about ARNs, see <a href="/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource
    /// Names (ARNs) and AWS Service Namespaces</a> in the <i>AWS General Reference</i>.</p>
    public let instanceArn: String?

    public init (
        identityStoreId: String? = nil,
        instanceArn: String? = nil
    )
    {
        self.identityStoreId = identityStoreId
        self.instanceArn = instanceArn
    }
}

extension InternalServerException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalServerException(message: \(String(describing: message)))"}
}

extension InternalServerException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request processing has failed because of an unknown error, exception, or failure with
///       an internal server.</p>
public struct InternalServerException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Equatable {
    public let message: String?
}

extension InternalServerExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ListAccountAssignmentCreationStatusInputBodyMiddleware: Middleware {
    public let id: String = "ListAccountAssignmentCreationStatusInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAccountAssignmentCreationStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAccountAssignmentCreationStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAccountAssignmentCreationStatusInput>
    public typealias MOutput = OperationOutput<ListAccountAssignmentCreationStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAccountAssignmentCreationStatusOutputError>
}

extension ListAccountAssignmentCreationStatusInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAccountAssignmentCreationStatusInput(filter: \(String(describing: filter)), instanceArn: \(String(describing: instanceArn)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListAccountAssignmentCreationStatusInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filter = "Filter"
        case instanceArn = "InstanceArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let instanceArn = instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListAccountAssignmentCreationStatusInputHeadersMiddleware: Middleware {
    public let id: String = "ListAccountAssignmentCreationStatusInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAccountAssignmentCreationStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAccountAssignmentCreationStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAccountAssignmentCreationStatusInput>
    public typealias MOutput = OperationOutput<ListAccountAssignmentCreationStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAccountAssignmentCreationStatusOutputError>
}

public struct ListAccountAssignmentCreationStatusInputQueryItemMiddleware: Middleware {
    public let id: String = "ListAccountAssignmentCreationStatusInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAccountAssignmentCreationStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAccountAssignmentCreationStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAccountAssignmentCreationStatusInput>
    public typealias MOutput = OperationOutput<ListAccountAssignmentCreationStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAccountAssignmentCreationStatusOutputError>
}

public struct ListAccountAssignmentCreationStatusInput: Equatable {
    /// <p>Filters results based on the passed attribute value.</p>
    public let filter: OperationStatusFilter?
    /// <p>The ARN of the SSO instance under which the operation will be executed.
    ///       For more information about ARNs, see <a href="/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource
    /// Names (ARNs) and AWS Service Namespaces</a> in the <i>AWS General Reference</i>.</p>
    public let instanceArn: String?
    /// <p>The maximum number of results to display for the assignment.</p>
    public let maxResults: Int?
    /// <p>The pagination token for the list API. Initially the value is null. Use the output of previous API calls to make subsequent calls.</p>
    public let nextToken: String?

    public init (
        filter: OperationStatusFilter? = nil,
        instanceArn: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.filter = filter
        self.instanceArn = instanceArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAccountAssignmentCreationStatusInputBody: Equatable {
    public let instanceArn: String?
    public let maxResults: Int?
    public let nextToken: String?
    public let filter: OperationStatusFilter?
}

extension ListAccountAssignmentCreationStatusInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filter = "Filter"
        case instanceArn = "InstanceArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let filterDecoded = try containerValues.decodeIfPresent(OperationStatusFilter.self, forKey: .filter)
        filter = filterDecoded
    }
}

extension ListAccountAssignmentCreationStatusOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAccountAssignmentCreationStatusOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAccountAssignmentCreationStatusOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAccountAssignmentCreationStatusOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAccountAssignmentCreationStatusOutputResponse(accountAssignmentsCreationStatus: \(String(describing: accountAssignmentsCreationStatus)), nextToken: \(String(describing: nextToken)))"}
}

extension ListAccountAssignmentCreationStatusOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListAccountAssignmentCreationStatusOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.accountAssignmentsCreationStatus = output.accountAssignmentsCreationStatus
            self.nextToken = output.nextToken
        } else {
            self.accountAssignmentsCreationStatus = nil
            self.nextToken = nil
        }
    }
}

public struct ListAccountAssignmentCreationStatusOutputResponse: Equatable {
    /// <p>The status object for the account assignment creation operation.</p>
    public let accountAssignmentsCreationStatus: [AccountAssignmentOperationStatusMetadata]?
    /// <p>The pagination token for the list API. Initially the value is null. Use the output of previous API calls to make subsequent calls.</p>
    public let nextToken: String?

    public init (
        accountAssignmentsCreationStatus: [AccountAssignmentOperationStatusMetadata]? = nil,
        nextToken: String? = nil
    )
    {
        self.accountAssignmentsCreationStatus = accountAssignmentsCreationStatus
        self.nextToken = nextToken
    }
}

struct ListAccountAssignmentCreationStatusOutputResponseBody: Equatable {
    public let accountAssignmentsCreationStatus: [AccountAssignmentOperationStatusMetadata]?
    public let nextToken: String?
}

extension ListAccountAssignmentCreationStatusOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accountAssignmentsCreationStatus = "AccountAssignmentsCreationStatus"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountAssignmentsCreationStatusContainer = try containerValues.decodeIfPresent([AccountAssignmentOperationStatusMetadata?].self, forKey: .accountAssignmentsCreationStatus)
        var accountAssignmentsCreationStatusDecoded0:[AccountAssignmentOperationStatusMetadata]? = nil
        if let accountAssignmentsCreationStatusContainer = accountAssignmentsCreationStatusContainer {
            accountAssignmentsCreationStatusDecoded0 = [AccountAssignmentOperationStatusMetadata]()
            for structure0 in accountAssignmentsCreationStatusContainer {
                if let structure0 = structure0 {
                    accountAssignmentsCreationStatusDecoded0?.append(structure0)
                }
            }
        }
        accountAssignmentsCreationStatus = accountAssignmentsCreationStatusDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListAccountAssignmentDeletionStatusInputBodyMiddleware: Middleware {
    public let id: String = "ListAccountAssignmentDeletionStatusInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAccountAssignmentDeletionStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAccountAssignmentDeletionStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAccountAssignmentDeletionStatusInput>
    public typealias MOutput = OperationOutput<ListAccountAssignmentDeletionStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAccountAssignmentDeletionStatusOutputError>
}

extension ListAccountAssignmentDeletionStatusInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAccountAssignmentDeletionStatusInput(filter: \(String(describing: filter)), instanceArn: \(String(describing: instanceArn)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListAccountAssignmentDeletionStatusInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filter = "Filter"
        case instanceArn = "InstanceArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let instanceArn = instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListAccountAssignmentDeletionStatusInputHeadersMiddleware: Middleware {
    public let id: String = "ListAccountAssignmentDeletionStatusInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAccountAssignmentDeletionStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAccountAssignmentDeletionStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAccountAssignmentDeletionStatusInput>
    public typealias MOutput = OperationOutput<ListAccountAssignmentDeletionStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAccountAssignmentDeletionStatusOutputError>
}

public struct ListAccountAssignmentDeletionStatusInputQueryItemMiddleware: Middleware {
    public let id: String = "ListAccountAssignmentDeletionStatusInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAccountAssignmentDeletionStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAccountAssignmentDeletionStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAccountAssignmentDeletionStatusInput>
    public typealias MOutput = OperationOutput<ListAccountAssignmentDeletionStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAccountAssignmentDeletionStatusOutputError>
}

public struct ListAccountAssignmentDeletionStatusInput: Equatable {
    /// <p>Filters results based on the passed attribute value.</p>
    public let filter: OperationStatusFilter?
    /// <p>The ARN of the SSO instance under which the operation will be executed.
    ///       For more information about ARNs, see <a href="/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource
    /// Names (ARNs) and AWS Service Namespaces</a> in the <i>AWS General Reference</i>.</p>
    public let instanceArn: String?
    /// <p>The maximum number of results to display for the assignment.</p>
    public let maxResults: Int?
    /// <p>The pagination token for the list API. Initially the value is null. Use the output of previous API calls to make subsequent calls.</p>
    public let nextToken: String?

    public init (
        filter: OperationStatusFilter? = nil,
        instanceArn: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.filter = filter
        self.instanceArn = instanceArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAccountAssignmentDeletionStatusInputBody: Equatable {
    public let instanceArn: String?
    public let maxResults: Int?
    public let nextToken: String?
    public let filter: OperationStatusFilter?
}

extension ListAccountAssignmentDeletionStatusInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filter = "Filter"
        case instanceArn = "InstanceArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let filterDecoded = try containerValues.decodeIfPresent(OperationStatusFilter.self, forKey: .filter)
        filter = filterDecoded
    }
}

extension ListAccountAssignmentDeletionStatusOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAccountAssignmentDeletionStatusOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAccountAssignmentDeletionStatusOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAccountAssignmentDeletionStatusOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAccountAssignmentDeletionStatusOutputResponse(accountAssignmentsDeletionStatus: \(String(describing: accountAssignmentsDeletionStatus)), nextToken: \(String(describing: nextToken)))"}
}

extension ListAccountAssignmentDeletionStatusOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListAccountAssignmentDeletionStatusOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.accountAssignmentsDeletionStatus = output.accountAssignmentsDeletionStatus
            self.nextToken = output.nextToken
        } else {
            self.accountAssignmentsDeletionStatus = nil
            self.nextToken = nil
        }
    }
}

public struct ListAccountAssignmentDeletionStatusOutputResponse: Equatable {
    /// <p>The status object for the account assignment deletion operation.</p>
    public let accountAssignmentsDeletionStatus: [AccountAssignmentOperationStatusMetadata]?
    /// <p>The pagination token for the list API. Initially the value is null. Use the output of previous API calls to make subsequent calls.</p>
    public let nextToken: String?

    public init (
        accountAssignmentsDeletionStatus: [AccountAssignmentOperationStatusMetadata]? = nil,
        nextToken: String? = nil
    )
    {
        self.accountAssignmentsDeletionStatus = accountAssignmentsDeletionStatus
        self.nextToken = nextToken
    }
}

struct ListAccountAssignmentDeletionStatusOutputResponseBody: Equatable {
    public let accountAssignmentsDeletionStatus: [AccountAssignmentOperationStatusMetadata]?
    public let nextToken: String?
}

extension ListAccountAssignmentDeletionStatusOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accountAssignmentsDeletionStatus = "AccountAssignmentsDeletionStatus"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountAssignmentsDeletionStatusContainer = try containerValues.decodeIfPresent([AccountAssignmentOperationStatusMetadata?].self, forKey: .accountAssignmentsDeletionStatus)
        var accountAssignmentsDeletionStatusDecoded0:[AccountAssignmentOperationStatusMetadata]? = nil
        if let accountAssignmentsDeletionStatusContainer = accountAssignmentsDeletionStatusContainer {
            accountAssignmentsDeletionStatusDecoded0 = [AccountAssignmentOperationStatusMetadata]()
            for structure0 in accountAssignmentsDeletionStatusContainer {
                if let structure0 = structure0 {
                    accountAssignmentsDeletionStatusDecoded0?.append(structure0)
                }
            }
        }
        accountAssignmentsDeletionStatus = accountAssignmentsDeletionStatusDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListAccountAssignmentsInputBodyMiddleware: Middleware {
    public let id: String = "ListAccountAssignmentsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAccountAssignmentsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAccountAssignmentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAccountAssignmentsInput>
    public typealias MOutput = OperationOutput<ListAccountAssignmentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAccountAssignmentsOutputError>
}

extension ListAccountAssignmentsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAccountAssignmentsInput(accountId: \(String(describing: accountId)), instanceArn: \(String(describing: instanceArn)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), permissionSetArn: \(String(describing: permissionSetArn)))"}
}

extension ListAccountAssignmentsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountId = "AccountId"
        case instanceArn = "InstanceArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case permissionSetArn = "PermissionSetArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let instanceArn = instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let permissionSetArn = permissionSetArn {
            try encodeContainer.encode(permissionSetArn, forKey: .permissionSetArn)
        }
    }
}

public struct ListAccountAssignmentsInputHeadersMiddleware: Middleware {
    public let id: String = "ListAccountAssignmentsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAccountAssignmentsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAccountAssignmentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAccountAssignmentsInput>
    public typealias MOutput = OperationOutput<ListAccountAssignmentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAccountAssignmentsOutputError>
}

public struct ListAccountAssignmentsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListAccountAssignmentsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAccountAssignmentsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAccountAssignmentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAccountAssignmentsInput>
    public typealias MOutput = OperationOutput<ListAccountAssignmentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAccountAssignmentsOutputError>
}

public struct ListAccountAssignmentsInput: Equatable {
    /// <p>The identifier of the AWS account from which to list the assignments.</p>
    public let accountId: String?
    /// <p>The ARN of the SSO instance under which the operation will be executed.
    ///       For more information about ARNs, see <a href="/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource
    /// Names (ARNs) and AWS Service Namespaces</a> in the <i>AWS General Reference</i>.</p>
    public let instanceArn: String?
    /// <p>The maximum number of results to display for the assignment.</p>
    public let maxResults: Int?
    /// <p>The pagination token for the list API. Initially the value is null. Use the output of previous API calls to make subsequent calls.</p>
    public let nextToken: String?
    /// <p>The ARN of the permission set from which to list assignments.</p>
    public let permissionSetArn: String?

    public init (
        accountId: String? = nil,
        instanceArn: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        permissionSetArn: String? = nil
    )
    {
        self.accountId = accountId
        self.instanceArn = instanceArn
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.permissionSetArn = permissionSetArn
    }
}

struct ListAccountAssignmentsInputBody: Equatable {
    public let instanceArn: String?
    public let accountId: String?
    public let permissionSetArn: String?
    public let maxResults: Int?
    public let nextToken: String?
}

extension ListAccountAssignmentsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accountId = "AccountId"
        case instanceArn = "InstanceArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case permissionSetArn = "PermissionSetArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let permissionSetArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .permissionSetArn)
        permissionSetArn = permissionSetArnDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAccountAssignmentsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAccountAssignmentsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAccountAssignmentsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAccountAssignmentsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAccountAssignmentsOutputResponse(accountAssignments: \(String(describing: accountAssignments)), nextToken: \(String(describing: nextToken)))"}
}

extension ListAccountAssignmentsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListAccountAssignmentsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.accountAssignments = output.accountAssignments
            self.nextToken = output.nextToken
        } else {
            self.accountAssignments = nil
            self.nextToken = nil
        }
    }
}

public struct ListAccountAssignmentsOutputResponse: Equatable {
    /// <p>The list of assignments that match the input AWS account and permission set.</p>
    public let accountAssignments: [AccountAssignment]?
    /// <p>The pagination token for the list API. Initially the value is null. Use the output of previous API calls to make subsequent calls.</p>
    public let nextToken: String?

    public init (
        accountAssignments: [AccountAssignment]? = nil,
        nextToken: String? = nil
    )
    {
        self.accountAssignments = accountAssignments
        self.nextToken = nextToken
    }
}

struct ListAccountAssignmentsOutputResponseBody: Equatable {
    public let accountAssignments: [AccountAssignment]?
    public let nextToken: String?
}

extension ListAccountAssignmentsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accountAssignments = "AccountAssignments"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountAssignmentsContainer = try containerValues.decodeIfPresent([AccountAssignment?].self, forKey: .accountAssignments)
        var accountAssignmentsDecoded0:[AccountAssignment]? = nil
        if let accountAssignmentsContainer = accountAssignmentsContainer {
            accountAssignmentsDecoded0 = [AccountAssignment]()
            for structure0 in accountAssignmentsContainer {
                if let structure0 = structure0 {
                    accountAssignmentsDecoded0?.append(structure0)
                }
            }
        }
        accountAssignments = accountAssignmentsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListAccountsForProvisionedPermissionSetInputBodyMiddleware: Middleware {
    public let id: String = "ListAccountsForProvisionedPermissionSetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAccountsForProvisionedPermissionSetInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAccountsForProvisionedPermissionSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAccountsForProvisionedPermissionSetInput>
    public typealias MOutput = OperationOutput<ListAccountsForProvisionedPermissionSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAccountsForProvisionedPermissionSetOutputError>
}

extension ListAccountsForProvisionedPermissionSetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAccountsForProvisionedPermissionSetInput(instanceArn: \(String(describing: instanceArn)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), permissionSetArn: \(String(describing: permissionSetArn)), provisioningStatus: \(String(describing: provisioningStatus)))"}
}

extension ListAccountsForProvisionedPermissionSetInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case instanceArn = "InstanceArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case permissionSetArn = "PermissionSetArn"
        case provisioningStatus = "ProvisioningStatus"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceArn = instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let permissionSetArn = permissionSetArn {
            try encodeContainer.encode(permissionSetArn, forKey: .permissionSetArn)
        }
        if let provisioningStatus = provisioningStatus {
            try encodeContainer.encode(provisioningStatus.rawValue, forKey: .provisioningStatus)
        }
    }
}

public struct ListAccountsForProvisionedPermissionSetInputHeadersMiddleware: Middleware {
    public let id: String = "ListAccountsForProvisionedPermissionSetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAccountsForProvisionedPermissionSetInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAccountsForProvisionedPermissionSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAccountsForProvisionedPermissionSetInput>
    public typealias MOutput = OperationOutput<ListAccountsForProvisionedPermissionSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAccountsForProvisionedPermissionSetOutputError>
}

public struct ListAccountsForProvisionedPermissionSetInputQueryItemMiddleware: Middleware {
    public let id: String = "ListAccountsForProvisionedPermissionSetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAccountsForProvisionedPermissionSetInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAccountsForProvisionedPermissionSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAccountsForProvisionedPermissionSetInput>
    public typealias MOutput = OperationOutput<ListAccountsForProvisionedPermissionSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAccountsForProvisionedPermissionSetOutputError>
}

public struct ListAccountsForProvisionedPermissionSetInput: Equatable {
    /// <p>The ARN of the SSO instance under which the operation will be executed.
    ///       For more information about ARNs, see <a href="/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource
    /// Names (ARNs) and AWS Service Namespaces</a> in the <i>AWS General Reference</i>.</p>
    public let instanceArn: String?
    /// <p>The maximum number of results to display for the <a>PermissionSet</a>.</p>
    public let maxResults: Int?
    /// <p>The pagination token for the list API. Initially the value is null. Use the output of previous API calls to make subsequent calls.</p>
    public let nextToken: String?
    /// <p>The ARN of the <a>PermissionSet</a> from which the associated AWS accounts
    ///       will be listed.</p>
    public let permissionSetArn: String?
    /// <p>The permission set provisioning status for an AWS account.</p>
    public let provisioningStatus: ProvisioningStatus?

    public init (
        instanceArn: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        permissionSetArn: String? = nil,
        provisioningStatus: ProvisioningStatus? = nil
    )
    {
        self.instanceArn = instanceArn
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.permissionSetArn = permissionSetArn
        self.provisioningStatus = provisioningStatus
    }
}

struct ListAccountsForProvisionedPermissionSetInputBody: Equatable {
    public let instanceArn: String?
    public let permissionSetArn: String?
    public let provisioningStatus: ProvisioningStatus?
    public let maxResults: Int?
    public let nextToken: String?
}

extension ListAccountsForProvisionedPermissionSetInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case instanceArn = "InstanceArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case permissionSetArn = "PermissionSetArn"
        case provisioningStatus = "ProvisioningStatus"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let permissionSetArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .permissionSetArn)
        permissionSetArn = permissionSetArnDecoded
        let provisioningStatusDecoded = try containerValues.decodeIfPresent(ProvisioningStatus.self, forKey: .provisioningStatus)
        provisioningStatus = provisioningStatusDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAccountsForProvisionedPermissionSetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAccountsForProvisionedPermissionSetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAccountsForProvisionedPermissionSetOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAccountsForProvisionedPermissionSetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAccountsForProvisionedPermissionSetOutputResponse(accountIds: \(String(describing: accountIds)), nextToken: \(String(describing: nextToken)))"}
}

extension ListAccountsForProvisionedPermissionSetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListAccountsForProvisionedPermissionSetOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.accountIds = output.accountIds
            self.nextToken = output.nextToken
        } else {
            self.accountIds = nil
            self.nextToken = nil
        }
    }
}

public struct ListAccountsForProvisionedPermissionSetOutputResponse: Equatable {
    /// <p>The list of AWS <code>AccountIds</code>.</p>
    public let accountIds: [String]?
    /// <p>The pagination token for the list API. Initially the value is null. Use the output of previous API calls to make subsequent calls.</p>
    public let nextToken: String?

    public init (
        accountIds: [String]? = nil,
        nextToken: String? = nil
    )
    {
        self.accountIds = accountIds
        self.nextToken = nextToken
    }
}

struct ListAccountsForProvisionedPermissionSetOutputResponseBody: Equatable {
    public let accountIds: [String]?
    public let nextToken: String?
}

extension ListAccountsForProvisionedPermissionSetOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accountIds = "AccountIds"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .accountIds)
        var accountIdsDecoded0:[String]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [String]()
            for string0 in accountIdsContainer {
                if let string0 = string0 {
                    accountIdsDecoded0?.append(string0)
                }
            }
        }
        accountIds = accountIdsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListInstancesInputBodyMiddleware: Middleware {
    public let id: String = "ListInstancesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListInstancesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListInstancesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListInstancesInput>
    public typealias MOutput = OperationOutput<ListInstancesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListInstancesOutputError>
}

extension ListInstancesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListInstancesInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListInstancesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListInstancesInputHeadersMiddleware: Middleware {
    public let id: String = "ListInstancesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListInstancesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListInstancesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListInstancesInput>
    public typealias MOutput = OperationOutput<ListInstancesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListInstancesOutputError>
}

public struct ListInstancesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListInstancesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListInstancesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListInstancesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListInstancesInput>
    public typealias MOutput = OperationOutput<ListInstancesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListInstancesOutputError>
}

public struct ListInstancesInput: Equatable {
    /// <p>The maximum number of results to display for the instance.</p>
    public let maxResults: Int?
    /// <p>The pagination token for the list API. Initially the value is null. Use the output of previous API calls to make subsequent calls.</p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListInstancesInputBody: Equatable {
    public let maxResults: Int?
    public let nextToken: String?
}

extension ListInstancesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListInstancesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListInstancesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListInstancesOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListInstancesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListInstancesOutputResponse(instances: \(String(describing: instances)), nextToken: \(String(describing: nextToken)))"}
}

extension ListInstancesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListInstancesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.instances = output.instances
            self.nextToken = output.nextToken
        } else {
            self.instances = nil
            self.nextToken = nil
        }
    }
}

public struct ListInstancesOutputResponse: Equatable {
    /// <p>Lists the SSO instances that the caller has access to.</p>
    public let instances: [InstanceMetadata]?
    /// <p>The pagination token for the list API. Initially the value is null. Use the output of previous API calls to make subsequent calls.</p>
    public let nextToken: String?

    public init (
        instances: [InstanceMetadata]? = nil,
        nextToken: String? = nil
    )
    {
        self.instances = instances
        self.nextToken = nextToken
    }
}

struct ListInstancesOutputResponseBody: Equatable {
    public let instances: [InstanceMetadata]?
    public let nextToken: String?
}

extension ListInstancesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case instances = "Instances"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instancesContainer = try containerValues.decodeIfPresent([InstanceMetadata?].self, forKey: .instances)
        var instancesDecoded0:[InstanceMetadata]? = nil
        if let instancesContainer = instancesContainer {
            instancesDecoded0 = [InstanceMetadata]()
            for structure0 in instancesContainer {
                if let structure0 = structure0 {
                    instancesDecoded0?.append(structure0)
                }
            }
        }
        instances = instancesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListManagedPoliciesInPermissionSetInputBodyMiddleware: Middleware {
    public let id: String = "ListManagedPoliciesInPermissionSetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListManagedPoliciesInPermissionSetInput>,
                  next: H) -> Swift.Result<OperationOutput<ListManagedPoliciesInPermissionSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListManagedPoliciesInPermissionSetInput>
    public typealias MOutput = OperationOutput<ListManagedPoliciesInPermissionSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListManagedPoliciesInPermissionSetOutputError>
}

extension ListManagedPoliciesInPermissionSetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListManagedPoliciesInPermissionSetInput(instanceArn: \(String(describing: instanceArn)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), permissionSetArn: \(String(describing: permissionSetArn)))"}
}

extension ListManagedPoliciesInPermissionSetInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case instanceArn = "InstanceArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case permissionSetArn = "PermissionSetArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceArn = instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let permissionSetArn = permissionSetArn {
            try encodeContainer.encode(permissionSetArn, forKey: .permissionSetArn)
        }
    }
}

public struct ListManagedPoliciesInPermissionSetInputHeadersMiddleware: Middleware {
    public let id: String = "ListManagedPoliciesInPermissionSetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListManagedPoliciesInPermissionSetInput>,
                  next: H) -> Swift.Result<OperationOutput<ListManagedPoliciesInPermissionSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListManagedPoliciesInPermissionSetInput>
    public typealias MOutput = OperationOutput<ListManagedPoliciesInPermissionSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListManagedPoliciesInPermissionSetOutputError>
}

public struct ListManagedPoliciesInPermissionSetInputQueryItemMiddleware: Middleware {
    public let id: String = "ListManagedPoliciesInPermissionSetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListManagedPoliciesInPermissionSetInput>,
                  next: H) -> Swift.Result<OperationOutput<ListManagedPoliciesInPermissionSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListManagedPoliciesInPermissionSetInput>
    public typealias MOutput = OperationOutput<ListManagedPoliciesInPermissionSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListManagedPoliciesInPermissionSetOutputError>
}

public struct ListManagedPoliciesInPermissionSetInput: Equatable {
    /// <p>The ARN of the SSO instance under which the operation will be executed.
    ///       For more information about ARNs, see <a href="/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource
    /// Names (ARNs) and AWS Service Namespaces</a> in the <i>AWS General Reference</i>.</p>
    public let instanceArn: String?
    /// <p>The maximum number of results to display for the <a>PermissionSet</a>.</p>
    public let maxResults: Int?
    /// <p>The pagination token for the list API. Initially the value is null. Use the output of previous API calls to make subsequent calls.</p>
    public let nextToken: String?
    /// <p>The ARN of the <a>PermissionSet</a> whose managed policies will be listed.</p>
    public let permissionSetArn: String?

    public init (
        instanceArn: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        permissionSetArn: String? = nil
    )
    {
        self.instanceArn = instanceArn
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.permissionSetArn = permissionSetArn
    }
}

struct ListManagedPoliciesInPermissionSetInputBody: Equatable {
    public let instanceArn: String?
    public let permissionSetArn: String?
    public let maxResults: Int?
    public let nextToken: String?
}

extension ListManagedPoliciesInPermissionSetInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case instanceArn = "InstanceArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case permissionSetArn = "PermissionSetArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let permissionSetArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .permissionSetArn)
        permissionSetArn = permissionSetArnDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListManagedPoliciesInPermissionSetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListManagedPoliciesInPermissionSetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListManagedPoliciesInPermissionSetOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListManagedPoliciesInPermissionSetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListManagedPoliciesInPermissionSetOutputResponse(attachedManagedPolicies: \(String(describing: attachedManagedPolicies)), nextToken: \(String(describing: nextToken)))"}
}

extension ListManagedPoliciesInPermissionSetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListManagedPoliciesInPermissionSetOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.attachedManagedPolicies = output.attachedManagedPolicies
            self.nextToken = output.nextToken
        } else {
            self.attachedManagedPolicies = nil
            self.nextToken = nil
        }
    }
}

public struct ListManagedPoliciesInPermissionSetOutputResponse: Equatable {
    /// <p>The array of the <a>AttachedManagedPolicy</a> data type object.</p>
    public let attachedManagedPolicies: [AttachedManagedPolicy]?
    /// <p>The pagination token for the list API. Initially the value is null. Use the output of previous API calls to make subsequent calls.</p>
    public let nextToken: String?

    public init (
        attachedManagedPolicies: [AttachedManagedPolicy]? = nil,
        nextToken: String? = nil
    )
    {
        self.attachedManagedPolicies = attachedManagedPolicies
        self.nextToken = nextToken
    }
}

struct ListManagedPoliciesInPermissionSetOutputResponseBody: Equatable {
    public let attachedManagedPolicies: [AttachedManagedPolicy]?
    public let nextToken: String?
}

extension ListManagedPoliciesInPermissionSetOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case attachedManagedPolicies = "AttachedManagedPolicies"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attachedManagedPoliciesContainer = try containerValues.decodeIfPresent([AttachedManagedPolicy?].self, forKey: .attachedManagedPolicies)
        var attachedManagedPoliciesDecoded0:[AttachedManagedPolicy]? = nil
        if let attachedManagedPoliciesContainer = attachedManagedPoliciesContainer {
            attachedManagedPoliciesDecoded0 = [AttachedManagedPolicy]()
            for structure0 in attachedManagedPoliciesContainer {
                if let structure0 = structure0 {
                    attachedManagedPoliciesDecoded0?.append(structure0)
                }
            }
        }
        attachedManagedPolicies = attachedManagedPoliciesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListPermissionSetProvisioningStatusInputBodyMiddleware: Middleware {
    public let id: String = "ListPermissionSetProvisioningStatusInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPermissionSetProvisioningStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPermissionSetProvisioningStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPermissionSetProvisioningStatusInput>
    public typealias MOutput = OperationOutput<ListPermissionSetProvisioningStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPermissionSetProvisioningStatusOutputError>
}

extension ListPermissionSetProvisioningStatusInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListPermissionSetProvisioningStatusInput(filter: \(String(describing: filter)), instanceArn: \(String(describing: instanceArn)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListPermissionSetProvisioningStatusInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filter = "Filter"
        case instanceArn = "InstanceArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let instanceArn = instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListPermissionSetProvisioningStatusInputHeadersMiddleware: Middleware {
    public let id: String = "ListPermissionSetProvisioningStatusInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPermissionSetProvisioningStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPermissionSetProvisioningStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPermissionSetProvisioningStatusInput>
    public typealias MOutput = OperationOutput<ListPermissionSetProvisioningStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPermissionSetProvisioningStatusOutputError>
}

public struct ListPermissionSetProvisioningStatusInputQueryItemMiddleware: Middleware {
    public let id: String = "ListPermissionSetProvisioningStatusInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPermissionSetProvisioningStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPermissionSetProvisioningStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPermissionSetProvisioningStatusInput>
    public typealias MOutput = OperationOutput<ListPermissionSetProvisioningStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPermissionSetProvisioningStatusOutputError>
}

public struct ListPermissionSetProvisioningStatusInput: Equatable {
    /// <p>Filters results based on the passed attribute value.</p>
    public let filter: OperationStatusFilter?
    /// <p>The ARN of the SSO instance under which the operation will be executed.
    ///       For more information about ARNs, see <a href="/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource
    /// Names (ARNs) and AWS Service Namespaces</a> in the <i>AWS General Reference</i>.</p>
    public let instanceArn: String?
    /// <p>The maximum number of results to display for the assignment.</p>
    public let maxResults: Int?
    /// <p>The pagination token for the list API. Initially the value is null. Use the output of previous API calls to make subsequent calls.</p>
    public let nextToken: String?

    public init (
        filter: OperationStatusFilter? = nil,
        instanceArn: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.filter = filter
        self.instanceArn = instanceArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListPermissionSetProvisioningStatusInputBody: Equatable {
    public let instanceArn: String?
    public let maxResults: Int?
    public let nextToken: String?
    public let filter: OperationStatusFilter?
}

extension ListPermissionSetProvisioningStatusInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filter = "Filter"
        case instanceArn = "InstanceArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let filterDecoded = try containerValues.decodeIfPresent(OperationStatusFilter.self, forKey: .filter)
        filter = filterDecoded
    }
}

extension ListPermissionSetProvisioningStatusOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPermissionSetProvisioningStatusOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPermissionSetProvisioningStatusOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPermissionSetProvisioningStatusOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListPermissionSetProvisioningStatusOutputResponse(nextToken: \(String(describing: nextToken)), permissionSetsProvisioningStatus: \(String(describing: permissionSetsProvisioningStatus)))"}
}

extension ListPermissionSetProvisioningStatusOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListPermissionSetProvisioningStatusOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.permissionSetsProvisioningStatus = output.permissionSetsProvisioningStatus
        } else {
            self.nextToken = nil
            self.permissionSetsProvisioningStatus = nil
        }
    }
}

public struct ListPermissionSetProvisioningStatusOutputResponse: Equatable {
    /// <p>The pagination token for the list API. Initially the value is null. Use the output of previous API calls to make subsequent calls.</p>
    public let nextToken: String?
    /// <p>The status object for the permission set provisioning operation.</p>
    public let permissionSetsProvisioningStatus: [PermissionSetProvisioningStatusMetadata]?

    public init (
        nextToken: String? = nil,
        permissionSetsProvisioningStatus: [PermissionSetProvisioningStatusMetadata]? = nil
    )
    {
        self.nextToken = nextToken
        self.permissionSetsProvisioningStatus = permissionSetsProvisioningStatus
    }
}

struct ListPermissionSetProvisioningStatusOutputResponseBody: Equatable {
    public let permissionSetsProvisioningStatus: [PermissionSetProvisioningStatusMetadata]?
    public let nextToken: String?
}

extension ListPermissionSetProvisioningStatusOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case permissionSetsProvisioningStatus = "PermissionSetsProvisioningStatus"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let permissionSetsProvisioningStatusContainer = try containerValues.decodeIfPresent([PermissionSetProvisioningStatusMetadata?].self, forKey: .permissionSetsProvisioningStatus)
        var permissionSetsProvisioningStatusDecoded0:[PermissionSetProvisioningStatusMetadata]? = nil
        if let permissionSetsProvisioningStatusContainer = permissionSetsProvisioningStatusContainer {
            permissionSetsProvisioningStatusDecoded0 = [PermissionSetProvisioningStatusMetadata]()
            for structure0 in permissionSetsProvisioningStatusContainer {
                if let structure0 = structure0 {
                    permissionSetsProvisioningStatusDecoded0?.append(structure0)
                }
            }
        }
        permissionSetsProvisioningStatus = permissionSetsProvisioningStatusDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListPermissionSetsInputBodyMiddleware: Middleware {
    public let id: String = "ListPermissionSetsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPermissionSetsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPermissionSetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPermissionSetsInput>
    public typealias MOutput = OperationOutput<ListPermissionSetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPermissionSetsOutputError>
}

extension ListPermissionSetsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListPermissionSetsInput(instanceArn: \(String(describing: instanceArn)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListPermissionSetsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case instanceArn = "InstanceArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceArn = instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListPermissionSetsInputHeadersMiddleware: Middleware {
    public let id: String = "ListPermissionSetsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPermissionSetsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPermissionSetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPermissionSetsInput>
    public typealias MOutput = OperationOutput<ListPermissionSetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPermissionSetsOutputError>
}

public struct ListPermissionSetsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListPermissionSetsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPermissionSetsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPermissionSetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPermissionSetsInput>
    public typealias MOutput = OperationOutput<ListPermissionSetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPermissionSetsOutputError>
}

public struct ListPermissionSetsInput: Equatable {
    /// <p>The ARN of the SSO instance under which the operation will be executed.
    ///       For more information about ARNs, see <a href="/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource
    /// Names (ARNs) and AWS Service Namespaces</a> in the <i>AWS General Reference</i>.</p>
    public let instanceArn: String?
    /// <p>The maximum number of results to display for the assignment.</p>
    public let maxResults: Int?
    /// <p>The pagination token for the list API. Initially the value is null. Use the output of previous API calls to make subsequent calls.</p>
    public let nextToken: String?

    public init (
        instanceArn: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.instanceArn = instanceArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListPermissionSetsInputBody: Equatable {
    public let instanceArn: String?
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListPermissionSetsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case instanceArn = "InstanceArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListPermissionSetsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPermissionSetsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPermissionSetsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPermissionSetsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListPermissionSetsOutputResponse(nextToken: \(String(describing: nextToken)), permissionSets: \(String(describing: permissionSets)))"}
}

extension ListPermissionSetsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListPermissionSetsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.permissionSets = output.permissionSets
        } else {
            self.nextToken = nil
            self.permissionSets = nil
        }
    }
}

public struct ListPermissionSetsOutputResponse: Equatable {
    /// <p>The pagination token for the list API. Initially the value is null. Use the output of previous API calls to make subsequent calls.</p>
    public let nextToken: String?
    /// <p>Defines the level of access on an AWS account.</p>
    public let permissionSets: [String]?

    public init (
        nextToken: String? = nil,
        permissionSets: [String]? = nil
    )
    {
        self.nextToken = nextToken
        self.permissionSets = permissionSets
    }
}

struct ListPermissionSetsOutputResponseBody: Equatable {
    public let permissionSets: [String]?
    public let nextToken: String?
}

extension ListPermissionSetsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case permissionSets = "PermissionSets"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let permissionSetsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .permissionSets)
        var permissionSetsDecoded0:[String]? = nil
        if let permissionSetsContainer = permissionSetsContainer {
            permissionSetsDecoded0 = [String]()
            for string0 in permissionSetsContainer {
                if let string0 = string0 {
                    permissionSetsDecoded0?.append(string0)
                }
            }
        }
        permissionSets = permissionSetsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListPermissionSetsProvisionedToAccountInputBodyMiddleware: Middleware {
    public let id: String = "ListPermissionSetsProvisionedToAccountInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPermissionSetsProvisionedToAccountInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPermissionSetsProvisionedToAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPermissionSetsProvisionedToAccountInput>
    public typealias MOutput = OperationOutput<ListPermissionSetsProvisionedToAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPermissionSetsProvisionedToAccountOutputError>
}

extension ListPermissionSetsProvisionedToAccountInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListPermissionSetsProvisionedToAccountInput(accountId: \(String(describing: accountId)), instanceArn: \(String(describing: instanceArn)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), provisioningStatus: \(String(describing: provisioningStatus)))"}
}

extension ListPermissionSetsProvisionedToAccountInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountId = "AccountId"
        case instanceArn = "InstanceArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case provisioningStatus = "ProvisioningStatus"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let instanceArn = instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let provisioningStatus = provisioningStatus {
            try encodeContainer.encode(provisioningStatus.rawValue, forKey: .provisioningStatus)
        }
    }
}

public struct ListPermissionSetsProvisionedToAccountInputHeadersMiddleware: Middleware {
    public let id: String = "ListPermissionSetsProvisionedToAccountInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPermissionSetsProvisionedToAccountInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPermissionSetsProvisionedToAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPermissionSetsProvisionedToAccountInput>
    public typealias MOutput = OperationOutput<ListPermissionSetsProvisionedToAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPermissionSetsProvisionedToAccountOutputError>
}

public struct ListPermissionSetsProvisionedToAccountInputQueryItemMiddleware: Middleware {
    public let id: String = "ListPermissionSetsProvisionedToAccountInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPermissionSetsProvisionedToAccountInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPermissionSetsProvisionedToAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPermissionSetsProvisionedToAccountInput>
    public typealias MOutput = OperationOutput<ListPermissionSetsProvisionedToAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPermissionSetsProvisionedToAccountOutputError>
}

public struct ListPermissionSetsProvisionedToAccountInput: Equatable {
    /// <p>The identifier of the AWS account from which to list the assignments.</p>
    public let accountId: String?
    /// <p>The ARN of the SSO instance under which the operation will be executed.
    ///       For more information about ARNs, see <a href="/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource
    /// Names (ARNs) and AWS Service Namespaces</a> in the <i>AWS General Reference</i>.</p>
    public let instanceArn: String?
    /// <p>The maximum number of results to display for the assignment.</p>
    public let maxResults: Int?
    /// <p>The pagination token for the list API. Initially the value is null. Use the output of previous API calls to make subsequent calls.</p>
    public let nextToken: String?
    /// <p>The status object for the permission set provisioning operation.</p>
    public let provisioningStatus: ProvisioningStatus?

    public init (
        accountId: String? = nil,
        instanceArn: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        provisioningStatus: ProvisioningStatus? = nil
    )
    {
        self.accountId = accountId
        self.instanceArn = instanceArn
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.provisioningStatus = provisioningStatus
    }
}

struct ListPermissionSetsProvisionedToAccountInputBody: Equatable {
    public let instanceArn: String?
    public let accountId: String?
    public let provisioningStatus: ProvisioningStatus?
    public let maxResults: Int?
    public let nextToken: String?
}

extension ListPermissionSetsProvisionedToAccountInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accountId = "AccountId"
        case instanceArn = "InstanceArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case provisioningStatus = "ProvisioningStatus"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let provisioningStatusDecoded = try containerValues.decodeIfPresent(ProvisioningStatus.self, forKey: .provisioningStatus)
        provisioningStatus = provisioningStatusDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListPermissionSetsProvisionedToAccountOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPermissionSetsProvisionedToAccountOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPermissionSetsProvisionedToAccountOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPermissionSetsProvisionedToAccountOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListPermissionSetsProvisionedToAccountOutputResponse(nextToken: \(String(describing: nextToken)), permissionSets: \(String(describing: permissionSets)))"}
}

extension ListPermissionSetsProvisionedToAccountOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListPermissionSetsProvisionedToAccountOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.permissionSets = output.permissionSets
        } else {
            self.nextToken = nil
            self.permissionSets = nil
        }
    }
}

public struct ListPermissionSetsProvisionedToAccountOutputResponse: Equatable {
    /// <p>The pagination token for the list API. Initially the value is null. Use the output of previous API calls to make subsequent calls.</p>
    public let nextToken: String?
    /// <p>Defines the level of access that an AWS account has.</p>
    public let permissionSets: [String]?

    public init (
        nextToken: String? = nil,
        permissionSets: [String]? = nil
    )
    {
        self.nextToken = nextToken
        self.permissionSets = permissionSets
    }
}

struct ListPermissionSetsProvisionedToAccountOutputResponseBody: Equatable {
    public let nextToken: String?
    public let permissionSets: [String]?
}

extension ListPermissionSetsProvisionedToAccountOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case permissionSets = "PermissionSets"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let permissionSetsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .permissionSets)
        var permissionSetsDecoded0:[String]? = nil
        if let permissionSetsContainer = permissionSetsContainer {
            permissionSetsDecoded0 = [String]()
            for string0 in permissionSetsContainer {
                if let string0 = string0 {
                    permissionSetsDecoded0?.append(string0)
                }
            }
        }
        permissionSets = permissionSetsDecoded0
    }
}

public struct ListTagsForResourceInputBodyMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

extension ListTagsForResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceInput(instanceArn: \(String(describing: instanceArn)), nextToken: \(String(describing: nextToken)), resourceArn: \(String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case instanceArn = "InstanceArn"
        case nextToken = "NextToken"
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceArn = instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Equatable {
    /// <p>The ARN of the SSO instance under which the operation will be executed.
    ///       For more information about ARNs, see <a href="/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource
    /// Names (ARNs) and AWS Service Namespaces</a> in the <i>AWS General Reference</i>.</p>
    public let instanceArn: String?
    /// <p>The pagination token for the list API. Initially the value is null. Use the output of previous API calls to make subsequent calls.</p>
    public let nextToken: String?
    /// <p>The ARN of the resource with the tags to be listed.</p>
    public let resourceArn: String?

    public init (
        instanceArn: String? = nil,
        nextToken: String? = nil,
        resourceArn: String? = nil
    )
    {
        self.instanceArn = instanceArn
        self.nextToken = nextToken
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Equatable {
    public let instanceArn: String?
    public let resourceArn: String?
    public let nextToken: String?
}

extension ListTagsForResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case instanceArn = "InstanceArn"
        case nextToken = "NextToken"
        case resourceArn = "ResourceArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceOutputResponse(nextToken: \(String(describing: nextToken)), tags: \(String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.tags = output.tags
        } else {
            self.nextToken = nil
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Equatable {
    /// <p>The pagination token for the list API. Initially the value is null. Use the output of previous API calls to make subsequent calls.</p>
    public let nextToken: String?
    /// <p>A set of key-value pairs that are used to manage the resource.</p>
    public let tags: [Tag]?

    public init (
        nextToken: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.nextToken = nextToken
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Equatable {
    public let tags: [Tag]?
    public let nextToken: String?
}

extension ListTagsForResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension OperationStatusFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(StatusValues.self, forKey: .status)
        status = statusDecoded
    }
}

extension OperationStatusFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OperationStatusFilter(status: \(String(describing: status)))"}
}

/// <p>Filters he operation status list based on the passed attribute value.</p>
public struct OperationStatusFilter: Equatable {
    /// <p>Filters the list operations result based on the status attribute.</p>
    public let status: StatusValues?

    public init (
        status: StatusValues? = nil
    )
    {
        self.status = status
    }
}

extension PermissionSet: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case createdDate = "CreatedDate"
        case description = "Description"
        case name = "Name"
        case permissionSetArn = "PermissionSetArn"
        case relayState = "RelayState"
        case sessionDuration = "SessionDuration"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdDate = createdDate {
            try encodeContainer.encode(createdDate.timeIntervalSince1970, forKey: .createdDate)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let permissionSetArn = permissionSetArn {
            try encodeContainer.encode(permissionSetArn, forKey: .permissionSetArn)
        }
        if let relayState = relayState {
            try encodeContainer.encode(relayState, forKey: .relayState)
        }
        if let sessionDuration = sessionDuration {
            try encodeContainer.encode(sessionDuration, forKey: .sessionDuration)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let permissionSetArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .permissionSetArn)
        permissionSetArn = permissionSetArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let sessionDurationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sessionDuration)
        sessionDuration = sessionDurationDecoded
        let relayStateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .relayState)
        relayState = relayStateDecoded
    }
}

extension PermissionSet: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PermissionSet(createdDate: \(String(describing: createdDate)), description: \(String(describing: description)), name: \(String(describing: name)), permissionSetArn: \(String(describing: permissionSetArn)), relayState: \(String(describing: relayState)), sessionDuration: \(String(describing: sessionDuration)))"}
}

/// <p>An entity that contains IAM policies.</p>
public struct PermissionSet: Equatable {
    /// <p>The date that the permission set was created.</p>
    public let createdDate: Date?
    /// <p>The description of the <a>PermissionSet</a>.</p>
    public let description: String?
    /// <p>The name of the permission set.</p>
    public let name: String?
    /// <p>The ARN of the permission set. For more information about ARNs, see <a href="/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource
    /// Names (ARNs) and AWS Service Namespaces</a> in the <i>AWS General Reference</i>.</p>
    public let permissionSetArn: String?
    /// <p>Used to redirect users within the application during the federation authentication
    ///        process.</p>
    public let relayState: String?
    /// <p>The length of time that the application user sessions are valid for in the ISO-8601
    ///        standard.</p>
    public let sessionDuration: String?

    public init (
        createdDate: Date? = nil,
        description: String? = nil,
        name: String? = nil,
        permissionSetArn: String? = nil,
        relayState: String? = nil,
        sessionDuration: String? = nil
    )
    {
        self.createdDate = createdDate
        self.description = description
        self.name = name
        self.permissionSetArn = permissionSetArn
        self.relayState = relayState
        self.sessionDuration = sessionDuration
    }
}

extension PermissionSetProvisioningStatus: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountId = "AccountId"
        case createdDate = "CreatedDate"
        case failureReason = "FailureReason"
        case permissionSetArn = "PermissionSetArn"
        case requestId = "RequestId"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let createdDate = createdDate {
            try encodeContainer.encode(createdDate.timeIntervalSince1970, forKey: .createdDate)
        }
        if let failureReason = failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let permissionSetArn = permissionSetArn {
            try encodeContainer.encode(permissionSetArn, forKey: .permissionSetArn)
        }
        if let requestId = requestId {
            try encodeContainer.encode(requestId, forKey: .requestId)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(StatusValues.self, forKey: .status)
        status = statusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let permissionSetArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .permissionSetArn)
        permissionSetArn = permissionSetArnDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
    }
}

extension PermissionSetProvisioningStatus: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PermissionSetProvisioningStatus(accountId: \(String(describing: accountId)), createdDate: \(String(describing: createdDate)), failureReason: \(String(describing: failureReason)), permissionSetArn: \(String(describing: permissionSetArn)), requestId: \(String(describing: requestId)), status: \(String(describing: status)))"}
}

/// <p>A structure that is used to provide the status of the provisioning operation for a
///       specified permission set.</p>
public struct PermissionSetProvisioningStatus: Equatable {
    /// <p>The identifier of the AWS account from which to list the assignments.</p>
    public let accountId: String?
    /// <p>The date that the permission set was created.</p>
    public let createdDate: Date?
    /// <p>The message that contains an error or exception in case of an operation failure.</p>
    public let failureReason: String?
    /// <p>The ARN of the permission set that is being provisioned. For more information about ARNs, see <a href="/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource
    /// Names (ARNs) and AWS Service Namespaces</a> in the <i>AWS General Reference</i>.</p>
    public let permissionSetArn: String?
    /// <p>The identifier for tracking the request operation that is generated by the universally
    ///       unique identifier (UUID) workflow.</p>
    public let requestId: String?
    /// <p>The status of the permission set provisioning process.</p>
    public let status: StatusValues?

    public init (
        accountId: String? = nil,
        createdDate: Date? = nil,
        failureReason: String? = nil,
        permissionSetArn: String? = nil,
        requestId: String? = nil,
        status: StatusValues? = nil
    )
    {
        self.accountId = accountId
        self.createdDate = createdDate
        self.failureReason = failureReason
        self.permissionSetArn = permissionSetArn
        self.requestId = requestId
        self.status = status
    }
}

extension PermissionSetProvisioningStatusMetadata: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case createdDate = "CreatedDate"
        case requestId = "RequestId"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdDate = createdDate {
            try encodeContainer.encode(createdDate.timeIntervalSince1970, forKey: .createdDate)
        }
        if let requestId = requestId {
            try encodeContainer.encode(requestId, forKey: .requestId)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(StatusValues.self, forKey: .status)
        status = statusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
    }
}

extension PermissionSetProvisioningStatusMetadata: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PermissionSetProvisioningStatusMetadata(createdDate: \(String(describing: createdDate)), requestId: \(String(describing: requestId)), status: \(String(describing: status)))"}
}

/// <p>Provides information about the permission set provisioning status.</p>
public struct PermissionSetProvisioningStatusMetadata: Equatable {
    /// <p>The date that the permission set was created.</p>
    public let createdDate: Date?
    /// <p>The identifier for tracking the request operation that is generated by the universally
    ///       unique identifier (UUID) workflow.</p>
    public let requestId: String?
    /// <p>The status of the permission set provisioning process.</p>
    public let status: StatusValues?

    public init (
        createdDate: Date? = nil,
        requestId: String? = nil,
        status: StatusValues? = nil
    )
    {
        self.createdDate = createdDate
        self.requestId = requestId
        self.status = status
    }
}

public enum PrincipalType {
    case group
    case user
    case sdkUnknown(String)
}

extension PrincipalType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [PrincipalType] {
        return [
            .group,
            .user,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .group: return "GROUP"
        case .user: return "USER"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = PrincipalType(rawValue: rawValue) ?? PrincipalType.sdkUnknown(rawValue)
    }
}

public struct ProvisionPermissionSetInputBodyMiddleware: Middleware {
    public let id: String = "ProvisionPermissionSetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ProvisionPermissionSetInput>,
                  next: H) -> Swift.Result<OperationOutput<ProvisionPermissionSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ProvisionPermissionSetInput>
    public typealias MOutput = OperationOutput<ProvisionPermissionSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ProvisionPermissionSetOutputError>
}

extension ProvisionPermissionSetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ProvisionPermissionSetInput(instanceArn: \(String(describing: instanceArn)), permissionSetArn: \(String(describing: permissionSetArn)), targetId: \(String(describing: targetId)), targetType: \(String(describing: targetType)))"}
}

extension ProvisionPermissionSetInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case instanceArn = "InstanceArn"
        case permissionSetArn = "PermissionSetArn"
        case targetId = "TargetId"
        case targetType = "TargetType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceArn = instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
        if let permissionSetArn = permissionSetArn {
            try encodeContainer.encode(permissionSetArn, forKey: .permissionSetArn)
        }
        if let targetId = targetId {
            try encodeContainer.encode(targetId, forKey: .targetId)
        }
        if let targetType = targetType {
            try encodeContainer.encode(targetType.rawValue, forKey: .targetType)
        }
    }
}

public struct ProvisionPermissionSetInputHeadersMiddleware: Middleware {
    public let id: String = "ProvisionPermissionSetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ProvisionPermissionSetInput>,
                  next: H) -> Swift.Result<OperationOutput<ProvisionPermissionSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ProvisionPermissionSetInput>
    public typealias MOutput = OperationOutput<ProvisionPermissionSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ProvisionPermissionSetOutputError>
}

public struct ProvisionPermissionSetInputQueryItemMiddleware: Middleware {
    public let id: String = "ProvisionPermissionSetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ProvisionPermissionSetInput>,
                  next: H) -> Swift.Result<OperationOutput<ProvisionPermissionSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ProvisionPermissionSetInput>
    public typealias MOutput = OperationOutput<ProvisionPermissionSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ProvisionPermissionSetOutputError>
}

public struct ProvisionPermissionSetInput: Equatable {
    /// <p>The ARN of the SSO instance under which the operation will be executed.
    ///       For more information about ARNs, see <a href="/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource
    /// Names (ARNs) and AWS Service Namespaces</a> in the <i>AWS General Reference</i>.</p>
    public let instanceArn: String?
    /// <p>The ARN of the permission set.</p>
    public let permissionSetArn: String?
    /// <p>TargetID is an AWS account identifier, typically a 10-12 digit string (For example, 123456789012).</p>
    public let targetId: String?
    /// <p>The entity type for which the assignment will be created.</p>
    public let targetType: ProvisionTargetType?

    public init (
        instanceArn: String? = nil,
        permissionSetArn: String? = nil,
        targetId: String? = nil,
        targetType: ProvisionTargetType? = nil
    )
    {
        self.instanceArn = instanceArn
        self.permissionSetArn = permissionSetArn
        self.targetId = targetId
        self.targetType = targetType
    }
}

struct ProvisionPermissionSetInputBody: Equatable {
    public let instanceArn: String?
    public let permissionSetArn: String?
    public let targetId: String?
    public let targetType: ProvisionTargetType?
}

extension ProvisionPermissionSetInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case instanceArn = "InstanceArn"
        case permissionSetArn = "PermissionSetArn"
        case targetId = "TargetId"
        case targetType = "TargetType"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let permissionSetArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .permissionSetArn)
        permissionSetArn = permissionSetArnDecoded
        let targetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .targetId)
        targetId = targetIdDecoded
        let targetTypeDecoded = try containerValues.decodeIfPresent(ProvisionTargetType.self, forKey: .targetType)
        targetType = targetTypeDecoded
    }
}

extension ProvisionPermissionSetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ProvisionPermissionSetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ProvisionPermissionSetOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ProvisionPermissionSetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ProvisionPermissionSetOutputResponse(permissionSetProvisioningStatus: \(String(describing: permissionSetProvisioningStatus)))"}
}

extension ProvisionPermissionSetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ProvisionPermissionSetOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.permissionSetProvisioningStatus = output.permissionSetProvisioningStatus
        } else {
            self.permissionSetProvisioningStatus = nil
        }
    }
}

public struct ProvisionPermissionSetOutputResponse: Equatable {
    /// <p>The status object for the permission set provisioning operation.</p>
    public let permissionSetProvisioningStatus: PermissionSetProvisioningStatus?

    public init (
        permissionSetProvisioningStatus: PermissionSetProvisioningStatus? = nil
    )
    {
        self.permissionSetProvisioningStatus = permissionSetProvisioningStatus
    }
}

struct ProvisionPermissionSetOutputResponseBody: Equatable {
    public let permissionSetProvisioningStatus: PermissionSetProvisioningStatus?
}

extension ProvisionPermissionSetOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case permissionSetProvisioningStatus = "PermissionSetProvisioningStatus"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let permissionSetProvisioningStatusDecoded = try containerValues.decodeIfPresent(PermissionSetProvisioningStatus.self, forKey: .permissionSetProvisioningStatus)
        permissionSetProvisioningStatus = permissionSetProvisioningStatusDecoded
    }
}

public enum ProvisionTargetType {
    case allProvisionedAccounts
    case awsAccount
    case sdkUnknown(String)
}

extension ProvisionTargetType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ProvisionTargetType] {
        return [
            .allProvisionedAccounts,
            .awsAccount,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .allProvisionedAccounts: return "ALL_PROVISIONED_ACCOUNTS"
        case .awsAccount: return "AWS_ACCOUNT"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ProvisionTargetType(rawValue: rawValue) ?? ProvisionTargetType.sdkUnknown(rawValue)
    }
}

public enum ProvisioningStatus {
    case latestPermissionSetNotProvisioned
    case latestPermissionSetProvisioned
    case sdkUnknown(String)
}

extension ProvisioningStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ProvisioningStatus] {
        return [
            .latestPermissionSetNotProvisioned,
            .latestPermissionSetProvisioned,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .latestPermissionSetNotProvisioned: return "LATEST_PERMISSION_SET_NOT_PROVISIONED"
        case .latestPermissionSetProvisioned: return "LATEST_PERMISSION_SET_PROVISIONED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ProvisioningStatus(rawValue: rawValue) ?? ProvisioningStatus.sdkUnknown(rawValue)
    }
}

public struct PutInlinePolicyToPermissionSetInputBodyMiddleware: Middleware {
    public let id: String = "PutInlinePolicyToPermissionSetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutInlinePolicyToPermissionSetInput>,
                  next: H) -> Swift.Result<OperationOutput<PutInlinePolicyToPermissionSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutInlinePolicyToPermissionSetInput>
    public typealias MOutput = OperationOutput<PutInlinePolicyToPermissionSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutInlinePolicyToPermissionSetOutputError>
}

extension PutInlinePolicyToPermissionSetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutInlinePolicyToPermissionSetInput(inlinePolicy: \(String(describing: inlinePolicy)), instanceArn: \(String(describing: instanceArn)), permissionSetArn: \(String(describing: permissionSetArn)))"}
}

extension PutInlinePolicyToPermissionSetInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case inlinePolicy = "InlinePolicy"
        case instanceArn = "InstanceArn"
        case permissionSetArn = "PermissionSetArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inlinePolicy = inlinePolicy {
            try encodeContainer.encode(inlinePolicy, forKey: .inlinePolicy)
        }
        if let instanceArn = instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
        if let permissionSetArn = permissionSetArn {
            try encodeContainer.encode(permissionSetArn, forKey: .permissionSetArn)
        }
    }
}

public struct PutInlinePolicyToPermissionSetInputHeadersMiddleware: Middleware {
    public let id: String = "PutInlinePolicyToPermissionSetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutInlinePolicyToPermissionSetInput>,
                  next: H) -> Swift.Result<OperationOutput<PutInlinePolicyToPermissionSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutInlinePolicyToPermissionSetInput>
    public typealias MOutput = OperationOutput<PutInlinePolicyToPermissionSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutInlinePolicyToPermissionSetOutputError>
}

public struct PutInlinePolicyToPermissionSetInputQueryItemMiddleware: Middleware {
    public let id: String = "PutInlinePolicyToPermissionSetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutInlinePolicyToPermissionSetInput>,
                  next: H) -> Swift.Result<OperationOutput<PutInlinePolicyToPermissionSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutInlinePolicyToPermissionSetInput>
    public typealias MOutput = OperationOutput<PutInlinePolicyToPermissionSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutInlinePolicyToPermissionSetOutputError>
}

public struct PutInlinePolicyToPermissionSetInput: Equatable {
    /// <p>The IAM inline policy to attach to a <a>PermissionSet</a>.</p>
    public let inlinePolicy: String?
    /// <p>The ARN of the SSO instance under which the operation will be executed.
    ///       For more information about ARNs, see <a href="/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource
    /// Names (ARNs) and AWS Service Namespaces</a> in the <i>AWS General Reference</i>.</p>
    public let instanceArn: String?
    /// <p>The ARN of the permission set.</p>
    public let permissionSetArn: String?

    public init (
        inlinePolicy: String? = nil,
        instanceArn: String? = nil,
        permissionSetArn: String? = nil
    )
    {
        self.inlinePolicy = inlinePolicy
        self.instanceArn = instanceArn
        self.permissionSetArn = permissionSetArn
    }
}

struct PutInlinePolicyToPermissionSetInputBody: Equatable {
    public let instanceArn: String?
    public let permissionSetArn: String?
    public let inlinePolicy: String?
}

extension PutInlinePolicyToPermissionSetInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case inlinePolicy = "InlinePolicy"
        case instanceArn = "InstanceArn"
        case permissionSetArn = "PermissionSetArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let permissionSetArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .permissionSetArn)
        permissionSetArn = permissionSetArnDecoded
        let inlinePolicyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .inlinePolicy)
        inlinePolicy = inlinePolicyDecoded
    }
}

extension PutInlinePolicyToPermissionSetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutInlinePolicyToPermissionSetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutInlinePolicyToPermissionSetOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutInlinePolicyToPermissionSetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutInlinePolicyToPermissionSetOutputResponse()"}
}

extension PutInlinePolicyToPermissionSetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct PutInlinePolicyToPermissionSetOutputResponse: Equatable {

    public init() {}
}

struct PutInlinePolicyToPermissionSetOutputResponseBody: Equatable {
}

extension PutInlinePolicyToPermissionSetOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundException(message: \(String(describing: message)))"}
}

extension ResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Indicates that a requested resource is not found.</p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension ResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceQuotaExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceQuotaExceededException(message: \(String(describing: message)))"}
}

extension ServiceQuotaExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Indicates that the principal has crossed the permitted number of resources that can be created.</p>
public struct ServiceQuotaExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Equatable {
    public let message: String?
}

extension ServiceQuotaExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum StatusValues {
    case failed
    case inProgress
    case succeeded
    case sdkUnknown(String)
}

extension StatusValues : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [StatusValues] {
        return [
            .failed,
            .inProgress,
            .succeeded,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .failed: return "FAILED"
        case .inProgress: return "IN_PROGRESS"
        case .succeeded: return "SUCCEEDED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = StatusValues(rawValue: rawValue) ?? StatusValues.sdkUnknown(rawValue)
    }
}

extension Tag: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Tag: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Tag(key: \(String(describing: key)), value: \(String(describing: value)))"}
}

/// <p>A set of key-value pairs that are used to manage the resource. Tags can only be applied to permission sets and cannot be applied to corresponding roles
///        that AWS SSO creates in AWS accounts.</p>
public struct Tag: Equatable {
    /// <p>The key for the tag.</p>
    public let key: String?
    /// <p>The value of the tag.</p>
    public let value: String?

    public init (
        key: String? = nil,
        value: String? = nil
    )
    {
        self.key = key
        self.value = value
    }
}

public struct TagResourceInputBodyMiddleware: Middleware {
    public let id: String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

extension TagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceInput(instanceArn: \(String(describing: instanceArn)), resourceArn: \(String(describing: resourceArn)), tags: \(String(describing: tags)))"}
}

extension TagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case instanceArn = "InstanceArn"
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceArn = instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Equatable {
    /// <p>The ARN of the SSO instance under which the operation will be executed.
    ///       For more information about ARNs, see <a href="/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource
    /// Names (ARNs) and AWS Service Namespaces</a> in the <i>AWS General Reference</i>.</p>
    public let instanceArn: String?
    /// <p>The ARN of the resource with the tags to be listed.</p>
    public let resourceArn: String?
    /// <p>A set of key-value pairs that are used to manage the resource.</p>
    public let tags: [Tag]?

    public init (
        instanceArn: String? = nil,
        resourceArn: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.instanceArn = instanceArn
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Equatable {
    public let instanceArn: String?
    public let resourceArn: String?
    public let tags: [Tag]?
}

extension TagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case instanceArn = "InstanceArn"
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Equatable {
}

extension TagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public enum TargetType {
    case awsAccount
    case sdkUnknown(String)
}

extension TargetType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [TargetType] {
        return [
            .awsAccount,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .awsAccount: return "AWS_ACCOUNT"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = TargetType(rawValue: rawValue) ?? TargetType.sdkUnknown(rawValue)
    }
}

extension ThrottlingException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ThrottlingException(message: \(String(describing: message)))"}
}

extension ThrottlingException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Indicates that the principal has crossed the throttling limits of the API operations.</p>
public struct ThrottlingException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ThrottlingExceptionBody: Equatable {
    public let message: String?
}

extension ThrottlingExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct UntagResourceInputBodyMiddleware: Middleware {
    public let id: String = "UntagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

extension UntagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceInput(instanceArn: \(String(describing: instanceArn)), resourceArn: \(String(describing: resourceArn)), tagKeys: \(String(describing: tagKeys)))"}
}

extension UntagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case instanceArn = "InstanceArn"
        case resourceArn = "ResourceArn"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceArn = instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkeylist0 in tagKeys {
                try tagKeysContainer.encode(tagkeylist0)
            }
        }
    }
}

public struct UntagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Equatable {
    /// <p>The ARN of the SSO instance under which the operation will be executed.
    ///       For more information about ARNs, see <a href="/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource
    /// Names (ARNs) and AWS Service Namespaces</a> in the <i>AWS General Reference</i>.</p>
    public let instanceArn: String?
    /// <p>The ARN of the resource with the tags to be listed.</p>
    public let resourceArn: String?
    /// <p>The keys of tags that are attached to the resource.</p>
    public let tagKeys: [String]?

    public init (
        instanceArn: String? = nil,
        resourceArn: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.instanceArn = instanceArn
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Equatable {
    public let instanceArn: String?
    public let resourceArn: String?
    public let tagKeys: [String]?
}

extension UntagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case instanceArn = "InstanceArn"
        case resourceArn = "ResourceArn"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Equatable {
}

extension UntagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateInstanceAccessControlAttributeConfigurationInputBodyMiddleware: Middleware {
    public let id: String = "UpdateInstanceAccessControlAttributeConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateInstanceAccessControlAttributeConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateInstanceAccessControlAttributeConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateInstanceAccessControlAttributeConfigurationInput>
    public typealias MOutput = OperationOutput<UpdateInstanceAccessControlAttributeConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateInstanceAccessControlAttributeConfigurationOutputError>
}

extension UpdateInstanceAccessControlAttributeConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateInstanceAccessControlAttributeConfigurationInput(instanceAccessControlAttributeConfiguration: \(String(describing: instanceAccessControlAttributeConfiguration)), instanceArn: \(String(describing: instanceArn)))"}
}

extension UpdateInstanceAccessControlAttributeConfigurationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case instanceAccessControlAttributeConfiguration = "InstanceAccessControlAttributeConfiguration"
        case instanceArn = "InstanceArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceAccessControlAttributeConfiguration = instanceAccessControlAttributeConfiguration {
            try encodeContainer.encode(instanceAccessControlAttributeConfiguration, forKey: .instanceAccessControlAttributeConfiguration)
        }
        if let instanceArn = instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
    }
}

public struct UpdateInstanceAccessControlAttributeConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateInstanceAccessControlAttributeConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateInstanceAccessControlAttributeConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateInstanceAccessControlAttributeConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateInstanceAccessControlAttributeConfigurationInput>
    public typealias MOutput = OperationOutput<UpdateInstanceAccessControlAttributeConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateInstanceAccessControlAttributeConfigurationOutputError>
}

public struct UpdateInstanceAccessControlAttributeConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateInstanceAccessControlAttributeConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateInstanceAccessControlAttributeConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateInstanceAccessControlAttributeConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateInstanceAccessControlAttributeConfigurationInput>
    public typealias MOutput = OperationOutput<UpdateInstanceAccessControlAttributeConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateInstanceAccessControlAttributeConfigurationOutputError>
}

public struct UpdateInstanceAccessControlAttributeConfigurationInput: Equatable {
    /// <p>Updates the attributes for your ABAC configuration.</p>
    public let instanceAccessControlAttributeConfiguration: InstanceAccessControlAttributeConfiguration?
    /// <p>The ARN of the SSO instance under which the operation will be executed.</p>
    public let instanceArn: String?

    public init (
        instanceAccessControlAttributeConfiguration: InstanceAccessControlAttributeConfiguration? = nil,
        instanceArn: String? = nil
    )
    {
        self.instanceAccessControlAttributeConfiguration = instanceAccessControlAttributeConfiguration
        self.instanceArn = instanceArn
    }
}

struct UpdateInstanceAccessControlAttributeConfigurationInputBody: Equatable {
    public let instanceArn: String?
    public let instanceAccessControlAttributeConfiguration: InstanceAccessControlAttributeConfiguration?
}

extension UpdateInstanceAccessControlAttributeConfigurationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case instanceAccessControlAttributeConfiguration = "InstanceAccessControlAttributeConfiguration"
        case instanceArn = "InstanceArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let instanceAccessControlAttributeConfigurationDecoded = try containerValues.decodeIfPresent(InstanceAccessControlAttributeConfiguration.self, forKey: .instanceAccessControlAttributeConfiguration)
        instanceAccessControlAttributeConfiguration = instanceAccessControlAttributeConfigurationDecoded
    }
}

extension UpdateInstanceAccessControlAttributeConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateInstanceAccessControlAttributeConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateInstanceAccessControlAttributeConfigurationOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateInstanceAccessControlAttributeConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateInstanceAccessControlAttributeConfigurationOutputResponse()"}
}

extension UpdateInstanceAccessControlAttributeConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateInstanceAccessControlAttributeConfigurationOutputResponse: Equatable {

    public init() {}
}

struct UpdateInstanceAccessControlAttributeConfigurationOutputResponseBody: Equatable {
}

extension UpdateInstanceAccessControlAttributeConfigurationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdatePermissionSetInputBodyMiddleware: Middleware {
    public let id: String = "UpdatePermissionSetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdatePermissionSetInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdatePermissionSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdatePermissionSetInput>
    public typealias MOutput = OperationOutput<UpdatePermissionSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdatePermissionSetOutputError>
}

extension UpdatePermissionSetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdatePermissionSetInput(description: \(String(describing: description)), instanceArn: \(String(describing: instanceArn)), permissionSetArn: \(String(describing: permissionSetArn)), relayState: \(String(describing: relayState)), sessionDuration: \(String(describing: sessionDuration)))"}
}

extension UpdatePermissionSetInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case instanceArn = "InstanceArn"
        case permissionSetArn = "PermissionSetArn"
        case relayState = "RelayState"
        case sessionDuration = "SessionDuration"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let instanceArn = instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
        if let permissionSetArn = permissionSetArn {
            try encodeContainer.encode(permissionSetArn, forKey: .permissionSetArn)
        }
        if let relayState = relayState {
            try encodeContainer.encode(relayState, forKey: .relayState)
        }
        if let sessionDuration = sessionDuration {
            try encodeContainer.encode(sessionDuration, forKey: .sessionDuration)
        }
    }
}

public struct UpdatePermissionSetInputHeadersMiddleware: Middleware {
    public let id: String = "UpdatePermissionSetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdatePermissionSetInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdatePermissionSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdatePermissionSetInput>
    public typealias MOutput = OperationOutput<UpdatePermissionSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdatePermissionSetOutputError>
}

public struct UpdatePermissionSetInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdatePermissionSetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdatePermissionSetInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdatePermissionSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdatePermissionSetInput>
    public typealias MOutput = OperationOutput<UpdatePermissionSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdatePermissionSetOutputError>
}

public struct UpdatePermissionSetInput: Equatable {
    /// <p>The description of the <a>PermissionSet</a>.</p>
    public let description: String?
    /// <p>The ARN of the SSO instance under which the operation will be executed.
    ///       For more information about ARNs, see <a href="/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource
    /// Names (ARNs) and AWS Service Namespaces</a> in the <i>AWS General Reference</i>.</p>
    public let instanceArn: String?
    /// <p>The ARN of the permission set.</p>
    public let permissionSetArn: String?
    /// <p>Used to redirect users within the application during the federation authentication
    ///        process.</p>
    public let relayState: String?
    /// <p>The length of time that the application user sessions are valid for in the ISO-8601
    ///        standard.</p>
    public let sessionDuration: String?

    public init (
        description: String? = nil,
        instanceArn: String? = nil,
        permissionSetArn: String? = nil,
        relayState: String? = nil,
        sessionDuration: String? = nil
    )
    {
        self.description = description
        self.instanceArn = instanceArn
        self.permissionSetArn = permissionSetArn
        self.relayState = relayState
        self.sessionDuration = sessionDuration
    }
}

struct UpdatePermissionSetInputBody: Equatable {
    public let instanceArn: String?
    public let permissionSetArn: String?
    public let description: String?
    public let sessionDuration: String?
    public let relayState: String?
}

extension UpdatePermissionSetInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case instanceArn = "InstanceArn"
        case permissionSetArn = "PermissionSetArn"
        case relayState = "RelayState"
        case sessionDuration = "SessionDuration"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let permissionSetArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .permissionSetArn)
        permissionSetArn = permissionSetArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let sessionDurationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sessionDuration)
        sessionDuration = sessionDurationDecoded
        let relayStateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .relayState)
        relayState = relayStateDecoded
    }
}

extension UpdatePermissionSetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdatePermissionSetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdatePermissionSetOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdatePermissionSetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdatePermissionSetOutputResponse()"}
}

extension UpdatePermissionSetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdatePermissionSetOutputResponse: Equatable {

    public init() {}
}

struct UpdatePermissionSetOutputResponseBody: Equatable {
}

extension UpdatePermissionSetOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ValidationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ValidationException(message: \(String(describing: message)))"}
}

extension ValidationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request failed because it contains a syntax error.</p>
public struct ValidationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Equatable {
    public let message: String?
}

extension ValidationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}
