// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

#if swift(>=5.5)
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, macCatalyst 15.0, *)
public extension CodeDeployClient {
    /// <p>Adds tags to on-premises instances.</p>
    func addTagsToOnPremisesInstances(input: AddTagsToOnPremisesInstancesInput) async throws -> AddTagsToOnPremisesInstancesOutputResponse
    {
        typealias addTagsToOnPremisesInstancesContinuation = CheckedContinuation<AddTagsToOnPremisesInstancesOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: addTagsToOnPremisesInstancesContinuation) in
            addTagsToOnPremisesInstances(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Gets information about one or more application revisions. The maximum number of
    ///             application revisions that can be returned is 25.</p>
    func batchGetApplicationRevisions(input: BatchGetApplicationRevisionsInput) async throws -> BatchGetApplicationRevisionsOutputResponse
    {
        typealias batchGetApplicationRevisionsContinuation = CheckedContinuation<BatchGetApplicationRevisionsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: batchGetApplicationRevisionsContinuation) in
            batchGetApplicationRevisions(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Gets information about one or more applications. The maximum number of applications
    ///             that can be returned is 100.</p>
    func batchGetApplications(input: BatchGetApplicationsInput) async throws -> BatchGetApplicationsOutputResponse
    {
        typealias batchGetApplicationsContinuation = CheckedContinuation<BatchGetApplicationsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: batchGetApplicationsContinuation) in
            batchGetApplications(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Gets information about one or more deployment groups.</p>
    func batchGetDeploymentGroups(input: BatchGetDeploymentGroupsInput) async throws -> BatchGetDeploymentGroupsOutputResponse
    {
        typealias batchGetDeploymentGroupsContinuation = CheckedContinuation<BatchGetDeploymentGroupsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: batchGetDeploymentGroupsContinuation) in
            batchGetDeploymentGroups(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <note>
    ///             <p> This method works, but is deprecated. Use <code>BatchGetDeploymentTargets</code>
    ///                 instead. </p>
    ///         </note>
    ///         <p> Returns an array of one or more instances associated with a deployment. This method
    ///             works with EC2/On-premises and AWS Lambda compute platforms. The newer
    ///                 <code>BatchGetDeploymentTargets</code> works with all compute platforms. The maximum
    ///             number of instances that can be returned is 25.</p>
    @available(*, deprecated, message: "This operation is deprecated, use BatchGetDeploymentTargets instead.")
    func batchGetDeploymentInstances(input: BatchGetDeploymentInstancesInput) async throws -> BatchGetDeploymentInstancesOutputResponse
    {
        typealias batchGetDeploymentInstancesContinuation = CheckedContinuation<BatchGetDeploymentInstancesOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: batchGetDeploymentInstancesContinuation) in
            batchGetDeploymentInstances(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p> Returns an array of one or more targets associated with a deployment. This method
    ///             works with all compute types and should be used instead of the deprecated
    ///                 <code>BatchGetDeploymentInstances</code>. The maximum number of targets that can be
    ///             returned is 25.</p>
    ///         <p> The type of targets returned depends on the deployment's compute platform or
    ///             deployment method: </p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                     <b>EC2/On-premises</b>: Information about EC2 instance
    ///                     targets. </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <b>AWS Lambda</b>: Information about Lambda functions
    ///                     targets. </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <b>Amazon ECS</b>: Information about Amazon ECS
    ///                     service targets. </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <b>CloudFormation</b>: Information about targets of
    ///                     blue/green deployments initiated by a CloudFormation stack update.</p>
    ///             </li>
    ///          </ul>
    func batchGetDeploymentTargets(input: BatchGetDeploymentTargetsInput) async throws -> BatchGetDeploymentTargetsOutputResponse
    {
        typealias batchGetDeploymentTargetsContinuation = CheckedContinuation<BatchGetDeploymentTargetsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: batchGetDeploymentTargetsContinuation) in
            batchGetDeploymentTargets(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Gets information about one or more deployments. The maximum number of deployments that
    ///             can be returned is 25.</p>
    func batchGetDeployments(input: BatchGetDeploymentsInput) async throws -> BatchGetDeploymentsOutputResponse
    {
        typealias batchGetDeploymentsContinuation = CheckedContinuation<BatchGetDeploymentsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: batchGetDeploymentsContinuation) in
            batchGetDeployments(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Gets information about one or more on-premises instances. The maximum number of
    ///             on-premises instances that can be returned is 25.</p>
    func batchGetOnPremisesInstances(input: BatchGetOnPremisesInstancesInput) async throws -> BatchGetOnPremisesInstancesOutputResponse
    {
        typealias batchGetOnPremisesInstancesContinuation = CheckedContinuation<BatchGetOnPremisesInstancesOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: batchGetOnPremisesInstancesContinuation) in
            batchGetOnPremisesInstances(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>For a blue/green deployment, starts the process of rerouting traffic from instances in
    ///             the original environment to instances in the replacement environment without waiting for
    ///             a specified wait time to elapse. (Traffic rerouting, which is achieved by registering
    ///             instances in the replacement environment with the load balancer, can start as soon as
    ///             all instances have a status of Ready.) </p>
    func continueDeployment(input: ContinueDeploymentInput) async throws -> ContinueDeploymentOutputResponse
    {
        typealias continueDeploymentContinuation = CheckedContinuation<ContinueDeploymentOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: continueDeploymentContinuation) in
            continueDeployment(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Creates an application.</p>
    func createApplication(input: CreateApplicationInput) async throws -> CreateApplicationOutputResponse
    {
        typealias createApplicationContinuation = CheckedContinuation<CreateApplicationOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createApplicationContinuation) in
            createApplication(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Deploys an application revision through the specified deployment group.</p>
    func createDeployment(input: CreateDeploymentInput) async throws -> CreateDeploymentOutputResponse
    {
        typealias createDeploymentContinuation = CheckedContinuation<CreateDeploymentOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createDeploymentContinuation) in
            createDeployment(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p> Creates a deployment configuration. </p>
    func createDeploymentConfig(input: CreateDeploymentConfigInput) async throws -> CreateDeploymentConfigOutputResponse
    {
        typealias createDeploymentConfigContinuation = CheckedContinuation<CreateDeploymentConfigOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createDeploymentConfigContinuation) in
            createDeploymentConfig(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Creates a deployment group to which application revisions are deployed.</p>
    func createDeploymentGroup(input: CreateDeploymentGroupInput) async throws -> CreateDeploymentGroupOutputResponse
    {
        typealias createDeploymentGroupContinuation = CheckedContinuation<CreateDeploymentGroupOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createDeploymentGroupContinuation) in
            createDeploymentGroup(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Deletes an application.</p>
    func deleteApplication(input: DeleteApplicationInput) async throws -> DeleteApplicationOutputResponse
    {
        typealias deleteApplicationContinuation = CheckedContinuation<DeleteApplicationOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteApplicationContinuation) in
            deleteApplication(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Deletes a deployment configuration.</p>
    ///         <note>
    ///             <p>A deployment configuration cannot be deleted if it is currently in use. Predefined
    ///                 configurations cannot be deleted.</p>
    ///         </note>
    func deleteDeploymentConfig(input: DeleteDeploymentConfigInput) async throws -> DeleteDeploymentConfigOutputResponse
    {
        typealias deleteDeploymentConfigContinuation = CheckedContinuation<DeleteDeploymentConfigOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteDeploymentConfigContinuation) in
            deleteDeploymentConfig(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Deletes a deployment group.</p>
    func deleteDeploymentGroup(input: DeleteDeploymentGroupInput) async throws -> DeleteDeploymentGroupOutputResponse
    {
        typealias deleteDeploymentGroupContinuation = CheckedContinuation<DeleteDeploymentGroupOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteDeploymentGroupContinuation) in
            deleteDeploymentGroup(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Deletes a GitHub account connection.</p>
    func deleteGitHubAccountToken(input: DeleteGitHubAccountTokenInput) async throws -> DeleteGitHubAccountTokenOutputResponse
    {
        typealias deleteGitHubAccountTokenContinuation = CheckedContinuation<DeleteGitHubAccountTokenOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteGitHubAccountTokenContinuation) in
            deleteGitHubAccountToken(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Deletes resources linked to an external ID.</p>
    func deleteResourcesByExternalId(input: DeleteResourcesByExternalIdInput) async throws -> DeleteResourcesByExternalIdOutputResponse
    {
        typealias deleteResourcesByExternalIdContinuation = CheckedContinuation<DeleteResourcesByExternalIdOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteResourcesByExternalIdContinuation) in
            deleteResourcesByExternalId(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Deregisters an on-premises instance.</p>
    func deregisterOnPremisesInstance(input: DeregisterOnPremisesInstanceInput) async throws -> DeregisterOnPremisesInstanceOutputResponse
    {
        typealias deregisterOnPremisesInstanceContinuation = CheckedContinuation<DeregisterOnPremisesInstanceOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deregisterOnPremisesInstanceContinuation) in
            deregisterOnPremisesInstance(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Gets information about an application.</p>
    func getApplication(input: GetApplicationInput) async throws -> GetApplicationOutputResponse
    {
        typealias getApplicationContinuation = CheckedContinuation<GetApplicationOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getApplicationContinuation) in
            getApplication(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Gets information about an application revision.</p>
    func getApplicationRevision(input: GetApplicationRevisionInput) async throws -> GetApplicationRevisionOutputResponse
    {
        typealias getApplicationRevisionContinuation = CheckedContinuation<GetApplicationRevisionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getApplicationRevisionContinuation) in
            getApplicationRevision(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Gets information about a deployment.</p>
    ///         <note>
    ///             <p> The <code>content</code> property of the <code>appSpecContent</code> object in
    ///                 the returned revision is always null. Use <code>GetApplicationRevision</code> and
    ///                 the <code>sha256</code> property of the returned <code>appSpecContent</code> object
    ///                 to get the content of the deploymentâ€™s AppSpec file. </p>
    ///         </note>
    func getDeployment(input: GetDeploymentInput) async throws -> GetDeploymentOutputResponse
    {
        typealias getDeploymentContinuation = CheckedContinuation<GetDeploymentOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getDeploymentContinuation) in
            getDeployment(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Gets information about a deployment configuration.</p>
    func getDeploymentConfig(input: GetDeploymentConfigInput) async throws -> GetDeploymentConfigOutputResponse
    {
        typealias getDeploymentConfigContinuation = CheckedContinuation<GetDeploymentConfigOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getDeploymentConfigContinuation) in
            getDeploymentConfig(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Gets information about a deployment group.</p>
    func getDeploymentGroup(input: GetDeploymentGroupInput) async throws -> GetDeploymentGroupOutputResponse
    {
        typealias getDeploymentGroupContinuation = CheckedContinuation<GetDeploymentGroupOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getDeploymentGroupContinuation) in
            getDeploymentGroup(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Gets information about an instance as part of a deployment.</p>
    @available(*, deprecated, message: "This operation is deprecated, use GetDeploymentTarget instead.")
    func getDeploymentInstance(input: GetDeploymentInstanceInput) async throws -> GetDeploymentInstanceOutputResponse
    {
        typealias getDeploymentInstanceContinuation = CheckedContinuation<GetDeploymentInstanceOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getDeploymentInstanceContinuation) in
            getDeploymentInstance(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p> Returns information about a deployment target. </p>
    func getDeploymentTarget(input: GetDeploymentTargetInput) async throws -> GetDeploymentTargetOutputResponse
    {
        typealias getDeploymentTargetContinuation = CheckedContinuation<GetDeploymentTargetOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getDeploymentTargetContinuation) in
            getDeploymentTarget(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p> Gets information about an on-premises instance. </p>
    func getOnPremisesInstance(input: GetOnPremisesInstanceInput) async throws -> GetOnPremisesInstanceOutputResponse
    {
        typealias getOnPremisesInstanceContinuation = CheckedContinuation<GetOnPremisesInstanceOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getOnPremisesInstanceContinuation) in
            getOnPremisesInstance(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Lists information about revisions for an application.</p>
    func listApplicationRevisions(input: ListApplicationRevisionsInput) async throws -> ListApplicationRevisionsOutputResponse
    {
        typealias listApplicationRevisionsContinuation = CheckedContinuation<ListApplicationRevisionsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listApplicationRevisionsContinuation) in
            listApplicationRevisions(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Lists the applications registered with the IAM user or AWS account.</p>
    func listApplications(input: ListApplicationsInput) async throws -> ListApplicationsOutputResponse
    {
        typealias listApplicationsContinuation = CheckedContinuation<ListApplicationsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listApplicationsContinuation) in
            listApplications(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Lists the deployment configurations with the IAM user or AWS account.</p>
    func listDeploymentConfigs(input: ListDeploymentConfigsInput) async throws -> ListDeploymentConfigsOutputResponse
    {
        typealias listDeploymentConfigsContinuation = CheckedContinuation<ListDeploymentConfigsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listDeploymentConfigsContinuation) in
            listDeploymentConfigs(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Lists the deployment groups for an application registered with the IAM user or AWS
    ///             account.</p>
    func listDeploymentGroups(input: ListDeploymentGroupsInput) async throws -> ListDeploymentGroupsOutputResponse
    {
        typealias listDeploymentGroupsContinuation = CheckedContinuation<ListDeploymentGroupsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listDeploymentGroupsContinuation) in
            listDeploymentGroups(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <note>
    ///             <p> The newer <code>BatchGetDeploymentTargets</code> should be used instead because
    ///                 it works with all compute types. <code>ListDeploymentInstances</code> throws an
    ///                 exception if it is used with a compute platform other than EC2/On-premises or AWS
    ///                 Lambda. </p>
    ///         </note>
    ///         <p> Lists the instance for a deployment associated with the IAM user or AWS account. </p>
    @available(*, deprecated, message: "This operation is deprecated, use ListDeploymentTargets instead.")
    func listDeploymentInstances(input: ListDeploymentInstancesInput) async throws -> ListDeploymentInstancesOutputResponse
    {
        typealias listDeploymentInstancesContinuation = CheckedContinuation<ListDeploymentInstancesOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listDeploymentInstancesContinuation) in
            listDeploymentInstances(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p> Returns an array of target IDs that are associated a deployment. </p>
    func listDeploymentTargets(input: ListDeploymentTargetsInput) async throws -> ListDeploymentTargetsOutputResponse
    {
        typealias listDeploymentTargetsContinuation = CheckedContinuation<ListDeploymentTargetsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listDeploymentTargetsContinuation) in
            listDeploymentTargets(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Lists the deployments in a deployment group for an application registered with the IAM
    ///             user or AWS account.</p>
    func listDeployments(input: ListDeploymentsInput) async throws -> ListDeploymentsOutputResponse
    {
        typealias listDeploymentsContinuation = CheckedContinuation<ListDeploymentsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listDeploymentsContinuation) in
            listDeployments(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Lists the names of stored connections to GitHub accounts.</p>
    func listGitHubAccountTokenNames(input: ListGitHubAccountTokenNamesInput) async throws -> ListGitHubAccountTokenNamesOutputResponse
    {
        typealias listGitHubAccountTokenNamesContinuation = CheckedContinuation<ListGitHubAccountTokenNamesOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listGitHubAccountTokenNamesContinuation) in
            listGitHubAccountTokenNames(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Gets a list of names for one or more on-premises instances.</p>
    ///         <p>Unless otherwise specified, both registered and deregistered on-premises instance
    ///             names are listed. To list only registered or deregistered on-premises instance names,
    ///             use the registration status parameter.</p>
    func listOnPremisesInstances(input: ListOnPremisesInstancesInput) async throws -> ListOnPremisesInstancesOutputResponse
    {
        typealias listOnPremisesInstancesContinuation = CheckedContinuation<ListOnPremisesInstancesOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listOnPremisesInstancesContinuation) in
            listOnPremisesInstances(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p> Returns a list of tags for the resource identified by a specified Amazon Resource
    ///             Name (ARN). Tags are used to organize and categorize your CodeDeploy resources. </p>
    func listTagsForResource(input: ListTagsForResourceInput) async throws -> ListTagsForResourceOutputResponse
    {
        typealias listTagsForResourceContinuation = CheckedContinuation<ListTagsForResourceOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listTagsForResourceContinuation) in
            listTagsForResource(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p> Sets the result of a Lambda validation function. The function validates lifecycle
    ///             hooks during a deployment that uses the AWS Lambda or Amazon ECS compute platform. For
    ///             AWS Lambda deployments, the available lifecycle hooks are
    ///                 <code>BeforeAllowTraffic</code> and <code>AfterAllowTraffic</code>. For Amazon ECS
    ///             deployments, the available lifecycle hooks are <code>BeforeInstall</code>,
    ///                 <code>AfterInstall</code>, <code>AfterAllowTestTraffic</code>,
    ///                 <code>BeforeAllowTraffic</code>, and <code>AfterAllowTraffic</code>. Lambda
    ///             validation functions return <code>Succeeded</code> or <code>Failed</code>. For more
    ///             information, see <a href="https://docs.aws.amazon.com/codedeploy/latest/userguide/reference-appspec-file-structure-hooks.html#appspec-hooks-lambda">AppSpec 'hooks' Section for an AWS Lambda Deployment </a> and <a href="https://docs.aws.amazon.com/codedeploy/latest/userguide/reference-appspec-file-structure-hooks.html#appspec-hooks-ecs">AppSpec 'hooks' Section for an Amazon ECS Deployment</a>.</p>
    func putLifecycleEventHookExecutionStatus(input: PutLifecycleEventHookExecutionStatusInput) async throws -> PutLifecycleEventHookExecutionStatusOutputResponse
    {
        typealias putLifecycleEventHookExecutionStatusContinuation = CheckedContinuation<PutLifecycleEventHookExecutionStatusOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: putLifecycleEventHookExecutionStatusContinuation) in
            putLifecycleEventHookExecutionStatus(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Registers with AWS CodeDeploy a revision for the specified application.</p>
    func registerApplicationRevision(input: RegisterApplicationRevisionInput) async throws -> RegisterApplicationRevisionOutputResponse
    {
        typealias registerApplicationRevisionContinuation = CheckedContinuation<RegisterApplicationRevisionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: registerApplicationRevisionContinuation) in
            registerApplicationRevision(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Registers an on-premises instance.</p>
    ///         <note>
    ///             <p>Only one IAM ARN (an IAM session ARN or IAM user ARN) is supported in the request.
    ///                 You cannot use both.</p>
    ///         </note>
    func registerOnPremisesInstance(input: RegisterOnPremisesInstanceInput) async throws -> RegisterOnPremisesInstanceOutputResponse
    {
        typealias registerOnPremisesInstanceContinuation = CheckedContinuation<RegisterOnPremisesInstanceOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: registerOnPremisesInstanceContinuation) in
            registerOnPremisesInstance(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Removes one or more tags from one or more on-premises instances.</p>
    func removeTagsFromOnPremisesInstances(input: RemoveTagsFromOnPremisesInstancesInput) async throws -> RemoveTagsFromOnPremisesInstancesOutputResponse
    {
        typealias removeTagsFromOnPremisesInstancesContinuation = CheckedContinuation<RemoveTagsFromOnPremisesInstancesOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: removeTagsFromOnPremisesInstancesContinuation) in
            removeTagsFromOnPremisesInstances(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>In a blue/green deployment, overrides any specified wait time and starts terminating
    ///             instances immediately after the traffic routing is complete.</p>
    @available(*, deprecated, message: "This operation is deprecated, use ContinueDeployment with DeploymentWaitType instead.")
    func skipWaitTimeForInstanceTermination(input: SkipWaitTimeForInstanceTerminationInput) async throws -> SkipWaitTimeForInstanceTerminationOutputResponse
    {
        typealias skipWaitTimeForInstanceTerminationContinuation = CheckedContinuation<SkipWaitTimeForInstanceTerminationOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: skipWaitTimeForInstanceTerminationContinuation) in
            skipWaitTimeForInstanceTermination(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Attempts to stop an ongoing deployment.</p>
    func stopDeployment(input: StopDeploymentInput) async throws -> StopDeploymentOutputResponse
    {
        typealias stopDeploymentContinuation = CheckedContinuation<StopDeploymentOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: stopDeploymentContinuation) in
            stopDeployment(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p> Associates the list of tags in the input <code>Tags</code> parameter with the
    ///             resource identified by the <code>ResourceArn</code> input parameter. </p>
    func tagResource(input: TagResourceInput) async throws -> TagResourceOutputResponse
    {
        typealias tagResourceContinuation = CheckedContinuation<TagResourceOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: tagResourceContinuation) in
            tagResource(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p> Disassociates a resource from a list of tags. The resource is identified by the
    ///                 <code>ResourceArn</code> input parameter. The tags are identified by the list of
    ///             keys in the <code>TagKeys</code> input parameter. </p>
    func untagResource(input: UntagResourceInput) async throws -> UntagResourceOutputResponse
    {
        typealias untagResourceContinuation = CheckedContinuation<UntagResourceOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: untagResourceContinuation) in
            untagResource(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Changes the name of an application.</p>
    func updateApplication(input: UpdateApplicationInput) async throws -> UpdateApplicationOutputResponse
    {
        typealias updateApplicationContinuation = CheckedContinuation<UpdateApplicationOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: updateApplicationContinuation) in
            updateApplication(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Changes information about a deployment group.</p>
    func updateDeploymentGroup(input: UpdateDeploymentGroupInput) async throws -> UpdateDeploymentGroupOutputResponse
    {
        typealias updateDeploymentGroupContinuation = CheckedContinuation<UpdateDeploymentGroupOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: updateDeploymentGroupContinuation) in
            updateDeploymentGroup(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

}
#endif
