// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccessDeniedException(message: \(String(describing: message)))"}
}

extension AccessDeniedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You do not have sufficient access to perform this action.</p>
public struct AccessDeniedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Equatable {
    public let message: String?
}

extension AccessDeniedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ApplicationState: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applicationId = "ApplicationId"
        case applicationStatus = "ApplicationStatus"
        case lastUpdatedTime = "LastUpdatedTime"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationId = applicationId {
            try encodeContainer.encode(applicationId, forKey: .applicationId)
        }
        if let applicationStatus = applicationStatus {
            try encodeContainer.encode(applicationStatus.rawValue, forKey: .applicationStatus)
        }
        if let lastUpdatedTime = lastUpdatedTime {
            try encodeContainer.encode(lastUpdatedTime.timeIntervalSince1970, forKey: .lastUpdatedTime)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let applicationStatusDecoded = try containerValues.decodeIfPresent(ApplicationStatus.self, forKey: .applicationStatus)
        applicationStatus = applicationStatusDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
    }
}

extension ApplicationState: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ApplicationState(applicationId: \(String(describing: applicationId)), applicationStatus: \(String(describing: applicationStatus)), lastUpdatedTime: \(String(describing: lastUpdatedTime)))"}
}

/// <p>The state of an application discovered through Migration Hub import, the AWS Agentless
///          Discovery Connector, or the AWS Application Discovery Agent.</p>
public struct ApplicationState: Equatable {
    /// <p>The configurationId from the Application Discovery Service that uniquely identifies an
    ///          application.</p>
    public let applicationId: String?
    /// <p>The current status of an application.</p>
    public let applicationStatus: ApplicationStatus?
    /// <p>The timestamp when the application status was last updated.</p>
    public let lastUpdatedTime: Date?

    public init (
        applicationId: String? = nil,
        applicationStatus: ApplicationStatus? = nil,
        lastUpdatedTime: Date? = nil
    )
    {
        self.applicationId = applicationId
        self.applicationStatus = applicationStatus
        self.lastUpdatedTime = lastUpdatedTime
    }
}

public enum ApplicationStatus {
    case completed
    case inProgress
    case notStarted
    case sdkUnknown(String)
}

extension ApplicationStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ApplicationStatus] {
        return [
            .completed,
            .inProgress,
            .notStarted,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .completed: return "COMPLETED"
        case .inProgress: return "IN_PROGRESS"
        case .notStarted: return "NOT_STARTED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ApplicationStatus(rawValue: rawValue) ?? ApplicationStatus.sdkUnknown(rawValue)
    }
}

public struct AssociateCreatedArtifactInputBodyMiddleware: Middleware {
    public let id: String = "AssociateCreatedArtifactInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateCreatedArtifactInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateCreatedArtifactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateCreatedArtifactInput>
    public typealias MOutput = OperationOutput<AssociateCreatedArtifactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateCreatedArtifactOutputError>
}

extension AssociateCreatedArtifactInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateCreatedArtifactInput(createdArtifact: \(String(describing: createdArtifact)), dryRun: \(String(describing: dryRun)), migrationTaskName: \(String(describing: migrationTaskName)), progressUpdateStream: \(String(describing: progressUpdateStream)))"}
}

extension AssociateCreatedArtifactInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case createdArtifact = "CreatedArtifact"
        case dryRun = "DryRun"
        case migrationTaskName = "MigrationTaskName"
        case progressUpdateStream = "ProgressUpdateStream"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdArtifact = createdArtifact {
            try encodeContainer.encode(createdArtifact, forKey: .createdArtifact)
        }
        if dryRun != false {
            try encodeContainer.encode(dryRun, forKey: .dryRun)
        }
        if let migrationTaskName = migrationTaskName {
            try encodeContainer.encode(migrationTaskName, forKey: .migrationTaskName)
        }
        if let progressUpdateStream = progressUpdateStream {
            try encodeContainer.encode(progressUpdateStream, forKey: .progressUpdateStream)
        }
    }
}

public struct AssociateCreatedArtifactInputHeadersMiddleware: Middleware {
    public let id: String = "AssociateCreatedArtifactInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateCreatedArtifactInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateCreatedArtifactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateCreatedArtifactInput>
    public typealias MOutput = OperationOutput<AssociateCreatedArtifactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateCreatedArtifactOutputError>
}

public struct AssociateCreatedArtifactInputQueryItemMiddleware: Middleware {
    public let id: String = "AssociateCreatedArtifactInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateCreatedArtifactInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateCreatedArtifactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateCreatedArtifactInput>
    public typealias MOutput = OperationOutput<AssociateCreatedArtifactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateCreatedArtifactOutputError>
}

public struct AssociateCreatedArtifactInput: Equatable {
    /// <p>An ARN of the AWS resource related to the migration (e.g., AMI, EC2 instance, RDS
    ///          instance, etc.) </p>
    public let createdArtifact: CreatedArtifact?
    /// <p>Optional boolean flag to indicate whether any effect should take place. Used to test if
    ///          the caller has permission to make the call.</p>
    public let dryRun: Bool
    /// <p>Unique identifier that references the migration task. <i>Do not store personal
    ///             data in this field.</i>
    ///          </p>
    public let migrationTaskName: String?
    /// <p>The name of the ProgressUpdateStream. </p>
    public let progressUpdateStream: String?

    public init (
        createdArtifact: CreatedArtifact? = nil,
        dryRun: Bool = false,
        migrationTaskName: String? = nil,
        progressUpdateStream: String? = nil
    )
    {
        self.createdArtifact = createdArtifact
        self.dryRun = dryRun
        self.migrationTaskName = migrationTaskName
        self.progressUpdateStream = progressUpdateStream
    }
}

struct AssociateCreatedArtifactInputBody: Equatable {
    public let progressUpdateStream: String?
    public let migrationTaskName: String?
    public let createdArtifact: CreatedArtifact?
    public let dryRun: Bool
}

extension AssociateCreatedArtifactInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case createdArtifact = "CreatedArtifact"
        case dryRun = "DryRun"
        case migrationTaskName = "MigrationTaskName"
        case progressUpdateStream = "ProgressUpdateStream"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let progressUpdateStreamDecoded = try containerValues.decodeIfPresent(String.self, forKey: .progressUpdateStream)
        progressUpdateStream = progressUpdateStreamDecoded
        let migrationTaskNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .migrationTaskName)
        migrationTaskName = migrationTaskNameDecoded
        let createdArtifactDecoded = try containerValues.decodeIfPresent(CreatedArtifact.self, forKey: .createdArtifact)
        createdArtifact = createdArtifactDecoded
        let dryRunDecoded = try containerValues.decode(Bool.self, forKey: .dryRun)
        dryRun = dryRunDecoded
    }
}

extension AssociateCreatedArtifactOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateCreatedArtifactOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DryRunOperation" : self = .dryRunOperation(try DryRunOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HomeRegionNotSetException" : self = .homeRegionNotSetException(try HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperation" : self = .unauthorizedOperation(try UnauthorizedOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateCreatedArtifactOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case dryRunOperation(DryRunOperation)
    case homeRegionNotSetException(HomeRegionNotSetException)
    case internalServerError(InternalServerError)
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unauthorizedOperation(UnauthorizedOperation)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateCreatedArtifactOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateCreatedArtifactOutputResponse()"}
}

extension AssociateCreatedArtifactOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct AssociateCreatedArtifactOutputResponse: Equatable {

    public init() {}
}

struct AssociateCreatedArtifactOutputResponseBody: Equatable {
}

extension AssociateCreatedArtifactOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct AssociateDiscoveredResourceInputBodyMiddleware: Middleware {
    public let id: String = "AssociateDiscoveredResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateDiscoveredResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateDiscoveredResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateDiscoveredResourceInput>
    public typealias MOutput = OperationOutput<AssociateDiscoveredResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateDiscoveredResourceOutputError>
}

extension AssociateDiscoveredResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateDiscoveredResourceInput(discoveredResource: \(String(describing: discoveredResource)), dryRun: \(String(describing: dryRun)), migrationTaskName: \(String(describing: migrationTaskName)), progressUpdateStream: \(String(describing: progressUpdateStream)))"}
}

extension AssociateDiscoveredResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case discoveredResource = "DiscoveredResource"
        case dryRun = "DryRun"
        case migrationTaskName = "MigrationTaskName"
        case progressUpdateStream = "ProgressUpdateStream"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let discoveredResource = discoveredResource {
            try encodeContainer.encode(discoveredResource, forKey: .discoveredResource)
        }
        if dryRun != false {
            try encodeContainer.encode(dryRun, forKey: .dryRun)
        }
        if let migrationTaskName = migrationTaskName {
            try encodeContainer.encode(migrationTaskName, forKey: .migrationTaskName)
        }
        if let progressUpdateStream = progressUpdateStream {
            try encodeContainer.encode(progressUpdateStream, forKey: .progressUpdateStream)
        }
    }
}

public struct AssociateDiscoveredResourceInputHeadersMiddleware: Middleware {
    public let id: String = "AssociateDiscoveredResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateDiscoveredResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateDiscoveredResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateDiscoveredResourceInput>
    public typealias MOutput = OperationOutput<AssociateDiscoveredResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateDiscoveredResourceOutputError>
}

public struct AssociateDiscoveredResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "AssociateDiscoveredResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateDiscoveredResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateDiscoveredResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateDiscoveredResourceInput>
    public typealias MOutput = OperationOutput<AssociateDiscoveredResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateDiscoveredResourceOutputError>
}

public struct AssociateDiscoveredResourceInput: Equatable {
    /// <p>Object representing a Resource.</p>
    public let discoveredResource: DiscoveredResource?
    /// <p>Optional boolean flag to indicate whether any effect should take place. Used to test if
    ///          the caller has permission to make the call.</p>
    public let dryRun: Bool
    /// <p>The identifier given to the MigrationTask. <i>Do not store personal data in this
    ///             field.</i>
    ///          </p>
    public let migrationTaskName: String?
    /// <p>The name of the ProgressUpdateStream.</p>
    public let progressUpdateStream: String?

    public init (
        discoveredResource: DiscoveredResource? = nil,
        dryRun: Bool = false,
        migrationTaskName: String? = nil,
        progressUpdateStream: String? = nil
    )
    {
        self.discoveredResource = discoveredResource
        self.dryRun = dryRun
        self.migrationTaskName = migrationTaskName
        self.progressUpdateStream = progressUpdateStream
    }
}

struct AssociateDiscoveredResourceInputBody: Equatable {
    public let progressUpdateStream: String?
    public let migrationTaskName: String?
    public let discoveredResource: DiscoveredResource?
    public let dryRun: Bool
}

extension AssociateDiscoveredResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case discoveredResource = "DiscoveredResource"
        case dryRun = "DryRun"
        case migrationTaskName = "MigrationTaskName"
        case progressUpdateStream = "ProgressUpdateStream"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let progressUpdateStreamDecoded = try containerValues.decodeIfPresent(String.self, forKey: .progressUpdateStream)
        progressUpdateStream = progressUpdateStreamDecoded
        let migrationTaskNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .migrationTaskName)
        migrationTaskName = migrationTaskNameDecoded
        let discoveredResourceDecoded = try containerValues.decodeIfPresent(DiscoveredResource.self, forKey: .discoveredResource)
        discoveredResource = discoveredResourceDecoded
        let dryRunDecoded = try containerValues.decode(Bool.self, forKey: .dryRun)
        dryRun = dryRunDecoded
    }
}

extension AssociateDiscoveredResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateDiscoveredResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DryRunOperation" : self = .dryRunOperation(try DryRunOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HomeRegionNotSetException" : self = .homeRegionNotSetException(try HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PolicyErrorException" : self = .policyErrorException(try PolicyErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperation" : self = .unauthorizedOperation(try UnauthorizedOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateDiscoveredResourceOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case dryRunOperation(DryRunOperation)
    case homeRegionNotSetException(HomeRegionNotSetException)
    case internalServerError(InternalServerError)
    case invalidInputException(InvalidInputException)
    case policyErrorException(PolicyErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unauthorizedOperation(UnauthorizedOperation)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateDiscoveredResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateDiscoveredResourceOutputResponse()"}
}

extension AssociateDiscoveredResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct AssociateDiscoveredResourceOutputResponse: Equatable {

    public init() {}
}

struct AssociateDiscoveredResourceOutputResponseBody: Equatable {
}

extension AssociateDiscoveredResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct CreateProgressUpdateStreamInputBodyMiddleware: Middleware {
    public let id: String = "CreateProgressUpdateStreamInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateProgressUpdateStreamInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateProgressUpdateStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateProgressUpdateStreamInput>
    public typealias MOutput = OperationOutput<CreateProgressUpdateStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateProgressUpdateStreamOutputError>
}

extension CreateProgressUpdateStreamInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateProgressUpdateStreamInput(dryRun: \(String(describing: dryRun)), progressUpdateStreamName: \(String(describing: progressUpdateStreamName)))"}
}

extension CreateProgressUpdateStreamInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case progressUpdateStreamName = "ProgressUpdateStreamName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if dryRun != false {
            try encodeContainer.encode(dryRun, forKey: .dryRun)
        }
        if let progressUpdateStreamName = progressUpdateStreamName {
            try encodeContainer.encode(progressUpdateStreamName, forKey: .progressUpdateStreamName)
        }
    }
}

public struct CreateProgressUpdateStreamInputHeadersMiddleware: Middleware {
    public let id: String = "CreateProgressUpdateStreamInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateProgressUpdateStreamInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateProgressUpdateStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateProgressUpdateStreamInput>
    public typealias MOutput = OperationOutput<CreateProgressUpdateStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateProgressUpdateStreamOutputError>
}

public struct CreateProgressUpdateStreamInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateProgressUpdateStreamInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateProgressUpdateStreamInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateProgressUpdateStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateProgressUpdateStreamInput>
    public typealias MOutput = OperationOutput<CreateProgressUpdateStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateProgressUpdateStreamOutputError>
}

public struct CreateProgressUpdateStreamInput: Equatable {
    /// <p>Optional boolean flag to indicate whether any effect should take place. Used to test if
    ///          the caller has permission to make the call.</p>
    public let dryRun: Bool
    /// <p>The name of the ProgressUpdateStream. <i>Do not store personal data in this
    ///             field.</i>
    ///          </p>
    public let progressUpdateStreamName: String?

    public init (
        dryRun: Bool = false,
        progressUpdateStreamName: String? = nil
    )
    {
        self.dryRun = dryRun
        self.progressUpdateStreamName = progressUpdateStreamName
    }
}

struct CreateProgressUpdateStreamInputBody: Equatable {
    public let progressUpdateStreamName: String?
    public let dryRun: Bool
}

extension CreateProgressUpdateStreamInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case progressUpdateStreamName = "ProgressUpdateStreamName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let progressUpdateStreamNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .progressUpdateStreamName)
        progressUpdateStreamName = progressUpdateStreamNameDecoded
        let dryRunDecoded = try containerValues.decode(Bool.self, forKey: .dryRun)
        dryRun = dryRunDecoded
    }
}

extension CreateProgressUpdateStreamOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateProgressUpdateStreamOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DryRunOperation" : self = .dryRunOperation(try DryRunOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HomeRegionNotSetException" : self = .homeRegionNotSetException(try HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperation" : self = .unauthorizedOperation(try UnauthorizedOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateProgressUpdateStreamOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case dryRunOperation(DryRunOperation)
    case homeRegionNotSetException(HomeRegionNotSetException)
    case internalServerError(InternalServerError)
    case invalidInputException(InvalidInputException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unauthorizedOperation(UnauthorizedOperation)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateProgressUpdateStreamOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateProgressUpdateStreamOutputResponse()"}
}

extension CreateProgressUpdateStreamOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct CreateProgressUpdateStreamOutputResponse: Equatable {

    public init() {}
}

struct CreateProgressUpdateStreamOutputResponseBody: Equatable {
}

extension CreateProgressUpdateStreamOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension CreatedArtifact: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension CreatedArtifact: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreatedArtifact(description: \(String(describing: description)), name: \(String(describing: name)))"}
}

/// <p>An ARN of the AWS cloud resource target receiving the migration (e.g., AMI, EC2
///          instance, RDS instance, etc.).</p>
public struct CreatedArtifact: Equatable {
    /// <p>A description that can be free-form text to record additional detail about the artifact
    ///          for clarity or for later reference.</p>
    public let description: String?
    /// <p>An ARN that uniquely identifies the result of a migration task.</p>
    public let name: String?

    public init (
        description: String? = nil,
        name: String? = nil
    )
    {
        self.description = description
        self.name = name
    }
}

public struct DeleteProgressUpdateStreamInputBodyMiddleware: Middleware {
    public let id: String = "DeleteProgressUpdateStreamInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteProgressUpdateStreamInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteProgressUpdateStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteProgressUpdateStreamInput>
    public typealias MOutput = OperationOutput<DeleteProgressUpdateStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteProgressUpdateStreamOutputError>
}

extension DeleteProgressUpdateStreamInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteProgressUpdateStreamInput(dryRun: \(String(describing: dryRun)), progressUpdateStreamName: \(String(describing: progressUpdateStreamName)))"}
}

extension DeleteProgressUpdateStreamInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case progressUpdateStreamName = "ProgressUpdateStreamName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if dryRun != false {
            try encodeContainer.encode(dryRun, forKey: .dryRun)
        }
        if let progressUpdateStreamName = progressUpdateStreamName {
            try encodeContainer.encode(progressUpdateStreamName, forKey: .progressUpdateStreamName)
        }
    }
}

public struct DeleteProgressUpdateStreamInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteProgressUpdateStreamInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteProgressUpdateStreamInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteProgressUpdateStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteProgressUpdateStreamInput>
    public typealias MOutput = OperationOutput<DeleteProgressUpdateStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteProgressUpdateStreamOutputError>
}

public struct DeleteProgressUpdateStreamInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteProgressUpdateStreamInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteProgressUpdateStreamInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteProgressUpdateStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteProgressUpdateStreamInput>
    public typealias MOutput = OperationOutput<DeleteProgressUpdateStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteProgressUpdateStreamOutputError>
}

public struct DeleteProgressUpdateStreamInput: Equatable {
    /// <p>Optional boolean flag to indicate whether any effect should take place. Used to test if
    ///          the caller has permission to make the call.</p>
    public let dryRun: Bool
    /// <p>The name of the ProgressUpdateStream. <i>Do not store personal data in this
    ///             field.</i>
    ///          </p>
    public let progressUpdateStreamName: String?

    public init (
        dryRun: Bool = false,
        progressUpdateStreamName: String? = nil
    )
    {
        self.dryRun = dryRun
        self.progressUpdateStreamName = progressUpdateStreamName
    }
}

struct DeleteProgressUpdateStreamInputBody: Equatable {
    public let progressUpdateStreamName: String?
    public let dryRun: Bool
}

extension DeleteProgressUpdateStreamInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case progressUpdateStreamName = "ProgressUpdateStreamName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let progressUpdateStreamNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .progressUpdateStreamName)
        progressUpdateStreamName = progressUpdateStreamNameDecoded
        let dryRunDecoded = try containerValues.decode(Bool.self, forKey: .dryRun)
        dryRun = dryRunDecoded
    }
}

extension DeleteProgressUpdateStreamOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteProgressUpdateStreamOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DryRunOperation" : self = .dryRunOperation(try DryRunOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HomeRegionNotSetException" : self = .homeRegionNotSetException(try HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperation" : self = .unauthorizedOperation(try UnauthorizedOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteProgressUpdateStreamOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case dryRunOperation(DryRunOperation)
    case homeRegionNotSetException(HomeRegionNotSetException)
    case internalServerError(InternalServerError)
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unauthorizedOperation(UnauthorizedOperation)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteProgressUpdateStreamOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteProgressUpdateStreamOutputResponse()"}
}

extension DeleteProgressUpdateStreamOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteProgressUpdateStreamOutputResponse: Equatable {

    public init() {}
}

struct DeleteProgressUpdateStreamOutputResponseBody: Equatable {
}

extension DeleteProgressUpdateStreamOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DescribeApplicationStateInputBodyMiddleware: Middleware {
    public let id: String = "DescribeApplicationStateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeApplicationStateInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeApplicationStateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeApplicationStateInput>
    public typealias MOutput = OperationOutput<DescribeApplicationStateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeApplicationStateOutputError>
}

extension DescribeApplicationStateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeApplicationStateInput(applicationId: \(String(describing: applicationId)))"}
}

extension DescribeApplicationStateInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applicationId = "ApplicationId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationId = applicationId {
            try encodeContainer.encode(applicationId, forKey: .applicationId)
        }
    }
}

public struct DescribeApplicationStateInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeApplicationStateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeApplicationStateInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeApplicationStateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeApplicationStateInput>
    public typealias MOutput = OperationOutput<DescribeApplicationStateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeApplicationStateOutputError>
}

public struct DescribeApplicationStateInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeApplicationStateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeApplicationStateInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeApplicationStateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeApplicationStateInput>
    public typealias MOutput = OperationOutput<DescribeApplicationStateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeApplicationStateOutputError>
}

public struct DescribeApplicationStateInput: Equatable {
    /// <p>The configurationId in Application Discovery Service that uniquely identifies the
    ///          grouped application.</p>
    public let applicationId: String?

    public init (
        applicationId: String? = nil
    )
    {
        self.applicationId = applicationId
    }
}

struct DescribeApplicationStateInputBody: Equatable {
    public let applicationId: String?
}

extension DescribeApplicationStateInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case applicationId = "ApplicationId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
    }
}

extension DescribeApplicationStateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeApplicationStateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HomeRegionNotSetException" : self = .homeRegionNotSetException(try HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PolicyErrorException" : self = .policyErrorException(try PolicyErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeApplicationStateOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case homeRegionNotSetException(HomeRegionNotSetException)
    case internalServerError(InternalServerError)
    case invalidInputException(InvalidInputException)
    case policyErrorException(PolicyErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeApplicationStateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeApplicationStateOutputResponse(applicationStatus: \(String(describing: applicationStatus)), lastUpdatedTime: \(String(describing: lastUpdatedTime)))"}
}

extension DescribeApplicationStateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeApplicationStateOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.applicationStatus = output.applicationStatus
            self.lastUpdatedTime = output.lastUpdatedTime
        } else {
            self.applicationStatus = nil
            self.lastUpdatedTime = nil
        }
    }
}

public struct DescribeApplicationStateOutputResponse: Equatable {
    /// <p>Status of the application - Not Started, In-Progress, Complete.</p>
    public let applicationStatus: ApplicationStatus?
    /// <p>The timestamp when the application status was last updated.</p>
    public let lastUpdatedTime: Date?

    public init (
        applicationStatus: ApplicationStatus? = nil,
        lastUpdatedTime: Date? = nil
    )
    {
        self.applicationStatus = applicationStatus
        self.lastUpdatedTime = lastUpdatedTime
    }
}

struct DescribeApplicationStateOutputResponseBody: Equatable {
    public let applicationStatus: ApplicationStatus?
    public let lastUpdatedTime: Date?
}

extension DescribeApplicationStateOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case applicationStatus = "ApplicationStatus"
        case lastUpdatedTime = "LastUpdatedTime"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationStatusDecoded = try containerValues.decodeIfPresent(ApplicationStatus.self, forKey: .applicationStatus)
        applicationStatus = applicationStatusDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
    }
}

public struct DescribeMigrationTaskInputBodyMiddleware: Middleware {
    public let id: String = "DescribeMigrationTaskInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeMigrationTaskInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeMigrationTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeMigrationTaskInput>
    public typealias MOutput = OperationOutput<DescribeMigrationTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeMigrationTaskOutputError>
}

extension DescribeMigrationTaskInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeMigrationTaskInput(migrationTaskName: \(String(describing: migrationTaskName)), progressUpdateStream: \(String(describing: progressUpdateStream)))"}
}

extension DescribeMigrationTaskInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case migrationTaskName = "MigrationTaskName"
        case progressUpdateStream = "ProgressUpdateStream"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let migrationTaskName = migrationTaskName {
            try encodeContainer.encode(migrationTaskName, forKey: .migrationTaskName)
        }
        if let progressUpdateStream = progressUpdateStream {
            try encodeContainer.encode(progressUpdateStream, forKey: .progressUpdateStream)
        }
    }
}

public struct DescribeMigrationTaskInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeMigrationTaskInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeMigrationTaskInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeMigrationTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeMigrationTaskInput>
    public typealias MOutput = OperationOutput<DescribeMigrationTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeMigrationTaskOutputError>
}

public struct DescribeMigrationTaskInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeMigrationTaskInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeMigrationTaskInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeMigrationTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeMigrationTaskInput>
    public typealias MOutput = OperationOutput<DescribeMigrationTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeMigrationTaskOutputError>
}

public struct DescribeMigrationTaskInput: Equatable {
    /// <p>The identifier given to the MigrationTask. <i>Do not store personal data in this
    ///             field.</i>
    ///          </p>
    public let migrationTaskName: String?
    /// <p>The name of the ProgressUpdateStream. </p>
    public let progressUpdateStream: String?

    public init (
        migrationTaskName: String? = nil,
        progressUpdateStream: String? = nil
    )
    {
        self.migrationTaskName = migrationTaskName
        self.progressUpdateStream = progressUpdateStream
    }
}

struct DescribeMigrationTaskInputBody: Equatable {
    public let progressUpdateStream: String?
    public let migrationTaskName: String?
}

extension DescribeMigrationTaskInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case migrationTaskName = "MigrationTaskName"
        case progressUpdateStream = "ProgressUpdateStream"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let progressUpdateStreamDecoded = try containerValues.decodeIfPresent(String.self, forKey: .progressUpdateStream)
        progressUpdateStream = progressUpdateStreamDecoded
        let migrationTaskNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .migrationTaskName)
        migrationTaskName = migrationTaskNameDecoded
    }
}

extension DescribeMigrationTaskOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeMigrationTaskOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HomeRegionNotSetException" : self = .homeRegionNotSetException(try HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeMigrationTaskOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case homeRegionNotSetException(HomeRegionNotSetException)
    case internalServerError(InternalServerError)
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeMigrationTaskOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeMigrationTaskOutputResponse(migrationTask: \(String(describing: migrationTask)))"}
}

extension DescribeMigrationTaskOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeMigrationTaskOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.migrationTask = output.migrationTask
        } else {
            self.migrationTask = nil
        }
    }
}

public struct DescribeMigrationTaskOutputResponse: Equatable {
    /// <p>Object encapsulating information about the migration task.</p>
    public let migrationTask: MigrationTask?

    public init (
        migrationTask: MigrationTask? = nil
    )
    {
        self.migrationTask = migrationTask
    }
}

struct DescribeMigrationTaskOutputResponseBody: Equatable {
    public let migrationTask: MigrationTask?
}

extension DescribeMigrationTaskOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case migrationTask = "MigrationTask"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let migrationTaskDecoded = try containerValues.decodeIfPresent(MigrationTask.self, forKey: .migrationTask)
        migrationTask = migrationTaskDecoded
    }
}

public struct DisassociateCreatedArtifactInputBodyMiddleware: Middleware {
    public let id: String = "DisassociateCreatedArtifactInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateCreatedArtifactInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateCreatedArtifactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateCreatedArtifactInput>
    public typealias MOutput = OperationOutput<DisassociateCreatedArtifactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateCreatedArtifactOutputError>
}

extension DisassociateCreatedArtifactInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateCreatedArtifactInput(createdArtifactName: \(String(describing: createdArtifactName)), dryRun: \(String(describing: dryRun)), migrationTaskName: \(String(describing: migrationTaskName)), progressUpdateStream: \(String(describing: progressUpdateStream)))"}
}

extension DisassociateCreatedArtifactInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case createdArtifactName = "CreatedArtifactName"
        case dryRun = "DryRun"
        case migrationTaskName = "MigrationTaskName"
        case progressUpdateStream = "ProgressUpdateStream"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdArtifactName = createdArtifactName {
            try encodeContainer.encode(createdArtifactName, forKey: .createdArtifactName)
        }
        if dryRun != false {
            try encodeContainer.encode(dryRun, forKey: .dryRun)
        }
        if let migrationTaskName = migrationTaskName {
            try encodeContainer.encode(migrationTaskName, forKey: .migrationTaskName)
        }
        if let progressUpdateStream = progressUpdateStream {
            try encodeContainer.encode(progressUpdateStream, forKey: .progressUpdateStream)
        }
    }
}

public struct DisassociateCreatedArtifactInputHeadersMiddleware: Middleware {
    public let id: String = "DisassociateCreatedArtifactInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateCreatedArtifactInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateCreatedArtifactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateCreatedArtifactInput>
    public typealias MOutput = OperationOutput<DisassociateCreatedArtifactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateCreatedArtifactOutputError>
}

public struct DisassociateCreatedArtifactInputQueryItemMiddleware: Middleware {
    public let id: String = "DisassociateCreatedArtifactInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateCreatedArtifactInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateCreatedArtifactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateCreatedArtifactInput>
    public typealias MOutput = OperationOutput<DisassociateCreatedArtifactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateCreatedArtifactOutputError>
}

public struct DisassociateCreatedArtifactInput: Equatable {
    /// <p>An ARN of the AWS resource related to the migration (e.g., AMI, EC2 instance, RDS
    ///          instance, etc.)</p>
    public let createdArtifactName: String?
    /// <p>Optional boolean flag to indicate whether any effect should take place. Used to test if
    ///          the caller has permission to make the call.</p>
    public let dryRun: Bool
    /// <p>Unique identifier that references the migration task to be disassociated with the
    ///          artifact. <i>Do not store personal data in this field.</i>
    ///          </p>
    public let migrationTaskName: String?
    /// <p>The name of the ProgressUpdateStream. </p>
    public let progressUpdateStream: String?

    public init (
        createdArtifactName: String? = nil,
        dryRun: Bool = false,
        migrationTaskName: String? = nil,
        progressUpdateStream: String? = nil
    )
    {
        self.createdArtifactName = createdArtifactName
        self.dryRun = dryRun
        self.migrationTaskName = migrationTaskName
        self.progressUpdateStream = progressUpdateStream
    }
}

struct DisassociateCreatedArtifactInputBody: Equatable {
    public let progressUpdateStream: String?
    public let migrationTaskName: String?
    public let createdArtifactName: String?
    public let dryRun: Bool
}

extension DisassociateCreatedArtifactInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case createdArtifactName = "CreatedArtifactName"
        case dryRun = "DryRun"
        case migrationTaskName = "MigrationTaskName"
        case progressUpdateStream = "ProgressUpdateStream"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let progressUpdateStreamDecoded = try containerValues.decodeIfPresent(String.self, forKey: .progressUpdateStream)
        progressUpdateStream = progressUpdateStreamDecoded
        let migrationTaskNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .migrationTaskName)
        migrationTaskName = migrationTaskNameDecoded
        let createdArtifactNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createdArtifactName)
        createdArtifactName = createdArtifactNameDecoded
        let dryRunDecoded = try containerValues.decode(Bool.self, forKey: .dryRun)
        dryRun = dryRunDecoded
    }
}

extension DisassociateCreatedArtifactOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateCreatedArtifactOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DryRunOperation" : self = .dryRunOperation(try DryRunOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HomeRegionNotSetException" : self = .homeRegionNotSetException(try HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperation" : self = .unauthorizedOperation(try UnauthorizedOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateCreatedArtifactOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case dryRunOperation(DryRunOperation)
    case homeRegionNotSetException(HomeRegionNotSetException)
    case internalServerError(InternalServerError)
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unauthorizedOperation(UnauthorizedOperation)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateCreatedArtifactOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateCreatedArtifactOutputResponse()"}
}

extension DisassociateCreatedArtifactOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateCreatedArtifactOutputResponse: Equatable {

    public init() {}
}

struct DisassociateCreatedArtifactOutputResponseBody: Equatable {
}

extension DisassociateCreatedArtifactOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DisassociateDiscoveredResourceInputBodyMiddleware: Middleware {
    public let id: String = "DisassociateDiscoveredResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateDiscoveredResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateDiscoveredResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateDiscoveredResourceInput>
    public typealias MOutput = OperationOutput<DisassociateDiscoveredResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateDiscoveredResourceOutputError>
}

extension DisassociateDiscoveredResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateDiscoveredResourceInput(configurationId: \(String(describing: configurationId)), dryRun: \(String(describing: dryRun)), migrationTaskName: \(String(describing: migrationTaskName)), progressUpdateStream: \(String(describing: progressUpdateStream)))"}
}

extension DisassociateDiscoveredResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case configurationId = "ConfigurationId"
        case dryRun = "DryRun"
        case migrationTaskName = "MigrationTaskName"
        case progressUpdateStream = "ProgressUpdateStream"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationId = configurationId {
            try encodeContainer.encode(configurationId, forKey: .configurationId)
        }
        if dryRun != false {
            try encodeContainer.encode(dryRun, forKey: .dryRun)
        }
        if let migrationTaskName = migrationTaskName {
            try encodeContainer.encode(migrationTaskName, forKey: .migrationTaskName)
        }
        if let progressUpdateStream = progressUpdateStream {
            try encodeContainer.encode(progressUpdateStream, forKey: .progressUpdateStream)
        }
    }
}

public struct DisassociateDiscoveredResourceInputHeadersMiddleware: Middleware {
    public let id: String = "DisassociateDiscoveredResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateDiscoveredResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateDiscoveredResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateDiscoveredResourceInput>
    public typealias MOutput = OperationOutput<DisassociateDiscoveredResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateDiscoveredResourceOutputError>
}

public struct DisassociateDiscoveredResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "DisassociateDiscoveredResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateDiscoveredResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateDiscoveredResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateDiscoveredResourceInput>
    public typealias MOutput = OperationOutput<DisassociateDiscoveredResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateDiscoveredResourceOutputError>
}

public struct DisassociateDiscoveredResourceInput: Equatable {
    /// <p>ConfigurationId of the Application Discovery Service resource to be
    ///          disassociated.</p>
    public let configurationId: String?
    /// <p>Optional boolean flag to indicate whether any effect should take place. Used to test if
    ///          the caller has permission to make the call.</p>
    public let dryRun: Bool
    /// <p>The identifier given to the MigrationTask. <i>Do not store personal data in this
    ///             field.</i>
    ///          </p>
    public let migrationTaskName: String?
    /// <p>The name of the ProgressUpdateStream.</p>
    public let progressUpdateStream: String?

    public init (
        configurationId: String? = nil,
        dryRun: Bool = false,
        migrationTaskName: String? = nil,
        progressUpdateStream: String? = nil
    )
    {
        self.configurationId = configurationId
        self.dryRun = dryRun
        self.migrationTaskName = migrationTaskName
        self.progressUpdateStream = progressUpdateStream
    }
}

struct DisassociateDiscoveredResourceInputBody: Equatable {
    public let progressUpdateStream: String?
    public let migrationTaskName: String?
    public let configurationId: String?
    public let dryRun: Bool
}

extension DisassociateDiscoveredResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case configurationId = "ConfigurationId"
        case dryRun = "DryRun"
        case migrationTaskName = "MigrationTaskName"
        case progressUpdateStream = "ProgressUpdateStream"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let progressUpdateStreamDecoded = try containerValues.decodeIfPresent(String.self, forKey: .progressUpdateStream)
        progressUpdateStream = progressUpdateStreamDecoded
        let migrationTaskNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .migrationTaskName)
        migrationTaskName = migrationTaskNameDecoded
        let configurationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .configurationId)
        configurationId = configurationIdDecoded
        let dryRunDecoded = try containerValues.decode(Bool.self, forKey: .dryRun)
        dryRun = dryRunDecoded
    }
}

extension DisassociateDiscoveredResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateDiscoveredResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DryRunOperation" : self = .dryRunOperation(try DryRunOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HomeRegionNotSetException" : self = .homeRegionNotSetException(try HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperation" : self = .unauthorizedOperation(try UnauthorizedOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateDiscoveredResourceOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case dryRunOperation(DryRunOperation)
    case homeRegionNotSetException(HomeRegionNotSetException)
    case internalServerError(InternalServerError)
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unauthorizedOperation(UnauthorizedOperation)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateDiscoveredResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateDiscoveredResourceOutputResponse()"}
}

extension DisassociateDiscoveredResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateDiscoveredResourceOutputResponse: Equatable {

    public init() {}
}

struct DisassociateDiscoveredResourceOutputResponseBody: Equatable {
}

extension DisassociateDiscoveredResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DiscoveredResource: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case configurationId = "ConfigurationId"
        case description = "Description"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationId = configurationId {
            try encodeContainer.encode(configurationId, forKey: .configurationId)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .configurationId)
        configurationId = configurationIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension DiscoveredResource: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DiscoveredResource(configurationId: \(String(describing: configurationId)), description: \(String(describing: description)))"}
}

/// <p>Object representing the on-premises resource being migrated.</p>
public struct DiscoveredResource: Equatable {
    /// <p>The configurationId in Application Discovery Service that uniquely identifies the
    ///          on-premise resource.</p>
    public let configurationId: String?
    /// <p>A description that can be free-form text to record additional detail about the
    ///          discovered resource for clarity or later reference.</p>
    public let description: String?

    public init (
        configurationId: String? = nil,
        description: String? = nil
    )
    {
        self.configurationId = configurationId
        self.description = description
    }
}

extension DryRunOperation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DryRunOperation(message: \(String(describing: message)))"}
}

extension DryRunOperation: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DryRunOperationBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Exception raised to indicate a successfully authorized action when the
///             <code>DryRun</code> flag is set to "true".</p>
public struct DryRunOperation: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DryRunOperationBody: Equatable {
    public let message: String?
}

extension DryRunOperationBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension HomeRegionNotSetException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "HomeRegionNotSetException(message: \(String(describing: message)))"}
}

extension HomeRegionNotSetException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: HomeRegionNotSetExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The home region is not set. Set the home region to continue.</p>
public struct HomeRegionNotSetException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct HomeRegionNotSetExceptionBody: Equatable {
    public let message: String?
}

extension HomeRegionNotSetExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ImportMigrationTaskInputBodyMiddleware: Middleware {
    public let id: String = "ImportMigrationTaskInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ImportMigrationTaskInput>,
                  next: H) -> Swift.Result<OperationOutput<ImportMigrationTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ImportMigrationTaskInput>
    public typealias MOutput = OperationOutput<ImportMigrationTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ImportMigrationTaskOutputError>
}

extension ImportMigrationTaskInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ImportMigrationTaskInput(dryRun: \(String(describing: dryRun)), migrationTaskName: \(String(describing: migrationTaskName)), progressUpdateStream: \(String(describing: progressUpdateStream)))"}
}

extension ImportMigrationTaskInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case migrationTaskName = "MigrationTaskName"
        case progressUpdateStream = "ProgressUpdateStream"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if dryRun != false {
            try encodeContainer.encode(dryRun, forKey: .dryRun)
        }
        if let migrationTaskName = migrationTaskName {
            try encodeContainer.encode(migrationTaskName, forKey: .migrationTaskName)
        }
        if let progressUpdateStream = progressUpdateStream {
            try encodeContainer.encode(progressUpdateStream, forKey: .progressUpdateStream)
        }
    }
}

public struct ImportMigrationTaskInputHeadersMiddleware: Middleware {
    public let id: String = "ImportMigrationTaskInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ImportMigrationTaskInput>,
                  next: H) -> Swift.Result<OperationOutput<ImportMigrationTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ImportMigrationTaskInput>
    public typealias MOutput = OperationOutput<ImportMigrationTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ImportMigrationTaskOutputError>
}

public struct ImportMigrationTaskInputQueryItemMiddleware: Middleware {
    public let id: String = "ImportMigrationTaskInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ImportMigrationTaskInput>,
                  next: H) -> Swift.Result<OperationOutput<ImportMigrationTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ImportMigrationTaskInput>
    public typealias MOutput = OperationOutput<ImportMigrationTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ImportMigrationTaskOutputError>
}

public struct ImportMigrationTaskInput: Equatable {
    /// <p>Optional boolean flag to indicate whether any effect should take place. Used to test if
    ///          the caller has permission to make the call.</p>
    public let dryRun: Bool
    /// <p>Unique identifier that references the migration task. <i>Do not store personal
    ///             data in this field.</i>
    ///          </p>
    public let migrationTaskName: String?
    /// <p>The name of the ProgressUpdateStream. ></p>
    public let progressUpdateStream: String?

    public init (
        dryRun: Bool = false,
        migrationTaskName: String? = nil,
        progressUpdateStream: String? = nil
    )
    {
        self.dryRun = dryRun
        self.migrationTaskName = migrationTaskName
        self.progressUpdateStream = progressUpdateStream
    }
}

struct ImportMigrationTaskInputBody: Equatable {
    public let progressUpdateStream: String?
    public let migrationTaskName: String?
    public let dryRun: Bool
}

extension ImportMigrationTaskInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case migrationTaskName = "MigrationTaskName"
        case progressUpdateStream = "ProgressUpdateStream"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let progressUpdateStreamDecoded = try containerValues.decodeIfPresent(String.self, forKey: .progressUpdateStream)
        progressUpdateStream = progressUpdateStreamDecoded
        let migrationTaskNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .migrationTaskName)
        migrationTaskName = migrationTaskNameDecoded
        let dryRunDecoded = try containerValues.decode(Bool.self, forKey: .dryRun)
        dryRun = dryRunDecoded
    }
}

extension ImportMigrationTaskOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ImportMigrationTaskOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DryRunOperation" : self = .dryRunOperation(try DryRunOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HomeRegionNotSetException" : self = .homeRegionNotSetException(try HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperation" : self = .unauthorizedOperation(try UnauthorizedOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ImportMigrationTaskOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case dryRunOperation(DryRunOperation)
    case homeRegionNotSetException(HomeRegionNotSetException)
    case internalServerError(InternalServerError)
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unauthorizedOperation(UnauthorizedOperation)
    case unknown(UnknownAWSHttpServiceError)
}

extension ImportMigrationTaskOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ImportMigrationTaskOutputResponse()"}
}

extension ImportMigrationTaskOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct ImportMigrationTaskOutputResponse: Equatable {

    public init() {}
}

struct ImportMigrationTaskOutputResponseBody: Equatable {
}

extension ImportMigrationTaskOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension InternalServerError: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalServerError(message: \(String(describing: message)))"}
}

extension InternalServerError: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InternalServerErrorBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Exception raised when an internal, configuration, or dependency error is
///          encountered.</p>
public struct InternalServerError: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerErrorBody: Equatable {
    public let message: String?
}

extension InternalServerErrorBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidInputException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidInputException(message: \(String(describing: message)))"}
}

extension InvalidInputException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidInputExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Exception raised when the provided input violates a policy constraint or is entered in
///          the wrong format or data type.</p>
public struct InvalidInputException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidInputExceptionBody: Equatable {
    public let message: String?
}

extension InvalidInputExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ListApplicationStatesInputBodyMiddleware: Middleware {
    public let id: String = "ListApplicationStatesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListApplicationStatesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListApplicationStatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListApplicationStatesInput>
    public typealias MOutput = OperationOutput<ListApplicationStatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListApplicationStatesOutputError>
}

extension ListApplicationStatesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListApplicationStatesInput(applicationIds: \(String(describing: applicationIds)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListApplicationStatesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applicationIds = "ApplicationIds"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationIds = applicationIds {
            var applicationIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .applicationIds)
            for applicationids0 in applicationIds {
                try applicationIdsContainer.encode(applicationids0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListApplicationStatesInputHeadersMiddleware: Middleware {
    public let id: String = "ListApplicationStatesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListApplicationStatesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListApplicationStatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListApplicationStatesInput>
    public typealias MOutput = OperationOutput<ListApplicationStatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListApplicationStatesOutputError>
}

public struct ListApplicationStatesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListApplicationStatesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListApplicationStatesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListApplicationStatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListApplicationStatesInput>
    public typealias MOutput = OperationOutput<ListApplicationStatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListApplicationStatesOutputError>
}

public struct ListApplicationStatesInput: Equatable {
    /// <p>The configurationIds from the Application Discovery Service that uniquely identifies
    ///          your applications.</p>
    public let applicationIds: [String]?
    /// <p>Maximum number of results to be returned per page.</p>
    public let maxResults: Int?
    /// <p>If a <code>NextToken</code> was returned by a previous call, there are more results
    ///          available. To retrieve the next page of results, make the call again using the returned
    ///          token in <code>NextToken</code>.</p>
    public let nextToken: String?

    public init (
        applicationIds: [String]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.applicationIds = applicationIds
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListApplicationStatesInputBody: Equatable {
    public let applicationIds: [String]?
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListApplicationStatesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case applicationIds = "ApplicationIds"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .applicationIds)
        var applicationIdsDecoded0:[String]? = nil
        if let applicationIdsContainer = applicationIdsContainer {
            applicationIdsDecoded0 = [String]()
            for string0 in applicationIdsContainer {
                if let string0 = string0 {
                    applicationIdsDecoded0?.append(string0)
                }
            }
        }
        applicationIds = applicationIdsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListApplicationStatesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListApplicationStatesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HomeRegionNotSetException" : self = .homeRegionNotSetException(try HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListApplicationStatesOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case homeRegionNotSetException(HomeRegionNotSetException)
    case internalServerError(InternalServerError)
    case invalidInputException(InvalidInputException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListApplicationStatesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListApplicationStatesOutputResponse(applicationStateList: \(String(describing: applicationStateList)), nextToken: \(String(describing: nextToken)))"}
}

extension ListApplicationStatesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListApplicationStatesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.applicationStateList = output.applicationStateList
            self.nextToken = output.nextToken
        } else {
            self.applicationStateList = nil
            self.nextToken = nil
        }
    }
}

public struct ListApplicationStatesOutputResponse: Equatable {
    /// <p>A list of Applications that exist in Application Discovery Service.</p>
    public let applicationStateList: [ApplicationState]?
    /// <p>If a <code>NextToken</code> was returned by a previous call, there are more results
    ///          available. To retrieve the next page of results, make the call again using the returned
    ///          token in <code>NextToken</code>.</p>
    public let nextToken: String?

    public init (
        applicationStateList: [ApplicationState]? = nil,
        nextToken: String? = nil
    )
    {
        self.applicationStateList = applicationStateList
        self.nextToken = nextToken
    }
}

struct ListApplicationStatesOutputResponseBody: Equatable {
    public let applicationStateList: [ApplicationState]?
    public let nextToken: String?
}

extension ListApplicationStatesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case applicationStateList = "ApplicationStateList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationStateListContainer = try containerValues.decodeIfPresent([ApplicationState?].self, forKey: .applicationStateList)
        var applicationStateListDecoded0:[ApplicationState]? = nil
        if let applicationStateListContainer = applicationStateListContainer {
            applicationStateListDecoded0 = [ApplicationState]()
            for structure0 in applicationStateListContainer {
                if let structure0 = structure0 {
                    applicationStateListDecoded0?.append(structure0)
                }
            }
        }
        applicationStateList = applicationStateListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListCreatedArtifactsInputBodyMiddleware: Middleware {
    public let id: String = "ListCreatedArtifactsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListCreatedArtifactsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListCreatedArtifactsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListCreatedArtifactsInput>
    public typealias MOutput = OperationOutput<ListCreatedArtifactsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListCreatedArtifactsOutputError>
}

extension ListCreatedArtifactsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListCreatedArtifactsInput(maxResults: \(String(describing: maxResults)), migrationTaskName: \(String(describing: migrationTaskName)), nextToken: \(String(describing: nextToken)), progressUpdateStream: \(String(describing: progressUpdateStream)))"}
}

extension ListCreatedArtifactsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case migrationTaskName = "MigrationTaskName"
        case nextToken = "NextToken"
        case progressUpdateStream = "ProgressUpdateStream"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let migrationTaskName = migrationTaskName {
            try encodeContainer.encode(migrationTaskName, forKey: .migrationTaskName)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let progressUpdateStream = progressUpdateStream {
            try encodeContainer.encode(progressUpdateStream, forKey: .progressUpdateStream)
        }
    }
}

public struct ListCreatedArtifactsInputHeadersMiddleware: Middleware {
    public let id: String = "ListCreatedArtifactsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListCreatedArtifactsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListCreatedArtifactsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListCreatedArtifactsInput>
    public typealias MOutput = OperationOutput<ListCreatedArtifactsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListCreatedArtifactsOutputError>
}

public struct ListCreatedArtifactsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListCreatedArtifactsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListCreatedArtifactsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListCreatedArtifactsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListCreatedArtifactsInput>
    public typealias MOutput = OperationOutput<ListCreatedArtifactsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListCreatedArtifactsOutputError>
}

public struct ListCreatedArtifactsInput: Equatable {
    /// <p>Maximum number of results to be returned per page.</p>
    public let maxResults: Int?
    /// <p>Unique identifier that references the migration task. <i>Do not store personal
    ///             data in this field.</i>
    ///          </p>
    public let migrationTaskName: String?
    /// <p>If a <code>NextToken</code> was returned by a previous call, there are more results
    ///          available. To retrieve the next page of results, make the call again using the returned
    ///          token in <code>NextToken</code>.</p>
    public let nextToken: String?
    /// <p>The name of the ProgressUpdateStream. </p>
    public let progressUpdateStream: String?

    public init (
        maxResults: Int? = nil,
        migrationTaskName: String? = nil,
        nextToken: String? = nil,
        progressUpdateStream: String? = nil
    )
    {
        self.maxResults = maxResults
        self.migrationTaskName = migrationTaskName
        self.nextToken = nextToken
        self.progressUpdateStream = progressUpdateStream
    }
}

struct ListCreatedArtifactsInputBody: Equatable {
    public let progressUpdateStream: String?
    public let migrationTaskName: String?
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListCreatedArtifactsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case migrationTaskName = "MigrationTaskName"
        case nextToken = "NextToken"
        case progressUpdateStream = "ProgressUpdateStream"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let progressUpdateStreamDecoded = try containerValues.decodeIfPresent(String.self, forKey: .progressUpdateStream)
        progressUpdateStream = progressUpdateStreamDecoded
        let migrationTaskNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .migrationTaskName)
        migrationTaskName = migrationTaskNameDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListCreatedArtifactsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListCreatedArtifactsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HomeRegionNotSetException" : self = .homeRegionNotSetException(try HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListCreatedArtifactsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case homeRegionNotSetException(HomeRegionNotSetException)
    case internalServerError(InternalServerError)
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListCreatedArtifactsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListCreatedArtifactsOutputResponse(createdArtifactList: \(String(describing: createdArtifactList)), nextToken: \(String(describing: nextToken)))"}
}

extension ListCreatedArtifactsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListCreatedArtifactsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.createdArtifactList = output.createdArtifactList
            self.nextToken = output.nextToken
        } else {
            self.createdArtifactList = nil
            self.nextToken = nil
        }
    }
}

public struct ListCreatedArtifactsOutputResponse: Equatable {
    /// <p>List of created artifacts up to the maximum number of results specified in the
    ///          request.</p>
    public let createdArtifactList: [CreatedArtifact]?
    /// <p>If there are more created artifacts than the max result, return the next token to be
    ///          passed to the next call as a bookmark of where to start from.</p>
    public let nextToken: String?

    public init (
        createdArtifactList: [CreatedArtifact]? = nil,
        nextToken: String? = nil
    )
    {
        self.createdArtifactList = createdArtifactList
        self.nextToken = nextToken
    }
}

struct ListCreatedArtifactsOutputResponseBody: Equatable {
    public let nextToken: String?
    public let createdArtifactList: [CreatedArtifact]?
}

extension ListCreatedArtifactsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case createdArtifactList = "CreatedArtifactList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let createdArtifactListContainer = try containerValues.decodeIfPresent([CreatedArtifact?].self, forKey: .createdArtifactList)
        var createdArtifactListDecoded0:[CreatedArtifact]? = nil
        if let createdArtifactListContainer = createdArtifactListContainer {
            createdArtifactListDecoded0 = [CreatedArtifact]()
            for structure0 in createdArtifactListContainer {
                if let structure0 = structure0 {
                    createdArtifactListDecoded0?.append(structure0)
                }
            }
        }
        createdArtifactList = createdArtifactListDecoded0
    }
}

public struct ListDiscoveredResourcesInputBodyMiddleware: Middleware {
    public let id: String = "ListDiscoveredResourcesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDiscoveredResourcesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDiscoveredResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDiscoveredResourcesInput>
    public typealias MOutput = OperationOutput<ListDiscoveredResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDiscoveredResourcesOutputError>
}

extension ListDiscoveredResourcesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDiscoveredResourcesInput(maxResults: \(String(describing: maxResults)), migrationTaskName: \(String(describing: migrationTaskName)), nextToken: \(String(describing: nextToken)), progressUpdateStream: \(String(describing: progressUpdateStream)))"}
}

extension ListDiscoveredResourcesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case migrationTaskName = "MigrationTaskName"
        case nextToken = "NextToken"
        case progressUpdateStream = "ProgressUpdateStream"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let migrationTaskName = migrationTaskName {
            try encodeContainer.encode(migrationTaskName, forKey: .migrationTaskName)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let progressUpdateStream = progressUpdateStream {
            try encodeContainer.encode(progressUpdateStream, forKey: .progressUpdateStream)
        }
    }
}

public struct ListDiscoveredResourcesInputHeadersMiddleware: Middleware {
    public let id: String = "ListDiscoveredResourcesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDiscoveredResourcesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDiscoveredResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDiscoveredResourcesInput>
    public typealias MOutput = OperationOutput<ListDiscoveredResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDiscoveredResourcesOutputError>
}

public struct ListDiscoveredResourcesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListDiscoveredResourcesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDiscoveredResourcesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDiscoveredResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDiscoveredResourcesInput>
    public typealias MOutput = OperationOutput<ListDiscoveredResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDiscoveredResourcesOutputError>
}

public struct ListDiscoveredResourcesInput: Equatable {
    /// <p>The maximum number of results returned per page.</p>
    public let maxResults: Int?
    /// <p>The name of the MigrationTask. <i>Do not store personal data in this
    ///             field.</i>
    ///          </p>
    public let migrationTaskName: String?
    /// <p>If a <code>NextToken</code> was returned by a previous call, there are more results
    ///          available. To retrieve the next page of results, make the call again using the returned
    ///          token in <code>NextToken</code>.</p>
    public let nextToken: String?
    /// <p>The name of the ProgressUpdateStream.</p>
    public let progressUpdateStream: String?

    public init (
        maxResults: Int? = nil,
        migrationTaskName: String? = nil,
        nextToken: String? = nil,
        progressUpdateStream: String? = nil
    )
    {
        self.maxResults = maxResults
        self.migrationTaskName = migrationTaskName
        self.nextToken = nextToken
        self.progressUpdateStream = progressUpdateStream
    }
}

struct ListDiscoveredResourcesInputBody: Equatable {
    public let progressUpdateStream: String?
    public let migrationTaskName: String?
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListDiscoveredResourcesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case migrationTaskName = "MigrationTaskName"
        case nextToken = "NextToken"
        case progressUpdateStream = "ProgressUpdateStream"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let progressUpdateStreamDecoded = try containerValues.decodeIfPresent(String.self, forKey: .progressUpdateStream)
        progressUpdateStream = progressUpdateStreamDecoded
        let migrationTaskNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .migrationTaskName)
        migrationTaskName = migrationTaskNameDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListDiscoveredResourcesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDiscoveredResourcesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HomeRegionNotSetException" : self = .homeRegionNotSetException(try HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDiscoveredResourcesOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case homeRegionNotSetException(HomeRegionNotSetException)
    case internalServerError(InternalServerError)
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDiscoveredResourcesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDiscoveredResourcesOutputResponse(discoveredResourceList: \(String(describing: discoveredResourceList)), nextToken: \(String(describing: nextToken)))"}
}

extension ListDiscoveredResourcesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListDiscoveredResourcesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.discoveredResourceList = output.discoveredResourceList
            self.nextToken = output.nextToken
        } else {
            self.discoveredResourceList = nil
            self.nextToken = nil
        }
    }
}

public struct ListDiscoveredResourcesOutputResponse: Equatable {
    /// <p>Returned list of discovered resources associated with the given MigrationTask.</p>
    public let discoveredResourceList: [DiscoveredResource]?
    /// <p>If there are more discovered resources than the max result, return the next token to be
    ///          passed to the next call as a bookmark of where to start from.</p>
    public let nextToken: String?

    public init (
        discoveredResourceList: [DiscoveredResource]? = nil,
        nextToken: String? = nil
    )
    {
        self.discoveredResourceList = discoveredResourceList
        self.nextToken = nextToken
    }
}

struct ListDiscoveredResourcesOutputResponseBody: Equatable {
    public let nextToken: String?
    public let discoveredResourceList: [DiscoveredResource]?
}

extension ListDiscoveredResourcesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case discoveredResourceList = "DiscoveredResourceList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let discoveredResourceListContainer = try containerValues.decodeIfPresent([DiscoveredResource?].self, forKey: .discoveredResourceList)
        var discoveredResourceListDecoded0:[DiscoveredResource]? = nil
        if let discoveredResourceListContainer = discoveredResourceListContainer {
            discoveredResourceListDecoded0 = [DiscoveredResource]()
            for structure0 in discoveredResourceListContainer {
                if let structure0 = structure0 {
                    discoveredResourceListDecoded0?.append(structure0)
                }
            }
        }
        discoveredResourceList = discoveredResourceListDecoded0
    }
}

public struct ListMigrationTasksInputBodyMiddleware: Middleware {
    public let id: String = "ListMigrationTasksInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListMigrationTasksInput>,
                  next: H) -> Swift.Result<OperationOutput<ListMigrationTasksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListMigrationTasksInput>
    public typealias MOutput = OperationOutput<ListMigrationTasksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListMigrationTasksOutputError>
}

extension ListMigrationTasksInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListMigrationTasksInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), resourceName: \(String(describing: resourceName)))"}
}

extension ListMigrationTasksInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceName = "ResourceName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceName = resourceName {
            try encodeContainer.encode(resourceName, forKey: .resourceName)
        }
    }
}

public struct ListMigrationTasksInputHeadersMiddleware: Middleware {
    public let id: String = "ListMigrationTasksInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListMigrationTasksInput>,
                  next: H) -> Swift.Result<OperationOutput<ListMigrationTasksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListMigrationTasksInput>
    public typealias MOutput = OperationOutput<ListMigrationTasksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListMigrationTasksOutputError>
}

public struct ListMigrationTasksInputQueryItemMiddleware: Middleware {
    public let id: String = "ListMigrationTasksInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListMigrationTasksInput>,
                  next: H) -> Swift.Result<OperationOutput<ListMigrationTasksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListMigrationTasksInput>
    public typealias MOutput = OperationOutput<ListMigrationTasksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListMigrationTasksOutputError>
}

public struct ListMigrationTasksInput: Equatable {
    /// <p>Value to specify how many results are returned per page.</p>
    public let maxResults: Int?
    /// <p>If a <code>NextToken</code> was returned by a previous call, there are more results
    ///          available. To retrieve the next page of results, make the call again using the returned
    ///          token in <code>NextToken</code>.</p>
    public let nextToken: String?
    /// <p>Filter migration tasks by discovered resource name.</p>
    public let resourceName: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        resourceName: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceName = resourceName
    }
}

struct ListMigrationTasksInputBody: Equatable {
    public let nextToken: String?
    public let maxResults: Int?
    public let resourceName: String?
}

extension ListMigrationTasksInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceName = "ResourceName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension ListMigrationTasksOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListMigrationTasksOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HomeRegionNotSetException" : self = .homeRegionNotSetException(try HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PolicyErrorException" : self = .policyErrorException(try PolicyErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListMigrationTasksOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case homeRegionNotSetException(HomeRegionNotSetException)
    case internalServerError(InternalServerError)
    case invalidInputException(InvalidInputException)
    case policyErrorException(PolicyErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListMigrationTasksOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListMigrationTasksOutputResponse(migrationTaskSummaryList: \(String(describing: migrationTaskSummaryList)), nextToken: \(String(describing: nextToken)))"}
}

extension ListMigrationTasksOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListMigrationTasksOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.migrationTaskSummaryList = output.migrationTaskSummaryList
            self.nextToken = output.nextToken
        } else {
            self.migrationTaskSummaryList = nil
            self.nextToken = nil
        }
    }
}

public struct ListMigrationTasksOutputResponse: Equatable {
    /// <p>Lists the migration task's summary which includes: <code>MigrationTaskName</code>,
    ///             <code>ProgressPercent</code>, <code>ProgressUpdateStream</code>, <code>Status</code>,
    ///          and the <code>UpdateDateTime</code> for each task.</p>
    public let migrationTaskSummaryList: [MigrationTaskSummary]?
    /// <p>If there are more migration tasks than the max result, return the next token to be
    ///          passed to the next call as a bookmark of where to start from.</p>
    public let nextToken: String?

    public init (
        migrationTaskSummaryList: [MigrationTaskSummary]? = nil,
        nextToken: String? = nil
    )
    {
        self.migrationTaskSummaryList = migrationTaskSummaryList
        self.nextToken = nextToken
    }
}

struct ListMigrationTasksOutputResponseBody: Equatable {
    public let nextToken: String?
    public let migrationTaskSummaryList: [MigrationTaskSummary]?
}

extension ListMigrationTasksOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case migrationTaskSummaryList = "MigrationTaskSummaryList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let migrationTaskSummaryListContainer = try containerValues.decodeIfPresent([MigrationTaskSummary?].self, forKey: .migrationTaskSummaryList)
        var migrationTaskSummaryListDecoded0:[MigrationTaskSummary]? = nil
        if let migrationTaskSummaryListContainer = migrationTaskSummaryListContainer {
            migrationTaskSummaryListDecoded0 = [MigrationTaskSummary]()
            for structure0 in migrationTaskSummaryListContainer {
                if let structure0 = structure0 {
                    migrationTaskSummaryListDecoded0?.append(structure0)
                }
            }
        }
        migrationTaskSummaryList = migrationTaskSummaryListDecoded0
    }
}

public struct ListProgressUpdateStreamsInputBodyMiddleware: Middleware {
    public let id: String = "ListProgressUpdateStreamsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListProgressUpdateStreamsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListProgressUpdateStreamsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListProgressUpdateStreamsInput>
    public typealias MOutput = OperationOutput<ListProgressUpdateStreamsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListProgressUpdateStreamsOutputError>
}

extension ListProgressUpdateStreamsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListProgressUpdateStreamsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListProgressUpdateStreamsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListProgressUpdateStreamsInputHeadersMiddleware: Middleware {
    public let id: String = "ListProgressUpdateStreamsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListProgressUpdateStreamsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListProgressUpdateStreamsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListProgressUpdateStreamsInput>
    public typealias MOutput = OperationOutput<ListProgressUpdateStreamsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListProgressUpdateStreamsOutputError>
}

public struct ListProgressUpdateStreamsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListProgressUpdateStreamsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListProgressUpdateStreamsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListProgressUpdateStreamsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListProgressUpdateStreamsInput>
    public typealias MOutput = OperationOutput<ListProgressUpdateStreamsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListProgressUpdateStreamsOutputError>
}

public struct ListProgressUpdateStreamsInput: Equatable {
    /// <p>Filter to limit the maximum number of results to list per page.</p>
    public let maxResults: Int?
    /// <p>If a <code>NextToken</code> was returned by a previous call, there are more results
    ///          available. To retrieve the next page of results, make the call again using the returned
    ///          token in <code>NextToken</code>.</p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListProgressUpdateStreamsInputBody: Equatable {
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListProgressUpdateStreamsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListProgressUpdateStreamsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListProgressUpdateStreamsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HomeRegionNotSetException" : self = .homeRegionNotSetException(try HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListProgressUpdateStreamsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case homeRegionNotSetException(HomeRegionNotSetException)
    case internalServerError(InternalServerError)
    case invalidInputException(InvalidInputException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListProgressUpdateStreamsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListProgressUpdateStreamsOutputResponse(nextToken: \(String(describing: nextToken)), progressUpdateStreamSummaryList: \(String(describing: progressUpdateStreamSummaryList)))"}
}

extension ListProgressUpdateStreamsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListProgressUpdateStreamsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.progressUpdateStreamSummaryList = output.progressUpdateStreamSummaryList
        } else {
            self.nextToken = nil
            self.progressUpdateStreamSummaryList = nil
        }
    }
}

public struct ListProgressUpdateStreamsOutputResponse: Equatable {
    /// <p>If there are more streams created than the max result, return the next token to be
    ///          passed to the next call as a bookmark of where to start from.</p>
    public let nextToken: String?
    /// <p>List of progress update streams up to the max number of results passed in the
    ///          input.</p>
    public let progressUpdateStreamSummaryList: [ProgressUpdateStreamSummary]?

    public init (
        nextToken: String? = nil,
        progressUpdateStreamSummaryList: [ProgressUpdateStreamSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.progressUpdateStreamSummaryList = progressUpdateStreamSummaryList
    }
}

struct ListProgressUpdateStreamsOutputResponseBody: Equatable {
    public let progressUpdateStreamSummaryList: [ProgressUpdateStreamSummary]?
    public let nextToken: String?
}

extension ListProgressUpdateStreamsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case progressUpdateStreamSummaryList = "ProgressUpdateStreamSummaryList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let progressUpdateStreamSummaryListContainer = try containerValues.decodeIfPresent([ProgressUpdateStreamSummary?].self, forKey: .progressUpdateStreamSummaryList)
        var progressUpdateStreamSummaryListDecoded0:[ProgressUpdateStreamSummary]? = nil
        if let progressUpdateStreamSummaryListContainer = progressUpdateStreamSummaryListContainer {
            progressUpdateStreamSummaryListDecoded0 = [ProgressUpdateStreamSummary]()
            for structure0 in progressUpdateStreamSummaryListContainer {
                if let structure0 = structure0 {
                    progressUpdateStreamSummaryListDecoded0?.append(structure0)
                }
            }
        }
        progressUpdateStreamSummaryList = progressUpdateStreamSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension MigrationTask: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case migrationTaskName = "MigrationTaskName"
        case progressUpdateStream = "ProgressUpdateStream"
        case resourceAttributeList = "ResourceAttributeList"
        case task = "Task"
        case updateDateTime = "UpdateDateTime"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let migrationTaskName = migrationTaskName {
            try encodeContainer.encode(migrationTaskName, forKey: .migrationTaskName)
        }
        if let progressUpdateStream = progressUpdateStream {
            try encodeContainer.encode(progressUpdateStream, forKey: .progressUpdateStream)
        }
        if let resourceAttributeList = resourceAttributeList {
            var resourceAttributeListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceAttributeList)
            for latestresourceattributelist0 in resourceAttributeList {
                try resourceAttributeListContainer.encode(latestresourceattributelist0)
            }
        }
        if let task = task {
            try encodeContainer.encode(task, forKey: .task)
        }
        if let updateDateTime = updateDateTime {
            try encodeContainer.encode(updateDateTime.timeIntervalSince1970, forKey: .updateDateTime)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let progressUpdateStreamDecoded = try containerValues.decodeIfPresent(String.self, forKey: .progressUpdateStream)
        progressUpdateStream = progressUpdateStreamDecoded
        let migrationTaskNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .migrationTaskName)
        migrationTaskName = migrationTaskNameDecoded
        let taskDecoded = try containerValues.decodeIfPresent(Task.self, forKey: .task)
        task = taskDecoded
        let updateDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .updateDateTime)
        updateDateTime = updateDateTimeDecoded
        let resourceAttributeListContainer = try containerValues.decodeIfPresent([ResourceAttribute?].self, forKey: .resourceAttributeList)
        var resourceAttributeListDecoded0:[ResourceAttribute]? = nil
        if let resourceAttributeListContainer = resourceAttributeListContainer {
            resourceAttributeListDecoded0 = [ResourceAttribute]()
            for structure0 in resourceAttributeListContainer {
                if let structure0 = structure0 {
                    resourceAttributeListDecoded0?.append(structure0)
                }
            }
        }
        resourceAttributeList = resourceAttributeListDecoded0
    }
}

extension MigrationTask: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MigrationTask(migrationTaskName: \(String(describing: migrationTaskName)), progressUpdateStream: \(String(describing: progressUpdateStream)), resourceAttributeList: \(String(describing: resourceAttributeList)), task: \(String(describing: task)), updateDateTime: \(String(describing: updateDateTime)))"}
}

/// <p>Represents a migration task in a migration tool.</p>
public struct MigrationTask: Equatable {
    /// <p>Unique identifier that references the migration task. <i>Do not store personal
    ///             data in this field.</i>
    ///          </p>
    public let migrationTaskName: String?
    /// <p>A name that identifies the vendor of the migration tool being used.</p>
    public let progressUpdateStream: String?
    /// <p>Information about the resource that is being migrated. This data will be used to map the
    ///          task to a resource in the Application Discovery Service repository.</p>
    public let resourceAttributeList: [ResourceAttribute]?
    /// <p>Task object encapsulating task information.</p>
    public let task: Task?
    /// <p>The timestamp when the task was gathered.</p>
    public let updateDateTime: Date?

    public init (
        migrationTaskName: String? = nil,
        progressUpdateStream: String? = nil,
        resourceAttributeList: [ResourceAttribute]? = nil,
        task: Task? = nil,
        updateDateTime: Date? = nil
    )
    {
        self.migrationTaskName = migrationTaskName
        self.progressUpdateStream = progressUpdateStream
        self.resourceAttributeList = resourceAttributeList
        self.task = task
        self.updateDateTime = updateDateTime
    }
}

extension MigrationTaskSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case migrationTaskName = "MigrationTaskName"
        case progressPercent = "ProgressPercent"
        case progressUpdateStream = "ProgressUpdateStream"
        case status = "Status"
        case statusDetail = "StatusDetail"
        case updateDateTime = "UpdateDateTime"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let migrationTaskName = migrationTaskName {
            try encodeContainer.encode(migrationTaskName, forKey: .migrationTaskName)
        }
        if let progressPercent = progressPercent {
            try encodeContainer.encode(progressPercent, forKey: .progressPercent)
        }
        if let progressUpdateStream = progressUpdateStream {
            try encodeContainer.encode(progressUpdateStream, forKey: .progressUpdateStream)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusDetail = statusDetail {
            try encodeContainer.encode(statusDetail, forKey: .statusDetail)
        }
        if let updateDateTime = updateDateTime {
            try encodeContainer.encode(updateDateTime.timeIntervalSince1970, forKey: .updateDateTime)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let progressUpdateStreamDecoded = try containerValues.decodeIfPresent(String.self, forKey: .progressUpdateStream)
        progressUpdateStream = progressUpdateStreamDecoded
        let migrationTaskNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .migrationTaskName)
        migrationTaskName = migrationTaskNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Status.self, forKey: .status)
        status = statusDecoded
        let progressPercentDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .progressPercent)
        progressPercent = progressPercentDecoded
        let statusDetailDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statusDetail)
        statusDetail = statusDetailDecoded
        let updateDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .updateDateTime)
        updateDateTime = updateDateTimeDecoded
    }
}

extension MigrationTaskSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MigrationTaskSummary(migrationTaskName: \(String(describing: migrationTaskName)), progressPercent: \(String(describing: progressPercent)), progressUpdateStream: \(String(describing: progressUpdateStream)), status: \(String(describing: status)), statusDetail: \(String(describing: statusDetail)), updateDateTime: \(String(describing: updateDateTime)))"}
}

/// <p>MigrationTaskSummary includes <code>MigrationTaskName</code>,
///             <code>ProgressPercent</code>, <code>ProgressUpdateStream</code>, <code>Status</code>,
///          and <code>UpdateDateTime</code> for each task.</p>
public struct MigrationTaskSummary: Equatable {
    /// <p>Unique identifier that references the migration task. <i>Do not store personal
    ///             data in this field.</i>
    ///          </p>
    public let migrationTaskName: String?
    /// <p>Indication of the percentage completion of the task.</p>
    public let progressPercent: Int?
    /// <p>An AWS resource used for access control. It should uniquely identify the migration tool
    ///          as it is used for all updates made by the tool.</p>
    public let progressUpdateStream: String?
    /// <p>Status of the task.</p>
    public let status: Status?
    /// <p>Detail information of what is being done within the overall status state.</p>
    public let statusDetail: String?
    /// <p>The timestamp when the task was gathered.</p>
    public let updateDateTime: Date?

    public init (
        migrationTaskName: String? = nil,
        progressPercent: Int? = nil,
        progressUpdateStream: String? = nil,
        status: Status? = nil,
        statusDetail: String? = nil,
        updateDateTime: Date? = nil
    )
    {
        self.migrationTaskName = migrationTaskName
        self.progressPercent = progressPercent
        self.progressUpdateStream = progressUpdateStream
        self.status = status
        self.statusDetail = statusDetail
        self.updateDateTime = updateDateTime
    }
}

public struct NotifyApplicationStateInputBodyMiddleware: Middleware {
    public let id: String = "NotifyApplicationStateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<NotifyApplicationStateInput>,
                  next: H) -> Swift.Result<OperationOutput<NotifyApplicationStateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<NotifyApplicationStateInput>
    public typealias MOutput = OperationOutput<NotifyApplicationStateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<NotifyApplicationStateOutputError>
}

extension NotifyApplicationStateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NotifyApplicationStateInput(applicationId: \(String(describing: applicationId)), dryRun: \(String(describing: dryRun)), status: \(String(describing: status)), updateDateTime: \(String(describing: updateDateTime)))"}
}

extension NotifyApplicationStateInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applicationId = "ApplicationId"
        case dryRun = "DryRun"
        case status = "Status"
        case updateDateTime = "UpdateDateTime"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationId = applicationId {
            try encodeContainer.encode(applicationId, forKey: .applicationId)
        }
        if dryRun != false {
            try encodeContainer.encode(dryRun, forKey: .dryRun)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let updateDateTime = updateDateTime {
            try encodeContainer.encode(updateDateTime.timeIntervalSince1970, forKey: .updateDateTime)
        }
    }
}

public struct NotifyApplicationStateInputHeadersMiddleware: Middleware {
    public let id: String = "NotifyApplicationStateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<NotifyApplicationStateInput>,
                  next: H) -> Swift.Result<OperationOutput<NotifyApplicationStateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<NotifyApplicationStateInput>
    public typealias MOutput = OperationOutput<NotifyApplicationStateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<NotifyApplicationStateOutputError>
}

public struct NotifyApplicationStateInputQueryItemMiddleware: Middleware {
    public let id: String = "NotifyApplicationStateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<NotifyApplicationStateInput>,
                  next: H) -> Swift.Result<OperationOutput<NotifyApplicationStateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<NotifyApplicationStateInput>
    public typealias MOutput = OperationOutput<NotifyApplicationStateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<NotifyApplicationStateOutputError>
}

public struct NotifyApplicationStateInput: Equatable {
    /// <p>The configurationId in Application Discovery Service that uniquely identifies the
    ///          grouped application.</p>
    public let applicationId: String?
    /// <p>Optional boolean flag to indicate whether any effect should take place. Used to test if
    ///          the caller has permission to make the call.</p>
    public let dryRun: Bool
    /// <p>Status of the application - Not Started, In-Progress, Complete.</p>
    public let status: ApplicationStatus?
    /// <p>The timestamp when the application state changed.</p>
    public let updateDateTime: Date?

    public init (
        applicationId: String? = nil,
        dryRun: Bool = false,
        status: ApplicationStatus? = nil,
        updateDateTime: Date? = nil
    )
    {
        self.applicationId = applicationId
        self.dryRun = dryRun
        self.status = status
        self.updateDateTime = updateDateTime
    }
}

struct NotifyApplicationStateInputBody: Equatable {
    public let applicationId: String?
    public let status: ApplicationStatus?
    public let updateDateTime: Date?
    public let dryRun: Bool
}

extension NotifyApplicationStateInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case applicationId = "ApplicationId"
        case dryRun = "DryRun"
        case status = "Status"
        case updateDateTime = "UpdateDateTime"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ApplicationStatus.self, forKey: .status)
        status = statusDecoded
        let updateDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .updateDateTime)
        updateDateTime = updateDateTimeDecoded
        let dryRunDecoded = try containerValues.decode(Bool.self, forKey: .dryRun)
        dryRun = dryRunDecoded
    }
}

extension NotifyApplicationStateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension NotifyApplicationStateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DryRunOperation" : self = .dryRunOperation(try DryRunOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HomeRegionNotSetException" : self = .homeRegionNotSetException(try HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PolicyErrorException" : self = .policyErrorException(try PolicyErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperation" : self = .unauthorizedOperation(try UnauthorizedOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum NotifyApplicationStateOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case dryRunOperation(DryRunOperation)
    case homeRegionNotSetException(HomeRegionNotSetException)
    case internalServerError(InternalServerError)
    case invalidInputException(InvalidInputException)
    case policyErrorException(PolicyErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unauthorizedOperation(UnauthorizedOperation)
    case unknown(UnknownAWSHttpServiceError)
}

extension NotifyApplicationStateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NotifyApplicationStateOutputResponse()"}
}

extension NotifyApplicationStateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct NotifyApplicationStateOutputResponse: Equatable {

    public init() {}
}

struct NotifyApplicationStateOutputResponseBody: Equatable {
}

extension NotifyApplicationStateOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct NotifyMigrationTaskStateInputBodyMiddleware: Middleware {
    public let id: String = "NotifyMigrationTaskStateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<NotifyMigrationTaskStateInput>,
                  next: H) -> Swift.Result<OperationOutput<NotifyMigrationTaskStateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<NotifyMigrationTaskStateInput>
    public typealias MOutput = OperationOutput<NotifyMigrationTaskStateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<NotifyMigrationTaskStateOutputError>
}

extension NotifyMigrationTaskStateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NotifyMigrationTaskStateInput(dryRun: \(String(describing: dryRun)), migrationTaskName: \(String(describing: migrationTaskName)), nextUpdateSeconds: \(String(describing: nextUpdateSeconds)), progressUpdateStream: \(String(describing: progressUpdateStream)), task: \(String(describing: task)), updateDateTime: \(String(describing: updateDateTime)))"}
}

extension NotifyMigrationTaskStateInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case migrationTaskName = "MigrationTaskName"
        case nextUpdateSeconds = "NextUpdateSeconds"
        case progressUpdateStream = "ProgressUpdateStream"
        case task = "Task"
        case updateDateTime = "UpdateDateTime"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if dryRun != false {
            try encodeContainer.encode(dryRun, forKey: .dryRun)
        }
        if let migrationTaskName = migrationTaskName {
            try encodeContainer.encode(migrationTaskName, forKey: .migrationTaskName)
        }
        if nextUpdateSeconds != 0 {
            try encodeContainer.encode(nextUpdateSeconds, forKey: .nextUpdateSeconds)
        }
        if let progressUpdateStream = progressUpdateStream {
            try encodeContainer.encode(progressUpdateStream, forKey: .progressUpdateStream)
        }
        if let task = task {
            try encodeContainer.encode(task, forKey: .task)
        }
        if let updateDateTime = updateDateTime {
            try encodeContainer.encode(updateDateTime.timeIntervalSince1970, forKey: .updateDateTime)
        }
    }
}

public struct NotifyMigrationTaskStateInputHeadersMiddleware: Middleware {
    public let id: String = "NotifyMigrationTaskStateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<NotifyMigrationTaskStateInput>,
                  next: H) -> Swift.Result<OperationOutput<NotifyMigrationTaskStateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<NotifyMigrationTaskStateInput>
    public typealias MOutput = OperationOutput<NotifyMigrationTaskStateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<NotifyMigrationTaskStateOutputError>
}

public struct NotifyMigrationTaskStateInputQueryItemMiddleware: Middleware {
    public let id: String = "NotifyMigrationTaskStateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<NotifyMigrationTaskStateInput>,
                  next: H) -> Swift.Result<OperationOutput<NotifyMigrationTaskStateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<NotifyMigrationTaskStateInput>
    public typealias MOutput = OperationOutput<NotifyMigrationTaskStateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<NotifyMigrationTaskStateOutputError>
}

public struct NotifyMigrationTaskStateInput: Equatable {
    /// <p>Optional boolean flag to indicate whether any effect should take place. Used to test if
    ///          the caller has permission to make the call.</p>
    public let dryRun: Bool
    /// <p>Unique identifier that references the migration task. <i>Do not store personal
    ///             data in this field.</i>
    ///          </p>
    public let migrationTaskName: String?
    /// <p>Number of seconds after the UpdateDateTime within which the Migration Hub can expect an
    ///          update. If Migration Hub does not receive an update within the specified interval, then the
    ///          migration task will be considered stale.</p>
    public let nextUpdateSeconds: Int
    /// <p>The name of the ProgressUpdateStream. </p>
    public let progressUpdateStream: String?
    /// <p>Information about the task's progress and status.</p>
    public let task: Task?
    /// <p>The timestamp when the task was gathered.</p>
    public let updateDateTime: Date?

    public init (
        dryRun: Bool = false,
        migrationTaskName: String? = nil,
        nextUpdateSeconds: Int = 0,
        progressUpdateStream: String? = nil,
        task: Task? = nil,
        updateDateTime: Date? = nil
    )
    {
        self.dryRun = dryRun
        self.migrationTaskName = migrationTaskName
        self.nextUpdateSeconds = nextUpdateSeconds
        self.progressUpdateStream = progressUpdateStream
        self.task = task
        self.updateDateTime = updateDateTime
    }
}

struct NotifyMigrationTaskStateInputBody: Equatable {
    public let progressUpdateStream: String?
    public let migrationTaskName: String?
    public let task: Task?
    public let updateDateTime: Date?
    public let nextUpdateSeconds: Int
    public let dryRun: Bool
}

extension NotifyMigrationTaskStateInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case migrationTaskName = "MigrationTaskName"
        case nextUpdateSeconds = "NextUpdateSeconds"
        case progressUpdateStream = "ProgressUpdateStream"
        case task = "Task"
        case updateDateTime = "UpdateDateTime"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let progressUpdateStreamDecoded = try containerValues.decodeIfPresent(String.self, forKey: .progressUpdateStream)
        progressUpdateStream = progressUpdateStreamDecoded
        let migrationTaskNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .migrationTaskName)
        migrationTaskName = migrationTaskNameDecoded
        let taskDecoded = try containerValues.decodeIfPresent(Task.self, forKey: .task)
        task = taskDecoded
        let updateDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .updateDateTime)
        updateDateTime = updateDateTimeDecoded
        let nextUpdateSecondsDecoded = try containerValues.decode(Int.self, forKey: .nextUpdateSeconds)
        nextUpdateSeconds = nextUpdateSecondsDecoded
        let dryRunDecoded = try containerValues.decode(Bool.self, forKey: .dryRun)
        dryRun = dryRunDecoded
    }
}

extension NotifyMigrationTaskStateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension NotifyMigrationTaskStateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DryRunOperation" : self = .dryRunOperation(try DryRunOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HomeRegionNotSetException" : self = .homeRegionNotSetException(try HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperation" : self = .unauthorizedOperation(try UnauthorizedOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum NotifyMigrationTaskStateOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case dryRunOperation(DryRunOperation)
    case homeRegionNotSetException(HomeRegionNotSetException)
    case internalServerError(InternalServerError)
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unauthorizedOperation(UnauthorizedOperation)
    case unknown(UnknownAWSHttpServiceError)
}

extension NotifyMigrationTaskStateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NotifyMigrationTaskStateOutputResponse()"}
}

extension NotifyMigrationTaskStateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct NotifyMigrationTaskStateOutputResponse: Equatable {

    public init() {}
}

struct NotifyMigrationTaskStateOutputResponseBody: Equatable {
}

extension NotifyMigrationTaskStateOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension PolicyErrorException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PolicyErrorException(message: \(String(describing: message)))"}
}

extension PolicyErrorException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PolicyErrorExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Exception raised when there are problems accessing Application Discovery Service
///          (Application Discovery Service); most likely due to a misconfigured policy or the
///             <code>migrationhub-discovery</code> role is missing or not configured correctly.</p>
public struct PolicyErrorException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct PolicyErrorExceptionBody: Equatable {
    public let message: String?
}

extension PolicyErrorExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ProgressUpdateStreamSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case progressUpdateStreamName = "ProgressUpdateStreamName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let progressUpdateStreamName = progressUpdateStreamName {
            try encodeContainer.encode(progressUpdateStreamName, forKey: .progressUpdateStreamName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let progressUpdateStreamNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .progressUpdateStreamName)
        progressUpdateStreamName = progressUpdateStreamNameDecoded
    }
}

extension ProgressUpdateStreamSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ProgressUpdateStreamSummary(progressUpdateStreamName: \(String(describing: progressUpdateStreamName)))"}
}

/// <p>Summary of the AWS resource used for access control that is implicitly linked to your
///          AWS account.</p>
public struct ProgressUpdateStreamSummary: Equatable {
    /// <p>The name of the ProgressUpdateStream. <i>Do not store personal data in this
    ///             field.</i>
    ///          </p>
    public let progressUpdateStreamName: String?

    public init (
        progressUpdateStreamName: String? = nil
    )
    {
        self.progressUpdateStreamName = progressUpdateStreamName
    }
}

public struct PutResourceAttributesInputBodyMiddleware: Middleware {
    public let id: String = "PutResourceAttributesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutResourceAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<PutResourceAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutResourceAttributesInput>
    public typealias MOutput = OperationOutput<PutResourceAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutResourceAttributesOutputError>
}

extension PutResourceAttributesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutResourceAttributesInput(dryRun: \(String(describing: dryRun)), migrationTaskName: \(String(describing: migrationTaskName)), progressUpdateStream: \(String(describing: progressUpdateStream)), resourceAttributeList: \(String(describing: resourceAttributeList)))"}
}

extension PutResourceAttributesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case migrationTaskName = "MigrationTaskName"
        case progressUpdateStream = "ProgressUpdateStream"
        case resourceAttributeList = "ResourceAttributeList"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if dryRun != false {
            try encodeContainer.encode(dryRun, forKey: .dryRun)
        }
        if let migrationTaskName = migrationTaskName {
            try encodeContainer.encode(migrationTaskName, forKey: .migrationTaskName)
        }
        if let progressUpdateStream = progressUpdateStream {
            try encodeContainer.encode(progressUpdateStream, forKey: .progressUpdateStream)
        }
        if let resourceAttributeList = resourceAttributeList {
            var resourceAttributeListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceAttributeList)
            for resourceattributelist0 in resourceAttributeList {
                try resourceAttributeListContainer.encode(resourceattributelist0)
            }
        }
    }
}

public struct PutResourceAttributesInputHeadersMiddleware: Middleware {
    public let id: String = "PutResourceAttributesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutResourceAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<PutResourceAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutResourceAttributesInput>
    public typealias MOutput = OperationOutput<PutResourceAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutResourceAttributesOutputError>
}

public struct PutResourceAttributesInputQueryItemMiddleware: Middleware {
    public let id: String = "PutResourceAttributesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutResourceAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<PutResourceAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutResourceAttributesInput>
    public typealias MOutput = OperationOutput<PutResourceAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutResourceAttributesOutputError>
}

public struct PutResourceAttributesInput: Equatable {
    /// <p>Optional boolean flag to indicate whether any effect should take place. Used to test if
    ///          the caller has permission to make the call.</p>
    public let dryRun: Bool
    /// <p>Unique identifier that references the migration task. <i>Do not store personal
    ///             data in this field.</i>
    ///          </p>
    public let migrationTaskName: String?
    /// <p>The name of the ProgressUpdateStream. </p>
    public let progressUpdateStream: String?
    /// <p>Information about the resource that is being migrated. This data will be used to map the
    ///          task to a resource in the Application Discovery Service repository.</p>
    ///          <note>
    ///             <p>Takes the object array of <code>ResourceAttribute</code> where the <code>Type</code>
    ///             field is reserved for the following values: <code>IPV4_ADDRESS | IPV6_ADDRESS |
    ///                MAC_ADDRESS | FQDN | VM_MANAGER_ID | VM_MANAGED_OBJECT_REFERENCE | VM_NAME | VM_PATH
    ///                | BIOS_ID | MOTHERBOARD_SERIAL_NUMBER</code> where the identifying value can be a
    ///             string up to 256 characters.</p>
    ///          </note>
    ///          <important>
    ///             <ul>
    ///                <li>
    ///
    ///                   <p>If any "VM" related value is set for a <code>ResourceAttribute</code> object,
    ///                   it is required that <code>VM_MANAGER_ID</code>, as a minimum, is always set. If
    ///                      <code>VM_MANAGER_ID</code> is not set, then all "VM" fields will be discarded
    ///                   and "VM" fields will not be used for matching the migration task to a server in
    ///                   Application Discovery Service repository. See the <a href="https://docs.aws.amazon.com/migrationhub/latest/ug/API_PutResourceAttributes.html#API_PutResourceAttributes_Examples">Example</a> section below for a use case of specifying "VM" related
    ///                   values.</p>
    ///                </li>
    ///                <li>
    ///                   <p> If a server you are trying to match has multiple IP or MAC addresses, you
    ///                   should provide as many as you know in separate type/value pairs passed to the
    ///                      <code>ResourceAttributeList</code> parameter to maximize the chances of
    ///                   matching.</p>
    ///                </li>
    ///             </ul>
    ///          </important>
    public let resourceAttributeList: [ResourceAttribute]?

    public init (
        dryRun: Bool = false,
        migrationTaskName: String? = nil,
        progressUpdateStream: String? = nil,
        resourceAttributeList: [ResourceAttribute]? = nil
    )
    {
        self.dryRun = dryRun
        self.migrationTaskName = migrationTaskName
        self.progressUpdateStream = progressUpdateStream
        self.resourceAttributeList = resourceAttributeList
    }
}

struct PutResourceAttributesInputBody: Equatable {
    public let progressUpdateStream: String?
    public let migrationTaskName: String?
    public let resourceAttributeList: [ResourceAttribute]?
    public let dryRun: Bool
}

extension PutResourceAttributesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case migrationTaskName = "MigrationTaskName"
        case progressUpdateStream = "ProgressUpdateStream"
        case resourceAttributeList = "ResourceAttributeList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let progressUpdateStreamDecoded = try containerValues.decodeIfPresent(String.self, forKey: .progressUpdateStream)
        progressUpdateStream = progressUpdateStreamDecoded
        let migrationTaskNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .migrationTaskName)
        migrationTaskName = migrationTaskNameDecoded
        let resourceAttributeListContainer = try containerValues.decodeIfPresent([ResourceAttribute?].self, forKey: .resourceAttributeList)
        var resourceAttributeListDecoded0:[ResourceAttribute]? = nil
        if let resourceAttributeListContainer = resourceAttributeListContainer {
            resourceAttributeListDecoded0 = [ResourceAttribute]()
            for structure0 in resourceAttributeListContainer {
                if let structure0 = structure0 {
                    resourceAttributeListDecoded0?.append(structure0)
                }
            }
        }
        resourceAttributeList = resourceAttributeListDecoded0
        let dryRunDecoded = try containerValues.decode(Bool.self, forKey: .dryRun)
        dryRun = dryRunDecoded
    }
}

extension PutResourceAttributesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutResourceAttributesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DryRunOperation" : self = .dryRunOperation(try DryRunOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HomeRegionNotSetException" : self = .homeRegionNotSetException(try HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperation" : self = .unauthorizedOperation(try UnauthorizedOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutResourceAttributesOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case dryRunOperation(DryRunOperation)
    case homeRegionNotSetException(HomeRegionNotSetException)
    case internalServerError(InternalServerError)
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unauthorizedOperation(UnauthorizedOperation)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutResourceAttributesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutResourceAttributesOutputResponse()"}
}

extension PutResourceAttributesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct PutResourceAttributesOutputResponse: Equatable {

    public init() {}
}

struct PutResourceAttributesOutputResponseBody: Equatable {
}

extension PutResourceAttributesOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ResourceAttribute: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case type = "Type"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(ResourceAttributeType.self, forKey: .type)
        type = typeDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension ResourceAttribute: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceAttribute(type: \(String(describing: type)), value: \(String(describing: value)))"}
}

/// <p>Attribute associated with a resource.</p>
///          <p>Note the corresponding format required per type listed below:</p>
///
///
///          <dl>
///             <dt>IPV4</dt>
///             <dd>
///                <p>
///                   <code>x.x.x.x</code>
///                </p>
///                <p>
///                   <i>where x is an integer in the range [0,255]</i>
///                </p>
///             </dd>
///             <dt>IPV6</dt>
///             <dd>
///                <p>
///                   <code>y : y : y : y : y : y : y : y</code>
///                </p>
///                <p>
///                   <i>where y is a hexadecimal between 0 and FFFF. [0,
///                   FFFF]</i>
///                </p>
///             </dd>
///             <dt>MAC_ADDRESS</dt>
///             <dd>
///                <p>
///                   <code>^([0-9A-Fa-f]{2}[:-]){5}([0-9A-Fa-f]{2})$</code>
///                </p>
///             </dd>
///             <dt>FQDN</dt>
///             <dd>
///                <p>
///                   <code>^[^<>{}\\\\/?,=\\p{Cntrl}]{1,256}$</code>
///                </p>
///             </dd>
///          </dl>
public struct ResourceAttribute: Equatable {
    /// <p>Type of resource.</p>
    public let type: ResourceAttributeType?
    /// <p>Value of the resource type.</p>
    public let value: String?

    public init (
        type: ResourceAttributeType? = nil,
        value: String? = nil
    )
    {
        self.type = type
        self.value = value
    }
}

public enum ResourceAttributeType {
    case biosId
    case fqdn
    case ipv4Address
    case ipv6Address
    case macAddress
    case motherboardSerialNumber
    case vmManagedObjectReference
    case vmManagerId
    case vmName
    case vmPath
    case sdkUnknown(String)
}

extension ResourceAttributeType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ResourceAttributeType] {
        return [
            .biosId,
            .fqdn,
            .ipv4Address,
            .ipv6Address,
            .macAddress,
            .motherboardSerialNumber,
            .vmManagedObjectReference,
            .vmManagerId,
            .vmName,
            .vmPath,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .biosId: return "BIOS_ID"
        case .fqdn: return "FQDN"
        case .ipv4Address: return "IPV4_ADDRESS"
        case .ipv6Address: return "IPV6_ADDRESS"
        case .macAddress: return "MAC_ADDRESS"
        case .motherboardSerialNumber: return "MOTHERBOARD_SERIAL_NUMBER"
        case .vmManagedObjectReference: return "VM_MANAGED_OBJECT_REFERENCE"
        case .vmManagerId: return "VM_MANAGER_ID"
        case .vmName: return "VM_NAME"
        case .vmPath: return "VM_PATH"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ResourceAttributeType(rawValue: rawValue) ?? ResourceAttributeType.sdkUnknown(rawValue)
    }
}

extension ResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundException(message: \(String(describing: message)))"}
}

extension ResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Exception raised when the request references a resource (Application Discovery Service
///          configuration, update stream, migration task, etc.) that does not exist in Application
///          Discovery Service (Application Discovery Service) or in Migration Hub's repository.</p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension ResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceUnavailableException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceUnavailableException(message: \(String(describing: message)))"}
}

extension ServiceUnavailableException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ServiceUnavailableExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Exception raised when there is an internal, configuration, or dependency error
///          encountered.</p>
public struct ServiceUnavailableException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceUnavailableExceptionBody: Equatable {
    public let message: String?
}

extension ServiceUnavailableExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum Status {
    case completed
    case failed
    case inProgress
    case notStarted
    case sdkUnknown(String)
}

extension Status : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Status] {
        return [
            .completed,
            .failed,
            .inProgress,
            .notStarted,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .completed: return "COMPLETED"
        case .failed: return "FAILED"
        case .inProgress: return "IN_PROGRESS"
        case .notStarted: return "NOT_STARTED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Status(rawValue: rawValue) ?? Status.sdkUnknown(rawValue)
    }
}

extension Task: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case progressPercent = "ProgressPercent"
        case status = "Status"
        case statusDetail = "StatusDetail"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let progressPercent = progressPercent {
            try encodeContainer.encode(progressPercent, forKey: .progressPercent)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusDetail = statusDetail {
            try encodeContainer.encode(statusDetail, forKey: .statusDetail)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(Status.self, forKey: .status)
        status = statusDecoded
        let statusDetailDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statusDetail)
        statusDetail = statusDetailDecoded
        let progressPercentDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .progressPercent)
        progressPercent = progressPercentDecoded
    }
}

extension Task: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Task(progressPercent: \(String(describing: progressPercent)), status: \(String(describing: status)), statusDetail: \(String(describing: statusDetail)))"}
}

/// <p>Task object encapsulating task information.</p>
public struct Task: Equatable {
    /// <p>Indication of the percentage completion of the task.</p>
    public let progressPercent: Int?
    /// <p>Status of the task - Not Started, In-Progress, Complete.</p>
    public let status: Status?
    /// <p>Details of task status as notified by a migration tool. A tool might use this field to
    ///          provide clarifying information about the status that is unique to that tool or that
    ///          explains an error state.</p>
    public let statusDetail: String?

    public init (
        progressPercent: Int? = nil,
        status: Status? = nil,
        statusDetail: String? = nil
    )
    {
        self.progressPercent = progressPercent
        self.status = status
        self.statusDetail = statusDetail
    }
}

extension ThrottlingException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ThrottlingException(message: \(String(describing: message)), retryAfterSeconds: \(String(describing: retryAfterSeconds)))"}
}

extension ThrottlingException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.retryAfterSeconds = Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.retryAfterSeconds = 0
        }
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request was denied due to request throttling.</p>
public struct ThrottlingException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A message that provides information about the exception.</p>
    public var message: String?
    /// <p>The number of seconds the caller should wait before retrying.</p>
    public var retryAfterSeconds: Int

    public init (
        message: String? = nil,
        retryAfterSeconds: Int = 0
    )
    {
        self.message = message
        self.retryAfterSeconds = retryAfterSeconds
    }
}

struct ThrottlingExceptionBody: Equatable {
    public let message: String?
}

extension ThrottlingExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UnauthorizedOperation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UnauthorizedOperation(message: \(String(describing: message)))"}
}

extension UnauthorizedOperation: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UnauthorizedOperationBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Exception raised to indicate a request was not authorized when the <code>DryRun</code>
///          flag is set to "true".</p>
public struct UnauthorizedOperation: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct UnauthorizedOperationBody: Equatable {
    public let message: String?
}

extension UnauthorizedOperationBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}
