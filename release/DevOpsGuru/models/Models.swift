// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccessDeniedException(message: \(String(describing: message)))"}
}

extension AccessDeniedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p> You don't have permissions to perform the requested operation. The user or role that is making the request must have at
/// 			least one IAM permissions policy attached that grants the required permissions. For more information, see
/// 			<a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access.html">Access Management</a> in the <i>IAM User Guide</i>. </p>
public struct AccessDeniedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Equatable {
    public let message: String?
}

extension AccessDeniedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct AddNotificationChannelInputBodyMiddleware: Middleware {
    public let id: String = "AddNotificationChannelInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddNotificationChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<AddNotificationChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddNotificationChannelInput>
    public typealias MOutput = OperationOutput<AddNotificationChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddNotificationChannelOutputError>
}

extension AddNotificationChannelInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AddNotificationChannelInput(config: \(String(describing: config)))"}
}

extension AddNotificationChannelInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case config = "Config"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let config = config {
            try encodeContainer.encode(config, forKey: .config)
        }
    }
}

public struct AddNotificationChannelInputHeadersMiddleware: Middleware {
    public let id: String = "AddNotificationChannelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddNotificationChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<AddNotificationChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddNotificationChannelInput>
    public typealias MOutput = OperationOutput<AddNotificationChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddNotificationChannelOutputError>
}

public struct AddNotificationChannelInputQueryItemMiddleware: Middleware {
    public let id: String = "AddNotificationChannelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddNotificationChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<AddNotificationChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddNotificationChannelInput>
    public typealias MOutput = OperationOutput<AddNotificationChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddNotificationChannelOutputError>
}

public struct AddNotificationChannelInput: Equatable {
    /// <p> A <code>NotificationChannelConfig</code> object that specifies what type of
    ///    		notification channel to add. The one
    ///       	supported notification channel is Amazon Simple Notification Service (Amazon SNS). </p>
    public let config: NotificationChannelConfig?

    public init (
        config: NotificationChannelConfig? = nil
    )
    {
        self.config = config
    }
}

struct AddNotificationChannelInputBody: Equatable {
    public let config: NotificationChannelConfig?
}

extension AddNotificationChannelInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case config = "Config"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configDecoded = try containerValues.decodeIfPresent(NotificationChannelConfig.self, forKey: .config)
        config = configDecoded
    }
}

extension AddNotificationChannelOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AddNotificationChannelOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AddNotificationChannelOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddNotificationChannelOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AddNotificationChannelOutputResponse(id: \(String(describing: id)))"}
}

extension AddNotificationChannelOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AddNotificationChannelOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.id = output.id
        } else {
            self.id = nil
        }
    }
}

public struct AddNotificationChannelOutputResponse: Equatable {
    /// <p>
    ///    		The ID of the added notification channel.
    ///    	</p>
    public let id: String?

    public init (
        id: String? = nil
    )
    {
        self.id = id
    }
}

struct AddNotificationChannelOutputResponseBody: Equatable {
    public let id: String?
}

extension AddNotificationChannelOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case id = "Id"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
    }
}

public enum AnomalySeverity {
    case high
    case low
    case medium
    case sdkUnknown(String)
}

extension AnomalySeverity : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AnomalySeverity] {
        return [
            .high,
            .low,
            .medium,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .high: return "HIGH"
        case .low: return "LOW"
        case .medium: return "MEDIUM"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AnomalySeverity(rawValue: rawValue) ?? AnomalySeverity.sdkUnknown(rawValue)
    }
}

extension AnomalySourceDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cloudWatchMetrics = "CloudWatchMetrics"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudWatchMetrics = cloudWatchMetrics {
            var cloudWatchMetricsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .cloudWatchMetrics)
            for cloudwatchmetricsdetails0 in cloudWatchMetrics {
                try cloudWatchMetricsContainer.encode(cloudwatchmetricsdetails0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudWatchMetricsContainer = try containerValues.decodeIfPresent([CloudWatchMetricsDetail?].self, forKey: .cloudWatchMetrics)
        var cloudWatchMetricsDecoded0:[CloudWatchMetricsDetail]? = nil
        if let cloudWatchMetricsContainer = cloudWatchMetricsContainer {
            cloudWatchMetricsDecoded0 = [CloudWatchMetricsDetail]()
            for structure0 in cloudWatchMetricsContainer {
                if let structure0 = structure0 {
                    cloudWatchMetricsDecoded0?.append(structure0)
                }
            }
        }
        cloudWatchMetrics = cloudWatchMetricsDecoded0
    }
}

extension AnomalySourceDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AnomalySourceDetails(cloudWatchMetrics: \(String(describing: cloudWatchMetrics)))"}
}

/// <p> Details about the source of the anomalous operational data that triggered the anomaly. The
/// 			one supported source is Amazon CloudWatch metrics. </p>
public struct AnomalySourceDetails: Equatable {
    /// <p> An array of <code>CloudWatchMetricsDetail</code> object that contains information
    /// 			about the analyzed metrics that displayed anomalous behavior. </p>
    public let cloudWatchMetrics: [CloudWatchMetricsDetail]?

    public init (
        cloudWatchMetrics: [CloudWatchMetricsDetail]? = nil
    )
    {
        self.cloudWatchMetrics = cloudWatchMetrics
    }
}

public enum AnomalyStatus {
    case closed
    case ongoing
    case sdkUnknown(String)
}

extension AnomalyStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AnomalyStatus] {
        return [
            .closed,
            .ongoing,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .closed: return "CLOSED"
        case .ongoing: return "ONGOING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AnomalyStatus(rawValue: rawValue) ?? AnomalyStatus.sdkUnknown(rawValue)
    }
}

extension AnomalyTimeRange: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case endTime = "EndTime"
        case startTime = "StartTime"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .endTime)
        endTime = endTimeDecoded
    }
}

extension AnomalyTimeRange: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AnomalyTimeRange(endTime: \(String(describing: endTime)), startTime: \(String(describing: startTime)))"}
}

/// <p>
/// 			A time range that specifies when the observed unusual behavior in an anomaly started and ended.
/// 		</p>
public struct AnomalyTimeRange: Equatable {
    /// <p> The time when the anomalous behavior ended. </p>
    public let endTime: Date?
    /// <p>
    /// 			The time when the anomalous behavior started.
    /// 		</p>
    public let startTime: Date?

    public init (
        endTime: Date? = nil,
        startTime: Date? = nil
    )
    {
        self.endTime = endTime
        self.startTime = startTime
    }
}

extension CloudFormationCollection: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case stackNames = "StackNames"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let stackNames = stackNames {
            var stackNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .stackNames)
            for stacknames0 in stackNames {
                try stackNamesContainer.encode(stacknames0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackNamesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .stackNames)
        var stackNamesDecoded0:[String]? = nil
        if let stackNamesContainer = stackNamesContainer {
            stackNamesDecoded0 = [String]()
            for string0 in stackNamesContainer {
                if let string0 = string0 {
                    stackNamesDecoded0?.append(string0)
                }
            }
        }
        stackNames = stackNamesDecoded0
    }
}

extension CloudFormationCollection: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CloudFormationCollection(stackNames: \(String(describing: stackNames)))"}
}

/// <p>
/// 			Information about AWS CloudFormation stacks. You can use up to 500 stacks to specify which AWS resources in your account to analyze.
/// 			For more information, see <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/stacks.html">Stacks</a>
/// 			in the <i>AWS CloudFormation User Guide</i>.
/// 		</p>
public struct CloudFormationCollection: Equatable {
    /// <p>
    /// 			An array of CloudFormation stack names.
    /// 		</p>
    public let stackNames: [String]?

    public init (
        stackNames: [String]? = nil
    )
    {
        self.stackNames = stackNames
    }
}

extension CloudFormationCollectionFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case stackNames = "StackNames"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let stackNames = stackNames {
            var stackNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .stackNames)
            for stacknames0 in stackNames {
                try stackNamesContainer.encode(stacknames0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackNamesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .stackNames)
        var stackNamesDecoded0:[String]? = nil
        if let stackNamesContainer = stackNamesContainer {
            stackNamesDecoded0 = [String]()
            for string0 in stackNamesContainer {
                if let string0 = string0 {
                    stackNamesDecoded0?.append(string0)
                }
            }
        }
        stackNames = stackNamesDecoded0
    }
}

extension CloudFormationCollectionFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CloudFormationCollectionFilter(stackNames: \(String(describing: stackNames)))"}
}

/// <p>
/// 			Information about AWS CloudFormation stacks. You can use up to 500 stacks to specify which AWS resources in your account to analyze.
/// 			For more information, see <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/stacks.html">Stacks</a>
/// 			in the <i>AWS CloudFormation User Guide</i>.
/// 		</p>
public struct CloudFormationCollectionFilter: Equatable {
    /// <p>
    /// 			An array of CloudFormation stack names.
    /// 		</p>
    public let stackNames: [String]?

    public init (
        stackNames: [String]? = nil
    )
    {
        self.stackNames = stackNames
    }
}

extension CloudFormationCostEstimationResourceCollectionFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case stackNames = "StackNames"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let stackNames = stackNames {
            var stackNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .stackNames)
            for costestimationstacknames0 in stackNames {
                try stackNamesContainer.encode(costestimationstacknames0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackNamesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .stackNames)
        var stackNamesDecoded0:[String]? = nil
        if let stackNamesContainer = stackNamesContainer {
            stackNamesDecoded0 = [String]()
            for string0 in stackNamesContainer {
                if let string0 = string0 {
                    stackNamesDecoded0?.append(string0)
                }
            }
        }
        stackNames = stackNamesDecoded0
    }
}

extension CloudFormationCostEstimationResourceCollectionFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CloudFormationCostEstimationResourceCollectionFilter(stackNames: \(String(describing: stackNames)))"}
}

/// <p>Information about an AWS CloudFormation stack used to create a monthly cost estimate for DevOps Guru to analyze
/// 		AWS resources. The maximum number of stacks you can specify for a cost estimate is one. The estimate created is for the cost
/// 		to analyze the AWS resources defined by the stack. For more information, see <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/stacks.html">Stacks</a>
/// 			in the <i>AWS CloudFormation User Guide</i>.</p>
public struct CloudFormationCostEstimationResourceCollectionFilter: Equatable {
    /// <p>An array of CloudFormation stack names. Its size is fixed at 1 item.</p>
    public let stackNames: [String]?

    public init (
        stackNames: [String]? = nil
    )
    {
        self.stackNames = stackNames
    }
}

extension CloudFormationHealth: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case insight = "Insight"
        case stackName = "StackName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let insight = insight {
            try encodeContainer.encode(insight, forKey: .insight)
        }
        if let stackName = stackName {
            try encodeContainer.encode(stackName, forKey: .stackName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stackName)
        stackName = stackNameDecoded
        let insightDecoded = try containerValues.decodeIfPresent(InsightHealth.self, forKey: .insight)
        insight = insightDecoded
    }
}

extension CloudFormationHealth: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CloudFormationHealth(insight: \(String(describing: insight)), stackName: \(String(describing: stackName)))"}
}

/// <p>
///    		Information about the health of AWS resources in your account that are specified by an AWS CloudFormation stack.
///    	</p>
public struct CloudFormationHealth: Equatable {
    /// <p>
    ///    		Information about the health of the AWS resources in your account that are specified by an AWS CloudFormation stack, including
    ///    		the number of open proactive, open reactive insights, and the Mean Time to Recover (MTTR) of closed insights.
    ///    	</p>
    public let insight: InsightHealth?
    /// <p>
    ///    		The name of the CloudFormation stack.
    ///    	</p>
    public let stackName: String?

    public init (
        insight: InsightHealth? = nil,
        stackName: String? = nil
    )
    {
        self.insight = insight
        self.stackName = stackName
    }
}

extension CloudWatchMetricsDetail: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dimensions = "Dimensions"
        case metricName = "MetricName"
        case namespace = "Namespace"
        case period = "Period"
        case stat = "Stat"
        case unit = "Unit"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dimensions = dimensions {
            var dimensionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dimensions)
            for cloudwatchmetricsdimensions0 in dimensions {
                try dimensionsContainer.encode(cloudwatchmetricsdimensions0)
            }
        }
        if let metricName = metricName {
            try encodeContainer.encode(metricName, forKey: .metricName)
        }
        if let namespace = namespace {
            try encodeContainer.encode(namespace, forKey: .namespace)
        }
        if period != 0 {
            try encodeContainer.encode(period, forKey: .period)
        }
        if let stat = stat {
            try encodeContainer.encode(stat.rawValue, forKey: .stat)
        }
        if let unit = unit {
            try encodeContainer.encode(unit, forKey: .unit)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .metricName)
        metricName = metricNameDecoded
        let namespaceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .namespace)
        namespace = namespaceDecoded
        let dimensionsContainer = try containerValues.decodeIfPresent([CloudWatchMetricsDimension?].self, forKey: .dimensions)
        var dimensionsDecoded0:[CloudWatchMetricsDimension]? = nil
        if let dimensionsContainer = dimensionsContainer {
            dimensionsDecoded0 = [CloudWatchMetricsDimension]()
            for structure0 in dimensionsContainer {
                if let structure0 = structure0 {
                    dimensionsDecoded0?.append(structure0)
                }
            }
        }
        dimensions = dimensionsDecoded0
        let statDecoded = try containerValues.decodeIfPresent(CloudWatchMetricsStat.self, forKey: .stat)
        stat = statDecoded
        let unitDecoded = try containerValues.decodeIfPresent(String.self, forKey: .unit)
        unit = unitDecoded
        let periodDecoded = try containerValues.decode(Int.self, forKey: .period)
        period = periodDecoded
    }
}

extension CloudWatchMetricsDetail: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CloudWatchMetricsDetail(dimensions: \(String(describing: dimensions)), metricName: \(String(describing: metricName)), namespace: \(String(describing: namespace)), period: \(String(describing: period)), stat: \(String(describing: stat)), unit: \(String(describing: unit)))"}
}

/// <p>
/// 			Information about an Amazon CloudWatch metric.
/// 		</p>
public struct CloudWatchMetricsDetail: Equatable {
    /// <p>
    /// 			An array of CloudWatch dimensions associated with
    /// 		</p>
    public let dimensions: [CloudWatchMetricsDimension]?
    /// <p>
    /// 			The name of the CloudWatch metric.
    /// 		</p>
    public let metricName: String?
    /// <p>
    /// 			The namespace of the CloudWatch metric. A namespace is a container for CloudWatch metrics.
    /// 		</p>
    public let namespace: String?
    /// <p>
    /// 			The length of time associated with the CloudWatch metric in number of seconds.
    /// 		</p>
    public let period: Int
    /// <p>
    /// 			The type of statistic associated with the CloudWatch metric. For more information, see
    /// 			<a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/cloudwatch_concepts.html#Statistic">Statistics</a> in the
    /// 			<i>Amazon CloudWatch User Guide</i>.
    /// 		</p>
    public let stat: CloudWatchMetricsStat?
    /// <p>
    /// 			The unit of measure used for the CloudWatch metric. For example, <code>Bytes</code>, <code>Seconds</code>,
    /// 			<code>Count</code>, and <code>Percent</code>.
    /// 		</p>
    public let unit: String?

    public init (
        dimensions: [CloudWatchMetricsDimension]? = nil,
        metricName: String? = nil,
        namespace: String? = nil,
        period: Int = 0,
        stat: CloudWatchMetricsStat? = nil,
        unit: String? = nil
    )
    {
        self.dimensions = dimensions
        self.metricName = metricName
        self.namespace = namespace
        self.period = period
        self.stat = stat
        self.unit = unit
    }
}

extension CloudWatchMetricsDimension: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension CloudWatchMetricsDimension: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CloudWatchMetricsDimension(name: \(String(describing: name)), value: \(String(describing: value)))"}
}

/// <p> The dimension of a Amazon CloudWatch metric that is used when DevOps Guru analyzes the resources in your
/// 			account for operational problems and anomalous behavior. A dimension is a name/value pair
/// 			that is part of the identity of a metric. A metric can have up to 10 dimensions. For more
/// 			information, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/cloudwatch_concepts.html#Dimension">Dimensions</a> in the <i>Amazon CloudWatch User Guide</i>. </p>
public struct CloudWatchMetricsDimension: Equatable {
    /// <p>
    /// 			The name of the CloudWatch dimension.
    /// 		</p>
    public let name: String?
    /// <p>
    /// 			The value of the CloudWatch dimension.
    /// 		</p>
    public let value: String?

    public init (
        name: String? = nil,
        value: String? = nil
    )
    {
        self.name = name
        self.value = value
    }
}

public enum CloudWatchMetricsStat {
    case average
    case maximum
    case minimum
    case p50
    case p90
    case p99
    case sampleCount
    case sum
    case sdkUnknown(String)
}

extension CloudWatchMetricsStat : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [CloudWatchMetricsStat] {
        return [
            .average,
            .maximum,
            .minimum,
            .p50,
            .p90,
            .p99,
            .sampleCount,
            .sum,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .average: return "Average"
        case .maximum: return "Maximum"
        case .minimum: return "Minimum"
        case .p50: return "p50"
        case .p90: return "p90"
        case .p99: return "p99"
        case .sampleCount: return "SampleCount"
        case .sum: return "Sum"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = CloudWatchMetricsStat(rawValue: rawValue) ?? CloudWatchMetricsStat.sdkUnknown(rawValue)
    }
}

extension ConflictException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConflictException(message: \(String(describing: message)), resourceId: \(String(describing: resourceId)), resourceType: \(String(describing: resourceType)))"}
}

extension ConflictException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>
/// 			An exception that is thrown when a conflict occurs.
/// 		</p>
public struct ConflictException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    /// <p>
    /// 			The ID of the AWS resource in which a conflict occurred.
    /// 		</p>
    public var resourceId: String?
    /// <p>
    /// 			The type of the AWS resource in which a conflict occurred.
    /// 		</p>
    public var resourceType: String?

    public init (
        message: String? = nil,
        resourceId: String? = nil,
        resourceType: String? = nil
    )
    {
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ConflictExceptionBody: Equatable {
    public let message: String?
    public let resourceId: String?
    public let resourceType: String?
}

extension ConflictExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension CostEstimationResourceCollectionFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cloudFormation = "CloudFormation"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudFormation = cloudFormation {
            try encodeContainer.encode(cloudFormation, forKey: .cloudFormation)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudFormationDecoded = try containerValues.decodeIfPresent(CloudFormationCostEstimationResourceCollectionFilter.self, forKey: .cloudFormation)
        cloudFormation = cloudFormationDecoded
    }
}

extension CostEstimationResourceCollectionFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CostEstimationResourceCollectionFilter(cloudFormation: \(String(describing: cloudFormation)))"}
}

/// <p>Information about a filter used to specify which AWS resources are analyzed to create
/// 			a monthly DevOps Guru cost estimate. For more information,
/// 			see <a href="https://docs.aws.amazon.com/devops-guru/latest/userguide/cost-estimate.html">Estimate your
/// 			Amazon DevOps Guru costs</a> and
/// 			<a href="http://aws.amazon.com/devops-guru/pricing/">Amazon DevOps Guru pricing</a>.
/// 		</p>
public struct CostEstimationResourceCollectionFilter: Equatable {
    /// <p>An object that specifies the CloudFormation stack that defines the AWS resources
    /// 			used to create a monthly estimate for DevOps Guru.</p>
    public let cloudFormation: CloudFormationCostEstimationResourceCollectionFilter?

    public init (
        cloudFormation: CloudFormationCostEstimationResourceCollectionFilter? = nil
    )
    {
        self.cloudFormation = cloudFormation
    }
}

public enum CostEstimationServiceResourceState {
    case active
    case inactive
    case sdkUnknown(String)
}

extension CostEstimationServiceResourceState : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [CostEstimationServiceResourceState] {
        return [
            .active,
            .inactive,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .active: return "ACTIVE"
        case .inactive: return "INACTIVE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = CostEstimationServiceResourceState(rawValue: rawValue) ?? CostEstimationServiceResourceState.sdkUnknown(rawValue)
    }
}

public enum CostEstimationStatus {
    case completed
    case ongoing
    case sdkUnknown(String)
}

extension CostEstimationStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [CostEstimationStatus] {
        return [
            .completed,
            .ongoing,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .completed: return "COMPLETED"
        case .ongoing: return "ONGOING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = CostEstimationStatus(rawValue: rawValue) ?? CostEstimationStatus.sdkUnknown(rawValue)
    }
}

extension CostEstimationTimeRange: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case endTime = "EndTime"
        case startTime = "StartTime"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .endTime)
        endTime = endTimeDecoded
    }
}

extension CostEstimationTimeRange: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CostEstimationTimeRange(endTime: \(String(describing: endTime)), startTime: \(String(describing: startTime)))"}
}

/// <p>The time range of a cost estimation.</p>
public struct CostEstimationTimeRange: Equatable {
    /// <p>The end time of the cost estimation.</p>
    public let endTime: Date?
    /// <p>The start time of the cost estimation.</p>
    public let startTime: Date?

    public init (
        endTime: Date? = nil,
        startTime: Date? = nil
    )
    {
        self.endTime = endTime
        self.startTime = startTime
    }
}

extension DescribeAccountHealthInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAccountHealthInput()"}
}

extension DescribeAccountHealthInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeAccountHealthInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeAccountHealthInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAccountHealthInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAccountHealthOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAccountHealthInput>
    public typealias MOutput = OperationOutput<DescribeAccountHealthOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAccountHealthOutputError>
}

public struct DescribeAccountHealthInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeAccountHealthInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAccountHealthInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAccountHealthOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAccountHealthInput>
    public typealias MOutput = OperationOutput<DescribeAccountHealthOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAccountHealthOutputError>
}

public struct DescribeAccountHealthInput: Equatable {

    public init() {}
}

struct DescribeAccountHealthInputBody: Equatable {
}

extension DescribeAccountHealthInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeAccountHealthOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAccountHealthOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAccountHealthOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAccountHealthOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAccountHealthOutputResponse(metricsAnalyzed: \(String(describing: metricsAnalyzed)), openProactiveInsights: \(String(describing: openProactiveInsights)), openReactiveInsights: \(String(describing: openReactiveInsights)), resourceHours: \(String(describing: resourceHours)))"}
}

extension DescribeAccountHealthOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeAccountHealthOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.metricsAnalyzed = output.metricsAnalyzed
            self.openProactiveInsights = output.openProactiveInsights
            self.openReactiveInsights = output.openReactiveInsights
            self.resourceHours = output.resourceHours
        } else {
            self.metricsAnalyzed = 0
            self.openProactiveInsights = 0
            self.openReactiveInsights = 0
            self.resourceHours = nil
        }
    }
}

public struct DescribeAccountHealthOutputResponse: Equatable {
    /// <p>
    ///    		An integer that specifies the number of metrics that have been analyzed in your AWS account.
    ///    	</p>
    public let metricsAnalyzed: Int
    /// <p>
    ///    		An integer that specifies the number of open proactive insights in your AWS account.
    ///    	</p>
    public let openProactiveInsights: Int
    /// <p>
    ///    		An integer that specifies the number of open reactive insights in your AWS account.
    ///    	</p>
    public let openReactiveInsights: Int
    /// <p>The number of Amazon DevOps Guru resource analysis hours billed to the current AWS account in the last hour.
    ///  		</p>
    public let resourceHours: Int?

    public init (
        metricsAnalyzed: Int = 0,
        openProactiveInsights: Int = 0,
        openReactiveInsights: Int = 0,
        resourceHours: Int? = nil
    )
    {
        self.metricsAnalyzed = metricsAnalyzed
        self.openProactiveInsights = openProactiveInsights
        self.openReactiveInsights = openReactiveInsights
        self.resourceHours = resourceHours
    }
}

struct DescribeAccountHealthOutputResponseBody: Equatable {
    public let openReactiveInsights: Int
    public let openProactiveInsights: Int
    public let metricsAnalyzed: Int
    public let resourceHours: Int?
}

extension DescribeAccountHealthOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case metricsAnalyzed = "MetricsAnalyzed"
        case openProactiveInsights = "OpenProactiveInsights"
        case openReactiveInsights = "OpenReactiveInsights"
        case resourceHours = "ResourceHours"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let openReactiveInsightsDecoded = try containerValues.decode(Int.self, forKey: .openReactiveInsights)
        openReactiveInsights = openReactiveInsightsDecoded
        let openProactiveInsightsDecoded = try containerValues.decode(Int.self, forKey: .openProactiveInsights)
        openProactiveInsights = openProactiveInsightsDecoded
        let metricsAnalyzedDecoded = try containerValues.decode(Int.self, forKey: .metricsAnalyzed)
        metricsAnalyzed = metricsAnalyzedDecoded
        let resourceHoursDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .resourceHours)
        resourceHours = resourceHoursDecoded
    }
}

public struct DescribeAccountOverviewInputBodyMiddleware: Middleware {
    public let id: String = "DescribeAccountOverviewInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAccountOverviewInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAccountOverviewOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAccountOverviewInput>
    public typealias MOutput = OperationOutput<DescribeAccountOverviewOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAccountOverviewOutputError>
}

extension DescribeAccountOverviewInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAccountOverviewInput(fromTime: \(String(describing: fromTime)), toTime: \(String(describing: toTime)))"}
}

extension DescribeAccountOverviewInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case fromTime = "FromTime"
        case toTime = "ToTime"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fromTime = fromTime {
            try encodeContainer.encode(fromTime.timeIntervalSince1970, forKey: .fromTime)
        }
        if let toTime = toTime {
            try encodeContainer.encode(toTime.timeIntervalSince1970, forKey: .toTime)
        }
    }
}

public struct DescribeAccountOverviewInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeAccountOverviewInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAccountOverviewInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAccountOverviewOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAccountOverviewInput>
    public typealias MOutput = OperationOutput<DescribeAccountOverviewOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAccountOverviewOutputError>
}

public struct DescribeAccountOverviewInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeAccountOverviewInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAccountOverviewInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAccountOverviewOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAccountOverviewInput>
    public typealias MOutput = OperationOutput<DescribeAccountOverviewOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAccountOverviewOutputError>
}

public struct DescribeAccountOverviewInput: Equatable {
    /// <p>
    ///    		The start of the time range passed in. The start time granularity is at the
    ///    		day level. The floor of the start time is used. Returned information occurred after this day.
    ///    	</p>
    public let fromTime: Date?
    /// <p>
    ///    		The end of the time range passed in. The start time granularity is at the
    ///    		day level. The floor of the start time is used. Returned information occurred before this day. If this is not specified, then the current day is used.
    ///    	</p>
    public let toTime: Date?

    public init (
        fromTime: Date? = nil,
        toTime: Date? = nil
    )
    {
        self.fromTime = fromTime
        self.toTime = toTime
    }
}

struct DescribeAccountOverviewInputBody: Equatable {
    public let fromTime: Date?
    public let toTime: Date?
}

extension DescribeAccountOverviewInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case fromTime = "FromTime"
        case toTime = "ToTime"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fromTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .fromTime)
        fromTime = fromTimeDecoded
        let toTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .toTime)
        toTime = toTimeDecoded
    }
}

extension DescribeAccountOverviewOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAccountOverviewOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAccountOverviewOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAccountOverviewOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAccountOverviewOutputResponse(meanTimeToRecoverInMilliseconds: \(String(describing: meanTimeToRecoverInMilliseconds)), proactiveInsights: \(String(describing: proactiveInsights)), reactiveInsights: \(String(describing: reactiveInsights)))"}
}

extension DescribeAccountOverviewOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeAccountOverviewOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.meanTimeToRecoverInMilliseconds = output.meanTimeToRecoverInMilliseconds
            self.proactiveInsights = output.proactiveInsights
            self.reactiveInsights = output.reactiveInsights
        } else {
            self.meanTimeToRecoverInMilliseconds = nil
            self.proactiveInsights = 0
            self.reactiveInsights = 0
        }
    }
}

public struct DescribeAccountOverviewOutputResponse: Equatable {
    /// <p>
    ///    		The Mean Time to Recover (MTTR) for all closed insights that were created during the
    ///    		time range passed in.
    ///    	</p>
    public let meanTimeToRecoverInMilliseconds: Int?
    /// <p>
    ///    		An integer that specifies the number of open proactive insights in your AWS account that were created during the
    ///    		time range passed in.
    ///    	</p>
    public let proactiveInsights: Int
    /// <p>
    ///    		An integer that specifies the number of open reactive insights in your AWS account that were created during the
    ///    		time range passed in.
    ///    	</p>
    public let reactiveInsights: Int

    public init (
        meanTimeToRecoverInMilliseconds: Int? = nil,
        proactiveInsights: Int = 0,
        reactiveInsights: Int = 0
    )
    {
        self.meanTimeToRecoverInMilliseconds = meanTimeToRecoverInMilliseconds
        self.proactiveInsights = proactiveInsights
        self.reactiveInsights = reactiveInsights
    }
}

struct DescribeAccountOverviewOutputResponseBody: Equatable {
    public let reactiveInsights: Int
    public let proactiveInsights: Int
    public let meanTimeToRecoverInMilliseconds: Int?
}

extension DescribeAccountOverviewOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case meanTimeToRecoverInMilliseconds = "MeanTimeToRecoverInMilliseconds"
        case proactiveInsights = "ProactiveInsights"
        case reactiveInsights = "ReactiveInsights"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reactiveInsightsDecoded = try containerValues.decode(Int.self, forKey: .reactiveInsights)
        reactiveInsights = reactiveInsightsDecoded
        let proactiveInsightsDecoded = try containerValues.decode(Int.self, forKey: .proactiveInsights)
        proactiveInsights = proactiveInsightsDecoded
        let meanTimeToRecoverInMillisecondsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .meanTimeToRecoverInMilliseconds)
        meanTimeToRecoverInMilliseconds = meanTimeToRecoverInMillisecondsDecoded
    }
}

extension DescribeAnomalyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAnomalyInput(id: \(String(describing: id)))"}
}

extension DescribeAnomalyInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeAnomalyInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeAnomalyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAnomalyInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAnomalyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAnomalyInput>
    public typealias MOutput = OperationOutput<DescribeAnomalyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAnomalyOutputError>
}

public struct DescribeAnomalyInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeAnomalyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAnomalyInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAnomalyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAnomalyInput>
    public typealias MOutput = OperationOutput<DescribeAnomalyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAnomalyOutputError>
}

public struct DescribeAnomalyInput: Equatable {
    /// <p>
    ///    		The ID of the anomaly.
    ///    	</p>
    public let id: String?

    public init (
        id: String? = nil
    )
    {
        self.id = id
    }
}

struct DescribeAnomalyInputBody: Equatable {
}

extension DescribeAnomalyInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeAnomalyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAnomalyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAnomalyOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAnomalyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAnomalyOutputResponse(proactiveAnomaly: \(String(describing: proactiveAnomaly)), reactiveAnomaly: \(String(describing: reactiveAnomaly)))"}
}

extension DescribeAnomalyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeAnomalyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.proactiveAnomaly = output.proactiveAnomaly
            self.reactiveAnomaly = output.reactiveAnomaly
        } else {
            self.proactiveAnomaly = nil
            self.reactiveAnomaly = nil
        }
    }
}

public struct DescribeAnomalyOutputResponse: Equatable {
    /// <p>
    /// 			A <code>ReactiveAnomaly</code> object that represents the requested anomaly.
    /// 		</p>
    public let proactiveAnomaly: ProactiveAnomaly?
    /// <p>
    /// 			A <code>ProactiveAnomaly</code> object that represents the requested anomaly.
    /// 		</p>
    public let reactiveAnomaly: ReactiveAnomaly?

    public init (
        proactiveAnomaly: ProactiveAnomaly? = nil,
        reactiveAnomaly: ReactiveAnomaly? = nil
    )
    {
        self.proactiveAnomaly = proactiveAnomaly
        self.reactiveAnomaly = reactiveAnomaly
    }
}

struct DescribeAnomalyOutputResponseBody: Equatable {
    public let proactiveAnomaly: ProactiveAnomaly?
    public let reactiveAnomaly: ReactiveAnomaly?
}

extension DescribeAnomalyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case proactiveAnomaly = "ProactiveAnomaly"
        case reactiveAnomaly = "ReactiveAnomaly"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let proactiveAnomalyDecoded = try containerValues.decodeIfPresent(ProactiveAnomaly.self, forKey: .proactiveAnomaly)
        proactiveAnomaly = proactiveAnomalyDecoded
        let reactiveAnomalyDecoded = try containerValues.decodeIfPresent(ReactiveAnomaly.self, forKey: .reactiveAnomaly)
        reactiveAnomaly = reactiveAnomalyDecoded
    }
}

public struct DescribeFeedbackInputBodyMiddleware: Middleware {
    public let id: String = "DescribeFeedbackInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeFeedbackInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeFeedbackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeFeedbackInput>
    public typealias MOutput = OperationOutput<DescribeFeedbackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeFeedbackOutputError>
}

extension DescribeFeedbackInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeFeedbackInput(insightId: \(String(describing: insightId)))"}
}

extension DescribeFeedbackInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case insightId = "InsightId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let insightId = insightId {
            try encodeContainer.encode(insightId, forKey: .insightId)
        }
    }
}

public struct DescribeFeedbackInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeFeedbackInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeFeedbackInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeFeedbackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeFeedbackInput>
    public typealias MOutput = OperationOutput<DescribeFeedbackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeFeedbackOutputError>
}

public struct DescribeFeedbackInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeFeedbackInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeFeedbackInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeFeedbackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeFeedbackInput>
    public typealias MOutput = OperationOutput<DescribeFeedbackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeFeedbackOutputError>
}

public struct DescribeFeedbackInput: Equatable {
    /// <p>
    /// 			The ID of the insight for which the feedback was provided.
    /// 		</p>
    public let insightId: String?

    public init (
        insightId: String? = nil
    )
    {
        self.insightId = insightId
    }
}

struct DescribeFeedbackInputBody: Equatable {
    public let insightId: String?
}

extension DescribeFeedbackInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case insightId = "InsightId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let insightIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .insightId)
        insightId = insightIdDecoded
    }
}

extension DescribeFeedbackOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeFeedbackOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeFeedbackOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeFeedbackOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeFeedbackOutputResponse(insightFeedback: \(String(describing: insightFeedback)))"}
}

extension DescribeFeedbackOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeFeedbackOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.insightFeedback = output.insightFeedback
        } else {
            self.insightFeedback = nil
        }
    }
}

public struct DescribeFeedbackOutputResponse: Equatable {
    /// <p>
    ///       	Information about insight feedback received from a customer.
    ///       </p>
    public let insightFeedback: InsightFeedback?

    public init (
        insightFeedback: InsightFeedback? = nil
    )
    {
        self.insightFeedback = insightFeedback
    }
}

struct DescribeFeedbackOutputResponseBody: Equatable {
    public let insightFeedback: InsightFeedback?
}

extension DescribeFeedbackOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case insightFeedback = "InsightFeedback"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let insightFeedbackDecoded = try containerValues.decodeIfPresent(InsightFeedback.self, forKey: .insightFeedback)
        insightFeedback = insightFeedbackDecoded
    }
}

extension DescribeInsightInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeInsightInput(id: \(String(describing: id)))"}
}

extension DescribeInsightInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeInsightInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeInsightInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeInsightInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeInsightOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeInsightInput>
    public typealias MOutput = OperationOutput<DescribeInsightOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeInsightOutputError>
}

public struct DescribeInsightInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeInsightInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeInsightInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeInsightOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeInsightInput>
    public typealias MOutput = OperationOutput<DescribeInsightOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeInsightOutputError>
}

public struct DescribeInsightInput: Equatable {
    /// <p>
    ///    		The ID of the insight.
    ///    	</p>
    public let id: String?

    public init (
        id: String? = nil
    )
    {
        self.id = id
    }
}

struct DescribeInsightInputBody: Equatable {
}

extension DescribeInsightInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeInsightOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeInsightOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeInsightOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeInsightOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeInsightOutputResponse(proactiveInsight: \(String(describing: proactiveInsight)), reactiveInsight: \(String(describing: reactiveInsight)))"}
}

extension DescribeInsightOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeInsightOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.proactiveInsight = output.proactiveInsight
            self.reactiveInsight = output.reactiveInsight
        } else {
            self.proactiveInsight = nil
            self.reactiveInsight = nil
        }
    }
}

public struct DescribeInsightOutputResponse: Equatable {
    /// <p>
    /// 			A <code>ProactiveInsight</code> object that represents the requested insight.
    /// 		</p>
    public let proactiveInsight: ProactiveInsight?
    /// <p>
    /// 			A <code>ReactiveInsight</code> object that represents the requested insight.
    /// 		</p>
    public let reactiveInsight: ReactiveInsight?

    public init (
        proactiveInsight: ProactiveInsight? = nil,
        reactiveInsight: ReactiveInsight? = nil
    )
    {
        self.proactiveInsight = proactiveInsight
        self.reactiveInsight = reactiveInsight
    }
}

struct DescribeInsightOutputResponseBody: Equatable {
    public let proactiveInsight: ProactiveInsight?
    public let reactiveInsight: ReactiveInsight?
}

extension DescribeInsightOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case proactiveInsight = "ProactiveInsight"
        case reactiveInsight = "ReactiveInsight"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let proactiveInsightDecoded = try containerValues.decodeIfPresent(ProactiveInsight.self, forKey: .proactiveInsight)
        proactiveInsight = proactiveInsightDecoded
        let reactiveInsightDecoded = try containerValues.decodeIfPresent(ReactiveInsight.self, forKey: .reactiveInsight)
        reactiveInsight = reactiveInsightDecoded
    }
}

extension DescribeResourceCollectionHealthInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeResourceCollectionHealthInput(nextToken: \(String(describing: nextToken)), resourceCollectionType: \(String(describing: resourceCollectionType)))"}
}

extension DescribeResourceCollectionHealthInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeResourceCollectionHealthInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeResourceCollectionHealthInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeResourceCollectionHealthInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeResourceCollectionHealthOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeResourceCollectionHealthInput>
    public typealias MOutput = OperationOutput<DescribeResourceCollectionHealthOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeResourceCollectionHealthOutputError>
}

public struct DescribeResourceCollectionHealthInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeResourceCollectionHealthInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeResourceCollectionHealthInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeResourceCollectionHealthOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "NextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeResourceCollectionHealthInput>
    public typealias MOutput = OperationOutput<DescribeResourceCollectionHealthOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeResourceCollectionHealthOutputError>
}

public struct DescribeResourceCollectionHealthInput: Equatable {
    /// <p>The pagination token to use to retrieve
    ///    the next page of results for this operation. If this value is null, it retrieves the first page.</p>
    public let nextToken: String?
    /// <p>
    ///    		An AWS resource collection type. This type specifies how analyzed AWS resources are defined. The one type of AWS resource collection supported is AWS CloudFormation stacks. DevOps Guru can be configured to analyze
    ///       	only the AWS resources that are defined in the stacks. You can specify up to 500 AWS CloudFormation stacks.
    ///    	</p>
    public let resourceCollectionType: ResourceCollectionType?

    public init (
        nextToken: String? = nil,
        resourceCollectionType: ResourceCollectionType? = nil
    )
    {
        self.nextToken = nextToken
        self.resourceCollectionType = resourceCollectionType
    }
}

struct DescribeResourceCollectionHealthInputBody: Equatable {
}

extension DescribeResourceCollectionHealthInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeResourceCollectionHealthOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeResourceCollectionHealthOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeResourceCollectionHealthOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeResourceCollectionHealthOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeResourceCollectionHealthOutputResponse(cloudFormation: \(String(describing: cloudFormation)), nextToken: \(String(describing: nextToken)), service: \(String(describing: service)))"}
}

extension DescribeResourceCollectionHealthOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeResourceCollectionHealthOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.cloudFormation = output.cloudFormation
            self.nextToken = output.nextToken
            self.service = output.service
        } else {
            self.cloudFormation = nil
            self.nextToken = nil
            self.service = nil
        }
    }
}

public struct DescribeResourceCollectionHealthOutputResponse: Equatable {
    /// <p>
    ///    		The returned <code>CloudFormationHealthOverview</code> object that contains an <code>InsightHealthOverview</code> object with
    ///    		the requested system health information.
    ///    	</p>
    public let cloudFormation: [CloudFormationHealth]?
    /// <p>The pagination token to use to retrieve
    ///    the next page of results for this operation. If there are no more pages, this value is null.</p>
    public let nextToken: String?
    /// <p>An array of <code>ServiceHealth</code> objects that describes the health of the AWS services
    /// 		associated with the resources in the collection.</p>
    public let service: [ServiceHealth]?

    public init (
        cloudFormation: [CloudFormationHealth]? = nil,
        nextToken: String? = nil,
        service: [ServiceHealth]? = nil
    )
    {
        self.cloudFormation = cloudFormation
        self.nextToken = nextToken
        self.service = service
    }
}

struct DescribeResourceCollectionHealthOutputResponseBody: Equatable {
    public let cloudFormation: [CloudFormationHealth]?
    public let service: [ServiceHealth]?
    public let nextToken: String?
}

extension DescribeResourceCollectionHealthOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case cloudFormation = "CloudFormation"
        case nextToken = "NextToken"
        case service = "Service"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudFormationContainer = try containerValues.decodeIfPresent([CloudFormationHealth?].self, forKey: .cloudFormation)
        var cloudFormationDecoded0:[CloudFormationHealth]? = nil
        if let cloudFormationContainer = cloudFormationContainer {
            cloudFormationDecoded0 = [CloudFormationHealth]()
            for structure0 in cloudFormationContainer {
                if let structure0 = structure0 {
                    cloudFormationDecoded0?.append(structure0)
                }
            }
        }
        cloudFormation = cloudFormationDecoded0
        let serviceContainer = try containerValues.decodeIfPresent([ServiceHealth?].self, forKey: .service)
        var serviceDecoded0:[ServiceHealth]? = nil
        if let serviceContainer = serviceContainer {
            serviceDecoded0 = [ServiceHealth]()
            for structure0 in serviceContainer {
                if let structure0 = structure0 {
                    serviceDecoded0?.append(structure0)
                }
            }
        }
        service = serviceDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeServiceIntegrationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeServiceIntegrationInput()"}
}

extension DescribeServiceIntegrationInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeServiceIntegrationInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeServiceIntegrationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeServiceIntegrationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeServiceIntegrationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeServiceIntegrationInput>
    public typealias MOutput = OperationOutput<DescribeServiceIntegrationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeServiceIntegrationOutputError>
}

public struct DescribeServiceIntegrationInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeServiceIntegrationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeServiceIntegrationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeServiceIntegrationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeServiceIntegrationInput>
    public typealias MOutput = OperationOutput<DescribeServiceIntegrationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeServiceIntegrationOutputError>
}

public struct DescribeServiceIntegrationInput: Equatable {

    public init() {}
}

struct DescribeServiceIntegrationInputBody: Equatable {
}

extension DescribeServiceIntegrationInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeServiceIntegrationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeServiceIntegrationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeServiceIntegrationOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeServiceIntegrationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeServiceIntegrationOutputResponse(serviceIntegration: \(String(describing: serviceIntegration)))"}
}

extension DescribeServiceIntegrationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeServiceIntegrationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.serviceIntegration = output.serviceIntegration
        } else {
            self.serviceIntegration = nil
        }
    }
}

public struct DescribeServiceIntegrationOutputResponse: Equatable {
    /// <p>
    /// 			Information about the integration of DevOps Guru with another AWS service, such as AWS Systems Manager.
    /// 		</p>
    public let serviceIntegration: ServiceIntegrationConfig?

    public init (
        serviceIntegration: ServiceIntegrationConfig? = nil
    )
    {
        self.serviceIntegration = serviceIntegration
    }
}

struct DescribeServiceIntegrationOutputResponseBody: Equatable {
    public let serviceIntegration: ServiceIntegrationConfig?
}

extension DescribeServiceIntegrationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case serviceIntegration = "ServiceIntegration"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceIntegrationDecoded = try containerValues.decodeIfPresent(ServiceIntegrationConfig.self, forKey: .serviceIntegration)
        serviceIntegration = serviceIntegrationDecoded
    }
}

extension EndTimeRange: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case fromTime = "FromTime"
        case toTime = "ToTime"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fromTime = fromTime {
            try encodeContainer.encode(fromTime.timeIntervalSince1970, forKey: .fromTime)
        }
        if let toTime = toTime {
            try encodeContainer.encode(toTime.timeIntervalSince1970, forKey: .toTime)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fromTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .fromTime)
        fromTime = fromTimeDecoded
        let toTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .toTime)
        toTime = toTimeDecoded
    }
}

extension EndTimeRange: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EndTimeRange(fromTime: \(String(describing: fromTime)), toTime: \(String(describing: toTime)))"}
}

/// <p>
///       	A range of time that specifies when anomalous behavior in an anomaly or insight ended.
///       </p>
public struct EndTimeRange: Equatable {
    /// <p>
    ///       	The earliest end time in the time range.
    ///       </p>
    public let fromTime: Date?
    /// <p>
    ///       	The latest end time in the time range.
    ///       </p>
    public let toTime: Date?

    public init (
        fromTime: Date? = nil,
        toTime: Date? = nil
    )
    {
        self.fromTime = fromTime
        self.toTime = toTime
    }
}

extension Event: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dataSource = "DataSource"
        case eventClass = "EventClass"
        case eventSource = "EventSource"
        case id = "Id"
        case name = "Name"
        case resourceCollection = "ResourceCollection"
        case resources = "Resources"
        case time = "Time"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSource = dataSource {
            try encodeContainer.encode(dataSource.rawValue, forKey: .dataSource)
        }
        if let eventClass = eventClass {
            try encodeContainer.encode(eventClass.rawValue, forKey: .eventClass)
        }
        if let eventSource = eventSource {
            try encodeContainer.encode(eventSource, forKey: .eventSource)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let resourceCollection = resourceCollection {
            try encodeContainer.encode(resourceCollection, forKey: .resourceCollection)
        }
        if let resources = resources {
            var resourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resources)
            for eventresources0 in resources {
                try resourcesContainer.encode(eventresources0)
            }
        }
        if let time = time {
            try encodeContainer.encode(time.timeIntervalSince1970, forKey: .time)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceCollectionDecoded = try containerValues.decodeIfPresent(ResourceCollection.self, forKey: .resourceCollection)
        resourceCollection = resourceCollectionDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let timeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .time)
        time = timeDecoded
        let eventSourceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventSource)
        eventSource = eventSourceDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let dataSourceDecoded = try containerValues.decodeIfPresent(EventDataSource.self, forKey: .dataSource)
        dataSource = dataSourceDecoded
        let eventClassDecoded = try containerValues.decodeIfPresent(EventClass.self, forKey: .eventClass)
        eventClass = eventClassDecoded
        let resourcesContainer = try containerValues.decodeIfPresent([EventResource?].self, forKey: .resources)
        var resourcesDecoded0:[EventResource]? = nil
        if let resourcesContainer = resourcesContainer {
            resourcesDecoded0 = [EventResource]()
            for structure0 in resourcesContainer {
                if let structure0 = structure0 {
                    resourcesDecoded0?.append(structure0)
                }
            }
        }
        resources = resourcesDecoded0
    }
}

extension Event: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Event(dataSource: \(String(describing: dataSource)), eventClass: \(String(describing: eventClass)), eventSource: \(String(describing: eventSource)), id: \(String(describing: id)), name: \(String(describing: name)), resourceCollection: \(String(describing: resourceCollection)), resources: \(String(describing: resources)), time: \(String(describing: time)))"}
}

/// <p>
/// 			An AWS resource event. AWS resource events and metrics are analyzed by DevOps Guru to find anomalous behavior and
/// 			provide recommendations to improve your operational solutions.
/// 		</p>
public struct Event: Equatable {
    /// <p>
    /// 			The source, <code>AWS_CLOUD_TRAIL</code> or <code>AWS_CODE_DEPLOY</code>, where DevOps Guru analysis found the event.
    /// 		</p>
    public let dataSource: EventDataSource?
    /// <p>
    /// 			The class of the event. The class specifies what the event is related to, such as an infrastructure change, a deployment, or a schema change.
    /// 		</p>
    public let eventClass: EventClass?
    /// <p>
    /// 			The AWS source that emitted the event.
    /// 		</p>
    public let eventSource: String?
    /// <p>
    /// 			The ID of the event.
    /// 		</p>
    public let id: String?
    /// <p>
    /// 			The name of the event.
    /// 		</p>
    public let name: String?
    /// <p>
    /// 			A collection of AWS resources supported by DevOps Guru. The one type of AWS resource collection supported is AWS CloudFormation stacks. DevOps Guru can be configured to analyze
    ///       	only the AWS resources that are defined in the stacks. You can specify up to 500 AWS CloudFormation stacks.
    /// 		</p>
    public let resourceCollection: ResourceCollection?
    /// <p>
    /// 			An <code>EventResource</code> object that contains information about the resource that emitted the event.
    /// 		</p>
    public let resources: [EventResource]?
    /// <p> A <code>Timestamp</code> that specifies the time the event occurred. </p>
    public let time: Date?

    public init (
        dataSource: EventDataSource? = nil,
        eventClass: EventClass? = nil,
        eventSource: String? = nil,
        id: String? = nil,
        name: String? = nil,
        resourceCollection: ResourceCollection? = nil,
        resources: [EventResource]? = nil,
        time: Date? = nil
    )
    {
        self.dataSource = dataSource
        self.eventClass = eventClass
        self.eventSource = eventSource
        self.id = id
        self.name = name
        self.resourceCollection = resourceCollection
        self.resources = resources
        self.time = time
    }
}

public enum EventClass {
    case configChange
    case deployment
    case infrastructure
    case schemaChange
    case securityChange
    case sdkUnknown(String)
}

extension EventClass : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [EventClass] {
        return [
            .configChange,
            .deployment,
            .infrastructure,
            .schemaChange,
            .securityChange,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .configChange: return "CONFIG_CHANGE"
        case .deployment: return "DEPLOYMENT"
        case .infrastructure: return "INFRASTRUCTURE"
        case .schemaChange: return "SCHEMA_CHANGE"
        case .securityChange: return "SECURITY_CHANGE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = EventClass(rawValue: rawValue) ?? EventClass.sdkUnknown(rawValue)
    }
}

public enum EventDataSource {
    case awsCloudTrail
    case awsCodeDeploy
    case sdkUnknown(String)
}

extension EventDataSource : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [EventDataSource] {
        return [
            .awsCloudTrail,
            .awsCodeDeploy,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .awsCloudTrail: return "AWS_CLOUD_TRAIL"
        case .awsCodeDeploy: return "AWS_CODE_DEPLOY"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = EventDataSource(rawValue: rawValue) ?? EventDataSource.sdkUnknown(rawValue)
    }
}

extension EventResource: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case name = "Name"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension EventResource: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EventResource(arn: \(String(describing: arn)), name: \(String(describing: name)), type: \(String(describing: type)))"}
}

/// <p>
/// 			The AWS resource that emitted an event. AWS resource events and metrics are analyzed by DevOps Guru to find anomalous behavior and
/// 			provide recommendations to improve your operational solutions.
/// 		</p>
public struct EventResource: Equatable {
    /// <p>
    /// 			The Amazon Resource Name (ARN) of the resource that emitted an event.
    /// 		</p>
    public let arn: String?
    /// <p>
    /// 			The name of the resource that emitted an event.
    /// 		</p>
    public let name: String?
    /// <p>
    /// 			The type of resource that emitted an event.
    /// 		</p>
    public let type: String?

    public init (
        arn: String? = nil,
        name: String? = nil,
        type: String? = nil
    )
    {
        self.arn = arn
        self.name = name
        self.type = type
    }
}

extension EventTimeRange: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case fromTime = "FromTime"
        case toTime = "ToTime"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fromTime = fromTime {
            try encodeContainer.encode(fromTime.timeIntervalSince1970, forKey: .fromTime)
        }
        if let toTime = toTime {
            try encodeContainer.encode(toTime.timeIntervalSince1970, forKey: .toTime)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fromTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .fromTime)
        fromTime = fromTimeDecoded
        let toTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .toTime)
        toTime = toTimeDecoded
    }
}

extension EventTimeRange: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EventTimeRange(fromTime: \(String(describing: fromTime)), toTime: \(String(describing: toTime)))"}
}

/// <p>
/// 			The time range during which an AWS event occurred. AWS resource events and metrics are analyzed by DevOps Guru to find anomalous behavior and
/// 			provide recommendations to improve your operational solutions.
/// 		</p>
public struct EventTimeRange: Equatable {
    /// <p>
    /// 			The time when the event started.
    /// 		</p>
    public let fromTime: Date?
    /// <p>
    /// 			The time when the event ended.
    /// 		</p>
    public let toTime: Date?

    public init (
        fromTime: Date? = nil,
        toTime: Date? = nil
    )
    {
        self.fromTime = fromTime
        self.toTime = toTime
    }
}

extension GetCostEstimationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetCostEstimationInput(nextToken: \(String(describing: nextToken)))"}
}

extension GetCostEstimationInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetCostEstimationInputHeadersMiddleware: Middleware {
    public let id: String = "GetCostEstimationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetCostEstimationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetCostEstimationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetCostEstimationInput>
    public typealias MOutput = OperationOutput<GetCostEstimationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetCostEstimationOutputError>
}

public struct GetCostEstimationInputQueryItemMiddleware: Middleware {
    public let id: String = "GetCostEstimationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetCostEstimationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetCostEstimationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "NextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetCostEstimationInput>
    public typealias MOutput = OperationOutput<GetCostEstimationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetCostEstimationOutputError>
}

public struct GetCostEstimationInput: Equatable {
    /// <p>The pagination token to use to retrieve
    ///    the next page of results for this operation. If this value is null, it retrieves the first page.</p>
    public let nextToken: String?

    public init (
        nextToken: String? = nil
    )
    {
        self.nextToken = nextToken
    }
}

struct GetCostEstimationInputBody: Equatable {
}

extension GetCostEstimationInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetCostEstimationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetCostEstimationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetCostEstimationOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetCostEstimationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetCostEstimationOutputResponse(costs: \(String(describing: costs)), nextToken: \(String(describing: nextToken)), resourceCollection: \(String(describing: resourceCollection)), status: \(String(describing: status)), timeRange: \(String(describing: timeRange)), totalCost: \(String(describing: totalCost)))"}
}

extension GetCostEstimationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetCostEstimationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.costs = output.costs
            self.nextToken = output.nextToken
            self.resourceCollection = output.resourceCollection
            self.status = output.status
            self.timeRange = output.timeRange
            self.totalCost = output.totalCost
        } else {
            self.costs = nil
            self.nextToken = nil
            self.resourceCollection = nil
            self.status = nil
            self.timeRange = nil
            self.totalCost = 0.0
        }
    }
}

public struct GetCostEstimationOutputResponse: Equatable {
    /// <p>An array of <code>ResourceCost</code> objects that each contains details
    /// 			about the monthly cost estimate to analyze one of your AWS resources.</p>
    public let costs: [ServiceResourceCost]?
    /// <p>The pagination token to use to retrieve
    ///    the next page of results for this operation. If there are no more pages, this value is null.</p>
    public let nextToken: String?
    /// <p>The collection of the AWS resources used to create your monthly DevOps Guru cost estimate.</p>
    public let resourceCollection: CostEstimationResourceCollectionFilter?
    /// <p>The status of creating this cost estimate. If it's still in progress, the status
    /// 			<code>ONGOING</code> is returned. If it is finished, the status <code>COMPLETED</code> is returned.</p>
    public let status: CostEstimationStatus?
    /// <p>The start and end time of the cost estimation.</p>
    public let timeRange: CostEstimationTimeRange?
    /// <p>The estimated monthly cost to analyze the AWS resources.
    /// 			This value is the sum of the estimated costs to analyze each resource in the <code>Costs</code>
    /// 			object in this response.</p>
    public let totalCost: Double

    public init (
        costs: [ServiceResourceCost]? = nil,
        nextToken: String? = nil,
        resourceCollection: CostEstimationResourceCollectionFilter? = nil,
        status: CostEstimationStatus? = nil,
        timeRange: CostEstimationTimeRange? = nil,
        totalCost: Double = 0.0
    )
    {
        self.costs = costs
        self.nextToken = nextToken
        self.resourceCollection = resourceCollection
        self.status = status
        self.timeRange = timeRange
        self.totalCost = totalCost
    }
}

struct GetCostEstimationOutputResponseBody: Equatable {
    public let resourceCollection: CostEstimationResourceCollectionFilter?
    public let status: CostEstimationStatus?
    public let costs: [ServiceResourceCost]?
    public let timeRange: CostEstimationTimeRange?
    public let totalCost: Double
    public let nextToken: String?
}

extension GetCostEstimationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case costs = "Costs"
        case nextToken = "NextToken"
        case resourceCollection = "ResourceCollection"
        case status = "Status"
        case timeRange = "TimeRange"
        case totalCost = "TotalCost"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceCollectionDecoded = try containerValues.decodeIfPresent(CostEstimationResourceCollectionFilter.self, forKey: .resourceCollection)
        resourceCollection = resourceCollectionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(CostEstimationStatus.self, forKey: .status)
        status = statusDecoded
        let costsContainer = try containerValues.decodeIfPresent([ServiceResourceCost?].self, forKey: .costs)
        var costsDecoded0:[ServiceResourceCost]? = nil
        if let costsContainer = costsContainer {
            costsDecoded0 = [ServiceResourceCost]()
            for structure0 in costsContainer {
                if let structure0 = structure0 {
                    costsDecoded0?.append(structure0)
                }
            }
        }
        costs = costsDecoded0
        let timeRangeDecoded = try containerValues.decodeIfPresent(CostEstimationTimeRange.self, forKey: .timeRange)
        timeRange = timeRangeDecoded
        let totalCostDecoded = try containerValues.decode(Double.self, forKey: .totalCost)
        totalCost = totalCostDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetResourceCollectionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetResourceCollectionInput(nextToken: \(String(describing: nextToken)), resourceCollectionType: \(String(describing: resourceCollectionType)))"}
}

extension GetResourceCollectionInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetResourceCollectionInputHeadersMiddleware: Middleware {
    public let id: String = "GetResourceCollectionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetResourceCollectionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetResourceCollectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetResourceCollectionInput>
    public typealias MOutput = OperationOutput<GetResourceCollectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetResourceCollectionOutputError>
}

public struct GetResourceCollectionInputQueryItemMiddleware: Middleware {
    public let id: String = "GetResourceCollectionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetResourceCollectionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetResourceCollectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "NextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetResourceCollectionInput>
    public typealias MOutput = OperationOutput<GetResourceCollectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetResourceCollectionOutputError>
}

public struct GetResourceCollectionInput: Equatable {
    /// <p>The pagination token to use to retrieve
    ///    the next page of results for this operation. If this value is null, it retrieves the first page.</p>
    public let nextToken: String?
    /// <p>
    ///    		The type of AWS resource collections to return. The one valid value is <code>CLOUD_FORMATION</code> for
    ///    		AWS CloudFormation stacks.
    ///    	</p>
    public let resourceCollectionType: ResourceCollectionType?

    public init (
        nextToken: String? = nil,
        resourceCollectionType: ResourceCollectionType? = nil
    )
    {
        self.nextToken = nextToken
        self.resourceCollectionType = resourceCollectionType
    }
}

struct GetResourceCollectionInputBody: Equatable {
}

extension GetResourceCollectionInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetResourceCollectionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetResourceCollectionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetResourceCollectionOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetResourceCollectionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetResourceCollectionOutputResponse(nextToken: \(String(describing: nextToken)), resourceCollection: \(String(describing: resourceCollection)))"}
}

extension GetResourceCollectionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetResourceCollectionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.resourceCollection = output.resourceCollection
        } else {
            self.nextToken = nil
            self.resourceCollection = nil
        }
    }
}

public struct GetResourceCollectionOutputResponse: Equatable {
    /// <p>The pagination token to use to retrieve
    ///    the next page of results for this operation. If there are no more pages, this value is null.</p>
    public let nextToken: String?
    /// <p>
    ///    		The requested list of AWS resource collections. The one type of AWS resource collection supported is AWS CloudFormation stacks. DevOps Guru can be configured to analyze
    ///       	only the AWS resources that are defined in the stacks. You can specify up to 500 AWS CloudFormation stacks.
    ///    	</p>
    public let resourceCollection: ResourceCollectionFilter?

    public init (
        nextToken: String? = nil,
        resourceCollection: ResourceCollectionFilter? = nil
    )
    {
        self.nextToken = nextToken
        self.resourceCollection = resourceCollection
    }
}

struct GetResourceCollectionOutputResponseBody: Equatable {
    public let resourceCollection: ResourceCollectionFilter?
    public let nextToken: String?
}

extension GetResourceCollectionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case resourceCollection = "ResourceCollection"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceCollectionDecoded = try containerValues.decodeIfPresent(ResourceCollectionFilter.self, forKey: .resourceCollection)
        resourceCollection = resourceCollectionDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension InsightFeedback: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case feedback = "Feedback"
        case id = "Id"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let feedback = feedback {
            try encodeContainer.encode(feedback.rawValue, forKey: .feedback)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let feedbackDecoded = try containerValues.decodeIfPresent(InsightFeedbackOption.self, forKey: .feedback)
        feedback = feedbackDecoded
    }
}

extension InsightFeedback: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InsightFeedback(feedback: \(String(describing: feedback)), id: \(String(describing: id)))"}
}

/// <p>
///       	Information about insight feedback received from a customer.
///       </p>
public struct InsightFeedback: Equatable {
    /// <p>
    ///       	The feedback provided by the customer.
    ///       </p>
    public let feedback: InsightFeedbackOption?
    /// <p>
    ///       	The insight feedback ID.
    ///       </p>
    public let id: String?

    public init (
        feedback: InsightFeedbackOption? = nil,
        id: String? = nil
    )
    {
        self.feedback = feedback
        self.id = id
    }
}

public enum InsightFeedbackOption {
    case alertTooSensitive
    case dataIncorrect
    case dataNoisyAnomaly
    case recommendationUseful
    case validCollection
    case sdkUnknown(String)
}

extension InsightFeedbackOption : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [InsightFeedbackOption] {
        return [
            .alertTooSensitive,
            .dataIncorrect,
            .dataNoisyAnomaly,
            .recommendationUseful,
            .validCollection,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .alertTooSensitive: return "ALERT_TOO_SENSITIVE"
        case .dataIncorrect: return "DATA_INCORRECT"
        case .dataNoisyAnomaly: return "DATA_NOISY_ANOMALY"
        case .recommendationUseful: return "RECOMMENDATION_USEFUL"
        case .validCollection: return "VALID_COLLECTION"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = InsightFeedbackOption(rawValue: rawValue) ?? InsightFeedbackOption.sdkUnknown(rawValue)
    }
}

extension InsightHealth: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case meanTimeToRecoverInMilliseconds = "MeanTimeToRecoverInMilliseconds"
        case openProactiveInsights = "OpenProactiveInsights"
        case openReactiveInsights = "OpenReactiveInsights"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let meanTimeToRecoverInMilliseconds = meanTimeToRecoverInMilliseconds {
            try encodeContainer.encode(meanTimeToRecoverInMilliseconds, forKey: .meanTimeToRecoverInMilliseconds)
        }
        if openProactiveInsights != 0 {
            try encodeContainer.encode(openProactiveInsights, forKey: .openProactiveInsights)
        }
        if openReactiveInsights != 0 {
            try encodeContainer.encode(openReactiveInsights, forKey: .openReactiveInsights)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let openProactiveInsightsDecoded = try containerValues.decode(Int.self, forKey: .openProactiveInsights)
        openProactiveInsights = openProactiveInsightsDecoded
        let openReactiveInsightsDecoded = try containerValues.decode(Int.self, forKey: .openReactiveInsights)
        openReactiveInsights = openReactiveInsightsDecoded
        let meanTimeToRecoverInMillisecondsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .meanTimeToRecoverInMilliseconds)
        meanTimeToRecoverInMilliseconds = meanTimeToRecoverInMillisecondsDecoded
    }
}

extension InsightHealth: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InsightHealth(meanTimeToRecoverInMilliseconds: \(String(describing: meanTimeToRecoverInMilliseconds)), openProactiveInsights: \(String(describing: openProactiveInsights)), openReactiveInsights: \(String(describing: openReactiveInsights)))"}
}

/// <p>
///       	Information about the number of open reactive and proactive insights that can be
///       	used to gauge the health of your system.
///       </p>
public struct InsightHealth: Equatable {
    /// <p>
    ///       	The Meant Time to Recover (MTTR) for the insight.	
    ///       </p>
    public let meanTimeToRecoverInMilliseconds: Int?
    /// <p>
    ///       	The number of open proactive insights.
    ///       </p>
    public let openProactiveInsights: Int
    /// <p>
    ///       	The number of open reactive insights.
    ///       </p>
    public let openReactiveInsights: Int

    public init (
        meanTimeToRecoverInMilliseconds: Int? = nil,
        openProactiveInsights: Int = 0,
        openReactiveInsights: Int = 0
    )
    {
        self.meanTimeToRecoverInMilliseconds = meanTimeToRecoverInMilliseconds
        self.openProactiveInsights = openProactiveInsights
        self.openReactiveInsights = openReactiveInsights
    }
}

public enum InsightSeverity {
    case high
    case low
    case medium
    case sdkUnknown(String)
}

extension InsightSeverity : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [InsightSeverity] {
        return [
            .high,
            .low,
            .medium,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .high: return "HIGH"
        case .low: return "LOW"
        case .medium: return "MEDIUM"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = InsightSeverity(rawValue: rawValue) ?? InsightSeverity.sdkUnknown(rawValue)
    }
}

public enum InsightStatus {
    case closed
    case ongoing
    case sdkUnknown(String)
}

extension InsightStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [InsightStatus] {
        return [
            .closed,
            .ongoing,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .closed: return "CLOSED"
        case .ongoing: return "ONGOING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = InsightStatus(rawValue: rawValue) ?? InsightStatus.sdkUnknown(rawValue)
    }
}

extension InsightTimeRange: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case endTime = "EndTime"
        case startTime = "StartTime"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .endTime)
        endTime = endTimeDecoded
    }
}

extension InsightTimeRange: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InsightTimeRange(endTime: \(String(describing: endTime)), startTime: \(String(describing: startTime)))"}
}

/// <p> A time ranged that specifies when the observed behavior in an insight started and
/// 			ended. </p>
public struct InsightTimeRange: Equatable {
    /// <p>
    /// 			The time when the behavior described in an insight ended.
    /// 		</p>
    public let endTime: Date?
    /// <p>
    /// 			The time when the behavior described in an insight started.
    /// 		</p>
    public let startTime: Date?

    public init (
        endTime: Date? = nil,
        startTime: Date? = nil
    )
    {
        self.endTime = endTime
        self.startTime = startTime
    }
}

public enum InsightType {
    case proactive
    case reactive
    case sdkUnknown(String)
}

extension InsightType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [InsightType] {
        return [
            .proactive,
            .reactive,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .proactive: return "PROACTIVE"
        case .reactive: return "REACTIVE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = InsightType(rawValue: rawValue) ?? InsightType.sdkUnknown(rawValue)
    }
}

extension InternalServerException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalServerException(message: \(String(describing: message)), retryAfterSeconds: \(String(describing: retryAfterSeconds)))"}
}

extension InternalServerException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.retryAfterSeconds = Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.retryAfterSeconds = 0
        }
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An internal failure in an Amazon service occurred.</p>
public struct InternalServerException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?
    /// <p>
    /// 			The number of seconds after which the action that caused the internal server
    /// 			exception can be retried.
    /// 		</p>
    public var retryAfterSeconds: Int

    public init (
        message: String? = nil,
        retryAfterSeconds: Int = 0
    )
    {
        self.message = message
        self.retryAfterSeconds = retryAfterSeconds
    }
}

struct InternalServerExceptionBody: Equatable {
    public let message: String?
}

extension InternalServerExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ListAnomaliesForInsightInputBodyMiddleware: Middleware {
    public let id: String = "ListAnomaliesForInsightInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAnomaliesForInsightInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAnomaliesForInsightOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAnomaliesForInsightInput>
    public typealias MOutput = OperationOutput<ListAnomaliesForInsightOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAnomaliesForInsightOutputError>
}

extension ListAnomaliesForInsightInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAnomaliesForInsightInput(insightId: \(String(describing: insightId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), startTimeRange: \(String(describing: startTimeRange)))"}
}

extension ListAnomaliesForInsightInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case startTimeRange = "StartTimeRange"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let startTimeRange = startTimeRange {
            try encodeContainer.encode(startTimeRange, forKey: .startTimeRange)
        }
    }
}

public struct ListAnomaliesForInsightInputHeadersMiddleware: Middleware {
    public let id: String = "ListAnomaliesForInsightInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAnomaliesForInsightInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAnomaliesForInsightOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAnomaliesForInsightInput>
    public typealias MOutput = OperationOutput<ListAnomaliesForInsightOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAnomaliesForInsightOutputError>
}

public struct ListAnomaliesForInsightInputQueryItemMiddleware: Middleware {
    public let id: String = "ListAnomaliesForInsightInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAnomaliesForInsightInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAnomaliesForInsightOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAnomaliesForInsightInput>
    public typealias MOutput = OperationOutput<ListAnomaliesForInsightOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAnomaliesForInsightOutputError>
}

public struct ListAnomaliesForInsightInput: Equatable {
    /// <p>
    /// 			The ID of the insight. The returned anomalies belong to this insight.
    /// 		</p>
    public let insightId: String?
    /// <p>The maximum number of results to return with a single call.
    /// 	To retrieve the remaining results, make another call with the returned <code>nextToken</code> value.</p>
    public let maxResults: Int?
    /// <p>The pagination token to use to retrieve
    ///    the next page of results for this operation. If this value is null, it retrieves the first page.</p>
    public let nextToken: String?
    /// <p>
    ///    		A time range used to specify when the requested anomalies started. All returned anomalies started
    ///    		during this time range.
    ///    	</p>
    public let startTimeRange: StartTimeRange?

    public init (
        insightId: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        startTimeRange: StartTimeRange? = nil
    )
    {
        self.insightId = insightId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.startTimeRange = startTimeRange
    }
}

struct ListAnomaliesForInsightInputBody: Equatable {
    public let startTimeRange: StartTimeRange?
    public let maxResults: Int?
    public let nextToken: String?
}

extension ListAnomaliesForInsightInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case startTimeRange = "StartTimeRange"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startTimeRangeDecoded = try containerValues.decodeIfPresent(StartTimeRange.self, forKey: .startTimeRange)
        startTimeRange = startTimeRangeDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAnomaliesForInsightOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAnomaliesForInsightOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAnomaliesForInsightOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAnomaliesForInsightOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAnomaliesForInsightOutputResponse(nextToken: \(String(describing: nextToken)), proactiveAnomalies: \(String(describing: proactiveAnomalies)), reactiveAnomalies: \(String(describing: reactiveAnomalies)))"}
}

extension ListAnomaliesForInsightOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListAnomaliesForInsightOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.proactiveAnomalies = output.proactiveAnomalies
            self.reactiveAnomalies = output.reactiveAnomalies
        } else {
            self.nextToken = nil
            self.proactiveAnomalies = nil
            self.reactiveAnomalies = nil
        }
    }
}

public struct ListAnomaliesForInsightOutputResponse: Equatable {
    /// <p>The pagination token to use to retrieve
    ///    the next page of results for this operation. If there are no more pages, this value is null.</p>
    public let nextToken: String?
    /// <p>
    /// 			An array of <code>ProactiveAnomalySummary</code> objects that represent the requested anomalies
    /// 		</p>
    public let proactiveAnomalies: [ProactiveAnomalySummary]?
    /// <p>
    /// 			An array of <code>ReactiveAnomalySummary</code> objects that represent the requested anomalies
    /// 		</p>
    public let reactiveAnomalies: [ReactiveAnomalySummary]?

    public init (
        nextToken: String? = nil,
        proactiveAnomalies: [ProactiveAnomalySummary]? = nil,
        reactiveAnomalies: [ReactiveAnomalySummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.proactiveAnomalies = proactiveAnomalies
        self.reactiveAnomalies = reactiveAnomalies
    }
}

struct ListAnomaliesForInsightOutputResponseBody: Equatable {
    public let proactiveAnomalies: [ProactiveAnomalySummary]?
    public let reactiveAnomalies: [ReactiveAnomalySummary]?
    public let nextToken: String?
}

extension ListAnomaliesForInsightOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case proactiveAnomalies = "ProactiveAnomalies"
        case reactiveAnomalies = "ReactiveAnomalies"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let proactiveAnomaliesContainer = try containerValues.decodeIfPresent([ProactiveAnomalySummary?].self, forKey: .proactiveAnomalies)
        var proactiveAnomaliesDecoded0:[ProactiveAnomalySummary]? = nil
        if let proactiveAnomaliesContainer = proactiveAnomaliesContainer {
            proactiveAnomaliesDecoded0 = [ProactiveAnomalySummary]()
            for structure0 in proactiveAnomaliesContainer {
                if let structure0 = structure0 {
                    proactiveAnomaliesDecoded0?.append(structure0)
                }
            }
        }
        proactiveAnomalies = proactiveAnomaliesDecoded0
        let reactiveAnomaliesContainer = try containerValues.decodeIfPresent([ReactiveAnomalySummary?].self, forKey: .reactiveAnomalies)
        var reactiveAnomaliesDecoded0:[ReactiveAnomalySummary]? = nil
        if let reactiveAnomaliesContainer = reactiveAnomaliesContainer {
            reactiveAnomaliesDecoded0 = [ReactiveAnomalySummary]()
            for structure0 in reactiveAnomaliesContainer {
                if let structure0 = structure0 {
                    reactiveAnomaliesDecoded0?.append(structure0)
                }
            }
        }
        reactiveAnomalies = reactiveAnomaliesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListEventsFilters: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dataSource = "DataSource"
        case eventClass = "EventClass"
        case eventSource = "EventSource"
        case eventTimeRange = "EventTimeRange"
        case insightId = "InsightId"
        case resourceCollection = "ResourceCollection"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSource = dataSource {
            try encodeContainer.encode(dataSource.rawValue, forKey: .dataSource)
        }
        if let eventClass = eventClass {
            try encodeContainer.encode(eventClass.rawValue, forKey: .eventClass)
        }
        if let eventSource = eventSource {
            try encodeContainer.encode(eventSource, forKey: .eventSource)
        }
        if let eventTimeRange = eventTimeRange {
            try encodeContainer.encode(eventTimeRange, forKey: .eventTimeRange)
        }
        if let insightId = insightId {
            try encodeContainer.encode(insightId, forKey: .insightId)
        }
        if let resourceCollection = resourceCollection {
            try encodeContainer.encode(resourceCollection, forKey: .resourceCollection)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let insightIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .insightId)
        insightId = insightIdDecoded
        let eventTimeRangeDecoded = try containerValues.decodeIfPresent(EventTimeRange.self, forKey: .eventTimeRange)
        eventTimeRange = eventTimeRangeDecoded
        let eventClassDecoded = try containerValues.decodeIfPresent(EventClass.self, forKey: .eventClass)
        eventClass = eventClassDecoded
        let eventSourceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventSource)
        eventSource = eventSourceDecoded
        let dataSourceDecoded = try containerValues.decodeIfPresent(EventDataSource.self, forKey: .dataSource)
        dataSource = dataSourceDecoded
        let resourceCollectionDecoded = try containerValues.decodeIfPresent(ResourceCollection.self, forKey: .resourceCollection)
        resourceCollection = resourceCollectionDecoded
    }
}

extension ListEventsFilters: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListEventsFilters(dataSource: \(String(describing: dataSource)), eventClass: \(String(describing: eventClass)), eventSource: \(String(describing: eventSource)), eventTimeRange: \(String(describing: eventTimeRange)), insightId: \(String(describing: insightId)), resourceCollection: \(String(describing: resourceCollection)))"}
}

/// <p>
/// 			Filters you can use to specify which events are returned when <code>ListEvents</code> is called.
/// 		</p>
public struct ListEventsFilters: Equatable {
    /// <p>
    /// 			The source, <code>AWS_CLOUD_TRAIL</code> or <code>AWS_CODE_DEPLOY</code>, of the events you want returned.
    /// 		</p>
    public let dataSource: EventDataSource?
    /// <p>
    /// 			The class of the events you want to filter for, such as an infrastructure change, a deployment, or a schema change.      	
    /// 		</p>
    public let eventClass: EventClass?
    /// <p>
    /// 			The AWS source that emitted the events you want to filter for.
    /// 		</p>
    public let eventSource: String?
    /// <p> A time range during which you want the filtered events to have occurred. </p>
    public let eventTimeRange: EventTimeRange?
    /// <p>
    /// 			An ID of an insight that is related to the events you want to filter for.
    /// 		</p>
    public let insightId: String?
    /// <p>
    /// 			A collection of AWS resources supported by DevOps Guru. The one type of AWS resource collection supported is AWS CloudFormation stacks. DevOps Guru can be configured to analyze
    ///       	only the AWS resources that are defined in the stacks. You can specify up to 500 AWS CloudFormation stacks.
    /// 		</p>
    public let resourceCollection: ResourceCollection?

    public init (
        dataSource: EventDataSource? = nil,
        eventClass: EventClass? = nil,
        eventSource: String? = nil,
        eventTimeRange: EventTimeRange? = nil,
        insightId: String? = nil,
        resourceCollection: ResourceCollection? = nil
    )
    {
        self.dataSource = dataSource
        self.eventClass = eventClass
        self.eventSource = eventSource
        self.eventTimeRange = eventTimeRange
        self.insightId = insightId
        self.resourceCollection = resourceCollection
    }
}

public struct ListEventsInputBodyMiddleware: Middleware {
    public let id: String = "ListEventsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListEventsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListEventsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListEventsInput>
    public typealias MOutput = OperationOutput<ListEventsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListEventsOutputError>
}

extension ListEventsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListEventsInput(filters: \(String(describing: filters)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListEventsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            try encodeContainer.encode(filters, forKey: .filters)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListEventsInputHeadersMiddleware: Middleware {
    public let id: String = "ListEventsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListEventsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListEventsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListEventsInput>
    public typealias MOutput = OperationOutput<ListEventsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListEventsOutputError>
}

public struct ListEventsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListEventsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListEventsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListEventsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListEventsInput>
    public typealias MOutput = OperationOutput<ListEventsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListEventsOutputError>
}

public struct ListEventsInput: Equatable {
    /// <p>
    ///    		A <code>ListEventsFilters</code> object used to specify which events to return.
    ///    	</p>
    public let filters: ListEventsFilters?
    /// <p>The maximum number of results to return with a single call.
    /// 	To retrieve the remaining results, make another call with the returned <code>nextToken</code> value.</p>
    public let maxResults: Int?
    /// <p>The pagination token to use to retrieve
    ///    the next page of results for this operation. If this value is null, it retrieves the first page.</p>
    public let nextToken: String?

    public init (
        filters: ListEventsFilters? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListEventsInputBody: Equatable {
    public let filters: ListEventsFilters?
    public let maxResults: Int?
    public let nextToken: String?
}

extension ListEventsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersDecoded = try containerValues.decodeIfPresent(ListEventsFilters.self, forKey: .filters)
        filters = filtersDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListEventsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListEventsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListEventsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListEventsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListEventsOutputResponse(events: \(String(describing: events)), nextToken: \(String(describing: nextToken)))"}
}

extension ListEventsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListEventsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.events = output.events
            self.nextToken = output.nextToken
        } else {
            self.events = nil
            self.nextToken = nil
        }
    }
}

public struct ListEventsOutputResponse: Equatable {
    /// <p>
    ///    		A list of the requested events.
    ///    	</p>
    public let events: [Event]?
    /// <p>The pagination token to use to retrieve
    ///    the next page of results for this operation. If there are no more pages, this value is null.</p>
    public let nextToken: String?

    public init (
        events: [Event]? = nil,
        nextToken: String? = nil
    )
    {
        self.events = events
        self.nextToken = nextToken
    }
}

struct ListEventsOutputResponseBody: Equatable {
    public let events: [Event]?
    public let nextToken: String?
}

extension ListEventsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case events = "Events"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventsContainer = try containerValues.decodeIfPresent([Event?].self, forKey: .events)
        var eventsDecoded0:[Event]? = nil
        if let eventsContainer = eventsContainer {
            eventsDecoded0 = [Event]()
            for structure0 in eventsContainer {
                if let structure0 = structure0 {
                    eventsDecoded0?.append(structure0)
                }
            }
        }
        events = eventsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListInsightsAnyStatusFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case startTimeRange = "StartTimeRange"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let startTimeRange = startTimeRange {
            try encodeContainer.encode(startTimeRange, forKey: .startTimeRange)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(InsightType.self, forKey: .type)
        type = typeDecoded
        let startTimeRangeDecoded = try containerValues.decodeIfPresent(StartTimeRange.self, forKey: .startTimeRange)
        startTimeRange = startTimeRangeDecoded
    }
}

extension ListInsightsAnyStatusFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListInsightsAnyStatusFilter(startTimeRange: \(String(describing: startTimeRange)), type: \(String(describing: type)))"}
}

/// <p>
///    		Used to filter for insights that have any status.
///    	</p>
public struct ListInsightsAnyStatusFilter: Equatable {
    /// <p>
    ///    		A time range used to specify when the behavior of the filtered insights started.
    ///    	</p>
    public let startTimeRange: StartTimeRange?
    /// <p>
    ///    		Use to filter for either <code>REACTIVE</code> or <code>PROACTIVE</code> insights.
    ///    	</p>
    public let type: InsightType?

    public init (
        startTimeRange: StartTimeRange? = nil,
        type: InsightType? = nil
    )
    {
        self.startTimeRange = startTimeRange
        self.type = type
    }
}

extension ListInsightsClosedStatusFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case endTimeRange = "EndTimeRange"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTimeRange = endTimeRange {
            try encodeContainer.encode(endTimeRange, forKey: .endTimeRange)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(InsightType.self, forKey: .type)
        type = typeDecoded
        let endTimeRangeDecoded = try containerValues.decodeIfPresent(EndTimeRange.self, forKey: .endTimeRange)
        endTimeRange = endTimeRangeDecoded
    }
}

extension ListInsightsClosedStatusFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListInsightsClosedStatusFilter(endTimeRange: \(String(describing: endTimeRange)), type: \(String(describing: type)))"}
}

/// <p>
///    		Used to filter for insights that have the status <code>CLOSED</code>.
///    	</p>
public struct ListInsightsClosedStatusFilter: Equatable {
    /// <p>
    ///    		A time range used to specify when the behavior of the filtered insights ended.
    ///    	</p>
    public let endTimeRange: EndTimeRange?
    /// <p>
    ///       	Use to filter for either <code>REACTIVE</code> or <code>PROACTIVE</code> insights.
    ///       </p>
    public let type: InsightType?

    public init (
        endTimeRange: EndTimeRange? = nil,
        type: InsightType? = nil
    )
    {
        self.endTimeRange = endTimeRange
        self.type = type
    }
}

public struct ListInsightsInputBodyMiddleware: Middleware {
    public let id: String = "ListInsightsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListInsightsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListInsightsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListInsightsInput>
    public typealias MOutput = OperationOutput<ListInsightsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListInsightsOutputError>
}

extension ListInsightsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListInsightsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), statusFilter: \(String(describing: statusFilter)))"}
}

extension ListInsightsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case statusFilter = "StatusFilter"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let statusFilter = statusFilter {
            try encodeContainer.encode(statusFilter, forKey: .statusFilter)
        }
    }
}

public struct ListInsightsInputHeadersMiddleware: Middleware {
    public let id: String = "ListInsightsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListInsightsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListInsightsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListInsightsInput>
    public typealias MOutput = OperationOutput<ListInsightsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListInsightsOutputError>
}

public struct ListInsightsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListInsightsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListInsightsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListInsightsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListInsightsInput>
    public typealias MOutput = OperationOutput<ListInsightsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListInsightsOutputError>
}

public struct ListInsightsInput: Equatable {
    /// <p>The maximum number of results to return with a single call.
    /// 	To retrieve the remaining results, make another call with the returned <code>nextToken</code> value.</p>
    public let maxResults: Int?
    /// <p>The pagination token to use to retrieve
    ///    the next page of results for this operation. If this value is null, it retrieves the first page.</p>
    public let nextToken: String?
    /// <p>
    ///       	A filter used to filter the returned insights by their status. You can specify one status filter.
    ///       </p>
    public let statusFilter: ListInsightsStatusFilter?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        statusFilter: ListInsightsStatusFilter? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.statusFilter = statusFilter
    }
}

struct ListInsightsInputBody: Equatable {
    public let statusFilter: ListInsightsStatusFilter?
    public let maxResults: Int?
    public let nextToken: String?
}

extension ListInsightsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case statusFilter = "StatusFilter"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusFilterDecoded = try containerValues.decodeIfPresent(ListInsightsStatusFilter.self, forKey: .statusFilter)
        statusFilter = statusFilterDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListInsightsOngoingStatusFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(InsightType.self, forKey: .type)
        type = typeDecoded
    }
}

extension ListInsightsOngoingStatusFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListInsightsOngoingStatusFilter(type: \(String(describing: type)))"}
}

/// <p>
///       	Used to filter for insights that have the status <code>ONGOING</code>.
///       </p>
public struct ListInsightsOngoingStatusFilter: Equatable {
    /// <p>
    ///    		Use to filter for either <code>REACTIVE</code> or <code>PROACTIVE</code> insights.
    ///    	</p>
    public let type: InsightType?

    public init (
        type: InsightType? = nil
    )
    {
        self.type = type
    }
}

extension ListInsightsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListInsightsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListInsightsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListInsightsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListInsightsOutputResponse(nextToken: \(String(describing: nextToken)), proactiveInsights: \(String(describing: proactiveInsights)), reactiveInsights: \(String(describing: reactiveInsights)))"}
}

extension ListInsightsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListInsightsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.proactiveInsights = output.proactiveInsights
            self.reactiveInsights = output.reactiveInsights
        } else {
            self.nextToken = nil
            self.proactiveInsights = nil
            self.reactiveInsights = nil
        }
    }
}

public struct ListInsightsOutputResponse: Equatable {
    /// <p>The pagination token to use to retrieve
    ///    the next page of results for this operation. If there are no more pages, this value is null.</p>
    public let nextToken: String?
    /// <p>
    /// 			The returned list of proactive insights.
    /// 		</p>
    public let proactiveInsights: [ProactiveInsightSummary]?
    /// <p>
    /// 			The returned list of reactive insights.	
    /// 		</p>
    public let reactiveInsights: [ReactiveInsightSummary]?

    public init (
        nextToken: String? = nil,
        proactiveInsights: [ProactiveInsightSummary]? = nil,
        reactiveInsights: [ReactiveInsightSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.proactiveInsights = proactiveInsights
        self.reactiveInsights = reactiveInsights
    }
}

struct ListInsightsOutputResponseBody: Equatable {
    public let proactiveInsights: [ProactiveInsightSummary]?
    public let reactiveInsights: [ReactiveInsightSummary]?
    public let nextToken: String?
}

extension ListInsightsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case proactiveInsights = "ProactiveInsights"
        case reactiveInsights = "ReactiveInsights"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let proactiveInsightsContainer = try containerValues.decodeIfPresent([ProactiveInsightSummary?].self, forKey: .proactiveInsights)
        var proactiveInsightsDecoded0:[ProactiveInsightSummary]? = nil
        if let proactiveInsightsContainer = proactiveInsightsContainer {
            proactiveInsightsDecoded0 = [ProactiveInsightSummary]()
            for structure0 in proactiveInsightsContainer {
                if let structure0 = structure0 {
                    proactiveInsightsDecoded0?.append(structure0)
                }
            }
        }
        proactiveInsights = proactiveInsightsDecoded0
        let reactiveInsightsContainer = try containerValues.decodeIfPresent([ReactiveInsightSummary?].self, forKey: .reactiveInsights)
        var reactiveInsightsDecoded0:[ReactiveInsightSummary]? = nil
        if let reactiveInsightsContainer = reactiveInsightsContainer {
            reactiveInsightsDecoded0 = [ReactiveInsightSummary]()
            for structure0 in reactiveInsightsContainer {
                if let structure0 = structure0 {
                    reactiveInsightsDecoded0?.append(structure0)
                }
            }
        }
        reactiveInsights = reactiveInsightsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListInsightsStatusFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case any = "Any"
        case closed = "Closed"
        case ongoing = "Ongoing"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let any = any {
            try encodeContainer.encode(any, forKey: .any)
        }
        if let closed = closed {
            try encodeContainer.encode(closed, forKey: .closed)
        }
        if let ongoing = ongoing {
            try encodeContainer.encode(ongoing, forKey: .ongoing)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ongoingDecoded = try containerValues.decodeIfPresent(ListInsightsOngoingStatusFilter.self, forKey: .ongoing)
        ongoing = ongoingDecoded
        let closedDecoded = try containerValues.decodeIfPresent(ListInsightsClosedStatusFilter.self, forKey: .closed)
        closed = closedDecoded
        let anyDecoded = try containerValues.decodeIfPresent(ListInsightsAnyStatusFilter.self, forKey: .any)
        any = anyDecoded
    }
}

extension ListInsightsStatusFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListInsightsStatusFilter(any: \(String(describing: any)), closed: \(String(describing: closed)), ongoing: \(String(describing: ongoing)))"}
}

/// <p>
///       	A filter used by <code>ListInsights</code> to specify which insights to return.
///       </p>
public struct ListInsightsStatusFilter: Equatable {
    /// <p>
    ///    		A <code>ListInsightsAnyStatusFilter</code> that specifies insights of any status
    ///    		that are either <code>REACTIVE</code> or <code>PROACTIVE</code>.
    ///    	</p>
    public let any: ListInsightsAnyStatusFilter?
    /// <p>
    ///    		A <code>ListInsightsClosedStatusFilter</code> that specifies closed insights that are
    ///    		either <code>REACTIVE</code> or <code>PROACTIVE</code>.
    ///    	</p>
    public let closed: ListInsightsClosedStatusFilter?
    /// <p>
    ///       	A <code>ListInsightsAnyStatusFilter</code> that specifies ongoing insights
    ///       	that are either <code>REACTIVE</code> or <code>PROACTIVE</code>.
    ///       </p>
    public let ongoing: ListInsightsOngoingStatusFilter?

    public init (
        any: ListInsightsAnyStatusFilter? = nil,
        closed: ListInsightsClosedStatusFilter? = nil,
        ongoing: ListInsightsOngoingStatusFilter? = nil
    )
    {
        self.any = any
        self.closed = closed
        self.ongoing = ongoing
    }
}

public struct ListNotificationChannelsInputBodyMiddleware: Middleware {
    public let id: String = "ListNotificationChannelsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListNotificationChannelsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListNotificationChannelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListNotificationChannelsInput>
    public typealias MOutput = OperationOutput<ListNotificationChannelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListNotificationChannelsOutputError>
}

extension ListNotificationChannelsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListNotificationChannelsInput(nextToken: \(String(describing: nextToken)))"}
}

extension ListNotificationChannelsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListNotificationChannelsInputHeadersMiddleware: Middleware {
    public let id: String = "ListNotificationChannelsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListNotificationChannelsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListNotificationChannelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListNotificationChannelsInput>
    public typealias MOutput = OperationOutput<ListNotificationChannelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListNotificationChannelsOutputError>
}

public struct ListNotificationChannelsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListNotificationChannelsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListNotificationChannelsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListNotificationChannelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListNotificationChannelsInput>
    public typealias MOutput = OperationOutput<ListNotificationChannelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListNotificationChannelsOutputError>
}

public struct ListNotificationChannelsInput: Equatable {
    /// <p>The pagination token to use to retrieve
    ///    the next page of results for this operation. If this value is null, it retrieves the first page.</p>
    public let nextToken: String?

    public init (
        nextToken: String? = nil
    )
    {
        self.nextToken = nextToken
    }
}

struct ListNotificationChannelsInputBody: Equatable {
    public let nextToken: String?
}

extension ListNotificationChannelsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListNotificationChannelsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListNotificationChannelsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListNotificationChannelsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListNotificationChannelsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListNotificationChannelsOutputResponse(channels: \(String(describing: channels)), nextToken: \(String(describing: nextToken)))"}
}

extension ListNotificationChannelsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListNotificationChannelsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.channels = output.channels
            self.nextToken = output.nextToken
        } else {
            self.channels = nil
            self.nextToken = nil
        }
    }
}

public struct ListNotificationChannelsOutputResponse: Equatable {
    /// <p>
    ///    		An array that contains the requested notification channels.
    ///    	</p>
    public let channels: [NotificationChannel]?
    /// <p>The pagination token to use to retrieve
    ///    the next page of results for this operation. If there are no more pages, this value is null.</p>
    public let nextToken: String?

    public init (
        channels: [NotificationChannel]? = nil,
        nextToken: String? = nil
    )
    {
        self.channels = channels
        self.nextToken = nextToken
    }
}

struct ListNotificationChannelsOutputResponseBody: Equatable {
    public let channels: [NotificationChannel]?
    public let nextToken: String?
}

extension ListNotificationChannelsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case channels = "Channels"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelsContainer = try containerValues.decodeIfPresent([NotificationChannel?].self, forKey: .channels)
        var channelsDecoded0:[NotificationChannel]? = nil
        if let channelsContainer = channelsContainer {
            channelsDecoded0 = [NotificationChannel]()
            for structure0 in channelsContainer {
                if let structure0 = structure0 {
                    channelsDecoded0?.append(structure0)
                }
            }
        }
        channels = channelsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListRecommendationsInputBodyMiddleware: Middleware {
    public let id: String = "ListRecommendationsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListRecommendationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListRecommendationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListRecommendationsInput>
    public typealias MOutput = OperationOutput<ListRecommendationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListRecommendationsOutputError>
}

extension ListRecommendationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListRecommendationsInput(insightId: \(String(describing: insightId)), locale: \(String(describing: locale)), nextToken: \(String(describing: nextToken)))"}
}

extension ListRecommendationsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case insightId = "InsightId"
        case locale = "Locale"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let insightId = insightId {
            try encodeContainer.encode(insightId, forKey: .insightId)
        }
        if let locale = locale {
            try encodeContainer.encode(locale.rawValue, forKey: .locale)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListRecommendationsInputHeadersMiddleware: Middleware {
    public let id: String = "ListRecommendationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListRecommendationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListRecommendationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListRecommendationsInput>
    public typealias MOutput = OperationOutput<ListRecommendationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListRecommendationsOutputError>
}

public struct ListRecommendationsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListRecommendationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListRecommendationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListRecommendationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListRecommendationsInput>
    public typealias MOutput = OperationOutput<ListRecommendationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListRecommendationsOutputError>
}

public struct ListRecommendationsInput: Equatable {
    /// <p>
    /// 			The ID of the requested insight.
    /// 		</p>
    public let insightId: String?
    /// <p>A locale that specifies the language to use for recommendations.</p>
    public let locale: Locale?
    /// <p>The pagination token to use to retrieve
    ///    the next page of results for this operation. If this value is null, it retrieves the first page.</p>
    public let nextToken: String?

    public init (
        insightId: String? = nil,
        locale: Locale? = nil,
        nextToken: String? = nil
    )
    {
        self.insightId = insightId
        self.locale = locale
        self.nextToken = nextToken
    }
}

struct ListRecommendationsInputBody: Equatable {
    public let insightId: String?
    public let nextToken: String?
    public let locale: Locale?
}

extension ListRecommendationsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case insightId = "InsightId"
        case locale = "Locale"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let insightIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .insightId)
        insightId = insightIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let localeDecoded = try containerValues.decodeIfPresent(Locale.self, forKey: .locale)
        locale = localeDecoded
    }
}

extension ListRecommendationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListRecommendationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListRecommendationsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListRecommendationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListRecommendationsOutputResponse(nextToken: \(String(describing: nextToken)), recommendations: \(String(describing: recommendations)))"}
}

extension ListRecommendationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListRecommendationsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.recommendations = output.recommendations
        } else {
            self.nextToken = nil
            self.recommendations = nil
        }
    }
}

public struct ListRecommendationsOutputResponse: Equatable {
    /// <p>The pagination token to use to retrieve
    ///    the next page of results for this operation. If there are no more pages, this value is null.</p>
    public let nextToken: String?
    /// <p>
    ///    		An array of the requested recommendations.
    ///    	</p>
    public let recommendations: [Recommendation]?

    public init (
        nextToken: String? = nil,
        recommendations: [Recommendation]? = nil
    )
    {
        self.nextToken = nextToken
        self.recommendations = recommendations
    }
}

struct ListRecommendationsOutputResponseBody: Equatable {
    public let recommendations: [Recommendation]?
    public let nextToken: String?
}

extension ListRecommendationsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case recommendations = "Recommendations"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recommendationsContainer = try containerValues.decodeIfPresent([Recommendation?].self, forKey: .recommendations)
        var recommendationsDecoded0:[Recommendation]? = nil
        if let recommendationsContainer = recommendationsContainer {
            recommendationsDecoded0 = [Recommendation]()
            for structure0 in recommendationsContainer {
                if let structure0 = structure0 {
                    recommendationsDecoded0?.append(structure0)
                }
            }
        }
        recommendations = recommendationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public enum Locale {
    case deDe
    case enGb
    case enUs
    case esEs
    case frFr
    case itIt
    case jaJp
    case koKr
    case ptBr
    case zhCn
    case zhTw
    case sdkUnknown(String)
}

extension Locale : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Locale] {
        return [
            .deDe,
            .enGb,
            .enUs,
            .esEs,
            .frFr,
            .itIt,
            .jaJp,
            .koKr,
            .ptBr,
            .zhCn,
            .zhTw,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .deDe: return "DE_DE"
        case .enGb: return "EN_GB"
        case .enUs: return "EN_US"
        case .esEs: return "ES_ES"
        case .frFr: return "FR_FR"
        case .itIt: return "IT_IT"
        case .jaJp: return "JA_JP"
        case .koKr: return "KO_KR"
        case .ptBr: return "PT_BR"
        case .zhCn: return "ZH_CN"
        case .zhTw: return "ZH_TW"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Locale(rawValue: rawValue) ?? Locale.sdkUnknown(rawValue)
    }
}

extension NotificationChannel: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case config = "Config"
        case id = "Id"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let config = config {
            try encodeContainer.encode(config, forKey: .config)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let configDecoded = try containerValues.decodeIfPresent(NotificationChannelConfig.self, forKey: .config)
        config = configDecoded
    }
}

extension NotificationChannel: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NotificationChannel(config: \(String(describing: config)), id: \(String(describing: id)))"}
}

/// <p>
/// 			Information about a notification channel. A notification channel is used to notify you when DevOps Guru creates an insight.
/// 			The one
///       	supported notification channel is Amazon Simple Notification Service (Amazon SNS).
/// 		</p>
/// 		
/// 		       <p>If you use an Amazon SNS topic in another account, you must attach a policy to it that grants DevOps Guru permission
/// 				to it notifications. DevOps Guru adds the required policy on your behalf to send notifications using Amazon SNS in your account.
/// 				For more information, see <a href="https://docs.aws.amazon.com/devops-guru/latest/userguide/sns-required-permissions.html">Permissions
/// 				for cross account Amazon SNS topics</a>.</p>
/// 				     <p>If you use an Amazon SNS topic that is encrypted by an AWS Key Management Service customer-managed key (CMK), then you must add permissions
/// 				to the CMK. For more information, see <a href="https://docs.aws.amazon.com/devops-guru/latest/userguide/sns-kms-permissions.html">Permissions for
/// 				AWS KMS–encrypted Amazon SNS topics</a>.</p>
public struct NotificationChannel: Equatable {
    /// <p>
    /// 			A <code>NotificationChannelConfig</code> object that contains information about configured notification channels.
    /// 		</p>
    public let config: NotificationChannelConfig?
    /// <p>
    /// 			The ID of a notification channel.
    /// 		</p>
    public let id: String?

    public init (
        config: NotificationChannelConfig? = nil,
        id: String? = nil
    )
    {
        self.config = config
        self.id = id
    }
}

extension NotificationChannelConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case sns = "Sns"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sns = sns {
            try encodeContainer.encode(sns, forKey: .sns)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snsDecoded = try containerValues.decodeIfPresent(SnsChannelConfig.self, forKey: .sns)
        sns = snsDecoded
    }
}

extension NotificationChannelConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NotificationChannelConfig(sns: \(String(describing: sns)))"}
}

/// <p> Information about notification channels you have configured with DevOps Guru.
/// 			The one
///       	supported notification channel is Amazon Simple Notification Service (Amazon SNS).</p>
public struct NotificationChannelConfig: Equatable {
    /// <p>
    /// 			Information about a notification channel configured in DevOps Guru to send notifications when insights are created.
    /// 		</p>
    /// 		
    /// 		       <p>If you use an Amazon SNS topic in another account, you must attach a policy to it that grants DevOps Guru permission
    /// 				to it notifications. DevOps Guru adds the required policy on your behalf to send notifications using Amazon SNS in your account.
    /// 				For more information, see <a href="https://docs.aws.amazon.com/devops-guru/latest/userguide/sns-required-permissions.html">Permissions
    /// 				for cross account Amazon SNS topics</a>.</p>
    /// 				     <p>If you use an Amazon SNS topic that is encrypted by an AWS Key Management Service customer-managed key (CMK), then you must add permissions
    /// 				to the CMK. For more information, see <a href="https://docs.aws.amazon.com/devops-guru/latest/userguide/sns-kms-permissions.html">Permissions for
    /// 				AWS KMS–encrypted Amazon SNS topics</a>.</p>
    public let sns: SnsChannelConfig?

    public init (
        sns: SnsChannelConfig? = nil
    )
    {
        self.sns = sns
    }
}

extension OpsCenterIntegration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case optInStatus = "OptInStatus"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let optInStatus = optInStatus {
            try encodeContainer.encode(optInStatus.rawValue, forKey: .optInStatus)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let optInStatusDecoded = try containerValues.decodeIfPresent(OptInStatus.self, forKey: .optInStatus)
        optInStatus = optInStatusDecoded
    }
}

extension OpsCenterIntegration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OpsCenterIntegration(optInStatus: \(String(describing: optInStatus)))"}
}

/// <p>
/// 			Information about whether DevOps Guru is configured to create an OpsItem in AWS Systems Manager OpsCenter for each created insight.
/// 		</p>
public struct OpsCenterIntegration: Equatable {
    /// <p>
    /// 			Specifies if DevOps Guru is enabled to create an AWS Systems Manager OpsItem for each created insight.
    /// 		</p>
    public let optInStatus: OptInStatus?

    public init (
        optInStatus: OptInStatus? = nil
    )
    {
        self.optInStatus = optInStatus
    }
}

extension OpsCenterIntegrationConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case optInStatus = "OptInStatus"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let optInStatus = optInStatus {
            try encodeContainer.encode(optInStatus.rawValue, forKey: .optInStatus)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let optInStatusDecoded = try containerValues.decodeIfPresent(OptInStatus.self, forKey: .optInStatus)
        optInStatus = optInStatusDecoded
    }
}

extension OpsCenterIntegrationConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OpsCenterIntegrationConfig(optInStatus: \(String(describing: optInStatus)))"}
}

/// <p>
/// 			Information about whether DevOps Guru is configured to create an OpsItem in AWS Systems Manager OpsCenter for each created insight.
/// 		</p>
public struct OpsCenterIntegrationConfig: Equatable {
    /// <p>
    /// 			Specifies if DevOps Guru is enabled to create an AWS Systems Manager OpsItem for each created insight.
    /// 		</p>
    public let optInStatus: OptInStatus?

    public init (
        optInStatus: OptInStatus? = nil
    )
    {
        self.optInStatus = optInStatus
    }
}

/// <p>
/// 			Specifies if DevOps Guru is enabled to create an AWS Systems Manager OpsItem for each created insight.
/// 		</p>
public enum OptInStatus {
    case disabled
    case enabled
    case sdkUnknown(String)
}

extension OptInStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [OptInStatus] {
        return [
            .disabled,
            .enabled,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .disabled: return "DISABLED"
        case .enabled: return "ENABLED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = OptInStatus(rawValue: rawValue) ?? OptInStatus.sdkUnknown(rawValue)
    }
}

extension PredictionTimeRange: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case endTime = "EndTime"
        case startTime = "StartTime"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .endTime)
        endTime = endTimeDecoded
    }
}

extension PredictionTimeRange: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PredictionTimeRange(endTime: \(String(describing: endTime)), startTime: \(String(describing: startTime)))"}
}

/// <p>
/// 			The time range during which anomalous behavior in a proactive anomaly or an insight is expected to occur.
/// 		</p>
public struct PredictionTimeRange: Equatable {
    /// <p>
    /// 			The time when the behavior in a proactive insight is expected to end.
    /// 		</p>
    public let endTime: Date?
    /// <p>
    /// 			The time range during which a metric limit is expected to be exceeded. This applies to proactive insights only.
    /// 		</p>
    public let startTime: Date?

    public init (
        endTime: Date? = nil,
        startTime: Date? = nil
    )
    {
        self.endTime = endTime
        self.startTime = startTime
    }
}

extension ProactiveAnomaly: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case anomalyTimeRange = "AnomalyTimeRange"
        case associatedInsightId = "AssociatedInsightId"
        case id = "Id"
        case limit = "Limit"
        case predictionTimeRange = "PredictionTimeRange"
        case resourceCollection = "ResourceCollection"
        case severity = "Severity"
        case sourceDetails = "SourceDetails"
        case status = "Status"
        case updateTime = "UpdateTime"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let anomalyTimeRange = anomalyTimeRange {
            try encodeContainer.encode(anomalyTimeRange, forKey: .anomalyTimeRange)
        }
        if let associatedInsightId = associatedInsightId {
            try encodeContainer.encode(associatedInsightId, forKey: .associatedInsightId)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let limit = limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let predictionTimeRange = predictionTimeRange {
            try encodeContainer.encode(predictionTimeRange, forKey: .predictionTimeRange)
        }
        if let resourceCollection = resourceCollection {
            try encodeContainer.encode(resourceCollection, forKey: .resourceCollection)
        }
        if let severity = severity {
            try encodeContainer.encode(severity.rawValue, forKey: .severity)
        }
        if let sourceDetails = sourceDetails {
            try encodeContainer.encode(sourceDetails, forKey: .sourceDetails)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let updateTime = updateTime {
            try encodeContainer.encode(updateTime.timeIntervalSince1970, forKey: .updateTime)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let severityDecoded = try containerValues.decodeIfPresent(AnomalySeverity.self, forKey: .severity)
        severity = severityDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AnomalyStatus.self, forKey: .status)
        status = statusDecoded
        let updateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .updateTime)
        updateTime = updateTimeDecoded
        let anomalyTimeRangeDecoded = try containerValues.decodeIfPresent(AnomalyTimeRange.self, forKey: .anomalyTimeRange)
        anomalyTimeRange = anomalyTimeRangeDecoded
        let predictionTimeRangeDecoded = try containerValues.decodeIfPresent(PredictionTimeRange.self, forKey: .predictionTimeRange)
        predictionTimeRange = predictionTimeRangeDecoded
        let sourceDetailsDecoded = try containerValues.decodeIfPresent(AnomalySourceDetails.self, forKey: .sourceDetails)
        sourceDetails = sourceDetailsDecoded
        let associatedInsightIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .associatedInsightId)
        associatedInsightId = associatedInsightIdDecoded
        let resourceCollectionDecoded = try containerValues.decodeIfPresent(ResourceCollection.self, forKey: .resourceCollection)
        resourceCollection = resourceCollectionDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .limit)
        limit = limitDecoded
    }
}

extension ProactiveAnomaly: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ProactiveAnomaly(anomalyTimeRange: \(String(describing: anomalyTimeRange)), associatedInsightId: \(String(describing: associatedInsightId)), id: \(String(describing: id)), limit: \(String(describing: limit)), predictionTimeRange: \(String(describing: predictionTimeRange)), resourceCollection: \(String(describing: resourceCollection)), severity: \(String(describing: severity)), sourceDetails: \(String(describing: sourceDetails)), status: \(String(describing: status)), updateTime: \(String(describing: updateTime)))"}
}

/// <p>Information about an anomaly. This object is returned by <code>ListAnomalies</code>.</p>
public struct ProactiveAnomaly: Equatable {
    /// <p>
    /// 			A time range that specifies when the observed unusual behavior in an anomaly started and ended.
    /// 		</p>
    public let anomalyTimeRange: AnomalyTimeRange?
    /// <p>
    /// 			The ID of the insight that contains this anomaly. An insight is composed of related anomalies.
    /// 		</p>
    public let associatedInsightId: String?
    /// <p>
    /// 			The ID of a proactive anomaly.
    /// 		</p>
    public let id: String?
    /// <p>
    /// 			A threshold that was exceeded by behavior in analyzed resources. Exceeding this
    /// 			threshold is related to the anomalous behavior that generated this anomaly.
    /// 		</p>
    public let limit: Double?
    /// <p>
    /// 			The time range during which anomalous behavior in a proactive anomaly or an insight is expected to occur.
    /// 		</p>
    public let predictionTimeRange: PredictionTimeRange?
    /// <p>
    /// 			A collection of AWS resources supported by DevOps Guru. The one type of AWS resource collection supported is AWS CloudFormation stacks. DevOps Guru can be configured to analyze
    ///       	only the AWS resources that are defined in the stacks. You can specify up to 500 AWS CloudFormation stacks.
    /// 		</p>
    public let resourceCollection: ResourceCollection?
    /// <p>
    /// 			The severity of a proactive anomaly.
    /// 		</p>
    public let severity: AnomalySeverity?
    /// <p>
    /// 			Details about the source of the analyzed operational data that triggered the anomaly. The one supported source is Amazon CloudWatch metrics.
    /// 		</p>
    public let sourceDetails: AnomalySourceDetails?
    /// <p>
    /// 			The status of a proactive anomaly.
    /// 		</p>
    public let status: AnomalyStatus?
    /// <p>
    /// 			The time of the anomaly's most recent update.
    /// 		</p>
    public let updateTime: Date?

    public init (
        anomalyTimeRange: AnomalyTimeRange? = nil,
        associatedInsightId: String? = nil,
        id: String? = nil,
        limit: Double? = nil,
        predictionTimeRange: PredictionTimeRange? = nil,
        resourceCollection: ResourceCollection? = nil,
        severity: AnomalySeverity? = nil,
        sourceDetails: AnomalySourceDetails? = nil,
        status: AnomalyStatus? = nil,
        updateTime: Date? = nil
    )
    {
        self.anomalyTimeRange = anomalyTimeRange
        self.associatedInsightId = associatedInsightId
        self.id = id
        self.limit = limit
        self.predictionTimeRange = predictionTimeRange
        self.resourceCollection = resourceCollection
        self.severity = severity
        self.sourceDetails = sourceDetails
        self.status = status
        self.updateTime = updateTime
    }
}

extension ProactiveAnomalySummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case anomalyTimeRange = "AnomalyTimeRange"
        case associatedInsightId = "AssociatedInsightId"
        case id = "Id"
        case limit = "Limit"
        case predictionTimeRange = "PredictionTimeRange"
        case resourceCollection = "ResourceCollection"
        case severity = "Severity"
        case sourceDetails = "SourceDetails"
        case status = "Status"
        case updateTime = "UpdateTime"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let anomalyTimeRange = anomalyTimeRange {
            try encodeContainer.encode(anomalyTimeRange, forKey: .anomalyTimeRange)
        }
        if let associatedInsightId = associatedInsightId {
            try encodeContainer.encode(associatedInsightId, forKey: .associatedInsightId)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let limit = limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let predictionTimeRange = predictionTimeRange {
            try encodeContainer.encode(predictionTimeRange, forKey: .predictionTimeRange)
        }
        if let resourceCollection = resourceCollection {
            try encodeContainer.encode(resourceCollection, forKey: .resourceCollection)
        }
        if let severity = severity {
            try encodeContainer.encode(severity.rawValue, forKey: .severity)
        }
        if let sourceDetails = sourceDetails {
            try encodeContainer.encode(sourceDetails, forKey: .sourceDetails)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let updateTime = updateTime {
            try encodeContainer.encode(updateTime.timeIntervalSince1970, forKey: .updateTime)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let severityDecoded = try containerValues.decodeIfPresent(AnomalySeverity.self, forKey: .severity)
        severity = severityDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AnomalyStatus.self, forKey: .status)
        status = statusDecoded
        let updateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .updateTime)
        updateTime = updateTimeDecoded
        let anomalyTimeRangeDecoded = try containerValues.decodeIfPresent(AnomalyTimeRange.self, forKey: .anomalyTimeRange)
        anomalyTimeRange = anomalyTimeRangeDecoded
        let predictionTimeRangeDecoded = try containerValues.decodeIfPresent(PredictionTimeRange.self, forKey: .predictionTimeRange)
        predictionTimeRange = predictionTimeRangeDecoded
        let sourceDetailsDecoded = try containerValues.decodeIfPresent(AnomalySourceDetails.self, forKey: .sourceDetails)
        sourceDetails = sourceDetailsDecoded
        let associatedInsightIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .associatedInsightId)
        associatedInsightId = associatedInsightIdDecoded
        let resourceCollectionDecoded = try containerValues.decodeIfPresent(ResourceCollection.self, forKey: .resourceCollection)
        resourceCollection = resourceCollectionDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .limit)
        limit = limitDecoded
    }
}

extension ProactiveAnomalySummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ProactiveAnomalySummary(anomalyTimeRange: \(String(describing: anomalyTimeRange)), associatedInsightId: \(String(describing: associatedInsightId)), id: \(String(describing: id)), limit: \(String(describing: limit)), predictionTimeRange: \(String(describing: predictionTimeRange)), resourceCollection: \(String(describing: resourceCollection)), severity: \(String(describing: severity)), sourceDetails: \(String(describing: sourceDetails)), status: \(String(describing: status)), updateTime: \(String(describing: updateTime)))"}
}

/// <p>Details about a proactive anomaly. This object is returned by
/// 			<code>DescribeAnomaly.</code>
///          </p>
public struct ProactiveAnomalySummary: Equatable {
    /// <p>
    /// 			A time range that specifies when the observed unusual behavior in an anomaly started and ended.
    /// 		</p>
    public let anomalyTimeRange: AnomalyTimeRange?
    /// <p>
    /// 			The ID of the insight that contains this anomaly. An insight is composed of related anomalies.
    /// 		</p>
    public let associatedInsightId: String?
    /// <p>The ID of the anomaly.</p>
    public let id: String?
    /// <p>
    /// 			A threshold that was exceeded by behavior in analyzed resources. Exceeding this
    /// 			threshold is related to the anomalous behavior that generated this anomaly.
    /// 		</p>
    public let limit: Double?
    /// <p>
    /// 			The time range during which anomalous behavior in a proactive anomaly or an insight is expected to occur.
    /// 		</p>
    public let predictionTimeRange: PredictionTimeRange?
    /// <p>
    /// 			A collection of AWS resources supported by DevOps Guru. The one type of AWS resource collection supported is AWS CloudFormation stacks. DevOps Guru can be configured to analyze
    ///       	only the AWS resources that are defined in the stacks. You can specify up to 500 AWS CloudFormation stacks.
    /// 		</p>
    public let resourceCollection: ResourceCollection?
    /// <p>The severity of the anomaly.</p>
    public let severity: AnomalySeverity?
    /// <p>
    /// 			Details about the source of the analyzed operational data that triggered the anomaly. The one supported source is Amazon CloudWatch metrics.
    /// 		</p>
    public let sourceDetails: AnomalySourceDetails?
    /// <p>The status of the anomaly.</p>
    public let status: AnomalyStatus?
    /// <p>
    /// 			The time of the anomaly's most recent update.
    /// 		</p>
    public let updateTime: Date?

    public init (
        anomalyTimeRange: AnomalyTimeRange? = nil,
        associatedInsightId: String? = nil,
        id: String? = nil,
        limit: Double? = nil,
        predictionTimeRange: PredictionTimeRange? = nil,
        resourceCollection: ResourceCollection? = nil,
        severity: AnomalySeverity? = nil,
        sourceDetails: AnomalySourceDetails? = nil,
        status: AnomalyStatus? = nil,
        updateTime: Date? = nil
    )
    {
        self.anomalyTimeRange = anomalyTimeRange
        self.associatedInsightId = associatedInsightId
        self.id = id
        self.limit = limit
        self.predictionTimeRange = predictionTimeRange
        self.resourceCollection = resourceCollection
        self.severity = severity
        self.sourceDetails = sourceDetails
        self.status = status
        self.updateTime = updateTime
    }
}

extension ProactiveInsight: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case id = "Id"
        case insightTimeRange = "InsightTimeRange"
        case name = "Name"
        case predictionTimeRange = "PredictionTimeRange"
        case resourceCollection = "ResourceCollection"
        case severity = "Severity"
        case ssmOpsItemId = "SsmOpsItemId"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let insightTimeRange = insightTimeRange {
            try encodeContainer.encode(insightTimeRange, forKey: .insightTimeRange)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let predictionTimeRange = predictionTimeRange {
            try encodeContainer.encode(predictionTimeRange, forKey: .predictionTimeRange)
        }
        if let resourceCollection = resourceCollection {
            try encodeContainer.encode(resourceCollection, forKey: .resourceCollection)
        }
        if let severity = severity {
            try encodeContainer.encode(severity.rawValue, forKey: .severity)
        }
        if let ssmOpsItemId = ssmOpsItemId {
            try encodeContainer.encode(ssmOpsItemId, forKey: .ssmOpsItemId)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let severityDecoded = try containerValues.decodeIfPresent(InsightSeverity.self, forKey: .severity)
        severity = severityDecoded
        let statusDecoded = try containerValues.decodeIfPresent(InsightStatus.self, forKey: .status)
        status = statusDecoded
        let insightTimeRangeDecoded = try containerValues.decodeIfPresent(InsightTimeRange.self, forKey: .insightTimeRange)
        insightTimeRange = insightTimeRangeDecoded
        let predictionTimeRangeDecoded = try containerValues.decodeIfPresent(PredictionTimeRange.self, forKey: .predictionTimeRange)
        predictionTimeRange = predictionTimeRangeDecoded
        let resourceCollectionDecoded = try containerValues.decodeIfPresent(ResourceCollection.self, forKey: .resourceCollection)
        resourceCollection = resourceCollectionDecoded
        let ssmOpsItemIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ssmOpsItemId)
        ssmOpsItemId = ssmOpsItemIdDecoded
    }
}

extension ProactiveInsight: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ProactiveInsight(id: \(String(describing: id)), insightTimeRange: \(String(describing: insightTimeRange)), name: \(String(describing: name)), predictionTimeRange: \(String(describing: predictionTimeRange)), resourceCollection: \(String(describing: resourceCollection)), severity: \(String(describing: severity)), ssmOpsItemId: \(String(describing: ssmOpsItemId)), status: \(String(describing: status)))"}
}

/// <p>Details about a proactive insight. This object is returned by <code>ListInsights</code>.</p>
public struct ProactiveInsight: Equatable {
    /// <p>The ID of the proactive insight. </p>
    public let id: String?
    /// <p> A time ranged that specifies when the observed behavior in an insight started and
    /// 			ended. </p>
    public let insightTimeRange: InsightTimeRange?
    /// <p>The name of the proactive insight. </p>
    public let name: String?
    /// <p>
    /// 			The time range during which anomalous behavior in a proactive anomaly or an insight is expected to occur.
    /// 		</p>
    public let predictionTimeRange: PredictionTimeRange?
    /// <p>
    /// 			A collection of AWS resources supported by DevOps Guru. The one type of AWS resource collection supported is AWS CloudFormation stacks. DevOps Guru can be configured to analyze
    ///       	only the AWS resources that are defined in the stacks. You can specify up to 500 AWS CloudFormation stacks.
    /// 		</p>
    public let resourceCollection: ResourceCollection?
    /// <p>The severity of the proactive insight. </p>
    public let severity: InsightSeverity?
    /// <p>
    /// 			The ID of the AWS System Manager OpsItem created for this insight. You must enable
    /// 			the creation of OpstItems insights before they are created for each insight.
    /// 		</p>
    public let ssmOpsItemId: String?
    /// <p>The status of the proactive insight. </p>
    public let status: InsightStatus?

    public init (
        id: String? = nil,
        insightTimeRange: InsightTimeRange? = nil,
        name: String? = nil,
        predictionTimeRange: PredictionTimeRange? = nil,
        resourceCollection: ResourceCollection? = nil,
        severity: InsightSeverity? = nil,
        ssmOpsItemId: String? = nil,
        status: InsightStatus? = nil
    )
    {
        self.id = id
        self.insightTimeRange = insightTimeRange
        self.name = name
        self.predictionTimeRange = predictionTimeRange
        self.resourceCollection = resourceCollection
        self.severity = severity
        self.ssmOpsItemId = ssmOpsItemId
        self.status = status
    }
}

extension ProactiveInsightSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case id = "Id"
        case insightTimeRange = "InsightTimeRange"
        case name = "Name"
        case predictionTimeRange = "PredictionTimeRange"
        case resourceCollection = "ResourceCollection"
        case serviceCollection = "ServiceCollection"
        case severity = "Severity"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let insightTimeRange = insightTimeRange {
            try encodeContainer.encode(insightTimeRange, forKey: .insightTimeRange)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let predictionTimeRange = predictionTimeRange {
            try encodeContainer.encode(predictionTimeRange, forKey: .predictionTimeRange)
        }
        if let resourceCollection = resourceCollection {
            try encodeContainer.encode(resourceCollection, forKey: .resourceCollection)
        }
        if let serviceCollection = serviceCollection {
            try encodeContainer.encode(serviceCollection, forKey: .serviceCollection)
        }
        if let severity = severity {
            try encodeContainer.encode(severity.rawValue, forKey: .severity)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let severityDecoded = try containerValues.decodeIfPresent(InsightSeverity.self, forKey: .severity)
        severity = severityDecoded
        let statusDecoded = try containerValues.decodeIfPresent(InsightStatus.self, forKey: .status)
        status = statusDecoded
        let insightTimeRangeDecoded = try containerValues.decodeIfPresent(InsightTimeRange.self, forKey: .insightTimeRange)
        insightTimeRange = insightTimeRangeDecoded
        let predictionTimeRangeDecoded = try containerValues.decodeIfPresent(PredictionTimeRange.self, forKey: .predictionTimeRange)
        predictionTimeRange = predictionTimeRangeDecoded
        let resourceCollectionDecoded = try containerValues.decodeIfPresent(ResourceCollection.self, forKey: .resourceCollection)
        resourceCollection = resourceCollectionDecoded
        let serviceCollectionDecoded = try containerValues.decodeIfPresent(ServiceCollection.self, forKey: .serviceCollection)
        serviceCollection = serviceCollectionDecoded
    }
}

extension ProactiveInsightSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ProactiveInsightSummary(id: \(String(describing: id)), insightTimeRange: \(String(describing: insightTimeRange)), name: \(String(describing: name)), predictionTimeRange: \(String(describing: predictionTimeRange)), resourceCollection: \(String(describing: resourceCollection)), serviceCollection: \(String(describing: serviceCollection)), severity: \(String(describing: severity)), status: \(String(describing: status)))"}
}

/// <p>Details about a proactive insight. This object is returned by
/// 			<code>DescribeInsight.</code>
///          </p>
public struct ProactiveInsightSummary: Equatable {
    /// <p>The ID of the proactive insight. </p>
    public let id: String?
    /// <p> A time ranged that specifies when the observed behavior in an insight started and
    /// 			ended. </p>
    public let insightTimeRange: InsightTimeRange?
    /// <p>The name of the proactive insight. </p>
    public let name: String?
    /// <p>
    /// 			The time range during which anomalous behavior in a proactive anomaly or an insight is expected to occur.
    /// 		</p>
    public let predictionTimeRange: PredictionTimeRange?
    /// <p>
    /// 			A collection of AWS resources supported by DevOps Guru. The one type of AWS resource collection supported is AWS CloudFormation stacks. DevOps Guru can be configured to analyze
    ///       	only the AWS resources that are defined in the stacks. You can specify up to 500 AWS CloudFormation stacks.
    /// 		</p>
    public let resourceCollection: ResourceCollection?
    /// <p>A collection of the names of AWS services.</p>
    public let serviceCollection: ServiceCollection?
    /// <p>The severity of the proactive insight. </p>
    public let severity: InsightSeverity?
    /// <p>The status of the proactive insight. </p>
    public let status: InsightStatus?

    public init (
        id: String? = nil,
        insightTimeRange: InsightTimeRange? = nil,
        name: String? = nil,
        predictionTimeRange: PredictionTimeRange? = nil,
        resourceCollection: ResourceCollection? = nil,
        serviceCollection: ServiceCollection? = nil,
        severity: InsightSeverity? = nil,
        status: InsightStatus? = nil
    )
    {
        self.id = id
        self.insightTimeRange = insightTimeRange
        self.name = name
        self.predictionTimeRange = predictionTimeRange
        self.resourceCollection = resourceCollection
        self.serviceCollection = serviceCollection
        self.severity = severity
        self.status = status
    }
}

public struct PutFeedbackInputBodyMiddleware: Middleware {
    public let id: String = "PutFeedbackInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutFeedbackInput>,
                  next: H) -> Swift.Result<OperationOutput<PutFeedbackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutFeedbackInput>
    public typealias MOutput = OperationOutput<PutFeedbackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutFeedbackOutputError>
}

extension PutFeedbackInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutFeedbackInput(insightFeedback: \(String(describing: insightFeedback)))"}
}

extension PutFeedbackInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case insightFeedback = "InsightFeedback"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let insightFeedback = insightFeedback {
            try encodeContainer.encode(insightFeedback, forKey: .insightFeedback)
        }
    }
}

public struct PutFeedbackInputHeadersMiddleware: Middleware {
    public let id: String = "PutFeedbackInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutFeedbackInput>,
                  next: H) -> Swift.Result<OperationOutput<PutFeedbackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutFeedbackInput>
    public typealias MOutput = OperationOutput<PutFeedbackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutFeedbackOutputError>
}

public struct PutFeedbackInputQueryItemMiddleware: Middleware {
    public let id: String = "PutFeedbackInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutFeedbackInput>,
                  next: H) -> Swift.Result<OperationOutput<PutFeedbackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutFeedbackInput>
    public typealias MOutput = OperationOutput<PutFeedbackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutFeedbackOutputError>
}

public struct PutFeedbackInput: Equatable {
    /// <p>
    ///    		The feedback from customers is about the recommendations in this insight.
    ///    	</p>
    public let insightFeedback: InsightFeedback?

    public init (
        insightFeedback: InsightFeedback? = nil
    )
    {
        self.insightFeedback = insightFeedback
    }
}

struct PutFeedbackInputBody: Equatable {
    public let insightFeedback: InsightFeedback?
}

extension PutFeedbackInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case insightFeedback = "InsightFeedback"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let insightFeedbackDecoded = try containerValues.decodeIfPresent(InsightFeedback.self, forKey: .insightFeedback)
        insightFeedback = insightFeedbackDecoded
    }
}

extension PutFeedbackOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutFeedbackOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutFeedbackOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutFeedbackOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutFeedbackOutputResponse()"}
}

extension PutFeedbackOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct PutFeedbackOutputResponse: Equatable {

    public init() {}
}

struct PutFeedbackOutputResponseBody: Equatable {
}

extension PutFeedbackOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ReactiveAnomaly: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case anomalyTimeRange = "AnomalyTimeRange"
        case associatedInsightId = "AssociatedInsightId"
        case id = "Id"
        case resourceCollection = "ResourceCollection"
        case severity = "Severity"
        case sourceDetails = "SourceDetails"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let anomalyTimeRange = anomalyTimeRange {
            try encodeContainer.encode(anomalyTimeRange, forKey: .anomalyTimeRange)
        }
        if let associatedInsightId = associatedInsightId {
            try encodeContainer.encode(associatedInsightId, forKey: .associatedInsightId)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let resourceCollection = resourceCollection {
            try encodeContainer.encode(resourceCollection, forKey: .resourceCollection)
        }
        if let severity = severity {
            try encodeContainer.encode(severity.rawValue, forKey: .severity)
        }
        if let sourceDetails = sourceDetails {
            try encodeContainer.encode(sourceDetails, forKey: .sourceDetails)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let severityDecoded = try containerValues.decodeIfPresent(AnomalySeverity.self, forKey: .severity)
        severity = severityDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AnomalyStatus.self, forKey: .status)
        status = statusDecoded
        let anomalyTimeRangeDecoded = try containerValues.decodeIfPresent(AnomalyTimeRange.self, forKey: .anomalyTimeRange)
        anomalyTimeRange = anomalyTimeRangeDecoded
        let sourceDetailsDecoded = try containerValues.decodeIfPresent(AnomalySourceDetails.self, forKey: .sourceDetails)
        sourceDetails = sourceDetailsDecoded
        let associatedInsightIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .associatedInsightId)
        associatedInsightId = associatedInsightIdDecoded
        let resourceCollectionDecoded = try containerValues.decodeIfPresent(ResourceCollection.self, forKey: .resourceCollection)
        resourceCollection = resourceCollectionDecoded
    }
}

extension ReactiveAnomaly: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReactiveAnomaly(anomalyTimeRange: \(String(describing: anomalyTimeRange)), associatedInsightId: \(String(describing: associatedInsightId)), id: \(String(describing: id)), resourceCollection: \(String(describing: resourceCollection)), severity: \(String(describing: severity)), sourceDetails: \(String(describing: sourceDetails)), status: \(String(describing: status)))"}
}

/// <p>Details about a reactive anomaly.  This object is returned by <code>ListAnomalies</code>.</p>
public struct ReactiveAnomaly: Equatable {
    /// <p>
    /// 			A time range that specifies when the observed unusual behavior in an anomaly started and ended.
    /// 		</p>
    public let anomalyTimeRange: AnomalyTimeRange?
    /// <p>
    /// 			The ID of the insight that contains this anomaly. An insight is composed of related anomalies.
    /// 		</p>
    public let associatedInsightId: String?
    /// <p>The ID of the reactive anomaly. </p>
    public let id: String?
    /// <p>
    /// 			A collection of AWS resources supported by DevOps Guru. The one type of AWS resource collection supported is AWS CloudFormation stacks. DevOps Guru can be configured to analyze
    ///       	only the AWS resources that are defined in the stacks. You can specify up to 500 AWS CloudFormation stacks.
    /// 		</p>
    public let resourceCollection: ResourceCollection?
    /// <p>The severity of the anomaly. </p>
    public let severity: AnomalySeverity?
    /// <p>
    /// 			Details about the source of the analyzed operational data that triggered the anomaly. The one supported source is Amazon CloudWatch metrics.
    /// 		</p>
    public let sourceDetails: AnomalySourceDetails?
    /// <p>
    /// 			The status of the anomaly.
    /// 		</p>
    public let status: AnomalyStatus?

    public init (
        anomalyTimeRange: AnomalyTimeRange? = nil,
        associatedInsightId: String? = nil,
        id: String? = nil,
        resourceCollection: ResourceCollection? = nil,
        severity: AnomalySeverity? = nil,
        sourceDetails: AnomalySourceDetails? = nil,
        status: AnomalyStatus? = nil
    )
    {
        self.anomalyTimeRange = anomalyTimeRange
        self.associatedInsightId = associatedInsightId
        self.id = id
        self.resourceCollection = resourceCollection
        self.severity = severity
        self.sourceDetails = sourceDetails
        self.status = status
    }
}

extension ReactiveAnomalySummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case anomalyTimeRange = "AnomalyTimeRange"
        case associatedInsightId = "AssociatedInsightId"
        case id = "Id"
        case resourceCollection = "ResourceCollection"
        case severity = "Severity"
        case sourceDetails = "SourceDetails"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let anomalyTimeRange = anomalyTimeRange {
            try encodeContainer.encode(anomalyTimeRange, forKey: .anomalyTimeRange)
        }
        if let associatedInsightId = associatedInsightId {
            try encodeContainer.encode(associatedInsightId, forKey: .associatedInsightId)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let resourceCollection = resourceCollection {
            try encodeContainer.encode(resourceCollection, forKey: .resourceCollection)
        }
        if let severity = severity {
            try encodeContainer.encode(severity.rawValue, forKey: .severity)
        }
        if let sourceDetails = sourceDetails {
            try encodeContainer.encode(sourceDetails, forKey: .sourceDetails)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let severityDecoded = try containerValues.decodeIfPresent(AnomalySeverity.self, forKey: .severity)
        severity = severityDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AnomalyStatus.self, forKey: .status)
        status = statusDecoded
        let anomalyTimeRangeDecoded = try containerValues.decodeIfPresent(AnomalyTimeRange.self, forKey: .anomalyTimeRange)
        anomalyTimeRange = anomalyTimeRangeDecoded
        let sourceDetailsDecoded = try containerValues.decodeIfPresent(AnomalySourceDetails.self, forKey: .sourceDetails)
        sourceDetails = sourceDetailsDecoded
        let associatedInsightIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .associatedInsightId)
        associatedInsightId = associatedInsightIdDecoded
        let resourceCollectionDecoded = try containerValues.decodeIfPresent(ResourceCollection.self, forKey: .resourceCollection)
        resourceCollection = resourceCollectionDecoded
    }
}

extension ReactiveAnomalySummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReactiveAnomalySummary(anomalyTimeRange: \(String(describing: anomalyTimeRange)), associatedInsightId: \(String(describing: associatedInsightId)), id: \(String(describing: id)), resourceCollection: \(String(describing: resourceCollection)), severity: \(String(describing: severity)), sourceDetails: \(String(describing: sourceDetails)), status: \(String(describing: status)))"}
}

/// <p>Details about a reactive anomaly. This object is returned by
/// 			<code>DescribeAnomaly.</code>
///          </p>
public struct ReactiveAnomalySummary: Equatable {
    /// <p>
    /// 			A time range that specifies when the observed unusual behavior in an anomaly started and ended.
    /// 		</p>
    public let anomalyTimeRange: AnomalyTimeRange?
    /// <p>
    /// 			The ID of the insight that contains this anomaly. An insight is composed of related anomalies.
    /// 		</p>
    public let associatedInsightId: String?
    /// <p>
    /// 			The ID of the reactive anomaly.
    /// 		</p>
    public let id: String?
    /// <p>
    /// 			A collection of AWS resources supported by DevOps Guru. The one type of AWS resource collection supported is AWS CloudFormation stacks. DevOps Guru can be configured to analyze
    ///       	only the AWS resources that are defined in the stacks. You can specify up to 500 AWS CloudFormation stacks.
    /// 		</p>
    public let resourceCollection: ResourceCollection?
    /// <p>
    /// 			The severity of the reactive anomaly.			
    /// 		</p>
    public let severity: AnomalySeverity?
    /// <p>
    /// 			Details about the source of the analyzed operational data that triggered the anomaly. The one supported source is Amazon CloudWatch metrics.
    /// 		</p>
    public let sourceDetails: AnomalySourceDetails?
    /// <p>
    /// 			The status of the reactive anomaly.
    /// 		</p>
    public let status: AnomalyStatus?

    public init (
        anomalyTimeRange: AnomalyTimeRange? = nil,
        associatedInsightId: String? = nil,
        id: String? = nil,
        resourceCollection: ResourceCollection? = nil,
        severity: AnomalySeverity? = nil,
        sourceDetails: AnomalySourceDetails? = nil,
        status: AnomalyStatus? = nil
    )
    {
        self.anomalyTimeRange = anomalyTimeRange
        self.associatedInsightId = associatedInsightId
        self.id = id
        self.resourceCollection = resourceCollection
        self.severity = severity
        self.sourceDetails = sourceDetails
        self.status = status
    }
}

extension ReactiveInsight: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case id = "Id"
        case insightTimeRange = "InsightTimeRange"
        case name = "Name"
        case resourceCollection = "ResourceCollection"
        case severity = "Severity"
        case ssmOpsItemId = "SsmOpsItemId"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let insightTimeRange = insightTimeRange {
            try encodeContainer.encode(insightTimeRange, forKey: .insightTimeRange)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let resourceCollection = resourceCollection {
            try encodeContainer.encode(resourceCollection, forKey: .resourceCollection)
        }
        if let severity = severity {
            try encodeContainer.encode(severity.rawValue, forKey: .severity)
        }
        if let ssmOpsItemId = ssmOpsItemId {
            try encodeContainer.encode(ssmOpsItemId, forKey: .ssmOpsItemId)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let severityDecoded = try containerValues.decodeIfPresent(InsightSeverity.self, forKey: .severity)
        severity = severityDecoded
        let statusDecoded = try containerValues.decodeIfPresent(InsightStatus.self, forKey: .status)
        status = statusDecoded
        let insightTimeRangeDecoded = try containerValues.decodeIfPresent(InsightTimeRange.self, forKey: .insightTimeRange)
        insightTimeRange = insightTimeRangeDecoded
        let resourceCollectionDecoded = try containerValues.decodeIfPresent(ResourceCollection.self, forKey: .resourceCollection)
        resourceCollection = resourceCollectionDecoded
        let ssmOpsItemIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ssmOpsItemId)
        ssmOpsItemId = ssmOpsItemIdDecoded
    }
}

extension ReactiveInsight: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReactiveInsight(id: \(String(describing: id)), insightTimeRange: \(String(describing: insightTimeRange)), name: \(String(describing: name)), resourceCollection: \(String(describing: resourceCollection)), severity: \(String(describing: severity)), ssmOpsItemId: \(String(describing: ssmOpsItemId)), status: \(String(describing: status)))"}
}

/// <p>
/// 			Information about a reactive insight. This object is returned by <code>ListInsights</code>.
/// 		</p>
public struct ReactiveInsight: Equatable {
    /// <p>
    /// 			The ID of a reactive insight.
    /// 		</p>
    public let id: String?
    /// <p> A time ranged that specifies when the observed behavior in an insight started and
    /// 			ended. </p>
    public let insightTimeRange: InsightTimeRange?
    /// <p>
    /// 			The name of a reactive insight.
    /// 		</p>
    public let name: String?
    /// <p>
    /// 			A collection of AWS resources supported by DevOps Guru. The one type of AWS resource collection supported is AWS CloudFormation stacks. DevOps Guru can be configured to analyze
    ///       	only the AWS resources that are defined in the stacks. You can specify up to 500 AWS CloudFormation stacks.
    /// 		</p>
    public let resourceCollection: ResourceCollection?
    /// <p>
    /// 			The severity of a reactive insight.
    /// 		</p>
    public let severity: InsightSeverity?
    /// <p>
    /// 			The ID of the AWS System Manager OpsItem created for this insight. You must enable
    /// 			the creation of OpstItems insights before they are created for each insight.
    /// 		</p>
    public let ssmOpsItemId: String?
    /// <p>
    /// 			The status of a reactive insight.
    /// 		</p>
    public let status: InsightStatus?

    public init (
        id: String? = nil,
        insightTimeRange: InsightTimeRange? = nil,
        name: String? = nil,
        resourceCollection: ResourceCollection? = nil,
        severity: InsightSeverity? = nil,
        ssmOpsItemId: String? = nil,
        status: InsightStatus? = nil
    )
    {
        self.id = id
        self.insightTimeRange = insightTimeRange
        self.name = name
        self.resourceCollection = resourceCollection
        self.severity = severity
        self.ssmOpsItemId = ssmOpsItemId
        self.status = status
    }
}

extension ReactiveInsightSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case id = "Id"
        case insightTimeRange = "InsightTimeRange"
        case name = "Name"
        case resourceCollection = "ResourceCollection"
        case serviceCollection = "ServiceCollection"
        case severity = "Severity"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let insightTimeRange = insightTimeRange {
            try encodeContainer.encode(insightTimeRange, forKey: .insightTimeRange)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let resourceCollection = resourceCollection {
            try encodeContainer.encode(resourceCollection, forKey: .resourceCollection)
        }
        if let serviceCollection = serviceCollection {
            try encodeContainer.encode(serviceCollection, forKey: .serviceCollection)
        }
        if let severity = severity {
            try encodeContainer.encode(severity.rawValue, forKey: .severity)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let severityDecoded = try containerValues.decodeIfPresent(InsightSeverity.self, forKey: .severity)
        severity = severityDecoded
        let statusDecoded = try containerValues.decodeIfPresent(InsightStatus.self, forKey: .status)
        status = statusDecoded
        let insightTimeRangeDecoded = try containerValues.decodeIfPresent(InsightTimeRange.self, forKey: .insightTimeRange)
        insightTimeRange = insightTimeRangeDecoded
        let resourceCollectionDecoded = try containerValues.decodeIfPresent(ResourceCollection.self, forKey: .resourceCollection)
        resourceCollection = resourceCollectionDecoded
        let serviceCollectionDecoded = try containerValues.decodeIfPresent(ServiceCollection.self, forKey: .serviceCollection)
        serviceCollection = serviceCollectionDecoded
    }
}

extension ReactiveInsightSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReactiveInsightSummary(id: \(String(describing: id)), insightTimeRange: \(String(describing: insightTimeRange)), name: \(String(describing: name)), resourceCollection: \(String(describing: resourceCollection)), serviceCollection: \(String(describing: serviceCollection)), severity: \(String(describing: severity)), status: \(String(describing: status)))"}
}

/// <p> Information about a reactive insight. This object is returned by
/// 				<code>DescribeInsight.</code>
///          </p>
public struct ReactiveInsightSummary: Equatable {
    /// <p>
    /// 			The ID of a reactive summary.
    /// 		</p>
    public let id: String?
    /// <p> A time ranged that specifies when the observed behavior in an insight started and
    /// 			ended. </p>
    public let insightTimeRange: InsightTimeRange?
    /// <p>
    /// 			The name of a reactive insight.
    /// 		</p>
    public let name: String?
    /// <p>
    /// 			A collection of AWS resources supported by DevOps Guru. The one type of AWS resource collection supported is AWS CloudFormation stacks. DevOps Guru can be configured to analyze
    ///       	only the AWS resources that are defined in the stacks. You can specify up to 500 AWS CloudFormation stacks.
    /// 		</p>
    public let resourceCollection: ResourceCollection?
    /// <p>A collection of the names of AWS services.</p>
    public let serviceCollection: ServiceCollection?
    /// <p>
    /// 			The severity of a reactive insight.
    /// 		</p>
    public let severity: InsightSeverity?
    /// <p>
    /// 			The status of a reactive insight.
    /// 		</p>
    public let status: InsightStatus?

    public init (
        id: String? = nil,
        insightTimeRange: InsightTimeRange? = nil,
        name: String? = nil,
        resourceCollection: ResourceCollection? = nil,
        serviceCollection: ServiceCollection? = nil,
        severity: InsightSeverity? = nil,
        status: InsightStatus? = nil
    )
    {
        self.id = id
        self.insightTimeRange = insightTimeRange
        self.name = name
        self.resourceCollection = resourceCollection
        self.serviceCollection = serviceCollection
        self.severity = severity
        self.status = status
    }
}

extension Recommendation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case link = "Link"
        case name = "Name"
        case reason = "Reason"
        case relatedAnomalies = "RelatedAnomalies"
        case relatedEvents = "RelatedEvents"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let link = link {
            try encodeContainer.encode(link, forKey: .link)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let reason = reason {
            try encodeContainer.encode(reason, forKey: .reason)
        }
        if let relatedAnomalies = relatedAnomalies {
            var relatedAnomaliesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .relatedAnomalies)
            for recommendationrelatedanomalies0 in relatedAnomalies {
                try relatedAnomaliesContainer.encode(recommendationrelatedanomalies0)
            }
        }
        if let relatedEvents = relatedEvents {
            var relatedEventsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .relatedEvents)
            for recommendationrelatedevents0 in relatedEvents {
                try relatedEventsContainer.encode(recommendationrelatedevents0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let linkDecoded = try containerValues.decodeIfPresent(String.self, forKey: .link)
        link = linkDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .reason)
        reason = reasonDecoded
        let relatedEventsContainer = try containerValues.decodeIfPresent([RecommendationRelatedEvent?].self, forKey: .relatedEvents)
        var relatedEventsDecoded0:[RecommendationRelatedEvent]? = nil
        if let relatedEventsContainer = relatedEventsContainer {
            relatedEventsDecoded0 = [RecommendationRelatedEvent]()
            for structure0 in relatedEventsContainer {
                if let structure0 = structure0 {
                    relatedEventsDecoded0?.append(structure0)
                }
            }
        }
        relatedEvents = relatedEventsDecoded0
        let relatedAnomaliesContainer = try containerValues.decodeIfPresent([RecommendationRelatedAnomaly?].self, forKey: .relatedAnomalies)
        var relatedAnomaliesDecoded0:[RecommendationRelatedAnomaly]? = nil
        if let relatedAnomaliesContainer = relatedAnomaliesContainer {
            relatedAnomaliesDecoded0 = [RecommendationRelatedAnomaly]()
            for structure0 in relatedAnomaliesContainer {
                if let structure0 = structure0 {
                    relatedAnomaliesDecoded0?.append(structure0)
                }
            }
        }
        relatedAnomalies = relatedAnomaliesDecoded0
    }
}

extension Recommendation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Recommendation(description: \(String(describing: description)), link: \(String(describing: link)), name: \(String(describing: name)), reason: \(String(describing: reason)), relatedAnomalies: \(String(describing: relatedAnomalies)), relatedEvents: \(String(describing: relatedEvents)))"}
}

/// <p> Recommendation information to help you remediate detected anomalous behavior that
/// 			generated an insight. </p>
public struct Recommendation: Equatable {
    /// <p>
    /// 			A description of the problem.
    /// 		</p>
    public let description: String?
    /// <p>
    /// 			A hyperlink to information to help you address the problem.
    /// 		</p>
    public let link: String?
    /// <p>
    /// 			The name of the recommendation.
    /// 		</p>
    public let name: String?
    /// <p>
    /// 			The reason DevOps Guru flagged the anomalous behavior as a problem.
    /// 		</p>
    public let reason: String?
    /// <p>
    /// 			Anomalies that are related to the problem. Use these Anomalies to learn more about what's happening and to help address the issue.
    /// 		</p>
    public let relatedAnomalies: [RecommendationRelatedAnomaly]?
    /// <p>
    /// 			Events that are related to the problem. Use these events to learn more about what's happening and to help address the issue.
    /// 		</p>
    public let relatedEvents: [RecommendationRelatedEvent]?

    public init (
        description: String? = nil,
        link: String? = nil,
        name: String? = nil,
        reason: String? = nil,
        relatedAnomalies: [RecommendationRelatedAnomaly]? = nil,
        relatedEvents: [RecommendationRelatedEvent]? = nil
    )
    {
        self.description = description
        self.link = link
        self.name = name
        self.reason = reason
        self.relatedAnomalies = relatedAnomalies
        self.relatedEvents = relatedEvents
    }
}

extension RecommendationRelatedAnomaly: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resources = "Resources"
        case sourceDetails = "SourceDetails"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resources = resources {
            var resourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resources)
            for recommendationrelatedanomalyresources0 in resources {
                try resourcesContainer.encode(recommendationrelatedanomalyresources0)
            }
        }
        if let sourceDetails = sourceDetails {
            var sourceDetailsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sourceDetails)
            for relatedanomalysourcedetails0 in sourceDetails {
                try sourceDetailsContainer.encode(relatedanomalysourcedetails0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourcesContainer = try containerValues.decodeIfPresent([RecommendationRelatedAnomalyResource?].self, forKey: .resources)
        var resourcesDecoded0:[RecommendationRelatedAnomalyResource]? = nil
        if let resourcesContainer = resourcesContainer {
            resourcesDecoded0 = [RecommendationRelatedAnomalyResource]()
            for structure0 in resourcesContainer {
                if let structure0 = structure0 {
                    resourcesDecoded0?.append(structure0)
                }
            }
        }
        resources = resourcesDecoded0
        let sourceDetailsContainer = try containerValues.decodeIfPresent([RecommendationRelatedAnomalySourceDetail?].self, forKey: .sourceDetails)
        var sourceDetailsDecoded0:[RecommendationRelatedAnomalySourceDetail]? = nil
        if let sourceDetailsContainer = sourceDetailsContainer {
            sourceDetailsDecoded0 = [RecommendationRelatedAnomalySourceDetail]()
            for structure0 in sourceDetailsContainer {
                if let structure0 = structure0 {
                    sourceDetailsDecoded0?.append(structure0)
                }
            }
        }
        sourceDetails = sourceDetailsDecoded0
    }
}

extension RecommendationRelatedAnomaly: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RecommendationRelatedAnomaly(resources: \(String(describing: resources)), sourceDetails: \(String(describing: sourceDetails)))"}
}

/// <p>
/// 			Information about an anomaly that is related to a recommendation.
/// 		</p>
public struct RecommendationRelatedAnomaly: Equatable {
    /// <p>
    /// 			An array of objects that represent resources in which DevOps Guru detected anomalous behavior. Each object contains the name
    /// 			and type of the resource.
    /// 		</p>
    public let resources: [RecommendationRelatedAnomalyResource]?
    /// <p>
    /// 			Information about where the anomalous behavior related the recommendation was found. For example, details in Amazon CloudWatch metrics.
    /// 		</p>
    public let sourceDetails: [RecommendationRelatedAnomalySourceDetail]?

    public init (
        resources: [RecommendationRelatedAnomalyResource]? = nil,
        sourceDetails: [RecommendationRelatedAnomalySourceDetail]? = nil
    )
    {
        self.resources = resources
        self.sourceDetails = sourceDetails
    }
}

extension RecommendationRelatedAnomalyResource: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
    }
}

extension RecommendationRelatedAnomalyResource: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RecommendationRelatedAnomalyResource(name: \(String(describing: name)), type: \(String(describing: type)))"}
}

/// <p>
/// 			Information about a resource in which DevOps Guru detected anomalous behavior.
/// 		</p>
public struct RecommendationRelatedAnomalyResource: Equatable {
    /// <p>
    /// 			The name of the resource.
    /// 		</p>
    public let name: String?
    /// <p>
    /// 			The type of the resource.
    /// 		</p>
    public let type: String?

    public init (
        name: String? = nil,
        type: String? = nil
    )
    {
        self.name = name
        self.type = type
    }
}

extension RecommendationRelatedAnomalySourceDetail: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cloudWatchMetrics = "CloudWatchMetrics"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudWatchMetrics = cloudWatchMetrics {
            var cloudWatchMetricsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .cloudWatchMetrics)
            for recommendationrelatedcloudwatchmetricssourcedetails0 in cloudWatchMetrics {
                try cloudWatchMetricsContainer.encode(recommendationrelatedcloudwatchmetricssourcedetails0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudWatchMetricsContainer = try containerValues.decodeIfPresent([RecommendationRelatedCloudWatchMetricsSourceDetail?].self, forKey: .cloudWatchMetrics)
        var cloudWatchMetricsDecoded0:[RecommendationRelatedCloudWatchMetricsSourceDetail]? = nil
        if let cloudWatchMetricsContainer = cloudWatchMetricsContainer {
            cloudWatchMetricsDecoded0 = [RecommendationRelatedCloudWatchMetricsSourceDetail]()
            for structure0 in cloudWatchMetricsContainer {
                if let structure0 = structure0 {
                    cloudWatchMetricsDecoded0?.append(structure0)
                }
            }
        }
        cloudWatchMetrics = cloudWatchMetricsDecoded0
    }
}

extension RecommendationRelatedAnomalySourceDetail: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RecommendationRelatedAnomalySourceDetail(cloudWatchMetrics: \(String(describing: cloudWatchMetrics)))"}
}

/// <p>
/// 			Contains an array of <code>RecommendationRelatedCloudWatchMetricsSourceDetail</code> objects that contain the name
/// 			and namespace of an Amazon CloudWatch metric.
/// 		</p>
public struct RecommendationRelatedAnomalySourceDetail: Equatable {
    /// <p> An array of <code>CloudWatchMetricsDetail</code> objects that contains information
    /// 			about the analyzed metrics that displayed anomalous behavior. </p>
    public let cloudWatchMetrics: [RecommendationRelatedCloudWatchMetricsSourceDetail]?

    public init (
        cloudWatchMetrics: [RecommendationRelatedCloudWatchMetricsSourceDetail]? = nil
    )
    {
        self.cloudWatchMetrics = cloudWatchMetrics
    }
}

extension RecommendationRelatedCloudWatchMetricsSourceDetail: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case metricName = "MetricName"
        case namespace = "Namespace"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let metricName = metricName {
            try encodeContainer.encode(metricName, forKey: .metricName)
        }
        if let namespace = namespace {
            try encodeContainer.encode(namespace, forKey: .namespace)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .metricName)
        metricName = metricNameDecoded
        let namespaceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .namespace)
        namespace = namespaceDecoded
    }
}

extension RecommendationRelatedCloudWatchMetricsSourceDetail: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RecommendationRelatedCloudWatchMetricsSourceDetail(metricName: \(String(describing: metricName)), namespace: \(String(describing: namespace)))"}
}

/// <p>
/// 			Information about an Amazon CloudWatch metric that is analyzed by DevOps Guru. It is one of many analyzed metrics
/// 			that are used to generate insights.
/// 		</p>
public struct RecommendationRelatedCloudWatchMetricsSourceDetail: Equatable {
    /// <p>The name of the CloudWatch metric.</p>
    public let metricName: String?
    /// <p>The namespace of the CloudWatch metric. A namespace is a container for CloudWatch metrics.</p>
    public let namespace: String?

    public init (
        metricName: String? = nil,
        namespace: String? = nil
    )
    {
        self.metricName = metricName
        self.namespace = namespace
    }
}

extension RecommendationRelatedEvent: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case resources = "Resources"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let resources = resources {
            var resourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resources)
            for recommendationrelatedeventresources0 in resources {
                try resourcesContainer.encode(recommendationrelatedeventresources0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let resourcesContainer = try containerValues.decodeIfPresent([RecommendationRelatedEventResource?].self, forKey: .resources)
        var resourcesDecoded0:[RecommendationRelatedEventResource]? = nil
        if let resourcesContainer = resourcesContainer {
            resourcesDecoded0 = [RecommendationRelatedEventResource]()
            for structure0 in resourcesContainer {
                if let structure0 = structure0 {
                    resourcesDecoded0?.append(structure0)
                }
            }
        }
        resources = resourcesDecoded0
    }
}

extension RecommendationRelatedEvent: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RecommendationRelatedEvent(name: \(String(describing: name)), resources: \(String(describing: resources)))"}
}

/// <p>
/// 			Information about an event that is related to a recommendation.
/// 		</p>
public struct RecommendationRelatedEvent: Equatable {
    /// <p>
    /// 			The name of the event. This corresponds to the <code>Name</code> field in an
    /// 			<code>Event</code> object.
    /// 		</p>
    public let name: String?
    /// <p>
    /// 			A <code>ResourceCollection</code> object that contains arrays of the names of AWS
    /// 			CloudFormation stacks. You can specify up to 500 AWS CloudFormation stacks.
    /// 		</p>
    public let resources: [RecommendationRelatedEventResource]?

    public init (
        name: String? = nil,
        resources: [RecommendationRelatedEventResource]? = nil
    )
    {
        self.name = name
        self.resources = resources
    }
}

extension RecommendationRelatedEventResource: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
    }
}

extension RecommendationRelatedEventResource: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RecommendationRelatedEventResource(name: \(String(describing: name)), type: \(String(describing: type)))"}
}

/// <p>
/// 			Information about an AWS resource that emitted and event that is related to a recommendation in an insight.
/// 		</p>
public struct RecommendationRelatedEventResource: Equatable {
    /// <p>
    /// 			The name of the resource that emitted the event. This corresponds to the <code>Name</code> field in an
    /// 			<code>EventResource</code> object.
    /// 		</p>
    public let name: String?
    /// <p>
    /// 			The type of the resource that emitted the event. This corresponds to the <code>Type</code> field in an
    /// 			<code>EventResource</code> object.
    /// 		</p>
    public let type: String?

    public init (
        name: String? = nil,
        type: String? = nil
    )
    {
        self.name = name
        self.type = type
    }
}

extension RemoveNotificationChannelInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RemoveNotificationChannelInput(id: \(String(describing: id)))"}
}

extension RemoveNotificationChannelInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct RemoveNotificationChannelInputHeadersMiddleware: Middleware {
    public let id: String = "RemoveNotificationChannelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemoveNotificationChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<RemoveNotificationChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemoveNotificationChannelInput>
    public typealias MOutput = OperationOutput<RemoveNotificationChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemoveNotificationChannelOutputError>
}

public struct RemoveNotificationChannelInputQueryItemMiddleware: Middleware {
    public let id: String = "RemoveNotificationChannelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemoveNotificationChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<RemoveNotificationChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemoveNotificationChannelInput>
    public typealias MOutput = OperationOutput<RemoveNotificationChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemoveNotificationChannelOutputError>
}

public struct RemoveNotificationChannelInput: Equatable {
    /// <p>
    ///    		The ID of the notification channel to be removed.
    ///    	</p>
    public let id: String?

    public init (
        id: String? = nil
    )
    {
        self.id = id
    }
}

struct RemoveNotificationChannelInputBody: Equatable {
}

extension RemoveNotificationChannelInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension RemoveNotificationChannelOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RemoveNotificationChannelOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RemoveNotificationChannelOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RemoveNotificationChannelOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RemoveNotificationChannelOutputResponse()"}
}

extension RemoveNotificationChannelOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct RemoveNotificationChannelOutputResponse: Equatable {

    public init() {}
}

struct RemoveNotificationChannelOutputResponseBody: Equatable {
}

extension RemoveNotificationChannelOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ResourceCollection: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cloudFormation = "CloudFormation"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudFormation = cloudFormation {
            try encodeContainer.encode(cloudFormation, forKey: .cloudFormation)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudFormationDecoded = try containerValues.decodeIfPresent(CloudFormationCollection.self, forKey: .cloudFormation)
        cloudFormation = cloudFormationDecoded
    }
}

extension ResourceCollection: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceCollection(cloudFormation: \(String(describing: cloudFormation)))"}
}

/// <p>
/// 			A collection of AWS resources supported by DevOps Guru. The one type of AWS resource collection supported is AWS CloudFormation stacks. DevOps Guru can be configured to analyze
///       	only the AWS resources that are defined in the stacks. You can specify up to 500 AWS CloudFormation stacks.
/// 		</p>
public struct ResourceCollection: Equatable {
    /// <p> An array of the names of AWS CloudFormation stacks. The stacks define AWS resources
    ///    		that DevOps Guru analyzes. You can specify up to 500 AWS CloudFormation stacks.
    ///    	</p>
    public let cloudFormation: CloudFormationCollection?

    public init (
        cloudFormation: CloudFormationCollection? = nil
    )
    {
        self.cloudFormation = cloudFormation
    }
}

extension ResourceCollectionFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cloudFormation = "CloudFormation"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudFormation = cloudFormation {
            try encodeContainer.encode(cloudFormation, forKey: .cloudFormation)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudFormationDecoded = try containerValues.decodeIfPresent(CloudFormationCollectionFilter.self, forKey: .cloudFormation)
        cloudFormation = cloudFormationDecoded
    }
}

extension ResourceCollectionFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceCollectionFilter(cloudFormation: \(String(describing: cloudFormation)))"}
}

/// <p>
/// 			Information about a filter used to specify which AWS resources are analyzed for anomalous behavior by DevOps Guru.
/// 		</p>
public struct ResourceCollectionFilter: Equatable {
    /// <p>
    /// 			Information about AWS CloudFormation stacks. You can use up to 500 stacks to specify which AWS resources in your account to analyze.
    /// 			For more information, see <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/stacks.html">Stacks</a>
    /// 			in the <i>AWS CloudFormation User Guide</i>.
    /// 		</p>
    public let cloudFormation: CloudFormationCollectionFilter?

    public init (
        cloudFormation: CloudFormationCollectionFilter? = nil
    )
    {
        self.cloudFormation = cloudFormation
    }
}

public enum ResourceCollectionType {
    case awsCloudFormation
    case awsService
    case sdkUnknown(String)
}

extension ResourceCollectionType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ResourceCollectionType] {
        return [
            .awsCloudFormation,
            .awsService,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .awsCloudFormation: return "AWS_CLOUD_FORMATION"
        case .awsService: return "AWS_SERVICE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ResourceCollectionType(rawValue: rawValue) ?? ResourceCollectionType.sdkUnknown(rawValue)
    }
}

extension ResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundException(message: \(String(describing: message)), resourceId: \(String(describing: resourceId)), resourceType: \(String(describing: resourceType)))"}
}

extension ResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A requested resource could not be found</p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    /// <p>
    /// 			The ID of the AWS resource that could not be found.
    /// 		</p>
    public var resourceId: String?
    /// <p>
    /// 			The type of the AWS resource that could not be found.
    /// 		</p>
    public var resourceType: String?

    public init (
        message: String? = nil,
        resourceId: String? = nil,
        resourceType: String? = nil
    )
    {
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody: Equatable {
    public let message: String?
    public let resourceId: String?
    public let resourceType: String?
}

extension ResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension SearchInsightsFilters: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceCollection = "ResourceCollection"
        case serviceCollection = "ServiceCollection"
        case severities = "Severities"
        case statuses = "Statuses"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceCollection = resourceCollection {
            try encodeContainer.encode(resourceCollection, forKey: .resourceCollection)
        }
        if let serviceCollection = serviceCollection {
            try encodeContainer.encode(serviceCollection, forKey: .serviceCollection)
        }
        if let severities = severities {
            var severitiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .severities)
            for insightseverities0 in severities {
                try severitiesContainer.encode(insightseverities0.rawValue)
            }
        }
        if let statuses = statuses {
            var statusesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .statuses)
            for insightstatuses0 in statuses {
                try statusesContainer.encode(insightstatuses0.rawValue)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let severitiesContainer = try containerValues.decodeIfPresent([InsightSeverity?].self, forKey: .severities)
        var severitiesDecoded0:[InsightSeverity]? = nil
        if let severitiesContainer = severitiesContainer {
            severitiesDecoded0 = [InsightSeverity]()
            for string0 in severitiesContainer {
                if let string0 = string0 {
                    severitiesDecoded0?.append(string0)
                }
            }
        }
        severities = severitiesDecoded0
        let statusesContainer = try containerValues.decodeIfPresent([InsightStatus?].self, forKey: .statuses)
        var statusesDecoded0:[InsightStatus]? = nil
        if let statusesContainer = statusesContainer {
            statusesDecoded0 = [InsightStatus]()
            for string0 in statusesContainer {
                if let string0 = string0 {
                    statusesDecoded0?.append(string0)
                }
            }
        }
        statuses = statusesDecoded0
        let resourceCollectionDecoded = try containerValues.decodeIfPresent(ResourceCollection.self, forKey: .resourceCollection)
        resourceCollection = resourceCollectionDecoded
        let serviceCollectionDecoded = try containerValues.decodeIfPresent(ServiceCollection.self, forKey: .serviceCollection)
        serviceCollection = serviceCollectionDecoded
    }
}

extension SearchInsightsFilters: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SearchInsightsFilters(resourceCollection: \(String(describing: resourceCollection)), serviceCollection: \(String(describing: serviceCollection)), severities: \(String(describing: severities)), statuses: \(String(describing: statuses)))"}
}

/// <p>
///    		Specifies one or more severity values and one or more status values that are used to search
///    		for insights.
///    	</p>
public struct SearchInsightsFilters: Equatable {
    /// <p>
    /// 			A collection of AWS resources supported by DevOps Guru. The one type of AWS resource collection supported is AWS CloudFormation stacks. DevOps Guru can be configured to analyze
    ///       	only the AWS resources that are defined in the stacks. You can specify up to 500 AWS CloudFormation stacks.
    /// 		</p>
    public let resourceCollection: ResourceCollection?
    /// <p>A collection of the names of AWS services.</p>
    public let serviceCollection: ServiceCollection?
    /// <p>
    ///    		An array of severity values used to search for insights.
    ///    	</p>
    public let severities: [InsightSeverity]?
    /// <p>
    ///    		An array of status values used to search for insights.
    ///    	</p>
    public let statuses: [InsightStatus]?

    public init (
        resourceCollection: ResourceCollection? = nil,
        serviceCollection: ServiceCollection? = nil,
        severities: [InsightSeverity]? = nil,
        statuses: [InsightStatus]? = nil
    )
    {
        self.resourceCollection = resourceCollection
        self.serviceCollection = serviceCollection
        self.severities = severities
        self.statuses = statuses
    }
}

public struct SearchInsightsInputBodyMiddleware: Middleware {
    public let id: String = "SearchInsightsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SearchInsightsInput>,
                  next: H) -> Swift.Result<OperationOutput<SearchInsightsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SearchInsightsInput>
    public typealias MOutput = OperationOutput<SearchInsightsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SearchInsightsOutputError>
}

extension SearchInsightsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SearchInsightsInput(filters: \(String(describing: filters)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), startTimeRange: \(String(describing: startTimeRange)), type: \(String(describing: type)))"}
}

extension SearchInsightsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case startTimeRange = "StartTimeRange"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            try encodeContainer.encode(filters, forKey: .filters)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let startTimeRange = startTimeRange {
            try encodeContainer.encode(startTimeRange, forKey: .startTimeRange)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

public struct SearchInsightsInputHeadersMiddleware: Middleware {
    public let id: String = "SearchInsightsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SearchInsightsInput>,
                  next: H) -> Swift.Result<OperationOutput<SearchInsightsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SearchInsightsInput>
    public typealias MOutput = OperationOutput<SearchInsightsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SearchInsightsOutputError>
}

public struct SearchInsightsInputQueryItemMiddleware: Middleware {
    public let id: String = "SearchInsightsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SearchInsightsInput>,
                  next: H) -> Swift.Result<OperationOutput<SearchInsightsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SearchInsightsInput>
    public typealias MOutput = OperationOutput<SearchInsightsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SearchInsightsOutputError>
}

public struct SearchInsightsInput: Equatable {
    /// <p>
    ///    		A <code>SearchInsightsFilters</code> object that is used to set the severity and status filters on your insight search.
    ///    	</p>
    public let filters: SearchInsightsFilters?
    /// <p>The maximum number of results to return with a single call.
    /// 	To retrieve the remaining results, make another call with the returned <code>nextToken</code> value.</p>
    public let maxResults: Int?
    /// <p>The pagination token to use to retrieve
    ///    the next page of results for this operation. If this value is null, it retrieves the first page.</p>
    public let nextToken: String?
    /// <p>
    ///    		The start of the time range passed in. Returned insights occurred after this time.
    ///    	</p>
    public let startTimeRange: StartTimeRange?
    /// <p>
    ///    		The type of insights you are searching for (<code>REACTIVE</code> or <code>PROACTIVE</code>).
    ///    	</p>
    public let type: InsightType?

    public init (
        filters: SearchInsightsFilters? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        startTimeRange: StartTimeRange? = nil,
        type: InsightType? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.startTimeRange = startTimeRange
        self.type = type
    }
}

struct SearchInsightsInputBody: Equatable {
    public let startTimeRange: StartTimeRange?
    public let filters: SearchInsightsFilters?
    public let maxResults: Int?
    public let nextToken: String?
    public let type: InsightType?
}

extension SearchInsightsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case startTimeRange = "StartTimeRange"
        case type = "Type"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startTimeRangeDecoded = try containerValues.decodeIfPresent(StartTimeRange.self, forKey: .startTimeRange)
        startTimeRange = startTimeRangeDecoded
        let filtersDecoded = try containerValues.decodeIfPresent(SearchInsightsFilters.self, forKey: .filters)
        filters = filtersDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let typeDecoded = try containerValues.decodeIfPresent(InsightType.self, forKey: .type)
        type = typeDecoded
    }
}

extension SearchInsightsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SearchInsightsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SearchInsightsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SearchInsightsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SearchInsightsOutputResponse(nextToken: \(String(describing: nextToken)), proactiveInsights: \(String(describing: proactiveInsights)), reactiveInsights: \(String(describing: reactiveInsights)))"}
}

extension SearchInsightsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: SearchInsightsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.proactiveInsights = output.proactiveInsights
            self.reactiveInsights = output.reactiveInsights
        } else {
            self.nextToken = nil
            self.proactiveInsights = nil
            self.reactiveInsights = nil
        }
    }
}

public struct SearchInsightsOutputResponse: Equatable {
    /// <p>The pagination token to use to retrieve
    ///    the next page of results for this operation. If there are no more pages, this value is null.</p>
    public let nextToken: String?
    /// <p>
    /// 			The returned proactive insights.
    /// 		</p>
    public let proactiveInsights: [ProactiveInsightSummary]?
    /// <p>
    /// 			The returned reactive insights.
    /// 		</p>
    public let reactiveInsights: [ReactiveInsightSummary]?

    public init (
        nextToken: String? = nil,
        proactiveInsights: [ProactiveInsightSummary]? = nil,
        reactiveInsights: [ReactiveInsightSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.proactiveInsights = proactiveInsights
        self.reactiveInsights = reactiveInsights
    }
}

struct SearchInsightsOutputResponseBody: Equatable {
    public let proactiveInsights: [ProactiveInsightSummary]?
    public let reactiveInsights: [ReactiveInsightSummary]?
    public let nextToken: String?
}

extension SearchInsightsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case proactiveInsights = "ProactiveInsights"
        case reactiveInsights = "ReactiveInsights"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let proactiveInsightsContainer = try containerValues.decodeIfPresent([ProactiveInsightSummary?].self, forKey: .proactiveInsights)
        var proactiveInsightsDecoded0:[ProactiveInsightSummary]? = nil
        if let proactiveInsightsContainer = proactiveInsightsContainer {
            proactiveInsightsDecoded0 = [ProactiveInsightSummary]()
            for structure0 in proactiveInsightsContainer {
                if let structure0 = structure0 {
                    proactiveInsightsDecoded0?.append(structure0)
                }
            }
        }
        proactiveInsights = proactiveInsightsDecoded0
        let reactiveInsightsContainer = try containerValues.decodeIfPresent([ReactiveInsightSummary?].self, forKey: .reactiveInsights)
        var reactiveInsightsDecoded0:[ReactiveInsightSummary]? = nil
        if let reactiveInsightsContainer = reactiveInsightsContainer {
            reactiveInsightsDecoded0 = [ReactiveInsightSummary]()
            for structure0 in reactiveInsightsContainer {
                if let structure0 = structure0 {
                    reactiveInsightsDecoded0?.append(structure0)
                }
            }
        }
        reactiveInsights = reactiveInsightsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ServiceCollection: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case serviceNames = "ServiceNames"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serviceNames = serviceNames {
            var serviceNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .serviceNames)
            for servicenames0 in serviceNames {
                try serviceNamesContainer.encode(servicenames0.rawValue)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceNamesContainer = try containerValues.decodeIfPresent([ServiceName?].self, forKey: .serviceNames)
        var serviceNamesDecoded0:[ServiceName]? = nil
        if let serviceNamesContainer = serviceNamesContainer {
            serviceNamesDecoded0 = [ServiceName]()
            for string0 in serviceNamesContainer {
                if let string0 = string0 {
                    serviceNamesDecoded0?.append(string0)
                }
            }
        }
        serviceNames = serviceNamesDecoded0
    }
}

extension ServiceCollection: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceCollection(serviceNames: \(String(describing: serviceNames)))"}
}

/// <p>A collection of the names of AWS services.</p>
public struct ServiceCollection: Equatable {
    /// <p>An array of strings that each specifies the name of an AWS service.</p>
    public let serviceNames: [ServiceName]?

    public init (
        serviceNames: [ServiceName]? = nil
    )
    {
        self.serviceNames = serviceNames
    }
}

extension ServiceHealth: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case insight = "Insight"
        case serviceName = "ServiceName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let insight = insight {
            try encodeContainer.encode(insight, forKey: .insight)
        }
        if let serviceName = serviceName {
            try encodeContainer.encode(serviceName.rawValue, forKey: .serviceName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceNameDecoded = try containerValues.decodeIfPresent(ServiceName.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
        let insightDecoded = try containerValues.decodeIfPresent(ServiceInsightHealth.self, forKey: .insight)
        insight = insightDecoded
    }
}

extension ServiceHealth: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceHealth(insight: \(String(describing: insight)), serviceName: \(String(describing: serviceName)))"}
}

/// <p>Represents the health of an AWS service.</p>
public struct ServiceHealth: Equatable {
    /// <p>Represents the health of an AWS service. This is a <code>ServiceInsightHealth</code> that
    /// 		contains the number of open proactive and reactive insights for this service.</p>
    public let insight: ServiceInsightHealth?
    /// <p>The name of the AWS service.</p>
    public let serviceName: ServiceName?

    public init (
        insight: ServiceInsightHealth? = nil,
        serviceName: ServiceName? = nil
    )
    {
        self.insight = insight
        self.serviceName = serviceName
    }
}

extension ServiceInsightHealth: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case openProactiveInsights = "OpenProactiveInsights"
        case openReactiveInsights = "OpenReactiveInsights"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if openProactiveInsights != 0 {
            try encodeContainer.encode(openProactiveInsights, forKey: .openProactiveInsights)
        }
        if openReactiveInsights != 0 {
            try encodeContainer.encode(openReactiveInsights, forKey: .openReactiveInsights)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let openProactiveInsightsDecoded = try containerValues.decode(Int.self, forKey: .openProactiveInsights)
        openProactiveInsights = openProactiveInsightsDecoded
        let openReactiveInsightsDecoded = try containerValues.decode(Int.self, forKey: .openReactiveInsights)
        openReactiveInsights = openReactiveInsightsDecoded
    }
}

extension ServiceInsightHealth: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceInsightHealth(openProactiveInsights: \(String(describing: openProactiveInsights)), openReactiveInsights: \(String(describing: openReactiveInsights)))"}
}

/// <p>Contains the number of open proactive and reactive insights in an analyzed AWS service.</p>
public struct ServiceInsightHealth: Equatable {
    /// <p>The number of open proactive insights in the AWS service</p>
    public let openProactiveInsights: Int
    /// <p>The number of open reactive insights in the AWS service</p>
    public let openReactiveInsights: Int

    public init (
        openProactiveInsights: Int = 0,
        openReactiveInsights: Int = 0
    )
    {
        self.openProactiveInsights = openProactiveInsights
        self.openReactiveInsights = openReactiveInsights
    }
}

extension ServiceIntegrationConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case opsCenter = "OpsCenter"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let opsCenter = opsCenter {
            try encodeContainer.encode(opsCenter, forKey: .opsCenter)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let opsCenterDecoded = try containerValues.decodeIfPresent(OpsCenterIntegration.self, forKey: .opsCenter)
        opsCenter = opsCenterDecoded
    }
}

extension ServiceIntegrationConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceIntegrationConfig(opsCenter: \(String(describing: opsCenter)))"}
}

/// <p>
/// 			Information about the integration of DevOps Guru with another AWS service, such as AWS Systems Manager.
/// 		</p>
public struct ServiceIntegrationConfig: Equatable {
    /// <p>
    /// 			Information about whether DevOps Guru is configured to create an OpsItem in AWS Systems Manager OpsCenter for each created insight.
    /// 		</p>
    public let opsCenter: OpsCenterIntegration?

    public init (
        opsCenter: OpsCenterIntegration? = nil
    )
    {
        self.opsCenter = opsCenter
    }
}

public enum ServiceName {
    case apiGateway
    case applicationElb
    case autoScalingGroup
    case cloudFront
    case dynamoDb
    case ec2
    case ecs
    case eks
    case elasticBeanstalk
    case elastiCache
    case elb
    case es
    case kinesis
    case lambda
    case natGateway
    case networkElb
    case rds
    case redshift
    case route53
    case s3
    case sageMaker
    case sns
    case sqs
    case stepFunctions
    case swf
    case sdkUnknown(String)
}

extension ServiceName : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ServiceName] {
        return [
            .apiGateway,
            .applicationElb,
            .autoScalingGroup,
            .cloudFront,
            .dynamoDb,
            .ec2,
            .ecs,
            .eks,
            .elasticBeanstalk,
            .elastiCache,
            .elb,
            .es,
            .kinesis,
            .lambda,
            .natGateway,
            .networkElb,
            .rds,
            .redshift,
            .route53,
            .s3,
            .sageMaker,
            .sns,
            .sqs,
            .stepFunctions,
            .swf,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .apiGateway: return "API_GATEWAY"
        case .applicationElb: return "APPLICATION_ELB"
        case .autoScalingGroup: return "AUTO_SCALING_GROUP"
        case .cloudFront: return "CLOUD_FRONT"
        case .dynamoDb: return "DYNAMO_DB"
        case .ec2: return "EC2"
        case .ecs: return "ECS"
        case .eks: return "EKS"
        case .elasticBeanstalk: return "ELASTIC_BEANSTALK"
        case .elastiCache: return "ELASTI_CACHE"
        case .elb: return "ELB"
        case .es: return "ES"
        case .kinesis: return "KINESIS"
        case .lambda: return "LAMBDA"
        case .natGateway: return "NAT_GATEWAY"
        case .networkElb: return "NETWORK_ELB"
        case .rds: return "RDS"
        case .redshift: return "REDSHIFT"
        case .route53: return "ROUTE_53"
        case .s3: return "S3"
        case .sageMaker: return "SAGE_MAKER"
        case .sns: return "SNS"
        case .sqs: return "SQS"
        case .stepFunctions: return "STEP_FUNCTIONS"
        case .swf: return "SWF"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ServiceName(rawValue: rawValue) ?? ServiceName.sdkUnknown(rawValue)
    }
}

extension ServiceQuotaExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceQuotaExceededException(message: \(String(describing: message)))"}
}

extension ServiceQuotaExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request contains a value that exceeds a maximum quota.</p>
public struct ServiceQuotaExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Equatable {
    public let message: String?
}

extension ServiceQuotaExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceResourceCost: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cost = "Cost"
        case count = "Count"
        case state = "State"
        case type = "Type"
        case unitCost = "UnitCost"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if cost != 0.0 {
            try encodeContainer.encode(cost, forKey: .cost)
        }
        if count != 0 {
            try encodeContainer.encode(count, forKey: .count)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
        if unitCost != 0.0 {
            try encodeContainer.encode(unitCost, forKey: .unitCost)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
        let stateDecoded = try containerValues.decodeIfPresent(CostEstimationServiceResourceState.self, forKey: .state)
        state = stateDecoded
        let countDecoded = try containerValues.decode(Int.self, forKey: .count)
        count = countDecoded
        let unitCostDecoded = try containerValues.decode(Double.self, forKey: .unitCost)
        unitCost = unitCostDecoded
        let costDecoded = try containerValues.decode(Double.self, forKey: .cost)
        cost = costDecoded
    }
}

extension ServiceResourceCost: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceResourceCost(cost: \(String(describing: cost)), count: \(String(describing: count)), state: \(String(describing: state)), type: \(String(describing: type)), unitCost: \(String(describing: unitCost)))"}
}

/// <p>An object that contains information about the estimated monthly cost to
/// 			analyze an AWS resource. For more information,
/// 			see <a href="https://docs.aws.amazon.com/devops-guru/latest/userguide/cost-estimate.html">Estimate your
/// 			Amazon DevOps Guru costs</a> and
/// 			<a href="http://aws.amazon.com/devops-guru/pricing/">Amazon DevOps Guru pricing</a>.</p>
public struct ServiceResourceCost: Equatable {
    /// <p>The total estimated monthly cost to analyze the active resources for this resource.</p>
    public let cost: Double
    /// <p>The number of active resources analyzed for this service to create a monthly cost
    /// 			estimate.</p>
    public let count: Int
    /// <p>The state of the resource. The resource is <code>ACTIVE</code> if it produces metrics,
    /// 			events, or logs within an hour, otherwise it is <code>INACTIVE</code>. You pay for
    /// 			the number of active AWS resource hours analyzed for each resource. Inactive resources are
    /// 			not charged.
    /// 		</p>
    public let state: CostEstimationServiceResourceState?
    /// <p>The type of the AWS resource.</p>
    public let type: String?
    /// <p>The price per hour to analyze the resources in the service.
    /// 			For more information,
    /// 			see <a href="https://docs.aws.amazon.com/devops-guru/latest/userguide/cost-estimate.html">Estimate your
    /// 			Amazon DevOps Guru costs</a> and
    /// 			<a href="http://aws.amazon.com/devops-guru/pricing/">Amazon DevOps Guru pricing</a>.</p>
    public let unitCost: Double

    public init (
        cost: Double = 0.0,
        count: Int = 0,
        state: CostEstimationServiceResourceState? = nil,
        type: String? = nil,
        unitCost: Double = 0.0
    )
    {
        self.cost = cost
        self.count = count
        self.state = state
        self.type = type
        self.unitCost = unitCost
    }
}

extension SnsChannelConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case topicArn = "TopicArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let topicArn = topicArn {
            try encodeContainer.encode(topicArn, forKey: .topicArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let topicArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .topicArn)
        topicArn = topicArnDecoded
    }
}

extension SnsChannelConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SnsChannelConfig(topicArn: \(String(describing: topicArn)))"}
}

/// <p> Contains the Amazon Resource Name (ARN) of an Amazon Simple Notification Service topic. </p>
/// 		
/// 		       <p>If you use an Amazon SNS topic in another account, you must attach a policy to it that grants DevOps Guru permission
/// 				to it notifications. DevOps Guru adds the required policy on your behalf to send notifications using Amazon SNS in your account.
/// 				For more information, see <a href="https://docs.aws.amazon.com/devops-guru/latest/userguide/sns-required-permissions.html">Permissions
/// 				for cross account Amazon SNS topics</a>.</p>
/// 				     <p>If you use an Amazon SNS topic that is encrypted by an AWS Key Management Service customer-managed key (CMK), then you must add permissions
/// 				to the CMK. For more information, see <a href="https://docs.aws.amazon.com/devops-guru/latest/userguide/sns-kms-permissions.html">Permissions for
/// 				AWS KMS–encrypted Amazon SNS topics</a>.</p>
public struct SnsChannelConfig: Equatable {
    /// <p> The Amazon Resource Name (ARN) of an Amazon Simple Notification Service topic. </p>
    public let topicArn: String?

    public init (
        topicArn: String? = nil
    )
    {
        self.topicArn = topicArn
    }
}

public struct StartCostEstimationInputBodyMiddleware: Middleware {
    public let id: String = "StartCostEstimationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartCostEstimationInput>,
                  next: H) -> Swift.Result<OperationOutput<StartCostEstimationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartCostEstimationInput>
    public typealias MOutput = OperationOutput<StartCostEstimationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartCostEstimationOutputError>
}

extension StartCostEstimationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartCostEstimationInput(clientToken: \(String(describing: clientToken)), resourceCollection: \(String(describing: resourceCollection)))"}
}

extension StartCostEstimationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case resourceCollection = "ResourceCollection"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let resourceCollection = resourceCollection {
            try encodeContainer.encode(resourceCollection, forKey: .resourceCollection)
        }
    }
}

public struct StartCostEstimationInputHeadersMiddleware: Middleware {
    public let id: String = "StartCostEstimationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartCostEstimationInput>,
                  next: H) -> Swift.Result<OperationOutput<StartCostEstimationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartCostEstimationInput>
    public typealias MOutput = OperationOutput<StartCostEstimationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartCostEstimationOutputError>
}

public struct StartCostEstimationInputQueryItemMiddleware: Middleware {
    public let id: String = "StartCostEstimationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartCostEstimationInput>,
                  next: H) -> Swift.Result<OperationOutput<StartCostEstimationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartCostEstimationInput>
    public typealias MOutput = OperationOutput<StartCostEstimationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartCostEstimationOutputError>
}

public struct StartCostEstimationInput: Equatable {
    /// <p>The idempotency token used to identify each cost estimate request.</p>
    public var clientToken: String?
    /// <p>The collection of AWS resources used to create a monthly DevOps Guru cost estimate.</p>
    public let resourceCollection: CostEstimationResourceCollectionFilter?

    public init (
        clientToken: String? = nil,
        resourceCollection: CostEstimationResourceCollectionFilter? = nil
    )
    {
        self.clientToken = clientToken
        self.resourceCollection = resourceCollection
    }
}

struct StartCostEstimationInputBody: Equatable {
    public let resourceCollection: CostEstimationResourceCollectionFilter?
    public let clientToken: String?
}

extension StartCostEstimationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case resourceCollection = "ResourceCollection"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceCollectionDecoded = try containerValues.decodeIfPresent(CostEstimationResourceCollectionFilter.self, forKey: .resourceCollection)
        resourceCollection = resourceCollectionDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension StartCostEstimationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartCostEstimationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartCostEstimationOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartCostEstimationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartCostEstimationOutputResponse()"}
}

extension StartCostEstimationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct StartCostEstimationOutputResponse: Equatable {

    public init() {}
}

struct StartCostEstimationOutputResponseBody: Equatable {
}

extension StartCostEstimationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension StartTimeRange: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case fromTime = "FromTime"
        case toTime = "ToTime"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fromTime = fromTime {
            try encodeContainer.encode(fromTime.timeIntervalSince1970, forKey: .fromTime)
        }
        if let toTime = toTime {
            try encodeContainer.encode(toTime.timeIntervalSince1970, forKey: .toTime)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fromTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .fromTime)
        fromTime = fromTimeDecoded
        let toTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .toTime)
        toTime = toTimeDecoded
    }
}

extension StartTimeRange: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartTimeRange(fromTime: \(String(describing: fromTime)), toTime: \(String(describing: toTime)))"}
}

/// <p>
/// 			A time range used to specify when the behavior of an insight or anomaly started.
/// 		</p>
public struct StartTimeRange: Equatable {
    /// <p>
    /// 			The start time of the time range.
    /// 		</p>
    public let fromTime: Date?
    /// <p>
    /// 			The end time of the time range.
    /// 		</p>
    public let toTime: Date?

    public init (
        fromTime: Date? = nil,
        toTime: Date? = nil
    )
    {
        self.fromTime = fromTime
        self.toTime = toTime
    }
}

extension ThrottlingException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ThrottlingException(message: \(String(describing: message)), quotaCode: \(String(describing: quotaCode)), retryAfterSeconds: \(String(describing: retryAfterSeconds)), serviceCode: \(String(describing: serviceCode)))"}
}

extension ThrottlingException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.retryAfterSeconds = Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.retryAfterSeconds = 0
        }
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.quotaCode = output.quotaCode
            self.serviceCode = output.serviceCode
        } else {
            self.message = nil
            self.quotaCode = nil
            self.serviceCode = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request was denied due to a request throttling.</p>
public struct ThrottlingException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    /// <p>
    /// 			The code of the quota that was exceeded, causing the throttling exception.
    /// 		</p>
    public var quotaCode: String?
    /// <p>
    /// 			The number of seconds after which the action that caused the throttling
    /// 			exception can be retried.
    /// 		</p>
    public var retryAfterSeconds: Int
    /// <p>
    /// 			The code of the service that caused the throttling exception.
    /// 		</p>
    public var serviceCode: String?

    public init (
        message: String? = nil,
        quotaCode: String? = nil,
        retryAfterSeconds: Int = 0,
        serviceCode: String? = nil
    )
    {
        self.message = message
        self.quotaCode = quotaCode
        self.retryAfterSeconds = retryAfterSeconds
        self.serviceCode = serviceCode
    }
}

struct ThrottlingExceptionBody: Equatable {
    public let message: String?
    public let quotaCode: String?
    public let serviceCode: String?
}

extension ThrottlingExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case quotaCode = "QuotaCode"
        case serviceCode = "ServiceCode"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
    }
}

extension UpdateCloudFormationCollectionFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case stackNames = "StackNames"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let stackNames = stackNames {
            var stackNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .stackNames)
            for updatestacknames0 in stackNames {
                try stackNamesContainer.encode(updatestacknames0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackNamesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .stackNames)
        var stackNamesDecoded0:[String]? = nil
        if let stackNamesContainer = stackNamesContainer {
            stackNamesDecoded0 = [String]()
            for string0 in stackNamesContainer {
                if let string0 = string0 {
                    stackNamesDecoded0?.append(string0)
                }
            }
        }
        stackNames = stackNamesDecoded0
    }
}

extension UpdateCloudFormationCollectionFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateCloudFormationCollectionFilter(stackNames: \(String(describing: stackNames)))"}
}

/// <p> Contains the names of AWS CloudFormation stacks used to update a collection of stacks. You can specify up to 500 AWS CloudFormation stacks.</p>
public struct UpdateCloudFormationCollectionFilter: Equatable {
    /// <p>
    /// 			An array of the names of the AWS CloudFormation stacks to update. You can specify up to 500 AWS CloudFormation stacks.
    /// 		</p>
    public let stackNames: [String]?

    public init (
        stackNames: [String]? = nil
    )
    {
        self.stackNames = stackNames
    }
}

public enum UpdateResourceCollectionAction {
    case add
    case remove
    case sdkUnknown(String)
}

extension UpdateResourceCollectionAction : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [UpdateResourceCollectionAction] {
        return [
            .add,
            .remove,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .add: return "ADD"
        case .remove: return "REMOVE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = UpdateResourceCollectionAction(rawValue: rawValue) ?? UpdateResourceCollectionAction.sdkUnknown(rawValue)
    }
}

extension UpdateResourceCollectionFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cloudFormation = "CloudFormation"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudFormation = cloudFormation {
            try encodeContainer.encode(cloudFormation, forKey: .cloudFormation)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudFormationDecoded = try containerValues.decodeIfPresent(UpdateCloudFormationCollectionFilter.self, forKey: .cloudFormation)
        cloudFormation = cloudFormationDecoded
    }
}

extension UpdateResourceCollectionFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateResourceCollectionFilter(cloudFormation: \(String(describing: cloudFormation)))"}
}

/// <p>
/// 			Contains information used to update a collection of AWS resources.
/// 		</p>
public struct UpdateResourceCollectionFilter: Equatable {
    /// <p>
    /// 			An collection of AWS CloudFormation stacks. You can specify up to 500 AWS CloudFormation stacks.
    /// 		</p>
    public let cloudFormation: UpdateCloudFormationCollectionFilter?

    public init (
        cloudFormation: UpdateCloudFormationCollectionFilter? = nil
    )
    {
        self.cloudFormation = cloudFormation
    }
}

public struct UpdateResourceCollectionInputBodyMiddleware: Middleware {
    public let id: String = "UpdateResourceCollectionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateResourceCollectionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateResourceCollectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateResourceCollectionInput>
    public typealias MOutput = OperationOutput<UpdateResourceCollectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateResourceCollectionOutputError>
}

extension UpdateResourceCollectionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateResourceCollectionInput(action: \(String(describing: action)), resourceCollection: \(String(describing: resourceCollection)))"}
}

extension UpdateResourceCollectionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case action = "Action"
        case resourceCollection = "ResourceCollection"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            try encodeContainer.encode(action.rawValue, forKey: .action)
        }
        if let resourceCollection = resourceCollection {
            try encodeContainer.encode(resourceCollection, forKey: .resourceCollection)
        }
    }
}

public struct UpdateResourceCollectionInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateResourceCollectionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateResourceCollectionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateResourceCollectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateResourceCollectionInput>
    public typealias MOutput = OperationOutput<UpdateResourceCollectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateResourceCollectionOutputError>
}

public struct UpdateResourceCollectionInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateResourceCollectionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateResourceCollectionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateResourceCollectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateResourceCollectionInput>
    public typealias MOutput = OperationOutput<UpdateResourceCollectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateResourceCollectionOutputError>
}

public struct UpdateResourceCollectionInput: Equatable {
    /// <p>
    /// 			Specifies if the resource collection in the request is added or deleted to the resource collection.
    /// 		</p>
    public let action: UpdateResourceCollectionAction?
    /// <p>
    /// 			Contains information used to update a collection of AWS resources.
    /// 		</p>
    public let resourceCollection: UpdateResourceCollectionFilter?

    public init (
        action: UpdateResourceCollectionAction? = nil,
        resourceCollection: UpdateResourceCollectionFilter? = nil
    )
    {
        self.action = action
        self.resourceCollection = resourceCollection
    }
}

struct UpdateResourceCollectionInputBody: Equatable {
    public let action: UpdateResourceCollectionAction?
    public let resourceCollection: UpdateResourceCollectionFilter?
}

extension UpdateResourceCollectionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case action = "Action"
        case resourceCollection = "ResourceCollection"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionDecoded = try containerValues.decodeIfPresent(UpdateResourceCollectionAction.self, forKey: .action)
        action = actionDecoded
        let resourceCollectionDecoded = try containerValues.decodeIfPresent(UpdateResourceCollectionFilter.self, forKey: .resourceCollection)
        resourceCollection = resourceCollectionDecoded
    }
}

extension UpdateResourceCollectionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateResourceCollectionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateResourceCollectionOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateResourceCollectionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateResourceCollectionOutputResponse()"}
}

extension UpdateResourceCollectionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateResourceCollectionOutputResponse: Equatable {

    public init() {}
}

struct UpdateResourceCollectionOutputResponseBody: Equatable {
}

extension UpdateResourceCollectionOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension UpdateServiceIntegrationConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case opsCenter = "OpsCenter"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let opsCenter = opsCenter {
            try encodeContainer.encode(opsCenter, forKey: .opsCenter)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let opsCenterDecoded = try containerValues.decodeIfPresent(OpsCenterIntegrationConfig.self, forKey: .opsCenter)
        opsCenter = opsCenterDecoded
    }
}

extension UpdateServiceIntegrationConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateServiceIntegrationConfig(opsCenter: \(String(describing: opsCenter)))"}
}

/// <p>
/// 			Information about updating the integration status of an AWS service, such as AWS Systems Manager, with DevOps Guru.
/// 		</p>
public struct UpdateServiceIntegrationConfig: Equatable {
    /// <p>
    /// 			Information about whether DevOps Guru is configured to create an OpsItem in AWS Systems Manager OpsCenter for each created insight.
    /// 		</p>
    public let opsCenter: OpsCenterIntegrationConfig?

    public init (
        opsCenter: OpsCenterIntegrationConfig? = nil
    )
    {
        self.opsCenter = opsCenter
    }
}

public struct UpdateServiceIntegrationInputBodyMiddleware: Middleware {
    public let id: String = "UpdateServiceIntegrationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateServiceIntegrationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateServiceIntegrationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateServiceIntegrationInput>
    public typealias MOutput = OperationOutput<UpdateServiceIntegrationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateServiceIntegrationOutputError>
}

extension UpdateServiceIntegrationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateServiceIntegrationInput(serviceIntegration: \(String(describing: serviceIntegration)))"}
}

extension UpdateServiceIntegrationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case serviceIntegration = "ServiceIntegration"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serviceIntegration = serviceIntegration {
            try encodeContainer.encode(serviceIntegration, forKey: .serviceIntegration)
        }
    }
}

public struct UpdateServiceIntegrationInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateServiceIntegrationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateServiceIntegrationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateServiceIntegrationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateServiceIntegrationInput>
    public typealias MOutput = OperationOutput<UpdateServiceIntegrationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateServiceIntegrationOutputError>
}

public struct UpdateServiceIntegrationInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateServiceIntegrationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateServiceIntegrationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateServiceIntegrationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateServiceIntegrationInput>
    public typealias MOutput = OperationOutput<UpdateServiceIntegrationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateServiceIntegrationOutputError>
}

public struct UpdateServiceIntegrationInput: Equatable {
    /// <p>
    /// 			An <code>IntegratedServiceConfig</code> object used to specify the integrated service you want to update, and whether you
    /// 			want to update it to enabled or disabled.
    /// 		</p>
    public let serviceIntegration: UpdateServiceIntegrationConfig?

    public init (
        serviceIntegration: UpdateServiceIntegrationConfig? = nil
    )
    {
        self.serviceIntegration = serviceIntegration
    }
}

struct UpdateServiceIntegrationInputBody: Equatable {
    public let serviceIntegration: UpdateServiceIntegrationConfig?
}

extension UpdateServiceIntegrationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case serviceIntegration = "ServiceIntegration"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceIntegrationDecoded = try containerValues.decodeIfPresent(UpdateServiceIntegrationConfig.self, forKey: .serviceIntegration)
        serviceIntegration = serviceIntegrationDecoded
    }
}

extension UpdateServiceIntegrationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateServiceIntegrationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateServiceIntegrationOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateServiceIntegrationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateServiceIntegrationOutputResponse()"}
}

extension UpdateServiceIntegrationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateServiceIntegrationOutputResponse: Equatable {

    public init() {}
}

struct UpdateServiceIntegrationOutputResponseBody: Equatable {
}

extension UpdateServiceIntegrationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ValidationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ValidationException(fields: \(String(describing: fields)), message: \(String(describing: message)), reason: \(String(describing: reason)))"}
}

extension ValidationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.fields = output.fields
            self.message = output.message
            self.reason = output.reason
        } else {
            self.fields = nil
            self.message = nil
            self.reason = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>
/// 			Contains information about data passed in to a field during a request that is not valid.
/// 		</p>
public struct ValidationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>
    /// 			An array of fields that are associated with the validation exception.
    /// 		</p>
    public var fields: [ValidationExceptionField]?
    /// <p>
    /// 			A message that describes the validation exception.
    /// 		</p>
    public var message: String?
    /// <p>
    /// 			The reason the validation exception was thrown.
    /// 		</p>
    public var reason: ValidationExceptionReason?

    public init (
        fields: [ValidationExceptionField]? = nil,
        message: String? = nil,
        reason: ValidationExceptionReason? = nil
    )
    {
        self.fields = fields
        self.message = message
        self.reason = reason
    }
}

struct ValidationExceptionBody: Equatable {
    public let message: String?
    public let reason: ValidationExceptionReason?
    public let fields: [ValidationExceptionField]?
}

extension ValidationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case fields = "Fields"
        case message = "Message"
        case reason = "Reason"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(ValidationExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
        let fieldsContainer = try containerValues.decodeIfPresent([ValidationExceptionField?].self, forKey: .fields)
        var fieldsDecoded0:[ValidationExceptionField]? = nil
        if let fieldsContainer = fieldsContainer {
            fieldsDecoded0 = [ValidationExceptionField]()
            for structure0 in fieldsContainer {
                if let structure0 = structure0 {
                    fieldsDecoded0?.append(structure0)
                }
            }
        }
        fields = fieldsDecoded0
    }
}

extension ValidationExceptionField: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ValidationExceptionField: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ValidationExceptionField(message: \(String(describing: message)), name: \(String(describing: name)))"}
}

/// <p>
/// 			The field associated with the validation exception.
/// 		</p>
public struct ValidationExceptionField: Equatable {
    /// <p>
    /// 			The message associated with the validation exception with information to help
    /// 			determine its cause.
    /// 		</p>
    public let message: String?
    /// <p>
    /// 			The name of the field.
    /// 		</p>
    public let name: String?

    public init (
        message: String? = nil,
        name: String? = nil
    )
    {
        self.message = message
        self.name = name
    }
}

public enum ValidationExceptionReason {
    case cannotParse
    case fieldValidationFailed
    case other
    case unknownOperation
    case sdkUnknown(String)
}

extension ValidationExceptionReason : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ValidationExceptionReason] {
        return [
            .cannotParse,
            .fieldValidationFailed,
            .other,
            .unknownOperation,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .cannotParse: return "CANNOT_PARSE"
        case .fieldValidationFailed: return "FIELD_VALIDATION_FAILED"
        case .other: return "OTHER"
        case .unknownOperation: return "UNKNOWN_OPERATION"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ValidationExceptionReason(rawValue: rawValue) ?? ValidationExceptionReason.sdkUnknown(rawValue)
    }
}
