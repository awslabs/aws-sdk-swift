// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension BatchPrediction: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case completionTime
        case detectorName
        case detectorVersion
        case eventTypeName
        case failureReason
        case iamRoleArn
        case inputPath
        case jobId
        case lastHeartbeatTime
        case outputPath
        case processedRecordsCount
        case startTime
        case status
        case totalRecordsCount
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let completionTime = completionTime {
            try encodeContainer.encode(completionTime, forKey: .completionTime)
        }
        if let detectorName = detectorName {
            try encodeContainer.encode(detectorName, forKey: .detectorName)
        }
        if let detectorVersion = detectorVersion {
            try encodeContainer.encode(detectorVersion, forKey: .detectorVersion)
        }
        if let eventTypeName = eventTypeName {
            try encodeContainer.encode(eventTypeName, forKey: .eventTypeName)
        }
        if let failureReason = failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let iamRoleArn = iamRoleArn {
            try encodeContainer.encode(iamRoleArn, forKey: .iamRoleArn)
        }
        if let inputPath = inputPath {
            try encodeContainer.encode(inputPath, forKey: .inputPath)
        }
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let lastHeartbeatTime = lastHeartbeatTime {
            try encodeContainer.encode(lastHeartbeatTime, forKey: .lastHeartbeatTime)
        }
        if let outputPath = outputPath {
            try encodeContainer.encode(outputPath, forKey: .outputPath)
        }
        if let processedRecordsCount = processedRecordsCount {
            try encodeContainer.encode(processedRecordsCount, forKey: .processedRecordsCount)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime, forKey: .startTime)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let totalRecordsCount = totalRecordsCount {
            try encodeContainer.encode(totalRecordsCount, forKey: .totalRecordsCount)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AsyncJobStatus.self, forKey: .status)
        status = statusDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .startTime)
        startTime = startTimeDecoded
        let completionTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .completionTime)
        completionTime = completionTimeDecoded
        let lastHeartbeatTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastHeartbeatTime)
        lastHeartbeatTime = lastHeartbeatTimeDecoded
        let inputPathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .inputPath)
        inputPath = inputPathDecoded
        let outputPathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .outputPath)
        outputPath = outputPathDecoded
        let eventTypeNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventTypeName)
        eventTypeName = eventTypeNameDecoded
        let detectorNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .detectorName)
        detectorName = detectorNameDecoded
        let detectorVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .detectorVersion)
        detectorVersion = detectorVersionDecoded
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let processedRecordsCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .processedRecordsCount)
        processedRecordsCount = processedRecordsCountDecoded
        let totalRecordsCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .totalRecordsCount)
        totalRecordsCount = totalRecordsCountDecoded
    }
}
