// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccessDeniedException(message: \(String(describing: message)))"}
}

extension AccessDeniedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An exception indicating Amazon Fraud Detector does not have the needed permissions. This can occur if you submit a request, such as <code>PutExternalModel</code>, that specifies a role that is not in your account.</p>
public struct AccessDeniedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Equatable {
    public let message: String?
}

extension AccessDeniedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum AsyncJobStatus {
    case canceled
    case cancelInProgress
    case complete
    case failed
    case inProgress
    case inProgressInitializing
    case sdkUnknown(String)
}

extension AsyncJobStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AsyncJobStatus] {
        return [
            .canceled,
            .cancelInProgress,
            .complete,
            .failed,
            .inProgress,
            .inProgressInitializing,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .canceled: return "CANCELED"
        case .cancelInProgress: return "CANCEL_IN_PROGRESS"
        case .complete: return "COMPLETE"
        case .failed: return "FAILED"
        case .inProgress: return "IN_PROGRESS"
        case .inProgressInitializing: return "IN_PROGRESS_INITIALIZING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AsyncJobStatus(rawValue: rawValue) ?? AsyncJobStatus.sdkUnknown(rawValue)
    }
}

extension BatchCreateVariableError: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case code
        case message
        case name
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if code != 0 {
            try encodeContainer.encode(code, forKey: .code)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let codeDecoded = try containerValues.decode(Int.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BatchCreateVariableError: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchCreateVariableError(code: \(String(describing: code)), message: \(String(describing: message)), name: \(String(describing: name)))"}
}

/// <p>Provides the error of the batch create variable API.</p>
public struct BatchCreateVariableError: Equatable {
    /// <p>The error code. </p>
    public let code: Int
    /// <p>The error message.</p>
    public let message: String?
    /// <p>The name.</p>
    public let name: String?

    public init (
        code: Int = 0,
        message: String? = nil,
        name: String? = nil
    )
    {
        self.code = code
        self.message = message
        self.name = name
    }
}

public struct BatchCreateVariableInputBodyMiddleware: Middleware {
    public let id: String = "BatchCreateVariableInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchCreateVariableInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchCreateVariableOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchCreateVariableInput>
    public typealias MOutput = OperationOutput<BatchCreateVariableOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchCreateVariableOutputError>
}

extension BatchCreateVariableInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchCreateVariableInput(tags: \(String(describing: tags)), variableEntries: \(String(describing: variableEntries)))"}
}

extension BatchCreateVariableInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case tags
        case variableEntries
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let variableEntries = variableEntries {
            var variableEntriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .variableEntries)
            for variableentrylist0 in variableEntries {
                try variableEntriesContainer.encode(variableentrylist0)
            }
        }
    }
}

public struct BatchCreateVariableInputHeadersMiddleware: Middleware {
    public let id: String = "BatchCreateVariableInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchCreateVariableInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchCreateVariableOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchCreateVariableInput>
    public typealias MOutput = OperationOutput<BatchCreateVariableOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchCreateVariableOutputError>
}

public struct BatchCreateVariableInputQueryItemMiddleware: Middleware {
    public let id: String = "BatchCreateVariableInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchCreateVariableInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchCreateVariableOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchCreateVariableInput>
    public typealias MOutput = OperationOutput<BatchCreateVariableOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchCreateVariableOutputError>
}

public struct BatchCreateVariableInput: Equatable {
    /// <p>A collection of key and value pairs.</p>
    public let tags: [Tag]?
    /// <p>The list of variables for the batch create variable request.</p>
    public let variableEntries: [VariableEntry]?

    public init (
        tags: [Tag]? = nil,
        variableEntries: [VariableEntry]? = nil
    )
    {
        self.tags = tags
        self.variableEntries = variableEntries
    }
}

struct BatchCreateVariableInputBody: Equatable {
    public let variableEntries: [VariableEntry]?
    public let tags: [Tag]?
}

extension BatchCreateVariableInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags
        case variableEntries
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let variableEntriesContainer = try containerValues.decodeIfPresent([VariableEntry?].self, forKey: .variableEntries)
        var variableEntriesDecoded0:[VariableEntry]? = nil
        if let variableEntriesContainer = variableEntriesContainer {
            variableEntriesDecoded0 = [VariableEntry]()
            for structure0 in variableEntriesContainer {
                if let structure0 = structure0 {
                    variableEntriesDecoded0?.append(structure0)
                }
            }
        }
        variableEntries = variableEntriesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension BatchCreateVariableOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchCreateVariableOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchCreateVariableOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchCreateVariableOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchCreateVariableOutputResponse(errors: \(String(describing: errors)))"}
}

extension BatchCreateVariableOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BatchCreateVariableOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.errors = output.errors
        } else {
            self.errors = nil
        }
    }
}

public struct BatchCreateVariableOutputResponse: Equatable {
    /// <p>Provides the errors for the <code>BatchCreateVariable</code> request.</p>
    public let errors: [BatchCreateVariableError]?

    public init (
        errors: [BatchCreateVariableError]? = nil
    )
    {
        self.errors = errors
    }
}

struct BatchCreateVariableOutputResponseBody: Equatable {
    public let errors: [BatchCreateVariableError]?
}

extension BatchCreateVariableOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case errors
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorsContainer = try containerValues.decodeIfPresent([BatchCreateVariableError?].self, forKey: .errors)
        var errorsDecoded0:[BatchCreateVariableError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [BatchCreateVariableError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

extension BatchGetVariableError: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case code
        case message
        case name
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if code != 0 {
            try encodeContainer.encode(code, forKey: .code)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let codeDecoded = try containerValues.decode(Int.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BatchGetVariableError: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchGetVariableError(code: \(String(describing: code)), message: \(String(describing: message)), name: \(String(describing: name)))"}
}

/// <p>Provides the error of the batch get variable API.</p>
public struct BatchGetVariableError: Equatable {
    /// <p>The error code. </p>
    public let code: Int
    /// <p>The error message.</p>
    public let message: String?
    /// <p>The error name. </p>
    public let name: String?

    public init (
        code: Int = 0,
        message: String? = nil,
        name: String? = nil
    )
    {
        self.code = code
        self.message = message
        self.name = name
    }
}

public struct BatchGetVariableInputBodyMiddleware: Middleware {
    public let id: String = "BatchGetVariableInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchGetVariableInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchGetVariableOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchGetVariableInput>
    public typealias MOutput = OperationOutput<BatchGetVariableOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchGetVariableOutputError>
}

extension BatchGetVariableInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchGetVariableInput(names: \(String(describing: names)))"}
}

extension BatchGetVariableInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case names
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let names = names {
            var namesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .names)
            for namelist0 in names {
                try namesContainer.encode(namelist0)
            }
        }
    }
}

public struct BatchGetVariableInputHeadersMiddleware: Middleware {
    public let id: String = "BatchGetVariableInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchGetVariableInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchGetVariableOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchGetVariableInput>
    public typealias MOutput = OperationOutput<BatchGetVariableOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchGetVariableOutputError>
}

public struct BatchGetVariableInputQueryItemMiddleware: Middleware {
    public let id: String = "BatchGetVariableInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchGetVariableInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchGetVariableOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchGetVariableInput>
    public typealias MOutput = OperationOutput<BatchGetVariableOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchGetVariableOutputError>
}

public struct BatchGetVariableInput: Equatable {
    /// <p>The list of variable names to get.</p>
    public let names: [String]?

    public init (
        names: [String]? = nil
    )
    {
        self.names = names
    }
}

struct BatchGetVariableInputBody: Equatable {
    public let names: [String]?
}

extension BatchGetVariableInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case names
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .names)
        var namesDecoded0:[String]? = nil
        if let namesContainer = namesContainer {
            namesDecoded0 = [String]()
            for string0 in namesContainer {
                if let string0 = string0 {
                    namesDecoded0?.append(string0)
                }
            }
        }
        names = namesDecoded0
    }
}

extension BatchGetVariableOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchGetVariableOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchGetVariableOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchGetVariableOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchGetVariableOutputResponse(errors: \(String(describing: errors)), variables: \(String(describing: variables)))"}
}

extension BatchGetVariableOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BatchGetVariableOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.errors = output.errors
            self.variables = output.variables
        } else {
            self.errors = nil
            self.variables = nil
        }
    }
}

public struct BatchGetVariableOutputResponse: Equatable {
    /// <p>The errors from the request.</p>
    public let errors: [BatchGetVariableError]?
    /// <p>The returned variables.</p>
    public let variables: [Variable]?

    public init (
        errors: [BatchGetVariableError]? = nil,
        variables: [Variable]? = nil
    )
    {
        self.errors = errors
        self.variables = variables
    }
}

struct BatchGetVariableOutputResponseBody: Equatable {
    public let variables: [Variable]?
    public let errors: [BatchGetVariableError]?
}

extension BatchGetVariableOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case errors
        case variables
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let variablesContainer = try containerValues.decodeIfPresent([Variable?].self, forKey: .variables)
        var variablesDecoded0:[Variable]? = nil
        if let variablesContainer = variablesContainer {
            variablesDecoded0 = [Variable]()
            for structure0 in variablesContainer {
                if let structure0 = structure0 {
                    variablesDecoded0?.append(structure0)
                }
            }
        }
        variables = variablesDecoded0
        let errorsContainer = try containerValues.decodeIfPresent([BatchGetVariableError?].self, forKey: .errors)
        var errorsDecoded0:[BatchGetVariableError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [BatchGetVariableError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

extension BatchPrediction: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case completionTime
        case detectorName
        case detectorVersion
        case eventTypeName
        case failureReason
        case iamRoleArn
        case inputPath
        case jobId
        case lastHeartbeatTime
        case outputPath
        case processedRecordsCount
        case startTime
        case status
        case totalRecordsCount
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let completionTime = completionTime {
            try encodeContainer.encode(completionTime, forKey: .completionTime)
        }
        if let detectorName = detectorName {
            try encodeContainer.encode(detectorName, forKey: .detectorName)
        }
        if let detectorVersion = detectorVersion {
            try encodeContainer.encode(detectorVersion, forKey: .detectorVersion)
        }
        if let eventTypeName = eventTypeName {
            try encodeContainer.encode(eventTypeName, forKey: .eventTypeName)
        }
        if let failureReason = failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let iamRoleArn = iamRoleArn {
            try encodeContainer.encode(iamRoleArn, forKey: .iamRoleArn)
        }
        if let inputPath = inputPath {
            try encodeContainer.encode(inputPath, forKey: .inputPath)
        }
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let lastHeartbeatTime = lastHeartbeatTime {
            try encodeContainer.encode(lastHeartbeatTime, forKey: .lastHeartbeatTime)
        }
        if let outputPath = outputPath {
            try encodeContainer.encode(outputPath, forKey: .outputPath)
        }
        if let processedRecordsCount = processedRecordsCount {
            try encodeContainer.encode(processedRecordsCount, forKey: .processedRecordsCount)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime, forKey: .startTime)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let totalRecordsCount = totalRecordsCount {
            try encodeContainer.encode(totalRecordsCount, forKey: .totalRecordsCount)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AsyncJobStatus.self, forKey: .status)
        status = statusDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .startTime)
        startTime = startTimeDecoded
        let completionTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .completionTime)
        completionTime = completionTimeDecoded
        let lastHeartbeatTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastHeartbeatTime)
        lastHeartbeatTime = lastHeartbeatTimeDecoded
        let inputPathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .inputPath)
        inputPath = inputPathDecoded
        let outputPathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .outputPath)
        outputPath = outputPathDecoded
        let eventTypeNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventTypeName)
        eventTypeName = eventTypeNameDecoded
        let detectorNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .detectorName)
        detectorName = detectorNameDecoded
        let detectorVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .detectorVersion)
        detectorVersion = detectorVersionDecoded
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let processedRecordsCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .processedRecordsCount)
        processedRecordsCount = processedRecordsCountDecoded
        let totalRecordsCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .totalRecordsCount)
        totalRecordsCount = totalRecordsCountDecoded
    }
}

extension BatchPrediction: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchPrediction(arn: \(String(describing: arn)), completionTime: \(String(describing: completionTime)), detectorName: \(String(describing: detectorName)), detectorVersion: \(String(describing: detectorVersion)), eventTypeName: \(String(describing: eventTypeName)), failureReason: \(String(describing: failureReason)), iamRoleArn: \(String(describing: iamRoleArn)), inputPath: \(String(describing: inputPath)), jobId: \(String(describing: jobId)), lastHeartbeatTime: \(String(describing: lastHeartbeatTime)), outputPath: \(String(describing: outputPath)), processedRecordsCount: \(String(describing: processedRecordsCount)), startTime: \(String(describing: startTime)), status: \(String(describing: status)), totalRecordsCount: \(String(describing: totalRecordsCount)))"}
}

/// <p>The batch prediction details.</p>
public struct BatchPrediction: Equatable {
    /// <p>The ARN of batch prediction job.</p>
    public let arn: String?
    /// <p>Timestamp of when the batch prediction job comleted.</p>
    public let completionTime: String?
    /// <p>The name of the detector.</p>
    public let detectorName: String?
    /// <p>The detector version. </p>
    public let detectorVersion: String?
    /// <p>The name of the event type.</p>
    public let eventTypeName: String?
    /// <p>The reason a batch prediction job failed.</p>
    public let failureReason: String?
    /// <p>The ARN of the IAM role to use for this job request.</p>
    public let iamRoleArn: String?
    /// <p>The Amazon S3 location of your training file.</p>
    public let inputPath: String?
    /// <p>The job ID for the batch prediction.</p>
    public let jobId: String?
    /// <p>Timestamp of most recent heartbeat indicating the batch prediction job was making progress.</p>
    public let lastHeartbeatTime: String?
    /// <p>The Amazon S3 location of your output file.</p>
    public let outputPath: String?
    /// <p>The number of records processed by the batch prediction job.</p>
    public let processedRecordsCount: Int?
    /// <p>Timestamp of when the batch prediction job started.</p>
    public let startTime: String?
    /// <p>The batch prediction status.</p>
    public let status: AsyncJobStatus?
    /// <p>The total number of records in the batch prediction job.</p>
    public let totalRecordsCount: Int?

    public init (
        arn: String? = nil,
        completionTime: String? = nil,
        detectorName: String? = nil,
        detectorVersion: String? = nil,
        eventTypeName: String? = nil,
        failureReason: String? = nil,
        iamRoleArn: String? = nil,
        inputPath: String? = nil,
        jobId: String? = nil,
        lastHeartbeatTime: String? = nil,
        outputPath: String? = nil,
        processedRecordsCount: Int? = nil,
        startTime: String? = nil,
        status: AsyncJobStatus? = nil,
        totalRecordsCount: Int? = nil
    )
    {
        self.arn = arn
        self.completionTime = completionTime
        self.detectorName = detectorName
        self.detectorVersion = detectorVersion
        self.eventTypeName = eventTypeName
        self.failureReason = failureReason
        self.iamRoleArn = iamRoleArn
        self.inputPath = inputPath
        self.jobId = jobId
        self.lastHeartbeatTime = lastHeartbeatTime
        self.outputPath = outputPath
        self.processedRecordsCount = processedRecordsCount
        self.startTime = startTime
        self.status = status
        self.totalRecordsCount = totalRecordsCount
    }
}

public struct CancelBatchPredictionJobInputBodyMiddleware: Middleware {
    public let id: String = "CancelBatchPredictionJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CancelBatchPredictionJobInput>,
                  next: H) -> Swift.Result<OperationOutput<CancelBatchPredictionJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CancelBatchPredictionJobInput>
    public typealias MOutput = OperationOutput<CancelBatchPredictionJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CancelBatchPredictionJobOutputError>
}

extension CancelBatchPredictionJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CancelBatchPredictionJobInput(jobId: \(String(describing: jobId)))"}
}

extension CancelBatchPredictionJobInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case jobId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
    }
}

public struct CancelBatchPredictionJobInputHeadersMiddleware: Middleware {
    public let id: String = "CancelBatchPredictionJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CancelBatchPredictionJobInput>,
                  next: H) -> Swift.Result<OperationOutput<CancelBatchPredictionJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CancelBatchPredictionJobInput>
    public typealias MOutput = OperationOutput<CancelBatchPredictionJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CancelBatchPredictionJobOutputError>
}

public struct CancelBatchPredictionJobInputQueryItemMiddleware: Middleware {
    public let id: String = "CancelBatchPredictionJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CancelBatchPredictionJobInput>,
                  next: H) -> Swift.Result<OperationOutput<CancelBatchPredictionJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CancelBatchPredictionJobInput>
    public typealias MOutput = OperationOutput<CancelBatchPredictionJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CancelBatchPredictionJobOutputError>
}

public struct CancelBatchPredictionJobInput: Equatable {
    /// <p>The ID of the batch prediction job to cancel.</p>
    public let jobId: String?

    public init (
        jobId: String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct CancelBatchPredictionJobInputBody: Equatable {
    public let jobId: String?
}

extension CancelBatchPredictionJobInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension CancelBatchPredictionJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CancelBatchPredictionJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CancelBatchPredictionJobOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CancelBatchPredictionJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CancelBatchPredictionJobOutputResponse()"}
}

extension CancelBatchPredictionJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct CancelBatchPredictionJobOutputResponse: Equatable {

    public init() {}
}

struct CancelBatchPredictionJobOutputResponseBody: Equatable {
}

extension CancelBatchPredictionJobOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ConflictException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConflictException(message: \(String(describing: message)))"}
}

extension ConflictException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An exception indicating there was a conflict during a delete operation. The following delete operations can cause a conflict exception:</p>
/// 	        <ul>
///             <li>
///                <p>DeleteDetector: A conflict exception will occur if the detector has associated <code>Rules</code> or <code>DetectorVersions</code>. You can only delete a detector if it has no <code>Rules</code> or <code>DetectorVersions</code>.</p>
///             </li>
///             <li>
///                <p>DeleteDetectorVersion: A conflict exception will occur if the <code>DetectorVersion</code> status is <code>ACTIVE</code>.</p>
///             </li>
///             <li>
///                <p>DeleteRule: A conflict exception will occur if the <code>RuleVersion</code> is in use by an associated <code>ACTIVE</code> or <code>INACTIVE DetectorVersion</code>.</p>
///             </li>
///          </ul>
public struct ConflictException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ConflictExceptionBody: Equatable {
    public let message: String?
}

extension ConflictExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct CreateBatchPredictionJobInputBodyMiddleware: Middleware {
    public let id: String = "CreateBatchPredictionJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateBatchPredictionJobInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateBatchPredictionJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateBatchPredictionJobInput>
    public typealias MOutput = OperationOutput<CreateBatchPredictionJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateBatchPredictionJobOutputError>
}

extension CreateBatchPredictionJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateBatchPredictionJobInput(detectorName: \(String(describing: detectorName)), detectorVersion: \(String(describing: detectorVersion)), eventTypeName: \(String(describing: eventTypeName)), iamRoleArn: \(String(describing: iamRoleArn)), inputPath: \(String(describing: inputPath)), jobId: \(String(describing: jobId)), outputPath: \(String(describing: outputPath)), tags: \(String(describing: tags)))"}
}

extension CreateBatchPredictionJobInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case detectorName
        case detectorVersion
        case eventTypeName
        case iamRoleArn
        case inputPath
        case jobId
        case outputPath
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let detectorName = detectorName {
            try encodeContainer.encode(detectorName, forKey: .detectorName)
        }
        if let detectorVersion = detectorVersion {
            try encodeContainer.encode(detectorVersion, forKey: .detectorVersion)
        }
        if let eventTypeName = eventTypeName {
            try encodeContainer.encode(eventTypeName, forKey: .eventTypeName)
        }
        if let iamRoleArn = iamRoleArn {
            try encodeContainer.encode(iamRoleArn, forKey: .iamRoleArn)
        }
        if let inputPath = inputPath {
            try encodeContainer.encode(inputPath, forKey: .inputPath)
        }
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let outputPath = outputPath {
            try encodeContainer.encode(outputPath, forKey: .outputPath)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateBatchPredictionJobInputHeadersMiddleware: Middleware {
    public let id: String = "CreateBatchPredictionJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateBatchPredictionJobInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateBatchPredictionJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateBatchPredictionJobInput>
    public typealias MOutput = OperationOutput<CreateBatchPredictionJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateBatchPredictionJobOutputError>
}

public struct CreateBatchPredictionJobInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateBatchPredictionJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateBatchPredictionJobInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateBatchPredictionJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateBatchPredictionJobInput>
    public typealias MOutput = OperationOutput<CreateBatchPredictionJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateBatchPredictionJobOutputError>
}

public struct CreateBatchPredictionJobInput: Equatable {
    /// <p>The name of the detector.</p>
    public let detectorName: String?
    /// <p>The detector version.</p>
    public let detectorVersion: String?
    /// <p>The name of the event type.</p>
    public let eventTypeName: String?
    /// <p>The ARN of the IAM role to use for this job request.</p>
    public let iamRoleArn: String?
    /// <p>The Amazon S3 location of your training file.</p>
    public let inputPath: String?
    /// <p>The ID of the batch prediction job.</p>
    public let jobId: String?
    /// <p>The Amazon S3 location of your output file.</p>
    public let outputPath: String?
    /// <p>A collection of key and value pairs.</p>
    public let tags: [Tag]?

    public init (
        detectorName: String? = nil,
        detectorVersion: String? = nil,
        eventTypeName: String? = nil,
        iamRoleArn: String? = nil,
        inputPath: String? = nil,
        jobId: String? = nil,
        outputPath: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.detectorName = detectorName
        self.detectorVersion = detectorVersion
        self.eventTypeName = eventTypeName
        self.iamRoleArn = iamRoleArn
        self.inputPath = inputPath
        self.jobId = jobId
        self.outputPath = outputPath
        self.tags = tags
    }
}

struct CreateBatchPredictionJobInputBody: Equatable {
    public let jobId: String?
    public let inputPath: String?
    public let outputPath: String?
    public let eventTypeName: String?
    public let detectorName: String?
    public let detectorVersion: String?
    public let iamRoleArn: String?
    public let tags: [Tag]?
}

extension CreateBatchPredictionJobInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case detectorName
        case detectorVersion
        case eventTypeName
        case iamRoleArn
        case inputPath
        case jobId
        case outputPath
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let inputPathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .inputPath)
        inputPath = inputPathDecoded
        let outputPathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .outputPath)
        outputPath = outputPathDecoded
        let eventTypeNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventTypeName)
        eventTypeName = eventTypeNameDecoded
        let detectorNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .detectorName)
        detectorName = detectorNameDecoded
        let detectorVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .detectorVersion)
        detectorVersion = detectorVersionDecoded
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateBatchPredictionJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateBatchPredictionJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateBatchPredictionJobOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateBatchPredictionJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateBatchPredictionJobOutputResponse()"}
}

extension CreateBatchPredictionJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct CreateBatchPredictionJobOutputResponse: Equatable {

    public init() {}
}

struct CreateBatchPredictionJobOutputResponseBody: Equatable {
}

extension CreateBatchPredictionJobOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct CreateDetectorVersionInputBodyMiddleware: Middleware {
    public let id: String = "CreateDetectorVersionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDetectorVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDetectorVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDetectorVersionInput>
    public typealias MOutput = OperationOutput<CreateDetectorVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDetectorVersionOutputError>
}

extension CreateDetectorVersionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDetectorVersionInput(description: \(String(describing: description)), detectorId: \(String(describing: detectorId)), externalModelEndpoints: \(String(describing: externalModelEndpoints)), modelVersions: \(String(describing: modelVersions)), ruleExecutionMode: \(String(describing: ruleExecutionMode)), rules: \(String(describing: rules)), tags: \(String(describing: tags)))"}
}

extension CreateDetectorVersionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description
        case detectorId
        case externalModelEndpoints
        case modelVersions
        case ruleExecutionMode
        case rules
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let detectorId = detectorId {
            try encodeContainer.encode(detectorId, forKey: .detectorId)
        }
        if let externalModelEndpoints = externalModelEndpoints {
            var externalModelEndpointsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .externalModelEndpoints)
            for listofstrings0 in externalModelEndpoints {
                try externalModelEndpointsContainer.encode(listofstrings0)
            }
        }
        if let modelVersions = modelVersions {
            var modelVersionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .modelVersions)
            for listofmodelversions0 in modelVersions {
                try modelVersionsContainer.encode(listofmodelversions0)
            }
        }
        if let ruleExecutionMode = ruleExecutionMode {
            try encodeContainer.encode(ruleExecutionMode.rawValue, forKey: .ruleExecutionMode)
        }
        if let rules = rules {
            var rulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rules)
            for rulelist0 in rules {
                try rulesContainer.encode(rulelist0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateDetectorVersionInputHeadersMiddleware: Middleware {
    public let id: String = "CreateDetectorVersionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDetectorVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDetectorVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDetectorVersionInput>
    public typealias MOutput = OperationOutput<CreateDetectorVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDetectorVersionOutputError>
}

public struct CreateDetectorVersionInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateDetectorVersionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDetectorVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDetectorVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDetectorVersionInput>
    public typealias MOutput = OperationOutput<CreateDetectorVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDetectorVersionOutputError>
}

public struct CreateDetectorVersionInput: Equatable {
    /// <p>The description of the detector version.</p>
    public let description: String?
    /// <p>The ID of the detector under which you want to create a new version.</p>
    public let detectorId: String?
    /// <p>The Amazon Sagemaker model endpoints to include in the detector version.</p>
    public let externalModelEndpoints: [String]?
    /// <p>The model versions to include in the detector version.</p>
    public let modelVersions: [ModelVersion]?
    /// <p>The rule execution mode for the rules included in the detector version.</p>
    /// 	        <p>You can define and edit the rule mode at the detector version level, when it is in draft status.</p>
    /// 	        <p>If you specify <code>FIRST_MATCHED</code>, Amazon Fraud Detector evaluates rules sequentially, first to last, stopping at the first matched rule. Amazon Fraud dectector then provides the outcomes for that single rule.</p>
    /// 	        <p>If you specifiy <code>ALL_MATCHED</code>, Amazon Fraud Detector evaluates all rules and returns the outcomes for all matched rules. </p>
    ///          <p>The default behavior is <code>FIRST_MATCHED</code>.</p>
    public let ruleExecutionMode: RuleExecutionMode?
    /// <p>The rules to include in the detector version.</p>
    public let rules: [Rule]?
    /// <p>A collection of key and value pairs.</p>
    public let tags: [Tag]?

    public init (
        description: String? = nil,
        detectorId: String? = nil,
        externalModelEndpoints: [String]? = nil,
        modelVersions: [ModelVersion]? = nil,
        ruleExecutionMode: RuleExecutionMode? = nil,
        rules: [Rule]? = nil,
        tags: [Tag]? = nil
    )
    {
        self.description = description
        self.detectorId = detectorId
        self.externalModelEndpoints = externalModelEndpoints
        self.modelVersions = modelVersions
        self.ruleExecutionMode = ruleExecutionMode
        self.rules = rules
        self.tags = tags
    }
}

struct CreateDetectorVersionInputBody: Equatable {
    public let detectorId: String?
    public let description: String?
    public let externalModelEndpoints: [String]?
    public let rules: [Rule]?
    public let modelVersions: [ModelVersion]?
    public let ruleExecutionMode: RuleExecutionMode?
    public let tags: [Tag]?
}

extension CreateDetectorVersionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description
        case detectorId
        case externalModelEndpoints
        case modelVersions
        case ruleExecutionMode
        case rules
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detectorIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .detectorId)
        detectorId = detectorIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let externalModelEndpointsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .externalModelEndpoints)
        var externalModelEndpointsDecoded0:[String]? = nil
        if let externalModelEndpointsContainer = externalModelEndpointsContainer {
            externalModelEndpointsDecoded0 = [String]()
            for string0 in externalModelEndpointsContainer {
                if let string0 = string0 {
                    externalModelEndpointsDecoded0?.append(string0)
                }
            }
        }
        externalModelEndpoints = externalModelEndpointsDecoded0
        let rulesContainer = try containerValues.decodeIfPresent([Rule?].self, forKey: .rules)
        var rulesDecoded0:[Rule]? = nil
        if let rulesContainer = rulesContainer {
            rulesDecoded0 = [Rule]()
            for structure0 in rulesContainer {
                if let structure0 = structure0 {
                    rulesDecoded0?.append(structure0)
                }
            }
        }
        rules = rulesDecoded0
        let modelVersionsContainer = try containerValues.decodeIfPresent([ModelVersion?].self, forKey: .modelVersions)
        var modelVersionsDecoded0:[ModelVersion]? = nil
        if let modelVersionsContainer = modelVersionsContainer {
            modelVersionsDecoded0 = [ModelVersion]()
            for structure0 in modelVersionsContainer {
                if let structure0 = structure0 {
                    modelVersionsDecoded0?.append(structure0)
                }
            }
        }
        modelVersions = modelVersionsDecoded0
        let ruleExecutionModeDecoded = try containerValues.decodeIfPresent(RuleExecutionMode.self, forKey: .ruleExecutionMode)
        ruleExecutionMode = ruleExecutionModeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateDetectorVersionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDetectorVersionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDetectorVersionOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDetectorVersionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDetectorVersionOutputResponse(detectorId: \(String(describing: detectorId)), detectorVersionId: \(String(describing: detectorVersionId)), status: \(String(describing: status)))"}
}

extension CreateDetectorVersionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateDetectorVersionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.detectorId = output.detectorId
            self.detectorVersionId = output.detectorVersionId
            self.status = output.status
        } else {
            self.detectorId = nil
            self.detectorVersionId = nil
            self.status = nil
        }
    }
}

public struct CreateDetectorVersionOutputResponse: Equatable {
    /// <p>The ID for the created version's parent detector.</p>
    public let detectorId: String?
    /// <p>The ID for the created detector. </p>
    public let detectorVersionId: String?
    /// <p>The status of the detector version.</p>
    public let status: DetectorVersionStatus?

    public init (
        detectorId: String? = nil,
        detectorVersionId: String? = nil,
        status: DetectorVersionStatus? = nil
    )
    {
        self.detectorId = detectorId
        self.detectorVersionId = detectorVersionId
        self.status = status
    }
}

struct CreateDetectorVersionOutputResponseBody: Equatable {
    public let detectorId: String?
    public let detectorVersionId: String?
    public let status: DetectorVersionStatus?
}

extension CreateDetectorVersionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case detectorId
        case detectorVersionId
        case status
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detectorIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .detectorId)
        detectorId = detectorIdDecoded
        let detectorVersionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .detectorVersionId)
        detectorVersionId = detectorVersionIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DetectorVersionStatus.self, forKey: .status)
        status = statusDecoded
    }
}

public struct CreateModelInputBodyMiddleware: Middleware {
    public let id: String = "CreateModelInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateModelInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateModelInput>
    public typealias MOutput = OperationOutput<CreateModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateModelOutputError>
}

extension CreateModelInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateModelInput(description: \(String(describing: description)), eventTypeName: \(String(describing: eventTypeName)), modelId: \(String(describing: modelId)), modelType: \(String(describing: modelType)), tags: \(String(describing: tags)))"}
}

extension CreateModelInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description
        case eventTypeName
        case modelId
        case modelType
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let eventTypeName = eventTypeName {
            try encodeContainer.encode(eventTypeName, forKey: .eventTypeName)
        }
        if let modelId = modelId {
            try encodeContainer.encode(modelId, forKey: .modelId)
        }
        if let modelType = modelType {
            try encodeContainer.encode(modelType.rawValue, forKey: .modelType)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateModelInputHeadersMiddleware: Middleware {
    public let id: String = "CreateModelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateModelInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateModelInput>
    public typealias MOutput = OperationOutput<CreateModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateModelOutputError>
}

public struct CreateModelInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateModelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateModelInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateModelInput>
    public typealias MOutput = OperationOutput<CreateModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateModelOutputError>
}

public struct CreateModelInput: Equatable {
    /// <p>The model description. </p>
    public let description: String?
    /// <p>The name of the event type.</p>
    public let eventTypeName: String?
    /// <p>The model ID.</p>
    public let modelId: String?
    /// <p>The model type. </p>
    public let modelType: ModelTypeEnum?
    /// <p>A collection of key and value pairs.</p>
    public let tags: [Tag]?

    public init (
        description: String? = nil,
        eventTypeName: String? = nil,
        modelId: String? = nil,
        modelType: ModelTypeEnum? = nil,
        tags: [Tag]? = nil
    )
    {
        self.description = description
        self.eventTypeName = eventTypeName
        self.modelId = modelId
        self.modelType = modelType
        self.tags = tags
    }
}

struct CreateModelInputBody: Equatable {
    public let modelId: String?
    public let modelType: ModelTypeEnum?
    public let description: String?
    public let eventTypeName: String?
    public let tags: [Tag]?
}

extension CreateModelInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description
        case eventTypeName
        case modelId
        case modelType
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .modelId)
        modelId = modelIdDecoded
        let modelTypeDecoded = try containerValues.decodeIfPresent(ModelTypeEnum.self, forKey: .modelType)
        modelType = modelTypeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let eventTypeNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventTypeName)
        eventTypeName = eventTypeNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateModelOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateModelOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateModelOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateModelOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateModelOutputResponse()"}
}

extension CreateModelOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct CreateModelOutputResponse: Equatable {

    public init() {}
}

struct CreateModelOutputResponseBody: Equatable {
}

extension CreateModelOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct CreateModelVersionInputBodyMiddleware: Middleware {
    public let id: String = "CreateModelVersionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateModelVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateModelVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateModelVersionInput>
    public typealias MOutput = OperationOutput<CreateModelVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateModelVersionOutputError>
}

extension CreateModelVersionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateModelVersionInput(externalEventsDetail: \(String(describing: externalEventsDetail)), modelId: \(String(describing: modelId)), modelType: \(String(describing: modelType)), tags: \(String(describing: tags)), trainingDataSchema: \(String(describing: trainingDataSchema)), trainingDataSource: \(String(describing: trainingDataSource)))"}
}

extension CreateModelVersionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case externalEventsDetail
        case modelId
        case modelType
        case tags
        case trainingDataSchema
        case trainingDataSource
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let externalEventsDetail = externalEventsDetail {
            try encodeContainer.encode(externalEventsDetail, forKey: .externalEventsDetail)
        }
        if let modelId = modelId {
            try encodeContainer.encode(modelId, forKey: .modelId)
        }
        if let modelType = modelType {
            try encodeContainer.encode(modelType.rawValue, forKey: .modelType)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let trainingDataSchema = trainingDataSchema {
            try encodeContainer.encode(trainingDataSchema, forKey: .trainingDataSchema)
        }
        if let trainingDataSource = trainingDataSource {
            try encodeContainer.encode(trainingDataSource.rawValue, forKey: .trainingDataSource)
        }
    }
}

public struct CreateModelVersionInputHeadersMiddleware: Middleware {
    public let id: String = "CreateModelVersionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateModelVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateModelVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateModelVersionInput>
    public typealias MOutput = OperationOutput<CreateModelVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateModelVersionOutputError>
}

public struct CreateModelVersionInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateModelVersionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateModelVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateModelVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateModelVersionInput>
    public typealias MOutput = OperationOutput<CreateModelVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateModelVersionOutputError>
}

public struct CreateModelVersionInput: Equatable {
    /// <p>Details for the external events data used for model version training. Required if <code>trainingDataSource</code> is <code>EXTERNAL_EVENTS</code>.</p>
    public let externalEventsDetail: ExternalEventsDetail?
    /// <p>The model ID. </p>
    public let modelId: String?
    /// <p>The model type.</p>
    public let modelType: ModelTypeEnum?
    /// <p>A collection of key and value pairs.</p>
    public let tags: [Tag]?
    /// <p>The training data schema.</p>
    public let trainingDataSchema: TrainingDataSchema?
    /// <p>The training data source location in Amazon S3. </p>
    public let trainingDataSource: TrainingDataSourceEnum?

    public init (
        externalEventsDetail: ExternalEventsDetail? = nil,
        modelId: String? = nil,
        modelType: ModelTypeEnum? = nil,
        tags: [Tag]? = nil,
        trainingDataSchema: TrainingDataSchema? = nil,
        trainingDataSource: TrainingDataSourceEnum? = nil
    )
    {
        self.externalEventsDetail = externalEventsDetail
        self.modelId = modelId
        self.modelType = modelType
        self.tags = tags
        self.trainingDataSchema = trainingDataSchema
        self.trainingDataSource = trainingDataSource
    }
}

struct CreateModelVersionInputBody: Equatable {
    public let modelId: String?
    public let modelType: ModelTypeEnum?
    public let trainingDataSource: TrainingDataSourceEnum?
    public let trainingDataSchema: TrainingDataSchema?
    public let externalEventsDetail: ExternalEventsDetail?
    public let tags: [Tag]?
}

extension CreateModelVersionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case externalEventsDetail
        case modelId
        case modelType
        case tags
        case trainingDataSchema
        case trainingDataSource
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .modelId)
        modelId = modelIdDecoded
        let modelTypeDecoded = try containerValues.decodeIfPresent(ModelTypeEnum.self, forKey: .modelType)
        modelType = modelTypeDecoded
        let trainingDataSourceDecoded = try containerValues.decodeIfPresent(TrainingDataSourceEnum.self, forKey: .trainingDataSource)
        trainingDataSource = trainingDataSourceDecoded
        let trainingDataSchemaDecoded = try containerValues.decodeIfPresent(TrainingDataSchema.self, forKey: .trainingDataSchema)
        trainingDataSchema = trainingDataSchemaDecoded
        let externalEventsDetailDecoded = try containerValues.decodeIfPresent(ExternalEventsDetail.self, forKey: .externalEventsDetail)
        externalEventsDetail = externalEventsDetailDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateModelVersionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateModelVersionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateModelVersionOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateModelVersionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateModelVersionOutputResponse(modelId: \(String(describing: modelId)), modelType: \(String(describing: modelType)), modelVersionNumber: \(String(describing: modelVersionNumber)), status: \(String(describing: status)))"}
}

extension CreateModelVersionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateModelVersionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.modelId = output.modelId
            self.modelType = output.modelType
            self.modelVersionNumber = output.modelVersionNumber
            self.status = output.status
        } else {
            self.modelId = nil
            self.modelType = nil
            self.modelVersionNumber = nil
            self.status = nil
        }
    }
}

public struct CreateModelVersionOutputResponse: Equatable {
    /// <p>The model ID.</p>
    public let modelId: String?
    /// <p>The model type.</p>
    public let modelType: ModelTypeEnum?
    /// <p>The model version number of the model version created.</p>
    public let modelVersionNumber: String?
    /// <p>The model version status. </p>
    public let status: String?

    public init (
        modelId: String? = nil,
        modelType: ModelTypeEnum? = nil,
        modelVersionNumber: String? = nil,
        status: String? = nil
    )
    {
        self.modelId = modelId
        self.modelType = modelType
        self.modelVersionNumber = modelVersionNumber
        self.status = status
    }
}

struct CreateModelVersionOutputResponseBody: Equatable {
    public let modelId: String?
    public let modelType: ModelTypeEnum?
    public let modelVersionNumber: String?
    public let status: String?
}

extension CreateModelVersionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case modelId
        case modelType
        case modelVersionNumber
        case status
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .modelId)
        modelId = modelIdDecoded
        let modelTypeDecoded = try containerValues.decodeIfPresent(ModelTypeEnum.self, forKey: .modelType)
        modelType = modelTypeDecoded
        let modelVersionNumberDecoded = try containerValues.decodeIfPresent(String.self, forKey: .modelVersionNumber)
        modelVersionNumber = modelVersionNumberDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
    }
}

public struct CreateRuleInputBodyMiddleware: Middleware {
    public let id: String = "CreateRuleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateRuleInput>
    public typealias MOutput = OperationOutput<CreateRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateRuleOutputError>
}

extension CreateRuleInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateRuleInput(description: \(String(describing: description)), detectorId: \(String(describing: detectorId)), expression: \(String(describing: expression)), language: \(String(describing: language)), outcomes: \(String(describing: outcomes)), ruleId: \(String(describing: ruleId)), tags: \(String(describing: tags)))"}
}

extension CreateRuleInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description
        case detectorId
        case expression
        case language
        case outcomes
        case ruleId
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let detectorId = detectorId {
            try encodeContainer.encode(detectorId, forKey: .detectorId)
        }
        if let expression = expression {
            try encodeContainer.encode(expression, forKey: .expression)
        }
        if let language = language {
            try encodeContainer.encode(language.rawValue, forKey: .language)
        }
        if let outcomes = outcomes {
            var outcomesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .outcomes)
            for nonemptylistofstrings0 in outcomes {
                try outcomesContainer.encode(nonemptylistofstrings0)
            }
        }
        if let ruleId = ruleId {
            try encodeContainer.encode(ruleId, forKey: .ruleId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateRuleInputHeadersMiddleware: Middleware {
    public let id: String = "CreateRuleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateRuleInput>
    public typealias MOutput = OperationOutput<CreateRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateRuleOutputError>
}

public struct CreateRuleInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateRuleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateRuleInput>
    public typealias MOutput = OperationOutput<CreateRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateRuleOutputError>
}

public struct CreateRuleInput: Equatable {
    /// <p>The rule description.</p>
    public let description: String?
    /// <p>The detector ID for the rule's parent detector.</p>
    public let detectorId: String?
    /// <p>The rule expression.</p>
    public let expression: String?
    /// <p>The language of the rule.</p>
    public let language: Language?
    /// <p>The outcome or outcomes returned when the rule expression matches.</p>
    public let outcomes: [String]?
    /// <p>The rule ID.</p>
    public let ruleId: String?
    /// <p>A collection of key and value pairs.</p>
    public let tags: [Tag]?

    public init (
        description: String? = nil,
        detectorId: String? = nil,
        expression: String? = nil,
        language: Language? = nil,
        outcomes: [String]? = nil,
        ruleId: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.description = description
        self.detectorId = detectorId
        self.expression = expression
        self.language = language
        self.outcomes = outcomes
        self.ruleId = ruleId
        self.tags = tags
    }
}

struct CreateRuleInputBody: Equatable {
    public let ruleId: String?
    public let detectorId: String?
    public let description: String?
    public let expression: String?
    public let language: Language?
    public let outcomes: [String]?
    public let tags: [Tag]?
}

extension CreateRuleInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description
        case detectorId
        case expression
        case language
        case outcomes
        case ruleId
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ruleId)
        ruleId = ruleIdDecoded
        let detectorIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .detectorId)
        detectorId = detectorIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let expressionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .expression)
        expression = expressionDecoded
        let languageDecoded = try containerValues.decodeIfPresent(Language.self, forKey: .language)
        language = languageDecoded
        let outcomesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .outcomes)
        var outcomesDecoded0:[String]? = nil
        if let outcomesContainer = outcomesContainer {
            outcomesDecoded0 = [String]()
            for string0 in outcomesContainer {
                if let string0 = string0 {
                    outcomesDecoded0?.append(string0)
                }
            }
        }
        outcomes = outcomesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateRuleOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateRuleOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateRuleOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateRuleOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateRuleOutputResponse(rule: \(String(describing: rule)))"}
}

extension CreateRuleOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateRuleOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.rule = output.rule
        } else {
            self.rule = nil
        }
    }
}

public struct CreateRuleOutputResponse: Equatable {
    /// <p>The created rule.</p>
    public let rule: Rule?

    public init (
        rule: Rule? = nil
    )
    {
        self.rule = rule
    }
}

struct CreateRuleOutputResponseBody: Equatable {
    public let rule: Rule?
}

extension CreateRuleOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case rule
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleDecoded = try containerValues.decodeIfPresent(Rule.self, forKey: .rule)
        rule = ruleDecoded
    }
}

public struct CreateVariableInputBodyMiddleware: Middleware {
    public let id: String = "CreateVariableInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateVariableInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateVariableOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateVariableInput>
    public typealias MOutput = OperationOutput<CreateVariableOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateVariableOutputError>
}

extension CreateVariableInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateVariableInput(dataSource: \(String(describing: dataSource)), dataType: \(String(describing: dataType)), defaultValue: \(String(describing: defaultValue)), description: \(String(describing: description)), name: \(String(describing: name)), tags: \(String(describing: tags)), variableType: \(String(describing: variableType)))"}
}

extension CreateVariableInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dataSource
        case dataType
        case defaultValue
        case description
        case name
        case tags
        case variableType
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSource = dataSource {
            try encodeContainer.encode(dataSource.rawValue, forKey: .dataSource)
        }
        if let dataType = dataType {
            try encodeContainer.encode(dataType.rawValue, forKey: .dataType)
        }
        if let defaultValue = defaultValue {
            try encodeContainer.encode(defaultValue, forKey: .defaultValue)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let variableType = variableType {
            try encodeContainer.encode(variableType, forKey: .variableType)
        }
    }
}

public struct CreateVariableInputHeadersMiddleware: Middleware {
    public let id: String = "CreateVariableInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateVariableInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateVariableOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateVariableInput>
    public typealias MOutput = OperationOutput<CreateVariableOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateVariableOutputError>
}

public struct CreateVariableInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateVariableInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateVariableInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateVariableOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateVariableInput>
    public typealias MOutput = OperationOutput<CreateVariableOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateVariableOutputError>
}

public struct CreateVariableInput: Equatable {
    /// <p>The source of the data.</p>
    public let dataSource: DataSource?
    /// <p>The data type.</p>
    public let dataType: DataType?
    /// <p>The default value for the variable when no value is received.</p>
    public let defaultValue: String?
    /// <p>The description.</p>
    public let description: String?
    /// <p>The name of the variable.</p>
    public let name: String?
    /// <p>A collection of key and value pairs.</p>
    public let tags: [Tag]?
    /// <p>The variable type. For more information see <a href="https://docs.aws.amazon.com/frauddetector/latest/ug/create-a-variable.html#variable-types">Variable types</a>.
    /// 				</p>
    ///          <p>Valid Values: <code>AUTH_CODE | AVS | BILLING_ADDRESS_L1 | BILLING_ADDRESS_L2 | BILLING_CITY | BILLING_COUNTRY | BILLING_NAME | BILLING_PHONE | BILLING_STATE | BILLING_ZIP | CARD_BIN | CATEGORICAL | CURRENCY_CODE | EMAIL_ADDRESS | FINGERPRINT | FRAUD_LABEL | FREE_FORM_TEXT | IP_ADDRESS | NUMERIC | ORDER_ID | PAYMENT_TYPE | PHONE_NUMBER | PRICE | PRODUCT_CATEGORY | SHIPPING_ADDRESS_L1 | SHIPPING_ADDRESS_L2 | SHIPPING_CITY | SHIPPING_COUNTRY | SHIPPING_NAME | SHIPPING_PHONE | SHIPPING_STATE | SHIPPING_ZIP | USERAGENT</code>
    ///          </p>
    public let variableType: String?

    public init (
        dataSource: DataSource? = nil,
        dataType: DataType? = nil,
        defaultValue: String? = nil,
        description: String? = nil,
        name: String? = nil,
        tags: [Tag]? = nil,
        variableType: String? = nil
    )
    {
        self.dataSource = dataSource
        self.dataType = dataType
        self.defaultValue = defaultValue
        self.description = description
        self.name = name
        self.tags = tags
        self.variableType = variableType
    }
}

struct CreateVariableInputBody: Equatable {
    public let name: String?
    public let dataType: DataType?
    public let dataSource: DataSource?
    public let defaultValue: String?
    public let description: String?
    public let variableType: String?
    public let tags: [Tag]?
}

extension CreateVariableInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dataSource
        case dataType
        case defaultValue
        case description
        case name
        case tags
        case variableType
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let dataTypeDecoded = try containerValues.decodeIfPresent(DataType.self, forKey: .dataType)
        dataType = dataTypeDecoded
        let dataSourceDecoded = try containerValues.decodeIfPresent(DataSource.self, forKey: .dataSource)
        dataSource = dataSourceDecoded
        let defaultValueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let variableTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .variableType)
        variableType = variableTypeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateVariableOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateVariableOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateVariableOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateVariableOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateVariableOutputResponse()"}
}

extension CreateVariableOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct CreateVariableOutputResponse: Equatable {

    public init() {}
}

struct CreateVariableOutputResponseBody: Equatable {
}

extension CreateVariableOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public enum DataSource {
    case event
    case externalModelScore
    case modelScore
    case sdkUnknown(String)
}

extension DataSource : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DataSource] {
        return [
            .event,
            .externalModelScore,
            .modelScore,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .event: return "EVENT"
        case .externalModelScore: return "EXTERNAL_MODEL_SCORE"
        case .modelScore: return "MODEL_SCORE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DataSource(rawValue: rawValue) ?? DataSource.sdkUnknown(rawValue)
    }
}

public enum DataType {
    case boolean
    case float
    case integer
    case string
    case sdkUnknown(String)
}

extension DataType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DataType] {
        return [
            .boolean,
            .float,
            .integer,
            .string,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .boolean: return "BOOLEAN"
        case .float: return "FLOAT"
        case .integer: return "INTEGER"
        case .string: return "STRING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DataType(rawValue: rawValue) ?? DataType.sdkUnknown(rawValue)
    }
}

extension DataValidationMetrics: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case fieldLevelMessages
        case fileLevelMessages
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fieldLevelMessages = fieldLevelMessages {
            var fieldLevelMessagesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .fieldLevelMessages)
            for fieldvalidationmessagelist0 in fieldLevelMessages {
                try fieldLevelMessagesContainer.encode(fieldvalidationmessagelist0)
            }
        }
        if let fileLevelMessages = fileLevelMessages {
            var fileLevelMessagesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .fileLevelMessages)
            for filevalidationmessagelist0 in fileLevelMessages {
                try fileLevelMessagesContainer.encode(filevalidationmessagelist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileLevelMessagesContainer = try containerValues.decodeIfPresent([FileValidationMessage?].self, forKey: .fileLevelMessages)
        var fileLevelMessagesDecoded0:[FileValidationMessage]? = nil
        if let fileLevelMessagesContainer = fileLevelMessagesContainer {
            fileLevelMessagesDecoded0 = [FileValidationMessage]()
            for structure0 in fileLevelMessagesContainer {
                if let structure0 = structure0 {
                    fileLevelMessagesDecoded0?.append(structure0)
                }
            }
        }
        fileLevelMessages = fileLevelMessagesDecoded0
        let fieldLevelMessagesContainer = try containerValues.decodeIfPresent([FieldValidationMessage?].self, forKey: .fieldLevelMessages)
        var fieldLevelMessagesDecoded0:[FieldValidationMessage]? = nil
        if let fieldLevelMessagesContainer = fieldLevelMessagesContainer {
            fieldLevelMessagesDecoded0 = [FieldValidationMessage]()
            for structure0 in fieldLevelMessagesContainer {
                if let structure0 = structure0 {
                    fieldLevelMessagesDecoded0?.append(structure0)
                }
            }
        }
        fieldLevelMessages = fieldLevelMessagesDecoded0
    }
}

extension DataValidationMetrics: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DataValidationMetrics(fieldLevelMessages: \(String(describing: fieldLevelMessages)), fileLevelMessages: \(String(describing: fileLevelMessages)))"}
}

/// <p>The model training validation messages.</p>
public struct DataValidationMetrics: Equatable {
    /// <p>The field-specific model training validation messages.</p>
    public let fieldLevelMessages: [FieldValidationMessage]?
    /// <p>The file-specific model training validation messages.</p>
    public let fileLevelMessages: [FileValidationMessage]?

    public init (
        fieldLevelMessages: [FieldValidationMessage]? = nil,
        fileLevelMessages: [FileValidationMessage]? = nil
    )
    {
        self.fieldLevelMessages = fieldLevelMessages
        self.fileLevelMessages = fileLevelMessages
    }
}

public struct DeleteBatchPredictionJobInputBodyMiddleware: Middleware {
    public let id: String = "DeleteBatchPredictionJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteBatchPredictionJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteBatchPredictionJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteBatchPredictionJobInput>
    public typealias MOutput = OperationOutput<DeleteBatchPredictionJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteBatchPredictionJobOutputError>
}

extension DeleteBatchPredictionJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteBatchPredictionJobInput(jobId: \(String(describing: jobId)))"}
}

extension DeleteBatchPredictionJobInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case jobId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
    }
}

public struct DeleteBatchPredictionJobInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteBatchPredictionJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteBatchPredictionJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteBatchPredictionJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteBatchPredictionJobInput>
    public typealias MOutput = OperationOutput<DeleteBatchPredictionJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteBatchPredictionJobOutputError>
}

public struct DeleteBatchPredictionJobInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteBatchPredictionJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteBatchPredictionJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteBatchPredictionJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteBatchPredictionJobInput>
    public typealias MOutput = OperationOutput<DeleteBatchPredictionJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteBatchPredictionJobOutputError>
}

public struct DeleteBatchPredictionJobInput: Equatable {
    /// <p>The ID of the batch prediction job to delete.</p>
    public let jobId: String?

    public init (
        jobId: String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct DeleteBatchPredictionJobInputBody: Equatable {
    public let jobId: String?
}

extension DeleteBatchPredictionJobInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension DeleteBatchPredictionJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteBatchPredictionJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteBatchPredictionJobOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteBatchPredictionJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteBatchPredictionJobOutputResponse()"}
}

extension DeleteBatchPredictionJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteBatchPredictionJobOutputResponse: Equatable {

    public init() {}
}

struct DeleteBatchPredictionJobOutputResponseBody: Equatable {
}

extension DeleteBatchPredictionJobOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteDetectorInputBodyMiddleware: Middleware {
    public let id: String = "DeleteDetectorInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDetectorInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDetectorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDetectorInput>
    public typealias MOutput = OperationOutput<DeleteDetectorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDetectorOutputError>
}

extension DeleteDetectorInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDetectorInput(detectorId: \(String(describing: detectorId)))"}
}

extension DeleteDetectorInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case detectorId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let detectorId = detectorId {
            try encodeContainer.encode(detectorId, forKey: .detectorId)
        }
    }
}

public struct DeleteDetectorInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteDetectorInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDetectorInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDetectorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDetectorInput>
    public typealias MOutput = OperationOutput<DeleteDetectorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDetectorOutputError>
}

public struct DeleteDetectorInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteDetectorInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDetectorInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDetectorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDetectorInput>
    public typealias MOutput = OperationOutput<DeleteDetectorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDetectorOutputError>
}

public struct DeleteDetectorInput: Equatable {
    /// <p>The ID of the detector to delete.</p>
    public let detectorId: String?

    public init (
        detectorId: String? = nil
    )
    {
        self.detectorId = detectorId
    }
}

struct DeleteDetectorInputBody: Equatable {
    public let detectorId: String?
}

extension DeleteDetectorInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case detectorId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detectorIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .detectorId)
        detectorId = detectorIdDecoded
    }
}

extension DeleteDetectorOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDetectorOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDetectorOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDetectorOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDetectorOutputResponse()"}
}

extension DeleteDetectorOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDetectorOutputResponse: Equatable {

    public init() {}
}

struct DeleteDetectorOutputResponseBody: Equatable {
}

extension DeleteDetectorOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteDetectorVersionInputBodyMiddleware: Middleware {
    public let id: String = "DeleteDetectorVersionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDetectorVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDetectorVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDetectorVersionInput>
    public typealias MOutput = OperationOutput<DeleteDetectorVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDetectorVersionOutputError>
}

extension DeleteDetectorVersionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDetectorVersionInput(detectorId: \(String(describing: detectorId)), detectorVersionId: \(String(describing: detectorVersionId)))"}
}

extension DeleteDetectorVersionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case detectorId
        case detectorVersionId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let detectorId = detectorId {
            try encodeContainer.encode(detectorId, forKey: .detectorId)
        }
        if let detectorVersionId = detectorVersionId {
            try encodeContainer.encode(detectorVersionId, forKey: .detectorVersionId)
        }
    }
}

public struct DeleteDetectorVersionInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteDetectorVersionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDetectorVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDetectorVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDetectorVersionInput>
    public typealias MOutput = OperationOutput<DeleteDetectorVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDetectorVersionOutputError>
}

public struct DeleteDetectorVersionInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteDetectorVersionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDetectorVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDetectorVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDetectorVersionInput>
    public typealias MOutput = OperationOutput<DeleteDetectorVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDetectorVersionOutputError>
}

public struct DeleteDetectorVersionInput: Equatable {
    /// <p>The ID of the parent detector for the detector version to delete.</p>
    public let detectorId: String?
    /// <p>The ID of the detector version to delete.</p>
    public let detectorVersionId: String?

    public init (
        detectorId: String? = nil,
        detectorVersionId: String? = nil
    )
    {
        self.detectorId = detectorId
        self.detectorVersionId = detectorVersionId
    }
}

struct DeleteDetectorVersionInputBody: Equatable {
    public let detectorId: String?
    public let detectorVersionId: String?
}

extension DeleteDetectorVersionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case detectorId
        case detectorVersionId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detectorIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .detectorId)
        detectorId = detectorIdDecoded
        let detectorVersionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .detectorVersionId)
        detectorVersionId = detectorVersionIdDecoded
    }
}

extension DeleteDetectorVersionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDetectorVersionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDetectorVersionOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDetectorVersionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDetectorVersionOutputResponse()"}
}

extension DeleteDetectorVersionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDetectorVersionOutputResponse: Equatable {

    public init() {}
}

struct DeleteDetectorVersionOutputResponseBody: Equatable {
}

extension DeleteDetectorVersionOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteEntityTypeInputBodyMiddleware: Middleware {
    public let id: String = "DeleteEntityTypeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteEntityTypeInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteEntityTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteEntityTypeInput>
    public typealias MOutput = OperationOutput<DeleteEntityTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteEntityTypeOutputError>
}

extension DeleteEntityTypeInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteEntityTypeInput(name: \(String(describing: name)))"}
}

extension DeleteEntityTypeInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct DeleteEntityTypeInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteEntityTypeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteEntityTypeInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteEntityTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteEntityTypeInput>
    public typealias MOutput = OperationOutput<DeleteEntityTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteEntityTypeOutputError>
}

public struct DeleteEntityTypeInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteEntityTypeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteEntityTypeInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteEntityTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteEntityTypeInput>
    public typealias MOutput = OperationOutput<DeleteEntityTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteEntityTypeOutputError>
}

public struct DeleteEntityTypeInput: Equatable {
    /// <p>The name of the entity type to delete.</p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

struct DeleteEntityTypeInputBody: Equatable {
    public let name: String?
}

extension DeleteEntityTypeInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DeleteEntityTypeOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteEntityTypeOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteEntityTypeOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteEntityTypeOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteEntityTypeOutputResponse()"}
}

extension DeleteEntityTypeOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteEntityTypeOutputResponse: Equatable {

    public init() {}
}

struct DeleteEntityTypeOutputResponseBody: Equatable {
}

extension DeleteEntityTypeOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteEventInputBodyMiddleware: Middleware {
    public let id: String = "DeleteEventInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteEventInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteEventOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteEventInput>
    public typealias MOutput = OperationOutput<DeleteEventOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteEventOutputError>
}

extension DeleteEventInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteEventInput(eventId: \(String(describing: eventId)), eventTypeName: \(String(describing: eventTypeName)))"}
}

extension DeleteEventInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case eventId
        case eventTypeName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventId = eventId {
            try encodeContainer.encode(eventId, forKey: .eventId)
        }
        if let eventTypeName = eventTypeName {
            try encodeContainer.encode(eventTypeName, forKey: .eventTypeName)
        }
    }
}

public struct DeleteEventInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteEventInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteEventInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteEventOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteEventInput>
    public typealias MOutput = OperationOutput<DeleteEventOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteEventOutputError>
}

public struct DeleteEventInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteEventInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteEventInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteEventOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteEventInput>
    public typealias MOutput = OperationOutput<DeleteEventOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteEventOutputError>
}

public struct DeleteEventInput: Equatable {
    /// <p>The ID of the event to delete.</p>
    public let eventId: String?
    /// <p>The name of the event type.</p>
    public let eventTypeName: String?

    public init (
        eventId: String? = nil,
        eventTypeName: String? = nil
    )
    {
        self.eventId = eventId
        self.eventTypeName = eventTypeName
    }
}

struct DeleteEventInputBody: Equatable {
    public let eventId: String?
    public let eventTypeName: String?
}

extension DeleteEventInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case eventId
        case eventTypeName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventId)
        eventId = eventIdDecoded
        let eventTypeNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventTypeName)
        eventTypeName = eventTypeNameDecoded
    }
}

extension DeleteEventOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteEventOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteEventOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteEventOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteEventOutputResponse()"}
}

extension DeleteEventOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteEventOutputResponse: Equatable {

    public init() {}
}

struct DeleteEventOutputResponseBody: Equatable {
}

extension DeleteEventOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteEventTypeInputBodyMiddleware: Middleware {
    public let id: String = "DeleteEventTypeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteEventTypeInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteEventTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteEventTypeInput>
    public typealias MOutput = OperationOutput<DeleteEventTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteEventTypeOutputError>
}

extension DeleteEventTypeInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteEventTypeInput(name: \(String(describing: name)))"}
}

extension DeleteEventTypeInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct DeleteEventTypeInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteEventTypeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteEventTypeInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteEventTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteEventTypeInput>
    public typealias MOutput = OperationOutput<DeleteEventTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteEventTypeOutputError>
}

public struct DeleteEventTypeInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteEventTypeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteEventTypeInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteEventTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteEventTypeInput>
    public typealias MOutput = OperationOutput<DeleteEventTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteEventTypeOutputError>
}

public struct DeleteEventTypeInput: Equatable {
    /// <p>The name of the event type to delete.</p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

struct DeleteEventTypeInputBody: Equatable {
    public let name: String?
}

extension DeleteEventTypeInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DeleteEventTypeOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteEventTypeOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteEventTypeOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteEventTypeOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteEventTypeOutputResponse()"}
}

extension DeleteEventTypeOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteEventTypeOutputResponse: Equatable {

    public init() {}
}

struct DeleteEventTypeOutputResponseBody: Equatable {
}

extension DeleteEventTypeOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteExternalModelInputBodyMiddleware: Middleware {
    public let id: String = "DeleteExternalModelInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteExternalModelInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteExternalModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteExternalModelInput>
    public typealias MOutput = OperationOutput<DeleteExternalModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteExternalModelOutputError>
}

extension DeleteExternalModelInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteExternalModelInput(modelEndpoint: \(String(describing: modelEndpoint)))"}
}

extension DeleteExternalModelInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case modelEndpoint
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let modelEndpoint = modelEndpoint {
            try encodeContainer.encode(modelEndpoint, forKey: .modelEndpoint)
        }
    }
}

public struct DeleteExternalModelInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteExternalModelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteExternalModelInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteExternalModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteExternalModelInput>
    public typealias MOutput = OperationOutput<DeleteExternalModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteExternalModelOutputError>
}

public struct DeleteExternalModelInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteExternalModelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteExternalModelInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteExternalModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteExternalModelInput>
    public typealias MOutput = OperationOutput<DeleteExternalModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteExternalModelOutputError>
}

public struct DeleteExternalModelInput: Equatable {
    /// <p>The endpoint of the Amazon Sagemaker model to delete.</p>
    public let modelEndpoint: String?

    public init (
        modelEndpoint: String? = nil
    )
    {
        self.modelEndpoint = modelEndpoint
    }
}

struct DeleteExternalModelInputBody: Equatable {
    public let modelEndpoint: String?
}

extension DeleteExternalModelInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case modelEndpoint
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelEndpointDecoded = try containerValues.decodeIfPresent(String.self, forKey: .modelEndpoint)
        modelEndpoint = modelEndpointDecoded
    }
}

extension DeleteExternalModelOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteExternalModelOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteExternalModelOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteExternalModelOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteExternalModelOutputResponse()"}
}

extension DeleteExternalModelOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteExternalModelOutputResponse: Equatable {

    public init() {}
}

struct DeleteExternalModelOutputResponseBody: Equatable {
}

extension DeleteExternalModelOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteLabelInputBodyMiddleware: Middleware {
    public let id: String = "DeleteLabelInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteLabelInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteLabelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteLabelInput>
    public typealias MOutput = OperationOutput<DeleteLabelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteLabelOutputError>
}

extension DeleteLabelInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteLabelInput(name: \(String(describing: name)))"}
}

extension DeleteLabelInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct DeleteLabelInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteLabelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteLabelInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteLabelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteLabelInput>
    public typealias MOutput = OperationOutput<DeleteLabelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteLabelOutputError>
}

public struct DeleteLabelInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteLabelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteLabelInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteLabelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteLabelInput>
    public typealias MOutput = OperationOutput<DeleteLabelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteLabelOutputError>
}

public struct DeleteLabelInput: Equatable {
    /// <p>The name of the label to delete.</p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

struct DeleteLabelInputBody: Equatable {
    public let name: String?
}

extension DeleteLabelInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DeleteLabelOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteLabelOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteLabelOutputError: Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteLabelOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteLabelOutputResponse()"}
}

extension DeleteLabelOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteLabelOutputResponse: Equatable {

    public init() {}
}

struct DeleteLabelOutputResponseBody: Equatable {
}

extension DeleteLabelOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteModelInputBodyMiddleware: Middleware {
    public let id: String = "DeleteModelInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteModelInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteModelInput>
    public typealias MOutput = OperationOutput<DeleteModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteModelOutputError>
}

extension DeleteModelInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteModelInput(modelId: \(String(describing: modelId)), modelType: \(String(describing: modelType)))"}
}

extension DeleteModelInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case modelId
        case modelType
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let modelId = modelId {
            try encodeContainer.encode(modelId, forKey: .modelId)
        }
        if let modelType = modelType {
            try encodeContainer.encode(modelType.rawValue, forKey: .modelType)
        }
    }
}

public struct DeleteModelInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteModelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteModelInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteModelInput>
    public typealias MOutput = OperationOutput<DeleteModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteModelOutputError>
}

public struct DeleteModelInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteModelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteModelInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteModelInput>
    public typealias MOutput = OperationOutput<DeleteModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteModelOutputError>
}

public struct DeleteModelInput: Equatable {
    /// <p>The model ID of the model to delete.</p>
    public let modelId: String?
    /// <p>The model type of the model to delete.</p>
    public let modelType: ModelTypeEnum?

    public init (
        modelId: String? = nil,
        modelType: ModelTypeEnum? = nil
    )
    {
        self.modelId = modelId
        self.modelType = modelType
    }
}

struct DeleteModelInputBody: Equatable {
    public let modelId: String?
    public let modelType: ModelTypeEnum?
}

extension DeleteModelInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case modelId
        case modelType
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .modelId)
        modelId = modelIdDecoded
        let modelTypeDecoded = try containerValues.decodeIfPresent(ModelTypeEnum.self, forKey: .modelType)
        modelType = modelTypeDecoded
    }
}

extension DeleteModelOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteModelOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteModelOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteModelOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteModelOutputResponse()"}
}

extension DeleteModelOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteModelOutputResponse: Equatable {

    public init() {}
}

struct DeleteModelOutputResponseBody: Equatable {
}

extension DeleteModelOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteModelVersionInputBodyMiddleware: Middleware {
    public let id: String = "DeleteModelVersionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteModelVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteModelVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteModelVersionInput>
    public typealias MOutput = OperationOutput<DeleteModelVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteModelVersionOutputError>
}

extension DeleteModelVersionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteModelVersionInput(modelId: \(String(describing: modelId)), modelType: \(String(describing: modelType)), modelVersionNumber: \(String(describing: modelVersionNumber)))"}
}

extension DeleteModelVersionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case modelId
        case modelType
        case modelVersionNumber
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let modelId = modelId {
            try encodeContainer.encode(modelId, forKey: .modelId)
        }
        if let modelType = modelType {
            try encodeContainer.encode(modelType.rawValue, forKey: .modelType)
        }
        if let modelVersionNumber = modelVersionNumber {
            try encodeContainer.encode(modelVersionNumber, forKey: .modelVersionNumber)
        }
    }
}

public struct DeleteModelVersionInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteModelVersionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteModelVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteModelVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteModelVersionInput>
    public typealias MOutput = OperationOutput<DeleteModelVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteModelVersionOutputError>
}

public struct DeleteModelVersionInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteModelVersionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteModelVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteModelVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteModelVersionInput>
    public typealias MOutput = OperationOutput<DeleteModelVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteModelVersionOutputError>
}

public struct DeleteModelVersionInput: Equatable {
    /// <p>The model ID of the model version to delete.</p>
    public let modelId: String?
    /// <p>The model type of the model version to delete.</p>
    public let modelType: ModelTypeEnum?
    /// <p>The model version number of the model version to delete.</p>
    public let modelVersionNumber: String?

    public init (
        modelId: String? = nil,
        modelType: ModelTypeEnum? = nil,
        modelVersionNumber: String? = nil
    )
    {
        self.modelId = modelId
        self.modelType = modelType
        self.modelVersionNumber = modelVersionNumber
    }
}

struct DeleteModelVersionInputBody: Equatable {
    public let modelId: String?
    public let modelType: ModelTypeEnum?
    public let modelVersionNumber: String?
}

extension DeleteModelVersionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case modelId
        case modelType
        case modelVersionNumber
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .modelId)
        modelId = modelIdDecoded
        let modelTypeDecoded = try containerValues.decodeIfPresent(ModelTypeEnum.self, forKey: .modelType)
        modelType = modelTypeDecoded
        let modelVersionNumberDecoded = try containerValues.decodeIfPresent(String.self, forKey: .modelVersionNumber)
        modelVersionNumber = modelVersionNumberDecoded
    }
}

extension DeleteModelVersionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteModelVersionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteModelVersionOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteModelVersionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteModelVersionOutputResponse()"}
}

extension DeleteModelVersionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteModelVersionOutputResponse: Equatable {

    public init() {}
}

struct DeleteModelVersionOutputResponseBody: Equatable {
}

extension DeleteModelVersionOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteOutcomeInputBodyMiddleware: Middleware {
    public let id: String = "DeleteOutcomeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteOutcomeInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteOutcomeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteOutcomeInput>
    public typealias MOutput = OperationOutput<DeleteOutcomeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteOutcomeOutputError>
}

extension DeleteOutcomeInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteOutcomeInput(name: \(String(describing: name)))"}
}

extension DeleteOutcomeInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct DeleteOutcomeInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteOutcomeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteOutcomeInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteOutcomeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteOutcomeInput>
    public typealias MOutput = OperationOutput<DeleteOutcomeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteOutcomeOutputError>
}

public struct DeleteOutcomeInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteOutcomeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteOutcomeInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteOutcomeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteOutcomeInput>
    public typealias MOutput = OperationOutput<DeleteOutcomeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteOutcomeOutputError>
}

public struct DeleteOutcomeInput: Equatable {
    /// <p>The name of the outcome to delete.</p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

struct DeleteOutcomeInputBody: Equatable {
    public let name: String?
}

extension DeleteOutcomeInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DeleteOutcomeOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteOutcomeOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteOutcomeOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteOutcomeOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteOutcomeOutputResponse()"}
}

extension DeleteOutcomeOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteOutcomeOutputResponse: Equatable {

    public init() {}
}

struct DeleteOutcomeOutputResponseBody: Equatable {
}

extension DeleteOutcomeOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteRuleInputBodyMiddleware: Middleware {
    public let id: String = "DeleteRuleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRuleInput>
    public typealias MOutput = OperationOutput<DeleteRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRuleOutputError>
}

extension DeleteRuleInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteRuleInput(rule: \(String(describing: rule)))"}
}

extension DeleteRuleInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case rule
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let rule = rule {
            try encodeContainer.encode(rule, forKey: .rule)
        }
    }
}

public struct DeleteRuleInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteRuleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRuleInput>
    public typealias MOutput = OperationOutput<DeleteRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRuleOutputError>
}

public struct DeleteRuleInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteRuleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRuleInput>
    public typealias MOutput = OperationOutput<DeleteRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRuleOutputError>
}

public struct DeleteRuleInput: Equatable {
    /// <p>A rule.</p>
    public let rule: Rule?

    public init (
        rule: Rule? = nil
    )
    {
        self.rule = rule
    }
}

struct DeleteRuleInputBody: Equatable {
    public let rule: Rule?
}

extension DeleteRuleInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case rule
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleDecoded = try containerValues.decodeIfPresent(Rule.self, forKey: .rule)
        rule = ruleDecoded
    }
}

extension DeleteRuleOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteRuleOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteRuleOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteRuleOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteRuleOutputResponse()"}
}

extension DeleteRuleOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteRuleOutputResponse: Equatable {

    public init() {}
}

struct DeleteRuleOutputResponseBody: Equatable {
}

extension DeleteRuleOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteVariableInputBodyMiddleware: Middleware {
    public let id: String = "DeleteVariableInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteVariableInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteVariableOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteVariableInput>
    public typealias MOutput = OperationOutput<DeleteVariableOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteVariableOutputError>
}

extension DeleteVariableInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteVariableInput(name: \(String(describing: name)))"}
}

extension DeleteVariableInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct DeleteVariableInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteVariableInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteVariableInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteVariableOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteVariableInput>
    public typealias MOutput = OperationOutput<DeleteVariableOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteVariableOutputError>
}

public struct DeleteVariableInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteVariableInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteVariableInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteVariableOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteVariableInput>
    public typealias MOutput = OperationOutput<DeleteVariableOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteVariableOutputError>
}

public struct DeleteVariableInput: Equatable {
    /// <p>The name of the variable to delete.</p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

struct DeleteVariableInputBody: Equatable {
    public let name: String?
}

extension DeleteVariableInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DeleteVariableOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteVariableOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteVariableOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteVariableOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteVariableOutputResponse()"}
}

extension DeleteVariableOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteVariableOutputResponse: Equatable {

    public init() {}
}

struct DeleteVariableOutputResponseBody: Equatable {
}

extension DeleteVariableOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DescribeDetectorInputBodyMiddleware: Middleware {
    public let id: String = "DescribeDetectorInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDetectorInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDetectorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDetectorInput>
    public typealias MOutput = OperationOutput<DescribeDetectorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDetectorOutputError>
}

extension DescribeDetectorInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDetectorInput(detectorId: \(String(describing: detectorId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeDetectorInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case detectorId
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let detectorId = detectorId {
            try encodeContainer.encode(detectorId, forKey: .detectorId)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct DescribeDetectorInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeDetectorInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDetectorInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDetectorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDetectorInput>
    public typealias MOutput = OperationOutput<DescribeDetectorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDetectorOutputError>
}

public struct DescribeDetectorInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeDetectorInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDetectorInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDetectorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDetectorInput>
    public typealias MOutput = OperationOutput<DescribeDetectorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDetectorOutputError>
}

public struct DescribeDetectorInput: Equatable {
    /// <p>The detector ID.</p>
    public let detectorId: String?
    /// <p>The maximum number of results to return for the request.</p>
    public let maxResults: Int?
    /// <p>The next token from the previous response.</p>
    public let nextToken: String?

    public init (
        detectorId: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.detectorId = detectorId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeDetectorInputBody: Equatable {
    public let detectorId: String?
    public let nextToken: String?
    public let maxResults: Int?
}

extension DescribeDetectorInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case detectorId
        case maxResults
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detectorIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .detectorId)
        detectorId = detectorIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeDetectorOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDetectorOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDetectorOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDetectorOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDetectorOutputResponse(arn: \(String(describing: arn)), detectorId: \(String(describing: detectorId)), detectorVersionSummaries: \(String(describing: detectorVersionSummaries)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeDetectorOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeDetectorOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.detectorId = output.detectorId
            self.detectorVersionSummaries = output.detectorVersionSummaries
            self.nextToken = output.nextToken
        } else {
            self.arn = nil
            self.detectorId = nil
            self.detectorVersionSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeDetectorOutputResponse: Equatable {
    /// <p>The detector ARN.</p>
    public let arn: String?
    /// <p>The detector ID.</p>
    public let detectorId: String?
    /// <p>The status and description for each detector version.</p>
    public let detectorVersionSummaries: [DetectorVersionSummary]?
    /// <p>The next token to be used for subsequent requests.</p>
    public let nextToken: String?

    public init (
        arn: String? = nil,
        detectorId: String? = nil,
        detectorVersionSummaries: [DetectorVersionSummary]? = nil,
        nextToken: String? = nil
    )
    {
        self.arn = arn
        self.detectorId = detectorId
        self.detectorVersionSummaries = detectorVersionSummaries
        self.nextToken = nextToken
    }
}

struct DescribeDetectorOutputResponseBody: Equatable {
    public let detectorId: String?
    public let detectorVersionSummaries: [DetectorVersionSummary]?
    public let nextToken: String?
    public let arn: String?
}

extension DescribeDetectorOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn
        case detectorId
        case detectorVersionSummaries
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detectorIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .detectorId)
        detectorId = detectorIdDecoded
        let detectorVersionSummariesContainer = try containerValues.decodeIfPresent([DetectorVersionSummary?].self, forKey: .detectorVersionSummaries)
        var detectorVersionSummariesDecoded0:[DetectorVersionSummary]? = nil
        if let detectorVersionSummariesContainer = detectorVersionSummariesContainer {
            detectorVersionSummariesDecoded0 = [DetectorVersionSummary]()
            for structure0 in detectorVersionSummariesContainer {
                if let structure0 = structure0 {
                    detectorVersionSummariesDecoded0?.append(structure0)
                }
            }
        }
        detectorVersionSummaries = detectorVersionSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
    }
}

public struct DescribeModelVersionsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeModelVersionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeModelVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeModelVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeModelVersionsInput>
    public typealias MOutput = OperationOutput<DescribeModelVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeModelVersionsOutputError>
}

extension DescribeModelVersionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeModelVersionsInput(maxResults: \(String(describing: maxResults)), modelId: \(String(describing: modelId)), modelType: \(String(describing: modelType)), modelVersionNumber: \(String(describing: modelVersionNumber)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeModelVersionsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case modelId
        case modelType
        case modelVersionNumber
        case nextToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let modelId = modelId {
            try encodeContainer.encode(modelId, forKey: .modelId)
        }
        if let modelType = modelType {
            try encodeContainer.encode(modelType.rawValue, forKey: .modelType)
        }
        if let modelVersionNumber = modelVersionNumber {
            try encodeContainer.encode(modelVersionNumber, forKey: .modelVersionNumber)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct DescribeModelVersionsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeModelVersionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeModelVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeModelVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeModelVersionsInput>
    public typealias MOutput = OperationOutput<DescribeModelVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeModelVersionsOutputError>
}

public struct DescribeModelVersionsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeModelVersionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeModelVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeModelVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeModelVersionsInput>
    public typealias MOutput = OperationOutput<DescribeModelVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeModelVersionsOutputError>
}

public struct DescribeModelVersionsInput: Equatable {
    /// <p>The maximum number of results to return.</p>
    public let maxResults: Int?
    /// <p>The model ID.</p>
    public let modelId: String?
    /// <p>The model type.</p>
    public let modelType: ModelTypeEnum?
    /// <p>The model version number.</p>
    public let modelVersionNumber: String?
    /// <p>The next token from the previous results.</p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        modelId: String? = nil,
        modelType: ModelTypeEnum? = nil,
        modelVersionNumber: String? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.modelId = modelId
        self.modelType = modelType
        self.modelVersionNumber = modelVersionNumber
        self.nextToken = nextToken
    }
}

struct DescribeModelVersionsInputBody: Equatable {
    public let modelId: String?
    public let modelVersionNumber: String?
    public let modelType: ModelTypeEnum?
    public let nextToken: String?
    public let maxResults: Int?
}

extension DescribeModelVersionsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case modelId
        case modelType
        case modelVersionNumber
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .modelId)
        modelId = modelIdDecoded
        let modelVersionNumberDecoded = try containerValues.decodeIfPresent(String.self, forKey: .modelVersionNumber)
        modelVersionNumber = modelVersionNumberDecoded
        let modelTypeDecoded = try containerValues.decodeIfPresent(ModelTypeEnum.self, forKey: .modelType)
        modelType = modelTypeDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeModelVersionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeModelVersionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeModelVersionsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeModelVersionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeModelVersionsOutputResponse(modelVersionDetails: \(String(describing: modelVersionDetails)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeModelVersionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeModelVersionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.modelVersionDetails = output.modelVersionDetails
            self.nextToken = output.nextToken
        } else {
            self.modelVersionDetails = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeModelVersionsOutputResponse: Equatable {
    /// <p>The model version details.</p>
    public let modelVersionDetails: [ModelVersionDetail]?
    /// <p>The next token.</p>
    public let nextToken: String?

    public init (
        modelVersionDetails: [ModelVersionDetail]? = nil,
        nextToken: String? = nil
    )
    {
        self.modelVersionDetails = modelVersionDetails
        self.nextToken = nextToken
    }
}

struct DescribeModelVersionsOutputResponseBody: Equatable {
    public let modelVersionDetails: [ModelVersionDetail]?
    public let nextToken: String?
}

extension DescribeModelVersionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case modelVersionDetails
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelVersionDetailsContainer = try containerValues.decodeIfPresent([ModelVersionDetail?].self, forKey: .modelVersionDetails)
        var modelVersionDetailsDecoded0:[ModelVersionDetail]? = nil
        if let modelVersionDetailsContainer = modelVersionDetailsContainer {
            modelVersionDetailsDecoded0 = [ModelVersionDetail]()
            for structure0 in modelVersionDetailsContainer {
                if let structure0 = structure0 {
                    modelVersionDetailsDecoded0?.append(structure0)
                }
            }
        }
        modelVersionDetails = modelVersionDetailsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension Detector: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case createdTime
        case description
        case detectorId
        case eventTypeName
        case lastUpdatedTime
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime, forKey: .createdTime)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let detectorId = detectorId {
            try encodeContainer.encode(detectorId, forKey: .detectorId)
        }
        if let eventTypeName = eventTypeName {
            try encodeContainer.encode(eventTypeName, forKey: .eventTypeName)
        }
        if let lastUpdatedTime = lastUpdatedTime {
            try encodeContainer.encode(lastUpdatedTime, forKey: .lastUpdatedTime)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detectorIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .detectorId)
        detectorId = detectorIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let eventTypeNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventTypeName)
        eventTypeName = eventTypeNameDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension Detector: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Detector(arn: \(String(describing: arn)), createdTime: \(String(describing: createdTime)), description: \(String(describing: description)), detectorId: \(String(describing: detectorId)), eventTypeName: \(String(describing: eventTypeName)), lastUpdatedTime: \(String(describing: lastUpdatedTime)))"}
}

/// <p>The detector.</p>
public struct Detector: Equatable {
    /// <p>The detector ARN.</p>
    public let arn: String?
    /// <p>Timestamp of when the detector was created.</p>
    public let createdTime: String?
    /// <p>The detector description.</p>
    public let description: String?
    /// <p>The detector ID.</p>
    public let detectorId: String?
    /// <p>The name of the event type.</p>
    public let eventTypeName: String?
    /// <p>Timestamp of when the detector was last updated.</p>
    public let lastUpdatedTime: String?

    public init (
        arn: String? = nil,
        createdTime: String? = nil,
        description: String? = nil,
        detectorId: String? = nil,
        eventTypeName: String? = nil,
        lastUpdatedTime: String? = nil
    )
    {
        self.arn = arn
        self.createdTime = createdTime
        self.description = description
        self.detectorId = detectorId
        self.eventTypeName = eventTypeName
        self.lastUpdatedTime = lastUpdatedTime
    }
}

public enum DetectorVersionStatus {
    case active
    case draft
    case inactive
    case sdkUnknown(String)
}

extension DetectorVersionStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DetectorVersionStatus] {
        return [
            .active,
            .draft,
            .inactive,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .active: return "ACTIVE"
        case .draft: return "DRAFT"
        case .inactive: return "INACTIVE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DetectorVersionStatus(rawValue: rawValue) ?? DetectorVersionStatus.sdkUnknown(rawValue)
    }
}

extension DetectorVersionSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description
        case detectorVersionId
        case lastUpdatedTime
        case status
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let detectorVersionId = detectorVersionId {
            try encodeContainer.encode(detectorVersionId, forKey: .detectorVersionId)
        }
        if let lastUpdatedTime = lastUpdatedTime {
            try encodeContainer.encode(lastUpdatedTime, forKey: .lastUpdatedTime)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detectorVersionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .detectorVersionId)
        detectorVersionId = detectorVersionIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DetectorVersionStatus.self, forKey: .status)
        status = statusDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
    }
}

extension DetectorVersionSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DetectorVersionSummary(description: \(String(describing: description)), detectorVersionId: \(String(describing: detectorVersionId)), lastUpdatedTime: \(String(describing: lastUpdatedTime)), status: \(String(describing: status)))"}
}

/// <p>The summary of the detector version.</p>
public struct DetectorVersionSummary: Equatable {
    /// <p>The detector version description. </p>
    public let description: String?
    /// <p>The detector version ID. </p>
    public let detectorVersionId: String?
    /// <p>Timestamp of when the detector version was last updated.</p>
    public let lastUpdatedTime: String?
    /// <p>The detector version status. </p>
    public let status: DetectorVersionStatus?

    public init (
        description: String? = nil,
        detectorVersionId: String? = nil,
        lastUpdatedTime: String? = nil,
        status: DetectorVersionStatus? = nil
    )
    {
        self.description = description
        self.detectorVersionId = detectorVersionId
        self.lastUpdatedTime = lastUpdatedTime
        self.status = status
    }
}

extension Entity: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case entityId
        case entityType
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entityId = entityId {
            try encodeContainer.encode(entityId, forKey: .entityId)
        }
        if let entityType = entityType {
            try encodeContainer.encode(entityType, forKey: .entityType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entityTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .entityType)
        entityType = entityTypeDecoded
        let entityIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .entityId)
        entityId = entityIdDecoded
    }
}

extension Entity: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Entity(entityId: \(String(describing: entityId)), entityType: \(String(describing: entityType)))"}
}

/// <p>The entity details. </p>
public struct Entity: Equatable {
    /// <p>The entity ID. If you do not know the <code>entityId</code>, you can pass <code>unknown</code>, which is areserved string literal.</p>
    public let entityId: String?
    /// <p>The entity type.</p>
    public let entityType: String?

    public init (
        entityId: String? = nil,
        entityType: String? = nil
    )
    {
        self.entityId = entityId
        self.entityType = entityType
    }
}

extension EntityType: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case createdTime
        case description
        case lastUpdatedTime
        case name
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime, forKey: .createdTime)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let lastUpdatedTime = lastUpdatedTime {
            try encodeContainer.encode(lastUpdatedTime, forKey: .lastUpdatedTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension EntityType: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EntityType(arn: \(String(describing: arn)), createdTime: \(String(describing: createdTime)), description: \(String(describing: description)), lastUpdatedTime: \(String(describing: lastUpdatedTime)), name: \(String(describing: name)))"}
}

/// <p>The entity type details.</p>
public struct EntityType: Equatable {
    /// <p>The entity type ARN.</p>
    public let arn: String?
    /// <p>Timestamp of when the entity type was created.</p>
    public let createdTime: String?
    /// <p>The entity type description.</p>
    public let description: String?
    /// <p>Timestamp of when the entity type was last updated.</p>
    public let lastUpdatedTime: String?
    /// <p>The entity type name.</p>
    public let name: String?

    public init (
        arn: String? = nil,
        createdTime: String? = nil,
        description: String? = nil,
        lastUpdatedTime: String? = nil,
        name: String? = nil
    )
    {
        self.arn = arn
        self.createdTime = createdTime
        self.description = description
        self.lastUpdatedTime = lastUpdatedTime
        self.name = name
    }
}

extension EventType: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case createdTime
        case description
        case entityTypes
        case eventVariables
        case labels
        case lastUpdatedTime
        case name
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime, forKey: .createdTime)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let entityTypes = entityTypes {
            var entityTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .entityTypes)
            for nonemptylistofstrings0 in entityTypes {
                try entityTypesContainer.encode(nonemptylistofstrings0)
            }
        }
        if let eventVariables = eventVariables {
            var eventVariablesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eventVariables)
            for listofstrings0 in eventVariables {
                try eventVariablesContainer.encode(listofstrings0)
            }
        }
        if let labels = labels {
            var labelsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .labels)
            for listofstrings0 in labels {
                try labelsContainer.encode(listofstrings0)
            }
        }
        if let lastUpdatedTime = lastUpdatedTime {
            try encodeContainer.encode(lastUpdatedTime, forKey: .lastUpdatedTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let eventVariablesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .eventVariables)
        var eventVariablesDecoded0:[String]? = nil
        if let eventVariablesContainer = eventVariablesContainer {
            eventVariablesDecoded0 = [String]()
            for string0 in eventVariablesContainer {
                if let string0 = string0 {
                    eventVariablesDecoded0?.append(string0)
                }
            }
        }
        eventVariables = eventVariablesDecoded0
        let labelsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .labels)
        var labelsDecoded0:[String]? = nil
        if let labelsContainer = labelsContainer {
            labelsDecoded0 = [String]()
            for string0 in labelsContainer {
                if let string0 = string0 {
                    labelsDecoded0?.append(string0)
                }
            }
        }
        labels = labelsDecoded0
        let entityTypesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .entityTypes)
        var entityTypesDecoded0:[String]? = nil
        if let entityTypesContainer = entityTypesContainer {
            entityTypesDecoded0 = [String]()
            for string0 in entityTypesContainer {
                if let string0 = string0 {
                    entityTypesDecoded0?.append(string0)
                }
            }
        }
        entityTypes = entityTypesDecoded0
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension EventType: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EventType(arn: \(String(describing: arn)), createdTime: \(String(describing: createdTime)), description: \(String(describing: description)), entityTypes: \(String(describing: entityTypes)), eventVariables: \(String(describing: eventVariables)), labels: \(String(describing: labels)), lastUpdatedTime: \(String(describing: lastUpdatedTime)), name: \(String(describing: name)))"}
}

/// <p>The event type details.</p>
public struct EventType: Equatable {
    /// <p>The entity type ARN.</p>
    public let arn: String?
    /// <p>Timestamp of when the event type was created.</p>
    public let createdTime: String?
    /// <p>The event type description.</p>
    public let description: String?
    /// <p>The event type entity types.</p>
    public let entityTypes: [String]?
    /// <p>The event type event variables.</p>
    public let eventVariables: [String]?
    /// <p>The event type labels.</p>
    public let labels: [String]?
    /// <p>Timestamp of when the event type was last updated.</p>
    public let lastUpdatedTime: String?
    /// <p>The event type name.</p>
    public let name: String?

    public init (
        arn: String? = nil,
        createdTime: String? = nil,
        description: String? = nil,
        entityTypes: [String]? = nil,
        eventVariables: [String]? = nil,
        labels: [String]? = nil,
        lastUpdatedTime: String? = nil,
        name: String? = nil
    )
    {
        self.arn = arn
        self.createdTime = createdTime
        self.description = description
        self.entityTypes = entityTypes
        self.eventVariables = eventVariables
        self.labels = labels
        self.lastUpdatedTime = lastUpdatedTime
        self.name = name
    }
}

extension ExternalEventsDetail: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dataAccessRoleArn
        case dataLocation
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataAccessRoleArn = dataAccessRoleArn {
            try encodeContainer.encode(dataAccessRoleArn, forKey: .dataAccessRoleArn)
        }
        if let dataLocation = dataLocation {
            try encodeContainer.encode(dataLocation, forKey: .dataLocation)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataLocationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dataLocation)
        dataLocation = dataLocationDecoded
        let dataAccessRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dataAccessRoleArn)
        dataAccessRoleArn = dataAccessRoleArnDecoded
    }
}

extension ExternalEventsDetail: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ExternalEventsDetail(dataAccessRoleArn: \(String(describing: dataAccessRoleArn)), dataLocation: \(String(describing: dataLocation)))"}
}

/// <p>Details for the external events data used for model version training.</p>
public struct ExternalEventsDetail: Equatable {
    /// <p>The ARN of the role that provides Amazon Fraud Detector access to the data location.</p>
    public let dataAccessRoleArn: String?
    /// <p>The Amazon S3 bucket location for the data.</p>
    public let dataLocation: String?

    public init (
        dataAccessRoleArn: String? = nil,
        dataLocation: String? = nil
    )
    {
        self.dataAccessRoleArn = dataAccessRoleArn
        self.dataLocation = dataLocation
    }
}

extension ExternalModel: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case createdTime
        case inputConfiguration
        case invokeModelEndpointRoleArn
        case lastUpdatedTime
        case modelEndpoint
        case modelEndpointStatus
        case modelSource
        case outputConfiguration
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime, forKey: .createdTime)
        }
        if let inputConfiguration = inputConfiguration {
            try encodeContainer.encode(inputConfiguration, forKey: .inputConfiguration)
        }
        if let invokeModelEndpointRoleArn = invokeModelEndpointRoleArn {
            try encodeContainer.encode(invokeModelEndpointRoleArn, forKey: .invokeModelEndpointRoleArn)
        }
        if let lastUpdatedTime = lastUpdatedTime {
            try encodeContainer.encode(lastUpdatedTime, forKey: .lastUpdatedTime)
        }
        if let modelEndpoint = modelEndpoint {
            try encodeContainer.encode(modelEndpoint, forKey: .modelEndpoint)
        }
        if let modelEndpointStatus = modelEndpointStatus {
            try encodeContainer.encode(modelEndpointStatus.rawValue, forKey: .modelEndpointStatus)
        }
        if let modelSource = modelSource {
            try encodeContainer.encode(modelSource.rawValue, forKey: .modelSource)
        }
        if let outputConfiguration = outputConfiguration {
            try encodeContainer.encode(outputConfiguration, forKey: .outputConfiguration)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelEndpointDecoded = try containerValues.decodeIfPresent(String.self, forKey: .modelEndpoint)
        modelEndpoint = modelEndpointDecoded
        let modelSourceDecoded = try containerValues.decodeIfPresent(ModelSource.self, forKey: .modelSource)
        modelSource = modelSourceDecoded
        let invokeModelEndpointRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .invokeModelEndpointRoleArn)
        invokeModelEndpointRoleArn = invokeModelEndpointRoleArnDecoded
        let inputConfigurationDecoded = try containerValues.decodeIfPresent(ModelInputConfiguration.self, forKey: .inputConfiguration)
        inputConfiguration = inputConfigurationDecoded
        let outputConfigurationDecoded = try containerValues.decodeIfPresent(ModelOutputConfiguration.self, forKey: .outputConfiguration)
        outputConfiguration = outputConfigurationDecoded
        let modelEndpointStatusDecoded = try containerValues.decodeIfPresent(ModelEndpointStatus.self, forKey: .modelEndpointStatus)
        modelEndpointStatus = modelEndpointStatusDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension ExternalModel: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ExternalModel(arn: \(String(describing: arn)), createdTime: \(String(describing: createdTime)), inputConfiguration: \(String(describing: inputConfiguration)), invokeModelEndpointRoleArn: \(String(describing: invokeModelEndpointRoleArn)), lastUpdatedTime: \(String(describing: lastUpdatedTime)), modelEndpoint: \(String(describing: modelEndpoint)), modelEndpointStatus: \(String(describing: modelEndpointStatus)), modelSource: \(String(describing: modelSource)), outputConfiguration: \(String(describing: outputConfiguration)))"}
}

/// <p>The Amazon SageMaker model.</p>
public struct ExternalModel: Equatable {
    /// <p>The model ARN.</p>
    public let arn: String?
    /// <p>Timestamp of when the model was last created.</p>
    public let createdTime: String?
    /// <p>The input configuration.</p>
    public let inputConfiguration: ModelInputConfiguration?
    /// <p>The role used to invoke the model. </p>
    public let invokeModelEndpointRoleArn: String?
    /// <p>Timestamp of when the model was last updated.</p>
    public let lastUpdatedTime: String?
    /// <p>The Amazon SageMaker model endpoints.</p>
    public let modelEndpoint: String?
    /// <p>The Amazon Fraud Detector status for the external model endpoint</p>
    public let modelEndpointStatus: ModelEndpointStatus?
    /// <p>The source of the model.</p>
    public let modelSource: ModelSource?
    /// <p>The output configuration.</p>
    public let outputConfiguration: ModelOutputConfiguration?

    public init (
        arn: String? = nil,
        createdTime: String? = nil,
        inputConfiguration: ModelInputConfiguration? = nil,
        invokeModelEndpointRoleArn: String? = nil,
        lastUpdatedTime: String? = nil,
        modelEndpoint: String? = nil,
        modelEndpointStatus: ModelEndpointStatus? = nil,
        modelSource: ModelSource? = nil,
        outputConfiguration: ModelOutputConfiguration? = nil
    )
    {
        self.arn = arn
        self.createdTime = createdTime
        self.inputConfiguration = inputConfiguration
        self.invokeModelEndpointRoleArn = invokeModelEndpointRoleArn
        self.lastUpdatedTime = lastUpdatedTime
        self.modelEndpoint = modelEndpoint
        self.modelEndpointStatus = modelEndpointStatus
        self.modelSource = modelSource
        self.outputConfiguration = outputConfiguration
    }
}

extension FieldValidationMessage: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case content
        case fieldName
        case identifier
        case title
        case type
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let content = content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let fieldName = fieldName {
            try encodeContainer.encode(fieldName, forKey: .fieldName)
        }
        if let identifier = identifier {
            try encodeContainer.encode(identifier, forKey: .identifier)
        }
        if let title = title {
            try encodeContainer.encode(title, forKey: .title)
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fieldName)
        fieldName = fieldNameDecoded
        let identifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .identifier)
        identifier = identifierDecoded
        let titleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .title)
        title = titleDecoded
        let contentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .content)
        content = contentDecoded
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
    }
}

extension FieldValidationMessage: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FieldValidationMessage(content: \(String(describing: content)), fieldName: \(String(describing: fieldName)), identifier: \(String(describing: identifier)), title: \(String(describing: title)), type: \(String(describing: type)))"}
}

/// <p>The message details.</p>
public struct FieldValidationMessage: Equatable {
    /// <p>The message content.</p>
    public let content: String?
    /// <p>The field name.</p>
    public let fieldName: String?
    /// <p>The message ID.</p>
    public let identifier: String?
    /// <p>The message title.</p>
    public let title: String?
    /// <p>The message type.</p>
    public let type: String?

    public init (
        content: String? = nil,
        fieldName: String? = nil,
        identifier: String? = nil,
        title: String? = nil,
        type: String? = nil
    )
    {
        self.content = content
        self.fieldName = fieldName
        self.identifier = identifier
        self.title = title
        self.type = type
    }
}

extension FileValidationMessage: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case content
        case title
        case type
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let content = content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let title = title {
            try encodeContainer.encode(title, forKey: .title)
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let titleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .title)
        title = titleDecoded
        let contentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .content)
        content = contentDecoded
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
    }
}

extension FileValidationMessage: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FileValidationMessage(content: \(String(describing: content)), title: \(String(describing: title)), type: \(String(describing: type)))"}
}

/// <p>The message details.</p>
public struct FileValidationMessage: Equatable {
    /// <p>The message content.</p>
    public let content: String?
    /// <p>The message title.</p>
    public let title: String?
    /// <p>The message type.</p>
    public let type: String?

    public init (
        content: String? = nil,
        title: String? = nil,
        type: String? = nil
    )
    {
        self.content = content
        self.title = title
        self.type = type
    }
}

public struct GetBatchPredictionJobsInputBodyMiddleware: Middleware {
    public let id: String = "GetBatchPredictionJobsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetBatchPredictionJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetBatchPredictionJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetBatchPredictionJobsInput>
    public typealias MOutput = OperationOutput<GetBatchPredictionJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetBatchPredictionJobsOutputError>
}

extension GetBatchPredictionJobsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetBatchPredictionJobsInput(jobId: \(String(describing: jobId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension GetBatchPredictionJobsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case jobId
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct GetBatchPredictionJobsInputHeadersMiddleware: Middleware {
    public let id: String = "GetBatchPredictionJobsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetBatchPredictionJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetBatchPredictionJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetBatchPredictionJobsInput>
    public typealias MOutput = OperationOutput<GetBatchPredictionJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetBatchPredictionJobsOutputError>
}

public struct GetBatchPredictionJobsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetBatchPredictionJobsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetBatchPredictionJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetBatchPredictionJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetBatchPredictionJobsInput>
    public typealias MOutput = OperationOutput<GetBatchPredictionJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetBatchPredictionJobsOutputError>
}

public struct GetBatchPredictionJobsInput: Equatable {
    /// <p>The batch prediction job for which to get the details.</p>
    public let jobId: String?
    /// <p>The maximum number of objects to return for the request.</p>
    public let maxResults: Int?
    /// <p>The next token from the previous request.</p>
    public let nextToken: String?

    public init (
        jobId: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.jobId = jobId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct GetBatchPredictionJobsInputBody: Equatable {
    public let jobId: String?
    public let maxResults: Int?
    public let nextToken: String?
}

extension GetBatchPredictionJobsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobId
        case maxResults
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetBatchPredictionJobsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetBatchPredictionJobsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetBatchPredictionJobsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetBatchPredictionJobsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetBatchPredictionJobsOutputResponse(batchPredictions: \(String(describing: batchPredictions)), nextToken: \(String(describing: nextToken)))"}
}

extension GetBatchPredictionJobsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetBatchPredictionJobsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.batchPredictions = output.batchPredictions
            self.nextToken = output.nextToken
        } else {
            self.batchPredictions = nil
            self.nextToken = nil
        }
    }
}

public struct GetBatchPredictionJobsOutputResponse: Equatable {
    /// <p>An array containing the details of each batch prediction job.</p>
    public let batchPredictions: [BatchPrediction]?
    /// <p>The next token for the subsequent request.</p>
    public let nextToken: String?

    public init (
        batchPredictions: [BatchPrediction]? = nil,
        nextToken: String? = nil
    )
    {
        self.batchPredictions = batchPredictions
        self.nextToken = nextToken
    }
}

struct GetBatchPredictionJobsOutputResponseBody: Equatable {
    public let batchPredictions: [BatchPrediction]?
    public let nextToken: String?
}

extension GetBatchPredictionJobsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case batchPredictions
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let batchPredictionsContainer = try containerValues.decodeIfPresent([BatchPrediction?].self, forKey: .batchPredictions)
        var batchPredictionsDecoded0:[BatchPrediction]? = nil
        if let batchPredictionsContainer = batchPredictionsContainer {
            batchPredictionsDecoded0 = [BatchPrediction]()
            for structure0 in batchPredictionsContainer {
                if let structure0 = structure0 {
                    batchPredictionsDecoded0?.append(structure0)
                }
            }
        }
        batchPredictions = batchPredictionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct GetDetectorVersionInputBodyMiddleware: Middleware {
    public let id: String = "GetDetectorVersionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDetectorVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDetectorVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDetectorVersionInput>
    public typealias MOutput = OperationOutput<GetDetectorVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDetectorVersionOutputError>
}

extension GetDetectorVersionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDetectorVersionInput(detectorId: \(String(describing: detectorId)), detectorVersionId: \(String(describing: detectorVersionId)))"}
}

extension GetDetectorVersionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case detectorId
        case detectorVersionId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let detectorId = detectorId {
            try encodeContainer.encode(detectorId, forKey: .detectorId)
        }
        if let detectorVersionId = detectorVersionId {
            try encodeContainer.encode(detectorVersionId, forKey: .detectorVersionId)
        }
    }
}

public struct GetDetectorVersionInputHeadersMiddleware: Middleware {
    public let id: String = "GetDetectorVersionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDetectorVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDetectorVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDetectorVersionInput>
    public typealias MOutput = OperationOutput<GetDetectorVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDetectorVersionOutputError>
}

public struct GetDetectorVersionInputQueryItemMiddleware: Middleware {
    public let id: String = "GetDetectorVersionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDetectorVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDetectorVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDetectorVersionInput>
    public typealias MOutput = OperationOutput<GetDetectorVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDetectorVersionOutputError>
}

public struct GetDetectorVersionInput: Equatable {
    /// <p>The detector ID.</p>
    public let detectorId: String?
    /// <p>The detector version ID.</p>
    public let detectorVersionId: String?

    public init (
        detectorId: String? = nil,
        detectorVersionId: String? = nil
    )
    {
        self.detectorId = detectorId
        self.detectorVersionId = detectorVersionId
    }
}

struct GetDetectorVersionInputBody: Equatable {
    public let detectorId: String?
    public let detectorVersionId: String?
}

extension GetDetectorVersionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case detectorId
        case detectorVersionId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detectorIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .detectorId)
        detectorId = detectorIdDecoded
        let detectorVersionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .detectorVersionId)
        detectorVersionId = detectorVersionIdDecoded
    }
}

extension GetDetectorVersionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDetectorVersionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDetectorVersionOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDetectorVersionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDetectorVersionOutputResponse(arn: \(String(describing: arn)), createdTime: \(String(describing: createdTime)), description: \(String(describing: description)), detectorId: \(String(describing: detectorId)), detectorVersionId: \(String(describing: detectorVersionId)), externalModelEndpoints: \(String(describing: externalModelEndpoints)), lastUpdatedTime: \(String(describing: lastUpdatedTime)), modelVersions: \(String(describing: modelVersions)), ruleExecutionMode: \(String(describing: ruleExecutionMode)), rules: \(String(describing: rules)), status: \(String(describing: status)))"}
}

extension GetDetectorVersionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetDetectorVersionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.createdTime = output.createdTime
            self.description = output.description
            self.detectorId = output.detectorId
            self.detectorVersionId = output.detectorVersionId
            self.externalModelEndpoints = output.externalModelEndpoints
            self.lastUpdatedTime = output.lastUpdatedTime
            self.modelVersions = output.modelVersions
            self.ruleExecutionMode = output.ruleExecutionMode
            self.rules = output.rules
            self.status = output.status
        } else {
            self.arn = nil
            self.createdTime = nil
            self.description = nil
            self.detectorId = nil
            self.detectorVersionId = nil
            self.externalModelEndpoints = nil
            self.lastUpdatedTime = nil
            self.modelVersions = nil
            self.ruleExecutionMode = nil
            self.rules = nil
            self.status = nil
        }
    }
}

public struct GetDetectorVersionOutputResponse: Equatable {
    /// <p>The detector version ARN.</p>
    public let arn: String?
    /// <p>The timestamp when the detector version was created. </p>
    public let createdTime: String?
    /// <p>The detector version description.</p>
    public let description: String?
    /// <p>The detector ID.</p>
    public let detectorId: String?
    /// <p>The detector version ID.</p>
    public let detectorVersionId: String?
    /// <p>The Amazon SageMaker model endpoints included in the detector version.</p>
    public let externalModelEndpoints: [String]?
    /// <p>The timestamp when the detector version was last updated.
    ///         </p>
    public let lastUpdatedTime: String?
    /// <p>The model versions included in the detector version. </p>
    public let modelVersions: [ModelVersion]?
    /// <p>The execution mode of the rule in the dectector</p>
    /// 	        <p>
    ///             <code>FIRST_MATCHED</code> indicates that Amazon Fraud Detector evaluates rules sequentially, first to last, stopping at the first matched rule. Amazon Fraud dectector then provides the outcomes for that single rule.</p>
    /// 	        <p>
    ///             <code>ALL_MATCHED</code> indicates that Amazon Fraud Detector evaluates all rules and returns the outcomes for all matched rules. You can define and edit the rule mode at the detector version level, when it is in draft status.</p>
    public let ruleExecutionMode: RuleExecutionMode?
    /// <p>The rules included in the detector version.</p>
    public let rules: [Rule]?
    /// <p>The status of the detector version.</p>
    public let status: DetectorVersionStatus?

    public init (
        arn: String? = nil,
        createdTime: String? = nil,
        description: String? = nil,
        detectorId: String? = nil,
        detectorVersionId: String? = nil,
        externalModelEndpoints: [String]? = nil,
        lastUpdatedTime: String? = nil,
        modelVersions: [ModelVersion]? = nil,
        ruleExecutionMode: RuleExecutionMode? = nil,
        rules: [Rule]? = nil,
        status: DetectorVersionStatus? = nil
    )
    {
        self.arn = arn
        self.createdTime = createdTime
        self.description = description
        self.detectorId = detectorId
        self.detectorVersionId = detectorVersionId
        self.externalModelEndpoints = externalModelEndpoints
        self.lastUpdatedTime = lastUpdatedTime
        self.modelVersions = modelVersions
        self.ruleExecutionMode = ruleExecutionMode
        self.rules = rules
        self.status = status
    }
}

struct GetDetectorVersionOutputResponseBody: Equatable {
    public let detectorId: String?
    public let detectorVersionId: String?
    public let description: String?
    public let externalModelEndpoints: [String]?
    public let modelVersions: [ModelVersion]?
    public let rules: [Rule]?
    public let status: DetectorVersionStatus?
    public let lastUpdatedTime: String?
    public let createdTime: String?
    public let ruleExecutionMode: RuleExecutionMode?
    public let arn: String?
}

extension GetDetectorVersionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn
        case createdTime
        case description
        case detectorId
        case detectorVersionId
        case externalModelEndpoints
        case lastUpdatedTime
        case modelVersions
        case ruleExecutionMode
        case rules
        case status
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detectorIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .detectorId)
        detectorId = detectorIdDecoded
        let detectorVersionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .detectorVersionId)
        detectorVersionId = detectorVersionIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let externalModelEndpointsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .externalModelEndpoints)
        var externalModelEndpointsDecoded0:[String]? = nil
        if let externalModelEndpointsContainer = externalModelEndpointsContainer {
            externalModelEndpointsDecoded0 = [String]()
            for string0 in externalModelEndpointsContainer {
                if let string0 = string0 {
                    externalModelEndpointsDecoded0?.append(string0)
                }
            }
        }
        externalModelEndpoints = externalModelEndpointsDecoded0
        let modelVersionsContainer = try containerValues.decodeIfPresent([ModelVersion?].self, forKey: .modelVersions)
        var modelVersionsDecoded0:[ModelVersion]? = nil
        if let modelVersionsContainer = modelVersionsContainer {
            modelVersionsDecoded0 = [ModelVersion]()
            for structure0 in modelVersionsContainer {
                if let structure0 = structure0 {
                    modelVersionsDecoded0?.append(structure0)
                }
            }
        }
        modelVersions = modelVersionsDecoded0
        let rulesContainer = try containerValues.decodeIfPresent([Rule?].self, forKey: .rules)
        var rulesDecoded0:[Rule]? = nil
        if let rulesContainer = rulesContainer {
            rulesDecoded0 = [Rule]()
            for structure0 in rulesContainer {
                if let structure0 = structure0 {
                    rulesDecoded0?.append(structure0)
                }
            }
        }
        rules = rulesDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(DetectorVersionStatus.self, forKey: .status)
        status = statusDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let ruleExecutionModeDecoded = try containerValues.decodeIfPresent(RuleExecutionMode.self, forKey: .ruleExecutionMode)
        ruleExecutionMode = ruleExecutionModeDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
    }
}

public struct GetDetectorsInputBodyMiddleware: Middleware {
    public let id: String = "GetDetectorsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDetectorsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDetectorsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDetectorsInput>
    public typealias MOutput = OperationOutput<GetDetectorsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDetectorsOutputError>
}

extension GetDetectorsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDetectorsInput(detectorId: \(String(describing: detectorId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension GetDetectorsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case detectorId
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let detectorId = detectorId {
            try encodeContainer.encode(detectorId, forKey: .detectorId)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct GetDetectorsInputHeadersMiddleware: Middleware {
    public let id: String = "GetDetectorsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDetectorsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDetectorsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDetectorsInput>
    public typealias MOutput = OperationOutput<GetDetectorsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDetectorsOutputError>
}

public struct GetDetectorsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetDetectorsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDetectorsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDetectorsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDetectorsInput>
    public typealias MOutput = OperationOutput<GetDetectorsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDetectorsOutputError>
}

public struct GetDetectorsInput: Equatable {
    /// <p>The detector ID.</p>
    public let detectorId: String?
    /// <p>The maximum number of objects to return for the request.</p>
    public let maxResults: Int?
    /// <p>The next token for the subsequent request.</p>
    public let nextToken: String?

    public init (
        detectorId: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.detectorId = detectorId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct GetDetectorsInputBody: Equatable {
    public let detectorId: String?
    public let nextToken: String?
    public let maxResults: Int?
}

extension GetDetectorsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case detectorId
        case maxResults
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detectorIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .detectorId)
        detectorId = detectorIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension GetDetectorsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDetectorsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDetectorsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDetectorsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDetectorsOutputResponse(detectors: \(String(describing: detectors)), nextToken: \(String(describing: nextToken)))"}
}

extension GetDetectorsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetDetectorsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.detectors = output.detectors
            self.nextToken = output.nextToken
        } else {
            self.detectors = nil
            self.nextToken = nil
        }
    }
}

public struct GetDetectorsOutputResponse: Equatable {
    /// <p>The detectors.</p>
    public let detectors: [Detector]?
    /// <p>The next page token.</p>
    public let nextToken: String?

    public init (
        detectors: [Detector]? = nil,
        nextToken: String? = nil
    )
    {
        self.detectors = detectors
        self.nextToken = nextToken
    }
}

struct GetDetectorsOutputResponseBody: Equatable {
    public let detectors: [Detector]?
    public let nextToken: String?
}

extension GetDetectorsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case detectors
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detectorsContainer = try containerValues.decodeIfPresent([Detector?].self, forKey: .detectors)
        var detectorsDecoded0:[Detector]? = nil
        if let detectorsContainer = detectorsContainer {
            detectorsDecoded0 = [Detector]()
            for structure0 in detectorsContainer {
                if let structure0 = structure0 {
                    detectorsDecoded0?.append(structure0)
                }
            }
        }
        detectors = detectorsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct GetEntityTypesInputBodyMiddleware: Middleware {
    public let id: String = "GetEntityTypesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetEntityTypesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetEntityTypesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetEntityTypesInput>
    public typealias MOutput = OperationOutput<GetEntityTypesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetEntityTypesOutputError>
}

extension GetEntityTypesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetEntityTypesInput(maxResults: \(String(describing: maxResults)), name: \(String(describing: name)), nextToken: \(String(describing: nextToken)))"}
}

extension GetEntityTypesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case name
        case nextToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct GetEntityTypesInputHeadersMiddleware: Middleware {
    public let id: String = "GetEntityTypesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetEntityTypesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetEntityTypesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetEntityTypesInput>
    public typealias MOutput = OperationOutput<GetEntityTypesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetEntityTypesOutputError>
}

public struct GetEntityTypesInputQueryItemMiddleware: Middleware {
    public let id: String = "GetEntityTypesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetEntityTypesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetEntityTypesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetEntityTypesInput>
    public typealias MOutput = OperationOutput<GetEntityTypesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetEntityTypesOutputError>
}

public struct GetEntityTypesInput: Equatable {
    /// <p>The maximum number of objects to return for the request.</p>
    public let maxResults: Int?
    /// <p>The name.</p>
    public let name: String?
    /// <p>The next token for the subsequent request.</p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        name: String? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.name = name
        self.nextToken = nextToken
    }
}

struct GetEntityTypesInputBody: Equatable {
    public let name: String?
    public let nextToken: String?
    public let maxResults: Int?
}

extension GetEntityTypesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case name
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension GetEntityTypesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetEntityTypesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetEntityTypesOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetEntityTypesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetEntityTypesOutputResponse(entityTypes: \(String(describing: entityTypes)), nextToken: \(String(describing: nextToken)))"}
}

extension GetEntityTypesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetEntityTypesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.entityTypes = output.entityTypes
            self.nextToken = output.nextToken
        } else {
            self.entityTypes = nil
            self.nextToken = nil
        }
    }
}

public struct GetEntityTypesOutputResponse: Equatable {
    /// <p>An array of entity types.</p>
    public let entityTypes: [EntityType]?
    /// <p>The next page token.</p>
    public let nextToken: String?

    public init (
        entityTypes: [EntityType]? = nil,
        nextToken: String? = nil
    )
    {
        self.entityTypes = entityTypes
        self.nextToken = nextToken
    }
}

struct GetEntityTypesOutputResponseBody: Equatable {
    public let entityTypes: [EntityType]?
    public let nextToken: String?
}

extension GetEntityTypesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case entityTypes
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entityTypesContainer = try containerValues.decodeIfPresent([EntityType?].self, forKey: .entityTypes)
        var entityTypesDecoded0:[EntityType]? = nil
        if let entityTypesContainer = entityTypesContainer {
            entityTypesDecoded0 = [EntityType]()
            for structure0 in entityTypesContainer {
                if let structure0 = structure0 {
                    entityTypesDecoded0?.append(structure0)
                }
            }
        }
        entityTypes = entityTypesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct GetEventPredictionInputBodyMiddleware: Middleware {
    public let id: String = "GetEventPredictionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetEventPredictionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetEventPredictionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetEventPredictionInput>
    public typealias MOutput = OperationOutput<GetEventPredictionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetEventPredictionOutputError>
}

extension GetEventPredictionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetEventPredictionInput(detectorId: \(String(describing: detectorId)), detectorVersionId: \(String(describing: detectorVersionId)), entities: \(String(describing: entities)), eventId: \(String(describing: eventId)), eventTimestamp: \(String(describing: eventTimestamp)), eventTypeName: \(String(describing: eventTypeName)), eventVariables: \(String(describing: eventVariables)), externalModelEndpointDataBlobs: \(String(describing: externalModelEndpointDataBlobs)))"}
}

extension GetEventPredictionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case detectorId
        case detectorVersionId
        case entities
        case eventId
        case eventTimestamp
        case eventTypeName
        case eventVariables
        case externalModelEndpointDataBlobs
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let detectorId = detectorId {
            try encodeContainer.encode(detectorId, forKey: .detectorId)
        }
        if let detectorVersionId = detectorVersionId {
            try encodeContainer.encode(detectorVersionId, forKey: .detectorVersionId)
        }
        if let entities = entities {
            var entitiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .entities)
            for listofentities0 in entities {
                try entitiesContainer.encode(listofentities0)
            }
        }
        if let eventId = eventId {
            try encodeContainer.encode(eventId, forKey: .eventId)
        }
        if let eventTimestamp = eventTimestamp {
            try encodeContainer.encode(eventTimestamp, forKey: .eventTimestamp)
        }
        if let eventTypeName = eventTypeName {
            try encodeContainer.encode(eventTypeName, forKey: .eventTypeName)
        }
        if let eventVariables = eventVariables {
            var eventVariablesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .eventVariables)
            for (dictKey0, eventvariablemap0) in eventVariables {
                try eventVariablesContainer.encode(eventvariablemap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let externalModelEndpointDataBlobs = externalModelEndpointDataBlobs {
            var externalModelEndpointDataBlobsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .externalModelEndpointDataBlobs)
            for (dictKey0, externalmodelendpointdatablobmap0) in externalModelEndpointDataBlobs {
                try externalModelEndpointDataBlobsContainer.encode(externalmodelendpointdatablobmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct GetEventPredictionInputHeadersMiddleware: Middleware {
    public let id: String = "GetEventPredictionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetEventPredictionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetEventPredictionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetEventPredictionInput>
    public typealias MOutput = OperationOutput<GetEventPredictionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetEventPredictionOutputError>
}

public struct GetEventPredictionInputQueryItemMiddleware: Middleware {
    public let id: String = "GetEventPredictionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetEventPredictionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetEventPredictionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetEventPredictionInput>
    public typealias MOutput = OperationOutput<GetEventPredictionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetEventPredictionOutputError>
}

public struct GetEventPredictionInput: Equatable {
    /// <p>The detector ID.</p>
    public let detectorId: String?
    /// <p>The detector version ID.</p>
    public let detectorVersionId: String?
    /// <p>The entity type (associated with the detector's event type) and specific entity ID representing who performed the event. If an entity id is not available, use "UNKNOWN."</p>
    public let entities: [Entity]?
    /// <p>The unique ID used to identify the event.</p>
    public let eventId: String?
    /// <p>Timestamp that defines when the event under evaluation occurred.</p>
    public let eventTimestamp: String?
    /// <p>The event type associated with the detector specified for the prediction.</p>
    public let eventTypeName: String?
    /// <p>Names of the event type's variables you defined in Amazon Fraud Detector to represent data elements and their corresponding values for the event you are sending for evaluation.</p>
    public let eventVariables: [String:String]?
    /// <p>The Amazon SageMaker model endpoint input data blobs.</p>
    public let externalModelEndpointDataBlobs: [String:ModelEndpointDataBlob]?

    public init (
        detectorId: String? = nil,
        detectorVersionId: String? = nil,
        entities: [Entity]? = nil,
        eventId: String? = nil,
        eventTimestamp: String? = nil,
        eventTypeName: String? = nil,
        eventVariables: [String:String]? = nil,
        externalModelEndpointDataBlobs: [String:ModelEndpointDataBlob]? = nil
    )
    {
        self.detectorId = detectorId
        self.detectorVersionId = detectorVersionId
        self.entities = entities
        self.eventId = eventId
        self.eventTimestamp = eventTimestamp
        self.eventTypeName = eventTypeName
        self.eventVariables = eventVariables
        self.externalModelEndpointDataBlobs = externalModelEndpointDataBlobs
    }
}

struct GetEventPredictionInputBody: Equatable {
    public let detectorId: String?
    public let detectorVersionId: String?
    public let eventId: String?
    public let eventTypeName: String?
    public let entities: [Entity]?
    public let eventTimestamp: String?
    public let eventVariables: [String:String]?
    public let externalModelEndpointDataBlobs: [String:ModelEndpointDataBlob]?
}

extension GetEventPredictionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case detectorId
        case detectorVersionId
        case entities
        case eventId
        case eventTimestamp
        case eventTypeName
        case eventVariables
        case externalModelEndpointDataBlobs
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detectorIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .detectorId)
        detectorId = detectorIdDecoded
        let detectorVersionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .detectorVersionId)
        detectorVersionId = detectorVersionIdDecoded
        let eventIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventId)
        eventId = eventIdDecoded
        let eventTypeNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventTypeName)
        eventTypeName = eventTypeNameDecoded
        let entitiesContainer = try containerValues.decodeIfPresent([Entity?].self, forKey: .entities)
        var entitiesDecoded0:[Entity]? = nil
        if let entitiesContainer = entitiesContainer {
            entitiesDecoded0 = [Entity]()
            for structure0 in entitiesContainer {
                if let structure0 = structure0 {
                    entitiesDecoded0?.append(structure0)
                }
            }
        }
        entities = entitiesDecoded0
        let eventTimestampDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventTimestamp)
        eventTimestamp = eventTimestampDecoded
        let eventVariablesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .eventVariables)
        var eventVariablesDecoded0: [String:String]? = nil
        if let eventVariablesContainer = eventVariablesContainer {
            eventVariablesDecoded0 = [String:String]()
            for (key0, variablevalue0) in eventVariablesContainer {
                if let variablevalue0 = variablevalue0 {
                    eventVariablesDecoded0?[key0] = variablevalue0
                }
            }
        }
        eventVariables = eventVariablesDecoded0
        let externalModelEndpointDataBlobsContainer = try containerValues.decodeIfPresent([String: ModelEndpointDataBlob?].self, forKey: .externalModelEndpointDataBlobs)
        var externalModelEndpointDataBlobsDecoded0: [String:ModelEndpointDataBlob]? = nil
        if let externalModelEndpointDataBlobsContainer = externalModelEndpointDataBlobsContainer {
            externalModelEndpointDataBlobsDecoded0 = [String:ModelEndpointDataBlob]()
            for (key0, modelendpointdatablob0) in externalModelEndpointDataBlobsContainer {
                if let modelendpointdatablob0 = modelendpointdatablob0 {
                    externalModelEndpointDataBlobsDecoded0?[key0] = modelendpointdatablob0
                }
            }
        }
        externalModelEndpointDataBlobs = externalModelEndpointDataBlobsDecoded0
    }
}

extension GetEventPredictionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetEventPredictionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetEventPredictionOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetEventPredictionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetEventPredictionOutputResponse(modelScores: \(String(describing: modelScores)), ruleResults: \(String(describing: ruleResults)))"}
}

extension GetEventPredictionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetEventPredictionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.modelScores = output.modelScores
            self.ruleResults = output.ruleResults
        } else {
            self.modelScores = nil
            self.ruleResults = nil
        }
    }
}

public struct GetEventPredictionOutputResponse: Equatable {
    /// <p>The model scores. Amazon Fraud Detector generates model scores between 0 and 1000, where 0 is low fraud risk and 1000 is high fraud risk. Model scores are directly related to the false positive rate (FPR). For example, a score of 600 corresponds to an estimated 10% false positive rate whereas a score of 900 corresponds to an estimated 2% false positive rate.</p>
    public let modelScores: [ModelScores]?
    /// <p>The results.</p>
    public let ruleResults: [RuleResult]?

    public init (
        modelScores: [ModelScores]? = nil,
        ruleResults: [RuleResult]? = nil
    )
    {
        self.modelScores = modelScores
        self.ruleResults = ruleResults
    }
}

struct GetEventPredictionOutputResponseBody: Equatable {
    public let modelScores: [ModelScores]?
    public let ruleResults: [RuleResult]?
}

extension GetEventPredictionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case modelScores
        case ruleResults
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelScoresContainer = try containerValues.decodeIfPresent([ModelScores?].self, forKey: .modelScores)
        var modelScoresDecoded0:[ModelScores]? = nil
        if let modelScoresContainer = modelScoresContainer {
            modelScoresDecoded0 = [ModelScores]()
            for structure0 in modelScoresContainer {
                if let structure0 = structure0 {
                    modelScoresDecoded0?.append(structure0)
                }
            }
        }
        modelScores = modelScoresDecoded0
        let ruleResultsContainer = try containerValues.decodeIfPresent([RuleResult?].self, forKey: .ruleResults)
        var ruleResultsDecoded0:[RuleResult]? = nil
        if let ruleResultsContainer = ruleResultsContainer {
            ruleResultsDecoded0 = [RuleResult]()
            for structure0 in ruleResultsContainer {
                if let structure0 = structure0 {
                    ruleResultsDecoded0?.append(structure0)
                }
            }
        }
        ruleResults = ruleResultsDecoded0
    }
}

public struct GetEventTypesInputBodyMiddleware: Middleware {
    public let id: String = "GetEventTypesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetEventTypesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetEventTypesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetEventTypesInput>
    public typealias MOutput = OperationOutput<GetEventTypesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetEventTypesOutputError>
}

extension GetEventTypesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetEventTypesInput(maxResults: \(String(describing: maxResults)), name: \(String(describing: name)), nextToken: \(String(describing: nextToken)))"}
}

extension GetEventTypesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case name
        case nextToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct GetEventTypesInputHeadersMiddleware: Middleware {
    public let id: String = "GetEventTypesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetEventTypesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetEventTypesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetEventTypesInput>
    public typealias MOutput = OperationOutput<GetEventTypesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetEventTypesOutputError>
}

public struct GetEventTypesInputQueryItemMiddleware: Middleware {
    public let id: String = "GetEventTypesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetEventTypesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetEventTypesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetEventTypesInput>
    public typealias MOutput = OperationOutput<GetEventTypesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetEventTypesOutputError>
}

public struct GetEventTypesInput: Equatable {
    /// <p>The maximum number of objects to return for the request.</p>
    public let maxResults: Int?
    /// <p>The name.</p>
    public let name: String?
    /// <p>The next token for the subsequent request.</p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        name: String? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.name = name
        self.nextToken = nextToken
    }
}

struct GetEventTypesInputBody: Equatable {
    public let name: String?
    public let nextToken: String?
    public let maxResults: Int?
}

extension GetEventTypesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case name
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension GetEventTypesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetEventTypesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetEventTypesOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetEventTypesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetEventTypesOutputResponse(eventTypes: \(String(describing: eventTypes)), nextToken: \(String(describing: nextToken)))"}
}

extension GetEventTypesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetEventTypesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.eventTypes = output.eventTypes
            self.nextToken = output.nextToken
        } else {
            self.eventTypes = nil
            self.nextToken = nil
        }
    }
}

public struct GetEventTypesOutputResponse: Equatable {
    /// <p>An array of event types.</p>
    public let eventTypes: [EventType]?
    /// <p>The next page token.</p>
    public let nextToken: String?

    public init (
        eventTypes: [EventType]? = nil,
        nextToken: String? = nil
    )
    {
        self.eventTypes = eventTypes
        self.nextToken = nextToken
    }
}

struct GetEventTypesOutputResponseBody: Equatable {
    public let eventTypes: [EventType]?
    public let nextToken: String?
}

extension GetEventTypesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case eventTypes
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventTypesContainer = try containerValues.decodeIfPresent([EventType?].self, forKey: .eventTypes)
        var eventTypesDecoded0:[EventType]? = nil
        if let eventTypesContainer = eventTypesContainer {
            eventTypesDecoded0 = [EventType]()
            for structure0 in eventTypesContainer {
                if let structure0 = structure0 {
                    eventTypesDecoded0?.append(structure0)
                }
            }
        }
        eventTypes = eventTypesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct GetExternalModelsInputBodyMiddleware: Middleware {
    public let id: String = "GetExternalModelsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetExternalModelsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetExternalModelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetExternalModelsInput>
    public typealias MOutput = OperationOutput<GetExternalModelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetExternalModelsOutputError>
}

extension GetExternalModelsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetExternalModelsInput(maxResults: \(String(describing: maxResults)), modelEndpoint: \(String(describing: modelEndpoint)), nextToken: \(String(describing: nextToken)))"}
}

extension GetExternalModelsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case modelEndpoint
        case nextToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let modelEndpoint = modelEndpoint {
            try encodeContainer.encode(modelEndpoint, forKey: .modelEndpoint)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct GetExternalModelsInputHeadersMiddleware: Middleware {
    public let id: String = "GetExternalModelsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetExternalModelsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetExternalModelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetExternalModelsInput>
    public typealias MOutput = OperationOutput<GetExternalModelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetExternalModelsOutputError>
}

public struct GetExternalModelsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetExternalModelsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetExternalModelsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetExternalModelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetExternalModelsInput>
    public typealias MOutput = OperationOutput<GetExternalModelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetExternalModelsOutputError>
}

public struct GetExternalModelsInput: Equatable {
    /// <p>The maximum number of objects to return for the request.</p>
    public let maxResults: Int?
    /// <p>The Amazon SageMaker model endpoint.</p>
    public let modelEndpoint: String?
    /// <p>The next page token for the request.</p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        modelEndpoint: String? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.modelEndpoint = modelEndpoint
        self.nextToken = nextToken
    }
}

struct GetExternalModelsInputBody: Equatable {
    public let modelEndpoint: String?
    public let nextToken: String?
    public let maxResults: Int?
}

extension GetExternalModelsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case modelEndpoint
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelEndpointDecoded = try containerValues.decodeIfPresent(String.self, forKey: .modelEndpoint)
        modelEndpoint = modelEndpointDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension GetExternalModelsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetExternalModelsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetExternalModelsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetExternalModelsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetExternalModelsOutputResponse(externalModels: \(String(describing: externalModels)), nextToken: \(String(describing: nextToken)))"}
}

extension GetExternalModelsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetExternalModelsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.externalModels = output.externalModels
            self.nextToken = output.nextToken
        } else {
            self.externalModels = nil
            self.nextToken = nil
        }
    }
}

public struct GetExternalModelsOutputResponse: Equatable {
    /// <p>Gets the Amazon SageMaker models.</p>
    public let externalModels: [ExternalModel]?
    /// <p>The next page token to be used in subsequent requests.</p>
    public let nextToken: String?

    public init (
        externalModels: [ExternalModel]? = nil,
        nextToken: String? = nil
    )
    {
        self.externalModels = externalModels
        self.nextToken = nextToken
    }
}

struct GetExternalModelsOutputResponseBody: Equatable {
    public let externalModels: [ExternalModel]?
    public let nextToken: String?
}

extension GetExternalModelsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case externalModels
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let externalModelsContainer = try containerValues.decodeIfPresent([ExternalModel?].self, forKey: .externalModels)
        var externalModelsDecoded0:[ExternalModel]? = nil
        if let externalModelsContainer = externalModelsContainer {
            externalModelsDecoded0 = [ExternalModel]()
            for structure0 in externalModelsContainer {
                if let structure0 = structure0 {
                    externalModelsDecoded0?.append(structure0)
                }
            }
        }
        externalModels = externalModelsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetKMSEncryptionKeyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetKMSEncryptionKeyInput()"}
}

extension GetKMSEncryptionKeyInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetKMSEncryptionKeyInputHeadersMiddleware: Middleware {
    public let id: String = "GetKMSEncryptionKeyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetKMSEncryptionKeyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetKMSEncryptionKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetKMSEncryptionKeyInput>
    public typealias MOutput = OperationOutput<GetKMSEncryptionKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetKMSEncryptionKeyOutputError>
}

public struct GetKMSEncryptionKeyInputQueryItemMiddleware: Middleware {
    public let id: String = "GetKMSEncryptionKeyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetKMSEncryptionKeyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetKMSEncryptionKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetKMSEncryptionKeyInput>
    public typealias MOutput = OperationOutput<GetKMSEncryptionKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetKMSEncryptionKeyOutputError>
}

public struct GetKMSEncryptionKeyInput: Equatable {

    public init() {}
}

struct GetKMSEncryptionKeyInputBody: Equatable {
}

extension GetKMSEncryptionKeyInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetKMSEncryptionKeyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetKMSEncryptionKeyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetKMSEncryptionKeyOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetKMSEncryptionKeyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetKMSEncryptionKeyOutputResponse(kmsKey: \(String(describing: kmsKey)))"}
}

extension GetKMSEncryptionKeyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetKMSEncryptionKeyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.kmsKey = output.kmsKey
        } else {
            self.kmsKey = nil
        }
    }
}

public struct GetKMSEncryptionKeyOutputResponse: Equatable {
    /// <p>The KMS encryption key.</p>
    public let kmsKey: KMSKey?

    public init (
        kmsKey: KMSKey? = nil
    )
    {
        self.kmsKey = kmsKey
    }
}

struct GetKMSEncryptionKeyOutputResponseBody: Equatable {
    public let kmsKey: KMSKey?
}

extension GetKMSEncryptionKeyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case kmsKey
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let kmsKeyDecoded = try containerValues.decodeIfPresent(KMSKey.self, forKey: .kmsKey)
        kmsKey = kmsKeyDecoded
    }
}

public struct GetLabelsInputBodyMiddleware: Middleware {
    public let id: String = "GetLabelsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetLabelsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetLabelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetLabelsInput>
    public typealias MOutput = OperationOutput<GetLabelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetLabelsOutputError>
}

extension GetLabelsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetLabelsInput(maxResults: \(String(describing: maxResults)), name: \(String(describing: name)), nextToken: \(String(describing: nextToken)))"}
}

extension GetLabelsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case name
        case nextToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct GetLabelsInputHeadersMiddleware: Middleware {
    public let id: String = "GetLabelsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetLabelsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetLabelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetLabelsInput>
    public typealias MOutput = OperationOutput<GetLabelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetLabelsOutputError>
}

public struct GetLabelsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetLabelsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetLabelsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetLabelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetLabelsInput>
    public typealias MOutput = OperationOutput<GetLabelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetLabelsOutputError>
}

public struct GetLabelsInput: Equatable {
    /// <p>The maximum number of objects to return for the request.</p>
    public let maxResults: Int?
    /// <p>The name of the label or labels to get.</p>
    public let name: String?
    /// <p>The next token for the subsequent request.</p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        name: String? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.name = name
        self.nextToken = nextToken
    }
}

struct GetLabelsInputBody: Equatable {
    public let name: String?
    public let nextToken: String?
    public let maxResults: Int?
}

extension GetLabelsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case name
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension GetLabelsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetLabelsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetLabelsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetLabelsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetLabelsOutputResponse(labels: \(String(describing: labels)), nextToken: \(String(describing: nextToken)))"}
}

extension GetLabelsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetLabelsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.labels = output.labels
            self.nextToken = output.nextToken
        } else {
            self.labels = nil
            self.nextToken = nil
        }
    }
}

public struct GetLabelsOutputResponse: Equatable {
    /// <p>An array of labels.</p>
    public let labels: [Label]?
    /// <p>The next page token.</p>
    public let nextToken: String?

    public init (
        labels: [Label]? = nil,
        nextToken: String? = nil
    )
    {
        self.labels = labels
        self.nextToken = nextToken
    }
}

struct GetLabelsOutputResponseBody: Equatable {
    public let labels: [Label]?
    public let nextToken: String?
}

extension GetLabelsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case labels
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let labelsContainer = try containerValues.decodeIfPresent([Label?].self, forKey: .labels)
        var labelsDecoded0:[Label]? = nil
        if let labelsContainer = labelsContainer {
            labelsDecoded0 = [Label]()
            for structure0 in labelsContainer {
                if let structure0 = structure0 {
                    labelsDecoded0?.append(structure0)
                }
            }
        }
        labels = labelsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct GetModelVersionInputBodyMiddleware: Middleware {
    public let id: String = "GetModelVersionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetModelVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetModelVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetModelVersionInput>
    public typealias MOutput = OperationOutput<GetModelVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetModelVersionOutputError>
}

extension GetModelVersionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetModelVersionInput(modelId: \(String(describing: modelId)), modelType: \(String(describing: modelType)), modelVersionNumber: \(String(describing: modelVersionNumber)))"}
}

extension GetModelVersionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case modelId
        case modelType
        case modelVersionNumber
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let modelId = modelId {
            try encodeContainer.encode(modelId, forKey: .modelId)
        }
        if let modelType = modelType {
            try encodeContainer.encode(modelType.rawValue, forKey: .modelType)
        }
        if let modelVersionNumber = modelVersionNumber {
            try encodeContainer.encode(modelVersionNumber, forKey: .modelVersionNumber)
        }
    }
}

public struct GetModelVersionInputHeadersMiddleware: Middleware {
    public let id: String = "GetModelVersionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetModelVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetModelVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetModelVersionInput>
    public typealias MOutput = OperationOutput<GetModelVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetModelVersionOutputError>
}

public struct GetModelVersionInputQueryItemMiddleware: Middleware {
    public let id: String = "GetModelVersionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetModelVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetModelVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetModelVersionInput>
    public typealias MOutput = OperationOutput<GetModelVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetModelVersionOutputError>
}

public struct GetModelVersionInput: Equatable {
    /// <p>The model ID.</p>
    public let modelId: String?
    /// <p>The model type.</p>
    public let modelType: ModelTypeEnum?
    /// <p>The model version number.</p>
    public let modelVersionNumber: String?

    public init (
        modelId: String? = nil,
        modelType: ModelTypeEnum? = nil,
        modelVersionNumber: String? = nil
    )
    {
        self.modelId = modelId
        self.modelType = modelType
        self.modelVersionNumber = modelVersionNumber
    }
}

struct GetModelVersionInputBody: Equatable {
    public let modelId: String?
    public let modelType: ModelTypeEnum?
    public let modelVersionNumber: String?
}

extension GetModelVersionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case modelId
        case modelType
        case modelVersionNumber
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .modelId)
        modelId = modelIdDecoded
        let modelTypeDecoded = try containerValues.decodeIfPresent(ModelTypeEnum.self, forKey: .modelType)
        modelType = modelTypeDecoded
        let modelVersionNumberDecoded = try containerValues.decodeIfPresent(String.self, forKey: .modelVersionNumber)
        modelVersionNumber = modelVersionNumberDecoded
    }
}

extension GetModelVersionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetModelVersionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetModelVersionOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetModelVersionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetModelVersionOutputResponse(arn: \(String(describing: arn)), externalEventsDetail: \(String(describing: externalEventsDetail)), modelId: \(String(describing: modelId)), modelType: \(String(describing: modelType)), modelVersionNumber: \(String(describing: modelVersionNumber)), status: \(String(describing: status)), trainingDataSchema: \(String(describing: trainingDataSchema)), trainingDataSource: \(String(describing: trainingDataSource)))"}
}

extension GetModelVersionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetModelVersionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.externalEventsDetail = output.externalEventsDetail
            self.modelId = output.modelId
            self.modelType = output.modelType
            self.modelVersionNumber = output.modelVersionNumber
            self.status = output.status
            self.trainingDataSchema = output.trainingDataSchema
            self.trainingDataSource = output.trainingDataSource
        } else {
            self.arn = nil
            self.externalEventsDetail = nil
            self.modelId = nil
            self.modelType = nil
            self.modelVersionNumber = nil
            self.status = nil
            self.trainingDataSchema = nil
            self.trainingDataSource = nil
        }
    }
}

public struct GetModelVersionOutputResponse: Equatable {
    /// <p>The model version ARN.</p>
    public let arn: String?
    /// <p>The event details.</p>
    public let externalEventsDetail: ExternalEventsDetail?
    /// <p>The model ID.</p>
    public let modelId: String?
    /// <p>The model type.</p>
    public let modelType: ModelTypeEnum?
    /// <p>The model version number.</p>
    public let modelVersionNumber: String?
    /// <p>The model version status.</p>
    /// 	        <p>Possible values are:</p>
    /// 	        <ul>
    ///             <li>
    ///                <p>
    ///                   <code>TRAINING_IN_PROGRESS</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>TRAINING_COMPLETE</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>ACTIVATE_REQUESTED</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>ACTIVATE_IN_PROGRESS</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>ACTIVE</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>INACTIVATE_REQUESTED</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>INACTIVATE_IN_PROGRESS</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>INACTIVE</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>ERROR</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let status: String?
    /// <p>The training data schema.</p>
    public let trainingDataSchema: TrainingDataSchema?
    /// <p>The training data source.</p>
    public let trainingDataSource: TrainingDataSourceEnum?

    public init (
        arn: String? = nil,
        externalEventsDetail: ExternalEventsDetail? = nil,
        modelId: String? = nil,
        modelType: ModelTypeEnum? = nil,
        modelVersionNumber: String? = nil,
        status: String? = nil,
        trainingDataSchema: TrainingDataSchema? = nil,
        trainingDataSource: TrainingDataSourceEnum? = nil
    )
    {
        self.arn = arn
        self.externalEventsDetail = externalEventsDetail
        self.modelId = modelId
        self.modelType = modelType
        self.modelVersionNumber = modelVersionNumber
        self.status = status
        self.trainingDataSchema = trainingDataSchema
        self.trainingDataSource = trainingDataSource
    }
}

struct GetModelVersionOutputResponseBody: Equatable {
    public let modelId: String?
    public let modelType: ModelTypeEnum?
    public let modelVersionNumber: String?
    public let trainingDataSource: TrainingDataSourceEnum?
    public let trainingDataSchema: TrainingDataSchema?
    public let externalEventsDetail: ExternalEventsDetail?
    public let status: String?
    public let arn: String?
}

extension GetModelVersionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn
        case externalEventsDetail
        case modelId
        case modelType
        case modelVersionNumber
        case status
        case trainingDataSchema
        case trainingDataSource
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .modelId)
        modelId = modelIdDecoded
        let modelTypeDecoded = try containerValues.decodeIfPresent(ModelTypeEnum.self, forKey: .modelType)
        modelType = modelTypeDecoded
        let modelVersionNumberDecoded = try containerValues.decodeIfPresent(String.self, forKey: .modelVersionNumber)
        modelVersionNumber = modelVersionNumberDecoded
        let trainingDataSourceDecoded = try containerValues.decodeIfPresent(TrainingDataSourceEnum.self, forKey: .trainingDataSource)
        trainingDataSource = trainingDataSourceDecoded
        let trainingDataSchemaDecoded = try containerValues.decodeIfPresent(TrainingDataSchema.self, forKey: .trainingDataSchema)
        trainingDataSchema = trainingDataSchemaDecoded
        let externalEventsDetailDecoded = try containerValues.decodeIfPresent(ExternalEventsDetail.self, forKey: .externalEventsDetail)
        externalEventsDetail = externalEventsDetailDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
    }
}

public struct GetModelsInputBodyMiddleware: Middleware {
    public let id: String = "GetModelsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetModelsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetModelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetModelsInput>
    public typealias MOutput = OperationOutput<GetModelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetModelsOutputError>
}

extension GetModelsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetModelsInput(maxResults: \(String(describing: maxResults)), modelId: \(String(describing: modelId)), modelType: \(String(describing: modelType)), nextToken: \(String(describing: nextToken)))"}
}

extension GetModelsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case modelId
        case modelType
        case nextToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let modelId = modelId {
            try encodeContainer.encode(modelId, forKey: .modelId)
        }
        if let modelType = modelType {
            try encodeContainer.encode(modelType.rawValue, forKey: .modelType)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct GetModelsInputHeadersMiddleware: Middleware {
    public let id: String = "GetModelsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetModelsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetModelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetModelsInput>
    public typealias MOutput = OperationOutput<GetModelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetModelsOutputError>
}

public struct GetModelsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetModelsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetModelsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetModelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetModelsInput>
    public typealias MOutput = OperationOutput<GetModelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetModelsOutputError>
}

public struct GetModelsInput: Equatable {
    /// <p>The maximum number of objects to return for the request. </p>
    public let maxResults: Int?
    /// <p>The model ID.</p>
    public let modelId: String?
    /// <p>The model type.</p>
    public let modelType: ModelTypeEnum?
    /// <p>The next token for the subsequent request.</p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        modelId: String? = nil,
        modelType: ModelTypeEnum? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.modelId = modelId
        self.modelType = modelType
        self.nextToken = nextToken
    }
}

struct GetModelsInputBody: Equatable {
    public let modelId: String?
    public let modelType: ModelTypeEnum?
    public let nextToken: String?
    public let maxResults: Int?
}

extension GetModelsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case modelId
        case modelType
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .modelId)
        modelId = modelIdDecoded
        let modelTypeDecoded = try containerValues.decodeIfPresent(ModelTypeEnum.self, forKey: .modelType)
        modelType = modelTypeDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension GetModelsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetModelsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetModelsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetModelsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetModelsOutputResponse(models: \(String(describing: models)), nextToken: \(String(describing: nextToken)))"}
}

extension GetModelsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetModelsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.models = output.models
            self.nextToken = output.nextToken
        } else {
            self.models = nil
            self.nextToken = nil
        }
    }
}

public struct GetModelsOutputResponse: Equatable {
    /// <p>The array of models.</p>
    public let models: [Model]?
    /// <p>The next page token to be used in subsequent requests.</p>
    public let nextToken: String?

    public init (
        models: [Model]? = nil,
        nextToken: String? = nil
    )
    {
        self.models = models
        self.nextToken = nextToken
    }
}

struct GetModelsOutputResponseBody: Equatable {
    public let nextToken: String?
    public let models: [Model]?
}

extension GetModelsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case models
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let modelsContainer = try containerValues.decodeIfPresent([Model?].self, forKey: .models)
        var modelsDecoded0:[Model]? = nil
        if let modelsContainer = modelsContainer {
            modelsDecoded0 = [Model]()
            for structure0 in modelsContainer {
                if let structure0 = structure0 {
                    modelsDecoded0?.append(structure0)
                }
            }
        }
        models = modelsDecoded0
    }
}

public struct GetOutcomesInputBodyMiddleware: Middleware {
    public let id: String = "GetOutcomesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetOutcomesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetOutcomesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetOutcomesInput>
    public typealias MOutput = OperationOutput<GetOutcomesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetOutcomesOutputError>
}

extension GetOutcomesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetOutcomesInput(maxResults: \(String(describing: maxResults)), name: \(String(describing: name)), nextToken: \(String(describing: nextToken)))"}
}

extension GetOutcomesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case name
        case nextToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct GetOutcomesInputHeadersMiddleware: Middleware {
    public let id: String = "GetOutcomesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetOutcomesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetOutcomesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetOutcomesInput>
    public typealias MOutput = OperationOutput<GetOutcomesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetOutcomesOutputError>
}

public struct GetOutcomesInputQueryItemMiddleware: Middleware {
    public let id: String = "GetOutcomesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetOutcomesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetOutcomesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetOutcomesInput>
    public typealias MOutput = OperationOutput<GetOutcomesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetOutcomesOutputError>
}

public struct GetOutcomesInput: Equatable {
    /// <p>The maximum number of objects to return for the request. </p>
    public let maxResults: Int?
    /// <p>The name of the outcome or outcomes to get.</p>
    public let name: String?
    /// <p>The next page token for the request. </p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        name: String? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.name = name
        self.nextToken = nextToken
    }
}

struct GetOutcomesInputBody: Equatable {
    public let name: String?
    public let nextToken: String?
    public let maxResults: Int?
}

extension GetOutcomesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case name
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension GetOutcomesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetOutcomesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetOutcomesOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetOutcomesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetOutcomesOutputResponse(nextToken: \(String(describing: nextToken)), outcomes: \(String(describing: outcomes)))"}
}

extension GetOutcomesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetOutcomesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.outcomes = output.outcomes
        } else {
            self.nextToken = nil
            self.outcomes = nil
        }
    }
}

public struct GetOutcomesOutputResponse: Equatable {
    /// <p>The next page token for subsequent requests.</p>
    public let nextToken: String?
    /// <p>The outcomes. </p>
    public let outcomes: [Outcome]?

    public init (
        nextToken: String? = nil,
        outcomes: [Outcome]? = nil
    )
    {
        self.nextToken = nextToken
        self.outcomes = outcomes
    }
}

struct GetOutcomesOutputResponseBody: Equatable {
    public let outcomes: [Outcome]?
    public let nextToken: String?
}

extension GetOutcomesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case outcomes
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let outcomesContainer = try containerValues.decodeIfPresent([Outcome?].self, forKey: .outcomes)
        var outcomesDecoded0:[Outcome]? = nil
        if let outcomesContainer = outcomesContainer {
            outcomesDecoded0 = [Outcome]()
            for structure0 in outcomesContainer {
                if let structure0 = structure0 {
                    outcomesDecoded0?.append(structure0)
                }
            }
        }
        outcomes = outcomesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct GetRulesInputBodyMiddleware: Middleware {
    public let id: String = "GetRulesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRulesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRulesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRulesInput>
    public typealias MOutput = OperationOutput<GetRulesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRulesOutputError>
}

extension GetRulesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetRulesInput(detectorId: \(String(describing: detectorId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), ruleId: \(String(describing: ruleId)), ruleVersion: \(String(describing: ruleVersion)))"}
}

extension GetRulesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case detectorId
        case maxResults
        case nextToken
        case ruleId
        case ruleVersion
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let detectorId = detectorId {
            try encodeContainer.encode(detectorId, forKey: .detectorId)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let ruleId = ruleId {
            try encodeContainer.encode(ruleId, forKey: .ruleId)
        }
        if let ruleVersion = ruleVersion {
            try encodeContainer.encode(ruleVersion, forKey: .ruleVersion)
        }
    }
}

public struct GetRulesInputHeadersMiddleware: Middleware {
    public let id: String = "GetRulesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRulesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRulesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRulesInput>
    public typealias MOutput = OperationOutput<GetRulesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRulesOutputError>
}

public struct GetRulesInputQueryItemMiddleware: Middleware {
    public let id: String = "GetRulesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRulesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRulesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRulesInput>
    public typealias MOutput = OperationOutput<GetRulesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRulesOutputError>
}

public struct GetRulesInput: Equatable {
    /// <p>The detector ID.</p>
    public let detectorId: String?
    /// <p>The maximum number of rules to return for the request.</p>
    public let maxResults: Int?
    /// <p>The next page token.</p>
    public let nextToken: String?
    /// <p>The rule ID.</p>
    public let ruleId: String?
    /// <p>The rule version.</p>
    public let ruleVersion: String?

    public init (
        detectorId: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        ruleId: String? = nil,
        ruleVersion: String? = nil
    )
    {
        self.detectorId = detectorId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.ruleId = ruleId
        self.ruleVersion = ruleVersion
    }
}

struct GetRulesInputBody: Equatable {
    public let ruleId: String?
    public let detectorId: String?
    public let ruleVersion: String?
    public let nextToken: String?
    public let maxResults: Int?
}

extension GetRulesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case detectorId
        case maxResults
        case nextToken
        case ruleId
        case ruleVersion
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ruleId)
        ruleId = ruleIdDecoded
        let detectorIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .detectorId)
        detectorId = detectorIdDecoded
        let ruleVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ruleVersion)
        ruleVersion = ruleVersionDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension GetRulesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetRulesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetRulesOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRulesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetRulesOutputResponse(nextToken: \(String(describing: nextToken)), ruleDetails: \(String(describing: ruleDetails)))"}
}

extension GetRulesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetRulesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.ruleDetails = output.ruleDetails
        } else {
            self.nextToken = nil
            self.ruleDetails = nil
        }
    }
}

public struct GetRulesOutputResponse: Equatable {
    /// <p>The next page token to be used in subsequent requests.</p>
    public let nextToken: String?
    /// <p>The details of the requested rule.</p>
    public let ruleDetails: [RuleDetail]?

    public init (
        nextToken: String? = nil,
        ruleDetails: [RuleDetail]? = nil
    )
    {
        self.nextToken = nextToken
        self.ruleDetails = ruleDetails
    }
}

struct GetRulesOutputResponseBody: Equatable {
    public let ruleDetails: [RuleDetail]?
    public let nextToken: String?
}

extension GetRulesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case ruleDetails
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleDetailsContainer = try containerValues.decodeIfPresent([RuleDetail?].self, forKey: .ruleDetails)
        var ruleDetailsDecoded0:[RuleDetail]? = nil
        if let ruleDetailsContainer = ruleDetailsContainer {
            ruleDetailsDecoded0 = [RuleDetail]()
            for structure0 in ruleDetailsContainer {
                if let structure0 = structure0 {
                    ruleDetailsDecoded0?.append(structure0)
                }
            }
        }
        ruleDetails = ruleDetailsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct GetVariablesInputBodyMiddleware: Middleware {
    public let id: String = "GetVariablesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetVariablesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetVariablesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetVariablesInput>
    public typealias MOutput = OperationOutput<GetVariablesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetVariablesOutputError>
}

extension GetVariablesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetVariablesInput(maxResults: \(String(describing: maxResults)), name: \(String(describing: name)), nextToken: \(String(describing: nextToken)))"}
}

extension GetVariablesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case name
        case nextToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct GetVariablesInputHeadersMiddleware: Middleware {
    public let id: String = "GetVariablesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetVariablesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetVariablesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetVariablesInput>
    public typealias MOutput = OperationOutput<GetVariablesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetVariablesOutputError>
}

public struct GetVariablesInputQueryItemMiddleware: Middleware {
    public let id: String = "GetVariablesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetVariablesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetVariablesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetVariablesInput>
    public typealias MOutput = OperationOutput<GetVariablesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetVariablesOutputError>
}

public struct GetVariablesInput: Equatable {
    /// <p>The max size per page determined for the get variable request. </p>
    public let maxResults: Int?
    /// <p>The name of the variable. </p>
    public let name: String?
    /// <p>The next page token of the get variable request. </p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        name: String? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.name = name
        self.nextToken = nextToken
    }
}

struct GetVariablesInputBody: Equatable {
    public let name: String?
    public let nextToken: String?
    public let maxResults: Int?
}

extension GetVariablesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case name
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension GetVariablesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetVariablesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetVariablesOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetVariablesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetVariablesOutputResponse(nextToken: \(String(describing: nextToken)), variables: \(String(describing: variables)))"}
}

extension GetVariablesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetVariablesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.variables = output.variables
        } else {
            self.nextToken = nil
            self.variables = nil
        }
    }
}

public struct GetVariablesOutputResponse: Equatable {
    /// <p>The next page token to be used in subsequent requests. </p>
    public let nextToken: String?
    /// <p>The names of the variables returned. </p>
    public let variables: [Variable]?

    public init (
        nextToken: String? = nil,
        variables: [Variable]? = nil
    )
    {
        self.nextToken = nextToken
        self.variables = variables
    }
}

struct GetVariablesOutputResponseBody: Equatable {
    public let variables: [Variable]?
    public let nextToken: String?
}

extension GetVariablesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case variables
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let variablesContainer = try containerValues.decodeIfPresent([Variable?].self, forKey: .variables)
        var variablesDecoded0:[Variable]? = nil
        if let variablesContainer = variablesContainer {
            variablesDecoded0 = [Variable]()
            for structure0 in variablesContainer {
                if let structure0 = structure0 {
                    variablesDecoded0?.append(structure0)
                }
            }
        }
        variables = variablesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension InternalServerException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalServerException(message: \(String(describing: message)))"}
}

extension InternalServerException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An exception indicating an internal server error.</p>
public struct InternalServerException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Equatable {
    public let message: String?
}

extension InternalServerExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KMSKey: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case kmsEncryptionKeyArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kmsEncryptionKeyArn = kmsEncryptionKeyArn {
            try encodeContainer.encode(kmsEncryptionKeyArn, forKey: .kmsEncryptionKeyArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let kmsEncryptionKeyArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsEncryptionKeyArn)
        kmsEncryptionKeyArn = kmsEncryptionKeyArnDecoded
    }
}

extension KMSKey: CustomDebugStringConvertible {
    public var debugDescription: String {
        "KMSKey(kmsEncryptionKeyArn: \(String(describing: kmsEncryptionKeyArn)))"}
}

/// <p>The KMS key details.</p>
public struct KMSKey: Equatable {
    /// <p>The encryption key ARN.</p>
    public let kmsEncryptionKeyArn: String?

    public init (
        kmsEncryptionKeyArn: String? = nil
    )
    {
        self.kmsEncryptionKeyArn = kmsEncryptionKeyArn
    }
}

extension Label: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case createdTime
        case description
        case lastUpdatedTime
        case name
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime, forKey: .createdTime)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let lastUpdatedTime = lastUpdatedTime {
            try encodeContainer.encode(lastUpdatedTime, forKey: .lastUpdatedTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension Label: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Label(arn: \(String(describing: arn)), createdTime: \(String(describing: createdTime)), description: \(String(describing: description)), lastUpdatedTime: \(String(describing: lastUpdatedTime)), name: \(String(describing: name)))"}
}

/// <p>The label details.</p>
public struct Label: Equatable {
    /// <p>The label ARN.</p>
    public let arn: String?
    /// <p>Timestamp of when the event type was created.</p>
    public let createdTime: String?
    /// <p>The label description.</p>
    public let description: String?
    /// <p>Timestamp of when the label was last updated.</p>
    public let lastUpdatedTime: String?
    /// <p>The label name.</p>
    public let name: String?

    public init (
        arn: String? = nil,
        createdTime: String? = nil,
        description: String? = nil,
        lastUpdatedTime: String? = nil,
        name: String? = nil
    )
    {
        self.arn = arn
        self.createdTime = createdTime
        self.description = description
        self.lastUpdatedTime = lastUpdatedTime
        self.name = name
    }
}

extension LabelSchema: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case labelMapper
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let labelMapper = labelMapper {
            var labelMapperContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .labelMapper)
            for (dictKey0, labelmapper0) in labelMapper {
                try labelMapperContainer.encode(labelmapper0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let labelMapperContainer = try containerValues.decodeIfPresent([String: [String?]?].self, forKey: .labelMapper)
        var labelMapperDecoded0: [String:[String]]? = nil
        if let labelMapperContainer = labelMapperContainer {
            labelMapperDecoded0 = [String:[String]]()
            for (key0, listofstrings0) in labelMapperContainer {
                var listofstrings0Decoded0: [String]? = nil
                if let listofstrings0 = listofstrings0 {
                    listofstrings0Decoded0 = [String]()
                    for string1 in listofstrings0 {
                        if let string1 = string1 {
                            listofstrings0Decoded0?.append(string1)
                        }
                    }
                }
                labelMapperDecoded0?[key0] = listofstrings0Decoded0
            }
        }
        labelMapper = labelMapperDecoded0
    }
}

extension LabelSchema: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LabelSchema(labelMapper: \(String(describing: labelMapper)))"}
}

/// <p>The label schema.</p>
public struct LabelSchema: Equatable {
    /// <p>The label mapper maps the Amazon Fraud Detector supported model classification labels (<code>FRAUD</code>, <code>LEGIT</code>) to the appropriate event type labels. For example, if "<code>FRAUD</code>" and "<code>LEGIT</code>" are Amazon Fraud Detector supported labels, this mapper could be: <code>{"FRAUD" => ["0"]</code>, <code>"LEGIT" => ["1"]}</code> or <code>{"FRAUD" => ["false"]</code>, <code>"LEGIT" => ["true"]}</code> or <code>{"FRAUD" => ["fraud", "abuse"]</code>, <code>"LEGIT" => ["legit", "safe"]}</code>. The value part of the mapper is a list, because you may have multiple label variants from your event type for a single Amazon Fraud Detector label.
    ///         </p>
    public let labelMapper: [String:[String]]?

    public init (
        labelMapper: [String:[String]]? = nil
    )
    {
        self.labelMapper = labelMapper
    }
}

public enum Language {
    case detectorpl
    case sdkUnknown(String)
}

extension Language : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Language] {
        return [
            .detectorpl,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .detectorpl: return "DETECTORPL"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Language(rawValue: rawValue) ?? Language.sdkUnknown(rawValue)
    }
}

public struct ListTagsForResourceInputBodyMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

extension ListTagsForResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), resourceARN: \(String(describing: resourceARN)))"}
}

extension ListTagsForResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case nextToken
        case resourceARN
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Equatable {
    /// <p>The maximum number of objects to return for the request. </p>
    public let maxResults: Int?
    /// <p>The next token from the previous results.</p>
    public let nextToken: String?
    /// <p>The ARN that specifies the resource whose tags you want to list.</p>
    public let resourceARN: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        resourceARN: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceARN = resourceARN
    }
}

struct ListTagsForResourceInputBody: Equatable {
    public let resourceARN: String?
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListTagsForResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case nextToken
        case resourceARN
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListTagsForResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceOutputResponse(nextToken: \(String(describing: nextToken)), tags: \(String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.tags = output.tags
        } else {
            self.nextToken = nil
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Equatable {
    /// <p>The next token for subsequent requests. </p>
    public let nextToken: String?
    /// <p>A collection of key and value pairs.</p>
    public let tags: [Tag]?

    public init (
        nextToken: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.nextToken = nextToken
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Equatable {
    public let tags: [Tag]?
    public let nextToken: String?
}

extension ListTagsForResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension MetricDataPoint: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case fpr
        case precision
        case threshold
        case tpr
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fpr = fpr {
            try encodeContainer.encode(fpr, forKey: .fpr)
        }
        if let precision = precision {
            try encodeContainer.encode(precision, forKey: .precision)
        }
        if let threshold = threshold {
            try encodeContainer.encode(threshold, forKey: .threshold)
        }
        if let tpr = tpr {
            try encodeContainer.encode(tpr, forKey: .tpr)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fprDecoded = try containerValues.decodeIfPresent(Float.self, forKey: .fpr)
        fpr = fprDecoded
        let precisionDecoded = try containerValues.decodeIfPresent(Float.self, forKey: .precision)
        precision = precisionDecoded
        let tprDecoded = try containerValues.decodeIfPresent(Float.self, forKey: .tpr)
        tpr = tprDecoded
        let thresholdDecoded = try containerValues.decodeIfPresent(Float.self, forKey: .threshold)
        threshold = thresholdDecoded
    }
}

extension MetricDataPoint: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MetricDataPoint(fpr: \(String(describing: fpr)), precision: \(String(describing: precision)), threshold: \(String(describing: threshold)), tpr: \(String(describing: tpr)))"}
}

/// <p>Model performance metrics data points.</p>
public struct MetricDataPoint: Equatable {
    /// <p>The false positive rate. This is the percentage of total legitimate events that are incorrectly predicted as fraud.</p>
    public let fpr: Float?
    /// <p>The percentage of fraud events correctly predicted as fraudulent as compared to all events predicted as fraudulent.</p>
    public let precision: Float?
    /// <p>The model threshold that specifies an acceptable fraud capture rate. For example, a threshold of 500 means any model score 500 or above is labeled as fraud.</p>
    public let threshold: Float?
    /// <p>The true positive rate. This is the percentage of total fraud the model detects. Also known as capture rate.</p>
    public let tpr: Float?

    public init (
        fpr: Float? = nil,
        precision: Float? = nil,
        threshold: Float? = nil,
        tpr: Float? = nil
    )
    {
        self.fpr = fpr
        self.precision = precision
        self.threshold = threshold
        self.tpr = tpr
    }
}

extension Model: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case createdTime
        case description
        case eventTypeName
        case lastUpdatedTime
        case modelId
        case modelType
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime, forKey: .createdTime)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let eventTypeName = eventTypeName {
            try encodeContainer.encode(eventTypeName, forKey: .eventTypeName)
        }
        if let lastUpdatedTime = lastUpdatedTime {
            try encodeContainer.encode(lastUpdatedTime, forKey: .lastUpdatedTime)
        }
        if let modelId = modelId {
            try encodeContainer.encode(modelId, forKey: .modelId)
        }
        if let modelType = modelType {
            try encodeContainer.encode(modelType.rawValue, forKey: .modelType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .modelId)
        modelId = modelIdDecoded
        let modelTypeDecoded = try containerValues.decodeIfPresent(ModelTypeEnum.self, forKey: .modelType)
        modelType = modelTypeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let eventTypeNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventTypeName)
        eventTypeName = eventTypeNameDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension Model: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Model(arn: \(String(describing: arn)), createdTime: \(String(describing: createdTime)), description: \(String(describing: description)), eventTypeName: \(String(describing: eventTypeName)), lastUpdatedTime: \(String(describing: lastUpdatedTime)), modelId: \(String(describing: modelId)), modelType: \(String(describing: modelType)))"}
}

/// <p>The model.</p>
public struct Model: Equatable {
    /// <p>The ARN of the model.</p>
    public let arn: String?
    /// <p>Timestamp of when the model was created.</p>
    public let createdTime: String?
    /// <p>The model description.</p>
    public let description: String?
    /// <p>The name of the event type.</p>
    public let eventTypeName: String?
    /// <p>Timestamp of last time the model was updated.</p>
    public let lastUpdatedTime: String?
    /// <p>The model ID.</p>
    public let modelId: String?
    /// <p>The model type.</p>
    public let modelType: ModelTypeEnum?

    public init (
        arn: String? = nil,
        createdTime: String? = nil,
        description: String? = nil,
        eventTypeName: String? = nil,
        lastUpdatedTime: String? = nil,
        modelId: String? = nil,
        modelType: ModelTypeEnum? = nil
    )
    {
        self.arn = arn
        self.createdTime = createdTime
        self.description = description
        self.eventTypeName = eventTypeName
        self.lastUpdatedTime = lastUpdatedTime
        self.modelId = modelId
        self.modelType = modelType
    }
}

extension ModelEndpointDataBlob: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case byteBuffer
        case contentType
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let byteBuffer = byteBuffer {
            try encodeContainer.encode(byteBuffer.base64EncodedString(), forKey: .byteBuffer)
        }
        if let contentType = contentType {
            try encodeContainer.encode(contentType, forKey: .contentType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let byteBufferDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .byteBuffer)
        byteBuffer = byteBufferDecoded
        let contentTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .contentType)
        contentType = contentTypeDecoded
    }
}

extension ModelEndpointDataBlob: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModelEndpointDataBlob(byteBuffer: \(String(describing: byteBuffer)), contentType: \(String(describing: contentType)))"}
}

/// <p>A pre-formed Amazon SageMaker model input you can include if your detector version includes an imported Amazon SageMaker model endpoint with pass-through input configuration.</p>
public struct ModelEndpointDataBlob: Equatable {
    /// <p>The byte buffer of the Amazon SageMaker model endpoint input data blob.</p>
    public let byteBuffer: Data?
    /// <p>The content type of the Amazon SageMaker model endpoint input data blob. </p>
    public let contentType: String?

    public init (
        byteBuffer: Data? = nil,
        contentType: String? = nil
    )
    {
        self.byteBuffer = byteBuffer
        self.contentType = contentType
    }
}

public enum ModelEndpointStatus {
    case associated
    case dissociated
    case sdkUnknown(String)
}

extension ModelEndpointStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ModelEndpointStatus] {
        return [
            .associated,
            .dissociated,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .associated: return "ASSOCIATED"
        case .dissociated: return "DISSOCIATED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ModelEndpointStatus(rawValue: rawValue) ?? ModelEndpointStatus.sdkUnknown(rawValue)
    }
}

extension ModelInputConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case csvInputTemplate
        case eventTypeName
        case format
        case jsonInputTemplate
        case useEventVariables
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let csvInputTemplate = csvInputTemplate {
            try encodeContainer.encode(csvInputTemplate, forKey: .csvInputTemplate)
        }
        if let eventTypeName = eventTypeName {
            try encodeContainer.encode(eventTypeName, forKey: .eventTypeName)
        }
        if let format = format {
            try encodeContainer.encode(format.rawValue, forKey: .format)
        }
        if let jsonInputTemplate = jsonInputTemplate {
            try encodeContainer.encode(jsonInputTemplate, forKey: .jsonInputTemplate)
        }
        if let useEventVariables = useEventVariables {
            try encodeContainer.encode(useEventVariables, forKey: .useEventVariables)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventTypeNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventTypeName)
        eventTypeName = eventTypeNameDecoded
        let formatDecoded = try containerValues.decodeIfPresent(ModelInputDataFormat.self, forKey: .format)
        format = formatDecoded
        let useEventVariablesDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .useEventVariables)
        useEventVariables = useEventVariablesDecoded
        let jsonInputTemplateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jsonInputTemplate)
        jsonInputTemplate = jsonInputTemplateDecoded
        let csvInputTemplateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .csvInputTemplate)
        csvInputTemplate = csvInputTemplateDecoded
    }
}

extension ModelInputConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModelInputConfiguration(csvInputTemplate: \(String(describing: csvInputTemplate)), eventTypeName: \(String(describing: eventTypeName)), format: \(String(describing: format)), jsonInputTemplate: \(String(describing: jsonInputTemplate)), useEventVariables: \(String(describing: useEventVariables)))"}
}

/// <p>The Amazon SageMaker model input configuration.</p>
public struct ModelInputConfiguration: Equatable {
    /// <p> Template for constructing the CSV input-data sent to SageMaker. At event-evaluation,
    ///             the placeholders for variable-names in the template will be replaced with the variable
    ///             values before being sent to SageMaker. </p>
    public let csvInputTemplate: String?
    /// <p>The event type name.</p>
    public let eventTypeName: String?
    /// <p> The format of the model input configuration. The format differs depending on if it is
    ///             passed through to SageMaker or constructed by Amazon Fraud Detector.</p>
    public let format: ModelInputDataFormat?
    /// <p> Template for constructing the JSON input-data sent to SageMaker. At event-evaluation,
    ///             the placeholders for variable names in the template will be replaced with the variable
    ///             values before being sent to SageMaker. </p>
    public let jsonInputTemplate: String?
    /// <p>The event variables.</p>
    public let useEventVariables: Bool?

    public init (
        csvInputTemplate: String? = nil,
        eventTypeName: String? = nil,
        format: ModelInputDataFormat? = nil,
        jsonInputTemplate: String? = nil,
        useEventVariables: Bool? = nil
    )
    {
        self.csvInputTemplate = csvInputTemplate
        self.eventTypeName = eventTypeName
        self.format = format
        self.jsonInputTemplate = jsonInputTemplate
        self.useEventVariables = useEventVariables
    }
}

public enum ModelInputDataFormat {
    case csv
    case json
    case sdkUnknown(String)
}

extension ModelInputDataFormat : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ModelInputDataFormat] {
        return [
            .csv,
            .json,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .csv: return "TEXT_CSV"
        case .json: return "APPLICATION_JSON"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ModelInputDataFormat(rawValue: rawValue) ?? ModelInputDataFormat.sdkUnknown(rawValue)
    }
}

extension ModelOutputConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case csvIndexToVariableMap
        case format
        case jsonKeyToVariableMap
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let csvIndexToVariableMap = csvIndexToVariableMap {
            var csvIndexToVariableMapContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .csvIndexToVariableMap)
            for (dictKey0, csvindextovariablemap0) in csvIndexToVariableMap {
                try csvIndexToVariableMapContainer.encode(csvindextovariablemap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let format = format {
            try encodeContainer.encode(format.rawValue, forKey: .format)
        }
        if let jsonKeyToVariableMap = jsonKeyToVariableMap {
            var jsonKeyToVariableMapContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .jsonKeyToVariableMap)
            for (dictKey0, jsonkeytovariablemap0) in jsonKeyToVariableMap {
                try jsonKeyToVariableMapContainer.encode(jsonkeytovariablemap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let formatDecoded = try containerValues.decodeIfPresent(ModelOutputDataFormat.self, forKey: .format)
        format = formatDecoded
        let jsonKeyToVariableMapContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .jsonKeyToVariableMap)
        var jsonKeyToVariableMapDecoded0: [String:String]? = nil
        if let jsonKeyToVariableMapContainer = jsonKeyToVariableMapContainer {
            jsonKeyToVariableMapDecoded0 = [String:String]()
            for (key0, string0) in jsonKeyToVariableMapContainer {
                if let string0 = string0 {
                    jsonKeyToVariableMapDecoded0?[key0] = string0
                }
            }
        }
        jsonKeyToVariableMap = jsonKeyToVariableMapDecoded0
        let csvIndexToVariableMapContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .csvIndexToVariableMap)
        var csvIndexToVariableMapDecoded0: [String:String]? = nil
        if let csvIndexToVariableMapContainer = csvIndexToVariableMapContainer {
            csvIndexToVariableMapDecoded0 = [String:String]()
            for (key0, string0) in csvIndexToVariableMapContainer {
                if let string0 = string0 {
                    csvIndexToVariableMapDecoded0?[key0] = string0
                }
            }
        }
        csvIndexToVariableMap = csvIndexToVariableMapDecoded0
    }
}

extension ModelOutputConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModelOutputConfiguration(csvIndexToVariableMap: \(String(describing: csvIndexToVariableMap)), format: \(String(describing: format)), jsonKeyToVariableMap: \(String(describing: jsonKeyToVariableMap)))"}
}

/// <p>Provides the Amazon Sagemaker model output configuration.</p>
public struct ModelOutputConfiguration: Equatable {
    /// <p>A map of CSV index values in the SageMaker response to the Amazon Fraud Detector variables. </p>
    public let csvIndexToVariableMap: [String:String]?
    /// <p>The format of the model output configuration.</p>
    public let format: ModelOutputDataFormat?
    /// <p>A map of JSON keys in response from SageMaker to the Amazon Fraud Detector variables. </p>
    public let jsonKeyToVariableMap: [String:String]?

    public init (
        csvIndexToVariableMap: [String:String]? = nil,
        format: ModelOutputDataFormat? = nil,
        jsonKeyToVariableMap: [String:String]? = nil
    )
    {
        self.csvIndexToVariableMap = csvIndexToVariableMap
        self.format = format
        self.jsonKeyToVariableMap = jsonKeyToVariableMap
    }
}

public enum ModelOutputDataFormat {
    case csv
    case jsonlines
    case sdkUnknown(String)
}

extension ModelOutputDataFormat : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ModelOutputDataFormat] {
        return [
            .csv,
            .jsonlines,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .csv: return "TEXT_CSV"
        case .jsonlines: return "APPLICATION_JSONLINES"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ModelOutputDataFormat(rawValue: rawValue) ?? ModelOutputDataFormat.sdkUnknown(rawValue)
    }
}

extension ModelScores: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case modelVersion
        case scores
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let modelVersion = modelVersion {
            try encodeContainer.encode(modelVersion, forKey: .modelVersion)
        }
        if let scores = scores {
            var scoresContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .scores)
            for (dictKey0, modelpredictionmap0) in scores {
                try scoresContainer.encode(modelpredictionmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelVersionDecoded = try containerValues.decodeIfPresent(ModelVersion.self, forKey: .modelVersion)
        modelVersion = modelVersionDecoded
        let scoresContainer = try containerValues.decodeIfPresent([String: Float?].self, forKey: .scores)
        var scoresDecoded0: [String:Float]? = nil
        if let scoresContainer = scoresContainer {
            scoresDecoded0 = [String:Float]()
            for (key0, float0) in scoresContainer {
                if let float0 = float0 {
                    scoresDecoded0?[key0] = float0
                }
            }
        }
        scores = scoresDecoded0
    }
}

extension ModelScores: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModelScores(modelVersion: \(String(describing: modelVersion)), scores: \(String(describing: scores)))"}
}

/// <p>The fraud prediction scores.</p>
public struct ModelScores: Equatable {
    /// <p>The model version.</p>
    public let modelVersion: ModelVersion?
    /// <p>The model's fraud prediction scores.</p>
    public let scores: [String:Float]?

    public init (
        modelVersion: ModelVersion? = nil,
        scores: [String:Float]? = nil
    )
    {
        self.modelVersion = modelVersion
        self.scores = scores
    }
}

public enum ModelSource {
    case sagemaker
    case sdkUnknown(String)
}

extension ModelSource : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ModelSource] {
        return [
            .sagemaker,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .sagemaker: return "SAGEMAKER"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ModelSource(rawValue: rawValue) ?? ModelSource.sdkUnknown(rawValue)
    }
}

public enum ModelTypeEnum {
    case onlineFraudInsights
    case sdkUnknown(String)
}

extension ModelTypeEnum : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ModelTypeEnum] {
        return [
            .onlineFraudInsights,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .onlineFraudInsights: return "ONLINE_FRAUD_INSIGHTS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ModelTypeEnum(rawValue: rawValue) ?? ModelTypeEnum.sdkUnknown(rawValue)
    }
}

extension ModelVersion: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case modelId
        case modelType
        case modelVersionNumber
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let modelId = modelId {
            try encodeContainer.encode(modelId, forKey: .modelId)
        }
        if let modelType = modelType {
            try encodeContainer.encode(modelType.rawValue, forKey: .modelType)
        }
        if let modelVersionNumber = modelVersionNumber {
            try encodeContainer.encode(modelVersionNumber, forKey: .modelVersionNumber)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .modelId)
        modelId = modelIdDecoded
        let modelTypeDecoded = try containerValues.decodeIfPresent(ModelTypeEnum.self, forKey: .modelType)
        modelType = modelTypeDecoded
        let modelVersionNumberDecoded = try containerValues.decodeIfPresent(String.self, forKey: .modelVersionNumber)
        modelVersionNumber = modelVersionNumberDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension ModelVersion: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModelVersion(arn: \(String(describing: arn)), modelId: \(String(describing: modelId)), modelType: \(String(describing: modelType)), modelVersionNumber: \(String(describing: modelVersionNumber)))"}
}

/// <p>The model version.</p>
public struct ModelVersion: Equatable {
    /// <p>The model version ARN.</p>
    public let arn: String?
    /// <p>The model ID.</p>
    public let modelId: String?
    /// <p>The model type.</p>
    public let modelType: ModelTypeEnum?
    /// <p>The model version number.</p>
    public let modelVersionNumber: String?

    public init (
        arn: String? = nil,
        modelId: String? = nil,
        modelType: ModelTypeEnum? = nil,
        modelVersionNumber: String? = nil
    )
    {
        self.arn = arn
        self.modelId = modelId
        self.modelType = modelType
        self.modelVersionNumber = modelVersionNumber
    }
}

extension ModelVersionDetail: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case createdTime
        case externalEventsDetail
        case lastUpdatedTime
        case modelId
        case modelType
        case modelVersionNumber
        case status
        case trainingDataSchema
        case trainingDataSource
        case trainingResult
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime, forKey: .createdTime)
        }
        if let externalEventsDetail = externalEventsDetail {
            try encodeContainer.encode(externalEventsDetail, forKey: .externalEventsDetail)
        }
        if let lastUpdatedTime = lastUpdatedTime {
            try encodeContainer.encode(lastUpdatedTime, forKey: .lastUpdatedTime)
        }
        if let modelId = modelId {
            try encodeContainer.encode(modelId, forKey: .modelId)
        }
        if let modelType = modelType {
            try encodeContainer.encode(modelType.rawValue, forKey: .modelType)
        }
        if let modelVersionNumber = modelVersionNumber {
            try encodeContainer.encode(modelVersionNumber, forKey: .modelVersionNumber)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let trainingDataSchema = trainingDataSchema {
            try encodeContainer.encode(trainingDataSchema, forKey: .trainingDataSchema)
        }
        if let trainingDataSource = trainingDataSource {
            try encodeContainer.encode(trainingDataSource.rawValue, forKey: .trainingDataSource)
        }
        if let trainingResult = trainingResult {
            try encodeContainer.encode(trainingResult, forKey: .trainingResult)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .modelId)
        modelId = modelIdDecoded
        let modelTypeDecoded = try containerValues.decodeIfPresent(ModelTypeEnum.self, forKey: .modelType)
        modelType = modelTypeDecoded
        let modelVersionNumberDecoded = try containerValues.decodeIfPresent(String.self, forKey: .modelVersionNumber)
        modelVersionNumber = modelVersionNumberDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let trainingDataSourceDecoded = try containerValues.decodeIfPresent(TrainingDataSourceEnum.self, forKey: .trainingDataSource)
        trainingDataSource = trainingDataSourceDecoded
        let trainingDataSchemaDecoded = try containerValues.decodeIfPresent(TrainingDataSchema.self, forKey: .trainingDataSchema)
        trainingDataSchema = trainingDataSchemaDecoded
        let externalEventsDetailDecoded = try containerValues.decodeIfPresent(ExternalEventsDetail.self, forKey: .externalEventsDetail)
        externalEventsDetail = externalEventsDetailDecoded
        let trainingResultDecoded = try containerValues.decodeIfPresent(TrainingResult.self, forKey: .trainingResult)
        trainingResult = trainingResultDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension ModelVersionDetail: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModelVersionDetail(arn: \(String(describing: arn)), createdTime: \(String(describing: createdTime)), externalEventsDetail: \(String(describing: externalEventsDetail)), lastUpdatedTime: \(String(describing: lastUpdatedTime)), modelId: \(String(describing: modelId)), modelType: \(String(describing: modelType)), modelVersionNumber: \(String(describing: modelVersionNumber)), status: \(String(describing: status)), trainingDataSchema: \(String(describing: trainingDataSchema)), trainingDataSource: \(String(describing: trainingDataSource)), trainingResult: \(String(describing: trainingResult)))"}
}

/// <p>The details of the model version.</p>
public struct ModelVersionDetail: Equatable {
    /// <p>The model version ARN.</p>
    public let arn: String?
    /// <p>The timestamp when the model was created.</p>
    public let createdTime: String?
    /// <p>The event details.</p>
    public let externalEventsDetail: ExternalEventsDetail?
    /// <p>The timestamp when the model was last updated.</p>
    public let lastUpdatedTime: String?
    /// <p>The model ID.</p>
    public let modelId: String?
    /// <p>The model type.</p>
    public let modelType: ModelTypeEnum?
    /// <p>The model version number.</p>
    public let modelVersionNumber: String?
    /// <p>The status of the model version.</p>
    public let status: String?
    /// <p>The training data schema.</p>
    public let trainingDataSchema: TrainingDataSchema?
    /// <p>The model version training data source.</p>
    public let trainingDataSource: TrainingDataSourceEnum?
    /// <p>The training results.</p>
    public let trainingResult: TrainingResult?

    public init (
        arn: String? = nil,
        createdTime: String? = nil,
        externalEventsDetail: ExternalEventsDetail? = nil,
        lastUpdatedTime: String? = nil,
        modelId: String? = nil,
        modelType: ModelTypeEnum? = nil,
        modelVersionNumber: String? = nil,
        status: String? = nil,
        trainingDataSchema: TrainingDataSchema? = nil,
        trainingDataSource: TrainingDataSourceEnum? = nil,
        trainingResult: TrainingResult? = nil
    )
    {
        self.arn = arn
        self.createdTime = createdTime
        self.externalEventsDetail = externalEventsDetail
        self.lastUpdatedTime = lastUpdatedTime
        self.modelId = modelId
        self.modelType = modelType
        self.modelVersionNumber = modelVersionNumber
        self.status = status
        self.trainingDataSchema = trainingDataSchema
        self.trainingDataSource = trainingDataSource
        self.trainingResult = trainingResult
    }
}

public enum ModelVersionStatus {
    case active
    case inactive
    case trainingCancelled
    case sdkUnknown(String)
}

extension ModelVersionStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ModelVersionStatus] {
        return [
            .active,
            .inactive,
            .trainingCancelled,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .active: return "ACTIVE"
        case .inactive: return "INACTIVE"
        case .trainingCancelled: return "TRAINING_CANCELLED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ModelVersionStatus(rawValue: rawValue) ?? ModelVersionStatus.sdkUnknown(rawValue)
    }
}

extension Outcome: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case createdTime
        case description
        case lastUpdatedTime
        case name
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime, forKey: .createdTime)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let lastUpdatedTime = lastUpdatedTime {
            try encodeContainer.encode(lastUpdatedTime, forKey: .lastUpdatedTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension Outcome: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Outcome(arn: \(String(describing: arn)), createdTime: \(String(describing: createdTime)), description: \(String(describing: description)), lastUpdatedTime: \(String(describing: lastUpdatedTime)), name: \(String(describing: name)))"}
}

/// <p>The outcome.</p>
public struct Outcome: Equatable {
    /// <p>The outcome ARN.</p>
    public let arn: String?
    /// <p>The timestamp when the outcome was created.</p>
    public let createdTime: String?
    /// <p>The outcome description.</p>
    public let description: String?
    /// <p>The timestamp when the outcome was last updated.</p>
    public let lastUpdatedTime: String?
    /// <p>The outcome name.</p>
    public let name: String?

    public init (
        arn: String? = nil,
        createdTime: String? = nil,
        description: String? = nil,
        lastUpdatedTime: String? = nil,
        name: String? = nil
    )
    {
        self.arn = arn
        self.createdTime = createdTime
        self.description = description
        self.lastUpdatedTime = lastUpdatedTime
        self.name = name
    }
}

public struct PutDetectorInputBodyMiddleware: Middleware {
    public let id: String = "PutDetectorInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutDetectorInput>,
                  next: H) -> Swift.Result<OperationOutput<PutDetectorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutDetectorInput>
    public typealias MOutput = OperationOutput<PutDetectorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutDetectorOutputError>
}

extension PutDetectorInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutDetectorInput(description: \(String(describing: description)), detectorId: \(String(describing: detectorId)), eventTypeName: \(String(describing: eventTypeName)), tags: \(String(describing: tags)))"}
}

extension PutDetectorInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description
        case detectorId
        case eventTypeName
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let detectorId = detectorId {
            try encodeContainer.encode(detectorId, forKey: .detectorId)
        }
        if let eventTypeName = eventTypeName {
            try encodeContainer.encode(eventTypeName, forKey: .eventTypeName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct PutDetectorInputHeadersMiddleware: Middleware {
    public let id: String = "PutDetectorInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutDetectorInput>,
                  next: H) -> Swift.Result<OperationOutput<PutDetectorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutDetectorInput>
    public typealias MOutput = OperationOutput<PutDetectorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutDetectorOutputError>
}

public struct PutDetectorInputQueryItemMiddleware: Middleware {
    public let id: String = "PutDetectorInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutDetectorInput>,
                  next: H) -> Swift.Result<OperationOutput<PutDetectorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutDetectorInput>
    public typealias MOutput = OperationOutput<PutDetectorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutDetectorOutputError>
}

public struct PutDetectorInput: Equatable {
    /// <p>The description of the detector.</p>
    public let description: String?
    /// <p>The detector ID. </p>
    public let detectorId: String?
    /// <p>The name of the event type.</p>
    public let eventTypeName: String?
    /// <p>A collection of key and value pairs.</p>
    public let tags: [Tag]?

    public init (
        description: String? = nil,
        detectorId: String? = nil,
        eventTypeName: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.description = description
        self.detectorId = detectorId
        self.eventTypeName = eventTypeName
        self.tags = tags
    }
}

struct PutDetectorInputBody: Equatable {
    public let detectorId: String?
    public let description: String?
    public let eventTypeName: String?
    public let tags: [Tag]?
}

extension PutDetectorInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description
        case detectorId
        case eventTypeName
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detectorIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .detectorId)
        detectorId = detectorIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let eventTypeNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventTypeName)
        eventTypeName = eventTypeNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension PutDetectorOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutDetectorOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutDetectorOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutDetectorOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutDetectorOutputResponse()"}
}

extension PutDetectorOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct PutDetectorOutputResponse: Equatable {

    public init() {}
}

struct PutDetectorOutputResponseBody: Equatable {
}

extension PutDetectorOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct PutEntityTypeInputBodyMiddleware: Middleware {
    public let id: String = "PutEntityTypeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutEntityTypeInput>,
                  next: H) -> Swift.Result<OperationOutput<PutEntityTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutEntityTypeInput>
    public typealias MOutput = OperationOutput<PutEntityTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutEntityTypeOutputError>
}

extension PutEntityTypeInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutEntityTypeInput(description: \(String(describing: description)), name: \(String(describing: name)), tags: \(String(describing: tags)))"}
}

extension PutEntityTypeInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description
        case name
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct PutEntityTypeInputHeadersMiddleware: Middleware {
    public let id: String = "PutEntityTypeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutEntityTypeInput>,
                  next: H) -> Swift.Result<OperationOutput<PutEntityTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutEntityTypeInput>
    public typealias MOutput = OperationOutput<PutEntityTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutEntityTypeOutputError>
}

public struct PutEntityTypeInputQueryItemMiddleware: Middleware {
    public let id: String = "PutEntityTypeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutEntityTypeInput>,
                  next: H) -> Swift.Result<OperationOutput<PutEntityTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutEntityTypeInput>
    public typealias MOutput = OperationOutput<PutEntityTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutEntityTypeOutputError>
}

public struct PutEntityTypeInput: Equatable {
    /// <p>The description.</p>
    public let description: String?
    /// <p>The name of the entity type.</p>
    public let name: String?
    /// <p>A collection of key and value pairs.</p>
    public let tags: [Tag]?

    public init (
        description: String? = nil,
        name: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.description = description
        self.name = name
        self.tags = tags
    }
}

struct PutEntityTypeInputBody: Equatable {
    public let name: String?
    public let description: String?
    public let tags: [Tag]?
}

extension PutEntityTypeInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description
        case name
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension PutEntityTypeOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutEntityTypeOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutEntityTypeOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutEntityTypeOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutEntityTypeOutputResponse()"}
}

extension PutEntityTypeOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct PutEntityTypeOutputResponse: Equatable {

    public init() {}
}

struct PutEntityTypeOutputResponseBody: Equatable {
}

extension PutEntityTypeOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct PutEventTypeInputBodyMiddleware: Middleware {
    public let id: String = "PutEventTypeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutEventTypeInput>,
                  next: H) -> Swift.Result<OperationOutput<PutEventTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutEventTypeInput>
    public typealias MOutput = OperationOutput<PutEventTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutEventTypeOutputError>
}

extension PutEventTypeInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutEventTypeInput(description: \(String(describing: description)), entityTypes: \(String(describing: entityTypes)), eventVariables: \(String(describing: eventVariables)), labels: \(String(describing: labels)), name: \(String(describing: name)), tags: \(String(describing: tags)))"}
}

extension PutEventTypeInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description
        case entityTypes
        case eventVariables
        case labels
        case name
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let entityTypes = entityTypes {
            var entityTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .entityTypes)
            for nonemptylistofstrings0 in entityTypes {
                try entityTypesContainer.encode(nonemptylistofstrings0)
            }
        }
        if let eventVariables = eventVariables {
            var eventVariablesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eventVariables)
            for nonemptylistofstrings0 in eventVariables {
                try eventVariablesContainer.encode(nonemptylistofstrings0)
            }
        }
        if let labels = labels {
            var labelsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .labels)
            for listofstrings0 in labels {
                try labelsContainer.encode(listofstrings0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct PutEventTypeInputHeadersMiddleware: Middleware {
    public let id: String = "PutEventTypeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutEventTypeInput>,
                  next: H) -> Swift.Result<OperationOutput<PutEventTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutEventTypeInput>
    public typealias MOutput = OperationOutput<PutEventTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutEventTypeOutputError>
}

public struct PutEventTypeInputQueryItemMiddleware: Middleware {
    public let id: String = "PutEventTypeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutEventTypeInput>,
                  next: H) -> Swift.Result<OperationOutput<PutEventTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutEventTypeInput>
    public typealias MOutput = OperationOutput<PutEventTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutEventTypeOutputError>
}

public struct PutEventTypeInput: Equatable {
    /// <p>The description of the event type.</p>
    public let description: String?
    /// <p>The entity type for the event type. Example entity types: customer, merchant, account.</p>
    public let entityTypes: [String]?
    /// <p>The event type variables.</p>
    public let eventVariables: [String]?
    /// <p>The event type labels.</p>
    public let labels: [String]?
    /// <p>The name.</p>
    public let name: String?
    /// <p>A collection of key and value pairs.</p>
    public let tags: [Tag]?

    public init (
        description: String? = nil,
        entityTypes: [String]? = nil,
        eventVariables: [String]? = nil,
        labels: [String]? = nil,
        name: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.description = description
        self.entityTypes = entityTypes
        self.eventVariables = eventVariables
        self.labels = labels
        self.name = name
        self.tags = tags
    }
}

struct PutEventTypeInputBody: Equatable {
    public let name: String?
    public let description: String?
    public let eventVariables: [String]?
    public let labels: [String]?
    public let entityTypes: [String]?
    public let tags: [Tag]?
}

extension PutEventTypeInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description
        case entityTypes
        case eventVariables
        case labels
        case name
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let eventVariablesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .eventVariables)
        var eventVariablesDecoded0:[String]? = nil
        if let eventVariablesContainer = eventVariablesContainer {
            eventVariablesDecoded0 = [String]()
            for string0 in eventVariablesContainer {
                if let string0 = string0 {
                    eventVariablesDecoded0?.append(string0)
                }
            }
        }
        eventVariables = eventVariablesDecoded0
        let labelsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .labels)
        var labelsDecoded0:[String]? = nil
        if let labelsContainer = labelsContainer {
            labelsDecoded0 = [String]()
            for string0 in labelsContainer {
                if let string0 = string0 {
                    labelsDecoded0?.append(string0)
                }
            }
        }
        labels = labelsDecoded0
        let entityTypesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .entityTypes)
        var entityTypesDecoded0:[String]? = nil
        if let entityTypesContainer = entityTypesContainer {
            entityTypesDecoded0 = [String]()
            for string0 in entityTypesContainer {
                if let string0 = string0 {
                    entityTypesDecoded0?.append(string0)
                }
            }
        }
        entityTypes = entityTypesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension PutEventTypeOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutEventTypeOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutEventTypeOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutEventTypeOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutEventTypeOutputResponse()"}
}

extension PutEventTypeOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct PutEventTypeOutputResponse: Equatable {

    public init() {}
}

struct PutEventTypeOutputResponseBody: Equatable {
}

extension PutEventTypeOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct PutExternalModelInputBodyMiddleware: Middleware {
    public let id: String = "PutExternalModelInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutExternalModelInput>,
                  next: H) -> Swift.Result<OperationOutput<PutExternalModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutExternalModelInput>
    public typealias MOutput = OperationOutput<PutExternalModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutExternalModelOutputError>
}

extension PutExternalModelInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutExternalModelInput(inputConfiguration: \(String(describing: inputConfiguration)), invokeModelEndpointRoleArn: \(String(describing: invokeModelEndpointRoleArn)), modelEndpoint: \(String(describing: modelEndpoint)), modelEndpointStatus: \(String(describing: modelEndpointStatus)), modelSource: \(String(describing: modelSource)), outputConfiguration: \(String(describing: outputConfiguration)), tags: \(String(describing: tags)))"}
}

extension PutExternalModelInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case inputConfiguration
        case invokeModelEndpointRoleArn
        case modelEndpoint
        case modelEndpointStatus
        case modelSource
        case outputConfiguration
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inputConfiguration = inputConfiguration {
            try encodeContainer.encode(inputConfiguration, forKey: .inputConfiguration)
        }
        if let invokeModelEndpointRoleArn = invokeModelEndpointRoleArn {
            try encodeContainer.encode(invokeModelEndpointRoleArn, forKey: .invokeModelEndpointRoleArn)
        }
        if let modelEndpoint = modelEndpoint {
            try encodeContainer.encode(modelEndpoint, forKey: .modelEndpoint)
        }
        if let modelEndpointStatus = modelEndpointStatus {
            try encodeContainer.encode(modelEndpointStatus.rawValue, forKey: .modelEndpointStatus)
        }
        if let modelSource = modelSource {
            try encodeContainer.encode(modelSource.rawValue, forKey: .modelSource)
        }
        if let outputConfiguration = outputConfiguration {
            try encodeContainer.encode(outputConfiguration, forKey: .outputConfiguration)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct PutExternalModelInputHeadersMiddleware: Middleware {
    public let id: String = "PutExternalModelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutExternalModelInput>,
                  next: H) -> Swift.Result<OperationOutput<PutExternalModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutExternalModelInput>
    public typealias MOutput = OperationOutput<PutExternalModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutExternalModelOutputError>
}

public struct PutExternalModelInputQueryItemMiddleware: Middleware {
    public let id: String = "PutExternalModelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutExternalModelInput>,
                  next: H) -> Swift.Result<OperationOutput<PutExternalModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutExternalModelInput>
    public typealias MOutput = OperationOutput<PutExternalModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutExternalModelOutputError>
}

public struct PutExternalModelInput: Equatable {
    /// <p>The model endpoint input configuration.</p>
    public let inputConfiguration: ModelInputConfiguration?
    /// <p>The IAM role used to invoke the model endpoint.</p>
    public let invokeModelEndpointRoleArn: String?
    /// <p>The model endpoints name.</p>
    public let modelEndpoint: String?
    /// <p>The model endpoint’s status in Amazon Fraud Detector.</p>
    public let modelEndpointStatus: ModelEndpointStatus?
    /// <p>The source of the model.</p>
    public let modelSource: ModelSource?
    /// <p>The model endpoint output configuration.</p>
    public let outputConfiguration: ModelOutputConfiguration?
    /// <p>A collection of key and value pairs.</p>
    public let tags: [Tag]?

    public init (
        inputConfiguration: ModelInputConfiguration? = nil,
        invokeModelEndpointRoleArn: String? = nil,
        modelEndpoint: String? = nil,
        modelEndpointStatus: ModelEndpointStatus? = nil,
        modelSource: ModelSource? = nil,
        outputConfiguration: ModelOutputConfiguration? = nil,
        tags: [Tag]? = nil
    )
    {
        self.inputConfiguration = inputConfiguration
        self.invokeModelEndpointRoleArn = invokeModelEndpointRoleArn
        self.modelEndpoint = modelEndpoint
        self.modelEndpointStatus = modelEndpointStatus
        self.modelSource = modelSource
        self.outputConfiguration = outputConfiguration
        self.tags = tags
    }
}

struct PutExternalModelInputBody: Equatable {
    public let modelEndpoint: String?
    public let modelSource: ModelSource?
    public let invokeModelEndpointRoleArn: String?
    public let inputConfiguration: ModelInputConfiguration?
    public let outputConfiguration: ModelOutputConfiguration?
    public let modelEndpointStatus: ModelEndpointStatus?
    public let tags: [Tag]?
}

extension PutExternalModelInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case inputConfiguration
        case invokeModelEndpointRoleArn
        case modelEndpoint
        case modelEndpointStatus
        case modelSource
        case outputConfiguration
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelEndpointDecoded = try containerValues.decodeIfPresent(String.self, forKey: .modelEndpoint)
        modelEndpoint = modelEndpointDecoded
        let modelSourceDecoded = try containerValues.decodeIfPresent(ModelSource.self, forKey: .modelSource)
        modelSource = modelSourceDecoded
        let invokeModelEndpointRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .invokeModelEndpointRoleArn)
        invokeModelEndpointRoleArn = invokeModelEndpointRoleArnDecoded
        let inputConfigurationDecoded = try containerValues.decodeIfPresent(ModelInputConfiguration.self, forKey: .inputConfiguration)
        inputConfiguration = inputConfigurationDecoded
        let outputConfigurationDecoded = try containerValues.decodeIfPresent(ModelOutputConfiguration.self, forKey: .outputConfiguration)
        outputConfiguration = outputConfigurationDecoded
        let modelEndpointStatusDecoded = try containerValues.decodeIfPresent(ModelEndpointStatus.self, forKey: .modelEndpointStatus)
        modelEndpointStatus = modelEndpointStatusDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension PutExternalModelOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutExternalModelOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutExternalModelOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutExternalModelOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutExternalModelOutputResponse()"}
}

extension PutExternalModelOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct PutExternalModelOutputResponse: Equatable {

    public init() {}
}

struct PutExternalModelOutputResponseBody: Equatable {
}

extension PutExternalModelOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct PutKMSEncryptionKeyInputBodyMiddleware: Middleware {
    public let id: String = "PutKMSEncryptionKeyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutKMSEncryptionKeyInput>,
                  next: H) -> Swift.Result<OperationOutput<PutKMSEncryptionKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutKMSEncryptionKeyInput>
    public typealias MOutput = OperationOutput<PutKMSEncryptionKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutKMSEncryptionKeyOutputError>
}

extension PutKMSEncryptionKeyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutKMSEncryptionKeyInput(kmsEncryptionKeyArn: \(String(describing: kmsEncryptionKeyArn)))"}
}

extension PutKMSEncryptionKeyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case kmsEncryptionKeyArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kmsEncryptionKeyArn = kmsEncryptionKeyArn {
            try encodeContainer.encode(kmsEncryptionKeyArn, forKey: .kmsEncryptionKeyArn)
        }
    }
}

public struct PutKMSEncryptionKeyInputHeadersMiddleware: Middleware {
    public let id: String = "PutKMSEncryptionKeyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutKMSEncryptionKeyInput>,
                  next: H) -> Swift.Result<OperationOutput<PutKMSEncryptionKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutKMSEncryptionKeyInput>
    public typealias MOutput = OperationOutput<PutKMSEncryptionKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutKMSEncryptionKeyOutputError>
}

public struct PutKMSEncryptionKeyInputQueryItemMiddleware: Middleware {
    public let id: String = "PutKMSEncryptionKeyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutKMSEncryptionKeyInput>,
                  next: H) -> Swift.Result<OperationOutput<PutKMSEncryptionKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutKMSEncryptionKeyInput>
    public typealias MOutput = OperationOutput<PutKMSEncryptionKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutKMSEncryptionKeyOutputError>
}

public struct PutKMSEncryptionKeyInput: Equatable {
    /// <p>The KMS encryption key ARN.</p>
    public let kmsEncryptionKeyArn: String?

    public init (
        kmsEncryptionKeyArn: String? = nil
    )
    {
        self.kmsEncryptionKeyArn = kmsEncryptionKeyArn
    }
}

struct PutKMSEncryptionKeyInputBody: Equatable {
    public let kmsEncryptionKeyArn: String?
}

extension PutKMSEncryptionKeyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case kmsEncryptionKeyArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let kmsEncryptionKeyArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsEncryptionKeyArn)
        kmsEncryptionKeyArn = kmsEncryptionKeyArnDecoded
    }
}

extension PutKMSEncryptionKeyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutKMSEncryptionKeyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutKMSEncryptionKeyOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutKMSEncryptionKeyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutKMSEncryptionKeyOutputResponse()"}
}

extension PutKMSEncryptionKeyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct PutKMSEncryptionKeyOutputResponse: Equatable {

    public init() {}
}

struct PutKMSEncryptionKeyOutputResponseBody: Equatable {
}

extension PutKMSEncryptionKeyOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct PutLabelInputBodyMiddleware: Middleware {
    public let id: String = "PutLabelInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutLabelInput>,
                  next: H) -> Swift.Result<OperationOutput<PutLabelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutLabelInput>
    public typealias MOutput = OperationOutput<PutLabelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutLabelOutputError>
}

extension PutLabelInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutLabelInput(description: \(String(describing: description)), name: \(String(describing: name)), tags: \(String(describing: tags)))"}
}

extension PutLabelInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description
        case name
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct PutLabelInputHeadersMiddleware: Middleware {
    public let id: String = "PutLabelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutLabelInput>,
                  next: H) -> Swift.Result<OperationOutput<PutLabelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutLabelInput>
    public typealias MOutput = OperationOutput<PutLabelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutLabelOutputError>
}

public struct PutLabelInputQueryItemMiddleware: Middleware {
    public let id: String = "PutLabelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutLabelInput>,
                  next: H) -> Swift.Result<OperationOutput<PutLabelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutLabelInput>
    public typealias MOutput = OperationOutput<PutLabelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutLabelOutputError>
}

public struct PutLabelInput: Equatable {
    /// <p>The label description.</p>
    public let description: String?
    /// <p>The label name.</p>
    public let name: String?
    /// <p></p>
    public let tags: [Tag]?

    public init (
        description: String? = nil,
        name: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.description = description
        self.name = name
        self.tags = tags
    }
}

struct PutLabelInputBody: Equatable {
    public let name: String?
    public let description: String?
    public let tags: [Tag]?
}

extension PutLabelInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description
        case name
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension PutLabelOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutLabelOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutLabelOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutLabelOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutLabelOutputResponse()"}
}

extension PutLabelOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct PutLabelOutputResponse: Equatable {

    public init() {}
}

struct PutLabelOutputResponseBody: Equatable {
}

extension PutLabelOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct PutOutcomeInputBodyMiddleware: Middleware {
    public let id: String = "PutOutcomeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutOutcomeInput>,
                  next: H) -> Swift.Result<OperationOutput<PutOutcomeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutOutcomeInput>
    public typealias MOutput = OperationOutput<PutOutcomeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutOutcomeOutputError>
}

extension PutOutcomeInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutOutcomeInput(description: \(String(describing: description)), name: \(String(describing: name)), tags: \(String(describing: tags)))"}
}

extension PutOutcomeInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description
        case name
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct PutOutcomeInputHeadersMiddleware: Middleware {
    public let id: String = "PutOutcomeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutOutcomeInput>,
                  next: H) -> Swift.Result<OperationOutput<PutOutcomeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutOutcomeInput>
    public typealias MOutput = OperationOutput<PutOutcomeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutOutcomeOutputError>
}

public struct PutOutcomeInputQueryItemMiddleware: Middleware {
    public let id: String = "PutOutcomeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutOutcomeInput>,
                  next: H) -> Swift.Result<OperationOutput<PutOutcomeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutOutcomeInput>
    public typealias MOutput = OperationOutput<PutOutcomeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutOutcomeOutputError>
}

public struct PutOutcomeInput: Equatable {
    /// <p>The outcome description.</p>
    public let description: String?
    /// <p>The name of the outcome.</p>
    public let name: String?
    /// <p>A collection of key and value pairs.</p>
    public let tags: [Tag]?

    public init (
        description: String? = nil,
        name: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.description = description
        self.name = name
        self.tags = tags
    }
}

struct PutOutcomeInputBody: Equatable {
    public let name: String?
    public let description: String?
    public let tags: [Tag]?
}

extension PutOutcomeInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description
        case name
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension PutOutcomeOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutOutcomeOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutOutcomeOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutOutcomeOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutOutcomeOutputResponse()"}
}

extension PutOutcomeOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct PutOutcomeOutputResponse: Equatable {

    public init() {}
}

struct PutOutcomeOutputResponseBody: Equatable {
}

extension PutOutcomeOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundException(message: \(String(describing: message)))"}
}

extension ResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An exception indicating the specified resource was not found.</p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension ResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Rule: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case detectorId
        case ruleId
        case ruleVersion
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let detectorId = detectorId {
            try encodeContainer.encode(detectorId, forKey: .detectorId)
        }
        if let ruleId = ruleId {
            try encodeContainer.encode(ruleId, forKey: .ruleId)
        }
        if let ruleVersion = ruleVersion {
            try encodeContainer.encode(ruleVersion, forKey: .ruleVersion)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detectorIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .detectorId)
        detectorId = detectorIdDecoded
        let ruleIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ruleId)
        ruleId = ruleIdDecoded
        let ruleVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ruleVersion)
        ruleVersion = ruleVersionDecoded
    }
}

extension Rule: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Rule(detectorId: \(String(describing: detectorId)), ruleId: \(String(describing: ruleId)), ruleVersion: \(String(describing: ruleVersion)))"}
}

/// <p>A rule.</p>
public struct Rule: Equatable {
    /// <p>The detector for which the rule is associated.</p>
    public let detectorId: String?
    /// <p>The rule ID.</p>
    public let ruleId: String?
    /// <p>The rule version.</p>
    public let ruleVersion: String?

    public init (
        detectorId: String? = nil,
        ruleId: String? = nil,
        ruleVersion: String? = nil
    )
    {
        self.detectorId = detectorId
        self.ruleId = ruleId
        self.ruleVersion = ruleVersion
    }
}

extension RuleDetail: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case createdTime
        case description
        case detectorId
        case expression
        case language
        case lastUpdatedTime
        case outcomes
        case ruleId
        case ruleVersion
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime, forKey: .createdTime)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let detectorId = detectorId {
            try encodeContainer.encode(detectorId, forKey: .detectorId)
        }
        if let expression = expression {
            try encodeContainer.encode(expression, forKey: .expression)
        }
        if let language = language {
            try encodeContainer.encode(language.rawValue, forKey: .language)
        }
        if let lastUpdatedTime = lastUpdatedTime {
            try encodeContainer.encode(lastUpdatedTime, forKey: .lastUpdatedTime)
        }
        if let outcomes = outcomes {
            var outcomesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .outcomes)
            for nonemptylistofstrings0 in outcomes {
                try outcomesContainer.encode(nonemptylistofstrings0)
            }
        }
        if let ruleId = ruleId {
            try encodeContainer.encode(ruleId, forKey: .ruleId)
        }
        if let ruleVersion = ruleVersion {
            try encodeContainer.encode(ruleVersion, forKey: .ruleVersion)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ruleId)
        ruleId = ruleIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let detectorIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .detectorId)
        detectorId = detectorIdDecoded
        let ruleVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ruleVersion)
        ruleVersion = ruleVersionDecoded
        let expressionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .expression)
        expression = expressionDecoded
        let languageDecoded = try containerValues.decodeIfPresent(Language.self, forKey: .language)
        language = languageDecoded
        let outcomesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .outcomes)
        var outcomesDecoded0:[String]? = nil
        if let outcomesContainer = outcomesContainer {
            outcomesDecoded0 = [String]()
            for string0 in outcomesContainer {
                if let string0 = string0 {
                    outcomesDecoded0?.append(string0)
                }
            }
        }
        outcomes = outcomesDecoded0
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension RuleDetail: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RuleDetail(arn: \(String(describing: arn)), createdTime: \(String(describing: createdTime)), description: \(String(describing: description)), detectorId: \(String(describing: detectorId)), expression: \(String(describing: expression)), language: \(String(describing: language)), lastUpdatedTime: \(String(describing: lastUpdatedTime)), outcomes: \(String(describing: outcomes)), ruleId: \(String(describing: ruleId)), ruleVersion: \(String(describing: ruleVersion)))"}
}

/// <p>The details of the rule.</p>
public struct RuleDetail: Equatable {
    /// <p>The rule ARN.</p>
    public let arn: String?
    /// <p>The timestamp of when the rule was created.</p>
    public let createdTime: String?
    /// <p>The rule description.</p>
    public let description: String?
    /// <p>The detector for which the rule is associated.</p>
    public let detectorId: String?
    /// <p>The rule expression.</p>
    public let expression: String?
    /// <p>The rule language.</p>
    public let language: Language?
    /// <p>Timestamp of the last time the rule was updated.</p>
    public let lastUpdatedTime: String?
    /// <p>The rule outcomes.</p>
    public let outcomes: [String]?
    /// <p>The rule ID.</p>
    public let ruleId: String?
    /// <p>The rule version.</p>
    public let ruleVersion: String?

    public init (
        arn: String? = nil,
        createdTime: String? = nil,
        description: String? = nil,
        detectorId: String? = nil,
        expression: String? = nil,
        language: Language? = nil,
        lastUpdatedTime: String? = nil,
        outcomes: [String]? = nil,
        ruleId: String? = nil,
        ruleVersion: String? = nil
    )
    {
        self.arn = arn
        self.createdTime = createdTime
        self.description = description
        self.detectorId = detectorId
        self.expression = expression
        self.language = language
        self.lastUpdatedTime = lastUpdatedTime
        self.outcomes = outcomes
        self.ruleId = ruleId
        self.ruleVersion = ruleVersion
    }
}

public enum RuleExecutionMode {
    case allMatched
    case firstMatched
    case sdkUnknown(String)
}

extension RuleExecutionMode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [RuleExecutionMode] {
        return [
            .allMatched,
            .firstMatched,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .allMatched: return "ALL_MATCHED"
        case .firstMatched: return "FIRST_MATCHED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = RuleExecutionMode(rawValue: rawValue) ?? RuleExecutionMode.sdkUnknown(rawValue)
    }
}

extension RuleResult: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case outcomes
        case ruleId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let outcomes = outcomes {
            var outcomesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .outcomes)
            for listofstrings0 in outcomes {
                try outcomesContainer.encode(listofstrings0)
            }
        }
        if let ruleId = ruleId {
            try encodeContainer.encode(ruleId, forKey: .ruleId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ruleId)
        ruleId = ruleIdDecoded
        let outcomesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .outcomes)
        var outcomesDecoded0:[String]? = nil
        if let outcomesContainer = outcomesContainer {
            outcomesDecoded0 = [String]()
            for string0 in outcomesContainer {
                if let string0 = string0 {
                    outcomesDecoded0?.append(string0)
                }
            }
        }
        outcomes = outcomesDecoded0
    }
}

extension RuleResult: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RuleResult(outcomes: \(String(describing: outcomes)), ruleId: \(String(describing: ruleId)))"}
}

/// <p>The rule results.</p>
public struct RuleResult: Equatable {
    /// <p>The outcomes of the matched rule, based on the rule execution mode.</p>
    public let outcomes: [String]?
    /// <p>The rule ID that was matched, based on the rule execution mode.</p>
    public let ruleId: String?

    public init (
        outcomes: [String]? = nil,
        ruleId: String? = nil
    )
    {
        self.outcomes = outcomes
        self.ruleId = ruleId
    }
}

extension Tag: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key
        case value
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Tag: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Tag(key: \(String(describing: key)), value: \(String(describing: value)))"}
}

/// <p>A key and value pair. </p>
public struct Tag: Equatable {
    /// <p>A tag key.</p>
    public let key: String?
    /// <p>A value assigned to a tag key.</p>
    public let value: String?

    public init (
        key: String? = nil,
        value: String? = nil
    )
    {
        self.key = key
        self.value = value
    }
}

public struct TagResourceInputBodyMiddleware: Middleware {
    public let id: String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

extension TagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceInput(resourceARN: \(String(describing: resourceARN)), tags: \(String(describing: tags)))"}
}

extension TagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceARN
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Equatable {
    /// <p>The resource ARN.</p>
    public let resourceARN: String?
    /// <p>The tags to assign to the resource.</p>
    public let tags: [Tag]?

    public init (
        resourceARN: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

struct TagResourceInputBody: Equatable {
    public let resourceARN: String?
    public let tags: [Tag]?
}

extension TagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceARN
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Equatable {
}

extension TagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ThrottlingException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ThrottlingException(message: \(String(describing: message)))"}
}

extension ThrottlingException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An exception indicating a throttling error.</p>
public struct ThrottlingException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ThrottlingExceptionBody: Equatable {
    public let message: String?
}

extension ThrottlingExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TrainingDataSchema: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case labelSchema
        case modelVariables
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let labelSchema = labelSchema {
            try encodeContainer.encode(labelSchema, forKey: .labelSchema)
        }
        if let modelVariables = modelVariables {
            var modelVariablesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .modelVariables)
            for listofstrings0 in modelVariables {
                try modelVariablesContainer.encode(listofstrings0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelVariablesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .modelVariables)
        var modelVariablesDecoded0:[String]? = nil
        if let modelVariablesContainer = modelVariablesContainer {
            modelVariablesDecoded0 = [String]()
            for string0 in modelVariablesContainer {
                if let string0 = string0 {
                    modelVariablesDecoded0?.append(string0)
                }
            }
        }
        modelVariables = modelVariablesDecoded0
        let labelSchemaDecoded = try containerValues.decodeIfPresent(LabelSchema.self, forKey: .labelSchema)
        labelSchema = labelSchemaDecoded
    }
}

extension TrainingDataSchema: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TrainingDataSchema(labelSchema: \(String(describing: labelSchema)), modelVariables: \(String(describing: modelVariables)))"}
}

/// <p>The training data schema.</p>
public struct TrainingDataSchema: Equatable {
    /// <p>The label schema.</p>
    public let labelSchema: LabelSchema?
    /// <p>The training data schema variables.</p>
    public let modelVariables: [String]?

    public init (
        labelSchema: LabelSchema? = nil,
        modelVariables: [String]? = nil
    )
    {
        self.labelSchema = labelSchema
        self.modelVariables = modelVariables
    }
}

public enum TrainingDataSourceEnum {
    case externalEvents
    case sdkUnknown(String)
}

extension TrainingDataSourceEnum : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [TrainingDataSourceEnum] {
        return [
            .externalEvents,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .externalEvents: return "EXTERNAL_EVENTS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = TrainingDataSourceEnum(rawValue: rawValue) ?? TrainingDataSourceEnum.sdkUnknown(rawValue)
    }
}

extension TrainingMetrics: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case auc
        case metricDataPoints
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let auc = auc {
            try encodeContainer.encode(auc, forKey: .auc)
        }
        if let metricDataPoints = metricDataPoints {
            var metricDataPointsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .metricDataPoints)
            for metricdatapointslist0 in metricDataPoints {
                try metricDataPointsContainer.encode(metricdatapointslist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aucDecoded = try containerValues.decodeIfPresent(Float.self, forKey: .auc)
        auc = aucDecoded
        let metricDataPointsContainer = try containerValues.decodeIfPresent([MetricDataPoint?].self, forKey: .metricDataPoints)
        var metricDataPointsDecoded0:[MetricDataPoint]? = nil
        if let metricDataPointsContainer = metricDataPointsContainer {
            metricDataPointsDecoded0 = [MetricDataPoint]()
            for structure0 in metricDataPointsContainer {
                if let structure0 = structure0 {
                    metricDataPointsDecoded0?.append(structure0)
                }
            }
        }
        metricDataPoints = metricDataPointsDecoded0
    }
}

extension TrainingMetrics: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TrainingMetrics(auc: \(String(describing: auc)), metricDataPoints: \(String(describing: metricDataPoints)))"}
}

/// <p>The training metric details.</p>
public struct TrainingMetrics: Equatable {
    /// <p>The area under the curve. This summarizes true positive rate (TPR) and false positive rate (FPR) across all possible model score thresholds. A model with no predictive power has an AUC of 0.5, whereas a perfect model has a score of 1.0.</p>
    public let auc: Float?
    /// <p>The data points details.</p>
    public let metricDataPoints: [MetricDataPoint]?

    public init (
        auc: Float? = nil,
        metricDataPoints: [MetricDataPoint]? = nil
    )
    {
        self.auc = auc
        self.metricDataPoints = metricDataPoints
    }
}

extension TrainingResult: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dataValidationMetrics
        case trainingMetrics
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataValidationMetrics = dataValidationMetrics {
            try encodeContainer.encode(dataValidationMetrics, forKey: .dataValidationMetrics)
        }
        if let trainingMetrics = trainingMetrics {
            try encodeContainer.encode(trainingMetrics, forKey: .trainingMetrics)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataValidationMetricsDecoded = try containerValues.decodeIfPresent(DataValidationMetrics.self, forKey: .dataValidationMetrics)
        dataValidationMetrics = dataValidationMetricsDecoded
        let trainingMetricsDecoded = try containerValues.decodeIfPresent(TrainingMetrics.self, forKey: .trainingMetrics)
        trainingMetrics = trainingMetricsDecoded
    }
}

extension TrainingResult: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TrainingResult(dataValidationMetrics: \(String(describing: dataValidationMetrics)), trainingMetrics: \(String(describing: trainingMetrics)))"}
}

/// <p>The training result details.</p>
public struct TrainingResult: Equatable {
    /// <p>The validation metrics.</p>
    public let dataValidationMetrics: DataValidationMetrics?
    /// <p>The training metric details.</p>
    public let trainingMetrics: TrainingMetrics?

    public init (
        dataValidationMetrics: DataValidationMetrics? = nil,
        trainingMetrics: TrainingMetrics? = nil
    )
    {
        self.dataValidationMetrics = dataValidationMetrics
        self.trainingMetrics = trainingMetrics
    }
}

public struct UntagResourceInputBodyMiddleware: Middleware {
    public let id: String = "UntagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

extension UntagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceInput(resourceARN: \(String(describing: resourceARN)), tagKeys: \(String(describing: tagKeys)))"}
}

extension UntagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceARN
        case tagKeys
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkeylist0 in tagKeys {
                try tagKeysContainer.encode(tagkeylist0)
            }
        }
    }
}

public struct UntagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Equatable {
    /// <p>The ARN of the resource from which to remove the tag.</p>
    public let resourceARN: String?
    /// <p>The resource ARN.</p>
    public let tagKeys: [String]?

    public init (
        resourceARN: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Equatable {
    public let resourceARN: String?
    public let tagKeys: [String]?
}

extension UntagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceARN
        case tagKeys
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Equatable {
}

extension UntagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateDetectorVersionInputBodyMiddleware: Middleware {
    public let id: String = "UpdateDetectorVersionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDetectorVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDetectorVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDetectorVersionInput>
    public typealias MOutput = OperationOutput<UpdateDetectorVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDetectorVersionOutputError>
}

extension UpdateDetectorVersionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateDetectorVersionInput(description: \(String(describing: description)), detectorId: \(String(describing: detectorId)), detectorVersionId: \(String(describing: detectorVersionId)), externalModelEndpoints: \(String(describing: externalModelEndpoints)), modelVersions: \(String(describing: modelVersions)), ruleExecutionMode: \(String(describing: ruleExecutionMode)), rules: \(String(describing: rules)))"}
}

extension UpdateDetectorVersionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description
        case detectorId
        case detectorVersionId
        case externalModelEndpoints
        case modelVersions
        case ruleExecutionMode
        case rules
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let detectorId = detectorId {
            try encodeContainer.encode(detectorId, forKey: .detectorId)
        }
        if let detectorVersionId = detectorVersionId {
            try encodeContainer.encode(detectorVersionId, forKey: .detectorVersionId)
        }
        if let externalModelEndpoints = externalModelEndpoints {
            var externalModelEndpointsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .externalModelEndpoints)
            for listofstrings0 in externalModelEndpoints {
                try externalModelEndpointsContainer.encode(listofstrings0)
            }
        }
        if let modelVersions = modelVersions {
            var modelVersionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .modelVersions)
            for listofmodelversions0 in modelVersions {
                try modelVersionsContainer.encode(listofmodelversions0)
            }
        }
        if let ruleExecutionMode = ruleExecutionMode {
            try encodeContainer.encode(ruleExecutionMode.rawValue, forKey: .ruleExecutionMode)
        }
        if let rules = rules {
            var rulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rules)
            for rulelist0 in rules {
                try rulesContainer.encode(rulelist0)
            }
        }
    }
}

public struct UpdateDetectorVersionInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateDetectorVersionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDetectorVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDetectorVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDetectorVersionInput>
    public typealias MOutput = OperationOutput<UpdateDetectorVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDetectorVersionOutputError>
}

public struct UpdateDetectorVersionInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateDetectorVersionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDetectorVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDetectorVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDetectorVersionInput>
    public typealias MOutput = OperationOutput<UpdateDetectorVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDetectorVersionOutputError>
}

public struct UpdateDetectorVersionInput: Equatable {
    /// <p>The detector version description. </p>
    public let description: String?
    /// <p>The parent detector ID for the detector version you want to update.</p>
    public let detectorId: String?
    /// <p>The detector version ID. </p>
    public let detectorVersionId: String?
    /// <p>The Amazon SageMaker model endpoints to include in the detector version.</p>
    public let externalModelEndpoints: [String]?
    /// <p>The model versions to include in the detector version.</p>
    public let modelVersions: [ModelVersion]?
    /// <p>The rule execution mode to add to the detector.</p>
    /// 	        <p>If you specify <code>FIRST_MATCHED</code>, Amazon Fraud Detector evaluates rules sequentially, first to last, stopping at the first matched rule. Amazon Fraud dectector then provides the outcomes for that single rule.</p>
    /// 	        <p>If you specifiy <code>ALL_MATCHED</code>, Amazon Fraud Detector evaluates all rules and returns the outcomes for all matched rules. You can define and edit the rule mode at the detector version level, when it is in draft status.</p>
    ///          <p>The default behavior is <code>FIRST_MATCHED</code>.</p>
    public let ruleExecutionMode: RuleExecutionMode?
    /// <p>The rules to include in the detector version.</p>
    public let rules: [Rule]?

    public init (
        description: String? = nil,
        detectorId: String? = nil,
        detectorVersionId: String? = nil,
        externalModelEndpoints: [String]? = nil,
        modelVersions: [ModelVersion]? = nil,
        ruleExecutionMode: RuleExecutionMode? = nil,
        rules: [Rule]? = nil
    )
    {
        self.description = description
        self.detectorId = detectorId
        self.detectorVersionId = detectorVersionId
        self.externalModelEndpoints = externalModelEndpoints
        self.modelVersions = modelVersions
        self.ruleExecutionMode = ruleExecutionMode
        self.rules = rules
    }
}

struct UpdateDetectorVersionInputBody: Equatable {
    public let detectorId: String?
    public let detectorVersionId: String?
    public let externalModelEndpoints: [String]?
    public let rules: [Rule]?
    public let description: String?
    public let modelVersions: [ModelVersion]?
    public let ruleExecutionMode: RuleExecutionMode?
}

extension UpdateDetectorVersionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description
        case detectorId
        case detectorVersionId
        case externalModelEndpoints
        case modelVersions
        case ruleExecutionMode
        case rules
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detectorIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .detectorId)
        detectorId = detectorIdDecoded
        let detectorVersionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .detectorVersionId)
        detectorVersionId = detectorVersionIdDecoded
        let externalModelEndpointsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .externalModelEndpoints)
        var externalModelEndpointsDecoded0:[String]? = nil
        if let externalModelEndpointsContainer = externalModelEndpointsContainer {
            externalModelEndpointsDecoded0 = [String]()
            for string0 in externalModelEndpointsContainer {
                if let string0 = string0 {
                    externalModelEndpointsDecoded0?.append(string0)
                }
            }
        }
        externalModelEndpoints = externalModelEndpointsDecoded0
        let rulesContainer = try containerValues.decodeIfPresent([Rule?].self, forKey: .rules)
        var rulesDecoded0:[Rule]? = nil
        if let rulesContainer = rulesContainer {
            rulesDecoded0 = [Rule]()
            for structure0 in rulesContainer {
                if let structure0 = structure0 {
                    rulesDecoded0?.append(structure0)
                }
            }
        }
        rules = rulesDecoded0
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let modelVersionsContainer = try containerValues.decodeIfPresent([ModelVersion?].self, forKey: .modelVersions)
        var modelVersionsDecoded0:[ModelVersion]? = nil
        if let modelVersionsContainer = modelVersionsContainer {
            modelVersionsDecoded0 = [ModelVersion]()
            for structure0 in modelVersionsContainer {
                if let structure0 = structure0 {
                    modelVersionsDecoded0?.append(structure0)
                }
            }
        }
        modelVersions = modelVersionsDecoded0
        let ruleExecutionModeDecoded = try containerValues.decodeIfPresent(RuleExecutionMode.self, forKey: .ruleExecutionMode)
        ruleExecutionMode = ruleExecutionModeDecoded
    }
}

public struct UpdateDetectorVersionMetadataInputBodyMiddleware: Middleware {
    public let id: String = "UpdateDetectorVersionMetadataInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDetectorVersionMetadataInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDetectorVersionMetadataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDetectorVersionMetadataInput>
    public typealias MOutput = OperationOutput<UpdateDetectorVersionMetadataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDetectorVersionMetadataOutputError>
}

extension UpdateDetectorVersionMetadataInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateDetectorVersionMetadataInput(description: \(String(describing: description)), detectorId: \(String(describing: detectorId)), detectorVersionId: \(String(describing: detectorVersionId)))"}
}

extension UpdateDetectorVersionMetadataInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description
        case detectorId
        case detectorVersionId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let detectorId = detectorId {
            try encodeContainer.encode(detectorId, forKey: .detectorId)
        }
        if let detectorVersionId = detectorVersionId {
            try encodeContainer.encode(detectorVersionId, forKey: .detectorVersionId)
        }
    }
}

public struct UpdateDetectorVersionMetadataInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateDetectorVersionMetadataInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDetectorVersionMetadataInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDetectorVersionMetadataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDetectorVersionMetadataInput>
    public typealias MOutput = OperationOutput<UpdateDetectorVersionMetadataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDetectorVersionMetadataOutputError>
}

public struct UpdateDetectorVersionMetadataInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateDetectorVersionMetadataInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDetectorVersionMetadataInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDetectorVersionMetadataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDetectorVersionMetadataInput>
    public typealias MOutput = OperationOutput<UpdateDetectorVersionMetadataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDetectorVersionMetadataOutputError>
}

public struct UpdateDetectorVersionMetadataInput: Equatable {
    /// <p>The description.</p>
    public let description: String?
    /// <p>The detector ID.</p>
    public let detectorId: String?
    /// <p>The detector version ID. </p>
    public let detectorVersionId: String?

    public init (
        description: String? = nil,
        detectorId: String? = nil,
        detectorVersionId: String? = nil
    )
    {
        self.description = description
        self.detectorId = detectorId
        self.detectorVersionId = detectorVersionId
    }
}

struct UpdateDetectorVersionMetadataInputBody: Equatable {
    public let detectorId: String?
    public let detectorVersionId: String?
    public let description: String?
}

extension UpdateDetectorVersionMetadataInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description
        case detectorId
        case detectorVersionId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detectorIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .detectorId)
        detectorId = detectorIdDecoded
        let detectorVersionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .detectorVersionId)
        detectorVersionId = detectorVersionIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateDetectorVersionMetadataOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDetectorVersionMetadataOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateDetectorVersionMetadataOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDetectorVersionMetadataOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateDetectorVersionMetadataOutputResponse()"}
}

extension UpdateDetectorVersionMetadataOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateDetectorVersionMetadataOutputResponse: Equatable {

    public init() {}
}

struct UpdateDetectorVersionMetadataOutputResponseBody: Equatable {
}

extension UpdateDetectorVersionMetadataOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension UpdateDetectorVersionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDetectorVersionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateDetectorVersionOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDetectorVersionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateDetectorVersionOutputResponse()"}
}

extension UpdateDetectorVersionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateDetectorVersionOutputResponse: Equatable {

    public init() {}
}

struct UpdateDetectorVersionOutputResponseBody: Equatable {
}

extension UpdateDetectorVersionOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateDetectorVersionStatusInputBodyMiddleware: Middleware {
    public let id: String = "UpdateDetectorVersionStatusInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDetectorVersionStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDetectorVersionStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDetectorVersionStatusInput>
    public typealias MOutput = OperationOutput<UpdateDetectorVersionStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDetectorVersionStatusOutputError>
}

extension UpdateDetectorVersionStatusInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateDetectorVersionStatusInput(detectorId: \(String(describing: detectorId)), detectorVersionId: \(String(describing: detectorVersionId)), status: \(String(describing: status)))"}
}

extension UpdateDetectorVersionStatusInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case detectorId
        case detectorVersionId
        case status
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let detectorId = detectorId {
            try encodeContainer.encode(detectorId, forKey: .detectorId)
        }
        if let detectorVersionId = detectorVersionId {
            try encodeContainer.encode(detectorVersionId, forKey: .detectorVersionId)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }
}

public struct UpdateDetectorVersionStatusInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateDetectorVersionStatusInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDetectorVersionStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDetectorVersionStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDetectorVersionStatusInput>
    public typealias MOutput = OperationOutput<UpdateDetectorVersionStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDetectorVersionStatusOutputError>
}

public struct UpdateDetectorVersionStatusInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateDetectorVersionStatusInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDetectorVersionStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDetectorVersionStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDetectorVersionStatusInput>
    public typealias MOutput = OperationOutput<UpdateDetectorVersionStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDetectorVersionStatusOutputError>
}

public struct UpdateDetectorVersionStatusInput: Equatable {
    /// <p>The detector ID. </p>
    public let detectorId: String?
    /// <p>The detector version ID. </p>
    public let detectorVersionId: String?
    /// <p>The new status.</p>
    public let status: DetectorVersionStatus?

    public init (
        detectorId: String? = nil,
        detectorVersionId: String? = nil,
        status: DetectorVersionStatus? = nil
    )
    {
        self.detectorId = detectorId
        self.detectorVersionId = detectorVersionId
        self.status = status
    }
}

struct UpdateDetectorVersionStatusInputBody: Equatable {
    public let detectorId: String?
    public let detectorVersionId: String?
    public let status: DetectorVersionStatus?
}

extension UpdateDetectorVersionStatusInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case detectorId
        case detectorVersionId
        case status
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detectorIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .detectorId)
        detectorId = detectorIdDecoded
        let detectorVersionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .detectorVersionId)
        detectorVersionId = detectorVersionIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DetectorVersionStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension UpdateDetectorVersionStatusOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDetectorVersionStatusOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateDetectorVersionStatusOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDetectorVersionStatusOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateDetectorVersionStatusOutputResponse()"}
}

extension UpdateDetectorVersionStatusOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateDetectorVersionStatusOutputResponse: Equatable {

    public init() {}
}

struct UpdateDetectorVersionStatusOutputResponseBody: Equatable {
}

extension UpdateDetectorVersionStatusOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateModelInputBodyMiddleware: Middleware {
    public let id: String = "UpdateModelInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateModelInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateModelInput>
    public typealias MOutput = OperationOutput<UpdateModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateModelOutputError>
}

extension UpdateModelInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateModelInput(description: \(String(describing: description)), modelId: \(String(describing: modelId)), modelType: \(String(describing: modelType)))"}
}

extension UpdateModelInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description
        case modelId
        case modelType
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let modelId = modelId {
            try encodeContainer.encode(modelId, forKey: .modelId)
        }
        if let modelType = modelType {
            try encodeContainer.encode(modelType.rawValue, forKey: .modelType)
        }
    }
}

public struct UpdateModelInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateModelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateModelInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateModelInput>
    public typealias MOutput = OperationOutput<UpdateModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateModelOutputError>
}

public struct UpdateModelInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateModelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateModelInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateModelInput>
    public typealias MOutput = OperationOutput<UpdateModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateModelOutputError>
}

public struct UpdateModelInput: Equatable {
    /// <p>The new model description.</p>
    public let description: String?
    /// <p>The model ID.</p>
    public let modelId: String?
    /// <p>The model type.</p>
    public let modelType: ModelTypeEnum?

    public init (
        description: String? = nil,
        modelId: String? = nil,
        modelType: ModelTypeEnum? = nil
    )
    {
        self.description = description
        self.modelId = modelId
        self.modelType = modelType
    }
}

struct UpdateModelInputBody: Equatable {
    public let modelId: String?
    public let modelType: ModelTypeEnum?
    public let description: String?
}

extension UpdateModelInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description
        case modelId
        case modelType
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .modelId)
        modelId = modelIdDecoded
        let modelTypeDecoded = try containerValues.decodeIfPresent(ModelTypeEnum.self, forKey: .modelType)
        modelType = modelTypeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateModelOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateModelOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateModelOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateModelOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateModelOutputResponse()"}
}

extension UpdateModelOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateModelOutputResponse: Equatable {

    public init() {}
}

struct UpdateModelOutputResponseBody: Equatable {
}

extension UpdateModelOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateModelVersionInputBodyMiddleware: Middleware {
    public let id: String = "UpdateModelVersionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateModelVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateModelVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateModelVersionInput>
    public typealias MOutput = OperationOutput<UpdateModelVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateModelVersionOutputError>
}

extension UpdateModelVersionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateModelVersionInput(externalEventsDetail: \(String(describing: externalEventsDetail)), majorVersionNumber: \(String(describing: majorVersionNumber)), modelId: \(String(describing: modelId)), modelType: \(String(describing: modelType)), tags: \(String(describing: tags)))"}
}

extension UpdateModelVersionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case externalEventsDetail
        case majorVersionNumber
        case modelId
        case modelType
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let externalEventsDetail = externalEventsDetail {
            try encodeContainer.encode(externalEventsDetail, forKey: .externalEventsDetail)
        }
        if let majorVersionNumber = majorVersionNumber {
            try encodeContainer.encode(majorVersionNumber, forKey: .majorVersionNumber)
        }
        if let modelId = modelId {
            try encodeContainer.encode(modelId, forKey: .modelId)
        }
        if let modelType = modelType {
            try encodeContainer.encode(modelType.rawValue, forKey: .modelType)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct UpdateModelVersionInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateModelVersionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateModelVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateModelVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateModelVersionInput>
    public typealias MOutput = OperationOutput<UpdateModelVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateModelVersionOutputError>
}

public struct UpdateModelVersionInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateModelVersionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateModelVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateModelVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateModelVersionInput>
    public typealias MOutput = OperationOutput<UpdateModelVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateModelVersionOutputError>
}

public struct UpdateModelVersionInput: Equatable {
    /// <p>The event details.</p>
    public let externalEventsDetail: ExternalEventsDetail?
    /// <p>The major version number.</p>
    public let majorVersionNumber: String?
    /// <p>The model ID.</p>
    public let modelId: String?
    /// <p>The model type.</p>
    public let modelType: ModelTypeEnum?
    /// <p>A collection of key and value pairs.</p>
    public let tags: [Tag]?

    public init (
        externalEventsDetail: ExternalEventsDetail? = nil,
        majorVersionNumber: String? = nil,
        modelId: String? = nil,
        modelType: ModelTypeEnum? = nil,
        tags: [Tag]? = nil
    )
    {
        self.externalEventsDetail = externalEventsDetail
        self.majorVersionNumber = majorVersionNumber
        self.modelId = modelId
        self.modelType = modelType
        self.tags = tags
    }
}

struct UpdateModelVersionInputBody: Equatable {
    public let modelId: String?
    public let modelType: ModelTypeEnum?
    public let majorVersionNumber: String?
    public let externalEventsDetail: ExternalEventsDetail?
    public let tags: [Tag]?
}

extension UpdateModelVersionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case externalEventsDetail
        case majorVersionNumber
        case modelId
        case modelType
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .modelId)
        modelId = modelIdDecoded
        let modelTypeDecoded = try containerValues.decodeIfPresent(ModelTypeEnum.self, forKey: .modelType)
        modelType = modelTypeDecoded
        let majorVersionNumberDecoded = try containerValues.decodeIfPresent(String.self, forKey: .majorVersionNumber)
        majorVersionNumber = majorVersionNumberDecoded
        let externalEventsDetailDecoded = try containerValues.decodeIfPresent(ExternalEventsDetail.self, forKey: .externalEventsDetail)
        externalEventsDetail = externalEventsDetailDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension UpdateModelVersionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateModelVersionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateModelVersionOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateModelVersionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateModelVersionOutputResponse(modelId: \(String(describing: modelId)), modelType: \(String(describing: modelType)), modelVersionNumber: \(String(describing: modelVersionNumber)), status: \(String(describing: status)))"}
}

extension UpdateModelVersionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateModelVersionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.modelId = output.modelId
            self.modelType = output.modelType
            self.modelVersionNumber = output.modelVersionNumber
            self.status = output.status
        } else {
            self.modelId = nil
            self.modelType = nil
            self.modelVersionNumber = nil
            self.status = nil
        }
    }
}

public struct UpdateModelVersionOutputResponse: Equatable {
    /// <p>The model ID.</p>
    public let modelId: String?
    /// <p>The model type.</p>
    public let modelType: ModelTypeEnum?
    /// <p>The model version number of the model version updated.</p>
    public let modelVersionNumber: String?
    /// <p>The status of the updated model version.</p>
    public let status: String?

    public init (
        modelId: String? = nil,
        modelType: ModelTypeEnum? = nil,
        modelVersionNumber: String? = nil,
        status: String? = nil
    )
    {
        self.modelId = modelId
        self.modelType = modelType
        self.modelVersionNumber = modelVersionNumber
        self.status = status
    }
}

struct UpdateModelVersionOutputResponseBody: Equatable {
    public let modelId: String?
    public let modelType: ModelTypeEnum?
    public let modelVersionNumber: String?
    public let status: String?
}

extension UpdateModelVersionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case modelId
        case modelType
        case modelVersionNumber
        case status
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .modelId)
        modelId = modelIdDecoded
        let modelTypeDecoded = try containerValues.decodeIfPresent(ModelTypeEnum.self, forKey: .modelType)
        modelType = modelTypeDecoded
        let modelVersionNumberDecoded = try containerValues.decodeIfPresent(String.self, forKey: .modelVersionNumber)
        modelVersionNumber = modelVersionNumberDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
    }
}

public struct UpdateModelVersionStatusInputBodyMiddleware: Middleware {
    public let id: String = "UpdateModelVersionStatusInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateModelVersionStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateModelVersionStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateModelVersionStatusInput>
    public typealias MOutput = OperationOutput<UpdateModelVersionStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateModelVersionStatusOutputError>
}

extension UpdateModelVersionStatusInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateModelVersionStatusInput(modelId: \(String(describing: modelId)), modelType: \(String(describing: modelType)), modelVersionNumber: \(String(describing: modelVersionNumber)), status: \(String(describing: status)))"}
}

extension UpdateModelVersionStatusInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case modelId
        case modelType
        case modelVersionNumber
        case status
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let modelId = modelId {
            try encodeContainer.encode(modelId, forKey: .modelId)
        }
        if let modelType = modelType {
            try encodeContainer.encode(modelType.rawValue, forKey: .modelType)
        }
        if let modelVersionNumber = modelVersionNumber {
            try encodeContainer.encode(modelVersionNumber, forKey: .modelVersionNumber)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }
}

public struct UpdateModelVersionStatusInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateModelVersionStatusInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateModelVersionStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateModelVersionStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateModelVersionStatusInput>
    public typealias MOutput = OperationOutput<UpdateModelVersionStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateModelVersionStatusOutputError>
}

public struct UpdateModelVersionStatusInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateModelVersionStatusInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateModelVersionStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateModelVersionStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateModelVersionStatusInput>
    public typealias MOutput = OperationOutput<UpdateModelVersionStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateModelVersionStatusOutputError>
}

public struct UpdateModelVersionStatusInput: Equatable {
    /// <p>The model ID of the model version to update.</p>
    public let modelId: String?
    /// <p>The model type.</p>
    public let modelType: ModelTypeEnum?
    /// <p>The model version number.</p>
    public let modelVersionNumber: String?
    /// <p>The model version status.</p>
    public let status: ModelVersionStatus?

    public init (
        modelId: String? = nil,
        modelType: ModelTypeEnum? = nil,
        modelVersionNumber: String? = nil,
        status: ModelVersionStatus? = nil
    )
    {
        self.modelId = modelId
        self.modelType = modelType
        self.modelVersionNumber = modelVersionNumber
        self.status = status
    }
}

struct UpdateModelVersionStatusInputBody: Equatable {
    public let modelId: String?
    public let modelType: ModelTypeEnum?
    public let modelVersionNumber: String?
    public let status: ModelVersionStatus?
}

extension UpdateModelVersionStatusInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case modelId
        case modelType
        case modelVersionNumber
        case status
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .modelId)
        modelId = modelIdDecoded
        let modelTypeDecoded = try containerValues.decodeIfPresent(ModelTypeEnum.self, forKey: .modelType)
        modelType = modelTypeDecoded
        let modelVersionNumberDecoded = try containerValues.decodeIfPresent(String.self, forKey: .modelVersionNumber)
        modelVersionNumber = modelVersionNumberDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ModelVersionStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension UpdateModelVersionStatusOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateModelVersionStatusOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateModelVersionStatusOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateModelVersionStatusOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateModelVersionStatusOutputResponse()"}
}

extension UpdateModelVersionStatusOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateModelVersionStatusOutputResponse: Equatable {

    public init() {}
}

struct UpdateModelVersionStatusOutputResponseBody: Equatable {
}

extension UpdateModelVersionStatusOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateRuleMetadataInputBodyMiddleware: Middleware {
    public let id: String = "UpdateRuleMetadataInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateRuleMetadataInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateRuleMetadataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateRuleMetadataInput>
    public typealias MOutput = OperationOutput<UpdateRuleMetadataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateRuleMetadataOutputError>
}

extension UpdateRuleMetadataInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateRuleMetadataInput(description: \(String(describing: description)), rule: \(String(describing: rule)))"}
}

extension UpdateRuleMetadataInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description
        case rule
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let rule = rule {
            try encodeContainer.encode(rule, forKey: .rule)
        }
    }
}

public struct UpdateRuleMetadataInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateRuleMetadataInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateRuleMetadataInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateRuleMetadataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateRuleMetadataInput>
    public typealias MOutput = OperationOutput<UpdateRuleMetadataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateRuleMetadataOutputError>
}

public struct UpdateRuleMetadataInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateRuleMetadataInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateRuleMetadataInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateRuleMetadataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateRuleMetadataInput>
    public typealias MOutput = OperationOutput<UpdateRuleMetadataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateRuleMetadataOutputError>
}

public struct UpdateRuleMetadataInput: Equatable {
    /// <p>The rule description.</p>
    public let description: String?
    /// <p>The rule to update.</p>
    public let rule: Rule?

    public init (
        description: String? = nil,
        rule: Rule? = nil
    )
    {
        self.description = description
        self.rule = rule
    }
}

struct UpdateRuleMetadataInputBody: Equatable {
    public let rule: Rule?
    public let description: String?
}

extension UpdateRuleMetadataInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description
        case rule
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleDecoded = try containerValues.decodeIfPresent(Rule.self, forKey: .rule)
        rule = ruleDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateRuleMetadataOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateRuleMetadataOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateRuleMetadataOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateRuleMetadataOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateRuleMetadataOutputResponse()"}
}

extension UpdateRuleMetadataOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateRuleMetadataOutputResponse: Equatable {

    public init() {}
}

struct UpdateRuleMetadataOutputResponseBody: Equatable {
}

extension UpdateRuleMetadataOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateRuleVersionInputBodyMiddleware: Middleware {
    public let id: String = "UpdateRuleVersionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateRuleVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateRuleVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateRuleVersionInput>
    public typealias MOutput = OperationOutput<UpdateRuleVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateRuleVersionOutputError>
}

extension UpdateRuleVersionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateRuleVersionInput(description: \(String(describing: description)), expression: \(String(describing: expression)), language: \(String(describing: language)), outcomes: \(String(describing: outcomes)), rule: \(String(describing: rule)), tags: \(String(describing: tags)))"}
}

extension UpdateRuleVersionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description
        case expression
        case language
        case outcomes
        case rule
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let expression = expression {
            try encodeContainer.encode(expression, forKey: .expression)
        }
        if let language = language {
            try encodeContainer.encode(language.rawValue, forKey: .language)
        }
        if let outcomes = outcomes {
            var outcomesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .outcomes)
            for nonemptylistofstrings0 in outcomes {
                try outcomesContainer.encode(nonemptylistofstrings0)
            }
        }
        if let rule = rule {
            try encodeContainer.encode(rule, forKey: .rule)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct UpdateRuleVersionInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateRuleVersionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateRuleVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateRuleVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateRuleVersionInput>
    public typealias MOutput = OperationOutput<UpdateRuleVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateRuleVersionOutputError>
}

public struct UpdateRuleVersionInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateRuleVersionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateRuleVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateRuleVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateRuleVersionInput>
    public typealias MOutput = OperationOutput<UpdateRuleVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateRuleVersionOutputError>
}

public struct UpdateRuleVersionInput: Equatable {
    /// <p>The description.</p>
    public let description: String?
    /// <p>The rule expression.</p>
    public let expression: String?
    /// <p>The language.</p>
    public let language: Language?
    /// <p>The outcomes.</p>
    public let outcomes: [String]?
    /// <p>The rule to update.</p>
    public let rule: Rule?
    /// <p>The tags to assign to the rule version.</p>
    public let tags: [Tag]?

    public init (
        description: String? = nil,
        expression: String? = nil,
        language: Language? = nil,
        outcomes: [String]? = nil,
        rule: Rule? = nil,
        tags: [Tag]? = nil
    )
    {
        self.description = description
        self.expression = expression
        self.language = language
        self.outcomes = outcomes
        self.rule = rule
        self.tags = tags
    }
}

struct UpdateRuleVersionInputBody: Equatable {
    public let rule: Rule?
    public let description: String?
    public let expression: String?
    public let language: Language?
    public let outcomes: [String]?
    public let tags: [Tag]?
}

extension UpdateRuleVersionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description
        case expression
        case language
        case outcomes
        case rule
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleDecoded = try containerValues.decodeIfPresent(Rule.self, forKey: .rule)
        rule = ruleDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let expressionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .expression)
        expression = expressionDecoded
        let languageDecoded = try containerValues.decodeIfPresent(Language.self, forKey: .language)
        language = languageDecoded
        let outcomesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .outcomes)
        var outcomesDecoded0:[String]? = nil
        if let outcomesContainer = outcomesContainer {
            outcomesDecoded0 = [String]()
            for string0 in outcomesContainer {
                if let string0 = string0 {
                    outcomesDecoded0?.append(string0)
                }
            }
        }
        outcomes = outcomesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension UpdateRuleVersionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateRuleVersionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateRuleVersionOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateRuleVersionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateRuleVersionOutputResponse(rule: \(String(describing: rule)))"}
}

extension UpdateRuleVersionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateRuleVersionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.rule = output.rule
        } else {
            self.rule = nil
        }
    }
}

public struct UpdateRuleVersionOutputResponse: Equatable {
    /// <p>The new rule version that was created.</p>
    public let rule: Rule?

    public init (
        rule: Rule? = nil
    )
    {
        self.rule = rule
    }
}

struct UpdateRuleVersionOutputResponseBody: Equatable {
    public let rule: Rule?
}

extension UpdateRuleVersionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case rule
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleDecoded = try containerValues.decodeIfPresent(Rule.self, forKey: .rule)
        rule = ruleDecoded
    }
}

public struct UpdateVariableInputBodyMiddleware: Middleware {
    public let id: String = "UpdateVariableInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateVariableInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateVariableOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateVariableInput>
    public typealias MOutput = OperationOutput<UpdateVariableOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateVariableOutputError>
}

extension UpdateVariableInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateVariableInput(defaultValue: \(String(describing: defaultValue)), description: \(String(describing: description)), name: \(String(describing: name)), variableType: \(String(describing: variableType)))"}
}

extension UpdateVariableInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case defaultValue
        case description
        case name
        case variableType
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultValue = defaultValue {
            try encodeContainer.encode(defaultValue, forKey: .defaultValue)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let variableType = variableType {
            try encodeContainer.encode(variableType, forKey: .variableType)
        }
    }
}

public struct UpdateVariableInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateVariableInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateVariableInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateVariableOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateVariableInput>
    public typealias MOutput = OperationOutput<UpdateVariableOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateVariableOutputError>
}

public struct UpdateVariableInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateVariableInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateVariableInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateVariableOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateVariableInput>
    public typealias MOutput = OperationOutput<UpdateVariableOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateVariableOutputError>
}

public struct UpdateVariableInput: Equatable {
    /// <p>The new default value of the variable.</p>
    public let defaultValue: String?
    /// <p>The new description.</p>
    public let description: String?
    /// <p>The name of the variable.</p>
    public let name: String?
    /// <p>The variable type. For more information see <a href="https://docs.aws.amazon.com/frauddetector/latest/ug/create-a-variable.html#variable-types">Variable types</a>.</p>
    public let variableType: String?

    public init (
        defaultValue: String? = nil,
        description: String? = nil,
        name: String? = nil,
        variableType: String? = nil
    )
    {
        self.defaultValue = defaultValue
        self.description = description
        self.name = name
        self.variableType = variableType
    }
}

struct UpdateVariableInputBody: Equatable {
    public let name: String?
    public let defaultValue: String?
    public let description: String?
    public let variableType: String?
}

extension UpdateVariableInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case defaultValue
        case description
        case name
        case variableType
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let defaultValueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let variableTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .variableType)
        variableType = variableTypeDecoded
    }
}

extension UpdateVariableOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateVariableOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateVariableOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateVariableOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateVariableOutputResponse()"}
}

extension UpdateVariableOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateVariableOutputResponse: Equatable {

    public init() {}
}

struct UpdateVariableOutputResponseBody: Equatable {
}

extension UpdateVariableOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ValidationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ValidationException(message: \(String(describing: message)))"}
}

extension ValidationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An exception indicating a specified value is not allowed.</p>
public struct ValidationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Equatable {
    public let message: String?
}

extension ValidationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Variable: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case createdTime
        case dataSource
        case dataType
        case defaultValue
        case description
        case lastUpdatedTime
        case name
        case variableType
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime, forKey: .createdTime)
        }
        if let dataSource = dataSource {
            try encodeContainer.encode(dataSource.rawValue, forKey: .dataSource)
        }
        if let dataType = dataType {
            try encodeContainer.encode(dataType.rawValue, forKey: .dataType)
        }
        if let defaultValue = defaultValue {
            try encodeContainer.encode(defaultValue, forKey: .defaultValue)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let lastUpdatedTime = lastUpdatedTime {
            try encodeContainer.encode(lastUpdatedTime, forKey: .lastUpdatedTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let variableType = variableType {
            try encodeContainer.encode(variableType, forKey: .variableType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let dataTypeDecoded = try containerValues.decodeIfPresent(DataType.self, forKey: .dataType)
        dataType = dataTypeDecoded
        let dataSourceDecoded = try containerValues.decodeIfPresent(DataSource.self, forKey: .dataSource)
        dataSource = dataSourceDecoded
        let defaultValueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let variableTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .variableType)
        variableType = variableTypeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension Variable: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Variable(arn: \(String(describing: arn)), createdTime: \(String(describing: createdTime)), dataSource: \(String(describing: dataSource)), dataType: \(String(describing: dataType)), defaultValue: \(String(describing: defaultValue)), description: \(String(describing: description)), lastUpdatedTime: \(String(describing: lastUpdatedTime)), name: \(String(describing: name)), variableType: \(String(describing: variableType)))"}
}

/// <p>The variable.</p>
public struct Variable: Equatable {
    /// <p>The ARN of the variable.</p>
    public let arn: String?
    /// <p>The time when the variable was created.</p>
    public let createdTime: String?
    /// <p>The data source of the variable.</p>
    public let dataSource: DataSource?
    /// <p>The data type of the variable. For more information see <a href="https://docs.aws.amazon.com/frauddetector/latest/ug/create-a-variable.html#variable-types">Variable types</a>.</p>
    public let dataType: DataType?
    /// <p>The default value of the variable.</p>
    public let defaultValue: String?
    /// <p>The description of the variable. </p>
    public let description: String?
    /// <p>The time when variable was last updated.</p>
    public let lastUpdatedTime: String?
    /// <p>The name of the variable.</p>
    public let name: String?
    /// <p>The variable type of the variable.</p>
    ///          <p>Valid Values: <code>AUTH_CODE | AVS | BILLING_ADDRESS_L1 | BILLING_ADDRESS_L2 | BILLING_CITY | BILLING_COUNTRY | BILLING_NAME | BILLING_PHONE | BILLING_STATE | BILLING_ZIP | CARD_BIN | CATEGORICAL | CURRENCY_CODE | EMAIL_ADDRESS | FINGERPRINT | FRAUD_LABEL | FREE_FORM_TEXT | IP_ADDRESS | NUMERIC | ORDER_ID | PAYMENT_TYPE | PHONE_NUMBER | PRICE | PRODUCT_CATEGORY | SHIPPING_ADDRESS_L1 | SHIPPING_ADDRESS_L2 | SHIPPING_CITY | SHIPPING_COUNTRY | SHIPPING_NAME | SHIPPING_PHONE | SHIPPING_STATE | SHIPPING_ZIP | USERAGENT </code>
    ///          </p>
    public let variableType: String?

    public init (
        arn: String? = nil,
        createdTime: String? = nil,
        dataSource: DataSource? = nil,
        dataType: DataType? = nil,
        defaultValue: String? = nil,
        description: String? = nil,
        lastUpdatedTime: String? = nil,
        name: String? = nil,
        variableType: String? = nil
    )
    {
        self.arn = arn
        self.createdTime = createdTime
        self.dataSource = dataSource
        self.dataType = dataType
        self.defaultValue = defaultValue
        self.description = description
        self.lastUpdatedTime = lastUpdatedTime
        self.name = name
        self.variableType = variableType
    }
}

extension VariableEntry: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dataSource
        case dataType
        case defaultValue
        case description
        case name
        case variableType
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSource = dataSource {
            try encodeContainer.encode(dataSource, forKey: .dataSource)
        }
        if let dataType = dataType {
            try encodeContainer.encode(dataType, forKey: .dataType)
        }
        if let defaultValue = defaultValue {
            try encodeContainer.encode(defaultValue, forKey: .defaultValue)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let variableType = variableType {
            try encodeContainer.encode(variableType, forKey: .variableType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let dataTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dataType)
        dataType = dataTypeDecoded
        let dataSourceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dataSource)
        dataSource = dataSourceDecoded
        let defaultValueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let variableTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .variableType)
        variableType = variableTypeDecoded
    }
}

extension VariableEntry: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VariableEntry(dataSource: \(String(describing: dataSource)), dataType: \(String(describing: dataType)), defaultValue: \(String(describing: defaultValue)), description: \(String(describing: description)), name: \(String(describing: name)), variableType: \(String(describing: variableType)))"}
}

/// <p>A variable in the list of variables for the batch create variable request.</p>
public struct VariableEntry: Equatable {
    /// <p>The data source of the variable.</p>
    public let dataSource: String?
    /// <p>The data type of the variable.</p>
    public let dataType: String?
    /// <p>The default value of the variable.</p>
    public let defaultValue: String?
    /// <p>The description of the variable.</p>
    public let description: String?
    /// <p>The name of the variable.</p>
    public let name: String?
    /// <p>The type of the variable. For more information see <a href="https://docs.aws.amazon.com/frauddetector/latest/ug/create-a-variable.html#variable-types">Variable types</a>.</p>
    ///          <p>Valid Values: <code>AUTH_CODE | AVS | BILLING_ADDRESS_L1 | BILLING_ADDRESS_L2 | BILLING_CITY | BILLING_COUNTRY | BILLING_NAME | BILLING_PHONE | BILLING_STATE | BILLING_ZIP | CARD_BIN | CATEGORICAL | CURRENCY_CODE | EMAIL_ADDRESS | FINGERPRINT | FRAUD_LABEL | FREE_FORM_TEXT | IP_ADDRESS | NUMERIC | ORDER_ID | PAYMENT_TYPE | PHONE_NUMBER | PRICE | PRODUCT_CATEGORY | SHIPPING_ADDRESS_L1 | SHIPPING_ADDRESS_L2 | SHIPPING_CITY | SHIPPING_COUNTRY | SHIPPING_NAME | SHIPPING_PHONE | SHIPPING_STATE | SHIPPING_ZIP | USERAGENT </code>
    ///          </p>
    public let variableType: String?

    public init (
        dataSource: String? = nil,
        dataType: String? = nil,
        defaultValue: String? = nil,
        description: String? = nil,
        name: String? = nil,
        variableType: String? = nil
    )
    {
        self.dataSource = dataSource
        self.dataType = dataType
        self.defaultValue = defaultValue
        self.description = description
        self.name = name
        self.variableType = variableType
    }
}
