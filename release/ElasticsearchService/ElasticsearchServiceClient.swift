// Code generated by smithy-swift-codegen. DO NOT EDIT!

import AWSClientRuntime
import ClientRuntime
import Foundation

public class ElasticsearchServiceClient {
    let client: SdkHttpClient
    let config: ElasticsearchServiceClientConfiguration
    let serviceName = "Elasticsearch Service"
    let encoder: RequestEncoder
    let decoder: ResponseDecoder

    public init(config: ElasticsearchServiceClientConfiguration) {
        client = SdkHttpClient(engine: config.httpClientEngine, config: config.httpClientConfiguration)
        let encoder = JSONEncoder()
        encoder.dateEncodingStrategy = .secondsSince1970
        self.encoder = config.encoder ?? encoder
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .secondsSince1970
        self.decoder = config.decoder ?? decoder
        self.config = config
    }

    public class ElasticsearchServiceClientConfiguration: ClientRuntime.Configuration, AWSClientConfiguration {

        public var region: String
        public var credentialsProvider: AWSCredentialsProvider
        public var signingRegion: String
        public var endpointResolver: EndpointResolver

        public init (
            credentialsProvider: AWSCredentialsProvider,
            endpointResolver: EndpointResolver,
            region: String,
            signingRegion: String
        ) throws
        {
            self.credentialsProvider = credentialsProvider
            self.endpointResolver = endpointResolver
            self.region = region
            self.signingRegion = signingRegion
        }

        public convenience init(credentialsProvider: AWSCredentialsProvider) throws {
            let region = "us-east-1"
            let signingRegion = "us-east-1"
            let endpointResolver = DefaultEndpointResolver()
            try self.init(
                credentialsProvider: credentialsProvider,
                endpointResolver: endpointResolver,
                region: region,
                signingRegion: signingRegion
            )
        }

        public static func `default`() throws -> ElasticsearchServiceClientConfiguration {
            let awsCredsProvider = try AWSCredentialsProvider.fromEnv()
            return try ElasticsearchServiceClientConfiguration(credentialsProvider: awsCredsProvider)
        }
    }
}

extension ElasticsearchServiceClient: ElasticsearchServiceClientProtocol {
    /// <p>Allows the destination domain owner to accept an inbound cross-cluster search connection request.</p>
    public func acceptInboundCrossClusterSearchConnection(input: AcceptInboundCrossClusterSearchConnectionInput, completion: @escaping (SdkResult<AcceptInboundCrossClusterSearchConnectionOutput, AcceptInboundCrossClusterSearchConnectionOutputError>) -> Void)
    {
        guard let crossClusterSearchConnectionId = input.crossClusterSearchConnectionId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component crossClusterSearchConnectionId unexpectedly nil"))))
            return
        }
        let urlPath = "/2015-01-01/es/ccs/inboundConnection/\(crossClusterSearchConnectionId)/accept"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "acceptInboundCrossClusterSearchConnection")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "es.\(config.region).amazonaws.com")
                      .withSigningName(value: "es")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<AcceptInboundCrossClusterSearchConnectionInput, AcceptInboundCrossClusterSearchConnectionOutput, AcceptInboundCrossClusterSearchConnectionOutputError>(id: "acceptInboundCrossClusterSearchConnection")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: AcceptInboundCrossClusterSearchConnectionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: AcceptInboundCrossClusterSearchConnectionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<AcceptInboundCrossClusterSearchConnectionInput, AcceptInboundCrossClusterSearchConnectionOutput, AcceptInboundCrossClusterSearchConnectionOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Attaches tags to an existing Elasticsearch domain. Tags are a set of case-sensitive key value pairs. An Elasticsearch domain may have up to 10 tags.  See <a href="http://docs.aws.amazon.com/elasticsearch-service/latest/developerguide/es-managedomains.html#es-managedomains-awsresorcetagging" target="_blank">
    ///           Tagging Amazon Elasticsearch Service Domains for more information.</a></p>
    public func addTags(input: AddTagsInput, completion: @escaping (SdkResult<AddTagsOutput, AddTagsOutputError>) -> Void)
    {
        let urlPath = "/2015-01-01/tags"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "addTags")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "es.\(config.region).amazonaws.com")
                      .withSigningName(value: "es")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<AddTagsInput, AddTagsOutput, AddTagsOutputError>(id: "addTags")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: AddTagsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: AddTagsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<AddTagsInput, AddTagsOutput, AddTagsOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: AddTagsInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Associates a package with an Amazon ES domain.</p>
    public func associatePackage(input: AssociatePackageInput, completion: @escaping (SdkResult<AssociatePackageOutput, AssociatePackageOutputError>) -> Void)
    {
        guard let packageID = input.packageID else {
            completion(.failure(.client(ClientError.serializationFailed("uri component packageID unexpectedly nil"))))
            return
        }
        guard let domainName = input.domainName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component domainName unexpectedly nil"))))
            return
        }
        let urlPath = "/2015-01-01/packages/associate/\(packageID)/\(domainName)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "associatePackage")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "es.\(config.region).amazonaws.com")
                      .withSigningName(value: "es")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<AssociatePackageInput, AssociatePackageOutput, AssociatePackageOutputError>(id: "associatePackage")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: AssociatePackageInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: AssociatePackageInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<AssociatePackageInput, AssociatePackageOutput, AssociatePackageOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Cancels a scheduled service software update for an Amazon ES domain. You can only perform this operation before the <code>AutomatedUpdateDate</code> and when the <code>UpdateStatus</code> is in the <code>PENDING_UPDATE</code> state.</p>
    public func cancelElasticsearchServiceSoftwareUpdate(input: CancelElasticsearchServiceSoftwareUpdateInput, completion: @escaping (SdkResult<CancelElasticsearchServiceSoftwareUpdateOutput, CancelElasticsearchServiceSoftwareUpdateOutputError>) -> Void)
    {
        let urlPath = "/2015-01-01/es/serviceSoftwareUpdate/cancel"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "cancelElasticsearchServiceSoftwareUpdate")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "es.\(config.region).amazonaws.com")
                      .withSigningName(value: "es")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CancelElasticsearchServiceSoftwareUpdateInput, CancelElasticsearchServiceSoftwareUpdateOutput, CancelElasticsearchServiceSoftwareUpdateOutputError>(id: "cancelElasticsearchServiceSoftwareUpdate")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CancelElasticsearchServiceSoftwareUpdateInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CancelElasticsearchServiceSoftwareUpdateInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CancelElasticsearchServiceSoftwareUpdateInput, CancelElasticsearchServiceSoftwareUpdateOutput, CancelElasticsearchServiceSoftwareUpdateOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CancelElasticsearchServiceSoftwareUpdateInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates a new Elasticsearch domain. For more information,
    ///           see <a href="http://docs.aws.amazon.com/elasticsearch-service/latest/developerguide/es-createupdatedomains.html#es-createdomains" target="_blank">Creating Elasticsearch Domains</a> in the <i>Amazon Elasticsearch Service Developer Guide</i>.</p>
    public func createElasticsearchDomain(input: CreateElasticsearchDomainInput, completion: @escaping (SdkResult<CreateElasticsearchDomainOutput, CreateElasticsearchDomainOutputError>) -> Void)
    {
        let urlPath = "/2015-01-01/es/domain"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createElasticsearchDomain")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "es.\(config.region).amazonaws.com")
                      .withSigningName(value: "es")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateElasticsearchDomainInput, CreateElasticsearchDomainOutput, CreateElasticsearchDomainOutputError>(id: "createElasticsearchDomain")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateElasticsearchDomainInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateElasticsearchDomainInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateElasticsearchDomainInput, CreateElasticsearchDomainOutput, CreateElasticsearchDomainOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateElasticsearchDomainInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates a new cross-cluster search connection from a source domain to a destination domain.</p>
    public func createOutboundCrossClusterSearchConnection(input: CreateOutboundCrossClusterSearchConnectionInput, completion: @escaping (SdkResult<CreateOutboundCrossClusterSearchConnectionOutput, CreateOutboundCrossClusterSearchConnectionOutputError>) -> Void)
    {
        let urlPath = "/2015-01-01/es/ccs/outboundConnection"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createOutboundCrossClusterSearchConnection")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "es.\(config.region).amazonaws.com")
                      .withSigningName(value: "es")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateOutboundCrossClusterSearchConnectionInput, CreateOutboundCrossClusterSearchConnectionOutput, CreateOutboundCrossClusterSearchConnectionOutputError>(id: "createOutboundCrossClusterSearchConnection")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateOutboundCrossClusterSearchConnectionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateOutboundCrossClusterSearchConnectionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateOutboundCrossClusterSearchConnectionInput, CreateOutboundCrossClusterSearchConnectionOutput, CreateOutboundCrossClusterSearchConnectionOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateOutboundCrossClusterSearchConnectionInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Create a package for use with Amazon ES domains.</p>
    public func createPackage(input: CreatePackageInput, completion: @escaping (SdkResult<CreatePackageOutput, CreatePackageOutputError>) -> Void)
    {
        let urlPath = "/2015-01-01/packages"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createPackage")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "es.\(config.region).amazonaws.com")
                      .withSigningName(value: "es")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreatePackageInput, CreatePackageOutput, CreatePackageOutputError>(id: "createPackage")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreatePackageInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreatePackageInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreatePackageInput, CreatePackageOutput, CreatePackageOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreatePackageInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Permanently deletes the specified Elasticsearch domain and all of its data. Once a domain is deleted, it cannot be recovered.</p>
    public func deleteElasticsearchDomain(input: DeleteElasticsearchDomainInput, completion: @escaping (SdkResult<DeleteElasticsearchDomainOutput, DeleteElasticsearchDomainOutputError>) -> Void)
    {
        guard let domainName = input.domainName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component domainName unexpectedly nil"))))
            return
        }
        let urlPath = "/2015-01-01/es/domain/\(domainName)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteElasticsearchDomain")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "es.\(config.region).amazonaws.com")
                      .withSigningName(value: "es")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteElasticsearchDomainInput, DeleteElasticsearchDomainOutput, DeleteElasticsearchDomainOutputError>(id: "deleteElasticsearchDomain")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteElasticsearchDomainInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteElasticsearchDomainInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteElasticsearchDomainInput, DeleteElasticsearchDomainOutput, DeleteElasticsearchDomainOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes the service-linked role that Elasticsearch Service uses to manage and maintain VPC domains. Role deletion will fail if any existing VPC domains use the role. You must delete any such Elasticsearch domains before deleting the role. See <a href="http://docs.aws.amazon.com/elasticsearch-service/latest/developerguide/es-vpc.html#es-enabling-slr" target="_blank">Deleting Elasticsearch Service Role</a> in <i>VPC Endpoints for Amazon Elasticsearch Service Domains</i>.</p>
    public func deleteElasticsearchServiceRole(input: DeleteElasticsearchServiceRoleInput, completion: @escaping (SdkResult<DeleteElasticsearchServiceRoleOutput, DeleteElasticsearchServiceRoleOutputError>) -> Void)
    {
        let urlPath = "/2015-01-01/es/role"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteElasticsearchServiceRole")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "es.\(config.region).amazonaws.com")
                      .withSigningName(value: "es")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteElasticsearchServiceRoleInput, DeleteElasticsearchServiceRoleOutput, DeleteElasticsearchServiceRoleOutputError>(id: "deleteElasticsearchServiceRole")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteElasticsearchServiceRoleInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteElasticsearchServiceRoleInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteElasticsearchServiceRoleInput, DeleteElasticsearchServiceRoleOutput, DeleteElasticsearchServiceRoleOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Allows the destination domain owner to delete an existing inbound cross-cluster search connection.</p>
    public func deleteInboundCrossClusterSearchConnection(input: DeleteInboundCrossClusterSearchConnectionInput, completion: @escaping (SdkResult<DeleteInboundCrossClusterSearchConnectionOutput, DeleteInboundCrossClusterSearchConnectionOutputError>) -> Void)
    {
        guard let crossClusterSearchConnectionId = input.crossClusterSearchConnectionId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component crossClusterSearchConnectionId unexpectedly nil"))))
            return
        }
        let urlPath = "/2015-01-01/es/ccs/inboundConnection/\(crossClusterSearchConnectionId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteInboundCrossClusterSearchConnection")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "es.\(config.region).amazonaws.com")
                      .withSigningName(value: "es")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteInboundCrossClusterSearchConnectionInput, DeleteInboundCrossClusterSearchConnectionOutput, DeleteInboundCrossClusterSearchConnectionOutputError>(id: "deleteInboundCrossClusterSearchConnection")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteInboundCrossClusterSearchConnectionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteInboundCrossClusterSearchConnectionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteInboundCrossClusterSearchConnectionInput, DeleteInboundCrossClusterSearchConnectionOutput, DeleteInboundCrossClusterSearchConnectionOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Allows the source domain owner to delete an existing outbound cross-cluster search connection.</p>
    public func deleteOutboundCrossClusterSearchConnection(input: DeleteOutboundCrossClusterSearchConnectionInput, completion: @escaping (SdkResult<DeleteOutboundCrossClusterSearchConnectionOutput, DeleteOutboundCrossClusterSearchConnectionOutputError>) -> Void)
    {
        guard let crossClusterSearchConnectionId = input.crossClusterSearchConnectionId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component crossClusterSearchConnectionId unexpectedly nil"))))
            return
        }
        let urlPath = "/2015-01-01/es/ccs/outboundConnection/\(crossClusterSearchConnectionId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteOutboundCrossClusterSearchConnection")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "es.\(config.region).amazonaws.com")
                      .withSigningName(value: "es")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteOutboundCrossClusterSearchConnectionInput, DeleteOutboundCrossClusterSearchConnectionOutput, DeleteOutboundCrossClusterSearchConnectionOutputError>(id: "deleteOutboundCrossClusterSearchConnection")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteOutboundCrossClusterSearchConnectionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteOutboundCrossClusterSearchConnectionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteOutboundCrossClusterSearchConnectionInput, DeleteOutboundCrossClusterSearchConnectionOutput, DeleteOutboundCrossClusterSearchConnectionOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Delete the package.</p>
    public func deletePackage(input: DeletePackageInput, completion: @escaping (SdkResult<DeletePackageOutput, DeletePackageOutputError>) -> Void)
    {
        guard let packageID = input.packageID else {
            completion(.failure(.client(ClientError.serializationFailed("uri component packageID unexpectedly nil"))))
            return
        }
        let urlPath = "/2015-01-01/packages/\(packageID)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deletePackage")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "es.\(config.region).amazonaws.com")
                      .withSigningName(value: "es")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeletePackageInput, DeletePackageOutput, DeletePackageOutputError>(id: "deletePackage")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeletePackageInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeletePackageInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeletePackageInput, DeletePackageOutput, DeletePackageOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Provides scheduled Auto-Tune action details for the Elasticsearch domain, such as Auto-Tune action type, description, severity, and scheduled date.</p>
    public func describeDomainAutoTunes(input: DescribeDomainAutoTunesInput, completion: @escaping (SdkResult<DescribeDomainAutoTunesOutput, DescribeDomainAutoTunesOutputError>) -> Void)
    {
        guard let domainName = input.domainName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component domainName unexpectedly nil"))))
            return
        }
        let urlPath = "/2015-01-01/es/domain/\(domainName)/autoTunes"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeDomainAutoTunes")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "es.\(config.region).amazonaws.com")
                      .withSigningName(value: "es")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeDomainAutoTunesInput, DescribeDomainAutoTunesOutput, DescribeDomainAutoTunesOutputError>(id: "describeDomainAutoTunes")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeDomainAutoTunesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeDomainAutoTunesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeDomainAutoTunesInput, DescribeDomainAutoTunesOutput, DescribeDomainAutoTunesOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: DescribeDomainAutoTunesInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns domain configuration information about the specified Elasticsearch domain, including the domain ID, domain endpoint, and domain ARN.</p>
    public func describeElasticsearchDomain(input: DescribeElasticsearchDomainInput, completion: @escaping (SdkResult<DescribeElasticsearchDomainOutput, DescribeElasticsearchDomainOutputError>) -> Void)
    {
        guard let domainName = input.domainName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component domainName unexpectedly nil"))))
            return
        }
        let urlPath = "/2015-01-01/es/domain/\(domainName)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeElasticsearchDomain")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "es.\(config.region).amazonaws.com")
                      .withSigningName(value: "es")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeElasticsearchDomainInput, DescribeElasticsearchDomainOutput, DescribeElasticsearchDomainOutputError>(id: "describeElasticsearchDomain")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeElasticsearchDomainInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeElasticsearchDomainInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeElasticsearchDomainInput, DescribeElasticsearchDomainOutput, DescribeElasticsearchDomainOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Provides cluster configuration information about the specified Elasticsearch domain, such as the state, creation date, update version, and update date for cluster options.</p>
    public func describeElasticsearchDomainConfig(input: DescribeElasticsearchDomainConfigInput, completion: @escaping (SdkResult<DescribeElasticsearchDomainConfigOutput, DescribeElasticsearchDomainConfigOutputError>) -> Void)
    {
        guard let domainName = input.domainName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component domainName unexpectedly nil"))))
            return
        }
        let urlPath = "/2015-01-01/es/domain/\(domainName)/config"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeElasticsearchDomainConfig")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "es.\(config.region).amazonaws.com")
                      .withSigningName(value: "es")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeElasticsearchDomainConfigInput, DescribeElasticsearchDomainConfigOutput, DescribeElasticsearchDomainConfigOutputError>(id: "describeElasticsearchDomainConfig")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeElasticsearchDomainConfigInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeElasticsearchDomainConfigInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeElasticsearchDomainConfigInput, DescribeElasticsearchDomainConfigOutput, DescribeElasticsearchDomainConfigOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns domain configuration information about the specified Elasticsearch domains, including the domain ID, domain endpoint, and domain ARN.</p>
    public func describeElasticsearchDomains(input: DescribeElasticsearchDomainsInput, completion: @escaping (SdkResult<DescribeElasticsearchDomainsOutput, DescribeElasticsearchDomainsOutputError>) -> Void)
    {
        let urlPath = "/2015-01-01/es/domain-info"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeElasticsearchDomains")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "es.\(config.region).amazonaws.com")
                      .withSigningName(value: "es")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeElasticsearchDomainsInput, DescribeElasticsearchDomainsOutput, DescribeElasticsearchDomainsOutputError>(id: "describeElasticsearchDomains")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeElasticsearchDomainsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeElasticsearchDomainsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeElasticsearchDomainsInput, DescribeElasticsearchDomainsOutput, DescribeElasticsearchDomainsOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: DescribeElasticsearchDomainsInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>
    ///     Describe Elasticsearch Limits for a given InstanceType and ElasticsearchVersion.
    ///     When modifying existing Domain, specify the
    ///     <code>
    ///       <a>DomainName</a>
    ///     </code>
    ///     to know what Limits are supported for modifying.
    ///   </p>
    public func describeElasticsearchInstanceTypeLimits(input: DescribeElasticsearchInstanceTypeLimitsInput, completion: @escaping (SdkResult<DescribeElasticsearchInstanceTypeLimitsOutput, DescribeElasticsearchInstanceTypeLimitsOutputError>) -> Void)
    {
        guard let elasticsearchVersion = input.elasticsearchVersion else {
            completion(.failure(.client(ClientError.serializationFailed("uri component elasticsearchVersion unexpectedly nil"))))
            return
        }
        guard let instanceType = input.instanceType else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceType unexpectedly nil"))))
            return
        }
        let urlPath = "/2015-01-01/es/instanceTypeLimits/\(elasticsearchVersion)/\(instanceType.rawValue)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeElasticsearchInstanceTypeLimits")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "es.\(config.region).amazonaws.com")
                      .withSigningName(value: "es")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeElasticsearchInstanceTypeLimitsInput, DescribeElasticsearchInstanceTypeLimitsOutput, DescribeElasticsearchInstanceTypeLimitsOutputError>(id: "describeElasticsearchInstanceTypeLimits")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeElasticsearchInstanceTypeLimitsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeElasticsearchInstanceTypeLimitsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeElasticsearchInstanceTypeLimitsInput, DescribeElasticsearchInstanceTypeLimitsOutput, DescribeElasticsearchInstanceTypeLimitsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Lists all the inbound cross-cluster search connections for a destination domain.</p>
    public func describeInboundCrossClusterSearchConnections(input: DescribeInboundCrossClusterSearchConnectionsInput, completion: @escaping (SdkResult<DescribeInboundCrossClusterSearchConnectionsOutput, DescribeInboundCrossClusterSearchConnectionsOutputError>) -> Void)
    {
        let urlPath = "/2015-01-01/es/ccs/inboundConnection/search"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeInboundCrossClusterSearchConnections")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "es.\(config.region).amazonaws.com")
                      .withSigningName(value: "es")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeInboundCrossClusterSearchConnectionsInput, DescribeInboundCrossClusterSearchConnectionsOutput, DescribeInboundCrossClusterSearchConnectionsOutputError>(id: "describeInboundCrossClusterSearchConnections")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeInboundCrossClusterSearchConnectionsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeInboundCrossClusterSearchConnectionsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeInboundCrossClusterSearchConnectionsInput, DescribeInboundCrossClusterSearchConnectionsOutput, DescribeInboundCrossClusterSearchConnectionsOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: DescribeInboundCrossClusterSearchConnectionsInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Lists all the outbound cross-cluster search connections for a source domain.</p>
    public func describeOutboundCrossClusterSearchConnections(input: DescribeOutboundCrossClusterSearchConnectionsInput, completion: @escaping (SdkResult<DescribeOutboundCrossClusterSearchConnectionsOutput, DescribeOutboundCrossClusterSearchConnectionsOutputError>) -> Void)
    {
        let urlPath = "/2015-01-01/es/ccs/outboundConnection/search"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeOutboundCrossClusterSearchConnections")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "es.\(config.region).amazonaws.com")
                      .withSigningName(value: "es")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeOutboundCrossClusterSearchConnectionsInput, DescribeOutboundCrossClusterSearchConnectionsOutput, DescribeOutboundCrossClusterSearchConnectionsOutputError>(id: "describeOutboundCrossClusterSearchConnections")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeOutboundCrossClusterSearchConnectionsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeOutboundCrossClusterSearchConnectionsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeOutboundCrossClusterSearchConnectionsInput, DescribeOutboundCrossClusterSearchConnectionsOutput, DescribeOutboundCrossClusterSearchConnectionsOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: DescribeOutboundCrossClusterSearchConnectionsInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Describes all packages available to Amazon ES. Includes options for filtering, limiting the number of results, and pagination.</p>
    public func describePackages(input: DescribePackagesInput, completion: @escaping (SdkResult<DescribePackagesOutput, DescribePackagesOutputError>) -> Void)
    {
        let urlPath = "/2015-01-01/packages/describe"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describePackages")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "es.\(config.region).amazonaws.com")
                      .withSigningName(value: "es")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribePackagesInput, DescribePackagesOutput, DescribePackagesOutputError>(id: "describePackages")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribePackagesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribePackagesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribePackagesInput, DescribePackagesOutput, DescribePackagesOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: DescribePackagesInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Lists available reserved Elasticsearch instance offerings.</p>
    public func describeReservedElasticsearchInstanceOfferings(input: DescribeReservedElasticsearchInstanceOfferingsInput, completion: @escaping (SdkResult<DescribeReservedElasticsearchInstanceOfferingsOutput, DescribeReservedElasticsearchInstanceOfferingsOutputError>) -> Void)
    {
        let urlPath = "/2015-01-01/es/reservedInstanceOfferings"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeReservedElasticsearchInstanceOfferings")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "es.\(config.region).amazonaws.com")
                      .withSigningName(value: "es")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeReservedElasticsearchInstanceOfferingsInput, DescribeReservedElasticsearchInstanceOfferingsOutput, DescribeReservedElasticsearchInstanceOfferingsOutputError>(id: "describeReservedElasticsearchInstanceOfferings")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeReservedElasticsearchInstanceOfferingsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeReservedElasticsearchInstanceOfferingsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeReservedElasticsearchInstanceOfferingsInput, DescribeReservedElasticsearchInstanceOfferingsOutput, DescribeReservedElasticsearchInstanceOfferingsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns information about reserved Elasticsearch instances for this account.</p>
    public func describeReservedElasticsearchInstances(input: DescribeReservedElasticsearchInstancesInput, completion: @escaping (SdkResult<DescribeReservedElasticsearchInstancesOutput, DescribeReservedElasticsearchInstancesOutputError>) -> Void)
    {
        let urlPath = "/2015-01-01/es/reservedInstances"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeReservedElasticsearchInstances")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "es.\(config.region).amazonaws.com")
                      .withSigningName(value: "es")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeReservedElasticsearchInstancesInput, DescribeReservedElasticsearchInstancesOutput, DescribeReservedElasticsearchInstancesOutputError>(id: "describeReservedElasticsearchInstances")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeReservedElasticsearchInstancesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeReservedElasticsearchInstancesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeReservedElasticsearchInstancesInput, DescribeReservedElasticsearchInstancesOutput, DescribeReservedElasticsearchInstancesOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Dissociates a package from the Amazon ES domain.</p>
    public func dissociatePackage(input: DissociatePackageInput, completion: @escaping (SdkResult<DissociatePackageOutput, DissociatePackageOutputError>) -> Void)
    {
        guard let packageID = input.packageID else {
            completion(.failure(.client(ClientError.serializationFailed("uri component packageID unexpectedly nil"))))
            return
        }
        guard let domainName = input.domainName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component domainName unexpectedly nil"))))
            return
        }
        let urlPath = "/2015-01-01/packages/dissociate/\(packageID)/\(domainName)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "dissociatePackage")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "es.\(config.region).amazonaws.com")
                      .withSigningName(value: "es")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DissociatePackageInput, DissociatePackageOutput, DissociatePackageOutputError>(id: "dissociatePackage")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DissociatePackageInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DissociatePackageInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DissociatePackageInput, DissociatePackageOutput, DissociatePackageOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>
    ///         Returns a list of upgrade compatible Elastisearch versions.
    ///         You can optionally pass a
    ///         <code>
    ///           <a>DomainName</a>
    ///         </code>
    ///         to get all upgrade compatible Elasticsearch versions for that specific domain.
    ///       </p>
    public func getCompatibleElasticsearchVersions(input: GetCompatibleElasticsearchVersionsInput, completion: @escaping (SdkResult<GetCompatibleElasticsearchVersionsOutput, GetCompatibleElasticsearchVersionsOutputError>) -> Void)
    {
        let urlPath = "/2015-01-01/es/compatibleVersions"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getCompatibleElasticsearchVersions")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "es.\(config.region).amazonaws.com")
                      .withSigningName(value: "es")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetCompatibleElasticsearchVersionsInput, GetCompatibleElasticsearchVersionsOutput, GetCompatibleElasticsearchVersionsOutputError>(id: "getCompatibleElasticsearchVersions")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetCompatibleElasticsearchVersionsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetCompatibleElasticsearchVersionsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetCompatibleElasticsearchVersionsInput, GetCompatibleElasticsearchVersionsOutput, GetCompatibleElasticsearchVersionsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns a list of versions of the package, along with their creation time and commit message.</p>
    public func getPackageVersionHistory(input: GetPackageVersionHistoryInput, completion: @escaping (SdkResult<GetPackageVersionHistoryOutput, GetPackageVersionHistoryOutputError>) -> Void)
    {
        guard let packageID = input.packageID else {
            completion(.failure(.client(ClientError.serializationFailed("uri component packageID unexpectedly nil"))))
            return
        }
        let urlPath = "/2015-01-01/packages/\(packageID)/history"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getPackageVersionHistory")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "es.\(config.region).amazonaws.com")
                      .withSigningName(value: "es")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetPackageVersionHistoryInput, GetPackageVersionHistoryOutput, GetPackageVersionHistoryOutputError>(id: "getPackageVersionHistory")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetPackageVersionHistoryInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetPackageVersionHistoryInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetPackageVersionHistoryInput, GetPackageVersionHistoryOutput, GetPackageVersionHistoryOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Retrieves the complete history of the last 10 upgrades that were performed on the domain.</p>
    public func getUpgradeHistory(input: GetUpgradeHistoryInput, completion: @escaping (SdkResult<GetUpgradeHistoryOutput, GetUpgradeHistoryOutputError>) -> Void)
    {
        guard let domainName = input.domainName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component domainName unexpectedly nil"))))
            return
        }
        let urlPath = "/2015-01-01/es/upgradeDomain/\(domainName)/history"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getUpgradeHistory")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "es.\(config.region).amazonaws.com")
                      .withSigningName(value: "es")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetUpgradeHistoryInput, GetUpgradeHistoryOutput, GetUpgradeHistoryOutputError>(id: "getUpgradeHistory")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetUpgradeHistoryInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetUpgradeHistoryInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetUpgradeHistoryInput, GetUpgradeHistoryOutput, GetUpgradeHistoryOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Retrieves the latest status of the last upgrade or upgrade eligibility check that was performed on the domain.</p>
    public func getUpgradeStatus(input: GetUpgradeStatusInput, completion: @escaping (SdkResult<GetUpgradeStatusOutput, GetUpgradeStatusOutputError>) -> Void)
    {
        guard let domainName = input.domainName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component domainName unexpectedly nil"))))
            return
        }
        let urlPath = "/2015-01-01/es/upgradeDomain/\(domainName)/status"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getUpgradeStatus")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "es.\(config.region).amazonaws.com")
                      .withSigningName(value: "es")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetUpgradeStatusInput, GetUpgradeStatusOutput, GetUpgradeStatusOutputError>(id: "getUpgradeStatus")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetUpgradeStatusInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetUpgradeStatusInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetUpgradeStatusInput, GetUpgradeStatusOutput, GetUpgradeStatusOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns the name of all Elasticsearch domains owned by the current user's account. </p>
    public func listDomainNames(input: ListDomainNamesInput, completion: @escaping (SdkResult<ListDomainNamesOutput, ListDomainNamesOutputError>) -> Void)
    {
        let urlPath = "/2015-01-01/domain"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listDomainNames")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "es.\(config.region).amazonaws.com")
                      .withSigningName(value: "es")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListDomainNamesInput, ListDomainNamesOutput, ListDomainNamesOutputError>(id: "listDomainNames")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListDomainNamesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListDomainNamesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListDomainNamesInput, ListDomainNamesOutput, ListDomainNamesOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Lists all Amazon ES domains associated with the package.</p>
    public func listDomainsForPackage(input: ListDomainsForPackageInput, completion: @escaping (SdkResult<ListDomainsForPackageOutput, ListDomainsForPackageOutputError>) -> Void)
    {
        guard let packageID = input.packageID else {
            completion(.failure(.client(ClientError.serializationFailed("uri component packageID unexpectedly nil"))))
            return
        }
        let urlPath = "/2015-01-01/packages/\(packageID)/domains"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listDomainsForPackage")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "es.\(config.region).amazonaws.com")
                      .withSigningName(value: "es")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListDomainsForPackageInput, ListDomainsForPackageOutput, ListDomainsForPackageOutputError>(id: "listDomainsForPackage")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListDomainsForPackageInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListDomainsForPackageInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListDomainsForPackageInput, ListDomainsForPackageOutput, ListDomainsForPackageOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>List all Elasticsearch instance types that are supported for given ElasticsearchVersion</p>
    public func listElasticsearchInstanceTypes(input: ListElasticsearchInstanceTypesInput, completion: @escaping (SdkResult<ListElasticsearchInstanceTypesOutput, ListElasticsearchInstanceTypesOutputError>) -> Void)
    {
        guard let elasticsearchVersion = input.elasticsearchVersion else {
            completion(.failure(.client(ClientError.serializationFailed("uri component elasticsearchVersion unexpectedly nil"))))
            return
        }
        let urlPath = "/2015-01-01/es/instanceTypes/\(elasticsearchVersion)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listElasticsearchInstanceTypes")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "es.\(config.region).amazonaws.com")
                      .withSigningName(value: "es")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListElasticsearchInstanceTypesInput, ListElasticsearchInstanceTypesOutput, ListElasticsearchInstanceTypesOutputError>(id: "listElasticsearchInstanceTypes")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListElasticsearchInstanceTypesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListElasticsearchInstanceTypesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListElasticsearchInstanceTypesInput, ListElasticsearchInstanceTypesOutput, ListElasticsearchInstanceTypesOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>List all supported Elasticsearch versions</p>
    public func listElasticsearchVersions(input: ListElasticsearchVersionsInput, completion: @escaping (SdkResult<ListElasticsearchVersionsOutput, ListElasticsearchVersionsOutputError>) -> Void)
    {
        let urlPath = "/2015-01-01/es/versions"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listElasticsearchVersions")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "es.\(config.region).amazonaws.com")
                      .withSigningName(value: "es")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListElasticsearchVersionsInput, ListElasticsearchVersionsOutput, ListElasticsearchVersionsOutputError>(id: "listElasticsearchVersions")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListElasticsearchVersionsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListElasticsearchVersionsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListElasticsearchVersionsInput, ListElasticsearchVersionsOutput, ListElasticsearchVersionsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Lists all packages associated with the Amazon ES domain.</p>
    public func listPackagesForDomain(input: ListPackagesForDomainInput, completion: @escaping (SdkResult<ListPackagesForDomainOutput, ListPackagesForDomainOutputError>) -> Void)
    {
        guard let domainName = input.domainName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component domainName unexpectedly nil"))))
            return
        }
        let urlPath = "/2015-01-01/domain/\(domainName)/packages"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listPackagesForDomain")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "es.\(config.region).amazonaws.com")
                      .withSigningName(value: "es")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListPackagesForDomainInput, ListPackagesForDomainOutput, ListPackagesForDomainOutputError>(id: "listPackagesForDomain")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListPackagesForDomainInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListPackagesForDomainInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListPackagesForDomainInput, ListPackagesForDomainOutput, ListPackagesForDomainOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns all tags for the given Elasticsearch domain.</p>
    public func listTags(input: ListTagsInput, completion: @escaping (SdkResult<ListTagsOutput, ListTagsOutputError>) -> Void)
    {
        let urlPath = "/2015-01-01/tags"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listTags")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "es.\(config.region).amazonaws.com")
                      .withSigningName(value: "es")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListTagsInput, ListTagsOutput, ListTagsOutputError>(id: "listTags")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListTagsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListTagsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListTagsInput, ListTagsOutput, ListTagsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Allows you to purchase reserved Elasticsearch instances.</p>
    public func purchaseReservedElasticsearchInstanceOffering(input: PurchaseReservedElasticsearchInstanceOfferingInput, completion: @escaping (SdkResult<PurchaseReservedElasticsearchInstanceOfferingOutput, PurchaseReservedElasticsearchInstanceOfferingOutputError>) -> Void)
    {
        let urlPath = "/2015-01-01/es/purchaseReservedInstanceOffering"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "purchaseReservedElasticsearchInstanceOffering")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "es.\(config.region).amazonaws.com")
                      .withSigningName(value: "es")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<PurchaseReservedElasticsearchInstanceOfferingInput, PurchaseReservedElasticsearchInstanceOfferingOutput, PurchaseReservedElasticsearchInstanceOfferingOutputError>(id: "purchaseReservedElasticsearchInstanceOffering")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: PurchaseReservedElasticsearchInstanceOfferingInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: PurchaseReservedElasticsearchInstanceOfferingInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<PurchaseReservedElasticsearchInstanceOfferingInput, PurchaseReservedElasticsearchInstanceOfferingOutput, PurchaseReservedElasticsearchInstanceOfferingOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: PurchaseReservedElasticsearchInstanceOfferingInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Allows the destination domain owner to reject an inbound cross-cluster search connection request.</p>
    public func rejectInboundCrossClusterSearchConnection(input: RejectInboundCrossClusterSearchConnectionInput, completion: @escaping (SdkResult<RejectInboundCrossClusterSearchConnectionOutput, RejectInboundCrossClusterSearchConnectionOutputError>) -> Void)
    {
        guard let crossClusterSearchConnectionId = input.crossClusterSearchConnectionId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component crossClusterSearchConnectionId unexpectedly nil"))))
            return
        }
        let urlPath = "/2015-01-01/es/ccs/inboundConnection/\(crossClusterSearchConnectionId)/reject"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "rejectInboundCrossClusterSearchConnection")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "es.\(config.region).amazonaws.com")
                      .withSigningName(value: "es")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<RejectInboundCrossClusterSearchConnectionInput, RejectInboundCrossClusterSearchConnectionOutput, RejectInboundCrossClusterSearchConnectionOutputError>(id: "rejectInboundCrossClusterSearchConnection")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: RejectInboundCrossClusterSearchConnectionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: RejectInboundCrossClusterSearchConnectionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<RejectInboundCrossClusterSearchConnectionInput, RejectInboundCrossClusterSearchConnectionOutput, RejectInboundCrossClusterSearchConnectionOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Removes the specified set of tags from the specified Elasticsearch domain.</p>
    public func removeTags(input: RemoveTagsInput, completion: @escaping (SdkResult<RemoveTagsOutput, RemoveTagsOutputError>) -> Void)
    {
        let urlPath = "/2015-01-01/tags-removal"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "removeTags")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "es.\(config.region).amazonaws.com")
                      .withSigningName(value: "es")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<RemoveTagsInput, RemoveTagsOutput, RemoveTagsOutputError>(id: "removeTags")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: RemoveTagsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: RemoveTagsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<RemoveTagsInput, RemoveTagsOutput, RemoveTagsOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: RemoveTagsInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Schedules a service software update for an Amazon ES domain.</p>
    public func startElasticsearchServiceSoftwareUpdate(input: StartElasticsearchServiceSoftwareUpdateInput, completion: @escaping (SdkResult<StartElasticsearchServiceSoftwareUpdateOutput, StartElasticsearchServiceSoftwareUpdateOutputError>) -> Void)
    {
        let urlPath = "/2015-01-01/es/serviceSoftwareUpdate/start"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "startElasticsearchServiceSoftwareUpdate")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "es.\(config.region).amazonaws.com")
                      .withSigningName(value: "es")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<StartElasticsearchServiceSoftwareUpdateInput, StartElasticsearchServiceSoftwareUpdateOutput, StartElasticsearchServiceSoftwareUpdateOutputError>(id: "startElasticsearchServiceSoftwareUpdate")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: StartElasticsearchServiceSoftwareUpdateInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: StartElasticsearchServiceSoftwareUpdateInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<StartElasticsearchServiceSoftwareUpdateInput, StartElasticsearchServiceSoftwareUpdateOutput, StartElasticsearchServiceSoftwareUpdateOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: StartElasticsearchServiceSoftwareUpdateInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Modifies the cluster configuration of the specified Elasticsearch domain, setting as setting the instance type and the number of instances. </p>
    public func updateElasticsearchDomainConfig(input: UpdateElasticsearchDomainConfigInput, completion: @escaping (SdkResult<UpdateElasticsearchDomainConfigOutput, UpdateElasticsearchDomainConfigOutputError>) -> Void)
    {
        guard let domainName = input.domainName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component domainName unexpectedly nil"))))
            return
        }
        let urlPath = "/2015-01-01/es/domain/\(domainName)/config"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateElasticsearchDomainConfig")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "es.\(config.region).amazonaws.com")
                      .withSigningName(value: "es")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateElasticsearchDomainConfigInput, UpdateElasticsearchDomainConfigOutput, UpdateElasticsearchDomainConfigOutputError>(id: "updateElasticsearchDomainConfig")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateElasticsearchDomainConfigInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateElasticsearchDomainConfigInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateElasticsearchDomainConfigInput, UpdateElasticsearchDomainConfigOutput, UpdateElasticsearchDomainConfigOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateElasticsearchDomainConfigInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Updates a package for use with Amazon ES domains.</p>
    public func updatePackage(input: UpdatePackageInput, completion: @escaping (SdkResult<UpdatePackageOutput, UpdatePackageOutputError>) -> Void)
    {
        let urlPath = "/2015-01-01/packages/update"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updatePackage")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "es.\(config.region).amazonaws.com")
                      .withSigningName(value: "es")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdatePackageInput, UpdatePackageOutput, UpdatePackageOutputError>(id: "updatePackage")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdatePackageInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdatePackageInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdatePackageInput, UpdatePackageOutput, UpdatePackageOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdatePackageInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Allows you to either upgrade your domain or perform an Upgrade eligibility check to a compatible Elasticsearch version.</p>
    public func upgradeElasticsearchDomain(input: UpgradeElasticsearchDomainInput, completion: @escaping (SdkResult<UpgradeElasticsearchDomainOutput, UpgradeElasticsearchDomainOutputError>) -> Void)
    {
        let urlPath = "/2015-01-01/es/upgradeDomain"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "upgradeElasticsearchDomain")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "es.\(config.region).amazonaws.com")
                      .withSigningName(value: "es")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpgradeElasticsearchDomainInput, UpgradeElasticsearchDomainOutput, UpgradeElasticsearchDomainOutputError>(id: "upgradeElasticsearchDomain")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpgradeElasticsearchDomainInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpgradeElasticsearchDomainInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpgradeElasticsearchDomainInput, UpgradeElasticsearchDomainOutput, UpgradeElasticsearchDomainOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpgradeElasticsearchDomainInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

}
