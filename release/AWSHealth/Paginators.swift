// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime


/// Paginate over `[DescribeAffectedAccountsForOrganizationOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeAffectedAccountsForOrganizationInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeAffectedAccountsForOrganizationOutputResponse`
extension HealthClient {
    public func describeAffectedAccountsForOrganizationPaginated(input: DescribeAffectedAccountsForOrganizationInput) -> ClientRuntime.PaginatorSequence<DescribeAffectedAccountsForOrganizationInput, DescribeAffectedAccountsForOrganizationOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeAffectedAccountsForOrganizationInput, DescribeAffectedAccountsForOrganizationOutputResponse>(input: input, inputKey: \DescribeAffectedAccountsForOrganizationInput.nextToken, outputKey: \DescribeAffectedAccountsForOrganizationOutputResponse.nextToken, paginationFunction: self.describeAffectedAccountsForOrganization(input:))
    }
}

extension DescribeAffectedAccountsForOrganizationInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeAffectedAccountsForOrganizationInput {
        return DescribeAffectedAccountsForOrganizationInput(
            eventArn: self.eventArn,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeAffectedAccountsForOrganizationPaginated`
/// to access the nested member `[Swift.String]`
/// - Returns: `[Swift.String]`
extension PaginatorSequence where Input == DescribeAffectedAccountsForOrganizationInput, Output == DescribeAffectedAccountsForOrganizationOutputResponse {
    func affectedAccounts() async throws -> [Swift.String] {
        return try await self.asyncCompactMap { item in item.affectedAccounts }
    }
}

/// Paginate over `[DescribeAffectedEntitiesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeAffectedEntitiesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeAffectedEntitiesOutputResponse`
extension HealthClient {
    public func describeAffectedEntitiesPaginated(input: DescribeAffectedEntitiesInput) -> ClientRuntime.PaginatorSequence<DescribeAffectedEntitiesInput, DescribeAffectedEntitiesOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeAffectedEntitiesInput, DescribeAffectedEntitiesOutputResponse>(input: input, inputKey: \DescribeAffectedEntitiesInput.nextToken, outputKey: \DescribeAffectedEntitiesOutputResponse.nextToken, paginationFunction: self.describeAffectedEntities(input:))
    }
}

extension DescribeAffectedEntitiesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeAffectedEntitiesInput {
        return DescribeAffectedEntitiesInput(
            filter: self.filter,
            locale: self.locale,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeAffectedEntitiesPaginated`
/// to access the nested member `[HealthClientTypes.AffectedEntity]`
/// - Returns: `[HealthClientTypes.AffectedEntity]`
extension PaginatorSequence where Input == DescribeAffectedEntitiesInput, Output == DescribeAffectedEntitiesOutputResponse {
    func entities() async throws -> [HealthClientTypes.AffectedEntity] {
        return try await self.asyncCompactMap { item in item.entities }
    }
}

/// Paginate over `[DescribeAffectedEntitiesForOrganizationOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeAffectedEntitiesForOrganizationInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeAffectedEntitiesForOrganizationOutputResponse`
extension HealthClient {
    public func describeAffectedEntitiesForOrganizationPaginated(input: DescribeAffectedEntitiesForOrganizationInput) -> ClientRuntime.PaginatorSequence<DescribeAffectedEntitiesForOrganizationInput, DescribeAffectedEntitiesForOrganizationOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeAffectedEntitiesForOrganizationInput, DescribeAffectedEntitiesForOrganizationOutputResponse>(input: input, inputKey: \DescribeAffectedEntitiesForOrganizationInput.nextToken, outputKey: \DescribeAffectedEntitiesForOrganizationOutputResponse.nextToken, paginationFunction: self.describeAffectedEntitiesForOrganization(input:))
    }
}

extension DescribeAffectedEntitiesForOrganizationInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeAffectedEntitiesForOrganizationInput {
        return DescribeAffectedEntitiesForOrganizationInput(
            locale: self.locale,
            maxResults: self.maxResults,
            nextToken: token,
            organizationEntityFilters: self.organizationEntityFilters
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeAffectedEntitiesForOrganizationPaginated`
/// to access the nested member `[HealthClientTypes.AffectedEntity]`
/// - Returns: `[HealthClientTypes.AffectedEntity]`
extension PaginatorSequence where Input == DescribeAffectedEntitiesForOrganizationInput, Output == DescribeAffectedEntitiesForOrganizationOutputResponse {
    func entities() async throws -> [HealthClientTypes.AffectedEntity] {
        return try await self.asyncCompactMap { item in item.entities }
    }
}

/// Paginate over `[DescribeEventAggregatesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeEventAggregatesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeEventAggregatesOutputResponse`
extension HealthClient {
    public func describeEventAggregatesPaginated(input: DescribeEventAggregatesInput) -> ClientRuntime.PaginatorSequence<DescribeEventAggregatesInput, DescribeEventAggregatesOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeEventAggregatesInput, DescribeEventAggregatesOutputResponse>(input: input, inputKey: \DescribeEventAggregatesInput.nextToken, outputKey: \DescribeEventAggregatesOutputResponse.nextToken, paginationFunction: self.describeEventAggregates(input:))
    }
}

extension DescribeEventAggregatesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeEventAggregatesInput {
        return DescribeEventAggregatesInput(
            aggregateField: self.aggregateField,
            filter: self.filter,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeEventAggregatesPaginated`
/// to access the nested member `[HealthClientTypes.EventAggregate]`
/// - Returns: `[HealthClientTypes.EventAggregate]`
extension PaginatorSequence where Input == DescribeEventAggregatesInput, Output == DescribeEventAggregatesOutputResponse {
    func eventAggregates() async throws -> [HealthClientTypes.EventAggregate] {
        return try await self.asyncCompactMap { item in item.eventAggregates }
    }
}

/// Paginate over `[DescribeEventsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeEventsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeEventsOutputResponse`
extension HealthClient {
    public func describeEventsPaginated(input: DescribeEventsInput) -> ClientRuntime.PaginatorSequence<DescribeEventsInput, DescribeEventsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeEventsInput, DescribeEventsOutputResponse>(input: input, inputKey: \DescribeEventsInput.nextToken, outputKey: \DescribeEventsOutputResponse.nextToken, paginationFunction: self.describeEvents(input:))
    }
}

extension DescribeEventsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeEventsInput {
        return DescribeEventsInput(
            filter: self.filter,
            locale: self.locale,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeEventsPaginated`
/// to access the nested member `[HealthClientTypes.Event]`
/// - Returns: `[HealthClientTypes.Event]`
extension PaginatorSequence where Input == DescribeEventsInput, Output == DescribeEventsOutputResponse {
    func events() async throws -> [HealthClientTypes.Event] {
        return try await self.asyncCompactMap { item in item.events }
    }
}

/// Paginate over `[DescribeEventsForOrganizationOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeEventsForOrganizationInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeEventsForOrganizationOutputResponse`
extension HealthClient {
    public func describeEventsForOrganizationPaginated(input: DescribeEventsForOrganizationInput) -> ClientRuntime.PaginatorSequence<DescribeEventsForOrganizationInput, DescribeEventsForOrganizationOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeEventsForOrganizationInput, DescribeEventsForOrganizationOutputResponse>(input: input, inputKey: \DescribeEventsForOrganizationInput.nextToken, outputKey: \DescribeEventsForOrganizationOutputResponse.nextToken, paginationFunction: self.describeEventsForOrganization(input:))
    }
}

extension DescribeEventsForOrganizationInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeEventsForOrganizationInput {
        return DescribeEventsForOrganizationInput(
            filter: self.filter,
            locale: self.locale,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeEventsForOrganizationPaginated`
/// to access the nested member `[HealthClientTypes.OrganizationEvent]`
/// - Returns: `[HealthClientTypes.OrganizationEvent]`
extension PaginatorSequence where Input == DescribeEventsForOrganizationInput, Output == DescribeEventsForOrganizationOutputResponse {
    func events() async throws -> [HealthClientTypes.OrganizationEvent] {
        return try await self.asyncCompactMap { item in item.events }
    }
}

/// Paginate over `[DescribeEventTypesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeEventTypesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeEventTypesOutputResponse`
extension HealthClient {
    public func describeEventTypesPaginated(input: DescribeEventTypesInput) -> ClientRuntime.PaginatorSequence<DescribeEventTypesInput, DescribeEventTypesOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeEventTypesInput, DescribeEventTypesOutputResponse>(input: input, inputKey: \DescribeEventTypesInput.nextToken, outputKey: \DescribeEventTypesOutputResponse.nextToken, paginationFunction: self.describeEventTypes(input:))
    }
}

extension DescribeEventTypesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeEventTypesInput {
        return DescribeEventTypesInput(
            filter: self.filter,
            locale: self.locale,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeEventTypesPaginated`
/// to access the nested member `[HealthClientTypes.EventType]`
/// - Returns: `[HealthClientTypes.EventType]`
extension PaginatorSequence where Input == DescribeEventTypesInput, Output == DescribeEventTypesOutputResponse {
    func eventTypes() async throws -> [HealthClientTypes.EventType] {
        return try await self.asyncCompactMap { item in item.eventTypes }
    }
}
