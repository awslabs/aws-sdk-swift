// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccessDeniedException(code: \(String(describing: code)), message: \(String(describing: message)))"}
}

extension AccessDeniedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You do not have sufficient access to perform this action.</p>
public struct AccessDeniedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var code: String?
    public var message: String?

    public init (
        code: String? = nil,
        message: String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Equatable {
    public let message: String?
    public let code: String?
}

extension AccessDeniedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case code
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .code)
        code = codeDecoded
    }
}

public struct AddProfilePermissionInputBodyMiddleware: Middleware {
    public let id: String = "AddProfilePermissionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddProfilePermissionInput>,
                  next: H) -> Swift.Result<OperationOutput<AddProfilePermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddProfilePermissionInput>
    public typealias MOutput = OperationOutput<AddProfilePermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddProfilePermissionOutputError>
}

extension AddProfilePermissionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AddProfilePermissionInput(action: \(String(describing: action)), principal: \(String(describing: principal)), profileName: \(String(describing: profileName)), profileVersion: \(String(describing: profileVersion)), revisionId: \(String(describing: revisionId)), statementId: \(String(describing: statementId)))"}
}

extension AddProfilePermissionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case action
        case principal
        case profileVersion
        case revisionId
        case statementId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            try encodeContainer.encode(action, forKey: .action)
        }
        if let principal = principal {
            try encodeContainer.encode(principal, forKey: .principal)
        }
        if let profileVersion = profileVersion {
            try encodeContainer.encode(profileVersion, forKey: .profileVersion)
        }
        if let revisionId = revisionId {
            try encodeContainer.encode(revisionId, forKey: .revisionId)
        }
        if let statementId = statementId {
            try encodeContainer.encode(statementId, forKey: .statementId)
        }
    }
}

public struct AddProfilePermissionInputHeadersMiddleware: Middleware {
    public let id: String = "AddProfilePermissionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddProfilePermissionInput>,
                  next: H) -> Swift.Result<OperationOutput<AddProfilePermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddProfilePermissionInput>
    public typealias MOutput = OperationOutput<AddProfilePermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddProfilePermissionOutputError>
}

public struct AddProfilePermissionInputQueryItemMiddleware: Middleware {
    public let id: String = "AddProfilePermissionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddProfilePermissionInput>,
                  next: H) -> Swift.Result<OperationOutput<AddProfilePermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddProfilePermissionInput>
    public typealias MOutput = OperationOutput<AddProfilePermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddProfilePermissionOutputError>
}

public struct AddProfilePermissionInput: Equatable {
    /// <p>The AWS Signer action permitted as part of cross-account permissions.</p>
    public let action: String?
    /// <p>The AWS principal receiving cross-account permissions. This may be an IAM role or
    /// 			another AWS account ID.</p>
    public let principal: String?
    /// <p>The human-readable name of the signing profile.</p>
    public let profileName: String?
    /// <p>The version of the signing profile.</p>
    public let profileVersion: String?
    /// <p>A unique identifier for the current profile revision.</p>
    public let revisionId: String?
    /// <p>A unique identifier for the cross-account permission statement.</p>
    public let statementId: String?

    public init (
        action: String? = nil,
        principal: String? = nil,
        profileName: String? = nil,
        profileVersion: String? = nil,
        revisionId: String? = nil,
        statementId: String? = nil
    )
    {
        self.action = action
        self.principal = principal
        self.profileName = profileName
        self.profileVersion = profileVersion
        self.revisionId = revisionId
        self.statementId = statementId
    }
}

struct AddProfilePermissionInputBody: Equatable {
    public let profileVersion: String?
    public let action: String?
    public let principal: String?
    public let revisionId: String?
    public let statementId: String?
}

extension AddProfilePermissionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case action
        case principal
        case profileVersion
        case revisionId
        case statementId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profileVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .profileVersion)
        profileVersion = profileVersionDecoded
        let actionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .action)
        action = actionDecoded
        let principalDecoded = try containerValues.decodeIfPresent(String.self, forKey: .principal)
        principal = principalDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
        let statementIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statementId)
        statementId = statementIdDecoded
    }
}

extension AddProfilePermissionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AddProfilePermissionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceLimitExceededException" : self = .serviceLimitExceededException(try ServiceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AddProfilePermissionOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServiceErrorException(InternalServiceErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceLimitExceededException(ServiceLimitExceededException)
    case tooManyRequestsException(TooManyRequestsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddProfilePermissionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AddProfilePermissionOutputResponse(revisionId: \(String(describing: revisionId)))"}
}

extension AddProfilePermissionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AddProfilePermissionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.revisionId = output.revisionId
        } else {
            self.revisionId = nil
        }
    }
}

public struct AddProfilePermissionOutputResponse: Equatable {
    /// <p>A unique identifier for the current profile revision.</p>
    public let revisionId: String?

    public init (
        revisionId: String? = nil
    )
    {
        self.revisionId = revisionId
    }
}

struct AddProfilePermissionOutputResponseBody: Equatable {
    public let revisionId: String?
}

extension AddProfilePermissionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case revisionId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let revisionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
    }
}

extension BadRequestException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BadRequestException(code: \(String(describing: code)), message: \(String(describing: message)))"}
}

extension BadRequestException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BadRequestExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request contains invalid parameters for the ARN or tags. This exception also
/// 			occurs when you call a tagging API on a cancelled signing profile.</p>
public struct BadRequestException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var code: String?
    public var message: String?

    public init (
        code: String? = nil,
        message: String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct BadRequestExceptionBody: Equatable {
    public let message: String?
    public let code: String?
}

extension BadRequestExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case code
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .code)
        code = codeDecoded
    }
}

extension CancelSigningProfileInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CancelSigningProfileInput(profileName: \(String(describing: profileName)))"}
}

extension CancelSigningProfileInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct CancelSigningProfileInputHeadersMiddleware: Middleware {
    public let id: String = "CancelSigningProfileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CancelSigningProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<CancelSigningProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CancelSigningProfileInput>
    public typealias MOutput = OperationOutput<CancelSigningProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CancelSigningProfileOutputError>
}

public struct CancelSigningProfileInputQueryItemMiddleware: Middleware {
    public let id: String = "CancelSigningProfileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CancelSigningProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<CancelSigningProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CancelSigningProfileInput>
    public typealias MOutput = OperationOutput<CancelSigningProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CancelSigningProfileOutputError>
}

public struct CancelSigningProfileInput: Equatable {
    /// <p>The name of the signing profile to be canceled.</p>
    public let profileName: String?

    public init (
        profileName: String? = nil
    )
    {
        self.profileName = profileName
    }
}

struct CancelSigningProfileInputBody: Equatable {
}

extension CancelSigningProfileInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension CancelSigningProfileOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CancelSigningProfileOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CancelSigningProfileOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceErrorException(InternalServiceErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CancelSigningProfileOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CancelSigningProfileOutputResponse()"}
}

extension CancelSigningProfileOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct CancelSigningProfileOutputResponse: Equatable {

    public init() {}
}

struct CancelSigningProfileOutputResponseBody: Equatable {
}

extension CancelSigningProfileOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public enum Category {
    case awsiot
    case sdkUnknown(String)
}

extension Category : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Category] {
        return [
            .awsiot,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .awsiot: return "AWSIoT"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Category(rawValue: rawValue) ?? Category.sdkUnknown(rawValue)
    }
}

extension ConflictException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConflictException(code: \(String(describing: code)), message: \(String(describing: message)))"}
}

extension ConflictException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The resource encountered a conflicting state.</p>
public struct ConflictException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var code: String?
    public var message: String?

    public init (
        code: String? = nil,
        message: String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct ConflictExceptionBody: Equatable {
    public let message: String?
    public let code: String?
}

extension ConflictExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case code
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .code)
        code = codeDecoded
    }
}

extension DescribeSigningJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeSigningJobInput(jobId: \(String(describing: jobId)))"}
}

extension DescribeSigningJobInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeSigningJobInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeSigningJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeSigningJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeSigningJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeSigningJobInput>
    public typealias MOutput = OperationOutput<DescribeSigningJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeSigningJobOutputError>
}

public struct DescribeSigningJobInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeSigningJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeSigningJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeSigningJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeSigningJobInput>
    public typealias MOutput = OperationOutput<DescribeSigningJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeSigningJobOutputError>
}

public struct DescribeSigningJobInput: Equatable {
    /// <p>The ID of the signing job on input.</p>
    public let jobId: String?

    public init (
        jobId: String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct DescribeSigningJobInputBody: Equatable {
}

extension DescribeSigningJobInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeSigningJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeSigningJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeSigningJobOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceErrorException(InternalServiceErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeSigningJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeSigningJobOutputResponse(completedAt: \(String(describing: completedAt)), createdAt: \(String(describing: createdAt)), jobId: \(String(describing: jobId)), jobInvoker: \(String(describing: jobInvoker)), jobOwner: \(String(describing: jobOwner)), overrides: \(String(describing: overrides)), platformDisplayName: \(String(describing: platformDisplayName)), platformId: \(String(describing: platformId)), profileName: \(String(describing: profileName)), profileVersion: \(String(describing: profileVersion)), requestedBy: \(String(describing: requestedBy)), revocationRecord: \(String(describing: revocationRecord)), signatureExpiresAt: \(String(describing: signatureExpiresAt)), signedObject: \(String(describing: signedObject)), signingMaterial: \(String(describing: signingMaterial)), signingParameters: \(String(describing: signingParameters)), source: \(String(describing: source)), status: \(String(describing: status)), statusReason: \(String(describing: statusReason)))"}
}

extension DescribeSigningJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeSigningJobOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.completedAt = output.completedAt
            self.createdAt = output.createdAt
            self.jobId = output.jobId
            self.jobInvoker = output.jobInvoker
            self.jobOwner = output.jobOwner
            self.overrides = output.overrides
            self.platformDisplayName = output.platformDisplayName
            self.platformId = output.platformId
            self.profileName = output.profileName
            self.profileVersion = output.profileVersion
            self.requestedBy = output.requestedBy
            self.revocationRecord = output.revocationRecord
            self.signatureExpiresAt = output.signatureExpiresAt
            self.signedObject = output.signedObject
            self.signingMaterial = output.signingMaterial
            self.signingParameters = output.signingParameters
            self.source = output.source
            self.status = output.status
            self.statusReason = output.statusReason
        } else {
            self.completedAt = nil
            self.createdAt = nil
            self.jobId = nil
            self.jobInvoker = nil
            self.jobOwner = nil
            self.overrides = nil
            self.platformDisplayName = nil
            self.platformId = nil
            self.profileName = nil
            self.profileVersion = nil
            self.requestedBy = nil
            self.revocationRecord = nil
            self.signatureExpiresAt = nil
            self.signedObject = nil
            self.signingMaterial = nil
            self.signingParameters = nil
            self.source = nil
            self.status = nil
            self.statusReason = nil
        }
    }
}

public struct DescribeSigningJobOutputResponse: Equatable {
    /// <p>Date and time that the signing job was completed.</p>
    public let completedAt: Date?
    /// <p>Date and time that the signing job was created.</p>
    public let createdAt: Date?
    /// <p>The ID of the signing job on output.</p>
    public let jobId: String?
    /// <p>The IAM entity that initiated the signing job.</p>
    public let jobInvoker: String?
    /// <p>The AWS account ID of the job owner.</p>
    public let jobOwner: String?
    /// <p>A list of any overrides that were applied to the signing operation.</p>
    public let overrides: SigningPlatformOverrides?
    /// <p>A human-readable name for the signing platform associated with the signing job.</p>
    public let platformDisplayName: String?
    /// <p>The microcontroller platform to which your signed code image will be
    /// 			distributed.</p>
    public let platformId: String?
    /// <p>The name of the profile that initiated the signing operation.</p>
    public let profileName: String?
    /// <p>The version of the signing profile used to initiate the signing job.</p>
    public let profileVersion: String?
    /// <p>The IAM principal that requested the signing job.</p>
    public let requestedBy: String?
    /// <p>A revocation record if the signature generated by the signing job has been revoked.
    /// 			Contains a timestamp and the ID of the IAM entity that revoked the signature.</p>
    public let revocationRecord: SigningJobRevocationRecord?
    /// <p>Thr expiration timestamp for the signature generated by the signing job.</p>
    public let signatureExpiresAt: Date?
    /// <p>Name of the S3 bucket where the signed code image is saved by code signing.</p>
    public let signedObject: SignedObject?
    /// <p>The Amazon Resource Name (ARN) of your code signing certificate.</p>
    public let signingMaterial: SigningMaterial?
    /// <p>Map of user-assigned key-value pairs used during signing. These values contain any
    /// 			information that you specified for use in your signing job. </p>
    public let signingParameters: [String:String]?
    /// <p>The object that contains the name of your S3 bucket or your raw code.</p>
    public let source: Source?
    /// <p>Status of the signing job.</p>
    public let status: SigningStatus?
    /// <p>String value that contains the status reason.</p>
    public let statusReason: String?

    public init (
        completedAt: Date? = nil,
        createdAt: Date? = nil,
        jobId: String? = nil,
        jobInvoker: String? = nil,
        jobOwner: String? = nil,
        overrides: SigningPlatformOverrides? = nil,
        platformDisplayName: String? = nil,
        platformId: String? = nil,
        profileName: String? = nil,
        profileVersion: String? = nil,
        requestedBy: String? = nil,
        revocationRecord: SigningJobRevocationRecord? = nil,
        signatureExpiresAt: Date? = nil,
        signedObject: SignedObject? = nil,
        signingMaterial: SigningMaterial? = nil,
        signingParameters: [String:String]? = nil,
        source: Source? = nil,
        status: SigningStatus? = nil,
        statusReason: String? = nil
    )
    {
        self.completedAt = completedAt
        self.createdAt = createdAt
        self.jobId = jobId
        self.jobInvoker = jobInvoker
        self.jobOwner = jobOwner
        self.overrides = overrides
        self.platformDisplayName = platformDisplayName
        self.platformId = platformId
        self.profileName = profileName
        self.profileVersion = profileVersion
        self.requestedBy = requestedBy
        self.revocationRecord = revocationRecord
        self.signatureExpiresAt = signatureExpiresAt
        self.signedObject = signedObject
        self.signingMaterial = signingMaterial
        self.signingParameters = signingParameters
        self.source = source
        self.status = status
        self.statusReason = statusReason
    }
}

struct DescribeSigningJobOutputResponseBody: Equatable {
    public let jobId: String?
    public let source: Source?
    public let signingMaterial: SigningMaterial?
    public let platformId: String?
    public let platformDisplayName: String?
    public let profileName: String?
    public let profileVersion: String?
    public let overrides: SigningPlatformOverrides?
    public let signingParameters: [String:String]?
    public let createdAt: Date?
    public let completedAt: Date?
    public let signatureExpiresAt: Date?
    public let requestedBy: String?
    public let status: SigningStatus?
    public let statusReason: String?
    public let revocationRecord: SigningJobRevocationRecord?
    public let signedObject: SignedObject?
    public let jobOwner: String?
    public let jobInvoker: String?
}

extension DescribeSigningJobOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case completedAt
        case createdAt
        case jobId
        case jobInvoker
        case jobOwner
        case overrides
        case platformDisplayName
        case platformId
        case profileName
        case profileVersion
        case requestedBy
        case revocationRecord
        case signatureExpiresAt
        case signedObject
        case signingMaterial
        case signingParameters
        case source
        case status
        case statusReason
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let sourceDecoded = try containerValues.decodeIfPresent(Source.self, forKey: .source)
        source = sourceDecoded
        let signingMaterialDecoded = try containerValues.decodeIfPresent(SigningMaterial.self, forKey: .signingMaterial)
        signingMaterial = signingMaterialDecoded
        let platformIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .platformId)
        platformId = platformIdDecoded
        let platformDisplayNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .platformDisplayName)
        platformDisplayName = platformDisplayNameDecoded
        let profileNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .profileName)
        profileName = profileNameDecoded
        let profileVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .profileVersion)
        profileVersion = profileVersionDecoded
        let overridesDecoded = try containerValues.decodeIfPresent(SigningPlatformOverrides.self, forKey: .overrides)
        overrides = overridesDecoded
        let signingParametersContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .signingParameters)
        var signingParametersDecoded0: [String:String]? = nil
        if let signingParametersContainer = signingParametersContainer {
            signingParametersDecoded0 = [String:String]()
            for (key0, signingparametervalue0) in signingParametersContainer {
                if let signingparametervalue0 = signingparametervalue0 {
                    signingParametersDecoded0?[key0] = signingparametervalue0
                }
            }
        }
        signingParameters = signingParametersDecoded0
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let completedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .completedAt)
        completedAt = completedAtDecoded
        let signatureExpiresAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .signatureExpiresAt)
        signatureExpiresAt = signatureExpiresAtDecoded
        let requestedByDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestedBy)
        requestedBy = requestedByDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SigningStatus.self, forKey: .status)
        status = statusDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
        let revocationRecordDecoded = try containerValues.decodeIfPresent(SigningJobRevocationRecord.self, forKey: .revocationRecord)
        revocationRecord = revocationRecordDecoded
        let signedObjectDecoded = try containerValues.decodeIfPresent(SignedObject.self, forKey: .signedObject)
        signedObject = signedObjectDecoded
        let jobOwnerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobOwner)
        jobOwner = jobOwnerDecoded
        let jobInvokerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobInvoker)
        jobInvoker = jobInvokerDecoded
    }
}

extension Destination: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case s3
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3 = s3 {
            try encodeContainer.encode(s3, forKey: .s3)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3Decoded = try containerValues.decodeIfPresent(S3Destination.self, forKey: .s3)
        s3 = s3Decoded
    }
}

extension Destination: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Destination(s3: \(String(describing: s3)))"}
}

/// <p>Points to an <code>S3Destination</code> object that contains information about your S3
/// 			bucket.</p>
public struct Destination: Equatable {
    /// <p>The <code>S3Destination</code> object.</p>
    public let s3: S3Destination?

    public init (
        s3: S3Destination? = nil
    )
    {
        self.s3 = s3
    }
}

public enum EncryptionAlgorithm {
    case ecdsa
    case rsa
    case sdkUnknown(String)
}

extension EncryptionAlgorithm : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [EncryptionAlgorithm] {
        return [
            .ecdsa,
            .rsa,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .ecdsa: return "ECDSA"
        case .rsa: return "RSA"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = EncryptionAlgorithm(rawValue: rawValue) ?? EncryptionAlgorithm.sdkUnknown(rawValue)
    }
}

extension EncryptionAlgorithmOptions: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case allowedValues
        case defaultValue
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowedValues = allowedValues {
            var allowedValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .allowedValues)
            for encryptionalgorithms0 in allowedValues {
                try allowedValuesContainer.encode(encryptionalgorithms0.rawValue)
            }
        }
        if let defaultValue = defaultValue {
            try encodeContainer.encode(defaultValue.rawValue, forKey: .defaultValue)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let allowedValuesContainer = try containerValues.decodeIfPresent([EncryptionAlgorithm?].self, forKey: .allowedValues)
        var allowedValuesDecoded0:[EncryptionAlgorithm]? = nil
        if let allowedValuesContainer = allowedValuesContainer {
            allowedValuesDecoded0 = [EncryptionAlgorithm]()
            for string0 in allowedValuesContainer {
                if let string0 = string0 {
                    allowedValuesDecoded0?.append(string0)
                }
            }
        }
        allowedValues = allowedValuesDecoded0
        let defaultValueDecoded = try containerValues.decodeIfPresent(EncryptionAlgorithm.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
    }
}

extension EncryptionAlgorithmOptions: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EncryptionAlgorithmOptions(allowedValues: \(String(describing: allowedValues)), defaultValue: \(String(describing: defaultValue)))"}
}

/// <p>The encryption algorithm options that are available to a code signing job.</p>
public struct EncryptionAlgorithmOptions: Equatable {
    /// <p>The set of accepted encryption algorithms that are allowed in a code signing job.</p>
    public let allowedValues: [EncryptionAlgorithm]?
    /// <p>The default encryption algorithm that is used by a code signing job.</p>
    public let defaultValue: EncryptionAlgorithm?

    public init (
        allowedValues: [EncryptionAlgorithm]? = nil,
        defaultValue: EncryptionAlgorithm? = nil
    )
    {
        self.allowedValues = allowedValues
        self.defaultValue = defaultValue
    }
}

extension GetSigningPlatformInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSigningPlatformInput(platformId: \(String(describing: platformId)))"}
}

extension GetSigningPlatformInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetSigningPlatformInputHeadersMiddleware: Middleware {
    public let id: String = "GetSigningPlatformInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSigningPlatformInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSigningPlatformOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSigningPlatformInput>
    public typealias MOutput = OperationOutput<GetSigningPlatformOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSigningPlatformOutputError>
}

public struct GetSigningPlatformInputQueryItemMiddleware: Middleware {
    public let id: String = "GetSigningPlatformInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSigningPlatformInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSigningPlatformOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSigningPlatformInput>
    public typealias MOutput = OperationOutput<GetSigningPlatformOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSigningPlatformOutputError>
}

public struct GetSigningPlatformInput: Equatable {
    /// <p>The ID of the target signing platform.</p>
    public let platformId: String?

    public init (
        platformId: String? = nil
    )
    {
        self.platformId = platformId
    }
}

struct GetSigningPlatformInputBody: Equatable {
}

extension GetSigningPlatformInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetSigningPlatformOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSigningPlatformOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetSigningPlatformOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceErrorException(InternalServiceErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSigningPlatformOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSigningPlatformOutputResponse(category: \(String(describing: category)), displayName: \(String(describing: displayName)), maxSizeInMB: \(String(describing: maxSizeInMB)), partner: \(String(describing: partner)), platformId: \(String(describing: platformId)), revocationSupported: \(String(describing: revocationSupported)), signingConfiguration: \(String(describing: signingConfiguration)), signingImageFormat: \(String(describing: signingImageFormat)), target: \(String(describing: target)))"}
}

extension GetSigningPlatformOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetSigningPlatformOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.category = output.category
            self.displayName = output.displayName
            self.maxSizeInMB = output.maxSizeInMB
            self.partner = output.partner
            self.platformId = output.platformId
            self.revocationSupported = output.revocationSupported
            self.signingConfiguration = output.signingConfiguration
            self.signingImageFormat = output.signingImageFormat
            self.target = output.target
        } else {
            self.category = nil
            self.displayName = nil
            self.maxSizeInMB = 0
            self.partner = nil
            self.platformId = nil
            self.revocationSupported = false
            self.signingConfiguration = nil
            self.signingImageFormat = nil
            self.target = nil
        }
    }
}

public struct GetSigningPlatformOutputResponse: Equatable {
    /// <p>The category type of the target signing platform.</p>
    public let category: Category?
    /// <p>The display name of the target signing platform.</p>
    public let displayName: String?
    /// <p>The maximum size (in MB) of the payload that can be signed by the target
    /// 			platform.</p>
    public let maxSizeInMB: Int
    /// <p>A list of partner entities that use the target signing platform.</p>
    public let partner: String?
    /// <p>The ID of the target signing platform.</p>
    public let platformId: String?
    /// <p>A flag indicating whether signatures generated for the signing platform can be
    /// 			revoked.</p>
    public let revocationSupported: Bool
    /// <p>A list of configurations applied to the target platform at signing.</p>
    public let signingConfiguration: SigningConfiguration?
    /// <p>The format of the target platform's signing image.</p>
    public let signingImageFormat: SigningImageFormat?
    /// <p>The validation template that is used by the target signing platform.</p>
    public let target: String?

    public init (
        category: Category? = nil,
        displayName: String? = nil,
        maxSizeInMB: Int = 0,
        partner: String? = nil,
        platformId: String? = nil,
        revocationSupported: Bool = false,
        signingConfiguration: SigningConfiguration? = nil,
        signingImageFormat: SigningImageFormat? = nil,
        target: String? = nil
    )
    {
        self.category = category
        self.displayName = displayName
        self.maxSizeInMB = maxSizeInMB
        self.partner = partner
        self.platformId = platformId
        self.revocationSupported = revocationSupported
        self.signingConfiguration = signingConfiguration
        self.signingImageFormat = signingImageFormat
        self.target = target
    }
}

struct GetSigningPlatformOutputResponseBody: Equatable {
    public let platformId: String?
    public let displayName: String?
    public let partner: String?
    public let target: String?
    public let category: Category?
    public let signingConfiguration: SigningConfiguration?
    public let signingImageFormat: SigningImageFormat?
    public let maxSizeInMB: Int
    public let revocationSupported: Bool
}

extension GetSigningPlatformOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case category
        case displayName
        case maxSizeInMB
        case partner
        case platformId
        case revocationSupported
        case signingConfiguration
        case signingImageFormat
        case target
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let platformIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .platformId)
        platformId = platformIdDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let partnerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .partner)
        partner = partnerDecoded
        let targetDecoded = try containerValues.decodeIfPresent(String.self, forKey: .target)
        target = targetDecoded
        let categoryDecoded = try containerValues.decodeIfPresent(Category.self, forKey: .category)
        category = categoryDecoded
        let signingConfigurationDecoded = try containerValues.decodeIfPresent(SigningConfiguration.self, forKey: .signingConfiguration)
        signingConfiguration = signingConfigurationDecoded
        let signingImageFormatDecoded = try containerValues.decodeIfPresent(SigningImageFormat.self, forKey: .signingImageFormat)
        signingImageFormat = signingImageFormatDecoded
        let maxSizeInMBDecoded = try containerValues.decode(Int.self, forKey: .maxSizeInMB)
        maxSizeInMB = maxSizeInMBDecoded
        let revocationSupportedDecoded = try containerValues.decode(Bool.self, forKey: .revocationSupported)
        revocationSupported = revocationSupportedDecoded
    }
}

extension GetSigningProfileInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSigningProfileInput(profileName: \(String(describing: profileName)), profileOwner: \(String(describing: profileOwner)))"}
}

extension GetSigningProfileInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetSigningProfileInputHeadersMiddleware: Middleware {
    public let id: String = "GetSigningProfileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSigningProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSigningProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSigningProfileInput>
    public typealias MOutput = OperationOutput<GetSigningProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSigningProfileOutputError>
}

public struct GetSigningProfileInputQueryItemMiddleware: Middleware {
    public let id: String = "GetSigningProfileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSigningProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSigningProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let profileOwner = input.operationInput.profileOwner {
            let profileOwnerQueryItem = URLQueryItem(name: "profileOwner".urlPercentEncoding(), value: String(profileOwner).urlPercentEncoding())
            input.builder.withQueryItem(profileOwnerQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSigningProfileInput>
    public typealias MOutput = OperationOutput<GetSigningProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSigningProfileOutputError>
}

public struct GetSigningProfileInput: Equatable {
    /// <p>The name of the target signing profile.</p>
    public let profileName: String?
    /// <p>The AWS account ID of the profile owner.</p>
    public let profileOwner: String?

    public init (
        profileName: String? = nil,
        profileOwner: String? = nil
    )
    {
        self.profileName = profileName
        self.profileOwner = profileOwner
    }
}

struct GetSigningProfileInputBody: Equatable {
}

extension GetSigningProfileInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetSigningProfileOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSigningProfileOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetSigningProfileOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceErrorException(InternalServiceErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSigningProfileOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSigningProfileOutputResponse(arn: \(String(describing: arn)), overrides: \(String(describing: overrides)), platformDisplayName: \(String(describing: platformDisplayName)), platformId: \(String(describing: platformId)), profileName: \(String(describing: profileName)), profileVersion: \(String(describing: profileVersion)), profileVersionArn: \(String(describing: profileVersionArn)), revocationRecord: \(String(describing: revocationRecord)), signatureValidityPeriod: \(String(describing: signatureValidityPeriod)), signingMaterial: \(String(describing: signingMaterial)), signingParameters: \(String(describing: signingParameters)), status: \(String(describing: status)), statusReason: \(String(describing: statusReason)), tags: \(String(describing: tags)))"}
}

extension GetSigningProfileOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetSigningProfileOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.overrides = output.overrides
            self.platformDisplayName = output.platformDisplayName
            self.platformId = output.platformId
            self.profileName = output.profileName
            self.profileVersion = output.profileVersion
            self.profileVersionArn = output.profileVersionArn
            self.revocationRecord = output.revocationRecord
            self.signatureValidityPeriod = output.signatureValidityPeriod
            self.signingMaterial = output.signingMaterial
            self.signingParameters = output.signingParameters
            self.status = output.status
            self.statusReason = output.statusReason
            self.tags = output.tags
        } else {
            self.arn = nil
            self.overrides = nil
            self.platformDisplayName = nil
            self.platformId = nil
            self.profileName = nil
            self.profileVersion = nil
            self.profileVersionArn = nil
            self.revocationRecord = nil
            self.signatureValidityPeriod = nil
            self.signingMaterial = nil
            self.signingParameters = nil
            self.status = nil
            self.statusReason = nil
            self.tags = nil
        }
    }
}

public struct GetSigningProfileOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) for the signing profile.</p>
    public let arn: String?
    /// <p>A list of overrides applied by the target signing profile for signing
    /// 			operations.</p>
    public let overrides: SigningPlatformOverrides?
    /// <p>A human-readable name for the signing platform associated with the signing
    /// 			profile.</p>
    public let platformDisplayName: String?
    /// <p>The ID of the platform that is used by the target signing profile.</p>
    public let platformId: String?
    /// <p>The name of the target signing profile.</p>
    public let profileName: String?
    /// <p>The current version of the signing profile.</p>
    public let profileVersion: String?
    /// <p>The signing profile ARN, including the profile version.</p>
    public let profileVersionArn: String?
    /// <p>Revocation information for a signing profile.</p>
    public let revocationRecord: SigningProfileRevocationRecord?
    /// <p>The validity period for a signing job.</p>
    public let signatureValidityPeriod: SignatureValidityPeriod?
    /// <p>The ARN of the certificate that the target profile uses for signing operations.</p>
    public let signingMaterial: SigningMaterial?
    /// <p>A map of key-value pairs for signing operations that is attached to the target signing
    /// 			profile.</p>
    public let signingParameters: [String:String]?
    /// <p>The status of the target signing profile.</p>
    public let status: SigningProfileStatus?
    /// <p>Reason for the status of the target signing profile.</p>
    public let statusReason: String?
    /// <p>A list of tags associated with the signing profile.</p>
    public let tags: [String:String]?

    public init (
        arn: String? = nil,
        overrides: SigningPlatformOverrides? = nil,
        platformDisplayName: String? = nil,
        platformId: String? = nil,
        profileName: String? = nil,
        profileVersion: String? = nil,
        profileVersionArn: String? = nil,
        revocationRecord: SigningProfileRevocationRecord? = nil,
        signatureValidityPeriod: SignatureValidityPeriod? = nil,
        signingMaterial: SigningMaterial? = nil,
        signingParameters: [String:String]? = nil,
        status: SigningProfileStatus? = nil,
        statusReason: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.arn = arn
        self.overrides = overrides
        self.platformDisplayName = platformDisplayName
        self.platformId = platformId
        self.profileName = profileName
        self.profileVersion = profileVersion
        self.profileVersionArn = profileVersionArn
        self.revocationRecord = revocationRecord
        self.signatureValidityPeriod = signatureValidityPeriod
        self.signingMaterial = signingMaterial
        self.signingParameters = signingParameters
        self.status = status
        self.statusReason = statusReason
        self.tags = tags
    }
}

struct GetSigningProfileOutputResponseBody: Equatable {
    public let profileName: String?
    public let profileVersion: String?
    public let profileVersionArn: String?
    public let revocationRecord: SigningProfileRevocationRecord?
    public let signingMaterial: SigningMaterial?
    public let platformId: String?
    public let platformDisplayName: String?
    public let signatureValidityPeriod: SignatureValidityPeriod?
    public let overrides: SigningPlatformOverrides?
    public let signingParameters: [String:String]?
    public let status: SigningProfileStatus?
    public let statusReason: String?
    public let arn: String?
    public let tags: [String:String]?
}

extension GetSigningProfileOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn
        case overrides
        case platformDisplayName
        case platformId
        case profileName
        case profileVersion
        case profileVersionArn
        case revocationRecord
        case signatureValidityPeriod
        case signingMaterial
        case signingParameters
        case status
        case statusReason
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profileNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .profileName)
        profileName = profileNameDecoded
        let profileVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .profileVersion)
        profileVersion = profileVersionDecoded
        let profileVersionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .profileVersionArn)
        profileVersionArn = profileVersionArnDecoded
        let revocationRecordDecoded = try containerValues.decodeIfPresent(SigningProfileRevocationRecord.self, forKey: .revocationRecord)
        revocationRecord = revocationRecordDecoded
        let signingMaterialDecoded = try containerValues.decodeIfPresent(SigningMaterial.self, forKey: .signingMaterial)
        signingMaterial = signingMaterialDecoded
        let platformIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .platformId)
        platformId = platformIdDecoded
        let platformDisplayNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .platformDisplayName)
        platformDisplayName = platformDisplayNameDecoded
        let signatureValidityPeriodDecoded = try containerValues.decodeIfPresent(SignatureValidityPeriod.self, forKey: .signatureValidityPeriod)
        signatureValidityPeriod = signatureValidityPeriodDecoded
        let overridesDecoded = try containerValues.decodeIfPresent(SigningPlatformOverrides.self, forKey: .overrides)
        overrides = overridesDecoded
        let signingParametersContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .signingParameters)
        var signingParametersDecoded0: [String:String]? = nil
        if let signingParametersContainer = signingParametersContainer {
            signingParametersDecoded0 = [String:String]()
            for (key0, signingparametervalue0) in signingParametersContainer {
                if let signingparametervalue0 = signingparametervalue0 {
                    signingParametersDecoded0?[key0] = signingparametervalue0
                }
            }
        }
        signingParameters = signingParametersDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(SigningProfileStatus.self, forKey: .status)
        status = statusDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

public enum HashAlgorithm {
    case sha1
    case sha256
    case sdkUnknown(String)
}

extension HashAlgorithm : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [HashAlgorithm] {
        return [
            .sha1,
            .sha256,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .sha1: return "SHA1"
        case .sha256: return "SHA256"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = HashAlgorithm(rawValue: rawValue) ?? HashAlgorithm.sdkUnknown(rawValue)
    }
}

extension HashAlgorithmOptions: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case allowedValues
        case defaultValue
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowedValues = allowedValues {
            var allowedValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .allowedValues)
            for hashalgorithms0 in allowedValues {
                try allowedValuesContainer.encode(hashalgorithms0.rawValue)
            }
        }
        if let defaultValue = defaultValue {
            try encodeContainer.encode(defaultValue.rawValue, forKey: .defaultValue)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let allowedValuesContainer = try containerValues.decodeIfPresent([HashAlgorithm?].self, forKey: .allowedValues)
        var allowedValuesDecoded0:[HashAlgorithm]? = nil
        if let allowedValuesContainer = allowedValuesContainer {
            allowedValuesDecoded0 = [HashAlgorithm]()
            for string0 in allowedValuesContainer {
                if let string0 = string0 {
                    allowedValuesDecoded0?.append(string0)
                }
            }
        }
        allowedValues = allowedValuesDecoded0
        let defaultValueDecoded = try containerValues.decodeIfPresent(HashAlgorithm.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
    }
}

extension HashAlgorithmOptions: CustomDebugStringConvertible {
    public var debugDescription: String {
        "HashAlgorithmOptions(allowedValues: \(String(describing: allowedValues)), defaultValue: \(String(describing: defaultValue)))"}
}

/// <p>The hash algorithms that are available to a code signing job.</p>
public struct HashAlgorithmOptions: Equatable {
    /// <p>The set of accepted hash algorithms allowed in a code signing job.</p>
    public let allowedValues: [HashAlgorithm]?
    /// <p>The default hash algorithm that is used in a code signing job.</p>
    public let defaultValue: HashAlgorithm?

    public init (
        allowedValues: [HashAlgorithm]? = nil,
        defaultValue: HashAlgorithm? = nil
    )
    {
        self.allowedValues = allowedValues
        self.defaultValue = defaultValue
    }
}

public enum ImageFormat {
    case json
    case jsondetached
    case jsonembedded
    case sdkUnknown(String)
}

extension ImageFormat : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ImageFormat] {
        return [
            .json,
            .jsondetached,
            .jsonembedded,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .json: return "JSON"
        case .jsondetached: return "JSONDetached"
        case .jsonembedded: return "JSONEmbedded"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ImageFormat(rawValue: rawValue) ?? ImageFormat.sdkUnknown(rawValue)
    }
}

extension InternalServiceErrorException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalServiceErrorException(code: \(String(describing: code)), message: \(String(describing: message)))"}
}

extension InternalServiceErrorException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InternalServiceErrorExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An internal error occurred.</p>
public struct InternalServiceErrorException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var code: String?
    public var message: String?

    public init (
        code: String? = nil,
        message: String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct InternalServiceErrorExceptionBody: Equatable {
    public let message: String?
    public let code: String?
}

extension InternalServiceErrorExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case code
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .code)
        code = codeDecoded
    }
}

extension ListProfilePermissionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListProfilePermissionsInput(nextToken: \(String(describing: nextToken)), profileName: \(String(describing: profileName)))"}
}

extension ListProfilePermissionsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListProfilePermissionsInputHeadersMiddleware: Middleware {
    public let id: String = "ListProfilePermissionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListProfilePermissionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListProfilePermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListProfilePermissionsInput>
    public typealias MOutput = OperationOutput<ListProfilePermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListProfilePermissionsOutputError>
}

public struct ListProfilePermissionsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListProfilePermissionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListProfilePermissionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListProfilePermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListProfilePermissionsInput>
    public typealias MOutput = OperationOutput<ListProfilePermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListProfilePermissionsOutputError>
}

public struct ListProfilePermissionsInput: Equatable {
    /// <p>String for specifying the next set of paginated results.</p>
    public let nextToken: String?
    /// <p>Name of the signing profile containing the cross-account permissions.</p>
    public let profileName: String?

    public init (
        nextToken: String? = nil,
        profileName: String? = nil
    )
    {
        self.nextToken = nextToken
        self.profileName = profileName
    }
}

struct ListProfilePermissionsInputBody: Equatable {
}

extension ListProfilePermissionsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListProfilePermissionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListProfilePermissionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListProfilePermissionsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceErrorException(InternalServiceErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListProfilePermissionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListProfilePermissionsOutputResponse(nextToken: \(String(describing: nextToken)), permissions: \(String(describing: permissions)), policySizeBytes: \(String(describing: policySizeBytes)), revisionId: \(String(describing: revisionId)))"}
}

extension ListProfilePermissionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListProfilePermissionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.permissions = output.permissions
            self.policySizeBytes = output.policySizeBytes
            self.revisionId = output.revisionId
        } else {
            self.nextToken = nil
            self.permissions = nil
            self.policySizeBytes = 0
            self.revisionId = nil
        }
    }
}

public struct ListProfilePermissionsOutputResponse: Equatable {
    /// <p>String for specifying the next set of paginated results.</p>
    public let nextToken: String?
    /// <p>List of permissions associated with the Signing Profile.</p>
    public let permissions: [Permission]?
    /// <p>Total size of the policy associated with the Signing Profile in bytes.</p>
    public let policySizeBytes: Int
    /// <p>The identifier for the current revision of profile permissions.</p>
    public let revisionId: String?

    public init (
        nextToken: String? = nil,
        permissions: [Permission]? = nil,
        policySizeBytes: Int = 0,
        revisionId: String? = nil
    )
    {
        self.nextToken = nextToken
        self.permissions = permissions
        self.policySizeBytes = policySizeBytes
        self.revisionId = revisionId
    }
}

struct ListProfilePermissionsOutputResponseBody: Equatable {
    public let revisionId: String?
    public let policySizeBytes: Int
    public let permissions: [Permission]?
    public let nextToken: String?
}

extension ListProfilePermissionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case permissions
        case policySizeBytes
        case revisionId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let revisionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
        let policySizeBytesDecoded = try containerValues.decode(Int.self, forKey: .policySizeBytes)
        policySizeBytes = policySizeBytesDecoded
        let permissionsContainer = try containerValues.decodeIfPresent([Permission?].self, forKey: .permissions)
        var permissionsDecoded0:[Permission]? = nil
        if let permissionsContainer = permissionsContainer {
            permissionsDecoded0 = [Permission]()
            for structure0 in permissionsContainer {
                if let structure0 = structure0 {
                    permissionsDecoded0?.append(structure0)
                }
            }
        }
        permissions = permissionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListSigningJobsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListSigningJobsInput(isRevoked: \(String(describing: isRevoked)), jobInvoker: \(String(describing: jobInvoker)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), platformId: \(String(describing: platformId)), requestedBy: \(String(describing: requestedBy)), signatureExpiresAfter: \(String(describing: signatureExpiresAfter)), signatureExpiresBefore: \(String(describing: signatureExpiresBefore)), status: \(String(describing: status)))"}
}

extension ListSigningJobsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListSigningJobsInputHeadersMiddleware: Middleware {
    public let id: String = "ListSigningJobsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSigningJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSigningJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSigningJobsInput>
    public typealias MOutput = OperationOutput<ListSigningJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSigningJobsOutputError>
}

public struct ListSigningJobsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListSigningJobsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSigningJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSigningJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let isRevokedQueryItem = URLQueryItem(name: "isRevoked".urlPercentEncoding(), value: String(input.operationInput.isRevoked).urlPercentEncoding())
        input.builder.withQueryItem(isRevokedQueryItem)
        if let requestedBy = input.operationInput.requestedBy {
            let requestedByQueryItem = URLQueryItem(name: "requestedBy".urlPercentEncoding(), value: String(requestedBy).urlPercentEncoding())
            input.builder.withQueryItem(requestedByQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let signatureExpiresBefore = input.operationInput.signatureExpiresBefore {
            let signatureExpiresBeforeQueryItem = URLQueryItem(name: "signatureExpiresBefore".urlPercentEncoding(), value: String(signatureExpiresBefore.iso8601WithoutFractionalSeconds()).urlPercentEncoding())
            input.builder.withQueryItem(signatureExpiresBeforeQueryItem)
        }
        if let jobInvoker = input.operationInput.jobInvoker {
            let jobInvokerQueryItem = URLQueryItem(name: "jobInvoker".urlPercentEncoding(), value: String(jobInvoker).urlPercentEncoding())
            input.builder.withQueryItem(jobInvokerQueryItem)
        }
        if let platformId = input.operationInput.platformId {
            let platformIdQueryItem = URLQueryItem(name: "platformId".urlPercentEncoding(), value: String(platformId).urlPercentEncoding())
            input.builder.withQueryItem(platformIdQueryItem)
        }
        if let signatureExpiresAfter = input.operationInput.signatureExpiresAfter {
            let signatureExpiresAfterQueryItem = URLQueryItem(name: "signatureExpiresAfter".urlPercentEncoding(), value: String(signatureExpiresAfter.iso8601WithoutFractionalSeconds()).urlPercentEncoding())
            input.builder.withQueryItem(signatureExpiresAfterQueryItem)
        }
        if let status = input.operationInput.status {
            let statusQueryItem = URLQueryItem(name: "status".urlPercentEncoding(), value: String(status.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(statusQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSigningJobsInput>
    public typealias MOutput = OperationOutput<ListSigningJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSigningJobsOutputError>
}

public struct ListSigningJobsInput: Equatable {
    /// <p>Filters results to return only signing jobs with revoked signatures.</p>
    public let isRevoked: Bool
    /// <p>Filters results to return only signing jobs initiated by a specified IAM
    /// 			entity.</p>
    public let jobInvoker: String?
    /// <p>Specifies the maximum number of items to return in the response. Use this parameter
    /// 			when paginating results. If additional items exist beyond the number you specify, the
    /// 				<code>nextToken</code> element is set in the response. Use the
    /// 				<code>nextToken</code> value in a subsequent request to retrieve additional items.
    /// 		</p>
    public let maxResults: Int?
    /// <p>String for specifying the next set of paginated results to return. After you receive a
    /// 			response with truncated results, use this parameter in a subsequent request. Set it to
    /// 			the value of <code>nextToken</code> from the response that you just received.</p>
    public let nextToken: String?
    /// <p>The ID of microcontroller platform that you specified for the distribution of your
    /// 			code image.</p>
    public let platformId: String?
    /// <p>The IAM principal that requested the signing job.</p>
    public let requestedBy: String?
    /// <p>Filters results to return only signing jobs with signatures expiring after a specified
    /// 			timestamp.</p>
    public let signatureExpiresAfter: Date?
    /// <p>Filters results to return only signing jobs with signatures expiring before a
    /// 			specified timestamp.</p>
    public let signatureExpiresBefore: Date?
    /// <p>A status value with which to filter your results.</p>
    public let status: SigningStatus?

    public init (
        isRevoked: Bool = false,
        jobInvoker: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        platformId: String? = nil,
        requestedBy: String? = nil,
        signatureExpiresAfter: Date? = nil,
        signatureExpiresBefore: Date? = nil,
        status: SigningStatus? = nil
    )
    {
        self.isRevoked = isRevoked
        self.jobInvoker = jobInvoker
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.platformId = platformId
        self.requestedBy = requestedBy
        self.signatureExpiresAfter = signatureExpiresAfter
        self.signatureExpiresBefore = signatureExpiresBefore
        self.status = status
    }
}

struct ListSigningJobsInputBody: Equatable {
}

extension ListSigningJobsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListSigningJobsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSigningJobsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListSigningJobsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceErrorException(InternalServiceErrorException)
    case tooManyRequestsException(TooManyRequestsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSigningJobsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListSigningJobsOutputResponse(jobs: \(String(describing: jobs)), nextToken: \(String(describing: nextToken)))"}
}

extension ListSigningJobsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListSigningJobsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.jobs = output.jobs
            self.nextToken = output.nextToken
        } else {
            self.jobs = nil
            self.nextToken = nil
        }
    }
}

public struct ListSigningJobsOutputResponse: Equatable {
    /// <p>A list of your signing jobs.</p>
    public let jobs: [SigningJob]?
    /// <p>String for specifying the next set of paginated results.</p>
    public let nextToken: String?

    public init (
        jobs: [SigningJob]? = nil,
        nextToken: String? = nil
    )
    {
        self.jobs = jobs
        self.nextToken = nextToken
    }
}

struct ListSigningJobsOutputResponseBody: Equatable {
    public let jobs: [SigningJob]?
    public let nextToken: String?
}

extension ListSigningJobsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobs
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobsContainer = try containerValues.decodeIfPresent([SigningJob?].self, forKey: .jobs)
        var jobsDecoded0:[SigningJob]? = nil
        if let jobsContainer = jobsContainer {
            jobsDecoded0 = [SigningJob]()
            for structure0 in jobsContainer {
                if let structure0 = structure0 {
                    jobsDecoded0?.append(structure0)
                }
            }
        }
        jobs = jobsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListSigningPlatformsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListSigningPlatformsInput(category: \(String(describing: category)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), partner: \(String(describing: partner)), target: \(String(describing: target)))"}
}

extension ListSigningPlatformsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListSigningPlatformsInputHeadersMiddleware: Middleware {
    public let id: String = "ListSigningPlatformsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSigningPlatformsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSigningPlatformsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSigningPlatformsInput>
    public typealias MOutput = OperationOutput<ListSigningPlatformsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSigningPlatformsOutputError>
}

public struct ListSigningPlatformsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListSigningPlatformsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSigningPlatformsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSigningPlatformsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let partner = input.operationInput.partner {
            let partnerQueryItem = URLQueryItem(name: "partner".urlPercentEncoding(), value: String(partner).urlPercentEncoding())
            input.builder.withQueryItem(partnerQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let category = input.operationInput.category {
            let categoryQueryItem = URLQueryItem(name: "category".urlPercentEncoding(), value: String(category).urlPercentEncoding())
            input.builder.withQueryItem(categoryQueryItem)
        }
        if let target = input.operationInput.target {
            let targetQueryItem = URLQueryItem(name: "target".urlPercentEncoding(), value: String(target).urlPercentEncoding())
            input.builder.withQueryItem(targetQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSigningPlatformsInput>
    public typealias MOutput = OperationOutput<ListSigningPlatformsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSigningPlatformsOutputError>
}

public struct ListSigningPlatformsInput: Equatable {
    /// <p>The category type of a signing platform.</p>
    public let category: String?
    /// <p>The maximum number of results to be returned by this operation.</p>
    public let maxResults: Int?
    /// <p>Value for specifying the next set of paginated results to return. After you receive a
    /// 			response with truncated results, use this parameter in a subsequent request. Set it to
    /// 			the value of <code>nextToken</code> from the response that you just received.</p>
    public let nextToken: String?
    /// <p>Any partner entities connected to a signing platform.</p>
    public let partner: String?
    /// <p>The validation template that is used by the target signing platform.</p>
    public let target: String?

    public init (
        category: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        partner: String? = nil,
        target: String? = nil
    )
    {
        self.category = category
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.partner = partner
        self.target = target
    }
}

struct ListSigningPlatformsInputBody: Equatable {
}

extension ListSigningPlatformsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListSigningPlatformsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSigningPlatformsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListSigningPlatformsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceErrorException(InternalServiceErrorException)
    case tooManyRequestsException(TooManyRequestsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSigningPlatformsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListSigningPlatformsOutputResponse(nextToken: \(String(describing: nextToken)), platforms: \(String(describing: platforms)))"}
}

extension ListSigningPlatformsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListSigningPlatformsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.platforms = output.platforms
        } else {
            self.nextToken = nil
            self.platforms = nil
        }
    }
}

public struct ListSigningPlatformsOutputResponse: Equatable {
    /// <p>Value for specifying the next set of paginated results to return.</p>
    public let nextToken: String?
    /// <p>A list of all platforms that match the request parameters.</p>
    public let platforms: [SigningPlatform]?

    public init (
        nextToken: String? = nil,
        platforms: [SigningPlatform]? = nil
    )
    {
        self.nextToken = nextToken
        self.platforms = platforms
    }
}

struct ListSigningPlatformsOutputResponseBody: Equatable {
    public let platforms: [SigningPlatform]?
    public let nextToken: String?
}

extension ListSigningPlatformsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case platforms
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let platformsContainer = try containerValues.decodeIfPresent([SigningPlatform?].self, forKey: .platforms)
        var platformsDecoded0:[SigningPlatform]? = nil
        if let platformsContainer = platformsContainer {
            platformsDecoded0 = [SigningPlatform]()
            for structure0 in platformsContainer {
                if let structure0 = structure0 {
                    platformsDecoded0?.append(structure0)
                }
            }
        }
        platforms = platformsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListSigningProfilesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListSigningProfilesInput(includeCanceled: \(String(describing: includeCanceled)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), platformId: \(String(describing: platformId)), statuses: \(String(describing: statuses)))"}
}

extension ListSigningProfilesInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListSigningProfilesInputHeadersMiddleware: Middleware {
    public let id: String = "ListSigningProfilesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSigningProfilesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSigningProfilesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSigningProfilesInput>
    public typealias MOutput = OperationOutput<ListSigningProfilesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSigningProfilesOutputError>
}

public struct ListSigningProfilesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListSigningProfilesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSigningProfilesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSigningProfilesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let includeCanceledQueryItem = URLQueryItem(name: "includeCanceled".urlPercentEncoding(), value: String(input.operationInput.includeCanceled).urlPercentEncoding())
        input.builder.withQueryItem(includeCanceledQueryItem)
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let statuses = input.operationInput.statuses {
            statuses.forEach { queryItemValue in
                let queryItem = URLQueryItem(name: "statuses".urlPercentEncoding(), value: String(queryItemValue.rawValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        if let platformId = input.operationInput.platformId {
            let platformIdQueryItem = URLQueryItem(name: "platformId".urlPercentEncoding(), value: String(platformId).urlPercentEncoding())
            input.builder.withQueryItem(platformIdQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSigningProfilesInput>
    public typealias MOutput = OperationOutput<ListSigningProfilesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSigningProfilesOutputError>
}

public struct ListSigningProfilesInput: Equatable {
    /// <p>Designates whether to include profiles with the status of
    /// 			<code>CANCELED</code>.</p>
    public let includeCanceled: Bool
    /// <p>The maximum number of profiles to be returned.</p>
    public let maxResults: Int?
    /// <p>Value for specifying the next set of paginated results to return. After you receive a
    /// 			response with truncated results, use this parameter in a subsequent request. Set it to
    /// 			the value of <code>nextToken</code> from the response that you just received.</p>
    public let nextToken: String?
    /// <p>Filters results to return only signing jobs initiated for a specified signing
    /// 			platform.</p>
    public let platformId: String?
    /// <p>Filters results to return only signing jobs with statuses in the specified
    /// 			list.</p>
    public let statuses: [SigningProfileStatus]?

    public init (
        includeCanceled: Bool = false,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        platformId: String? = nil,
        statuses: [SigningProfileStatus]? = nil
    )
    {
        self.includeCanceled = includeCanceled
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.platformId = platformId
        self.statuses = statuses
    }
}

struct ListSigningProfilesInputBody: Equatable {
}

extension ListSigningProfilesInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListSigningProfilesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSigningProfilesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListSigningProfilesOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceErrorException(InternalServiceErrorException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSigningProfilesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListSigningProfilesOutputResponse(nextToken: \(String(describing: nextToken)), profiles: \(String(describing: profiles)))"}
}

extension ListSigningProfilesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListSigningProfilesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.profiles = output.profiles
        } else {
            self.nextToken = nil
            self.profiles = nil
        }
    }
}

public struct ListSigningProfilesOutputResponse: Equatable {
    /// <p>Value for specifying the next set of paginated results to return.</p>
    public let nextToken: String?
    /// <p>A list of profiles that are available in the AWS account. This includes profiles with
    /// 			the status of <code>CANCELED</code> if the <code>includeCanceled</code> parameter is set
    /// 			to <code>true</code>.</p>
    public let profiles: [SigningProfile]?

    public init (
        nextToken: String? = nil,
        profiles: [SigningProfile]? = nil
    )
    {
        self.nextToken = nextToken
        self.profiles = profiles
    }
}

struct ListSigningProfilesOutputResponseBody: Equatable {
    public let profiles: [SigningProfile]?
    public let nextToken: String?
}

extension ListSigningProfilesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case profiles
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profilesContainer = try containerValues.decodeIfPresent([SigningProfile?].self, forKey: .profiles)
        var profilesDecoded0:[SigningProfile]? = nil
        if let profilesContainer = profilesContainer {
            profilesDecoded0 = [SigningProfile]()
            for structure0 in profilesContainer {
                if let structure0 = structure0 {
                    profilesDecoded0?.append(structure0)
                }
            }
        }
        profiles = profilesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceInput(resourceArn: \(String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) for the signing profile.</p>
    public let resourceArn: String?

    public init (
        resourceArn: String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Equatable {
}

extension ListTagsForResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Equatable {
    case badRequestException(BadRequestException)
    case internalServiceErrorException(InternalServiceErrorException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceOutputResponse(tags: \(String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Equatable {
    /// <p>A list of tags associated with the signing profile.</p>
    public let tags: [String:String]?

    public init (
        tags: [String:String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Equatable {
    public let tags: [String:String]?
}

extension ListTagsForResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension NotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NotFoundException(code: \(String(describing: code)), message: \(String(describing: message)))"}
}

extension NotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: NotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The signing profile was not found.</p>
public struct NotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var code: String?
    public var message: String?

    public init (
        code: String? = nil,
        message: String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct NotFoundExceptionBody: Equatable {
    public let message: String?
    public let code: String?
}

extension NotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case code
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .code)
        code = codeDecoded
    }
}

extension Permission: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case action
        case principal
        case profileVersion
        case statementId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            try encodeContainer.encode(action, forKey: .action)
        }
        if let principal = principal {
            try encodeContainer.encode(principal, forKey: .principal)
        }
        if let profileVersion = profileVersion {
            try encodeContainer.encode(profileVersion, forKey: .profileVersion)
        }
        if let statementId = statementId {
            try encodeContainer.encode(statementId, forKey: .statementId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .action)
        action = actionDecoded
        let principalDecoded = try containerValues.decodeIfPresent(String.self, forKey: .principal)
        principal = principalDecoded
        let statementIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statementId)
        statementId = statementIdDecoded
        let profileVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .profileVersion)
        profileVersion = profileVersionDecoded
    }
}

extension Permission: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Permission(action: \(String(describing: action)), principal: \(String(describing: principal)), profileVersion: \(String(describing: profileVersion)), statementId: \(String(describing: statementId)))"}
}

/// <p>A cross-account permission for a signing profile.</p>
public struct Permission: Equatable {
    /// <p>An AWS Signer action permitted as part of cross-account permissions.</p>
    public let action: String?
    /// <p>The AWS principal that has been granted a cross-account permission.</p>
    public let principal: String?
    /// <p>The signing profile version that a permission applies to.</p>
    public let profileVersion: String?
    /// <p>A unique identifier for a cross-account permission statement.</p>
    public let statementId: String?

    public init (
        action: String? = nil,
        principal: String? = nil,
        profileVersion: String? = nil,
        statementId: String? = nil
    )
    {
        self.action = action
        self.principal = principal
        self.profileVersion = profileVersion
        self.statementId = statementId
    }
}

public struct PutSigningProfileInputBodyMiddleware: Middleware {
    public let id: String = "PutSigningProfileInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutSigningProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<PutSigningProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutSigningProfileInput>
    public typealias MOutput = OperationOutput<PutSigningProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutSigningProfileOutputError>
}

extension PutSigningProfileInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutSigningProfileInput(overrides: \(String(describing: overrides)), platformId: \(String(describing: platformId)), profileName: \(String(describing: profileName)), signatureValidityPeriod: \(String(describing: signatureValidityPeriod)), signingMaterial: \(String(describing: signingMaterial)), signingParameters: \(String(describing: signingParameters)), tags: \(String(describing: tags)))"}
}

extension PutSigningProfileInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case overrides
        case platformId
        case signatureValidityPeriod
        case signingMaterial
        case signingParameters
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let overrides = overrides {
            try encodeContainer.encode(overrides, forKey: .overrides)
        }
        if let platformId = platformId {
            try encodeContainer.encode(platformId, forKey: .platformId)
        }
        if let signatureValidityPeriod = signatureValidityPeriod {
            try encodeContainer.encode(signatureValidityPeriod, forKey: .signatureValidityPeriod)
        }
        if let signingMaterial = signingMaterial {
            try encodeContainer.encode(signingMaterial, forKey: .signingMaterial)
        }
        if let signingParameters = signingParameters {
            var signingParametersContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .signingParameters)
            for (dictKey0, signingparameters0) in signingParameters {
                try signingParametersContainer.encode(signingparameters0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct PutSigningProfileInputHeadersMiddleware: Middleware {
    public let id: String = "PutSigningProfileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutSigningProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<PutSigningProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutSigningProfileInput>
    public typealias MOutput = OperationOutput<PutSigningProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutSigningProfileOutputError>
}

public struct PutSigningProfileInputQueryItemMiddleware: Middleware {
    public let id: String = "PutSigningProfileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutSigningProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<PutSigningProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutSigningProfileInput>
    public typealias MOutput = OperationOutput<PutSigningProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutSigningProfileOutputError>
}

public struct PutSigningProfileInput: Equatable {
    /// <p>A subfield of <code>platform</code>. This specifies any different configuration
    /// 			options that you want to apply to the chosen platform (such as a different
    /// 				<code>hash-algorithm</code> or <code>signing-algorithm</code>).</p>
    public let overrides: SigningPlatformOverrides?
    /// <p>The ID of the signing platform to be created.</p>
    public let platformId: String?
    /// <p>The name of the signing profile to be created.</p>
    public let profileName: String?
    /// <p>The default validity period override for any signature generated using this signing
    /// 			profile. If unspecified, the default is 135 months.</p>
    public let signatureValidityPeriod: SignatureValidityPeriod?
    /// <p>The AWS Certificate Manager certificate that will be used to sign code with the new signing
    /// 			profile.</p>
    public let signingMaterial: SigningMaterial?
    /// <p>Map of key-value pairs for signing. These can include any information that you want to
    /// 			use during signing.</p>
    public let signingParameters: [String:String]?
    /// <p>Tags to be associated with the signing profile that is being created.</p>
    public let tags: [String:String]?

    public init (
        overrides: SigningPlatformOverrides? = nil,
        platformId: String? = nil,
        profileName: String? = nil,
        signatureValidityPeriod: SignatureValidityPeriod? = nil,
        signingMaterial: SigningMaterial? = nil,
        signingParameters: [String:String]? = nil,
        tags: [String:String]? = nil
    )
    {
        self.overrides = overrides
        self.platformId = platformId
        self.profileName = profileName
        self.signatureValidityPeriod = signatureValidityPeriod
        self.signingMaterial = signingMaterial
        self.signingParameters = signingParameters
        self.tags = tags
    }
}

struct PutSigningProfileInputBody: Equatable {
    public let signingMaterial: SigningMaterial?
    public let signatureValidityPeriod: SignatureValidityPeriod?
    public let platformId: String?
    public let overrides: SigningPlatformOverrides?
    public let signingParameters: [String:String]?
    public let tags: [String:String]?
}

extension PutSigningProfileInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case overrides
        case platformId
        case signatureValidityPeriod
        case signingMaterial
        case signingParameters
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let signingMaterialDecoded = try containerValues.decodeIfPresent(SigningMaterial.self, forKey: .signingMaterial)
        signingMaterial = signingMaterialDecoded
        let signatureValidityPeriodDecoded = try containerValues.decodeIfPresent(SignatureValidityPeriod.self, forKey: .signatureValidityPeriod)
        signatureValidityPeriod = signatureValidityPeriodDecoded
        let platformIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .platformId)
        platformId = platformIdDecoded
        let overridesDecoded = try containerValues.decodeIfPresent(SigningPlatformOverrides.self, forKey: .overrides)
        overrides = overridesDecoded
        let signingParametersContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .signingParameters)
        var signingParametersDecoded0: [String:String]? = nil
        if let signingParametersContainer = signingParametersContainer {
            signingParametersDecoded0 = [String:String]()
            for (key0, signingparametervalue0) in signingParametersContainer {
                if let signingparametervalue0 = signingparametervalue0 {
                    signingParametersDecoded0?[key0] = signingparametervalue0
                }
            }
        }
        signingParameters = signingParametersDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension PutSigningProfileOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutSigningProfileOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutSigningProfileOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceErrorException(InternalServiceErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutSigningProfileOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutSigningProfileOutputResponse(arn: \(String(describing: arn)), profileVersion: \(String(describing: profileVersion)), profileVersionArn: \(String(describing: profileVersionArn)))"}
}

extension PutSigningProfileOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PutSigningProfileOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.profileVersion = output.profileVersion
            self.profileVersionArn = output.profileVersionArn
        } else {
            self.arn = nil
            self.profileVersion = nil
            self.profileVersionArn = nil
        }
    }
}

public struct PutSigningProfileOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the signing profile created.</p>
    public let arn: String?
    /// <p>The version of the signing profile being created.</p>
    public let profileVersion: String?
    /// <p>The signing profile ARN, including the profile version.</p>
    public let profileVersionArn: String?

    public init (
        arn: String? = nil,
        profileVersion: String? = nil,
        profileVersionArn: String? = nil
    )
    {
        self.arn = arn
        self.profileVersion = profileVersion
        self.profileVersionArn = profileVersionArn
    }
}

struct PutSigningProfileOutputResponseBody: Equatable {
    public let arn: String?
    public let profileVersion: String?
    public let profileVersionArn: String?
}

extension PutSigningProfileOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn
        case profileVersion
        case profileVersionArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let profileVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .profileVersion)
        profileVersion = profileVersionDecoded
        let profileVersionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .profileVersionArn)
        profileVersionArn = profileVersionArnDecoded
    }
}

extension RemoveProfilePermissionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RemoveProfilePermissionInput(profileName: \(String(describing: profileName)), revisionId: \(String(describing: revisionId)), statementId: \(String(describing: statementId)))"}
}

extension RemoveProfilePermissionInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct RemoveProfilePermissionInputHeadersMiddleware: Middleware {
    public let id: String = "RemoveProfilePermissionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemoveProfilePermissionInput>,
                  next: H) -> Swift.Result<OperationOutput<RemoveProfilePermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemoveProfilePermissionInput>
    public typealias MOutput = OperationOutput<RemoveProfilePermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemoveProfilePermissionOutputError>
}

public struct RemoveProfilePermissionInputQueryItemMiddleware: Middleware {
    public let id: String = "RemoveProfilePermissionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemoveProfilePermissionInput>,
                  next: H) -> Swift.Result<OperationOutput<RemoveProfilePermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let revisionId = input.operationInput.revisionId {
            let revisionIdQueryItem = URLQueryItem(name: "revisionId".urlPercentEncoding(), value: String(revisionId).urlPercentEncoding())
            input.builder.withQueryItem(revisionIdQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemoveProfilePermissionInput>
    public typealias MOutput = OperationOutput<RemoveProfilePermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemoveProfilePermissionOutputError>
}

public struct RemoveProfilePermissionInput: Equatable {
    /// <p>A human-readable name for the signing profile with permissions to be removed.</p>
    public let profileName: String?
    /// <p>An identifier for the current revision of the signing profile permissions.</p>
    public let revisionId: String?
    /// <p>A unique identifier for the cross-account permissions statement.</p>
    public let statementId: String?

    public init (
        profileName: String? = nil,
        revisionId: String? = nil,
        statementId: String? = nil
    )
    {
        self.profileName = profileName
        self.revisionId = revisionId
        self.statementId = statementId
    }
}

struct RemoveProfilePermissionInputBody: Equatable {
}

extension RemoveProfilePermissionInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension RemoveProfilePermissionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RemoveProfilePermissionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RemoveProfilePermissionOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServiceErrorException(InternalServiceErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RemoveProfilePermissionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RemoveProfilePermissionOutputResponse(revisionId: \(String(describing: revisionId)))"}
}

extension RemoveProfilePermissionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RemoveProfilePermissionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.revisionId = output.revisionId
        } else {
            self.revisionId = nil
        }
    }
}

public struct RemoveProfilePermissionOutputResponse: Equatable {
    /// <p>An identifier for the current revision of the profile permissions.</p>
    public let revisionId: String?

    public init (
        revisionId: String? = nil
    )
    {
        self.revisionId = revisionId
    }
}

struct RemoveProfilePermissionOutputResponseBody: Equatable {
    public let revisionId: String?
}

extension RemoveProfilePermissionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case revisionId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let revisionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
    }
}

extension ResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundException(code: \(String(describing: code)), message: \(String(describing: message)))"}
}

extension ResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A specified resource could not be found.</p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var code: String?
    public var message: String?

    public init (
        code: String? = nil,
        message: String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Equatable {
    public let message: String?
    public let code: String?
}

extension ResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case code
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .code)
        code = codeDecoded
    }
}

public struct RevokeSignatureInputBodyMiddleware: Middleware {
    public let id: String = "RevokeSignatureInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RevokeSignatureInput>,
                  next: H) -> Swift.Result<OperationOutput<RevokeSignatureOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RevokeSignatureInput>
    public typealias MOutput = OperationOutput<RevokeSignatureOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RevokeSignatureOutputError>
}

extension RevokeSignatureInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RevokeSignatureInput(jobId: \(String(describing: jobId)), jobOwner: \(String(describing: jobOwner)), reason: \(String(describing: reason)))"}
}

extension RevokeSignatureInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case jobOwner
        case reason
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobOwner = jobOwner {
            try encodeContainer.encode(jobOwner, forKey: .jobOwner)
        }
        if let reason = reason {
            try encodeContainer.encode(reason, forKey: .reason)
        }
    }
}

public struct RevokeSignatureInputHeadersMiddleware: Middleware {
    public let id: String = "RevokeSignatureInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RevokeSignatureInput>,
                  next: H) -> Swift.Result<OperationOutput<RevokeSignatureOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RevokeSignatureInput>
    public typealias MOutput = OperationOutput<RevokeSignatureOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RevokeSignatureOutputError>
}

public struct RevokeSignatureInputQueryItemMiddleware: Middleware {
    public let id: String = "RevokeSignatureInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RevokeSignatureInput>,
                  next: H) -> Swift.Result<OperationOutput<RevokeSignatureOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RevokeSignatureInput>
    public typealias MOutput = OperationOutput<RevokeSignatureOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RevokeSignatureOutputError>
}

public struct RevokeSignatureInput: Equatable {
    /// <p>ID of the signing job to be revoked.</p>
    public let jobId: String?
    /// <p>AWS account ID of the job owner.</p>
    public let jobOwner: String?
    /// <p>The reason for revoking the signing job.</p>
    public let reason: String?

    public init (
        jobId: String? = nil,
        jobOwner: String? = nil,
        reason: String? = nil
    )
    {
        self.jobId = jobId
        self.jobOwner = jobOwner
        self.reason = reason
    }
}

struct RevokeSignatureInputBody: Equatable {
    public let jobOwner: String?
    public let reason: String?
}

extension RevokeSignatureInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobOwner
        case reason
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobOwnerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobOwner)
        jobOwner = jobOwnerDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension RevokeSignatureOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RevokeSignatureOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RevokeSignatureOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceErrorException(InternalServiceErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RevokeSignatureOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RevokeSignatureOutputResponse()"}
}

extension RevokeSignatureOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct RevokeSignatureOutputResponse: Equatable {

    public init() {}
}

struct RevokeSignatureOutputResponseBody: Equatable {
}

extension RevokeSignatureOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct RevokeSigningProfileInputBodyMiddleware: Middleware {
    public let id: String = "RevokeSigningProfileInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RevokeSigningProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<RevokeSigningProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RevokeSigningProfileInput>
    public typealias MOutput = OperationOutput<RevokeSigningProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RevokeSigningProfileOutputError>
}

extension RevokeSigningProfileInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RevokeSigningProfileInput(effectiveTime: \(String(describing: effectiveTime)), profileName: \(String(describing: profileName)), profileVersion: \(String(describing: profileVersion)), reason: \(String(describing: reason)))"}
}

extension RevokeSigningProfileInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case effectiveTime
        case profileVersion
        case reason
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let effectiveTime = effectiveTime {
            try encodeContainer.encode(effectiveTime.timeIntervalSince1970, forKey: .effectiveTime)
        }
        if let profileVersion = profileVersion {
            try encodeContainer.encode(profileVersion, forKey: .profileVersion)
        }
        if let reason = reason {
            try encodeContainer.encode(reason, forKey: .reason)
        }
    }
}

public struct RevokeSigningProfileInputHeadersMiddleware: Middleware {
    public let id: String = "RevokeSigningProfileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RevokeSigningProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<RevokeSigningProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RevokeSigningProfileInput>
    public typealias MOutput = OperationOutput<RevokeSigningProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RevokeSigningProfileOutputError>
}

public struct RevokeSigningProfileInputQueryItemMiddleware: Middleware {
    public let id: String = "RevokeSigningProfileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RevokeSigningProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<RevokeSigningProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RevokeSigningProfileInput>
    public typealias MOutput = OperationOutput<RevokeSigningProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RevokeSigningProfileOutputError>
}

public struct RevokeSigningProfileInput: Equatable {
    /// <p>A timestamp for when revocation of a Signing Profile should become effective.
    /// 			Signatures generated using the signing profile after this timestamp are not
    /// 			trusted.</p>
    public let effectiveTime: Date?
    /// <p>The name of the signing profile to be revoked.</p>
    public let profileName: String?
    /// <p>The version of the signing profile to be revoked.</p>
    public let profileVersion: String?
    /// <p>The reason for revoking a signing profile.</p>
    public let reason: String?

    public init (
        effectiveTime: Date? = nil,
        profileName: String? = nil,
        profileVersion: String? = nil,
        reason: String? = nil
    )
    {
        self.effectiveTime = effectiveTime
        self.profileName = profileName
        self.profileVersion = profileVersion
        self.reason = reason
    }
}

struct RevokeSigningProfileInputBody: Equatable {
    public let profileVersion: String?
    public let reason: String?
    public let effectiveTime: Date?
}

extension RevokeSigningProfileInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case effectiveTime
        case profileVersion
        case reason
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profileVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .profileVersion)
        profileVersion = profileVersionDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .reason)
        reason = reasonDecoded
        let effectiveTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .effectiveTime)
        effectiveTime = effectiveTimeDecoded
    }
}

extension RevokeSigningProfileOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RevokeSigningProfileOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RevokeSigningProfileOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceErrorException(InternalServiceErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RevokeSigningProfileOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RevokeSigningProfileOutputResponse()"}
}

extension RevokeSigningProfileOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct RevokeSigningProfileOutputResponse: Equatable {

    public init() {}
}

struct RevokeSigningProfileOutputResponseBody: Equatable {
}

extension RevokeSigningProfileOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension S3Destination: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bucketName
        case prefix
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketName = bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
        if let prefix = prefix {
            try encodeContainer.encode(prefix, forKey: .prefix)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
        let prefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .prefix)
        prefix = prefixDecoded
    }
}

extension S3Destination: CustomDebugStringConvertible {
    public var debugDescription: String {
        "S3Destination(bucketName: \(String(describing: bucketName)), prefix: \(String(describing: prefix)))"}
}

/// <p>The name and prefix of the S3 bucket where code signing saves your signed objects.</p>
public struct S3Destination: Equatable {
    /// <p>Name of the S3 bucket.</p>
    public let bucketName: String?
    /// <p>An Amazon S3 prefix that you can use to limit responses to those that begin with the
    /// 			specified prefix.</p>
    public let prefix: String?

    public init (
        bucketName: String? = nil,
        prefix: String? = nil
    )
    {
        self.bucketName = bucketName
        self.prefix = prefix
    }
}

extension S3SignedObject: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bucketName
        case key
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketName = bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
    }
}

extension S3SignedObject: CustomDebugStringConvertible {
    public var debugDescription: String {
        "S3SignedObject(bucketName: \(String(describing: bucketName)), key: \(String(describing: key)))"}
}

/// <p>The S3 bucket name and key where code signing saved your signed code image.</p>
public struct S3SignedObject: Equatable {
    /// <p>Name of the S3 bucket.</p>
    public let bucketName: String?
    /// <p>Key name that uniquely identifies a signed code image in your bucket.</p>
    public let key: String?

    public init (
        bucketName: String? = nil,
        key: String? = nil
    )
    {
        self.bucketName = bucketName
        self.key = key
    }
}

extension S3Source: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bucketName
        case key
        case version
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketName = bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
    }
}

extension S3Source: CustomDebugStringConvertible {
    public var debugDescription: String {
        "S3Source(bucketName: \(String(describing: bucketName)), key: \(String(describing: key)), version: \(String(describing: version)))"}
}

/// <p>Information about the S3 bucket where you saved your unsigned code.</p>
public struct S3Source: Equatable {
    /// <p>Name of the S3 bucket.</p>
    public let bucketName: String?
    /// <p>Key name of the bucket object that contains your unsigned code.</p>
    public let key: String?
    /// <p>Version of your source image in your version enabled S3 bucket.</p>
    public let version: String?

    public init (
        bucketName: String? = nil,
        key: String? = nil,
        version: String? = nil
    )
    {
        self.bucketName = bucketName
        self.key = key
        self.version = version
    }
}

extension ServiceLimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceLimitExceededException(code: \(String(describing: code)), message: \(String(describing: message)))"}
}

extension ServiceLimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ServiceLimitExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The client is making a request that exceeds service limits.</p>
public struct ServiceLimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var code: String?
    public var message: String?

    public init (
        code: String? = nil,
        message: String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct ServiceLimitExceededExceptionBody: Equatable {
    public let message: String?
    public let code: String?
}

extension ServiceLimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case code
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .code)
        code = codeDecoded
    }
}

extension SignatureValidityPeriod: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case type
        case value
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if value != 0 {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decode(Int.self, forKey: .value)
        value = valueDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ValidityType.self, forKey: .type)
        type = typeDecoded
    }
}

extension SignatureValidityPeriod: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SignatureValidityPeriod(type: \(String(describing: type)), value: \(String(describing: value)))"}
}

/// <p>The validity period for a signing job.</p>
public struct SignatureValidityPeriod: Equatable {
    /// <p>The time unit for signature
    /// 			validity.</p>
    public let type: ValidityType?
    /// <p>The numerical value of the time unit for signature validity.</p>
    public let value: Int

    public init (
        type: ValidityType? = nil,
        value: Int = 0
    )
    {
        self.type = type
        self.value = value
    }
}

extension SignedObject: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case s3
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3 = s3 {
            try encodeContainer.encode(s3, forKey: .s3)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3Decoded = try containerValues.decodeIfPresent(S3SignedObject.self, forKey: .s3)
        s3 = s3Decoded
    }
}

extension SignedObject: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SignedObject(s3: \(String(describing: s3)))"}
}

/// <p>Points to an <code>S3SignedObject</code> object that contains information about your
/// 			signed code image.</p>
public struct SignedObject: Equatable {
    /// <p>The <code>S3SignedObject</code>.</p>
    public let s3: S3SignedObject?

    public init (
        s3: S3SignedObject? = nil
    )
    {
        self.s3 = s3
    }
}

extension SigningConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case encryptionAlgorithmOptions
        case hashAlgorithmOptions
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encryptionAlgorithmOptions = encryptionAlgorithmOptions {
            try encodeContainer.encode(encryptionAlgorithmOptions, forKey: .encryptionAlgorithmOptions)
        }
        if let hashAlgorithmOptions = hashAlgorithmOptions {
            try encodeContainer.encode(hashAlgorithmOptions, forKey: .hashAlgorithmOptions)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let encryptionAlgorithmOptionsDecoded = try containerValues.decodeIfPresent(EncryptionAlgorithmOptions.self, forKey: .encryptionAlgorithmOptions)
        encryptionAlgorithmOptions = encryptionAlgorithmOptionsDecoded
        let hashAlgorithmOptionsDecoded = try containerValues.decodeIfPresent(HashAlgorithmOptions.self, forKey: .hashAlgorithmOptions)
        hashAlgorithmOptions = hashAlgorithmOptionsDecoded
    }
}

extension SigningConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SigningConfiguration(encryptionAlgorithmOptions: \(String(describing: encryptionAlgorithmOptions)), hashAlgorithmOptions: \(String(describing: hashAlgorithmOptions)))"}
}

/// <p>The configuration of a code signing operation.</p>
public struct SigningConfiguration: Equatable {
    /// <p>The encryption algorithm options that are available for a code signing job.</p>
    public let encryptionAlgorithmOptions: EncryptionAlgorithmOptions?
    /// <p>The hash algorithm options that are available for a code signing job.</p>
    public let hashAlgorithmOptions: HashAlgorithmOptions?

    public init (
        encryptionAlgorithmOptions: EncryptionAlgorithmOptions? = nil,
        hashAlgorithmOptions: HashAlgorithmOptions? = nil
    )
    {
        self.encryptionAlgorithmOptions = encryptionAlgorithmOptions
        self.hashAlgorithmOptions = hashAlgorithmOptions
    }
}

extension SigningConfigurationOverrides: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case encryptionAlgorithm
        case hashAlgorithm
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encryptionAlgorithm = encryptionAlgorithm {
            try encodeContainer.encode(encryptionAlgorithm.rawValue, forKey: .encryptionAlgorithm)
        }
        if let hashAlgorithm = hashAlgorithm {
            try encodeContainer.encode(hashAlgorithm.rawValue, forKey: .hashAlgorithm)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let encryptionAlgorithmDecoded = try containerValues.decodeIfPresent(EncryptionAlgorithm.self, forKey: .encryptionAlgorithm)
        encryptionAlgorithm = encryptionAlgorithmDecoded
        let hashAlgorithmDecoded = try containerValues.decodeIfPresent(HashAlgorithm.self, forKey: .hashAlgorithm)
        hashAlgorithm = hashAlgorithmDecoded
    }
}

extension SigningConfigurationOverrides: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SigningConfigurationOverrides(encryptionAlgorithm: \(String(describing: encryptionAlgorithm)), hashAlgorithm: \(String(describing: hashAlgorithm)))"}
}

/// <p>A signing configuration that overrides the default encryption or hash algorithm of a
/// 			signing job.</p>
public struct SigningConfigurationOverrides: Equatable {
    /// <p>A specified override of the default encryption algorithm that is used in a code signing
    /// 			job.</p>
    public let encryptionAlgorithm: EncryptionAlgorithm?
    /// <p>A specified override of the default hash algorithm that is used in a code signing
    /// 			job.</p>
    public let hashAlgorithm: HashAlgorithm?

    public init (
        encryptionAlgorithm: EncryptionAlgorithm? = nil,
        hashAlgorithm: HashAlgorithm? = nil
    )
    {
        self.encryptionAlgorithm = encryptionAlgorithm
        self.hashAlgorithm = hashAlgorithm
    }
}

extension SigningImageFormat: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case defaultFormat
        case supportedFormats
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultFormat = defaultFormat {
            try encodeContainer.encode(defaultFormat.rawValue, forKey: .defaultFormat)
        }
        if let supportedFormats = supportedFormats {
            var supportedFormatsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .supportedFormats)
            for imageformats0 in supportedFormats {
                try supportedFormatsContainer.encode(imageformats0.rawValue)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let supportedFormatsContainer = try containerValues.decodeIfPresent([ImageFormat?].self, forKey: .supportedFormats)
        var supportedFormatsDecoded0:[ImageFormat]? = nil
        if let supportedFormatsContainer = supportedFormatsContainer {
            supportedFormatsDecoded0 = [ImageFormat]()
            for string0 in supportedFormatsContainer {
                if let string0 = string0 {
                    supportedFormatsDecoded0?.append(string0)
                }
            }
        }
        supportedFormats = supportedFormatsDecoded0
        let defaultFormatDecoded = try containerValues.decodeIfPresent(ImageFormat.self, forKey: .defaultFormat)
        defaultFormat = defaultFormatDecoded
    }
}

extension SigningImageFormat: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SigningImageFormat(defaultFormat: \(String(describing: defaultFormat)), supportedFormats: \(String(describing: supportedFormats)))"}
}

/// <p>The image format of a code signing platform or profile.</p>
public struct SigningImageFormat: Equatable {
    /// <p>The default format of a code signing image.</p>
    public let defaultFormat: ImageFormat?
    /// <p>The supported formats of a code signing image.</p>
    public let supportedFormats: [ImageFormat]?

    public init (
        defaultFormat: ImageFormat? = nil,
        supportedFormats: [ImageFormat]? = nil
    )
    {
        self.defaultFormat = defaultFormat
        self.supportedFormats = supportedFormats
    }
}

extension SigningJob: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case createdAt
        case isRevoked
        case jobId
        case jobInvoker
        case jobOwner
        case platformDisplayName
        case platformId
        case profileName
        case profileVersion
        case signatureExpiresAt
        case signedObject
        case signingMaterial
        case source
        case status
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if isRevoked != false {
            try encodeContainer.encode(isRevoked, forKey: .isRevoked)
        }
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let jobInvoker = jobInvoker {
            try encodeContainer.encode(jobInvoker, forKey: .jobInvoker)
        }
        if let jobOwner = jobOwner {
            try encodeContainer.encode(jobOwner, forKey: .jobOwner)
        }
        if let platformDisplayName = platformDisplayName {
            try encodeContainer.encode(platformDisplayName, forKey: .platformDisplayName)
        }
        if let platformId = platformId {
            try encodeContainer.encode(platformId, forKey: .platformId)
        }
        if let profileName = profileName {
            try encodeContainer.encode(profileName, forKey: .profileName)
        }
        if let profileVersion = profileVersion {
            try encodeContainer.encode(profileVersion, forKey: .profileVersion)
        }
        if let signatureExpiresAt = signatureExpiresAt {
            try encodeContainer.encode(signatureExpiresAt.timeIntervalSince1970, forKey: .signatureExpiresAt)
        }
        if let signedObject = signedObject {
            try encodeContainer.encode(signedObject, forKey: .signedObject)
        }
        if let signingMaterial = signingMaterial {
            try encodeContainer.encode(signingMaterial, forKey: .signingMaterial)
        }
        if let source = source {
            try encodeContainer.encode(source, forKey: .source)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let sourceDecoded = try containerValues.decodeIfPresent(Source.self, forKey: .source)
        source = sourceDecoded
        let signedObjectDecoded = try containerValues.decodeIfPresent(SignedObject.self, forKey: .signedObject)
        signedObject = signedObjectDecoded
        let signingMaterialDecoded = try containerValues.decodeIfPresent(SigningMaterial.self, forKey: .signingMaterial)
        signingMaterial = signingMaterialDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SigningStatus.self, forKey: .status)
        status = statusDecoded
        let isRevokedDecoded = try containerValues.decode(Bool.self, forKey: .isRevoked)
        isRevoked = isRevokedDecoded
        let profileNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .profileName)
        profileName = profileNameDecoded
        let profileVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .profileVersion)
        profileVersion = profileVersionDecoded
        let platformIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .platformId)
        platformId = platformIdDecoded
        let platformDisplayNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .platformDisplayName)
        platformDisplayName = platformDisplayNameDecoded
        let signatureExpiresAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .signatureExpiresAt)
        signatureExpiresAt = signatureExpiresAtDecoded
        let jobOwnerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobOwner)
        jobOwner = jobOwnerDecoded
        let jobInvokerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobInvoker)
        jobInvoker = jobInvokerDecoded
    }
}

extension SigningJob: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SigningJob(createdAt: \(String(describing: createdAt)), isRevoked: \(String(describing: isRevoked)), jobId: \(String(describing: jobId)), jobInvoker: \(String(describing: jobInvoker)), jobOwner: \(String(describing: jobOwner)), platformDisplayName: \(String(describing: platformDisplayName)), platformId: \(String(describing: platformId)), profileName: \(String(describing: profileName)), profileVersion: \(String(describing: profileVersion)), signatureExpiresAt: \(String(describing: signatureExpiresAt)), signedObject: \(String(describing: signedObject)), signingMaterial: \(String(describing: signingMaterial)), source: \(String(describing: source)), status: \(String(describing: status)))"}
}

/// <p>Contains information about a signing job.</p>
public struct SigningJob: Equatable {
    /// <p>The date and time that the signing job was created.</p>
    public let createdAt: Date?
    /// <p>Indicates whether the signing job is revoked.</p>
    public let isRevoked: Bool
    /// <p>The ID of the signing job.</p>
    public let jobId: String?
    /// <p>The AWS account ID of the job invoker.</p>
    public let jobInvoker: String?
    /// <p>The AWS account ID of the job owner.</p>
    public let jobOwner: String?
    /// <p>The name of a signing platform.</p>
    public let platformDisplayName: String?
    /// <p>The unique identifier for a signing platform.</p>
    public let platformId: String?
    /// <p>The name of the signing profile that created a signing job.</p>
    public let profileName: String?
    /// <p>The version of the signing profile that created a signing job.</p>
    public let profileVersion: String?
    /// <p>The time when the signature of a signing job expires.</p>
    public let signatureExpiresAt: Date?
    /// <p>A <code>SignedObject</code> structure that contains information about a signing job's
    /// 			signed code image.</p>
    public let signedObject: SignedObject?
    /// <p>A <code>SigningMaterial</code> object that contains the Amazon Resource Name (ARN) of
    /// 			the certificate used for the signing job.</p>
    public let signingMaterial: SigningMaterial?
    /// <p>A <code>Source</code> that contains information about a signing job's code image
    /// 			source.</p>
    public let source: Source?
    /// <p>The status of the signing job.</p>
    public let status: SigningStatus?

    public init (
        createdAt: Date? = nil,
        isRevoked: Bool = false,
        jobId: String? = nil,
        jobInvoker: String? = nil,
        jobOwner: String? = nil,
        platformDisplayName: String? = nil,
        platformId: String? = nil,
        profileName: String? = nil,
        profileVersion: String? = nil,
        signatureExpiresAt: Date? = nil,
        signedObject: SignedObject? = nil,
        signingMaterial: SigningMaterial? = nil,
        source: Source? = nil,
        status: SigningStatus? = nil
    )
    {
        self.createdAt = createdAt
        self.isRevoked = isRevoked
        self.jobId = jobId
        self.jobInvoker = jobInvoker
        self.jobOwner = jobOwner
        self.platformDisplayName = platformDisplayName
        self.platformId = platformId
        self.profileName = profileName
        self.profileVersion = profileVersion
        self.signatureExpiresAt = signatureExpiresAt
        self.signedObject = signedObject
        self.signingMaterial = signingMaterial
        self.source = source
        self.status = status
    }
}

extension SigningJobRevocationRecord: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case reason
        case revokedAt
        case revokedBy
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let reason = reason {
            try encodeContainer.encode(reason, forKey: .reason)
        }
        if let revokedAt = revokedAt {
            try encodeContainer.encode(revokedAt.timeIntervalSince1970, forKey: .revokedAt)
        }
        if let revokedBy = revokedBy {
            try encodeContainer.encode(revokedBy, forKey: .revokedBy)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .reason)
        reason = reasonDecoded
        let revokedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .revokedAt)
        revokedAt = revokedAtDecoded
        let revokedByDecoded = try containerValues.decodeIfPresent(String.self, forKey: .revokedBy)
        revokedBy = revokedByDecoded
    }
}

extension SigningJobRevocationRecord: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SigningJobRevocationRecord(reason: \(String(describing: reason)), revokedAt: \(String(describing: revokedAt)), revokedBy: \(String(describing: revokedBy)))"}
}

/// <p>Revocation information for a signing job.</p>
public struct SigningJobRevocationRecord: Equatable {
    /// <p>A caller-supplied reason for revocation.</p>
    public let reason: String?
    /// <p>The time of revocation.</p>
    public let revokedAt: Date?
    /// <p>The identity of the revoker.</p>
    public let revokedBy: String?

    public init (
        reason: String? = nil,
        revokedAt: Date? = nil,
        revokedBy: String? = nil
    )
    {
        self.reason = reason
        self.revokedAt = revokedAt
        self.revokedBy = revokedBy
    }
}

extension SigningMaterial: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case certificateArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateArn = certificateArn {
            try encodeContainer.encode(certificateArn, forKey: .certificateArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificateArn)
        certificateArn = certificateArnDecoded
    }
}

extension SigningMaterial: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SigningMaterial(certificateArn: \(String(describing: certificateArn)))"}
}

/// <p>The ACM certificate that is used to sign your code.</p>
public struct SigningMaterial: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the certificates that is used to sign your
    /// 			code.</p>
    public let certificateArn: String?

    public init (
        certificateArn: String? = nil
    )
    {
        self.certificateArn = certificateArn
    }
}

extension SigningPlatform: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case category
        case displayName
        case maxSizeInMB
        case partner
        case platformId
        case revocationSupported
        case signingConfiguration
        case signingImageFormat
        case target
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let category = category {
            try encodeContainer.encode(category.rawValue, forKey: .category)
        }
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if maxSizeInMB != 0 {
            try encodeContainer.encode(maxSizeInMB, forKey: .maxSizeInMB)
        }
        if let partner = partner {
            try encodeContainer.encode(partner, forKey: .partner)
        }
        if let platformId = platformId {
            try encodeContainer.encode(platformId, forKey: .platformId)
        }
        if revocationSupported != false {
            try encodeContainer.encode(revocationSupported, forKey: .revocationSupported)
        }
        if let signingConfiguration = signingConfiguration {
            try encodeContainer.encode(signingConfiguration, forKey: .signingConfiguration)
        }
        if let signingImageFormat = signingImageFormat {
            try encodeContainer.encode(signingImageFormat, forKey: .signingImageFormat)
        }
        if let target = target {
            try encodeContainer.encode(target, forKey: .target)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let platformIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .platformId)
        platformId = platformIdDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let partnerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .partner)
        partner = partnerDecoded
        let targetDecoded = try containerValues.decodeIfPresent(String.self, forKey: .target)
        target = targetDecoded
        let categoryDecoded = try containerValues.decodeIfPresent(Category.self, forKey: .category)
        category = categoryDecoded
        let signingConfigurationDecoded = try containerValues.decodeIfPresent(SigningConfiguration.self, forKey: .signingConfiguration)
        signingConfiguration = signingConfigurationDecoded
        let signingImageFormatDecoded = try containerValues.decodeIfPresent(SigningImageFormat.self, forKey: .signingImageFormat)
        signingImageFormat = signingImageFormatDecoded
        let maxSizeInMBDecoded = try containerValues.decode(Int.self, forKey: .maxSizeInMB)
        maxSizeInMB = maxSizeInMBDecoded
        let revocationSupportedDecoded = try containerValues.decode(Bool.self, forKey: .revocationSupported)
        revocationSupported = revocationSupportedDecoded
    }
}

extension SigningPlatform: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SigningPlatform(category: \(String(describing: category)), displayName: \(String(describing: displayName)), maxSizeInMB: \(String(describing: maxSizeInMB)), partner: \(String(describing: partner)), platformId: \(String(describing: platformId)), revocationSupported: \(String(describing: revocationSupported)), signingConfiguration: \(String(describing: signingConfiguration)), signingImageFormat: \(String(describing: signingImageFormat)), target: \(String(describing: target)))"}
}

/// <p>Contains information about the signing configurations and parameters that are used to
/// 			perform a code signing job.</p>
public struct SigningPlatform: Equatable {
    /// <p>The category of a code signing platform.</p>
    public let category: Category?
    /// <p>The display name of a code signing platform.</p>
    public let displayName: String?
    /// <p>The maximum size (in MB) of code that can be signed by a code signing platform.</p>
    public let maxSizeInMB: Int
    /// <p>Any partner entities linked to a code signing platform.</p>
    public let partner: String?
    /// <p>The ID of a code signing; platform.</p>
    public let platformId: String?
    /// <p>Indicates whether revocation is supported for the platform.</p>
    public let revocationSupported: Bool
    /// <p>The configuration of a code signing platform. This includes the designated hash algorithm
    /// 			and encryption algorithm of a signing platform.</p>
    public let signingConfiguration: SigningConfiguration?
    /// <p>The image format of a code signing platform or profile.</p>
    public let signingImageFormat: SigningImageFormat?
    /// <p>The types of targets that can be signed by a code signing platform.</p>
    public let target: String?

    public init (
        category: Category? = nil,
        displayName: String? = nil,
        maxSizeInMB: Int = 0,
        partner: String? = nil,
        platformId: String? = nil,
        revocationSupported: Bool = false,
        signingConfiguration: SigningConfiguration? = nil,
        signingImageFormat: SigningImageFormat? = nil,
        target: String? = nil
    )
    {
        self.category = category
        self.displayName = displayName
        self.maxSizeInMB = maxSizeInMB
        self.partner = partner
        self.platformId = platformId
        self.revocationSupported = revocationSupported
        self.signingConfiguration = signingConfiguration
        self.signingImageFormat = signingImageFormat
        self.target = target
    }
}

extension SigningPlatformOverrides: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case signingConfiguration
        case signingImageFormat
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let signingConfiguration = signingConfiguration {
            try encodeContainer.encode(signingConfiguration, forKey: .signingConfiguration)
        }
        if let signingImageFormat = signingImageFormat {
            try encodeContainer.encode(signingImageFormat.rawValue, forKey: .signingImageFormat)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let signingConfigurationDecoded = try containerValues.decodeIfPresent(SigningConfigurationOverrides.self, forKey: .signingConfiguration)
        signingConfiguration = signingConfigurationDecoded
        let signingImageFormatDecoded = try containerValues.decodeIfPresent(ImageFormat.self, forKey: .signingImageFormat)
        signingImageFormat = signingImageFormatDecoded
    }
}

extension SigningPlatformOverrides: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SigningPlatformOverrides(signingConfiguration: \(String(describing: signingConfiguration)), signingImageFormat: \(String(describing: signingImageFormat)))"}
}

/// <p>Any overrides that are applied to the signing configuration of a code signing
/// 			platform.</p>
public struct SigningPlatformOverrides: Equatable {
    /// <p>A signing configuration that overrides the default encryption or hash algorithm of a
    /// 			signing job.</p>
    public let signingConfiguration: SigningConfigurationOverrides?
    /// <p>A signed image is a JSON object. When overriding the default signing platform
    /// 			configuration, a customer can select either of two signing formats,
    /// 				<code>JSONEmbedded</code> or <code>JSONDetached</code>. (A third format value,
    /// 				<code>JSON</code>, is reserved for future use.) With <code>JSONEmbedded</code>, the
    /// 			signing image has the payload embedded in it. With <code>JSONDetached</code>, the
    /// 			payload is not be embedded in the signing image.</p>
    public let signingImageFormat: ImageFormat?

    public init (
        signingConfiguration: SigningConfigurationOverrides? = nil,
        signingImageFormat: ImageFormat? = nil
    )
    {
        self.signingConfiguration = signingConfiguration
        self.signingImageFormat = signingImageFormat
    }
}

extension SigningProfile: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case platformDisplayName
        case platformId
        case profileName
        case profileVersion
        case profileVersionArn
        case signatureValidityPeriod
        case signingMaterial
        case signingParameters
        case status
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let platformDisplayName = platformDisplayName {
            try encodeContainer.encode(platformDisplayName, forKey: .platformDisplayName)
        }
        if let platformId = platformId {
            try encodeContainer.encode(platformId, forKey: .platformId)
        }
        if let profileName = profileName {
            try encodeContainer.encode(profileName, forKey: .profileName)
        }
        if let profileVersion = profileVersion {
            try encodeContainer.encode(profileVersion, forKey: .profileVersion)
        }
        if let profileVersionArn = profileVersionArn {
            try encodeContainer.encode(profileVersionArn, forKey: .profileVersionArn)
        }
        if let signatureValidityPeriod = signatureValidityPeriod {
            try encodeContainer.encode(signatureValidityPeriod, forKey: .signatureValidityPeriod)
        }
        if let signingMaterial = signingMaterial {
            try encodeContainer.encode(signingMaterial, forKey: .signingMaterial)
        }
        if let signingParameters = signingParameters {
            var signingParametersContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .signingParameters)
            for (dictKey0, signingparameters0) in signingParameters {
                try signingParametersContainer.encode(signingparameters0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profileNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .profileName)
        profileName = profileNameDecoded
        let profileVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .profileVersion)
        profileVersion = profileVersionDecoded
        let profileVersionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .profileVersionArn)
        profileVersionArn = profileVersionArnDecoded
        let signingMaterialDecoded = try containerValues.decodeIfPresent(SigningMaterial.self, forKey: .signingMaterial)
        signingMaterial = signingMaterialDecoded
        let signatureValidityPeriodDecoded = try containerValues.decodeIfPresent(SignatureValidityPeriod.self, forKey: .signatureValidityPeriod)
        signatureValidityPeriod = signatureValidityPeriodDecoded
        let platformIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .platformId)
        platformId = platformIdDecoded
        let platformDisplayNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .platformDisplayName)
        platformDisplayName = platformDisplayNameDecoded
        let signingParametersContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .signingParameters)
        var signingParametersDecoded0: [String:String]? = nil
        if let signingParametersContainer = signingParametersContainer {
            signingParametersDecoded0 = [String:String]()
            for (key0, signingparametervalue0) in signingParametersContainer {
                if let signingparametervalue0 = signingparametervalue0 {
                    signingParametersDecoded0?[key0] = signingparametervalue0
                }
            }
        }
        signingParameters = signingParametersDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(SigningProfileStatus.self, forKey: .status)
        status = statusDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension SigningProfile: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SigningProfile(arn: \(String(describing: arn)), platformDisplayName: \(String(describing: platformDisplayName)), platformId: \(String(describing: platformId)), profileName: \(String(describing: profileName)), profileVersion: \(String(describing: profileVersion)), profileVersionArn: \(String(describing: profileVersionArn)), signatureValidityPeriod: \(String(describing: signatureValidityPeriod)), signingMaterial: \(String(describing: signingMaterial)), signingParameters: \(String(describing: signingParameters)), status: \(String(describing: status)), tags: \(String(describing: tags)))"}
}

/// <p>Contains information about the ACM certificates and code signing configuration parameters
/// 			that can be used by a given code signing user.</p>
public struct SigningProfile: Equatable {
    /// <p>The Amazon Resource Name (ARN) for the signing profile.</p>
    public let arn: String?
    /// <p>The name of the signing platform.</p>
    public let platformDisplayName: String?
    /// <p>The ID of a platform that is available for use by a signing profile.</p>
    public let platformId: String?
    /// <p>The name of the signing profile.</p>
    public let profileName: String?
    /// <p>The version of a signing profile.</p>
    public let profileVersion: String?
    /// <p>The ARN of a signing profile, including the profile version.</p>
    public let profileVersionArn: String?
    /// <p>The validity period for a signing job created using this signing profile.</p>
    public let signatureValidityPeriod: SignatureValidityPeriod?
    /// <p>The ACM certificate that is available for use by a signing profile.</p>
    public let signingMaterial: SigningMaterial?
    /// <p>The parameters that are available for use by a code signing user.</p>
    public let signingParameters: [String:String]?
    /// <p>The status of a code signing profile.</p>
    public let status: SigningProfileStatus?
    /// <p>A list of tags associated with the signing profile.</p>
    public let tags: [String:String]?

    public init (
        arn: String? = nil,
        platformDisplayName: String? = nil,
        platformId: String? = nil,
        profileName: String? = nil,
        profileVersion: String? = nil,
        profileVersionArn: String? = nil,
        signatureValidityPeriod: SignatureValidityPeriod? = nil,
        signingMaterial: SigningMaterial? = nil,
        signingParameters: [String:String]? = nil,
        status: SigningProfileStatus? = nil,
        tags: [String:String]? = nil
    )
    {
        self.arn = arn
        self.platformDisplayName = platformDisplayName
        self.platformId = platformId
        self.profileName = profileName
        self.profileVersion = profileVersion
        self.profileVersionArn = profileVersionArn
        self.signatureValidityPeriod = signatureValidityPeriod
        self.signingMaterial = signingMaterial
        self.signingParameters = signingParameters
        self.status = status
        self.tags = tags
    }
}

extension SigningProfileRevocationRecord: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case revocationEffectiveFrom
        case revokedAt
        case revokedBy
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let revocationEffectiveFrom = revocationEffectiveFrom {
            try encodeContainer.encode(revocationEffectiveFrom.timeIntervalSince1970, forKey: .revocationEffectiveFrom)
        }
        if let revokedAt = revokedAt {
            try encodeContainer.encode(revokedAt.timeIntervalSince1970, forKey: .revokedAt)
        }
        if let revokedBy = revokedBy {
            try encodeContainer.encode(revokedBy, forKey: .revokedBy)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let revocationEffectiveFromDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .revocationEffectiveFrom)
        revocationEffectiveFrom = revocationEffectiveFromDecoded
        let revokedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .revokedAt)
        revokedAt = revokedAtDecoded
        let revokedByDecoded = try containerValues.decodeIfPresent(String.self, forKey: .revokedBy)
        revokedBy = revokedByDecoded
    }
}

extension SigningProfileRevocationRecord: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SigningProfileRevocationRecord(revocationEffectiveFrom: \(String(describing: revocationEffectiveFrom)), revokedAt: \(String(describing: revokedAt)), revokedBy: \(String(describing: revokedBy)))"}
}

/// <p>Revocation information for a signing profile.</p>
public struct SigningProfileRevocationRecord: Equatable {
    /// <p>The time when revocation becomes effective.</p>
    public let revocationEffectiveFrom: Date?
    /// <p>The time when the signing profile was revoked.</p>
    public let revokedAt: Date?
    /// <p>The identity of the revoker.</p>
    public let revokedBy: String?

    public init (
        revocationEffectiveFrom: Date? = nil,
        revokedAt: Date? = nil,
        revokedBy: String? = nil
    )
    {
        self.revocationEffectiveFrom = revocationEffectiveFrom
        self.revokedAt = revokedAt
        self.revokedBy = revokedBy
    }
}

public enum SigningProfileStatus {
    case active
    case canceled
    case revoked
    case sdkUnknown(String)
}

extension SigningProfileStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SigningProfileStatus] {
        return [
            .active,
            .canceled,
            .revoked,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .active: return "Active"
        case .canceled: return "Canceled"
        case .revoked: return "Revoked"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SigningProfileStatus(rawValue: rawValue) ?? SigningProfileStatus.sdkUnknown(rawValue)
    }
}

public enum SigningStatus {
    case failed
    case inprogress
    case succeeded
    case sdkUnknown(String)
}

extension SigningStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SigningStatus] {
        return [
            .failed,
            .inprogress,
            .succeeded,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .failed: return "Failed"
        case .inprogress: return "InProgress"
        case .succeeded: return "Succeeded"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SigningStatus(rawValue: rawValue) ?? SigningStatus.sdkUnknown(rawValue)
    }
}

extension Source: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case s3
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3 = s3 {
            try encodeContainer.encode(s3, forKey: .s3)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3Decoded = try containerValues.decodeIfPresent(S3Source.self, forKey: .s3)
        s3 = s3Decoded
    }
}

extension Source: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Source(s3: \(String(describing: s3)))"}
}

/// <p>An <code>S3Source</code> object that contains information about the S3 bucket where
/// 			you saved your unsigned code.</p>
public struct Source: Equatable {
    /// <p>The <code>S3Source</code> object.</p>
    public let s3: S3Source?

    public init (
        s3: S3Source? = nil
    )
    {
        self.s3 = s3
    }
}

public struct StartSigningJobInputBodyMiddleware: Middleware {
    public let id: String = "StartSigningJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartSigningJobInput>,
                  next: H) -> Swift.Result<OperationOutput<StartSigningJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartSigningJobInput>
    public typealias MOutput = OperationOutput<StartSigningJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartSigningJobOutputError>
}

extension StartSigningJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartSigningJobInput(clientRequestToken: \(String(describing: clientRequestToken)), destination: \(String(describing: destination)), profileName: \(String(describing: profileName)), profileOwner: \(String(describing: profileOwner)), source: \(String(describing: source)))"}
}

extension StartSigningJobInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken
        case destination
        case profileName
        case profileOwner
        case source
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let destination = destination {
            try encodeContainer.encode(destination, forKey: .destination)
        }
        if let profileName = profileName {
            try encodeContainer.encode(profileName, forKey: .profileName)
        }
        if let profileOwner = profileOwner {
            try encodeContainer.encode(profileOwner, forKey: .profileOwner)
        }
        if let source = source {
            try encodeContainer.encode(source, forKey: .source)
        }
    }
}

public struct StartSigningJobInputHeadersMiddleware: Middleware {
    public let id: String = "StartSigningJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartSigningJobInput>,
                  next: H) -> Swift.Result<OperationOutput<StartSigningJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartSigningJobInput>
    public typealias MOutput = OperationOutput<StartSigningJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartSigningJobOutputError>
}

public struct StartSigningJobInputQueryItemMiddleware: Middleware {
    public let id: String = "StartSigningJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartSigningJobInput>,
                  next: H) -> Swift.Result<OperationOutput<StartSigningJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartSigningJobInput>
    public typealias MOutput = OperationOutput<StartSigningJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartSigningJobOutputError>
}

public struct StartSigningJobInput: Equatable {
    /// <p>String that identifies the signing request. All calls after the first that use this
    /// 			token return the same response as the first call.</p>
    public var clientRequestToken: String?
    /// <p>The S3 bucket in which to save your signed object. The destination contains the name
    /// 			of your bucket and an optional prefix.</p>
    public let destination: Destination?
    /// <p>The name of the signing profile.</p>
    public let profileName: String?
    /// <p>The AWS account ID of the signing profile owner.</p>
    public let profileOwner: String?
    /// <p>The S3 bucket that contains the object to sign or a BLOB that contains your raw
    /// 			code.</p>
    public let source: Source?

    public init (
        clientRequestToken: String? = nil,
        destination: Destination? = nil,
        profileName: String? = nil,
        profileOwner: String? = nil,
        source: Source? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.destination = destination
        self.profileName = profileName
        self.profileOwner = profileOwner
        self.source = source
    }
}

struct StartSigningJobInputBody: Equatable {
    public let source: Source?
    public let destination: Destination?
    public let profileName: String?
    public let clientRequestToken: String?
    public let profileOwner: String?
}

extension StartSigningJobInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken
        case destination
        case profileName
        case profileOwner
        case source
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceDecoded = try containerValues.decodeIfPresent(Source.self, forKey: .source)
        source = sourceDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(Destination.self, forKey: .destination)
        destination = destinationDecoded
        let profileNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .profileName)
        profileName = profileNameDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let profileOwnerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .profileOwner)
        profileOwner = profileOwnerDecoded
    }
}

extension StartSigningJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartSigningJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartSigningJobOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceErrorException(InternalServiceErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case tooManyRequestsException(TooManyRequestsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartSigningJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartSigningJobOutputResponse(jobId: \(String(describing: jobId)), jobOwner: \(String(describing: jobOwner)))"}
}

extension StartSigningJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StartSigningJobOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.jobId = output.jobId
            self.jobOwner = output.jobOwner
        } else {
            self.jobId = nil
            self.jobOwner = nil
        }
    }
}

public struct StartSigningJobOutputResponse: Equatable {
    /// <p>The ID of your signing job.</p>
    public let jobId: String?
    /// <p>The AWS account ID of the signing job owner.</p>
    public let jobOwner: String?

    public init (
        jobId: String? = nil,
        jobOwner: String? = nil
    )
    {
        self.jobId = jobId
        self.jobOwner = jobOwner
    }
}

struct StartSigningJobOutputResponseBody: Equatable {
    public let jobId: String?
    public let jobOwner: String?
}

extension StartSigningJobOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobId
        case jobOwner
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let jobOwnerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobOwner)
        jobOwner = jobOwnerDecoded
    }
}

public struct TagResourceInputBodyMiddleware: Middleware {
    public let id: String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

extension TagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceInput(resourceArn: \(String(describing: resourceArn)), tags: \(String(describing: tags)))"}
}

extension TagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) for the signing profile.</p>
    public let resourceArn: String?
    /// <p>One or more tags to be associated with the signing profile.</p>
    public let tags: [String:String]?

    public init (
        resourceArn: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Equatable {
    public let tags: [String:String]?
}

extension TagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Equatable {
    case badRequestException(BadRequestException)
    case internalServiceErrorException(InternalServiceErrorException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Equatable {
}

extension TagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ThrottlingException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ThrottlingException(code: \(String(describing: code)), message: \(String(describing: message)))"}
}

extension ThrottlingException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request was denied due to request throttling.</p>
///         <p>Instead of this error, <code>TooManyRequestsException</code> should be used.</p>
@available(*, deprecated, message: "Instead of this error, TooManyRequestsException should be used.")
public struct ThrottlingException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var code: String?
    public var message: String?

    public init (
        code: String? = nil,
        message: String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct ThrottlingExceptionBody: Equatable {
    public let message: String?
    public let code: String?
}

extension ThrottlingExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case code
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .code)
        code = codeDecoded
    }
}

extension TooManyRequestsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TooManyRequestsException(code: \(String(describing: code)), message: \(String(describing: message)))"}
}

extension TooManyRequestsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: TooManyRequestsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The allowed number of job-signing requests has been exceeded.</p>
/// 		       <p>This error supersedes the error <code>ThrottlingException</code>.</p>
public struct TooManyRequestsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var code: String?
    public var message: String?

    public init (
        code: String? = nil,
        message: String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct TooManyRequestsExceptionBody: Equatable {
    public let message: String?
    public let code: String?
}

extension TooManyRequestsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case code
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .code)
        code = codeDecoded
    }
}

extension UntagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceInput(resourceArn: \(String(describing: resourceArn)), tagKeys: \(String(describing: tagKeys)))"}
}

extension UntagResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct UntagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let tagKeys = input.operationInput.tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) for the signing profile.</p>
    public let resourceArn: String?
    /// <p>A list of tag keys to be removed from the signing profile.</p>
    public let tagKeys: [String]?

    public init (
        resourceArn: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Equatable {
}

extension UntagResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension UntagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Equatable {
    case badRequestException(BadRequestException)
    case internalServiceErrorException(InternalServiceErrorException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Equatable {
}

extension UntagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ValidationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ValidationException(code: \(String(describing: code)), message: \(String(describing: message)))"}
}

extension ValidationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You signing certificate could not be validated.</p>
public struct ValidationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var code: String?
    public var message: String?

    public init (
        code: String? = nil,
        message: String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct ValidationExceptionBody: Equatable {
    public let message: String?
    public let code: String?
}

extension ValidationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case code
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .code)
        code = codeDecoded
    }
}

public enum ValidityType {
    case days
    case months
    case years
    case sdkUnknown(String)
}

extension ValidityType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ValidityType] {
        return [
            .days,
            .months,
            .years,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .days: return "DAYS"
        case .months: return "MONTHS"
        case .years: return "YEARS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ValidityType(rawValue: rawValue) ?? ValidityType.sdkUnknown(rawValue)
    }
}
