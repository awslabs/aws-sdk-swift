// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension ApplicationDependencySummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applicationId = "applicationId"
        case semanticVersion = "semanticVersion"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationId = applicationId {
            try encodeContainer.encode(applicationId, forKey: .applicationId)
        }
        if let semanticVersion = semanticVersion {
            try encodeContainer.encode(semanticVersion, forKey: .semanticVersion)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let semanticVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .semanticVersion)
        semanticVersion = semanticVersionDecoded
    }
}

extension ApplicationDependencySummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ApplicationDependencySummary(applicationId: \(String(describing: applicationId)), semanticVersion: \(String(describing: semanticVersion)))"}
}

/// <p>A nested application summary.</p>
public struct ApplicationDependencySummary: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the nested application.</p>
    public let applicationId: String?
    /// <p>The semantic version of the nested application.</p>
    public let semanticVersion: String?

    public init (
        applicationId: String? = nil,
        semanticVersion: String? = nil
    )
    {
        self.applicationId = applicationId
        self.semanticVersion = semanticVersion
    }
}

extension ApplicationPolicyStatement: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case actions = "actions"
        case principalOrgIDs = "principalOrgIDs"
        case principals = "principals"
        case statementId = "statementId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actions = actions {
            var actionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .actions)
            for __listof__string0 in actions {
                try actionsContainer.encode(__listof__string0)
            }
        }
        if let principalOrgIDs = principalOrgIDs {
            var principalOrgIDsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .principalOrgIDs)
            for __listof__string0 in principalOrgIDs {
                try principalOrgIDsContainer.encode(__listof__string0)
            }
        }
        if let principals = principals {
            var principalsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .principals)
            for __listof__string0 in principals {
                try principalsContainer.encode(__listof__string0)
            }
        }
        if let statementId = statementId {
            try encodeContainer.encode(statementId, forKey: .statementId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .actions)
        var actionsDecoded0:[String]? = nil
        if let actionsContainer = actionsContainer {
            actionsDecoded0 = [String]()
            for string0 in actionsContainer {
                if let string0 = string0 {
                    actionsDecoded0?.append(string0)
                }
            }
        }
        actions = actionsDecoded0
        let principalOrgIDsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .principalOrgIDs)
        var principalOrgIDsDecoded0:[String]? = nil
        if let principalOrgIDsContainer = principalOrgIDsContainer {
            principalOrgIDsDecoded0 = [String]()
            for string0 in principalOrgIDsContainer {
                if let string0 = string0 {
                    principalOrgIDsDecoded0?.append(string0)
                }
            }
        }
        principalOrgIDs = principalOrgIDsDecoded0
        let principalsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .principals)
        var principalsDecoded0:[String]? = nil
        if let principalsContainer = principalsContainer {
            principalsDecoded0 = [String]()
            for string0 in principalsContainer {
                if let string0 = string0 {
                    principalsDecoded0?.append(string0)
                }
            }
        }
        principals = principalsDecoded0
        let statementIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statementId)
        statementId = statementIdDecoded
    }
}

extension ApplicationPolicyStatement: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ApplicationPolicyStatement(actions: \(String(describing: actions)), principalOrgIDs: \(String(describing: principalOrgIDs)), principals: \(String(describing: principals)), statementId: \(String(describing: statementId)))"}
}

/// <p>Policy statement applied to the application.</p>
public struct ApplicationPolicyStatement: Equatable {
    /// <p>For the list of actions supported for this operation, see <a href="https://docs.aws.amazon.com/serverlessrepo/latest/devguide/access-control-resource-based.html#application-permissions">Application
    ///  Permissions</a>.</p>
    public let actions: [String]?
    /// <p>An array of PrinciplalOrgIDs, which corresponds to AWS IAM <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_condition-keys.html#principal-org-id">aws:PrincipalOrgID</a> global condition key.</p>
    public let principalOrgIDs: [String]?
    /// <p>An array of AWS account IDs, or * to make the application public.</p>
    public let principals: [String]?
    /// <p>A unique ID for the statement.</p>
    public let statementId: String?

    public init (
        actions: [String]? = nil,
        principalOrgIDs: [String]? = nil,
        principals: [String]? = nil,
        statementId: String? = nil
    )
    {
        self.actions = actions
        self.principalOrgIDs = principalOrgIDs
        self.principals = principals
        self.statementId = statementId
    }
}

extension ApplicationSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applicationId = "applicationId"
        case author = "author"
        case creationTime = "creationTime"
        case description = "description"
        case homePageUrl = "homePageUrl"
        case labels = "labels"
        case name = "name"
        case spdxLicenseId = "spdxLicenseId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationId = applicationId {
            try encodeContainer.encode(applicationId, forKey: .applicationId)
        }
        if let author = author {
            try encodeContainer.encode(author, forKey: .author)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime, forKey: .creationTime)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let homePageUrl = homePageUrl {
            try encodeContainer.encode(homePageUrl, forKey: .homePageUrl)
        }
        if let labels = labels {
            var labelsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .labels)
            for __listof__string0 in labels {
                try labelsContainer.encode(__listof__string0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let spdxLicenseId = spdxLicenseId {
            try encodeContainer.encode(spdxLicenseId, forKey: .spdxLicenseId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let authorDecoded = try containerValues.decodeIfPresent(String.self, forKey: .author)
        author = authorDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let homePageUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .homePageUrl)
        homePageUrl = homePageUrlDecoded
        let labelsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .labels)
        var labelsDecoded0:[String]? = nil
        if let labelsContainer = labelsContainer {
            labelsDecoded0 = [String]()
            for string0 in labelsContainer {
                if let string0 = string0 {
                    labelsDecoded0?.append(string0)
                }
            }
        }
        labels = labelsDecoded0
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let spdxLicenseIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .spdxLicenseId)
        spdxLicenseId = spdxLicenseIdDecoded
    }
}

extension ApplicationSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ApplicationSummary(applicationId: \(String(describing: applicationId)), author: \(String(describing: author)), creationTime: \(String(describing: creationTime)), description: \(String(describing: description)), homePageUrl: \(String(describing: homePageUrl)), labels: \(String(describing: labels)), name: \(String(describing: name)), spdxLicenseId: \(String(describing: spdxLicenseId)))"}
}

/// <p>Summary of details about the application.</p>
public struct ApplicationSummary: Equatable {
    /// <p>The application Amazon Resource Name (ARN).</p>
    public let applicationId: String?
    /// <p>The name of the author publishing the app.</p><p>Minimum length=1. Maximum length=127.</p><p>Pattern "^[a-z0-9](([a-z0-9]|-(?!-))*[a-z0-9])?$";</p>
    public let author: String?
    /// <p>The date and time this resource was created.</p>
    public let creationTime: String?
    /// <p>The description of the application.</p><p>Minimum length=1. Maximum length=256</p>
    public let description: String?
    /// <p>A URL with more information about the application, for example the location of your GitHub repository for the application.</p>
    public let homePageUrl: String?
    /// <p>Labels to improve discovery of apps in search results.</p><p>Minimum length=1. Maximum length=127. Maximum number of labels: 10</p><p>Pattern: "^[a-zA-Z0-9+\\-_:\\/@]+$";</p>
    public let labels: [String]?
    /// <p>The name of the application.</p><p>Minimum length=1. Maximum length=140</p><p>Pattern: "[a-zA-Z0-9\\-]+";</p>
    public let name: String?
    /// <p>A valid identifier from <a href="https://spdx.org/licenses/">https://spdx.org/licenses/</a>.</p>
    public let spdxLicenseId: String?

    public init (
        applicationId: String? = nil,
        author: String? = nil,
        creationTime: String? = nil,
        description: String? = nil,
        homePageUrl: String? = nil,
        labels: [String]? = nil,
        name: String? = nil,
        spdxLicenseId: String? = nil
    )
    {
        self.applicationId = applicationId
        self.author = author
        self.creationTime = creationTime
        self.description = description
        self.homePageUrl = homePageUrl
        self.labels = labels
        self.name = name
        self.spdxLicenseId = spdxLicenseId
    }
}

extension BadRequestException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BadRequestException(errorCode: \(String(describing: errorCode)), message: \(String(describing: message)))"}
}

extension BadRequestException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BadRequestExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.errorCode = output.errorCode
            self.message = output.message
        } else {
            self.errorCode = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>One of the parameters in the request is invalid.</p>
public struct BadRequestException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>400</p>
    public var errorCode: String?
    /// <p>One of the parameters in the request is invalid.</p>
    public var message: String?

    public init (
        errorCode: String? = nil,
        message: String? = nil
    )
    {
        self.errorCode = errorCode
        self.message = message
    }
}

struct BadRequestExceptionBody: Equatable {
    public let errorCode: String?
    public let message: String?
}

extension BadRequestExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case errorCode = "errorCode"
        case message = "message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

/// <p>Values that must be specified in order to deploy some applications.</p>
public enum Capability {
    case capabilityAutoExpand
    case capabilityIam
    case capabilityNamedIam
    case capabilityResourcePolicy
    case sdkUnknown(String)
}

extension Capability : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Capability] {
        return [
            .capabilityAutoExpand,
            .capabilityIam,
            .capabilityNamedIam,
            .capabilityResourcePolicy,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .capabilityAutoExpand: return "CAPABILITY_AUTO_EXPAND"
        case .capabilityIam: return "CAPABILITY_IAM"
        case .capabilityNamedIam: return "CAPABILITY_NAMED_IAM"
        case .capabilityResourcePolicy: return "CAPABILITY_RESOURCE_POLICY"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Capability(rawValue: rawValue) ?? Capability.sdkUnknown(rawValue)
    }
}

extension ConflictException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConflictException(errorCode: \(String(describing: errorCode)), message: \(String(describing: message)))"}
}

extension ConflictException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.errorCode = output.errorCode
            self.message = output.message
        } else {
            self.errorCode = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The resource already exists.</p>
public struct ConflictException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>409</p>
    public var errorCode: String?
    /// <p>The resource already exists.</p>
    public var message: String?

    public init (
        errorCode: String? = nil,
        message: String? = nil
    )
    {
        self.errorCode = errorCode
        self.message = message
    }
}

struct ConflictExceptionBody: Equatable {
    public let errorCode: String?
    public let message: String?
}

extension ConflictExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case errorCode = "errorCode"
        case message = "message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct CreateApplicationInputBodyMiddleware: Middleware {
    public let id: String = "CreateApplicationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateApplicationInput>
    public typealias MOutput = OperationOutput<CreateApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateApplicationOutputError>
}

extension CreateApplicationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateApplicationInput(author: \(String(describing: author)), description: \(String(describing: description)), homePageUrl: \(String(describing: homePageUrl)), labels: \(String(describing: labels)), licenseBody: \(String(describing: licenseBody)), licenseUrl: \(String(describing: licenseUrl)), name: \(String(describing: name)), readmeBody: \(String(describing: readmeBody)), readmeUrl: \(String(describing: readmeUrl)), semanticVersion: \(String(describing: semanticVersion)), sourceCodeArchiveUrl: \(String(describing: sourceCodeArchiveUrl)), sourceCodeUrl: \(String(describing: sourceCodeUrl)), spdxLicenseId: \(String(describing: spdxLicenseId)), templateBody: \(String(describing: templateBody)), templateUrl: \(String(describing: templateUrl)))"}
}

extension CreateApplicationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case author = "author"
        case description = "description"
        case homePageUrl = "homePageUrl"
        case labels = "labels"
        case licenseBody = "licenseBody"
        case licenseUrl = "licenseUrl"
        case name = "name"
        case readmeBody = "readmeBody"
        case readmeUrl = "readmeUrl"
        case semanticVersion = "semanticVersion"
        case sourceCodeArchiveUrl = "sourceCodeArchiveUrl"
        case sourceCodeUrl = "sourceCodeUrl"
        case spdxLicenseId = "spdxLicenseId"
        case templateBody = "templateBody"
        case templateUrl = "templateUrl"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let author = author {
            try encodeContainer.encode(author, forKey: .author)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let homePageUrl = homePageUrl {
            try encodeContainer.encode(homePageUrl, forKey: .homePageUrl)
        }
        if let labels = labels {
            var labelsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .labels)
            for __listof__string0 in labels {
                try labelsContainer.encode(__listof__string0)
            }
        }
        if let licenseBody = licenseBody {
            try encodeContainer.encode(licenseBody, forKey: .licenseBody)
        }
        if let licenseUrl = licenseUrl {
            try encodeContainer.encode(licenseUrl, forKey: .licenseUrl)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let readmeBody = readmeBody {
            try encodeContainer.encode(readmeBody, forKey: .readmeBody)
        }
        if let readmeUrl = readmeUrl {
            try encodeContainer.encode(readmeUrl, forKey: .readmeUrl)
        }
        if let semanticVersion = semanticVersion {
            try encodeContainer.encode(semanticVersion, forKey: .semanticVersion)
        }
        if let sourceCodeArchiveUrl = sourceCodeArchiveUrl {
            try encodeContainer.encode(sourceCodeArchiveUrl, forKey: .sourceCodeArchiveUrl)
        }
        if let sourceCodeUrl = sourceCodeUrl {
            try encodeContainer.encode(sourceCodeUrl, forKey: .sourceCodeUrl)
        }
        if let spdxLicenseId = spdxLicenseId {
            try encodeContainer.encode(spdxLicenseId, forKey: .spdxLicenseId)
        }
        if let templateBody = templateBody {
            try encodeContainer.encode(templateBody, forKey: .templateBody)
        }
        if let templateUrl = templateUrl {
            try encodeContainer.encode(templateUrl, forKey: .templateUrl)
        }
    }
}

public struct CreateApplicationInputHeadersMiddleware: Middleware {
    public let id: String = "CreateApplicationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateApplicationInput>
    public typealias MOutput = OperationOutput<CreateApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateApplicationOutputError>
}

public struct CreateApplicationInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateApplicationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateApplicationInput>
    public typealias MOutput = OperationOutput<CreateApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateApplicationOutputError>
}

public struct CreateApplicationInput: Equatable {
    /// <p>The name of the author publishing the app.</p><p>Minimum length=1. Maximum length=127.</p><p>Pattern "^[a-z0-9](([a-z0-9]|-(?!-))*[a-z0-9])?$";</p>
    public let author: String?
    /// <p>The description of the application.</p><p>Minimum length=1. Maximum length=256</p>
    public let description: String?
    /// <p>A URL with more information about the application, for example the location of your GitHub repository for the application.</p>
    public let homePageUrl: String?
    /// <p>Labels to improve discovery of apps in search results.</p><p>Minimum length=1. Maximum length=127. Maximum number of labels: 10</p><p>Pattern: "^[a-zA-Z0-9+\\-_:\\/@]+$";</p>
    public let labels: [String]?
    /// <p>A local text file that contains the license of the app that matches the spdxLicenseID value of your application.
    ///  The file has the format file://&lt;path>/&lt;filename>.</p><p>Maximum size 5 MB</p><p>You can specify only one of licenseBody and licenseUrl; otherwise, an error results.</p>
    public let licenseBody: String?
    /// <p>A link to the S3 object that contains the license of the app that matches the spdxLicenseID value of your application.</p><p>Maximum size 5 MB</p><p>You can specify only one of licenseBody and licenseUrl; otherwise, an error results.</p>
    public let licenseUrl: String?
    /// <p>The name of the application that you want to publish.</p><p>Minimum length=1. Maximum length=140</p><p>Pattern: "[a-zA-Z0-9\\-]+";</p>
    public let name: String?
    /// <p>A local text readme file in Markdown language that contains a more detailed description of the application and how it works.
    ///  The file has the format file://&lt;path>/&lt;filename>.</p><p>Maximum size 5 MB</p><p>You can specify only one of readmeBody and readmeUrl; otherwise, an error results.</p>
    public let readmeBody: String?
    /// <p>A link to the S3 object in Markdown language that contains a more detailed description of the application and how it works.</p><p>Maximum size 5 MB</p><p>You can specify only one of readmeBody and readmeUrl; otherwise, an error results.</p>
    public let readmeUrl: String?
    /// <p>The semantic version of the application:</p><p>
    ///  <a href="https://semver.org/">https://semver.org/</a>
    ///  </p>
    public let semanticVersion: String?
    /// <p>A link to the S3 object that contains the ZIP archive of the source code for this version of your application.</p><p>Maximum size 50 MB</p>
    public let sourceCodeArchiveUrl: String?
    /// <p>A link to a public repository for the source code of your application, for example the URL of a specific GitHub commit.</p>
    public let sourceCodeUrl: String?
    /// <p>A valid identifier from <a href="https://spdx.org/licenses/">https://spdx.org/licenses/</a>.</p>
    public let spdxLicenseId: String?
    /// <p>The local raw packaged AWS SAM template file of your application.
    ///  The file has the format file://&lt;path>/&lt;filename>.</p><p>You can specify only one of templateBody and templateUrl; otherwise an error results.</p>
    public let templateBody: String?
    /// <p>A link to the S3 object containing the packaged AWS SAM template of your application.</p><p>You can specify only one of templateBody and templateUrl; otherwise an error results.</p>
    public let templateUrl: String?

    public init (
        author: String? = nil,
        description: String? = nil,
        homePageUrl: String? = nil,
        labels: [String]? = nil,
        licenseBody: String? = nil,
        licenseUrl: String? = nil,
        name: String? = nil,
        readmeBody: String? = nil,
        readmeUrl: String? = nil,
        semanticVersion: String? = nil,
        sourceCodeArchiveUrl: String? = nil,
        sourceCodeUrl: String? = nil,
        spdxLicenseId: String? = nil,
        templateBody: String? = nil,
        templateUrl: String? = nil
    )
    {
        self.author = author
        self.description = description
        self.homePageUrl = homePageUrl
        self.labels = labels
        self.licenseBody = licenseBody
        self.licenseUrl = licenseUrl
        self.name = name
        self.readmeBody = readmeBody
        self.readmeUrl = readmeUrl
        self.semanticVersion = semanticVersion
        self.sourceCodeArchiveUrl = sourceCodeArchiveUrl
        self.sourceCodeUrl = sourceCodeUrl
        self.spdxLicenseId = spdxLicenseId
        self.templateBody = templateBody
        self.templateUrl = templateUrl
    }
}

struct CreateApplicationInputBody: Equatable {
    public let author: String?
    public let description: String?
    public let homePageUrl: String?
    public let labels: [String]?
    public let licenseBody: String?
    public let licenseUrl: String?
    public let name: String?
    public let readmeBody: String?
    public let readmeUrl: String?
    public let semanticVersion: String?
    public let sourceCodeArchiveUrl: String?
    public let sourceCodeUrl: String?
    public let spdxLicenseId: String?
    public let templateBody: String?
    public let templateUrl: String?
}

extension CreateApplicationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case author = "author"
        case description = "description"
        case homePageUrl = "homePageUrl"
        case labels = "labels"
        case licenseBody = "licenseBody"
        case licenseUrl = "licenseUrl"
        case name = "name"
        case readmeBody = "readmeBody"
        case readmeUrl = "readmeUrl"
        case semanticVersion = "semanticVersion"
        case sourceCodeArchiveUrl = "sourceCodeArchiveUrl"
        case sourceCodeUrl = "sourceCodeUrl"
        case spdxLicenseId = "spdxLicenseId"
        case templateBody = "templateBody"
        case templateUrl = "templateUrl"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authorDecoded = try containerValues.decodeIfPresent(String.self, forKey: .author)
        author = authorDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let homePageUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .homePageUrl)
        homePageUrl = homePageUrlDecoded
        let labelsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .labels)
        var labelsDecoded0:[String]? = nil
        if let labelsContainer = labelsContainer {
            labelsDecoded0 = [String]()
            for string0 in labelsContainer {
                if let string0 = string0 {
                    labelsDecoded0?.append(string0)
                }
            }
        }
        labels = labelsDecoded0
        let licenseBodyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .licenseBody)
        licenseBody = licenseBodyDecoded
        let licenseUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .licenseUrl)
        licenseUrl = licenseUrlDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let readmeBodyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .readmeBody)
        readmeBody = readmeBodyDecoded
        let readmeUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .readmeUrl)
        readmeUrl = readmeUrlDecoded
        let semanticVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .semanticVersion)
        semanticVersion = semanticVersionDecoded
        let sourceCodeArchiveUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceCodeArchiveUrl)
        sourceCodeArchiveUrl = sourceCodeArchiveUrlDecoded
        let sourceCodeUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceCodeUrl)
        sourceCodeUrl = sourceCodeUrlDecoded
        let spdxLicenseIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .spdxLicenseId)
        spdxLicenseId = spdxLicenseIdDecoded
        let templateBodyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateBody)
        templateBody = templateBodyDecoded
        let templateUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateUrl)
        templateUrl = templateUrlDecoded
    }
}

extension CreateApplicationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateApplicationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateApplicationOutputError: Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateApplicationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateApplicationOutputResponse(applicationId: \(String(describing: applicationId)), author: \(String(describing: author)), creationTime: \(String(describing: creationTime)), description: \(String(describing: description)), homePageUrl: \(String(describing: homePageUrl)), isVerifiedAuthor: \(String(describing: isVerifiedAuthor)), labels: \(String(describing: labels)), licenseUrl: \(String(describing: licenseUrl)), name: \(String(describing: name)), readmeUrl: \(String(describing: readmeUrl)), spdxLicenseId: \(String(describing: spdxLicenseId)), verifiedAuthorUrl: \(String(describing: verifiedAuthorUrl)), version: \(String(describing: version)))"}
}

extension CreateApplicationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateApplicationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.applicationId = output.applicationId
            self.author = output.author
            self.creationTime = output.creationTime
            self.description = output.description
            self.homePageUrl = output.homePageUrl
            self.isVerifiedAuthor = output.isVerifiedAuthor
            self.labels = output.labels
            self.licenseUrl = output.licenseUrl
            self.name = output.name
            self.readmeUrl = output.readmeUrl
            self.spdxLicenseId = output.spdxLicenseId
            self.verifiedAuthorUrl = output.verifiedAuthorUrl
            self.version = output.version
        } else {
            self.applicationId = nil
            self.author = nil
            self.creationTime = nil
            self.description = nil
            self.homePageUrl = nil
            self.isVerifiedAuthor = false
            self.labels = nil
            self.licenseUrl = nil
            self.name = nil
            self.readmeUrl = nil
            self.spdxLicenseId = nil
            self.verifiedAuthorUrl = nil
            self.version = nil
        }
    }
}

public struct CreateApplicationOutputResponse: Equatable {
    /// <p>The application Amazon Resource Name (ARN).</p>
    public let applicationId: String?
    /// <p>The name of the author publishing the app.</p><p>Minimum length=1. Maximum length=127.</p><p>Pattern "^[a-z0-9](([a-z0-9]|-(?!-))*[a-z0-9])?$";</p>
    public let author: String?
    /// <p>The date and time this resource was created.</p>
    public let creationTime: String?
    /// <p>The description of the application.</p><p>Minimum length=1. Maximum length=256</p>
    public let description: String?
    /// <p>A URL with more information about the application, for example the location of your GitHub repository for the application.</p>
    public let homePageUrl: String?
    /// <p>Whether the author of this application has been verified. This means means that AWS has made a good faith review, as a reasonable and prudent service provider, of the information provided by the requester and has confirmed that the requester's identity is as claimed.</p>
    public let isVerifiedAuthor: Bool
    /// <p>Labels to improve discovery of apps in search results.</p><p>Minimum length=1. Maximum length=127. Maximum number of labels: 10</p><p>Pattern: "^[a-zA-Z0-9+\\-_:\\/@]+$";</p>
    public let labels: [String]?
    /// <p>A link to a license file of the app that matches the spdxLicenseID value of your application.</p><p>Maximum size 5 MB</p>
    public let licenseUrl: String?
    /// <p>The name of the application.</p><p>Minimum length=1. Maximum length=140</p><p>Pattern: "[a-zA-Z0-9\\-]+";</p>
    public let name: String?
    /// <p>A link to the readme file in Markdown language that contains a more detailed description of the application and how it works.</p><p>Maximum size 5 MB</p>
    public let readmeUrl: String?
    /// <p>A valid identifier from https://spdx.org/licenses/.</p>
    public let spdxLicenseId: String?
    /// <p>The URL to the public profile of a verified author. This URL is submitted by the author.</p>
    public let verifiedAuthorUrl: String?
    /// <p>Version information about the application.</p>
    public let version: Version?

    public init (
        applicationId: String? = nil,
        author: String? = nil,
        creationTime: String? = nil,
        description: String? = nil,
        homePageUrl: String? = nil,
        isVerifiedAuthor: Bool = false,
        labels: [String]? = nil,
        licenseUrl: String? = nil,
        name: String? = nil,
        readmeUrl: String? = nil,
        spdxLicenseId: String? = nil,
        verifiedAuthorUrl: String? = nil,
        version: Version? = nil
    )
    {
        self.applicationId = applicationId
        self.author = author
        self.creationTime = creationTime
        self.description = description
        self.homePageUrl = homePageUrl
        self.isVerifiedAuthor = isVerifiedAuthor
        self.labels = labels
        self.licenseUrl = licenseUrl
        self.name = name
        self.readmeUrl = readmeUrl
        self.spdxLicenseId = spdxLicenseId
        self.verifiedAuthorUrl = verifiedAuthorUrl
        self.version = version
    }
}

struct CreateApplicationOutputResponseBody: Equatable {
    public let applicationId: String?
    public let author: String?
    public let creationTime: String?
    public let description: String?
    public let homePageUrl: String?
    public let isVerifiedAuthor: Bool
    public let labels: [String]?
    public let licenseUrl: String?
    public let name: String?
    public let readmeUrl: String?
    public let spdxLicenseId: String?
    public let verifiedAuthorUrl: String?
    public let version: Version?
}

extension CreateApplicationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case applicationId = "applicationId"
        case author = "author"
        case creationTime = "creationTime"
        case description = "description"
        case homePageUrl = "homePageUrl"
        case isVerifiedAuthor = "isVerifiedAuthor"
        case labels = "labels"
        case licenseUrl = "licenseUrl"
        case name = "name"
        case readmeUrl = "readmeUrl"
        case spdxLicenseId = "spdxLicenseId"
        case verifiedAuthorUrl = "verifiedAuthorUrl"
        case version = "version"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let authorDecoded = try containerValues.decodeIfPresent(String.self, forKey: .author)
        author = authorDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let homePageUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .homePageUrl)
        homePageUrl = homePageUrlDecoded
        let isVerifiedAuthorDecoded = try containerValues.decode(Bool.self, forKey: .isVerifiedAuthor)
        isVerifiedAuthor = isVerifiedAuthorDecoded
        let labelsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .labels)
        var labelsDecoded0:[String]? = nil
        if let labelsContainer = labelsContainer {
            labelsDecoded0 = [String]()
            for string0 in labelsContainer {
                if let string0 = string0 {
                    labelsDecoded0?.append(string0)
                }
            }
        }
        labels = labelsDecoded0
        let licenseUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .licenseUrl)
        licenseUrl = licenseUrlDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let readmeUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .readmeUrl)
        readmeUrl = readmeUrlDecoded
        let spdxLicenseIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .spdxLicenseId)
        spdxLicenseId = spdxLicenseIdDecoded
        let verifiedAuthorUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .verifiedAuthorUrl)
        verifiedAuthorUrl = verifiedAuthorUrlDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Version.self, forKey: .version)
        version = versionDecoded
    }
}

public struct CreateApplicationVersionInputBodyMiddleware: Middleware {
    public let id: String = "CreateApplicationVersionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateApplicationVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateApplicationVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateApplicationVersionInput>
    public typealias MOutput = OperationOutput<CreateApplicationVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateApplicationVersionOutputError>
}

extension CreateApplicationVersionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateApplicationVersionInput(applicationId: \(String(describing: applicationId)), semanticVersion: \(String(describing: semanticVersion)), sourceCodeArchiveUrl: \(String(describing: sourceCodeArchiveUrl)), sourceCodeUrl: \(String(describing: sourceCodeUrl)), templateBody: \(String(describing: templateBody)), templateUrl: \(String(describing: templateUrl)))"}
}

extension CreateApplicationVersionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case sourceCodeArchiveUrl = "sourceCodeArchiveUrl"
        case sourceCodeUrl = "sourceCodeUrl"
        case templateBody = "templateBody"
        case templateUrl = "templateUrl"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sourceCodeArchiveUrl = sourceCodeArchiveUrl {
            try encodeContainer.encode(sourceCodeArchiveUrl, forKey: .sourceCodeArchiveUrl)
        }
        if let sourceCodeUrl = sourceCodeUrl {
            try encodeContainer.encode(sourceCodeUrl, forKey: .sourceCodeUrl)
        }
        if let templateBody = templateBody {
            try encodeContainer.encode(templateBody, forKey: .templateBody)
        }
        if let templateUrl = templateUrl {
            try encodeContainer.encode(templateUrl, forKey: .templateUrl)
        }
    }
}

public struct CreateApplicationVersionInputHeadersMiddleware: Middleware {
    public let id: String = "CreateApplicationVersionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateApplicationVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateApplicationVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateApplicationVersionInput>
    public typealias MOutput = OperationOutput<CreateApplicationVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateApplicationVersionOutputError>
}

public struct CreateApplicationVersionInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateApplicationVersionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateApplicationVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateApplicationVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateApplicationVersionInput>
    public typealias MOutput = OperationOutput<CreateApplicationVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateApplicationVersionOutputError>
}

public struct CreateApplicationVersionInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the application.</p>
    public let applicationId: String?
    /// <p>The semantic version of the new version.</p>
    public let semanticVersion: String?
    /// <p>A link to the S3 object that contains the ZIP archive of the source code for this version of your application.</p><p>Maximum size 50 MB</p>
    public let sourceCodeArchiveUrl: String?
    /// <p>A link to a public repository for the source code of your application, for example the URL of a specific GitHub commit.</p>
    public let sourceCodeUrl: String?
    /// <p>The raw packaged AWS SAM template of your application.</p>
    public let templateBody: String?
    /// <p>A link to the packaged AWS SAM template of your application.</p>
    public let templateUrl: String?

    public init (
        applicationId: String? = nil,
        semanticVersion: String? = nil,
        sourceCodeArchiveUrl: String? = nil,
        sourceCodeUrl: String? = nil,
        templateBody: String? = nil,
        templateUrl: String? = nil
    )
    {
        self.applicationId = applicationId
        self.semanticVersion = semanticVersion
        self.sourceCodeArchiveUrl = sourceCodeArchiveUrl
        self.sourceCodeUrl = sourceCodeUrl
        self.templateBody = templateBody
        self.templateUrl = templateUrl
    }
}

struct CreateApplicationVersionInputBody: Equatable {
    public let sourceCodeArchiveUrl: String?
    public let sourceCodeUrl: String?
    public let templateBody: String?
    public let templateUrl: String?
}

extension CreateApplicationVersionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case sourceCodeArchiveUrl = "sourceCodeArchiveUrl"
        case sourceCodeUrl = "sourceCodeUrl"
        case templateBody = "templateBody"
        case templateUrl = "templateUrl"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceCodeArchiveUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceCodeArchiveUrl)
        sourceCodeArchiveUrl = sourceCodeArchiveUrlDecoded
        let sourceCodeUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceCodeUrl)
        sourceCodeUrl = sourceCodeUrlDecoded
        let templateBodyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateBody)
        templateBody = templateBodyDecoded
        let templateUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateUrl)
        templateUrl = templateUrlDecoded
    }
}

extension CreateApplicationVersionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateApplicationVersionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateApplicationVersionOutputError: Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateApplicationVersionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateApplicationVersionOutputResponse(applicationId: \(String(describing: applicationId)), creationTime: \(String(describing: creationTime)), parameterDefinitions: \(String(describing: parameterDefinitions)), requiredCapabilities: \(String(describing: requiredCapabilities)), resourcesSupported: \(String(describing: resourcesSupported)), semanticVersion: \(String(describing: semanticVersion)), sourceCodeArchiveUrl: \(String(describing: sourceCodeArchiveUrl)), sourceCodeUrl: \(String(describing: sourceCodeUrl)), templateUrl: \(String(describing: templateUrl)))"}
}

extension CreateApplicationVersionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateApplicationVersionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.applicationId = output.applicationId
            self.creationTime = output.creationTime
            self.parameterDefinitions = output.parameterDefinitions
            self.requiredCapabilities = output.requiredCapabilities
            self.resourcesSupported = output.resourcesSupported
            self.semanticVersion = output.semanticVersion
            self.sourceCodeArchiveUrl = output.sourceCodeArchiveUrl
            self.sourceCodeUrl = output.sourceCodeUrl
            self.templateUrl = output.templateUrl
        } else {
            self.applicationId = nil
            self.creationTime = nil
            self.parameterDefinitions = nil
            self.requiredCapabilities = nil
            self.resourcesSupported = false
            self.semanticVersion = nil
            self.sourceCodeArchiveUrl = nil
            self.sourceCodeUrl = nil
            self.templateUrl = nil
        }
    }
}

public struct CreateApplicationVersionOutputResponse: Equatable {
    /// <p>The application Amazon Resource Name (ARN).</p>
    public let applicationId: String?
    /// <p>The date and time this resource was created.</p>
    public let creationTime: String?
    /// <p>An array of parameter types supported by the application.</p>
    public let parameterDefinitions: [ParameterDefinition]?
    /// <p>A list of values that you must specify before you can deploy certain applications.
    ///  Some applications might include resources that can affect permissions in your AWS
    ///  account, for example, by creating new AWS Identity and Access Management (IAM) users.
    ///  For those applications, you must explicitly acknowledge their capabilities by
    ///  specifying this parameter.</p><p>The only valid values are CAPABILITY_IAM, CAPABILITY_NAMED_IAM,
    ///  CAPABILITY_RESOURCE_POLICY, and CAPABILITY_AUTO_EXPAND.</p><p>The following resources require you to specify CAPABILITY_IAM or
    ///  CAPABILITY_NAMED_IAM:
    ///  <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iam-group.html">AWS::IAM::Group</a>,
    ///  <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-instanceprofile.html">AWS::IAM::InstanceProfile</a>,
    ///  <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-policy.html">AWS::IAM::Policy</a>, and
    ///  <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-role.html">AWS::IAM::Role</a>.
    ///  If the application contains IAM resources, you can specify either CAPABILITY_IAM
    ///  or CAPABILITY_NAMED_IAM. If the application contains IAM resources
    ///  with custom names, you must specify CAPABILITY_NAMED_IAM.</p><p>The following resources require you to specify CAPABILITY_RESOURCE_POLICY:
    ///  <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-lambda-permission.html">AWS::Lambda::Permission</a>,
    ///  <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-policy.html">AWS::IAM:Policy</a>,
    ///  <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-applicationautoscaling-scalingpolicy.html">AWS::ApplicationAutoScaling::ScalingPolicy</a>,
    ///  <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-policy.html">AWS::S3::BucketPolicy</a>,
    ///  <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sqs-policy.html">AWS::SQS::QueuePolicy</a>, and
    ///  <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sns-policy.html">AWS::SNS::TopicPolicy</a>.</p><p>Applications that contain one or more nested applications require you to specify
    ///  CAPABILITY_AUTO_EXPAND.</p><p>If your application template contains any of the above resources, we recommend that you review
    ///  all permissions associated with the application before deploying. If you don't specify
    ///  this parameter for an application that requires capabilities, the call will fail.</p>
    public let requiredCapabilities: [Capability]?
    /// <p>Whether all of the AWS resources contained in this application are supported in the region
    ///  in which it is being retrieved.</p>
    public let resourcesSupported: Bool
    /// <p>The semantic version of the application:</p><p>
    ///  <a href="https://semver.org/">https://semver.org/</a>
    ///  </p>
    public let semanticVersion: String?
    /// <p>A link to the S3 object that contains the ZIP archive of the source code for this version of your application.</p><p>Maximum size 50 MB</p>
    public let sourceCodeArchiveUrl: String?
    /// <p>A link to a public repository for the source code of your application, for example the URL of a specific GitHub commit.</p>
    public let sourceCodeUrl: String?
    /// <p>A link to the packaged AWS SAM template of your application.</p>
    public let templateUrl: String?

    public init (
        applicationId: String? = nil,
        creationTime: String? = nil,
        parameterDefinitions: [ParameterDefinition]? = nil,
        requiredCapabilities: [Capability]? = nil,
        resourcesSupported: Bool = false,
        semanticVersion: String? = nil,
        sourceCodeArchiveUrl: String? = nil,
        sourceCodeUrl: String? = nil,
        templateUrl: String? = nil
    )
    {
        self.applicationId = applicationId
        self.creationTime = creationTime
        self.parameterDefinitions = parameterDefinitions
        self.requiredCapabilities = requiredCapabilities
        self.resourcesSupported = resourcesSupported
        self.semanticVersion = semanticVersion
        self.sourceCodeArchiveUrl = sourceCodeArchiveUrl
        self.sourceCodeUrl = sourceCodeUrl
        self.templateUrl = templateUrl
    }
}

struct CreateApplicationVersionOutputResponseBody: Equatable {
    public let applicationId: String?
    public let creationTime: String?
    public let parameterDefinitions: [ParameterDefinition]?
    public let requiredCapabilities: [Capability]?
    public let resourcesSupported: Bool
    public let semanticVersion: String?
    public let sourceCodeArchiveUrl: String?
    public let sourceCodeUrl: String?
    public let templateUrl: String?
}

extension CreateApplicationVersionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case applicationId = "applicationId"
        case creationTime = "creationTime"
        case parameterDefinitions = "parameterDefinitions"
        case requiredCapabilities = "requiredCapabilities"
        case resourcesSupported = "resourcesSupported"
        case semanticVersion = "semanticVersion"
        case sourceCodeArchiveUrl = "sourceCodeArchiveUrl"
        case sourceCodeUrl = "sourceCodeUrl"
        case templateUrl = "templateUrl"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let parameterDefinitionsContainer = try containerValues.decodeIfPresent([ParameterDefinition?].self, forKey: .parameterDefinitions)
        var parameterDefinitionsDecoded0:[ParameterDefinition]? = nil
        if let parameterDefinitionsContainer = parameterDefinitionsContainer {
            parameterDefinitionsDecoded0 = [ParameterDefinition]()
            for structure0 in parameterDefinitionsContainer {
                if let structure0 = structure0 {
                    parameterDefinitionsDecoded0?.append(structure0)
                }
            }
        }
        parameterDefinitions = parameterDefinitionsDecoded0
        let requiredCapabilitiesContainer = try containerValues.decodeIfPresent([Capability?].self, forKey: .requiredCapabilities)
        var requiredCapabilitiesDecoded0:[Capability]? = nil
        if let requiredCapabilitiesContainer = requiredCapabilitiesContainer {
            requiredCapabilitiesDecoded0 = [Capability]()
            for string0 in requiredCapabilitiesContainer {
                if let string0 = string0 {
                    requiredCapabilitiesDecoded0?.append(string0)
                }
            }
        }
        requiredCapabilities = requiredCapabilitiesDecoded0
        let resourcesSupportedDecoded = try containerValues.decode(Bool.self, forKey: .resourcesSupported)
        resourcesSupported = resourcesSupportedDecoded
        let semanticVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .semanticVersion)
        semanticVersion = semanticVersionDecoded
        let sourceCodeArchiveUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceCodeArchiveUrl)
        sourceCodeArchiveUrl = sourceCodeArchiveUrlDecoded
        let sourceCodeUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceCodeUrl)
        sourceCodeUrl = sourceCodeUrlDecoded
        let templateUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateUrl)
        templateUrl = templateUrlDecoded
    }
}

public struct CreateCloudFormationChangeSetInputBodyMiddleware: Middleware {
    public let id: String = "CreateCloudFormationChangeSetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateCloudFormationChangeSetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateCloudFormationChangeSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateCloudFormationChangeSetInput>
    public typealias MOutput = OperationOutput<CreateCloudFormationChangeSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateCloudFormationChangeSetOutputError>
}

extension CreateCloudFormationChangeSetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateCloudFormationChangeSetInput(applicationId: \(String(describing: applicationId)), capabilities: \(String(describing: capabilities)), changeSetName: \(String(describing: changeSetName)), clientToken: \(String(describing: clientToken)), description: \(String(describing: description)), notificationArns: \(String(describing: notificationArns)), parameterOverrides: \(String(describing: parameterOverrides)), resourceTypes: \(String(describing: resourceTypes)), rollbackConfiguration: \(String(describing: rollbackConfiguration)), semanticVersion: \(String(describing: semanticVersion)), stackName: \(String(describing: stackName)), tags: \(String(describing: tags)), templateId: \(String(describing: templateId)))"}
}

extension CreateCloudFormationChangeSetInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case capabilities = "capabilities"
        case changeSetName = "changeSetName"
        case clientToken = "clientToken"
        case description = "description"
        case notificationArns = "notificationArns"
        case parameterOverrides = "parameterOverrides"
        case resourceTypes = "resourceTypes"
        case rollbackConfiguration = "rollbackConfiguration"
        case semanticVersion = "semanticVersion"
        case stackName = "stackName"
        case tags = "tags"
        case templateId = "templateId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let capabilities = capabilities {
            var capabilitiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .capabilities)
            for __listof__string0 in capabilities {
                try capabilitiesContainer.encode(__listof__string0)
            }
        }
        if let changeSetName = changeSetName {
            try encodeContainer.encode(changeSetName, forKey: .changeSetName)
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let notificationArns = notificationArns {
            var notificationArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notificationArns)
            for __listof__string0 in notificationArns {
                try notificationArnsContainer.encode(__listof__string0)
            }
        }
        if let parameterOverrides = parameterOverrides {
            var parameterOverridesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .parameterOverrides)
            for __listofparametervalue0 in parameterOverrides {
                try parameterOverridesContainer.encode(__listofparametervalue0)
            }
        }
        if let resourceTypes = resourceTypes {
            var resourceTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceTypes)
            for __listof__string0 in resourceTypes {
                try resourceTypesContainer.encode(__listof__string0)
            }
        }
        if let rollbackConfiguration = rollbackConfiguration {
            try encodeContainer.encode(rollbackConfiguration, forKey: .rollbackConfiguration)
        }
        if let semanticVersion = semanticVersion {
            try encodeContainer.encode(semanticVersion, forKey: .semanticVersion)
        }
        if let stackName = stackName {
            try encodeContainer.encode(stackName, forKey: .stackName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for __listoftag0 in tags {
                try tagsContainer.encode(__listoftag0)
            }
        }
        if let templateId = templateId {
            try encodeContainer.encode(templateId, forKey: .templateId)
        }
    }
}

public struct CreateCloudFormationChangeSetInputHeadersMiddleware: Middleware {
    public let id: String = "CreateCloudFormationChangeSetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateCloudFormationChangeSetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateCloudFormationChangeSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateCloudFormationChangeSetInput>
    public typealias MOutput = OperationOutput<CreateCloudFormationChangeSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateCloudFormationChangeSetOutputError>
}

public struct CreateCloudFormationChangeSetInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateCloudFormationChangeSetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateCloudFormationChangeSetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateCloudFormationChangeSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateCloudFormationChangeSetInput>
    public typealias MOutput = OperationOutput<CreateCloudFormationChangeSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateCloudFormationChangeSetOutputError>
}

public struct CreateCloudFormationChangeSetInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the application.</p>
    public let applicationId: String?
    /// <p>A list of values that you must specify before you can deploy certain applications.
    ///  Some applications might include resources that can affect permissions in your AWS
    ///  account, for example, by creating new AWS Identity and Access Management (IAM) users.
    ///  For those applications, you must explicitly acknowledge their capabilities by
    ///  specifying this parameter.</p><p>The only valid values are CAPABILITY_IAM, CAPABILITY_NAMED_IAM,
    ///  CAPABILITY_RESOURCE_POLICY, and CAPABILITY_AUTO_EXPAND.</p><p>The following resources require you to specify CAPABILITY_IAM or
    ///  CAPABILITY_NAMED_IAM:
    ///  <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iam-group.html">AWS::IAM::Group</a>,
    ///  <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-instanceprofile.html">AWS::IAM::InstanceProfile</a>,
    ///  <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-policy.html">AWS::IAM::Policy</a>, and
    ///  <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-role.html">AWS::IAM::Role</a>.
    ///  If the application contains IAM resources, you can specify either CAPABILITY_IAM
    ///  or CAPABILITY_NAMED_IAM. If the application contains IAM resources
    ///  with custom names, you must specify CAPABILITY_NAMED_IAM.</p><p>The following resources require you to specify CAPABILITY_RESOURCE_POLICY:
    ///  <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-lambda-permission.html">AWS::Lambda::Permission</a>,
    ///  <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-policy.html">AWS::IAM:Policy</a>,
    ///  <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-applicationautoscaling-scalingpolicy.html">AWS::ApplicationAutoScaling::ScalingPolicy</a>,
    ///  <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-policy.html">AWS::S3::BucketPolicy</a>,
    ///  <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sqs-policy.html">AWS::SQS::QueuePolicy</a>, and
    ///  <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sns-policy.html">AWS::SNS:TopicPolicy</a>.</p><p>Applications that contain one or more nested applications require you to specify
    ///  CAPABILITY_AUTO_EXPAND.</p><p>If your application template contains any of the above resources, we recommend that you review
    ///  all permissions associated with the application before deploying. If you don't specify
    ///  this parameter for an application that requires capabilities, the call will fail.</p>
    public let capabilities: [String]?
    /// <p>This property corresponds to the parameter of the same name for the <i>AWS CloudFormation <a href="https://docs.aws.amazon.com/goto/WebAPI/cloudformation-2010-05-15/CreateChangeSet">CreateChangeSet</a>
    ///  </i> API.</p>
    public let changeSetName: String?
    /// <p>This property corresponds to the parameter of the same name for the <i>AWS CloudFormation <a href="https://docs.aws.amazon.com/goto/WebAPI/cloudformation-2010-05-15/CreateChangeSet">CreateChangeSet</a>
    ///  </i> API.</p>
    public let clientToken: String?
    /// <p>This property corresponds to the parameter of the same name for the <i>AWS CloudFormation <a href="https://docs.aws.amazon.com/goto/WebAPI/cloudformation-2010-05-15/CreateChangeSet">CreateChangeSet</a>
    ///  </i> API.</p>
    public let description: String?
    /// <p>This property corresponds to the parameter of the same name for the <i>AWS CloudFormation <a href="https://docs.aws.amazon.com/goto/WebAPI/cloudformation-2010-05-15/CreateChangeSet">CreateChangeSet</a>
    ///  </i> API.</p>
    public let notificationArns: [String]?
    /// <p>A list of parameter values for the parameters of the application.</p>
    public let parameterOverrides: [ParameterValue]?
    /// <p>This property corresponds to the parameter of the same name for the <i>AWS CloudFormation <a href="https://docs.aws.amazon.com/goto/WebAPI/cloudformation-2010-05-15/CreateChangeSet">CreateChangeSet</a>
    ///  </i> API.</p>
    public let resourceTypes: [String]?
    /// <p>This property corresponds to the parameter of the same name for the <i>AWS CloudFormation <a href="https://docs.aws.amazon.com/goto/WebAPI/cloudformation-2010-05-15/CreateChangeSet">CreateChangeSet</a>
    ///  </i> API.</p>
    public let rollbackConfiguration: RollbackConfiguration?
    /// <p>The semantic version of the application:</p><p>
    ///  <a href="https://semver.org/">https://semver.org/</a>
    ///  </p>
    public let semanticVersion: String?
    /// <p>This property corresponds to the parameter of the same name for the <i>AWS CloudFormation <a href="https://docs.aws.amazon.com/goto/WebAPI/cloudformation-2010-05-15/CreateChangeSet">CreateChangeSet</a>
    ///  </i> API.</p>
    public let stackName: String?
    /// <p>This property corresponds to the parameter of the same name for the <i>AWS CloudFormation <a href="https://docs.aws.amazon.com/goto/WebAPI/cloudformation-2010-05-15/CreateChangeSet">CreateChangeSet</a>
    ///  </i> API.</p>
    public let tags: [Tag]?
    /// <p>The UUID returned by CreateCloudFormationTemplate.</p><p>Pattern: [0-9a-fA-F]{8}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{12}</p>
    public let templateId: String?

    public init (
        applicationId: String? = nil,
        capabilities: [String]? = nil,
        changeSetName: String? = nil,
        clientToken: String? = nil,
        description: String? = nil,
        notificationArns: [String]? = nil,
        parameterOverrides: [ParameterValue]? = nil,
        resourceTypes: [String]? = nil,
        rollbackConfiguration: RollbackConfiguration? = nil,
        semanticVersion: String? = nil,
        stackName: String? = nil,
        tags: [Tag]? = nil,
        templateId: String? = nil
    )
    {
        self.applicationId = applicationId
        self.capabilities = capabilities
        self.changeSetName = changeSetName
        self.clientToken = clientToken
        self.description = description
        self.notificationArns = notificationArns
        self.parameterOverrides = parameterOverrides
        self.resourceTypes = resourceTypes
        self.rollbackConfiguration = rollbackConfiguration
        self.semanticVersion = semanticVersion
        self.stackName = stackName
        self.tags = tags
        self.templateId = templateId
    }
}

struct CreateCloudFormationChangeSetInputBody: Equatable {
    public let capabilities: [String]?
    public let changeSetName: String?
    public let clientToken: String?
    public let description: String?
    public let notificationArns: [String]?
    public let parameterOverrides: [ParameterValue]?
    public let resourceTypes: [String]?
    public let rollbackConfiguration: RollbackConfiguration?
    public let semanticVersion: String?
    public let stackName: String?
    public let tags: [Tag]?
    public let templateId: String?
}

extension CreateCloudFormationChangeSetInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case capabilities = "capabilities"
        case changeSetName = "changeSetName"
        case clientToken = "clientToken"
        case description = "description"
        case notificationArns = "notificationArns"
        case parameterOverrides = "parameterOverrides"
        case resourceTypes = "resourceTypes"
        case rollbackConfiguration = "rollbackConfiguration"
        case semanticVersion = "semanticVersion"
        case stackName = "stackName"
        case tags = "tags"
        case templateId = "templateId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let capabilitiesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .capabilities)
        var capabilitiesDecoded0:[String]? = nil
        if let capabilitiesContainer = capabilitiesContainer {
            capabilitiesDecoded0 = [String]()
            for string0 in capabilitiesContainer {
                if let string0 = string0 {
                    capabilitiesDecoded0?.append(string0)
                }
            }
        }
        capabilities = capabilitiesDecoded0
        let changeSetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .changeSetName)
        changeSetName = changeSetNameDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let notificationArnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .notificationArns)
        var notificationArnsDecoded0:[String]? = nil
        if let notificationArnsContainer = notificationArnsContainer {
            notificationArnsDecoded0 = [String]()
            for string0 in notificationArnsContainer {
                if let string0 = string0 {
                    notificationArnsDecoded0?.append(string0)
                }
            }
        }
        notificationArns = notificationArnsDecoded0
        let parameterOverridesContainer = try containerValues.decodeIfPresent([ParameterValue?].self, forKey: .parameterOverrides)
        var parameterOverridesDecoded0:[ParameterValue]? = nil
        if let parameterOverridesContainer = parameterOverridesContainer {
            parameterOverridesDecoded0 = [ParameterValue]()
            for structure0 in parameterOverridesContainer {
                if let structure0 = structure0 {
                    parameterOverridesDecoded0?.append(structure0)
                }
            }
        }
        parameterOverrides = parameterOverridesDecoded0
        let resourceTypesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .resourceTypes)
        var resourceTypesDecoded0:[String]? = nil
        if let resourceTypesContainer = resourceTypesContainer {
            resourceTypesDecoded0 = [String]()
            for string0 in resourceTypesContainer {
                if let string0 = string0 {
                    resourceTypesDecoded0?.append(string0)
                }
            }
        }
        resourceTypes = resourceTypesDecoded0
        let rollbackConfigurationDecoded = try containerValues.decodeIfPresent(RollbackConfiguration.self, forKey: .rollbackConfiguration)
        rollbackConfiguration = rollbackConfigurationDecoded
        let semanticVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .semanticVersion)
        semanticVersion = semanticVersionDecoded
        let stackNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stackName)
        stackName = stackNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let templateIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateId)
        templateId = templateIdDecoded
    }
}

extension CreateCloudFormationChangeSetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateCloudFormationChangeSetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateCloudFormationChangeSetOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateCloudFormationChangeSetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateCloudFormationChangeSetOutputResponse(applicationId: \(String(describing: applicationId)), changeSetId: \(String(describing: changeSetId)), semanticVersion: \(String(describing: semanticVersion)), stackId: \(String(describing: stackId)))"}
}

extension CreateCloudFormationChangeSetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateCloudFormationChangeSetOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.applicationId = output.applicationId
            self.changeSetId = output.changeSetId
            self.semanticVersion = output.semanticVersion
            self.stackId = output.stackId
        } else {
            self.applicationId = nil
            self.changeSetId = nil
            self.semanticVersion = nil
            self.stackId = nil
        }
    }
}

public struct CreateCloudFormationChangeSetOutputResponse: Equatable {
    /// <p>The application Amazon Resource Name (ARN).</p>
    public let applicationId: String?
    /// <p>The Amazon Resource Name (ARN) of the change set.</p><p>Length constraints: Minimum length of 1.</p><p>Pattern: ARN:[-a-zA-Z0-9:/]*</p>
    public let changeSetId: String?
    /// <p>The semantic version of the application:</p><p>
    ///  <a href="https://semver.org/">https://semver.org/</a>
    ///  </p>
    public let semanticVersion: String?
    /// <p>The unique ID of the stack.</p>
    public let stackId: String?

    public init (
        applicationId: String? = nil,
        changeSetId: String? = nil,
        semanticVersion: String? = nil,
        stackId: String? = nil
    )
    {
        self.applicationId = applicationId
        self.changeSetId = changeSetId
        self.semanticVersion = semanticVersion
        self.stackId = stackId
    }
}

struct CreateCloudFormationChangeSetOutputResponseBody: Equatable {
    public let applicationId: String?
    public let changeSetId: String?
    public let semanticVersion: String?
    public let stackId: String?
}

extension CreateCloudFormationChangeSetOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case applicationId = "applicationId"
        case changeSetId = "changeSetId"
        case semanticVersion = "semanticVersion"
        case stackId = "stackId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let changeSetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .changeSetId)
        changeSetId = changeSetIdDecoded
        let semanticVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .semanticVersion)
        semanticVersion = semanticVersionDecoded
        let stackIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stackId)
        stackId = stackIdDecoded
    }
}

public struct CreateCloudFormationTemplateInputBodyMiddleware: Middleware {
    public let id: String = "CreateCloudFormationTemplateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateCloudFormationTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateCloudFormationTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateCloudFormationTemplateInput>
    public typealias MOutput = OperationOutput<CreateCloudFormationTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateCloudFormationTemplateOutputError>
}

extension CreateCloudFormationTemplateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateCloudFormationTemplateInput(applicationId: \(String(describing: applicationId)), semanticVersion: \(String(describing: semanticVersion)))"}
}

extension CreateCloudFormationTemplateInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case semanticVersion = "semanticVersion"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let semanticVersion = semanticVersion {
            try encodeContainer.encode(semanticVersion, forKey: .semanticVersion)
        }
    }
}

public struct CreateCloudFormationTemplateInputHeadersMiddleware: Middleware {
    public let id: String = "CreateCloudFormationTemplateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateCloudFormationTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateCloudFormationTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateCloudFormationTemplateInput>
    public typealias MOutput = OperationOutput<CreateCloudFormationTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateCloudFormationTemplateOutputError>
}

public struct CreateCloudFormationTemplateInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateCloudFormationTemplateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateCloudFormationTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateCloudFormationTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateCloudFormationTemplateInput>
    public typealias MOutput = OperationOutput<CreateCloudFormationTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateCloudFormationTemplateOutputError>
}

public struct CreateCloudFormationTemplateInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the application.</p>
    public let applicationId: String?
    /// <p>The semantic version of the application:</p><p>
    ///  <a href="https://semver.org/">https://semver.org/</a>
    ///  </p>
    public let semanticVersion: String?

    public init (
        applicationId: String? = nil,
        semanticVersion: String? = nil
    )
    {
        self.applicationId = applicationId
        self.semanticVersion = semanticVersion
    }
}

struct CreateCloudFormationTemplateInputBody: Equatable {
    public let semanticVersion: String?
}

extension CreateCloudFormationTemplateInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case semanticVersion = "semanticVersion"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let semanticVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .semanticVersion)
        semanticVersion = semanticVersionDecoded
    }
}

extension CreateCloudFormationTemplateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateCloudFormationTemplateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateCloudFormationTemplateOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateCloudFormationTemplateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateCloudFormationTemplateOutputResponse(applicationId: \(String(describing: applicationId)), creationTime: \(String(describing: creationTime)), expirationTime: \(String(describing: expirationTime)), semanticVersion: \(String(describing: semanticVersion)), status: \(String(describing: status)), templateId: \(String(describing: templateId)), templateUrl: \(String(describing: templateUrl)))"}
}

extension CreateCloudFormationTemplateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateCloudFormationTemplateOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.applicationId = output.applicationId
            self.creationTime = output.creationTime
            self.expirationTime = output.expirationTime
            self.semanticVersion = output.semanticVersion
            self.status = output.status
            self.templateId = output.templateId
            self.templateUrl = output.templateUrl
        } else {
            self.applicationId = nil
            self.creationTime = nil
            self.expirationTime = nil
            self.semanticVersion = nil
            self.status = nil
            self.templateId = nil
            self.templateUrl = nil
        }
    }
}

public struct CreateCloudFormationTemplateOutputResponse: Equatable {
    /// <p>The application Amazon Resource Name (ARN).</p>
    public let applicationId: String?
    /// <p>The date and time this resource was created.</p>
    public let creationTime: String?
    /// <p>The date and time this template expires. Templates
    ///  expire 1 hour after creation.</p>
    public let expirationTime: String?
    /// <p>The semantic version of the application:</p><p>
    ///  <a href="https://semver.org/">https://semver.org/</a>
    ///  </p>
    public let semanticVersion: String?
    /// <p>Status of the template creation workflow.</p><p>Possible values: PREPARING | ACTIVE | EXPIRED
    ///  </p>
    public let status: Status?
    /// <p>The UUID returned by CreateCloudFormationTemplate.</p><p>Pattern: [0-9a-fA-F]{8}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{12}</p>
    public let templateId: String?
    /// <p>A link to the template that can be used to deploy the application using
    ///  AWS CloudFormation.</p>
    public let templateUrl: String?

    public init (
        applicationId: String? = nil,
        creationTime: String? = nil,
        expirationTime: String? = nil,
        semanticVersion: String? = nil,
        status: Status? = nil,
        templateId: String? = nil,
        templateUrl: String? = nil
    )
    {
        self.applicationId = applicationId
        self.creationTime = creationTime
        self.expirationTime = expirationTime
        self.semanticVersion = semanticVersion
        self.status = status
        self.templateId = templateId
        self.templateUrl = templateUrl
    }
}

struct CreateCloudFormationTemplateOutputResponseBody: Equatable {
    public let applicationId: String?
    public let creationTime: String?
    public let expirationTime: String?
    public let semanticVersion: String?
    public let status: Status?
    public let templateId: String?
    public let templateUrl: String?
}

extension CreateCloudFormationTemplateOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case applicationId = "applicationId"
        case creationTime = "creationTime"
        case expirationTime = "expirationTime"
        case semanticVersion = "semanticVersion"
        case status = "status"
        case templateId = "templateId"
        case templateUrl = "templateUrl"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let expirationTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .expirationTime)
        expirationTime = expirationTimeDecoded
        let semanticVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .semanticVersion)
        semanticVersion = semanticVersionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Status.self, forKey: .status)
        status = statusDecoded
        let templateIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateId)
        templateId = templateIdDecoded
        let templateUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateUrl)
        templateUrl = templateUrlDecoded
    }
}

extension DeleteApplicationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteApplicationInput(applicationId: \(String(describing: applicationId)))"}
}

extension DeleteApplicationInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteApplicationInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteApplicationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteApplicationInput>
    public typealias MOutput = OperationOutput<DeleteApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteApplicationOutputError>
}

public struct DeleteApplicationInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteApplicationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteApplicationInput>
    public typealias MOutput = OperationOutput<DeleteApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteApplicationOutputError>
}

public struct DeleteApplicationInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the application.</p>
    public let applicationId: String?

    public init (
        applicationId: String? = nil
    )
    {
        self.applicationId = applicationId
    }
}

struct DeleteApplicationInputBody: Equatable {
}

extension DeleteApplicationInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteApplicationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteApplicationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteApplicationOutputError: Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteApplicationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteApplicationOutputResponse()"}
}

extension DeleteApplicationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteApplicationOutputResponse: Equatable {

    public init() {}
}

struct DeleteApplicationOutputResponseBody: Equatable {
}

extension DeleteApplicationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ForbiddenException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ForbiddenException(errorCode: \(String(describing: errorCode)), message: \(String(describing: message)))"}
}

extension ForbiddenException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ForbiddenExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.errorCode = output.errorCode
            self.message = output.message
        } else {
            self.errorCode = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The client is not authenticated.</p>
public struct ForbiddenException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>403</p>
    public var errorCode: String?
    /// <p>The client is not authenticated.</p>
    public var message: String?

    public init (
        errorCode: String? = nil,
        message: String? = nil
    )
    {
        self.errorCode = errorCode
        self.message = message
    }
}

struct ForbiddenExceptionBody: Equatable {
    public let errorCode: String?
    public let message: String?
}

extension ForbiddenExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case errorCode = "errorCode"
        case message = "message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension GetApplicationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetApplicationInput(applicationId: \(String(describing: applicationId)), semanticVersion: \(String(describing: semanticVersion)))"}
}

extension GetApplicationInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetApplicationInputHeadersMiddleware: Middleware {
    public let id: String = "GetApplicationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetApplicationInput>
    public typealias MOutput = OperationOutput<GetApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetApplicationOutputError>
}

public struct GetApplicationInputQueryItemMiddleware: Middleware {
    public let id: String = "GetApplicationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let semanticVersion = input.operationInput.semanticVersion {
            let semanticVersionQueryItem = URLQueryItem(name: "semanticVersion".urlPercentEncoding(), value: String(semanticVersion).urlPercentEncoding())
            input.builder.withQueryItem(semanticVersionQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetApplicationInput>
    public typealias MOutput = OperationOutput<GetApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetApplicationOutputError>
}

public struct GetApplicationInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the application.</p>
    public let applicationId: String?
    /// <p>The semantic version of the application to get.</p>
    public let semanticVersion: String?

    public init (
        applicationId: String? = nil,
        semanticVersion: String? = nil
    )
    {
        self.applicationId = applicationId
        self.semanticVersion = semanticVersion
    }
}

struct GetApplicationInputBody: Equatable {
}

extension GetApplicationInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetApplicationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetApplicationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetApplicationOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetApplicationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetApplicationOutputResponse(applicationId: \(String(describing: applicationId)), author: \(String(describing: author)), creationTime: \(String(describing: creationTime)), description: \(String(describing: description)), homePageUrl: \(String(describing: homePageUrl)), isVerifiedAuthor: \(String(describing: isVerifiedAuthor)), labels: \(String(describing: labels)), licenseUrl: \(String(describing: licenseUrl)), name: \(String(describing: name)), readmeUrl: \(String(describing: readmeUrl)), spdxLicenseId: \(String(describing: spdxLicenseId)), verifiedAuthorUrl: \(String(describing: verifiedAuthorUrl)), version: \(String(describing: version)))"}
}

extension GetApplicationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetApplicationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.applicationId = output.applicationId
            self.author = output.author
            self.creationTime = output.creationTime
            self.description = output.description
            self.homePageUrl = output.homePageUrl
            self.isVerifiedAuthor = output.isVerifiedAuthor
            self.labels = output.labels
            self.licenseUrl = output.licenseUrl
            self.name = output.name
            self.readmeUrl = output.readmeUrl
            self.spdxLicenseId = output.spdxLicenseId
            self.verifiedAuthorUrl = output.verifiedAuthorUrl
            self.version = output.version
        } else {
            self.applicationId = nil
            self.author = nil
            self.creationTime = nil
            self.description = nil
            self.homePageUrl = nil
            self.isVerifiedAuthor = false
            self.labels = nil
            self.licenseUrl = nil
            self.name = nil
            self.readmeUrl = nil
            self.spdxLicenseId = nil
            self.verifiedAuthorUrl = nil
            self.version = nil
        }
    }
}

public struct GetApplicationOutputResponse: Equatable {
    /// <p>The application Amazon Resource Name (ARN).</p>
    public let applicationId: String?
    /// <p>The name of the author publishing the app.</p><p>Minimum length=1. Maximum length=127.</p><p>Pattern "^[a-z0-9](([a-z0-9]|-(?!-))*[a-z0-9])?$";</p>
    public let author: String?
    /// <p>The date and time this resource was created.</p>
    public let creationTime: String?
    /// <p>The description of the application.</p><p>Minimum length=1. Maximum length=256</p>
    public let description: String?
    /// <p>A URL with more information about the application, for example the location of your GitHub repository for the application.</p>
    public let homePageUrl: String?
    /// <p>Whether the author of this application has been verified. This means means that AWS has made a good faith review, as a reasonable and prudent service provider, of the information provided by the requester and has confirmed that the requester's identity is as claimed.</p>
    public let isVerifiedAuthor: Bool
    /// <p>Labels to improve discovery of apps in search results.</p><p>Minimum length=1. Maximum length=127. Maximum number of labels: 10</p><p>Pattern: "^[a-zA-Z0-9+\\-_:\\/@]+$";</p>
    public let labels: [String]?
    /// <p>A link to a license file of the app that matches the spdxLicenseID value of your application.</p><p>Maximum size 5 MB</p>
    public let licenseUrl: String?
    /// <p>The name of the application.</p><p>Minimum length=1. Maximum length=140</p><p>Pattern: "[a-zA-Z0-9\\-]+";</p>
    public let name: String?
    /// <p>A link to the readme file in Markdown language that contains a more detailed description of the application and how it works.</p><p>Maximum size 5 MB</p>
    public let readmeUrl: String?
    /// <p>A valid identifier from https://spdx.org/licenses/.</p>
    public let spdxLicenseId: String?
    /// <p>The URL to the public profile of a verified author. This URL is submitted by the author.</p>
    public let verifiedAuthorUrl: String?
    /// <p>Version information about the application.</p>
    public let version: Version?

    public init (
        applicationId: String? = nil,
        author: String? = nil,
        creationTime: String? = nil,
        description: String? = nil,
        homePageUrl: String? = nil,
        isVerifiedAuthor: Bool = false,
        labels: [String]? = nil,
        licenseUrl: String? = nil,
        name: String? = nil,
        readmeUrl: String? = nil,
        spdxLicenseId: String? = nil,
        verifiedAuthorUrl: String? = nil,
        version: Version? = nil
    )
    {
        self.applicationId = applicationId
        self.author = author
        self.creationTime = creationTime
        self.description = description
        self.homePageUrl = homePageUrl
        self.isVerifiedAuthor = isVerifiedAuthor
        self.labels = labels
        self.licenseUrl = licenseUrl
        self.name = name
        self.readmeUrl = readmeUrl
        self.spdxLicenseId = spdxLicenseId
        self.verifiedAuthorUrl = verifiedAuthorUrl
        self.version = version
    }
}

struct GetApplicationOutputResponseBody: Equatable {
    public let applicationId: String?
    public let author: String?
    public let creationTime: String?
    public let description: String?
    public let homePageUrl: String?
    public let isVerifiedAuthor: Bool
    public let labels: [String]?
    public let licenseUrl: String?
    public let name: String?
    public let readmeUrl: String?
    public let spdxLicenseId: String?
    public let verifiedAuthorUrl: String?
    public let version: Version?
}

extension GetApplicationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case applicationId = "applicationId"
        case author = "author"
        case creationTime = "creationTime"
        case description = "description"
        case homePageUrl = "homePageUrl"
        case isVerifiedAuthor = "isVerifiedAuthor"
        case labels = "labels"
        case licenseUrl = "licenseUrl"
        case name = "name"
        case readmeUrl = "readmeUrl"
        case spdxLicenseId = "spdxLicenseId"
        case verifiedAuthorUrl = "verifiedAuthorUrl"
        case version = "version"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let authorDecoded = try containerValues.decodeIfPresent(String.self, forKey: .author)
        author = authorDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let homePageUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .homePageUrl)
        homePageUrl = homePageUrlDecoded
        let isVerifiedAuthorDecoded = try containerValues.decode(Bool.self, forKey: .isVerifiedAuthor)
        isVerifiedAuthor = isVerifiedAuthorDecoded
        let labelsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .labels)
        var labelsDecoded0:[String]? = nil
        if let labelsContainer = labelsContainer {
            labelsDecoded0 = [String]()
            for string0 in labelsContainer {
                if let string0 = string0 {
                    labelsDecoded0?.append(string0)
                }
            }
        }
        labels = labelsDecoded0
        let licenseUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .licenseUrl)
        licenseUrl = licenseUrlDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let readmeUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .readmeUrl)
        readmeUrl = readmeUrlDecoded
        let spdxLicenseIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .spdxLicenseId)
        spdxLicenseId = spdxLicenseIdDecoded
        let verifiedAuthorUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .verifiedAuthorUrl)
        verifiedAuthorUrl = verifiedAuthorUrlDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Version.self, forKey: .version)
        version = versionDecoded
    }
}

extension GetApplicationPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetApplicationPolicyInput(applicationId: \(String(describing: applicationId)))"}
}

extension GetApplicationPolicyInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetApplicationPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "GetApplicationPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetApplicationPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetApplicationPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetApplicationPolicyInput>
    public typealias MOutput = OperationOutput<GetApplicationPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetApplicationPolicyOutputError>
}

public struct GetApplicationPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "GetApplicationPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetApplicationPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetApplicationPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetApplicationPolicyInput>
    public typealias MOutput = OperationOutput<GetApplicationPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetApplicationPolicyOutputError>
}

public struct GetApplicationPolicyInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the application.</p>
    public let applicationId: String?

    public init (
        applicationId: String? = nil
    )
    {
        self.applicationId = applicationId
    }
}

struct GetApplicationPolicyInputBody: Equatable {
}

extension GetApplicationPolicyInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetApplicationPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetApplicationPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetApplicationPolicyOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetApplicationPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetApplicationPolicyOutputResponse(statements: \(String(describing: statements)))"}
}

extension GetApplicationPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetApplicationPolicyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.statements = output.statements
        } else {
            self.statements = nil
        }
    }
}

public struct GetApplicationPolicyOutputResponse: Equatable {
    /// <p>An array of policy statements applied to the application.</p>
    public let statements: [ApplicationPolicyStatement]?

    public init (
        statements: [ApplicationPolicyStatement]? = nil
    )
    {
        self.statements = statements
    }
}

struct GetApplicationPolicyOutputResponseBody: Equatable {
    public let statements: [ApplicationPolicyStatement]?
}

extension GetApplicationPolicyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case statements = "statements"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statementsContainer = try containerValues.decodeIfPresent([ApplicationPolicyStatement?].self, forKey: .statements)
        var statementsDecoded0:[ApplicationPolicyStatement]? = nil
        if let statementsContainer = statementsContainer {
            statementsDecoded0 = [ApplicationPolicyStatement]()
            for structure0 in statementsContainer {
                if let structure0 = structure0 {
                    statementsDecoded0?.append(structure0)
                }
            }
        }
        statements = statementsDecoded0
    }
}

extension GetCloudFormationTemplateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetCloudFormationTemplateInput(applicationId: \(String(describing: applicationId)), templateId: \(String(describing: templateId)))"}
}

extension GetCloudFormationTemplateInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetCloudFormationTemplateInputHeadersMiddleware: Middleware {
    public let id: String = "GetCloudFormationTemplateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetCloudFormationTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<GetCloudFormationTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetCloudFormationTemplateInput>
    public typealias MOutput = OperationOutput<GetCloudFormationTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetCloudFormationTemplateOutputError>
}

public struct GetCloudFormationTemplateInputQueryItemMiddleware: Middleware {
    public let id: String = "GetCloudFormationTemplateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetCloudFormationTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<GetCloudFormationTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetCloudFormationTemplateInput>
    public typealias MOutput = OperationOutput<GetCloudFormationTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetCloudFormationTemplateOutputError>
}

public struct GetCloudFormationTemplateInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the application.</p>
    public let applicationId: String?
    /// <p>The UUID returned by CreateCloudFormationTemplate.</p><p>Pattern: [0-9a-fA-F]{8}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{12}</p>
    public let templateId: String?

    public init (
        applicationId: String? = nil,
        templateId: String? = nil
    )
    {
        self.applicationId = applicationId
        self.templateId = templateId
    }
}

struct GetCloudFormationTemplateInputBody: Equatable {
}

extension GetCloudFormationTemplateInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetCloudFormationTemplateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetCloudFormationTemplateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetCloudFormationTemplateOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetCloudFormationTemplateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetCloudFormationTemplateOutputResponse(applicationId: \(String(describing: applicationId)), creationTime: \(String(describing: creationTime)), expirationTime: \(String(describing: expirationTime)), semanticVersion: \(String(describing: semanticVersion)), status: \(String(describing: status)), templateId: \(String(describing: templateId)), templateUrl: \(String(describing: templateUrl)))"}
}

extension GetCloudFormationTemplateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetCloudFormationTemplateOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.applicationId = output.applicationId
            self.creationTime = output.creationTime
            self.expirationTime = output.expirationTime
            self.semanticVersion = output.semanticVersion
            self.status = output.status
            self.templateId = output.templateId
            self.templateUrl = output.templateUrl
        } else {
            self.applicationId = nil
            self.creationTime = nil
            self.expirationTime = nil
            self.semanticVersion = nil
            self.status = nil
            self.templateId = nil
            self.templateUrl = nil
        }
    }
}

public struct GetCloudFormationTemplateOutputResponse: Equatable {
    /// <p>The application Amazon Resource Name (ARN).</p>
    public let applicationId: String?
    /// <p>The date and time this resource was created.</p>
    public let creationTime: String?
    /// <p>The date and time this template expires. Templates
    ///  expire 1 hour after creation.</p>
    public let expirationTime: String?
    /// <p>The semantic version of the application:</p><p>
    ///  <a href="https://semver.org/">https://semver.org/</a>
    ///  </p>
    public let semanticVersion: String?
    /// <p>Status of the template creation workflow.</p><p>Possible values: PREPARING | ACTIVE | EXPIRED
    ///  </p>
    public let status: Status?
    /// <p>The UUID returned by CreateCloudFormationTemplate.</p><p>Pattern: [0-9a-fA-F]{8}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{12}</p>
    public let templateId: String?
    /// <p>A link to the template that can be used to deploy the application using
    ///  AWS CloudFormation.</p>
    public let templateUrl: String?

    public init (
        applicationId: String? = nil,
        creationTime: String? = nil,
        expirationTime: String? = nil,
        semanticVersion: String? = nil,
        status: Status? = nil,
        templateId: String? = nil,
        templateUrl: String? = nil
    )
    {
        self.applicationId = applicationId
        self.creationTime = creationTime
        self.expirationTime = expirationTime
        self.semanticVersion = semanticVersion
        self.status = status
        self.templateId = templateId
        self.templateUrl = templateUrl
    }
}

struct GetCloudFormationTemplateOutputResponseBody: Equatable {
    public let applicationId: String?
    public let creationTime: String?
    public let expirationTime: String?
    public let semanticVersion: String?
    public let status: Status?
    public let templateId: String?
    public let templateUrl: String?
}

extension GetCloudFormationTemplateOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case applicationId = "applicationId"
        case creationTime = "creationTime"
        case expirationTime = "expirationTime"
        case semanticVersion = "semanticVersion"
        case status = "status"
        case templateId = "templateId"
        case templateUrl = "templateUrl"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let expirationTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .expirationTime)
        expirationTime = expirationTimeDecoded
        let semanticVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .semanticVersion)
        semanticVersion = semanticVersionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Status.self, forKey: .status)
        status = statusDecoded
        let templateIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateId)
        templateId = templateIdDecoded
        let templateUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateUrl)
        templateUrl = templateUrlDecoded
    }
}

extension InternalServerErrorException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalServerErrorException(errorCode: \(String(describing: errorCode)), message: \(String(describing: message)))"}
}

extension InternalServerErrorException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InternalServerErrorExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.errorCode = output.errorCode
            self.message = output.message
        } else {
            self.errorCode = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The AWS Serverless Application Repository service encountered an internal error.</p>
public struct InternalServerErrorException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    /// <p>500</p>
    public var errorCode: String?
    /// <p>The AWS Serverless Application Repository service encountered an internal error.</p>
    public var message: String?

    public init (
        errorCode: String? = nil,
        message: String? = nil
    )
    {
        self.errorCode = errorCode
        self.message = message
    }
}

struct InternalServerErrorExceptionBody: Equatable {
    public let errorCode: String?
    public let message: String?
}

extension InternalServerErrorExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case errorCode = "errorCode"
        case message = "message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListApplicationDependenciesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListApplicationDependenciesInput(applicationId: \(String(describing: applicationId)), maxItems: \(String(describing: maxItems)), nextToken: \(String(describing: nextToken)), semanticVersion: \(String(describing: semanticVersion)))"}
}

extension ListApplicationDependenciesInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListApplicationDependenciesInputHeadersMiddleware: Middleware {
    public let id: String = "ListApplicationDependenciesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListApplicationDependenciesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListApplicationDependenciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListApplicationDependenciesInput>
    public typealias MOutput = OperationOutput<ListApplicationDependenciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListApplicationDependenciesOutputError>
}

public struct ListApplicationDependenciesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListApplicationDependenciesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListApplicationDependenciesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListApplicationDependenciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        let maxItemsQueryItem = URLQueryItem(name: "maxItems".urlPercentEncoding(), value: String(input.operationInput.maxItems).urlPercentEncoding())
        input.builder.withQueryItem(maxItemsQueryItem)
        if let semanticVersion = input.operationInput.semanticVersion {
            let semanticVersionQueryItem = URLQueryItem(name: "semanticVersion".urlPercentEncoding(), value: String(semanticVersion).urlPercentEncoding())
            input.builder.withQueryItem(semanticVersionQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListApplicationDependenciesInput>
    public typealias MOutput = OperationOutput<ListApplicationDependenciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListApplicationDependenciesOutputError>
}

public struct ListApplicationDependenciesInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the application.</p>
    public let applicationId: String?
    /// <p>The total number of items to return.</p>
    public let maxItems: Int
    /// <p>A token to specify where to start paginating.</p>
    public let nextToken: String?
    /// <p>The semantic version of the application to get.</p>
    public let semanticVersion: String?

    public init (
        applicationId: String? = nil,
        maxItems: Int = 0,
        nextToken: String? = nil,
        semanticVersion: String? = nil
    )
    {
        self.applicationId = applicationId
        self.maxItems = maxItems
        self.nextToken = nextToken
        self.semanticVersion = semanticVersion
    }
}

struct ListApplicationDependenciesInputBody: Equatable {
}

extension ListApplicationDependenciesInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListApplicationDependenciesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListApplicationDependenciesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListApplicationDependenciesOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListApplicationDependenciesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListApplicationDependenciesOutputResponse(dependencies: \(String(describing: dependencies)), nextToken: \(String(describing: nextToken)))"}
}

extension ListApplicationDependenciesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListApplicationDependenciesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dependencies = output.dependencies
            self.nextToken = output.nextToken
        } else {
            self.dependencies = nil
            self.nextToken = nil
        }
    }
}

public struct ListApplicationDependenciesOutputResponse: Equatable {
    /// <p>An array of application summaries nested in the application.</p>
    public let dependencies: [ApplicationDependencySummary]?
    /// <p>The token to request the next page of results.</p>
    public let nextToken: String?

    public init (
        dependencies: [ApplicationDependencySummary]? = nil,
        nextToken: String? = nil
    )
    {
        self.dependencies = dependencies
        self.nextToken = nextToken
    }
}

struct ListApplicationDependenciesOutputResponseBody: Equatable {
    public let dependencies: [ApplicationDependencySummary]?
    public let nextToken: String?
}

extension ListApplicationDependenciesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dependencies = "dependencies"
        case nextToken = "nextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dependenciesContainer = try containerValues.decodeIfPresent([ApplicationDependencySummary?].self, forKey: .dependencies)
        var dependenciesDecoded0:[ApplicationDependencySummary]? = nil
        if let dependenciesContainer = dependenciesContainer {
            dependenciesDecoded0 = [ApplicationDependencySummary]()
            for structure0 in dependenciesContainer {
                if let structure0 = structure0 {
                    dependenciesDecoded0?.append(structure0)
                }
            }
        }
        dependencies = dependenciesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListApplicationVersionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListApplicationVersionsInput(applicationId: \(String(describing: applicationId)), maxItems: \(String(describing: maxItems)), nextToken: \(String(describing: nextToken)))"}
}

extension ListApplicationVersionsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListApplicationVersionsInputHeadersMiddleware: Middleware {
    public let id: String = "ListApplicationVersionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListApplicationVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListApplicationVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListApplicationVersionsInput>
    public typealias MOutput = OperationOutput<ListApplicationVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListApplicationVersionsOutputError>
}

public struct ListApplicationVersionsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListApplicationVersionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListApplicationVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListApplicationVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        let maxItemsQueryItem = URLQueryItem(name: "maxItems".urlPercentEncoding(), value: String(input.operationInput.maxItems).urlPercentEncoding())
        input.builder.withQueryItem(maxItemsQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListApplicationVersionsInput>
    public typealias MOutput = OperationOutput<ListApplicationVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListApplicationVersionsOutputError>
}

public struct ListApplicationVersionsInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the application.</p>
    public let applicationId: String?
    /// <p>The total number of items to return.</p>
    public let maxItems: Int
    /// <p>A token to specify where to start paginating.</p>
    public let nextToken: String?

    public init (
        applicationId: String? = nil,
        maxItems: Int = 0,
        nextToken: String? = nil
    )
    {
        self.applicationId = applicationId
        self.maxItems = maxItems
        self.nextToken = nextToken
    }
}

struct ListApplicationVersionsInputBody: Equatable {
}

extension ListApplicationVersionsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListApplicationVersionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListApplicationVersionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListApplicationVersionsOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListApplicationVersionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListApplicationVersionsOutputResponse(nextToken: \(String(describing: nextToken)), versions: \(String(describing: versions)))"}
}

extension ListApplicationVersionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListApplicationVersionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.versions = output.versions
        } else {
            self.nextToken = nil
            self.versions = nil
        }
    }
}

public struct ListApplicationVersionsOutputResponse: Equatable {
    /// <p>The token to request the next page of results.</p>
    public let nextToken: String?
    /// <p>An array of version summaries for the application.</p>
    public let versions: [VersionSummary]?

    public init (
        nextToken: String? = nil,
        versions: [VersionSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.versions = versions
    }
}

struct ListApplicationVersionsOutputResponseBody: Equatable {
    public let nextToken: String?
    public let versions: [VersionSummary]?
}

extension ListApplicationVersionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "nextToken"
        case versions = "versions"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let versionsContainer = try containerValues.decodeIfPresent([VersionSummary?].self, forKey: .versions)
        var versionsDecoded0:[VersionSummary]? = nil
        if let versionsContainer = versionsContainer {
            versionsDecoded0 = [VersionSummary]()
            for structure0 in versionsContainer {
                if let structure0 = structure0 {
                    versionsDecoded0?.append(structure0)
                }
            }
        }
        versions = versionsDecoded0
    }
}

extension ListApplicationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListApplicationsInput(maxItems: \(String(describing: maxItems)), nextToken: \(String(describing: nextToken)))"}
}

extension ListApplicationsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListApplicationsInputHeadersMiddleware: Middleware {
    public let id: String = "ListApplicationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListApplicationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListApplicationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListApplicationsInput>
    public typealias MOutput = OperationOutput<ListApplicationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListApplicationsOutputError>
}

public struct ListApplicationsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListApplicationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListApplicationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListApplicationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        let maxItemsQueryItem = URLQueryItem(name: "maxItems".urlPercentEncoding(), value: String(input.operationInput.maxItems).urlPercentEncoding())
        input.builder.withQueryItem(maxItemsQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListApplicationsInput>
    public typealias MOutput = OperationOutput<ListApplicationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListApplicationsOutputError>
}

public struct ListApplicationsInput: Equatable {
    /// <p>The total number of items to return.</p>
    public let maxItems: Int
    /// <p>A token to specify where to start paginating.</p>
    public let nextToken: String?

    public init (
        maxItems: Int = 0,
        nextToken: String? = nil
    )
    {
        self.maxItems = maxItems
        self.nextToken = nextToken
    }
}

struct ListApplicationsInputBody: Equatable {
}

extension ListApplicationsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListApplicationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListApplicationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListApplicationsOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListApplicationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListApplicationsOutputResponse(applications: \(String(describing: applications)), nextToken: \(String(describing: nextToken)))"}
}

extension ListApplicationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListApplicationsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.applications = output.applications
            self.nextToken = output.nextToken
        } else {
            self.applications = nil
            self.nextToken = nil
        }
    }
}

public struct ListApplicationsOutputResponse: Equatable {
    /// <p>An array of application summaries.</p>
    public let applications: [ApplicationSummary]?
    /// <p>The token to request the next page of results.</p>
    public let nextToken: String?

    public init (
        applications: [ApplicationSummary]? = nil,
        nextToken: String? = nil
    )
    {
        self.applications = applications
        self.nextToken = nextToken
    }
}

struct ListApplicationsOutputResponseBody: Equatable {
    public let applications: [ApplicationSummary]?
    public let nextToken: String?
}

extension ListApplicationsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case applications = "applications"
        case nextToken = "nextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationsContainer = try containerValues.decodeIfPresent([ApplicationSummary?].self, forKey: .applications)
        var applicationsDecoded0:[ApplicationSummary]? = nil
        if let applicationsContainer = applicationsContainer {
            applicationsDecoded0 = [ApplicationSummary]()
            for structure0 in applicationsContainer {
                if let structure0 = structure0 {
                    applicationsDecoded0?.append(structure0)
                }
            }
        }
        applications = applicationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension NotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NotFoundException(errorCode: \(String(describing: errorCode)), message: \(String(describing: message)))"}
}

extension NotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: NotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.errorCode = output.errorCode
            self.message = output.message
        } else {
            self.errorCode = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The resource (for example, an access policy statement) specified in the request doesn't exist.</p>
public struct NotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>404</p>
    public var errorCode: String?
    /// <p>The resource (for example, an access policy statement) specified in the request doesn't exist.</p>
    public var message: String?

    public init (
        errorCode: String? = nil,
        message: String? = nil
    )
    {
        self.errorCode = errorCode
        self.message = message
    }
}

struct NotFoundExceptionBody: Equatable {
    public let errorCode: String?
    public let message: String?
}

extension NotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case errorCode = "errorCode"
        case message = "message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ParameterDefinition: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case allowedPattern = "allowedPattern"
        case allowedValues = "allowedValues"
        case constraintDescription = "constraintDescription"
        case defaultValue = "defaultValue"
        case description = "description"
        case maxLength = "maxLength"
        case maxValue = "maxValue"
        case minLength = "minLength"
        case minValue = "minValue"
        case name = "name"
        case noEcho = "noEcho"
        case referencedByResources = "referencedByResources"
        case type = "type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowedPattern = allowedPattern {
            try encodeContainer.encode(allowedPattern, forKey: .allowedPattern)
        }
        if let allowedValues = allowedValues {
            var allowedValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .allowedValues)
            for __listof__string0 in allowedValues {
                try allowedValuesContainer.encode(__listof__string0)
            }
        }
        if let constraintDescription = constraintDescription {
            try encodeContainer.encode(constraintDescription, forKey: .constraintDescription)
        }
        if let defaultValue = defaultValue {
            try encodeContainer.encode(defaultValue, forKey: .defaultValue)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if maxLength != 0 {
            try encodeContainer.encode(maxLength, forKey: .maxLength)
        }
        if maxValue != 0 {
            try encodeContainer.encode(maxValue, forKey: .maxValue)
        }
        if minLength != 0 {
            try encodeContainer.encode(minLength, forKey: .minLength)
        }
        if minValue != 0 {
            try encodeContainer.encode(minValue, forKey: .minValue)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if noEcho != false {
            try encodeContainer.encode(noEcho, forKey: .noEcho)
        }
        if let referencedByResources = referencedByResources {
            var referencedByResourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .referencedByResources)
            for __listof__string0 in referencedByResources {
                try referencedByResourcesContainer.encode(__listof__string0)
            }
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let allowedPatternDecoded = try containerValues.decodeIfPresent(String.self, forKey: .allowedPattern)
        allowedPattern = allowedPatternDecoded
        let allowedValuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .allowedValues)
        var allowedValuesDecoded0:[String]? = nil
        if let allowedValuesContainer = allowedValuesContainer {
            allowedValuesDecoded0 = [String]()
            for string0 in allowedValuesContainer {
                if let string0 = string0 {
                    allowedValuesDecoded0?.append(string0)
                }
            }
        }
        allowedValues = allowedValuesDecoded0
        let constraintDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .constraintDescription)
        constraintDescription = constraintDescriptionDecoded
        let defaultValueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let maxLengthDecoded = try containerValues.decode(Int.self, forKey: .maxLength)
        maxLength = maxLengthDecoded
        let maxValueDecoded = try containerValues.decode(Int.self, forKey: .maxValue)
        maxValue = maxValueDecoded
        let minLengthDecoded = try containerValues.decode(Int.self, forKey: .minLength)
        minLength = minLengthDecoded
        let minValueDecoded = try containerValues.decode(Int.self, forKey: .minValue)
        minValue = minValueDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let noEchoDecoded = try containerValues.decode(Bool.self, forKey: .noEcho)
        noEcho = noEchoDecoded
        let referencedByResourcesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .referencedByResources)
        var referencedByResourcesDecoded0:[String]? = nil
        if let referencedByResourcesContainer = referencedByResourcesContainer {
            referencedByResourcesDecoded0 = [String]()
            for string0 in referencedByResourcesContainer {
                if let string0 = string0 {
                    referencedByResourcesDecoded0?.append(string0)
                }
            }
        }
        referencedByResources = referencedByResourcesDecoded0
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
    }
}

extension ParameterDefinition: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ParameterDefinition(allowedPattern: \(String(describing: allowedPattern)), allowedValues: \(String(describing: allowedValues)), constraintDescription: \(String(describing: constraintDescription)), defaultValue: \(String(describing: defaultValue)), description: \(String(describing: description)), maxLength: \(String(describing: maxLength)), maxValue: \(String(describing: maxValue)), minLength: \(String(describing: minLength)), minValue: \(String(describing: minValue)), name: \(String(describing: name)), noEcho: \(String(describing: noEcho)), referencedByResources: \(String(describing: referencedByResources)), type: \(String(describing: type)))"}
}

/// <p>Parameters supported by the application.</p>
public struct ParameterDefinition: Equatable {
    /// <p>A regular expression that represents the patterns to allow for String types.</p>
    public let allowedPattern: String?
    /// <p>An array containing the list of values allowed for the parameter.</p>
    public let allowedValues: [String]?
    /// <p>A string that explains a constraint when the constraint is violated. For example, without a constraint description,
    ///  a parameter that has an allowed pattern of [A-Za-z0-9]+ displays the following error message when the user
    ///  specifies an invalid value:</p><p>
    ///  Malformed input-Parameter MyParameter must match pattern [A-Za-z0-9]+
    ///  </p><p>By adding a constraint description, such as "must contain only uppercase and lowercase letters and numbers," you can display
    ///  the following customized error message:</p><p>
    ///  Malformed input-Parameter MyParameter must contain only uppercase and lowercase letters and numbers.
    ///  </p>
    public let constraintDescription: String?
    /// <p>A value of the appropriate type for the template to use if no value is specified when a stack is created.
    ///  If you define constraints for the parameter, you must specify a value that adheres to those constraints.</p>
    public let defaultValue: String?
    /// <p>A string of up to 4,000 characters that describes the parameter.</p>
    public let description: String?
    /// <p>An integer value that determines the largest number of characters that you want to allow for String types.</p>
    public let maxLength: Int
    /// <p>A numeric value that determines the largest numeric value that you want to allow for Number types.</p>
    public let maxValue: Int
    /// <p>An integer value that determines the smallest number of characters that you want to allow for String types.</p>
    public let minLength: Int
    /// <p>A numeric value that determines the smallest numeric value that you want to allow for Number types.</p>
    public let minValue: Int
    /// <p>The name of the parameter.</p>
    public let name: String?
    /// <p>Whether to mask the parameter value whenever anyone makes a call that describes the stack. If you set the
    ///  value to true, the parameter value is masked with asterisks (*****).</p>
    public let noEcho: Bool
    /// <p>A list of AWS SAM resources that use this parameter.</p>
    public let referencedByResources: [String]?
    /// <p>The type of the parameter.</p><p>Valid values: String | Number | List&lt;Number> | CommaDelimitedList
    ///  </p><p>
    ///  String: A literal string.</p><p>For example, users can specify "MyUserName".</p><p>
    ///  Number: An integer or float. AWS CloudFormation validates the parameter value as a number. However, when you use the
    ///  parameter elsewhere in your template (for example, by using the Ref intrinsic function), the parameter value becomes a string.</p><p>For example, users might specify "8888".</p><p>
    ///  List&lt;Number>: An array of integers or floats that are separated by commas. AWS CloudFormation validates the parameter value as numbers. However, when
    ///  you use the parameter elsewhere in your template (for example, by using the Ref intrinsic function), the parameter value becomes a list of strings.</p><p>For example, users might specify "80,20", and then Ref results in ["80","20"].</p><p>
    ///  CommaDelimitedList: An array of literal strings that are separated by commas. The total number of strings should be one more than the total number of commas.
    ///  Also, each member string is space-trimmed.</p><p>For example, users might specify "test,dev,prod", and then Ref results in ["test","dev","prod"].</p>
    public let type: String?

    public init (
        allowedPattern: String? = nil,
        allowedValues: [String]? = nil,
        constraintDescription: String? = nil,
        defaultValue: String? = nil,
        description: String? = nil,
        maxLength: Int = 0,
        maxValue: Int = 0,
        minLength: Int = 0,
        minValue: Int = 0,
        name: String? = nil,
        noEcho: Bool = false,
        referencedByResources: [String]? = nil,
        type: String? = nil
    )
    {
        self.allowedPattern = allowedPattern
        self.allowedValues = allowedValues
        self.constraintDescription = constraintDescription
        self.defaultValue = defaultValue
        self.description = description
        self.maxLength = maxLength
        self.maxValue = maxValue
        self.minLength = minLength
        self.minValue = minValue
        self.name = name
        self.noEcho = noEcho
        self.referencedByResources = referencedByResources
        self.type = type
    }
}

extension ParameterValue: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "name"
        case value = "value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension ParameterValue: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ParameterValue(name: \(String(describing: name)), value: \(String(describing: value)))"}
}

/// <p>Parameter value of the application.</p>
public struct ParameterValue: Equatable {
    /// <p>The key associated with the parameter. If you don't specify a key and value for a particular parameter, AWS CloudFormation
    ///  uses the default value that is specified in your template.</p>
    public let name: String?
    /// <p>The input value associated with the parameter.</p>
    public let value: String?

    public init (
        name: String? = nil,
        value: String? = nil
    )
    {
        self.name = name
        self.value = value
    }
}

public struct PutApplicationPolicyInputBodyMiddleware: Middleware {
    public let id: String = "PutApplicationPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutApplicationPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<PutApplicationPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutApplicationPolicyInput>
    public typealias MOutput = OperationOutput<PutApplicationPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutApplicationPolicyOutputError>
}

extension PutApplicationPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutApplicationPolicyInput(applicationId: \(String(describing: applicationId)), statements: \(String(describing: statements)))"}
}

extension PutApplicationPolicyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case statements = "statements"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let statements = statements {
            var statementsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .statements)
            for __listofapplicationpolicystatement0 in statements {
                try statementsContainer.encode(__listofapplicationpolicystatement0)
            }
        }
    }
}

public struct PutApplicationPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "PutApplicationPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutApplicationPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<PutApplicationPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutApplicationPolicyInput>
    public typealias MOutput = OperationOutput<PutApplicationPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutApplicationPolicyOutputError>
}

public struct PutApplicationPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "PutApplicationPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutApplicationPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<PutApplicationPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutApplicationPolicyInput>
    public typealias MOutput = OperationOutput<PutApplicationPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutApplicationPolicyOutputError>
}

public struct PutApplicationPolicyInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the application.</p>
    public let applicationId: String?
    /// <p>An array of policy statements applied to the application.</p>
    public let statements: [ApplicationPolicyStatement]?

    public init (
        applicationId: String? = nil,
        statements: [ApplicationPolicyStatement]? = nil
    )
    {
        self.applicationId = applicationId
        self.statements = statements
    }
}

struct PutApplicationPolicyInputBody: Equatable {
    public let statements: [ApplicationPolicyStatement]?
}

extension PutApplicationPolicyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case statements = "statements"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statementsContainer = try containerValues.decodeIfPresent([ApplicationPolicyStatement?].self, forKey: .statements)
        var statementsDecoded0:[ApplicationPolicyStatement]? = nil
        if let statementsContainer = statementsContainer {
            statementsDecoded0 = [ApplicationPolicyStatement]()
            for structure0 in statementsContainer {
                if let structure0 = structure0 {
                    statementsDecoded0?.append(structure0)
                }
            }
        }
        statements = statementsDecoded0
    }
}

extension PutApplicationPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutApplicationPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutApplicationPolicyOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutApplicationPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutApplicationPolicyOutputResponse(statements: \(String(describing: statements)))"}
}

extension PutApplicationPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PutApplicationPolicyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.statements = output.statements
        } else {
            self.statements = nil
        }
    }
}

public struct PutApplicationPolicyOutputResponse: Equatable {
    /// <p>An array of policy statements applied to the application.</p>
    public let statements: [ApplicationPolicyStatement]?

    public init (
        statements: [ApplicationPolicyStatement]? = nil
    )
    {
        self.statements = statements
    }
}

struct PutApplicationPolicyOutputResponseBody: Equatable {
    public let statements: [ApplicationPolicyStatement]?
}

extension PutApplicationPolicyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case statements = "statements"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statementsContainer = try containerValues.decodeIfPresent([ApplicationPolicyStatement?].self, forKey: .statements)
        var statementsDecoded0:[ApplicationPolicyStatement]? = nil
        if let statementsContainer = statementsContainer {
            statementsDecoded0 = [ApplicationPolicyStatement]()
            for structure0 in statementsContainer {
                if let structure0 = structure0 {
                    statementsDecoded0?.append(structure0)
                }
            }
        }
        statements = statementsDecoded0
    }
}

extension RollbackConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case monitoringTimeInMinutes = "monitoringTimeInMinutes"
        case rollbackTriggers = "rollbackTriggers"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if monitoringTimeInMinutes != 0 {
            try encodeContainer.encode(monitoringTimeInMinutes, forKey: .monitoringTimeInMinutes)
        }
        if let rollbackTriggers = rollbackTriggers {
            var rollbackTriggersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rollbackTriggers)
            for __listofrollbacktrigger0 in rollbackTriggers {
                try rollbackTriggersContainer.encode(__listofrollbacktrigger0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let monitoringTimeInMinutesDecoded = try containerValues.decode(Int.self, forKey: .monitoringTimeInMinutes)
        monitoringTimeInMinutes = monitoringTimeInMinutesDecoded
        let rollbackTriggersContainer = try containerValues.decodeIfPresent([RollbackTrigger?].self, forKey: .rollbackTriggers)
        var rollbackTriggersDecoded0:[RollbackTrigger]? = nil
        if let rollbackTriggersContainer = rollbackTriggersContainer {
            rollbackTriggersDecoded0 = [RollbackTrigger]()
            for structure0 in rollbackTriggersContainer {
                if let structure0 = structure0 {
                    rollbackTriggersDecoded0?.append(structure0)
                }
            }
        }
        rollbackTriggers = rollbackTriggersDecoded0
    }
}

extension RollbackConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RollbackConfiguration(monitoringTimeInMinutes: \(String(describing: monitoringTimeInMinutes)), rollbackTriggers: \(String(describing: rollbackTriggers)))"}
}

/// <p>This property corresponds to the <i>AWS CloudFormation <a href="https://docs.aws.amazon.com/goto/WebAPI/cloudformation-2010-05-15/RollbackConfiguration">RollbackConfiguration</a>
///  </i> Data Type.</p>
public struct RollbackConfiguration: Equatable {
    /// <p>This property corresponds to the content of the same name for the <i>AWS CloudFormation <a href="https://docs.aws.amazon.com/goto/WebAPI/cloudformation-2010-05-15/RollbackConfiguration">RollbackConfiguration</a>
    ///  </i> Data Type.</p>
    public let monitoringTimeInMinutes: Int
    /// <p>This property corresponds to the content of the same name for the <i>AWS CloudFormation <a href="https://docs.aws.amazon.com/goto/WebAPI/cloudformation-2010-05-15/RollbackConfiguration">RollbackConfiguration</a>
    ///  </i> Data Type.</p>
    public let rollbackTriggers: [RollbackTrigger]?

    public init (
        monitoringTimeInMinutes: Int = 0,
        rollbackTriggers: [RollbackTrigger]? = nil
    )
    {
        self.monitoringTimeInMinutes = monitoringTimeInMinutes
        self.rollbackTriggers = rollbackTriggers
    }
}

extension RollbackTrigger: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "arn"
        case type = "type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
    }
}

extension RollbackTrigger: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RollbackTrigger(arn: \(String(describing: arn)), type: \(String(describing: type)))"}
}

/// <p>This property corresponds to the <i>AWS CloudFormation <a href="https://docs.aws.amazon.com/goto/WebAPI/cloudformation-2010-05-15/RollbackTrigger">RollbackTrigger</a>
///  </i> Data Type.</p>
public struct RollbackTrigger: Equatable {
    /// <p>This property corresponds to the content of the same name for the <i>AWS CloudFormation <a href="https://docs.aws.amazon.com/goto/WebAPI/cloudformation-2010-05-15/RollbackTrigger">RollbackTrigger</a>
    ///  </i> Data Type.</p>
    public let arn: String?
    /// <p>This property corresponds to the content of the same name for the <i>AWS CloudFormation <a href="https://docs.aws.amazon.com/goto/WebAPI/cloudformation-2010-05-15/RollbackTrigger">RollbackTrigger</a>
    ///  </i> Data Type.</p>
    public let type: String?

    public init (
        arn: String? = nil,
        type: String? = nil
    )
    {
        self.arn = arn
        self.type = type
    }
}

public enum Status {
    case active
    case expired
    case preparing
    case sdkUnknown(String)
}

extension Status : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Status] {
        return [
            .active,
            .expired,
            .preparing,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .active: return "ACTIVE"
        case .expired: return "EXPIRED"
        case .preparing: return "PREPARING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Status(rawValue: rawValue) ?? Status.sdkUnknown(rawValue)
    }
}

extension Tag: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "key"
        case value = "value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Tag: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Tag(key: \(String(describing: key)), value: \(String(describing: value)))"}
}

/// <p>This property corresponds to the <i>AWS CloudFormation <a href="https://docs.aws.amazon.com/goto/WebAPI/cloudformation-2010-05-15/Tag">Tag</a>
///  </i> Data Type.</p>
public struct Tag: Equatable {
    /// <p>This property corresponds to the content of the same name for the <i>AWS CloudFormation <a href="https://docs.aws.amazon.com/goto/WebAPI/cloudformation-2010-05-15/Tag">Tag</a>
    ///  </i> Data Type.</p>
    public let key: String?
    /// <p>This property corresponds to the content of the same name for the <i>AWS CloudFormation <a href="https://docs.aws.amazon.com/goto/WebAPI/cloudformation-2010-05-15/Tag">
    ///  Tag</a>
    ///  </i>
    ///  Data Type.</p>
    public let value: String?

    public init (
        key: String? = nil,
        value: String? = nil
    )
    {
        self.key = key
        self.value = value
    }
}

extension TooManyRequestsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TooManyRequestsException(errorCode: \(String(describing: errorCode)), message: \(String(describing: message)))"}
}

extension TooManyRequestsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: TooManyRequestsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.errorCode = output.errorCode
            self.message = output.message
        } else {
            self.errorCode = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The client is sending more than the allowed number of requests per unit of time.</p>
public struct TooManyRequestsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>429</p>
    public var errorCode: String?
    /// <p>The client is sending more than the allowed number of requests per unit of time.</p>
    public var message: String?

    public init (
        errorCode: String? = nil,
        message: String? = nil
    )
    {
        self.errorCode = errorCode
        self.message = message
    }
}

struct TooManyRequestsExceptionBody: Equatable {
    public let errorCode: String?
    public let message: String?
}

extension TooManyRequestsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case errorCode = "errorCode"
        case message = "message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct UnshareApplicationInputBodyMiddleware: Middleware {
    public let id: String = "UnshareApplicationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UnshareApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<UnshareApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UnshareApplicationInput>
    public typealias MOutput = OperationOutput<UnshareApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UnshareApplicationOutputError>
}

extension UnshareApplicationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UnshareApplicationInput(applicationId: \(String(describing: applicationId)), organizationId: \(String(describing: organizationId)))"}
}

extension UnshareApplicationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case organizationId = "organizationId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let organizationId = organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

public struct UnshareApplicationInputHeadersMiddleware: Middleware {
    public let id: String = "UnshareApplicationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UnshareApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<UnshareApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UnshareApplicationInput>
    public typealias MOutput = OperationOutput<UnshareApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UnshareApplicationOutputError>
}

public struct UnshareApplicationInputQueryItemMiddleware: Middleware {
    public let id: String = "UnshareApplicationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UnshareApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<UnshareApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UnshareApplicationInput>
    public typealias MOutput = OperationOutput<UnshareApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UnshareApplicationOutputError>
}

public struct UnshareApplicationInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the application.</p>
    public let applicationId: String?
    /// <p>The AWS Organization ID to unshare the application from.</p>
    public let organizationId: String?

    public init (
        applicationId: String? = nil,
        organizationId: String? = nil
    )
    {
        self.applicationId = applicationId
        self.organizationId = organizationId
    }
}

struct UnshareApplicationInputBody: Equatable {
    public let organizationId: String?
}

extension UnshareApplicationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case organizationId = "organizationId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
    }
}

extension UnshareApplicationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UnshareApplicationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UnshareApplicationOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UnshareApplicationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UnshareApplicationOutputResponse()"}
}

extension UnshareApplicationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UnshareApplicationOutputResponse: Equatable {

    public init() {}
}

struct UnshareApplicationOutputResponseBody: Equatable {
}

extension UnshareApplicationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateApplicationInputBodyMiddleware: Middleware {
    public let id: String = "UpdateApplicationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateApplicationInput>
    public typealias MOutput = OperationOutput<UpdateApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateApplicationOutputError>
}

extension UpdateApplicationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateApplicationInput(applicationId: \(String(describing: applicationId)), author: \(String(describing: author)), description: \(String(describing: description)), homePageUrl: \(String(describing: homePageUrl)), labels: \(String(describing: labels)), readmeBody: \(String(describing: readmeBody)), readmeUrl: \(String(describing: readmeUrl)))"}
}

extension UpdateApplicationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case author = "author"
        case description = "description"
        case homePageUrl = "homePageUrl"
        case labels = "labels"
        case readmeBody = "readmeBody"
        case readmeUrl = "readmeUrl"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let author = author {
            try encodeContainer.encode(author, forKey: .author)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let homePageUrl = homePageUrl {
            try encodeContainer.encode(homePageUrl, forKey: .homePageUrl)
        }
        if let labels = labels {
            var labelsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .labels)
            for __listof__string0 in labels {
                try labelsContainer.encode(__listof__string0)
            }
        }
        if let readmeBody = readmeBody {
            try encodeContainer.encode(readmeBody, forKey: .readmeBody)
        }
        if let readmeUrl = readmeUrl {
            try encodeContainer.encode(readmeUrl, forKey: .readmeUrl)
        }
    }
}

public struct UpdateApplicationInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateApplicationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateApplicationInput>
    public typealias MOutput = OperationOutput<UpdateApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateApplicationOutputError>
}

public struct UpdateApplicationInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateApplicationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateApplicationInput>
    public typealias MOutput = OperationOutput<UpdateApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateApplicationOutputError>
}

public struct UpdateApplicationInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the application.</p>
    public let applicationId: String?
    /// <p>The name of the author publishing the app.</p><p>Minimum length=1. Maximum length=127.</p><p>Pattern "^[a-z0-9](([a-z0-9]|-(?!-))*[a-z0-9])?$";</p>
    public let author: String?
    /// <p>The description of the application.</p><p>Minimum length=1. Maximum length=256</p>
    public let description: String?
    /// <p>A URL with more information about the application, for example the location of your GitHub repository for the application.</p>
    public let homePageUrl: String?
    /// <p>Labels to improve discovery of apps in search results.</p><p>Minimum length=1. Maximum length=127. Maximum number of labels: 10</p><p>Pattern: "^[a-zA-Z0-9+\\-_:\\/@]+$";</p>
    public let labels: [String]?
    /// <p>A text readme file in Markdown language that contains a more detailed description of the application and how it works.</p><p>Maximum size 5 MB</p>
    public let readmeBody: String?
    /// <p>A link to the readme file in Markdown language that contains a more detailed description of the application and how it works.</p><p>Maximum size 5 MB</p>
    public let readmeUrl: String?

    public init (
        applicationId: String? = nil,
        author: String? = nil,
        description: String? = nil,
        homePageUrl: String? = nil,
        labels: [String]? = nil,
        readmeBody: String? = nil,
        readmeUrl: String? = nil
    )
    {
        self.applicationId = applicationId
        self.author = author
        self.description = description
        self.homePageUrl = homePageUrl
        self.labels = labels
        self.readmeBody = readmeBody
        self.readmeUrl = readmeUrl
    }
}

struct UpdateApplicationInputBody: Equatable {
    public let author: String?
    public let description: String?
    public let homePageUrl: String?
    public let labels: [String]?
    public let readmeBody: String?
    public let readmeUrl: String?
}

extension UpdateApplicationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case author = "author"
        case description = "description"
        case homePageUrl = "homePageUrl"
        case labels = "labels"
        case readmeBody = "readmeBody"
        case readmeUrl = "readmeUrl"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authorDecoded = try containerValues.decodeIfPresent(String.self, forKey: .author)
        author = authorDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let homePageUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .homePageUrl)
        homePageUrl = homePageUrlDecoded
        let labelsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .labels)
        var labelsDecoded0:[String]? = nil
        if let labelsContainer = labelsContainer {
            labelsDecoded0 = [String]()
            for string0 in labelsContainer {
                if let string0 = string0 {
                    labelsDecoded0?.append(string0)
                }
            }
        }
        labels = labelsDecoded0
        let readmeBodyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .readmeBody)
        readmeBody = readmeBodyDecoded
        let readmeUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .readmeUrl)
        readmeUrl = readmeUrlDecoded
    }
}

extension UpdateApplicationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateApplicationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateApplicationOutputError: Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateApplicationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateApplicationOutputResponse(applicationId: \(String(describing: applicationId)), author: \(String(describing: author)), creationTime: \(String(describing: creationTime)), description: \(String(describing: description)), homePageUrl: \(String(describing: homePageUrl)), isVerifiedAuthor: \(String(describing: isVerifiedAuthor)), labels: \(String(describing: labels)), licenseUrl: \(String(describing: licenseUrl)), name: \(String(describing: name)), readmeUrl: \(String(describing: readmeUrl)), spdxLicenseId: \(String(describing: spdxLicenseId)), verifiedAuthorUrl: \(String(describing: verifiedAuthorUrl)), version: \(String(describing: version)))"}
}

extension UpdateApplicationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateApplicationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.applicationId = output.applicationId
            self.author = output.author
            self.creationTime = output.creationTime
            self.description = output.description
            self.homePageUrl = output.homePageUrl
            self.isVerifiedAuthor = output.isVerifiedAuthor
            self.labels = output.labels
            self.licenseUrl = output.licenseUrl
            self.name = output.name
            self.readmeUrl = output.readmeUrl
            self.spdxLicenseId = output.spdxLicenseId
            self.verifiedAuthorUrl = output.verifiedAuthorUrl
            self.version = output.version
        } else {
            self.applicationId = nil
            self.author = nil
            self.creationTime = nil
            self.description = nil
            self.homePageUrl = nil
            self.isVerifiedAuthor = false
            self.labels = nil
            self.licenseUrl = nil
            self.name = nil
            self.readmeUrl = nil
            self.spdxLicenseId = nil
            self.verifiedAuthorUrl = nil
            self.version = nil
        }
    }
}

public struct UpdateApplicationOutputResponse: Equatable {
    /// <p>The application Amazon Resource Name (ARN).</p>
    public let applicationId: String?
    /// <p>The name of the author publishing the app.</p><p>Minimum length=1. Maximum length=127.</p><p>Pattern "^[a-z0-9](([a-z0-9]|-(?!-))*[a-z0-9])?$";</p>
    public let author: String?
    /// <p>The date and time this resource was created.</p>
    public let creationTime: String?
    /// <p>The description of the application.</p><p>Minimum length=1. Maximum length=256</p>
    public let description: String?
    /// <p>A URL with more information about the application, for example the location of your GitHub repository for the application.</p>
    public let homePageUrl: String?
    /// <p>Whether the author of this application has been verified. This means means that AWS has made a good faith review, as a reasonable and prudent service provider, of the information provided by the requester and has confirmed that the requester's identity is as claimed.</p>
    public let isVerifiedAuthor: Bool
    /// <p>Labels to improve discovery of apps in search results.</p><p>Minimum length=1. Maximum length=127. Maximum number of labels: 10</p><p>Pattern: "^[a-zA-Z0-9+\\-_:\\/@]+$";</p>
    public let labels: [String]?
    /// <p>A link to a license file of the app that matches the spdxLicenseID value of your application.</p><p>Maximum size 5 MB</p>
    public let licenseUrl: String?
    /// <p>The name of the application.</p><p>Minimum length=1. Maximum length=140</p><p>Pattern: "[a-zA-Z0-9\\-]+";</p>
    public let name: String?
    /// <p>A link to the readme file in Markdown language that contains a more detailed description of the application and how it works.</p><p>Maximum size 5 MB</p>
    public let readmeUrl: String?
    /// <p>A valid identifier from https://spdx.org/licenses/.</p>
    public let spdxLicenseId: String?
    /// <p>The URL to the public profile of a verified author. This URL is submitted by the author.</p>
    public let verifiedAuthorUrl: String?
    /// <p>Version information about the application.</p>
    public let version: Version?

    public init (
        applicationId: String? = nil,
        author: String? = nil,
        creationTime: String? = nil,
        description: String? = nil,
        homePageUrl: String? = nil,
        isVerifiedAuthor: Bool = false,
        labels: [String]? = nil,
        licenseUrl: String? = nil,
        name: String? = nil,
        readmeUrl: String? = nil,
        spdxLicenseId: String? = nil,
        verifiedAuthorUrl: String? = nil,
        version: Version? = nil
    )
    {
        self.applicationId = applicationId
        self.author = author
        self.creationTime = creationTime
        self.description = description
        self.homePageUrl = homePageUrl
        self.isVerifiedAuthor = isVerifiedAuthor
        self.labels = labels
        self.licenseUrl = licenseUrl
        self.name = name
        self.readmeUrl = readmeUrl
        self.spdxLicenseId = spdxLicenseId
        self.verifiedAuthorUrl = verifiedAuthorUrl
        self.version = version
    }
}

struct UpdateApplicationOutputResponseBody: Equatable {
    public let applicationId: String?
    public let author: String?
    public let creationTime: String?
    public let description: String?
    public let homePageUrl: String?
    public let isVerifiedAuthor: Bool
    public let labels: [String]?
    public let licenseUrl: String?
    public let name: String?
    public let readmeUrl: String?
    public let spdxLicenseId: String?
    public let verifiedAuthorUrl: String?
    public let version: Version?
}

extension UpdateApplicationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case applicationId = "applicationId"
        case author = "author"
        case creationTime = "creationTime"
        case description = "description"
        case homePageUrl = "homePageUrl"
        case isVerifiedAuthor = "isVerifiedAuthor"
        case labels = "labels"
        case licenseUrl = "licenseUrl"
        case name = "name"
        case readmeUrl = "readmeUrl"
        case spdxLicenseId = "spdxLicenseId"
        case verifiedAuthorUrl = "verifiedAuthorUrl"
        case version = "version"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let authorDecoded = try containerValues.decodeIfPresent(String.self, forKey: .author)
        author = authorDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let homePageUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .homePageUrl)
        homePageUrl = homePageUrlDecoded
        let isVerifiedAuthorDecoded = try containerValues.decode(Bool.self, forKey: .isVerifiedAuthor)
        isVerifiedAuthor = isVerifiedAuthorDecoded
        let labelsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .labels)
        var labelsDecoded0:[String]? = nil
        if let labelsContainer = labelsContainer {
            labelsDecoded0 = [String]()
            for string0 in labelsContainer {
                if let string0 = string0 {
                    labelsDecoded0?.append(string0)
                }
            }
        }
        labels = labelsDecoded0
        let licenseUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .licenseUrl)
        licenseUrl = licenseUrlDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let readmeUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .readmeUrl)
        readmeUrl = readmeUrlDecoded
        let spdxLicenseIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .spdxLicenseId)
        spdxLicenseId = spdxLicenseIdDecoded
        let verifiedAuthorUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .verifiedAuthorUrl)
        verifiedAuthorUrl = verifiedAuthorUrlDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Version.self, forKey: .version)
        version = versionDecoded
    }
}

extension Version: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applicationId = "applicationId"
        case creationTime = "creationTime"
        case parameterDefinitions = "parameterDefinitions"
        case requiredCapabilities = "requiredCapabilities"
        case resourcesSupported = "resourcesSupported"
        case semanticVersion = "semanticVersion"
        case sourceCodeArchiveUrl = "sourceCodeArchiveUrl"
        case sourceCodeUrl = "sourceCodeUrl"
        case templateUrl = "templateUrl"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationId = applicationId {
            try encodeContainer.encode(applicationId, forKey: .applicationId)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime, forKey: .creationTime)
        }
        if let parameterDefinitions = parameterDefinitions {
            var parameterDefinitionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .parameterDefinitions)
            for __listofparameterdefinition0 in parameterDefinitions {
                try parameterDefinitionsContainer.encode(__listofparameterdefinition0)
            }
        }
        if let requiredCapabilities = requiredCapabilities {
            var requiredCapabilitiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .requiredCapabilities)
            for __listofcapability0 in requiredCapabilities {
                try requiredCapabilitiesContainer.encode(__listofcapability0.rawValue)
            }
        }
        if resourcesSupported != false {
            try encodeContainer.encode(resourcesSupported, forKey: .resourcesSupported)
        }
        if let semanticVersion = semanticVersion {
            try encodeContainer.encode(semanticVersion, forKey: .semanticVersion)
        }
        if let sourceCodeArchiveUrl = sourceCodeArchiveUrl {
            try encodeContainer.encode(sourceCodeArchiveUrl, forKey: .sourceCodeArchiveUrl)
        }
        if let sourceCodeUrl = sourceCodeUrl {
            try encodeContainer.encode(sourceCodeUrl, forKey: .sourceCodeUrl)
        }
        if let templateUrl = templateUrl {
            try encodeContainer.encode(templateUrl, forKey: .templateUrl)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let parameterDefinitionsContainer = try containerValues.decodeIfPresent([ParameterDefinition?].self, forKey: .parameterDefinitions)
        var parameterDefinitionsDecoded0:[ParameterDefinition]? = nil
        if let parameterDefinitionsContainer = parameterDefinitionsContainer {
            parameterDefinitionsDecoded0 = [ParameterDefinition]()
            for structure0 in parameterDefinitionsContainer {
                if let structure0 = structure0 {
                    parameterDefinitionsDecoded0?.append(structure0)
                }
            }
        }
        parameterDefinitions = parameterDefinitionsDecoded0
        let requiredCapabilitiesContainer = try containerValues.decodeIfPresent([Capability?].self, forKey: .requiredCapabilities)
        var requiredCapabilitiesDecoded0:[Capability]? = nil
        if let requiredCapabilitiesContainer = requiredCapabilitiesContainer {
            requiredCapabilitiesDecoded0 = [Capability]()
            for string0 in requiredCapabilitiesContainer {
                if let string0 = string0 {
                    requiredCapabilitiesDecoded0?.append(string0)
                }
            }
        }
        requiredCapabilities = requiredCapabilitiesDecoded0
        let resourcesSupportedDecoded = try containerValues.decode(Bool.self, forKey: .resourcesSupported)
        resourcesSupported = resourcesSupportedDecoded
        let semanticVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .semanticVersion)
        semanticVersion = semanticVersionDecoded
        let sourceCodeArchiveUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceCodeArchiveUrl)
        sourceCodeArchiveUrl = sourceCodeArchiveUrlDecoded
        let sourceCodeUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceCodeUrl)
        sourceCodeUrl = sourceCodeUrlDecoded
        let templateUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateUrl)
        templateUrl = templateUrlDecoded
    }
}

extension Version: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Version(applicationId: \(String(describing: applicationId)), creationTime: \(String(describing: creationTime)), parameterDefinitions: \(String(describing: parameterDefinitions)), requiredCapabilities: \(String(describing: requiredCapabilities)), resourcesSupported: \(String(describing: resourcesSupported)), semanticVersion: \(String(describing: semanticVersion)), sourceCodeArchiveUrl: \(String(describing: sourceCodeArchiveUrl)), sourceCodeUrl: \(String(describing: sourceCodeUrl)), templateUrl: \(String(describing: templateUrl)))"}
}

/// <p>Application version details.</p>
public struct Version: Equatable {
    /// <p>The application Amazon Resource Name (ARN).</p>
    public let applicationId: String?
    /// <p>The date and time this resource was created.</p>
    public let creationTime: String?
    /// <p>An array of parameter types supported by the application.</p>
    public let parameterDefinitions: [ParameterDefinition]?
    /// <p>A list of values that you must specify before you can deploy certain applications.
    ///  Some applications might include resources that can affect permissions in your AWS
    ///  account, for example, by creating new AWS Identity and Access Management (IAM) users.
    ///  For those applications, you must explicitly acknowledge their capabilities by
    ///  specifying this parameter.</p><p>The only valid values are CAPABILITY_IAM, CAPABILITY_NAMED_IAM,
    ///  CAPABILITY_RESOURCE_POLICY, and CAPABILITY_AUTO_EXPAND.</p><p>The following resources require you to specify CAPABILITY_IAM or
    ///  CAPABILITY_NAMED_IAM:
    ///  <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iam-group.html">AWS::IAM::Group</a>,
    ///  <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-instanceprofile.html">AWS::IAM::InstanceProfile</a>,
    ///  <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-policy.html">AWS::IAM::Policy</a>, and
    ///  <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-role.html">AWS::IAM::Role</a>.
    ///  If the application contains IAM resources, you can specify either CAPABILITY_IAM
    ///  or CAPABILITY_NAMED_IAM. If the application contains IAM resources
    ///  with custom names, you must specify CAPABILITY_NAMED_IAM.</p><p>The following resources require you to specify CAPABILITY_RESOURCE_POLICY:
    ///  <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-lambda-permission.html">AWS::Lambda::Permission</a>,
    ///  <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-policy.html">AWS::IAM:Policy</a>,
    ///  <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-applicationautoscaling-scalingpolicy.html">AWS::ApplicationAutoScaling::ScalingPolicy</a>,
    ///  <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-policy.html">AWS::S3::BucketPolicy</a>,
    ///  <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sqs-policy.html">AWS::SQS::QueuePolicy</a>, and
    ///  <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sns-policy.html">AWS::SNS::TopicPolicy</a>.</p><p>Applications that contain one or more nested applications require you to specify
    ///  CAPABILITY_AUTO_EXPAND.</p><p>If your application template contains any of the above resources, we recommend that you review
    ///  all permissions associated with the application before deploying. If you don't specify
    ///  this parameter for an application that requires capabilities, the call will fail.</p>
    public let requiredCapabilities: [Capability]?
    /// <p>Whether all of the AWS resources contained in this application are supported in the region
    ///  in which it is being retrieved.</p>
    public let resourcesSupported: Bool
    /// <p>The semantic version of the application:</p><p>
    ///  <a href="https://semver.org/">https://semver.org/</a>
    ///  </p>
    public let semanticVersion: String?
    /// <p>A link to the S3 object that contains the ZIP archive of the source code for this version of your application.</p><p>Maximum size 50 MB</p>
    public let sourceCodeArchiveUrl: String?
    /// <p>A link to a public repository for the source code of your application, for example the URL of a specific GitHub commit.</p>
    public let sourceCodeUrl: String?
    /// <p>A link to the packaged AWS SAM template of your application.</p>
    public let templateUrl: String?

    public init (
        applicationId: String? = nil,
        creationTime: String? = nil,
        parameterDefinitions: [ParameterDefinition]? = nil,
        requiredCapabilities: [Capability]? = nil,
        resourcesSupported: Bool = false,
        semanticVersion: String? = nil,
        sourceCodeArchiveUrl: String? = nil,
        sourceCodeUrl: String? = nil,
        templateUrl: String? = nil
    )
    {
        self.applicationId = applicationId
        self.creationTime = creationTime
        self.parameterDefinitions = parameterDefinitions
        self.requiredCapabilities = requiredCapabilities
        self.resourcesSupported = resourcesSupported
        self.semanticVersion = semanticVersion
        self.sourceCodeArchiveUrl = sourceCodeArchiveUrl
        self.sourceCodeUrl = sourceCodeUrl
        self.templateUrl = templateUrl
    }
}

extension VersionSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applicationId = "applicationId"
        case creationTime = "creationTime"
        case semanticVersion = "semanticVersion"
        case sourceCodeUrl = "sourceCodeUrl"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationId = applicationId {
            try encodeContainer.encode(applicationId, forKey: .applicationId)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime, forKey: .creationTime)
        }
        if let semanticVersion = semanticVersion {
            try encodeContainer.encode(semanticVersion, forKey: .semanticVersion)
        }
        if let sourceCodeUrl = sourceCodeUrl {
            try encodeContainer.encode(sourceCodeUrl, forKey: .sourceCodeUrl)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let semanticVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .semanticVersion)
        semanticVersion = semanticVersionDecoded
        let sourceCodeUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceCodeUrl)
        sourceCodeUrl = sourceCodeUrlDecoded
    }
}

extension VersionSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VersionSummary(applicationId: \(String(describing: applicationId)), creationTime: \(String(describing: creationTime)), semanticVersion: \(String(describing: semanticVersion)), sourceCodeUrl: \(String(describing: sourceCodeUrl)))"}
}

/// <p>An application version summary.</p>
public struct VersionSummary: Equatable {
    /// <p>The application Amazon Resource Name (ARN).</p>
    public let applicationId: String?
    /// <p>The date and time this resource was created.</p>
    public let creationTime: String?
    /// <p>The semantic version of the application:</p><p>
    ///  <a href="https://semver.org/">https://semver.org/</a>
    ///  </p>
    public let semanticVersion: String?
    /// <p>A link to a public repository for the source code of your application, for example the URL of a specific GitHub commit.</p>
    public let sourceCodeUrl: String?

    public init (
        applicationId: String? = nil,
        creationTime: String? = nil,
        semanticVersion: String? = nil,
        sourceCodeUrl: String? = nil
    )
    {
        self.applicationId = applicationId
        self.creationTime = creationTime
        self.semanticVersion = semanticVersion
        self.sourceCodeUrl = sourceCodeUrl
    }
}
