// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

/// <p>Describes an AWS Lambda function recommendation.</p>
public struct LambdaFunctionRecommendation: Equatable {
    /// <p>The AWS account ID of the function.</p>
    public let accountId: String?
    /// <p>The amount of memory, in MB, that's allocated to the current function.</p>
    public let currentMemorySize: Int
    /// <p>The finding classification of the function.</p>
    ///         <p>Findings for functions include:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <b>
    ///                      <code>Optimized</code>
    ///                   </b> — The function is
    ///                     correctly provisioned to run your workload based on its current configuration
    ///                     and its utilization history. This finding classification does not include
    ///                     finding reason codes.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <b>
    ///                      <code>NotOptimized</code>
    ///                   </b> — The function is
    ///                     performing at a higher level (over-provisioned) or at a lower level
    ///                     (under-provisioned) than required for your workload because its current
    ///                     configuration is not optimal. Over-provisioned resources might lead to
    ///                     unnecessary infrastructure cost, and under-provisioned resources might lead to
    ///                     poor application performance. This finding classification can include the
    ///                         <code>MemoryUnderprovisioned</code> and <code>MemoryUnderprovisioned</code>
    ///                     finding reason codes.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <b>
    ///                      <code>Unavailable</code>
    ///                   </b> — Compute Optimizer was unable to
    ///                     generate a recommendation for the function. This could be because the function
    ///                     has not accumulated sufficient metric data, or the function does not qualify for
    ///                     a recommendation. This finding classification can include the
    ///                         <code>InsufficientData</code> and <code>Inconclusive</code> finding reason
    ///                     codes.</p>
    ///                 <note>
    ///                     <p>Functions with a finding of unavailable are not returned unless you
    ///                         specify the <code>filter</code> parameter with a value of
    ///                             <code>Unavailable</code> in your
    ///                             <code>GetLambdaFunctionRecommendations</code> request.</p>
    ///                 </note>
    ///             </li>
    ///          </ul>
    public let finding: LambdaFunctionRecommendationFinding?
    /// <p>The reason for the finding classification of the function.</p>
    ///         <note>
    ///             <p>Functions that have a finding classification of <code>Optimized</code> don't have
    ///                 a finding reason code.</p>
    ///         </note>
    ///         <p>Finding reason codes for functions include:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <b>
    ///                      <code>MemoryOverprovisioned</code>
    ///                   </b> — The
    ///                     function is over-provisioned when its memory configuration can be sized down
    ///                     while still meeting the performance requirements of your workload. An
    ///                     over-provisioned function might lead to unnecessary infrastructure cost. This
    ///                     finding reason code is part of the <code>NotOptimized</code> finding
    ///                     classification.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <b>
    ///                      <code>MemoryUnderprovisioned</code>
    ///                   </b> — The
    ///                     function is under-provisioned when its memory configuration doesn't meet the
    ///                     performance requirements of the workload. An under-provisioned function might
    ///                     lead to poor application performance. This finding reason code is part of the
    ///                         <code>NotOptimized</code> finding classification.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <b>
    ///                      <code>InsufficientData</code>
    ///                   </b> — The
    ///                     function does not have sufficient metric data for Compute Optimizer to generate a
    ///                     recommendation. For more information, see the <a href="https://docs.aws.amazon.com/compute-optimizer/latest/ug/requirements.html">Supported resources and
    ///                         requirements</a> in the <i>AWS Compute Optimizer User Guide</i>. This
    ///                     finding reason code is part of the <code>Unavailable</code> finding
    ///                     classification.</p>
    ///
    ///
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <b>
    ///                      <code>Inconclusive</code>
    ///                   </b> — The function does
    ///                     not qualify for a recommendation because Compute Optimizer cannot generate a recommendation
    ///                     with a high degree of confidence. This finding reason code is part of the
    ///                         <code>Unavailable</code> finding classification.</p>
    ///             </li>
    ///          </ul>
    public let findingReasonCodes: [LambdaFunctionRecommendationFindingReasonCode]?
    /// <p>The Amazon Resource Name (ARN) of the current function.</p>
    public let functionArn: String?
    /// <p>The version number of the current function.</p>
    public let functionVersion: String?
    /// <p>The time stamp of when the function recommendation was last refreshed.</p>
    public let lastRefreshTimestamp: Date?
    /// <p>The number of days for which utilization metrics were analyzed for the
    ///             function.</p>
    public let lookbackPeriodInDays: Double
    /// <p>An array of objects that describe the memory configuration recommendation options for
    ///             the function.</p>
    public let memorySizeRecommendationOptions: [LambdaFunctionMemoryRecommendationOption]?
    /// <p>The number of times your function code was executed during the look-back
    ///             period.</p>
    public let numberOfInvocations: Int
    /// <p>An array of objects that describe the utilization metrics of the function.</p>
    public let utilizationMetrics: [LambdaFunctionUtilizationMetric]?

    public init (
        accountId: String? = nil,
        currentMemorySize: Int = 0,
        finding: LambdaFunctionRecommendationFinding? = nil,
        findingReasonCodes: [LambdaFunctionRecommendationFindingReasonCode]? = nil,
        functionArn: String? = nil,
        functionVersion: String? = nil,
        lastRefreshTimestamp: Date? = nil,
        lookbackPeriodInDays: Double = 0.0,
        memorySizeRecommendationOptions: [LambdaFunctionMemoryRecommendationOption]? = nil,
        numberOfInvocations: Int = 0,
        utilizationMetrics: [LambdaFunctionUtilizationMetric]? = nil
    )
    {
        self.accountId = accountId
        self.currentMemorySize = currentMemorySize
        self.finding = finding
        self.findingReasonCodes = findingReasonCodes
        self.functionArn = functionArn
        self.functionVersion = functionVersion
        self.lastRefreshTimestamp = lastRefreshTimestamp
        self.lookbackPeriodInDays = lookbackPeriodInDays
        self.memorySizeRecommendationOptions = memorySizeRecommendationOptions
        self.numberOfInvocations = numberOfInvocations
        self.utilizationMetrics = utilizationMetrics
    }
}

extension LambdaFunctionRecommendation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LambdaFunctionRecommendation(accountId: \(String(describing: accountId)), currentMemorySize: \(String(describing: currentMemorySize)), finding: \(String(describing: finding)), findingReasonCodes: \(String(describing: findingReasonCodes)), functionArn: \(String(describing: functionArn)), functionVersion: \(String(describing: functionVersion)), lastRefreshTimestamp: \(String(describing: lastRefreshTimestamp)), lookbackPeriodInDays: \(String(describing: lookbackPeriodInDays)), memorySizeRecommendationOptions: \(String(describing: memorySizeRecommendationOptions)), numberOfInvocations: \(String(describing: numberOfInvocations)), utilizationMetrics: \(String(describing: utilizationMetrics)))"}
}
