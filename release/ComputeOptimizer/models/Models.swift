// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccessDeniedException(message: \(String(describing: message)))"}
}

extension AccessDeniedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You do not have sufficient access to perform this action.</p>
public struct AccessDeniedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Equatable {
    public let message: String?
}

extension AccessDeniedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AutoScalingGroupConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case desiredCapacity
        case instanceType
        case maxSize
        case minSize
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if desiredCapacity != 0 {
            try encodeContainer.encode(desiredCapacity, forKey: .desiredCapacity)
        }
        if let instanceType = instanceType {
            try encodeContainer.encode(instanceType, forKey: .instanceType)
        }
        if maxSize != 0 {
            try encodeContainer.encode(maxSize, forKey: .maxSize)
        }
        if minSize != 0 {
            try encodeContainer.encode(minSize, forKey: .minSize)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let desiredCapacityDecoded = try containerValues.decode(Int.self, forKey: .desiredCapacity)
        desiredCapacity = desiredCapacityDecoded
        let minSizeDecoded = try containerValues.decode(Int.self, forKey: .minSize)
        minSize = minSizeDecoded
        let maxSizeDecoded = try containerValues.decode(Int.self, forKey: .maxSize)
        maxSize = maxSizeDecoded
        let instanceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceType)
        instanceType = instanceTypeDecoded
    }
}

extension AutoScalingGroupConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AutoScalingGroupConfiguration(desiredCapacity: \(String(describing: desiredCapacity)), instanceType: \(String(describing: instanceType)), maxSize: \(String(describing: maxSize)), minSize: \(String(describing: minSize)))"}
}

/// <p>Describes the configuration of an Auto Scaling group.</p>
public struct AutoScalingGroupConfiguration: Equatable {
    /// <p>The desired capacity, or number of instances, for the Auto Scaling group.</p>
    public let desiredCapacity: Int
    /// <p>The instance type for the Auto Scaling group.</p>
    public let instanceType: String?
    /// <p>The maximum size, or maximum number of instances, for the Auto Scaling group.</p>
    public let maxSize: Int
    /// <p>The minimum size, or minimum number of instances, for the Auto Scaling group.</p>
    public let minSize: Int

    public init (
        desiredCapacity: Int = 0,
        instanceType: String? = nil,
        maxSize: Int = 0,
        minSize: Int = 0
    )
    {
        self.desiredCapacity = desiredCapacity
        self.instanceType = instanceType
        self.maxSize = maxSize
        self.minSize = minSize
    }
}

extension AutoScalingGroupRecommendation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountId
        case autoScalingGroupArn
        case autoScalingGroupName
        case currentConfiguration
        case finding
        case lastRefreshTimestamp
        case lookBackPeriodInDays
        case recommendationOptions
        case utilizationMetrics
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let autoScalingGroupArn = autoScalingGroupArn {
            try encodeContainer.encode(autoScalingGroupArn, forKey: .autoScalingGroupArn)
        }
        if let autoScalingGroupName = autoScalingGroupName {
            try encodeContainer.encode(autoScalingGroupName, forKey: .autoScalingGroupName)
        }
        if let currentConfiguration = currentConfiguration {
            try encodeContainer.encode(currentConfiguration, forKey: .currentConfiguration)
        }
        if let finding = finding {
            try encodeContainer.encode(finding.rawValue, forKey: .finding)
        }
        if let lastRefreshTimestamp = lastRefreshTimestamp {
            try encodeContainer.encode(lastRefreshTimestamp.timeIntervalSince1970, forKey: .lastRefreshTimestamp)
        }
        if lookBackPeriodInDays != 0.0 {
            try encodeContainer.encode(lookBackPeriodInDays, forKey: .lookBackPeriodInDays)
        }
        if let recommendationOptions = recommendationOptions {
            var recommendationOptionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .recommendationOptions)
            for autoscalinggrouprecommendationoptions0 in recommendationOptions {
                try recommendationOptionsContainer.encode(autoscalinggrouprecommendationoptions0)
            }
        }
        if let utilizationMetrics = utilizationMetrics {
            var utilizationMetricsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .utilizationMetrics)
            for utilizationmetrics0 in utilizationMetrics {
                try utilizationMetricsContainer.encode(utilizationmetrics0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let autoScalingGroupArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .autoScalingGroupArn)
        autoScalingGroupArn = autoScalingGroupArnDecoded
        let autoScalingGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .autoScalingGroupName)
        autoScalingGroupName = autoScalingGroupNameDecoded
        let findingDecoded = try containerValues.decodeIfPresent(Finding.self, forKey: .finding)
        finding = findingDecoded
        let utilizationMetricsContainer = try containerValues.decodeIfPresent([UtilizationMetric?].self, forKey: .utilizationMetrics)
        var utilizationMetricsDecoded0:[UtilizationMetric]? = nil
        if let utilizationMetricsContainer = utilizationMetricsContainer {
            utilizationMetricsDecoded0 = [UtilizationMetric]()
            for structure0 in utilizationMetricsContainer {
                if let structure0 = structure0 {
                    utilizationMetricsDecoded0?.append(structure0)
                }
            }
        }
        utilizationMetrics = utilizationMetricsDecoded0
        let lookBackPeriodInDaysDecoded = try containerValues.decode(Double.self, forKey: .lookBackPeriodInDays)
        lookBackPeriodInDays = lookBackPeriodInDaysDecoded
        let currentConfigurationDecoded = try containerValues.decodeIfPresent(AutoScalingGroupConfiguration.self, forKey: .currentConfiguration)
        currentConfiguration = currentConfigurationDecoded
        let recommendationOptionsContainer = try containerValues.decodeIfPresent([AutoScalingGroupRecommendationOption?].self, forKey: .recommendationOptions)
        var recommendationOptionsDecoded0:[AutoScalingGroupRecommendationOption]? = nil
        if let recommendationOptionsContainer = recommendationOptionsContainer {
            recommendationOptionsDecoded0 = [AutoScalingGroupRecommendationOption]()
            for structure0 in recommendationOptionsContainer {
                if let structure0 = structure0 {
                    recommendationOptionsDecoded0?.append(structure0)
                }
            }
        }
        recommendationOptions = recommendationOptionsDecoded0
        let lastRefreshTimestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastRefreshTimestamp)
        lastRefreshTimestamp = lastRefreshTimestampDecoded
    }
}

extension AutoScalingGroupRecommendation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AutoScalingGroupRecommendation(accountId: \(String(describing: accountId)), autoScalingGroupArn: \(String(describing: autoScalingGroupArn)), autoScalingGroupName: \(String(describing: autoScalingGroupName)), currentConfiguration: \(String(describing: currentConfiguration)), finding: \(String(describing: finding)), lastRefreshTimestamp: \(String(describing: lastRefreshTimestamp)), lookBackPeriodInDays: \(String(describing: lookBackPeriodInDays)), recommendationOptions: \(String(describing: recommendationOptions)), utilizationMetrics: \(String(describing: utilizationMetrics)))"}
}

/// <p>Describes an Auto Scaling group recommendation.</p>
public struct AutoScalingGroupRecommendation: Equatable {
    /// <p>The AWS account ID of the Auto Scaling group.</p>
    public let accountId: String?
    /// <p>The Amazon Resource Name (ARN) of the Auto Scaling group.</p>
    public let autoScalingGroupArn: String?
    /// <p>The name of the Auto Scaling group.</p>
    public let autoScalingGroupName: String?
    /// <p>An array of objects that describe the current configuration of the Auto Scaling group.</p>
    public let currentConfiguration: AutoScalingGroupConfiguration?
    /// <p>The finding classification of the Auto Scaling group.</p>
    ///         <p>Findings for Auto Scaling groups include:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <b>
    ///                      <code>NotOptimized</code>
    ///                   </b>—An Auto Scaling
    ///                     group is considered not optimized when AWS Compute Optimizer identifies a recommendation that
    ///                     can provide better performance for your workload.</p>
    ///
    ///
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <b>
    ///                      <code>Optimized</code>
    ///                   </b>—An Auto Scaling group is
    ///                     considered optimized when Compute Optimizer determines that the group is correctly
    ///                     provisioned to run your workload based on the chosen instance type. For
    ///                     optimized resources, Compute Optimizer might recommend a new generation instance type.</p>
    ///             </li>
    ///          </ul>
    public let finding: Finding?
    /// <p>The time stamp of when the Auto Scaling group recommendation was last refreshed.</p>
    public let lastRefreshTimestamp: Date?
    /// <p>The number of days for which utilization metrics were analyzed for the Auto Scaling
    ///             group.</p>
    public let lookBackPeriodInDays: Double
    /// <p>An array of objects that describe the recommendation options for the Auto Scaling
    ///             group.</p>
    public let recommendationOptions: [AutoScalingGroupRecommendationOption]?
    /// <p>An array of objects that describe the utilization metrics of the Auto Scaling group.</p>
    public let utilizationMetrics: [UtilizationMetric]?

    public init (
        accountId: String? = nil,
        autoScalingGroupArn: String? = nil,
        autoScalingGroupName: String? = nil,
        currentConfiguration: AutoScalingGroupConfiguration? = nil,
        finding: Finding? = nil,
        lastRefreshTimestamp: Date? = nil,
        lookBackPeriodInDays: Double = 0.0,
        recommendationOptions: [AutoScalingGroupRecommendationOption]? = nil,
        utilizationMetrics: [UtilizationMetric]? = nil
    )
    {
        self.accountId = accountId
        self.autoScalingGroupArn = autoScalingGroupArn
        self.autoScalingGroupName = autoScalingGroupName
        self.currentConfiguration = currentConfiguration
        self.finding = finding
        self.lastRefreshTimestamp = lastRefreshTimestamp
        self.lookBackPeriodInDays = lookBackPeriodInDays
        self.recommendationOptions = recommendationOptions
        self.utilizationMetrics = utilizationMetrics
    }
}

extension AutoScalingGroupRecommendationOption: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case configuration
        case performanceRisk
        case projectedUtilizationMetrics
        case rank
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configuration = configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
        if performanceRisk != 0.0 {
            try encodeContainer.encode(performanceRisk, forKey: .performanceRisk)
        }
        if let projectedUtilizationMetrics = projectedUtilizationMetrics {
            var projectedUtilizationMetricsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .projectedUtilizationMetrics)
            for projectedutilizationmetrics0 in projectedUtilizationMetrics {
                try projectedUtilizationMetricsContainer.encode(projectedutilizationmetrics0)
            }
        }
        if rank != 0 {
            try encodeContainer.encode(rank, forKey: .rank)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationDecoded = try containerValues.decodeIfPresent(AutoScalingGroupConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
        let projectedUtilizationMetricsContainer = try containerValues.decodeIfPresent([UtilizationMetric?].self, forKey: .projectedUtilizationMetrics)
        var projectedUtilizationMetricsDecoded0:[UtilizationMetric]? = nil
        if let projectedUtilizationMetricsContainer = projectedUtilizationMetricsContainer {
            projectedUtilizationMetricsDecoded0 = [UtilizationMetric]()
            for structure0 in projectedUtilizationMetricsContainer {
                if let structure0 = structure0 {
                    projectedUtilizationMetricsDecoded0?.append(structure0)
                }
            }
        }
        projectedUtilizationMetrics = projectedUtilizationMetricsDecoded0
        let performanceRiskDecoded = try containerValues.decode(Double.self, forKey: .performanceRisk)
        performanceRisk = performanceRiskDecoded
        let rankDecoded = try containerValues.decode(Int.self, forKey: .rank)
        rank = rankDecoded
    }
}

extension AutoScalingGroupRecommendationOption: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AutoScalingGroupRecommendationOption(configuration: \(String(describing: configuration)), performanceRisk: \(String(describing: performanceRisk)), projectedUtilizationMetrics: \(String(describing: projectedUtilizationMetrics)), rank: \(String(describing: rank)))"}
}

/// <p>Describes a recommendation option for an Auto Scaling group.</p>
public struct AutoScalingGroupRecommendationOption: Equatable {
    /// <p>An array of objects that describe an Auto Scaling group configuration.</p>
    public let configuration: AutoScalingGroupConfiguration?
    /// <p>The performance risk of the Auto Scaling group configuration recommendation.</p>
    ///         <p>Performance risk indicates the likelihood of the recommended instance type not meeting
    ///             the resource needs of your workload. Compute Optimizer calculates an individual performance risk
    ///             score for each specification of the recommended instance, including CPU, memory, EBS
    ///             throughput, EBS IOPS, disk throughput, disk IOPS, network throughput, and network PPS.
    ///             The performance
    ///             risk of the recommended instance is calculated as the maximum performance risk score
    ///             across the analyzed resource specifications.</p>
    ///         <p>The value ranges from 0 to 5, with 0 meaning that the recommended resource is
    ///             predicted to always provide enough hardware capability. The higher the performance risk
    ///             is, the more likely you should validate whether the recommended resource meets the
    ///             performance requirements of your workload before migrating your resource.</p>
    public let performanceRisk: Double
    /// <p>An array of objects that describe the projected utilization metrics of the Auto Scaling group
    ///             recommendation option.</p>
    ///
    ///         <note>
    ///             <p>The <code>Cpu</code> and <code>Memory</code> metrics are the only projected
    ///                 utilization metrics returned. Additionally, the <code>Memory</code> metric is
    ///                 returned only for resources that have the unified CloudWatch agent installed on them. For
    ///                 more information, see <a href="https://docs.aws.amazon.com/compute-optimizer/latest/ug/metrics.html#cw-agent">Enabling Memory
    ///                     Utilization with the CloudWatch Agent</a>.</p>
    ///         </note>
    public let projectedUtilizationMetrics: [UtilizationMetric]?
    /// <p>The rank of the Auto Scaling group recommendation option.</p>
    ///         <p>The top recommendation option is ranked as <code>1</code>.</p>
    public let rank: Int

    public init (
        configuration: AutoScalingGroupConfiguration? = nil,
        performanceRisk: Double = 0.0,
        projectedUtilizationMetrics: [UtilizationMetric]? = nil,
        rank: Int = 0
    )
    {
        self.configuration = configuration
        self.performanceRisk = performanceRisk
        self.projectedUtilizationMetrics = projectedUtilizationMetrics
        self.rank = rank
    }
}

public struct DescribeRecommendationExportJobsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeRecommendationExportJobsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeRecommendationExportJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeRecommendationExportJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeRecommendationExportJobsInput>
    public typealias MOutput = OperationOutput<DescribeRecommendationExportJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeRecommendationExportJobsOutputError>
}

extension DescribeRecommendationExportJobsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeRecommendationExportJobsInput(filters: \(String(describing: filters)), jobIds: \(String(describing: jobIds)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeRecommendationExportJobsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters
        case jobIds
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for jobfilters0 in filters {
                try filtersContainer.encode(jobfilters0)
            }
        }
        if let jobIds = jobIds {
            var jobIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .jobIds)
            for jobids0 in jobIds {
                try jobIdsContainer.encode(jobids0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct DescribeRecommendationExportJobsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeRecommendationExportJobsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeRecommendationExportJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeRecommendationExportJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeRecommendationExportJobsInput>
    public typealias MOutput = OperationOutput<DescribeRecommendationExportJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeRecommendationExportJobsOutputError>
}

public struct DescribeRecommendationExportJobsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeRecommendationExportJobsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeRecommendationExportJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeRecommendationExportJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeRecommendationExportJobsInput>
    public typealias MOutput = OperationOutput<DescribeRecommendationExportJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeRecommendationExportJobsOutputError>
}

public struct DescribeRecommendationExportJobsInput: Equatable {
    /// <p>An array of objects that describe a filter to return a more specific list of export
    ///             jobs.</p>
    public let filters: [JobFilter]?
    /// <p>The identification numbers of the export jobs to return.</p>
    ///
    ///         <p>An export job ID is returned when you create an export using the
    ///                 <code>ExportAutoScalingGroupRecommendations</code> or
    ///                 <code>ExportEC2InstanceRecommendations</code> actions.</p>
    ///
    ///         <p>All export jobs created in the last seven days are returned if this parameter is
    ///             omitted.</p>
    public let jobIds: [String]?
    /// <p>The maximum number of export jobs to return with a single request.</p>
    ///         <p>To retrieve the remaining results, make another request with the returned
    ///                 <code>NextToken</code> value.</p>
    public let maxResults: Int?
    /// <p>The token to advance to the next page of export jobs.</p>
    public let nextToken: String?

    public init (
        filters: [JobFilter]? = nil,
        jobIds: [String]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.filters = filters
        self.jobIds = jobIds
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeRecommendationExportJobsInputBody: Equatable {
    public let jobIds: [String]?
    public let filters: [JobFilter]?
    public let nextToken: String?
    public let maxResults: Int?
}

extension DescribeRecommendationExportJobsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filters
        case jobIds
        case maxResults
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .jobIds)
        var jobIdsDecoded0:[String]? = nil
        if let jobIdsContainer = jobIdsContainer {
            jobIdsDecoded0 = [String]()
            for string0 in jobIdsContainer {
                if let string0 = string0 {
                    jobIdsDecoded0?.append(string0)
                }
            }
        }
        jobIds = jobIdsDecoded0
        let filtersContainer = try containerValues.decodeIfPresent([JobFilter?].self, forKey: .filters)
        var filtersDecoded0:[JobFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [JobFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeRecommendationExportJobsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeRecommendationExportJobsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingAuthenticationToken" : self = .missingAuthenticationToken(try MissingAuthenticationToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OptInRequiredException" : self = .optInRequiredException(try OptInRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeRecommendationExportJobsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case invalidParameterValueException(InvalidParameterValueException)
    case missingAuthenticationToken(MissingAuthenticationToken)
    case optInRequiredException(OptInRequiredException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeRecommendationExportJobsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeRecommendationExportJobsOutputResponse(nextToken: \(String(describing: nextToken)), recommendationExportJobs: \(String(describing: recommendationExportJobs)))"}
}

extension DescribeRecommendationExportJobsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeRecommendationExportJobsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.recommendationExportJobs = output.recommendationExportJobs
        } else {
            self.nextToken = nil
            self.recommendationExportJobs = nil
        }
    }
}

public struct DescribeRecommendationExportJobsOutputResponse: Equatable {
    /// <p>The token to use to advance to the next page of export jobs.</p>
    ///         <p>This value is null when there are no more pages of export jobs to return.</p>
    public let nextToken: String?
    /// <p>An array of objects that describe recommendation export jobs.</p>
    public let recommendationExportJobs: [RecommendationExportJob]?

    public init (
        nextToken: String? = nil,
        recommendationExportJobs: [RecommendationExportJob]? = nil
    )
    {
        self.nextToken = nextToken
        self.recommendationExportJobs = recommendationExportJobs
    }
}

struct DescribeRecommendationExportJobsOutputResponseBody: Equatable {
    public let recommendationExportJobs: [RecommendationExportJob]?
    public let nextToken: String?
}

extension DescribeRecommendationExportJobsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case recommendationExportJobs
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recommendationExportJobsContainer = try containerValues.decodeIfPresent([RecommendationExportJob?].self, forKey: .recommendationExportJobs)
        var recommendationExportJobsDecoded0:[RecommendationExportJob]? = nil
        if let recommendationExportJobsContainer = recommendationExportJobsContainer {
            recommendationExportJobsDecoded0 = [RecommendationExportJob]()
            for structure0 in recommendationExportJobsContainer {
                if let structure0 = structure0 {
                    recommendationExportJobsDecoded0?.append(structure0)
                }
            }
        }
        recommendationExportJobs = recommendationExportJobsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension EBSFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name
        case values
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for filtervalues0 in values {
                try valuesContainer.encode(filtervalues0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(EBSFilterName.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .values)
        var valuesDecoded0:[String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension EBSFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EBSFilter(name: \(String(describing: name)), values: \(String(describing: values)))"}
}

/// <p>Describes a filter that returns a more specific list of Amazon Elastic Block Store (Amazon EBS) volume
///             recommendations. Use this filter with the <code>GetEBSVolumeRecommendations</code>
///             action.</p>
///
///         <p>You can use <code>LambdaFunctionRecommendationFilter</code> with the
///                 <code>GetLambdaFunctionRecommendations</code> action, <code>JobFilter</code> with
///             the <code>DescribeRecommendationExportJobs</code> action, and <code>Filter</code> with
///             the <code>GetAutoScalingGroupRecommendations</code> and
///                 <code>GetEC2InstanceRecommendations</code> actions.</p>
public struct EBSFilter: Equatable {
    /// <p>The name of the filter.</p>
    ///
    ///         <p>Specify <code>Finding</code> to return recommendations with a specific finding
    ///             classification (e.g., <code>NotOptimized</code>).</p>
    public let name: EBSFilterName?
    /// <p>The value of the filter.</p>
    ///
    ///         <p>The valid values are <code>Optimized</code>, or <code>NotOptimized</code>.</p>
    public let values: [String]?

    public init (
        name: EBSFilterName? = nil,
        values: [String]? = nil
    )
    {
        self.name = name
        self.values = values
    }
}

public enum EBSFilterName {
    case finding
    case sdkUnknown(String)
}

extension EBSFilterName : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [EBSFilterName] {
        return [
            .finding,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .finding: return "Finding"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = EBSFilterName(rawValue: rawValue) ?? EBSFilterName.sdkUnknown(rawValue)
    }
}

public enum EBSFinding {
    case notOptimized
    case optimized
    case sdkUnknown(String)
}

extension EBSFinding : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [EBSFinding] {
        return [
            .notOptimized,
            .optimized,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .notOptimized: return "NotOptimized"
        case .optimized: return "Optimized"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = EBSFinding(rawValue: rawValue) ?? EBSFinding.sdkUnknown(rawValue)
    }
}

public enum EBSMetricName {
    case volumeReadBytesPerSecond
    case volumeReadOpsPerSecond
    case volumeWriteBytesPerSecond
    case volumeWriteOpsPerSecond
    case sdkUnknown(String)
}

extension EBSMetricName : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [EBSMetricName] {
        return [
            .volumeReadBytesPerSecond,
            .volumeReadOpsPerSecond,
            .volumeWriteBytesPerSecond,
            .volumeWriteOpsPerSecond,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .volumeReadBytesPerSecond: return "VolumeReadBytesPerSecond"
        case .volumeReadOpsPerSecond: return "VolumeReadOpsPerSecond"
        case .volumeWriteBytesPerSecond: return "VolumeWriteBytesPerSecond"
        case .volumeWriteOpsPerSecond: return "VolumeWriteOpsPerSecond"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = EBSMetricName(rawValue: rawValue) ?? EBSMetricName.sdkUnknown(rawValue)
    }
}

extension EBSUtilizationMetric: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name
        case statistic
        case value
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let statistic = statistic {
            try encodeContainer.encode(statistic.rawValue, forKey: .statistic)
        }
        if value != 0.0 {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(EBSMetricName.self, forKey: .name)
        name = nameDecoded
        let statisticDecoded = try containerValues.decodeIfPresent(MetricStatistic.self, forKey: .statistic)
        statistic = statisticDecoded
        let valueDecoded = try containerValues.decode(Double.self, forKey: .value)
        value = valueDecoded
    }
}

extension EBSUtilizationMetric: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EBSUtilizationMetric(name: \(String(describing: name)), statistic: \(String(describing: statistic)), value: \(String(describing: value)))"}
}

/// <p>Describes a utilization metric of an Amazon Elastic Block Store (Amazon EBS) volume.</p>
///
///         <p>Compare the utilization metric data of your resource against its projected utilization
///             metric data to determine the performance difference between your current resource and
///             the recommended option.</p>
public struct EBSUtilizationMetric: Equatable {
    /// <p>The name of the utilization metric.</p>
    ///         <p>The following utilization metrics are available:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <code>VolumeReadOpsPerSecond</code> - The completed read operations per second
    ///                     from the volume in a specified period of time.</p>
    ///                 <p>Unit: Count</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>VolumeWriteOpsPerSecond</code> - The completed write operations per
    ///                     second to the volume in a specified period of time.</p>
    ///                 <p>Unit: Count</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>VolumeReadBytesPerSecond</code> - The bytes read per second from the
    ///                     volume in a specified period of time.</p>
    ///                 <p>Unit: Bytes</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>VolumeWriteBytesPerSecond</code> - The bytes written to the volume in a
    ///                     specified period of time.</p>
    ///                 <p>Unit: Bytes</p>
    ///             </li>
    ///          </ul>
    public let name: EBSMetricName?
    /// <p>The statistic of the utilization metric.</p>
    ///
    ///         <p>The Compute Optimizer API, AWS Command Line Interface (AWS CLI), and SDKs return utilization metrics using
    ///             only the <code>Maximum</code> statistic, which is the highest value observed during the
    ///             specified period.</p>
    ///
    ///
    ///
    ///         <p>The Compute Optimizer console displays graphs for some utilization metrics using the
    ///                 <code>Average</code> statistic, which is the value of <code>Sum</code> /
    ///                 <code>SampleCount</code> during the specified period. For more information, see
    ///                 <a href="https://docs.aws.amazon.com/compute-optimizer/latest/ug/viewing-recommendations.html">Viewing resource
    ///                 recommendations</a> in the <i>AWS Compute Optimizer User Guide</i>. You can
    ///             also get averaged utilization metric data for your resources using Amazon CloudWatch. For more
    ///             information, see the <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/WhatIsCloudWatch.html">Amazon CloudWatch User
    ///                 Guide</a>.</p>
    public let statistic: MetricStatistic?
    /// <p>The value of the utilization metric.</p>
    public let value: Double

    public init (
        name: EBSMetricName? = nil,
        statistic: MetricStatistic? = nil,
        value: Double = 0.0
    )
    {
        self.name = name
        self.statistic = statistic
        self.value = value
    }
}

public struct ExportAutoScalingGroupRecommendationsInputBodyMiddleware: Middleware {
    public let id: String = "ExportAutoScalingGroupRecommendationsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ExportAutoScalingGroupRecommendationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ExportAutoScalingGroupRecommendationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ExportAutoScalingGroupRecommendationsInput>
    public typealias MOutput = OperationOutput<ExportAutoScalingGroupRecommendationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ExportAutoScalingGroupRecommendationsOutputError>
}

extension ExportAutoScalingGroupRecommendationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ExportAutoScalingGroupRecommendationsInput(accountIds: \(String(describing: accountIds)), fieldsToExport: \(String(describing: fieldsToExport)), fileFormat: \(String(describing: fileFormat)), filters: \(String(describing: filters)), includeMemberAccounts: \(String(describing: includeMemberAccounts)), s3DestinationConfig: \(String(describing: s3DestinationConfig)))"}
}

extension ExportAutoScalingGroupRecommendationsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountIds
        case fieldsToExport
        case fileFormat
        case filters
        case includeMemberAccounts
        case s3DestinationConfig
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountIds = accountIds {
            var accountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountIds)
            for accountids0 in accountIds {
                try accountIdsContainer.encode(accountids0)
            }
        }
        if let fieldsToExport = fieldsToExport {
            var fieldsToExportContainer = encodeContainer.nestedUnkeyedContainer(forKey: .fieldsToExport)
            for exportableautoscalinggroupfields0 in fieldsToExport {
                try fieldsToExportContainer.encode(exportableautoscalinggroupfields0.rawValue)
            }
        }
        if let fileFormat = fileFormat {
            try encodeContainer.encode(fileFormat.rawValue, forKey: .fileFormat)
        }
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filters0 in filters {
                try filtersContainer.encode(filters0)
            }
        }
        if includeMemberAccounts != false {
            try encodeContainer.encode(includeMemberAccounts, forKey: .includeMemberAccounts)
        }
        if let s3DestinationConfig = s3DestinationConfig {
            try encodeContainer.encode(s3DestinationConfig, forKey: .s3DestinationConfig)
        }
    }
}

public struct ExportAutoScalingGroupRecommendationsInputHeadersMiddleware: Middleware {
    public let id: String = "ExportAutoScalingGroupRecommendationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ExportAutoScalingGroupRecommendationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ExportAutoScalingGroupRecommendationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ExportAutoScalingGroupRecommendationsInput>
    public typealias MOutput = OperationOutput<ExportAutoScalingGroupRecommendationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ExportAutoScalingGroupRecommendationsOutputError>
}

public struct ExportAutoScalingGroupRecommendationsInputQueryItemMiddleware: Middleware {
    public let id: String = "ExportAutoScalingGroupRecommendationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ExportAutoScalingGroupRecommendationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ExportAutoScalingGroupRecommendationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ExportAutoScalingGroupRecommendationsInput>
    public typealias MOutput = OperationOutput<ExportAutoScalingGroupRecommendationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ExportAutoScalingGroupRecommendationsOutputError>
}

public struct ExportAutoScalingGroupRecommendationsInput: Equatable {
    /// <p>The IDs of the AWS accounts for which to export Auto Scaling group
    ///             recommendations.</p>
    ///
    ///
    ///
    ///         <p>If your account is the management account of an organization, use this parameter to
    ///             specify the member account for which you want to export recommendations.</p>
    ///         <p>This parameter cannot be specified together with the include member accounts
    ///             parameter. The parameters are mutually exclusive.</p>
    ///         <p>Recommendations for member accounts are not included in the export if this parameter,
    ///             or the include member accounts parameter, is omitted.</p>
    ///         <p>You can specify multiple account IDs per request.</p>
    public let accountIds: [String]?
    /// <p>The recommendations data to include in the export file. For more information about the
    ///             fields that can be exported, see <a href="https://docs.aws.amazon.com/compute-optimizer/latest/ug/exporting-recommendations.html#exported-files">Exported files</a> in the <i>Compute Optimizer User Guide</i>.</p>
    public let fieldsToExport: [ExportableAutoScalingGroupField]?
    /// <p>The format of the export file.</p>
    ///         <p>The only export file format currently supported is <code>Csv</code>.</p>
    public let fileFormat: FileFormat?
    /// <p>An array of objects that describe a filter to export a more specific set of Auto Scaling group
    ///             recommendations.</p>
    public let filters: [Filter]?
    /// <p>Indicates whether to include recommendations for resources in all member accounts of
    ///             the organization if your account is the management account of an organization.</p>
    ///
    ///         <p>The member accounts must also be opted in to Compute Optimizer, and trusted access for
    ///             Compute Optimizer must be enabled in the organization account. For more information, see <a href="https://docs.aws.amazon.com/compute-optimizer/latest/ug/security-iam.html#trusted-service-access">Compute Optimizer and
    ///                 AWS Organizations trusted access</a> in the <i>AWS Compute Optimizer User
    ///                 Guide</i>.</p>
    ///
    ///
    ///
    ///         <p>Recommendations for member accounts of the organization are not included in the export
    ///             file if this parameter is omitted.</p>
    ///         <p>This parameter cannot be specified together with the account IDs parameter. The
    ///             parameters are mutually exclusive.</p>
    ///         <p>Recommendations for member accounts are not included in the export if this parameter,
    ///             or the account IDs parameter, is omitted.</p>
    public let includeMemberAccounts: Bool
    /// <p>An object to specify the destination Amazon Simple Storage Service (Amazon S3) bucket name and key prefix for
    ///             the export job.</p>
    ///         <p>You must create the destination Amazon S3 bucket for your recommendations export before you
    ///             create the export job. Compute Optimizer does not create the S3 bucket for you. After you create the
    ///             S3 bucket, ensure that it has the required permission policy to allow Compute Optimizer to write the
    ///             export file to it. If you plan to specify an object prefix when you create the export
    ///             job, you must include the object prefix in the policy that you add to the S3 bucket. For
    ///             more information, see <a href="https://docs.aws.amazon.com/compute-optimizer/latest/ug/create-s3-bucket-policy-for-compute-optimizer.html">Amazon S3 Bucket Policy for Compute Optimizer</a> in the <i>Compute Optimizer user
    ///             guide</i>.</p>
    public let s3DestinationConfig: S3DestinationConfig?

    public init (
        accountIds: [String]? = nil,
        fieldsToExport: [ExportableAutoScalingGroupField]? = nil,
        fileFormat: FileFormat? = nil,
        filters: [Filter]? = nil,
        includeMemberAccounts: Bool = false,
        s3DestinationConfig: S3DestinationConfig? = nil
    )
    {
        self.accountIds = accountIds
        self.fieldsToExport = fieldsToExport
        self.fileFormat = fileFormat
        self.filters = filters
        self.includeMemberAccounts = includeMemberAccounts
        self.s3DestinationConfig = s3DestinationConfig
    }
}

struct ExportAutoScalingGroupRecommendationsInputBody: Equatable {
    public let accountIds: [String]?
    public let filters: [Filter]?
    public let fieldsToExport: [ExportableAutoScalingGroupField]?
    public let s3DestinationConfig: S3DestinationConfig?
    public let fileFormat: FileFormat?
    public let includeMemberAccounts: Bool
}

extension ExportAutoScalingGroupRecommendationsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accountIds
        case fieldsToExport
        case fileFormat
        case filters
        case includeMemberAccounts
        case s3DestinationConfig
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .accountIds)
        var accountIdsDecoded0:[String]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [String]()
            for string0 in accountIdsContainer {
                if let string0 = string0 {
                    accountIdsDecoded0?.append(string0)
                }
            }
        }
        accountIds = accountIdsDecoded0
        let filtersContainer = try containerValues.decodeIfPresent([Filter?].self, forKey: .filters)
        var filtersDecoded0:[Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let fieldsToExportContainer = try containerValues.decodeIfPresent([ExportableAutoScalingGroupField?].self, forKey: .fieldsToExport)
        var fieldsToExportDecoded0:[ExportableAutoScalingGroupField]? = nil
        if let fieldsToExportContainer = fieldsToExportContainer {
            fieldsToExportDecoded0 = [ExportableAutoScalingGroupField]()
            for string0 in fieldsToExportContainer {
                if let string0 = string0 {
                    fieldsToExportDecoded0?.append(string0)
                }
            }
        }
        fieldsToExport = fieldsToExportDecoded0
        let s3DestinationConfigDecoded = try containerValues.decodeIfPresent(S3DestinationConfig.self, forKey: .s3DestinationConfig)
        s3DestinationConfig = s3DestinationConfigDecoded
        let fileFormatDecoded = try containerValues.decodeIfPresent(FileFormat.self, forKey: .fileFormat)
        fileFormat = fileFormatDecoded
        let includeMemberAccountsDecoded = try containerValues.decode(Bool.self, forKey: .includeMemberAccounts)
        includeMemberAccounts = includeMemberAccountsDecoded
    }
}

extension ExportAutoScalingGroupRecommendationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ExportAutoScalingGroupRecommendationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingAuthenticationToken" : self = .missingAuthenticationToken(try MissingAuthenticationToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OptInRequiredException" : self = .optInRequiredException(try OptInRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ExportAutoScalingGroupRecommendationsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case invalidParameterValueException(InvalidParameterValueException)
    case limitExceededException(LimitExceededException)
    case missingAuthenticationToken(MissingAuthenticationToken)
    case optInRequiredException(OptInRequiredException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ExportAutoScalingGroupRecommendationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ExportAutoScalingGroupRecommendationsOutputResponse(jobId: \(String(describing: jobId)), s3Destination: \(String(describing: s3Destination)))"}
}

extension ExportAutoScalingGroupRecommendationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ExportAutoScalingGroupRecommendationsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.jobId = output.jobId
            self.s3Destination = output.s3Destination
        } else {
            self.jobId = nil
            self.s3Destination = nil
        }
    }
}

public struct ExportAutoScalingGroupRecommendationsOutputResponse: Equatable {
    /// <p>The identification number of the export job.</p>
    ///         <p>Use the <code>DescribeRecommendationExportJobs</code> action, and specify the job ID
    ///             to view the status of an export job.</p>
    public let jobId: String?
    /// <p>An object that describes the destination Amazon S3 bucket of a recommendations export
    ///             file.</p>
    public let s3Destination: S3Destination?

    public init (
        jobId: String? = nil,
        s3Destination: S3Destination? = nil
    )
    {
        self.jobId = jobId
        self.s3Destination = s3Destination
    }
}

struct ExportAutoScalingGroupRecommendationsOutputResponseBody: Equatable {
    public let jobId: String?
    public let s3Destination: S3Destination?
}

extension ExportAutoScalingGroupRecommendationsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobId
        case s3Destination
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let s3DestinationDecoded = try containerValues.decodeIfPresent(S3Destination.self, forKey: .s3Destination)
        s3Destination = s3DestinationDecoded
    }
}

extension ExportDestination: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case s3
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3 = s3 {
            try encodeContainer.encode(s3, forKey: .s3)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3Decoded = try containerValues.decodeIfPresent(S3Destination.self, forKey: .s3)
        s3 = s3Decoded
    }
}

extension ExportDestination: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ExportDestination(s3: \(String(describing: s3)))"}
}

/// <p>Describes the destination of the recommendations export and metadata files.</p>
public struct ExportDestination: Equatable {
    /// <p>An object that describes the destination Amazon Simple Storage Service (Amazon S3) bucket name and object keys
    ///             of a recommendations export file, and its associated metadata file.</p>
    public let s3: S3Destination?

    public init (
        s3: S3Destination? = nil
    )
    {
        self.s3 = s3
    }
}

public struct ExportEBSVolumeRecommendationsInputBodyMiddleware: Middleware {
    public let id: String = "ExportEBSVolumeRecommendationsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ExportEBSVolumeRecommendationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ExportEBSVolumeRecommendationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ExportEBSVolumeRecommendationsInput>
    public typealias MOutput = OperationOutput<ExportEBSVolumeRecommendationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ExportEBSVolumeRecommendationsOutputError>
}

extension ExportEBSVolumeRecommendationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ExportEBSVolumeRecommendationsInput(accountIds: \(String(describing: accountIds)), fieldsToExport: \(String(describing: fieldsToExport)), fileFormat: \(String(describing: fileFormat)), filters: \(String(describing: filters)), includeMemberAccounts: \(String(describing: includeMemberAccounts)), s3DestinationConfig: \(String(describing: s3DestinationConfig)))"}
}

extension ExportEBSVolumeRecommendationsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountIds
        case fieldsToExport
        case fileFormat
        case filters
        case includeMemberAccounts
        case s3DestinationConfig
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountIds = accountIds {
            var accountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountIds)
            for accountids0 in accountIds {
                try accountIdsContainer.encode(accountids0)
            }
        }
        if let fieldsToExport = fieldsToExport {
            var fieldsToExportContainer = encodeContainer.nestedUnkeyedContainer(forKey: .fieldsToExport)
            for exportablevolumefields0 in fieldsToExport {
                try fieldsToExportContainer.encode(exportablevolumefields0.rawValue)
            }
        }
        if let fileFormat = fileFormat {
            try encodeContainer.encode(fileFormat.rawValue, forKey: .fileFormat)
        }
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for ebsfilters0 in filters {
                try filtersContainer.encode(ebsfilters0)
            }
        }
        if includeMemberAccounts != false {
            try encodeContainer.encode(includeMemberAccounts, forKey: .includeMemberAccounts)
        }
        if let s3DestinationConfig = s3DestinationConfig {
            try encodeContainer.encode(s3DestinationConfig, forKey: .s3DestinationConfig)
        }
    }
}

public struct ExportEBSVolumeRecommendationsInputHeadersMiddleware: Middleware {
    public let id: String = "ExportEBSVolumeRecommendationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ExportEBSVolumeRecommendationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ExportEBSVolumeRecommendationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ExportEBSVolumeRecommendationsInput>
    public typealias MOutput = OperationOutput<ExportEBSVolumeRecommendationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ExportEBSVolumeRecommendationsOutputError>
}

public struct ExportEBSVolumeRecommendationsInputQueryItemMiddleware: Middleware {
    public let id: String = "ExportEBSVolumeRecommendationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ExportEBSVolumeRecommendationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ExportEBSVolumeRecommendationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ExportEBSVolumeRecommendationsInput>
    public typealias MOutput = OperationOutput<ExportEBSVolumeRecommendationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ExportEBSVolumeRecommendationsOutputError>
}

public struct ExportEBSVolumeRecommendationsInput: Equatable {
    /// <p>The IDs of the AWS accounts for which to export Amazon EBS volume
    ///             recommendations.</p>
    ///
    ///
    ///
    ///         <p>If your account is the management account of an organization, use this parameter to
    ///             specify the member account for which you want to export recommendations.</p>
    ///         <p>This parameter cannot be specified together with the include member accounts
    ///             parameter. The parameters are mutually exclusive.</p>
    ///         <p>Recommendations for member accounts are not included in the export if this parameter,
    ///             or the include member accounts parameter, is omitted.</p>
    ///         <p>You can specify multiple account IDs per request.</p>
    public let accountIds: [String]?
    /// <p>The recommendations data to include in the export file. For more information about the
    ///             fields that can be exported, see <a href="https://docs.aws.amazon.com/compute-optimizer/latest/ug/exporting-recommendations.html#exported-files">Exported files</a> in the <i>Compute Optimizer User Guide</i>.</p>
    public let fieldsToExport: [ExportableVolumeField]?
    /// <p>The format of the export file.</p>
    ///         <p>The only export file format currently supported is <code>Csv</code>.</p>
    public let fileFormat: FileFormat?
    /// <p>An array of objects that describe a filter to export a more specific set of Amazon EBS
    ///             volume recommendations.</p>
    public let filters: [EBSFilter]?
    /// <p>Indicates whether to include recommendations for resources in all member accounts of
    ///             the organization if your account is the management account of an organization.</p>
    ///
    ///         <p>The member accounts must also be opted in to Compute Optimizer, and trusted access for
    ///             Compute Optimizer must be enabled in the organization account. For more information, see <a href="https://docs.aws.amazon.com/compute-optimizer/latest/ug/security-iam.html#trusted-service-access">Compute Optimizer and
    ///                 AWS Organizations trusted access</a> in the <i>AWS Compute Optimizer User
    ///                 Guide</i>.</p>
    ///
    ///
    ///
    ///         <p>Recommendations for member accounts of the organization are not included in the export
    ///             file if this parameter is omitted.</p>
    ///         <p>This parameter cannot be specified together with the account IDs parameter. The
    ///             parameters are mutually exclusive.</p>
    ///         <p>Recommendations for member accounts are not included in the export if this parameter,
    ///             or the account IDs parameter, is omitted.</p>
    public let includeMemberAccounts: Bool
    /// <p>Describes the destination Amazon Simple Storage Service (Amazon S3) bucket name and key prefix for a
    ///             recommendations export job.</p>
    ///         <p>You must create the destination Amazon S3 bucket for your recommendations export before you
    ///             create the export job. Compute Optimizer does not create the S3 bucket for you. After you create the
    ///             S3 bucket, ensure that it has the required permission policy to allow Compute Optimizer to write the
    ///             export file to it. If you plan to specify an object prefix when you create the export
    ///             job, you must include the object prefix in the policy that you add to the S3 bucket. For
    ///             more information, see <a href="https://docs.aws.amazon.com/compute-optimizer/latest/ug/create-s3-bucket-policy-for-compute-optimizer.html">Amazon S3 Bucket Policy for Compute Optimizer</a> in the <i>Compute Optimizer user
    ///             guide</i>.</p>
    public let s3DestinationConfig: S3DestinationConfig?

    public init (
        accountIds: [String]? = nil,
        fieldsToExport: [ExportableVolumeField]? = nil,
        fileFormat: FileFormat? = nil,
        filters: [EBSFilter]? = nil,
        includeMemberAccounts: Bool = false,
        s3DestinationConfig: S3DestinationConfig? = nil
    )
    {
        self.accountIds = accountIds
        self.fieldsToExport = fieldsToExport
        self.fileFormat = fileFormat
        self.filters = filters
        self.includeMemberAccounts = includeMemberAccounts
        self.s3DestinationConfig = s3DestinationConfig
    }
}

struct ExportEBSVolumeRecommendationsInputBody: Equatable {
    public let accountIds: [String]?
    public let filters: [EBSFilter]?
    public let fieldsToExport: [ExportableVolumeField]?
    public let s3DestinationConfig: S3DestinationConfig?
    public let fileFormat: FileFormat?
    public let includeMemberAccounts: Bool
}

extension ExportEBSVolumeRecommendationsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accountIds
        case fieldsToExport
        case fileFormat
        case filters
        case includeMemberAccounts
        case s3DestinationConfig
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .accountIds)
        var accountIdsDecoded0:[String]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [String]()
            for string0 in accountIdsContainer {
                if let string0 = string0 {
                    accountIdsDecoded0?.append(string0)
                }
            }
        }
        accountIds = accountIdsDecoded0
        let filtersContainer = try containerValues.decodeIfPresent([EBSFilter?].self, forKey: .filters)
        var filtersDecoded0:[EBSFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [EBSFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let fieldsToExportContainer = try containerValues.decodeIfPresent([ExportableVolumeField?].self, forKey: .fieldsToExport)
        var fieldsToExportDecoded0:[ExportableVolumeField]? = nil
        if let fieldsToExportContainer = fieldsToExportContainer {
            fieldsToExportDecoded0 = [ExportableVolumeField]()
            for string0 in fieldsToExportContainer {
                if let string0 = string0 {
                    fieldsToExportDecoded0?.append(string0)
                }
            }
        }
        fieldsToExport = fieldsToExportDecoded0
        let s3DestinationConfigDecoded = try containerValues.decodeIfPresent(S3DestinationConfig.self, forKey: .s3DestinationConfig)
        s3DestinationConfig = s3DestinationConfigDecoded
        let fileFormatDecoded = try containerValues.decodeIfPresent(FileFormat.self, forKey: .fileFormat)
        fileFormat = fileFormatDecoded
        let includeMemberAccountsDecoded = try containerValues.decode(Bool.self, forKey: .includeMemberAccounts)
        includeMemberAccounts = includeMemberAccountsDecoded
    }
}

extension ExportEBSVolumeRecommendationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ExportEBSVolumeRecommendationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingAuthenticationToken" : self = .missingAuthenticationToken(try MissingAuthenticationToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OptInRequiredException" : self = .optInRequiredException(try OptInRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ExportEBSVolumeRecommendationsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case invalidParameterValueException(InvalidParameterValueException)
    case limitExceededException(LimitExceededException)
    case missingAuthenticationToken(MissingAuthenticationToken)
    case optInRequiredException(OptInRequiredException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ExportEBSVolumeRecommendationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ExportEBSVolumeRecommendationsOutputResponse(jobId: \(String(describing: jobId)), s3Destination: \(String(describing: s3Destination)))"}
}

extension ExportEBSVolumeRecommendationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ExportEBSVolumeRecommendationsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.jobId = output.jobId
            self.s3Destination = output.s3Destination
        } else {
            self.jobId = nil
            self.s3Destination = nil
        }
    }
}

public struct ExportEBSVolumeRecommendationsOutputResponse: Equatable {
    /// <p>The identification number of the export job.</p>
    ///         <p>Use the <code>DescribeRecommendationExportJobs</code> action, and specify the job ID
    ///             to view the status of an export job.</p>
    public let jobId: String?
    /// <p>Describes the destination Amazon Simple Storage Service (Amazon S3) bucket name and object keys of a
    ///             recommendations export file, and its associated metadata file.</p>
    public let s3Destination: S3Destination?

    public init (
        jobId: String? = nil,
        s3Destination: S3Destination? = nil
    )
    {
        self.jobId = jobId
        self.s3Destination = s3Destination
    }
}

struct ExportEBSVolumeRecommendationsOutputResponseBody: Equatable {
    public let jobId: String?
    public let s3Destination: S3Destination?
}

extension ExportEBSVolumeRecommendationsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobId
        case s3Destination
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let s3DestinationDecoded = try containerValues.decodeIfPresent(S3Destination.self, forKey: .s3Destination)
        s3Destination = s3DestinationDecoded
    }
}

public struct ExportEC2InstanceRecommendationsInputBodyMiddleware: Middleware {
    public let id: String = "ExportEC2InstanceRecommendationsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ExportEC2InstanceRecommendationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ExportEC2InstanceRecommendationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ExportEC2InstanceRecommendationsInput>
    public typealias MOutput = OperationOutput<ExportEC2InstanceRecommendationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ExportEC2InstanceRecommendationsOutputError>
}

extension ExportEC2InstanceRecommendationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ExportEC2InstanceRecommendationsInput(accountIds: \(String(describing: accountIds)), fieldsToExport: \(String(describing: fieldsToExport)), fileFormat: \(String(describing: fileFormat)), filters: \(String(describing: filters)), includeMemberAccounts: \(String(describing: includeMemberAccounts)), s3DestinationConfig: \(String(describing: s3DestinationConfig)))"}
}

extension ExportEC2InstanceRecommendationsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountIds
        case fieldsToExport
        case fileFormat
        case filters
        case includeMemberAccounts
        case s3DestinationConfig
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountIds = accountIds {
            var accountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountIds)
            for accountids0 in accountIds {
                try accountIdsContainer.encode(accountids0)
            }
        }
        if let fieldsToExport = fieldsToExport {
            var fieldsToExportContainer = encodeContainer.nestedUnkeyedContainer(forKey: .fieldsToExport)
            for exportableinstancefields0 in fieldsToExport {
                try fieldsToExportContainer.encode(exportableinstancefields0.rawValue)
            }
        }
        if let fileFormat = fileFormat {
            try encodeContainer.encode(fileFormat.rawValue, forKey: .fileFormat)
        }
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filters0 in filters {
                try filtersContainer.encode(filters0)
            }
        }
        if includeMemberAccounts != false {
            try encodeContainer.encode(includeMemberAccounts, forKey: .includeMemberAccounts)
        }
        if let s3DestinationConfig = s3DestinationConfig {
            try encodeContainer.encode(s3DestinationConfig, forKey: .s3DestinationConfig)
        }
    }
}

public struct ExportEC2InstanceRecommendationsInputHeadersMiddleware: Middleware {
    public let id: String = "ExportEC2InstanceRecommendationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ExportEC2InstanceRecommendationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ExportEC2InstanceRecommendationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ExportEC2InstanceRecommendationsInput>
    public typealias MOutput = OperationOutput<ExportEC2InstanceRecommendationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ExportEC2InstanceRecommendationsOutputError>
}

public struct ExportEC2InstanceRecommendationsInputQueryItemMiddleware: Middleware {
    public let id: String = "ExportEC2InstanceRecommendationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ExportEC2InstanceRecommendationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ExportEC2InstanceRecommendationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ExportEC2InstanceRecommendationsInput>
    public typealias MOutput = OperationOutput<ExportEC2InstanceRecommendationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ExportEC2InstanceRecommendationsOutputError>
}

public struct ExportEC2InstanceRecommendationsInput: Equatable {
    /// <p>The IDs of the AWS accounts for which to export instance
    ///             recommendations.</p>
    ///
    ///
    ///
    ///         <p>If your account is the management account of an organization, use this parameter to
    ///             specify the member account for which you want to export recommendations.</p>
    ///         <p>This parameter cannot be specified together with the include member accounts
    ///             parameter. The parameters are mutually exclusive.</p>
    ///         <p>Recommendations for member accounts are not included in the export if this parameter,
    ///             or the include member accounts parameter, is omitted.</p>
    ///         <p>You can specify multiple account IDs per request.</p>
    public let accountIds: [String]?
    /// <p>The recommendations data to include in the export file. For more information about the
    ///             fields that can be exported, see <a href="https://docs.aws.amazon.com/compute-optimizer/latest/ug/exporting-recommendations.html#exported-files">Exported files</a> in the <i>Compute Optimizer User Guide</i>.</p>
    public let fieldsToExport: [ExportableInstanceField]?
    /// <p>The format of the export file.</p>
    ///         <p>The only export file format currently supported is <code>Csv</code>.</p>
    public let fileFormat: FileFormat?
    /// <p>An array of objects that describe a filter to export a more specific set of instance
    ///             recommendations.</p>
    public let filters: [Filter]?
    /// <p>Indicates whether to include recommendations for resources in all member accounts of
    ///             the organization if your account is the management account of an organization.</p>
    ///
    ///         <p>The member accounts must also be opted in to Compute Optimizer, and trusted access for
    ///             Compute Optimizer must be enabled in the organization account. For more information, see <a href="https://docs.aws.amazon.com/compute-optimizer/latest/ug/security-iam.html#trusted-service-access">Compute Optimizer and
    ///                 AWS Organizations trusted access</a> in the <i>AWS Compute Optimizer User
    ///                 Guide</i>.</p>
    ///
    ///
    ///
    ///         <p>Recommendations for member accounts of the organization are not included in the export
    ///             file if this parameter is omitted.</p>
    ///         <p>Recommendations for member accounts are not included in the export if this parameter,
    ///             or the account IDs parameter, is omitted.</p>
    public let includeMemberAccounts: Bool
    /// <p>An object to specify the destination Amazon Simple Storage Service (Amazon S3) bucket name and key prefix for
    ///             the export job.</p>
    ///         <p>You must create the destination Amazon S3 bucket for your recommendations export before you
    ///             create the export job. Compute Optimizer does not create the S3 bucket for you. After you create the
    ///             S3 bucket, ensure that it has the required permission policy to allow Compute Optimizer to write the
    ///             export file to it. If you plan to specify an object prefix when you create the export
    ///             job, you must include the object prefix in the policy that you add to the S3 bucket. For
    ///             more information, see <a href="https://docs.aws.amazon.com/compute-optimizer/latest/ug/create-s3-bucket-policy-for-compute-optimizer.html">Amazon S3 Bucket Policy for Compute Optimizer</a> in the <i>Compute Optimizer user
    ///             guide</i>.</p>
    public let s3DestinationConfig: S3DestinationConfig?

    public init (
        accountIds: [String]? = nil,
        fieldsToExport: [ExportableInstanceField]? = nil,
        fileFormat: FileFormat? = nil,
        filters: [Filter]? = nil,
        includeMemberAccounts: Bool = false,
        s3DestinationConfig: S3DestinationConfig? = nil
    )
    {
        self.accountIds = accountIds
        self.fieldsToExport = fieldsToExport
        self.fileFormat = fileFormat
        self.filters = filters
        self.includeMemberAccounts = includeMemberAccounts
        self.s3DestinationConfig = s3DestinationConfig
    }
}

struct ExportEC2InstanceRecommendationsInputBody: Equatable {
    public let accountIds: [String]?
    public let filters: [Filter]?
    public let fieldsToExport: [ExportableInstanceField]?
    public let s3DestinationConfig: S3DestinationConfig?
    public let fileFormat: FileFormat?
    public let includeMemberAccounts: Bool
}

extension ExportEC2InstanceRecommendationsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accountIds
        case fieldsToExport
        case fileFormat
        case filters
        case includeMemberAccounts
        case s3DestinationConfig
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .accountIds)
        var accountIdsDecoded0:[String]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [String]()
            for string0 in accountIdsContainer {
                if let string0 = string0 {
                    accountIdsDecoded0?.append(string0)
                }
            }
        }
        accountIds = accountIdsDecoded0
        let filtersContainer = try containerValues.decodeIfPresent([Filter?].self, forKey: .filters)
        var filtersDecoded0:[Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let fieldsToExportContainer = try containerValues.decodeIfPresent([ExportableInstanceField?].self, forKey: .fieldsToExport)
        var fieldsToExportDecoded0:[ExportableInstanceField]? = nil
        if let fieldsToExportContainer = fieldsToExportContainer {
            fieldsToExportDecoded0 = [ExportableInstanceField]()
            for string0 in fieldsToExportContainer {
                if let string0 = string0 {
                    fieldsToExportDecoded0?.append(string0)
                }
            }
        }
        fieldsToExport = fieldsToExportDecoded0
        let s3DestinationConfigDecoded = try containerValues.decodeIfPresent(S3DestinationConfig.self, forKey: .s3DestinationConfig)
        s3DestinationConfig = s3DestinationConfigDecoded
        let fileFormatDecoded = try containerValues.decodeIfPresent(FileFormat.self, forKey: .fileFormat)
        fileFormat = fileFormatDecoded
        let includeMemberAccountsDecoded = try containerValues.decode(Bool.self, forKey: .includeMemberAccounts)
        includeMemberAccounts = includeMemberAccountsDecoded
    }
}

extension ExportEC2InstanceRecommendationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ExportEC2InstanceRecommendationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingAuthenticationToken" : self = .missingAuthenticationToken(try MissingAuthenticationToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OptInRequiredException" : self = .optInRequiredException(try OptInRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ExportEC2InstanceRecommendationsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case invalidParameterValueException(InvalidParameterValueException)
    case limitExceededException(LimitExceededException)
    case missingAuthenticationToken(MissingAuthenticationToken)
    case optInRequiredException(OptInRequiredException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ExportEC2InstanceRecommendationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ExportEC2InstanceRecommendationsOutputResponse(jobId: \(String(describing: jobId)), s3Destination: \(String(describing: s3Destination)))"}
}

extension ExportEC2InstanceRecommendationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ExportEC2InstanceRecommendationsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.jobId = output.jobId
            self.s3Destination = output.s3Destination
        } else {
            self.jobId = nil
            self.s3Destination = nil
        }
    }
}

public struct ExportEC2InstanceRecommendationsOutputResponse: Equatable {
    /// <p>The identification number of the export job.</p>
    ///         <p>Use the <code>DescribeRecommendationExportJobs</code> action, and specify the job ID
    ///             to view the status of an export job.</p>
    public let jobId: String?
    /// <p>An object that describes the destination Amazon S3 bucket of a recommendations export
    ///             file.</p>
    public let s3Destination: S3Destination?

    public init (
        jobId: String? = nil,
        s3Destination: S3Destination? = nil
    )
    {
        self.jobId = jobId
        self.s3Destination = s3Destination
    }
}

struct ExportEC2InstanceRecommendationsOutputResponseBody: Equatable {
    public let jobId: String?
    public let s3Destination: S3Destination?
}

extension ExportEC2InstanceRecommendationsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobId
        case s3Destination
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let s3DestinationDecoded = try containerValues.decodeIfPresent(S3Destination.self, forKey: .s3Destination)
        s3Destination = s3DestinationDecoded
    }
}

public struct ExportLambdaFunctionRecommendationsInputBodyMiddleware: Middleware {
    public let id: String = "ExportLambdaFunctionRecommendationsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ExportLambdaFunctionRecommendationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ExportLambdaFunctionRecommendationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ExportLambdaFunctionRecommendationsInput>
    public typealias MOutput = OperationOutput<ExportLambdaFunctionRecommendationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ExportLambdaFunctionRecommendationsOutputError>
}

extension ExportLambdaFunctionRecommendationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ExportLambdaFunctionRecommendationsInput(accountIds: \(String(describing: accountIds)), fieldsToExport: \(String(describing: fieldsToExport)), fileFormat: \(String(describing: fileFormat)), filters: \(String(describing: filters)), includeMemberAccounts: \(String(describing: includeMemberAccounts)), s3DestinationConfig: \(String(describing: s3DestinationConfig)))"}
}

extension ExportLambdaFunctionRecommendationsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountIds
        case fieldsToExport
        case fileFormat
        case filters
        case includeMemberAccounts
        case s3DestinationConfig
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountIds = accountIds {
            var accountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountIds)
            for accountids0 in accountIds {
                try accountIdsContainer.encode(accountids0)
            }
        }
        if let fieldsToExport = fieldsToExport {
            var fieldsToExportContainer = encodeContainer.nestedUnkeyedContainer(forKey: .fieldsToExport)
            for exportablelambdafunctionfields0 in fieldsToExport {
                try fieldsToExportContainer.encode(exportablelambdafunctionfields0.rawValue)
            }
        }
        if let fileFormat = fileFormat {
            try encodeContainer.encode(fileFormat.rawValue, forKey: .fileFormat)
        }
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for lambdafunctionrecommendationfilters0 in filters {
                try filtersContainer.encode(lambdafunctionrecommendationfilters0)
            }
        }
        if includeMemberAccounts != false {
            try encodeContainer.encode(includeMemberAccounts, forKey: .includeMemberAccounts)
        }
        if let s3DestinationConfig = s3DestinationConfig {
            try encodeContainer.encode(s3DestinationConfig, forKey: .s3DestinationConfig)
        }
    }
}

public struct ExportLambdaFunctionRecommendationsInputHeadersMiddleware: Middleware {
    public let id: String = "ExportLambdaFunctionRecommendationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ExportLambdaFunctionRecommendationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ExportLambdaFunctionRecommendationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ExportLambdaFunctionRecommendationsInput>
    public typealias MOutput = OperationOutput<ExportLambdaFunctionRecommendationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ExportLambdaFunctionRecommendationsOutputError>
}

public struct ExportLambdaFunctionRecommendationsInputQueryItemMiddleware: Middleware {
    public let id: String = "ExportLambdaFunctionRecommendationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ExportLambdaFunctionRecommendationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ExportLambdaFunctionRecommendationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ExportLambdaFunctionRecommendationsInput>
    public typealias MOutput = OperationOutput<ExportLambdaFunctionRecommendationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ExportLambdaFunctionRecommendationsOutputError>
}

public struct ExportLambdaFunctionRecommendationsInput: Equatable {
    /// <p>The IDs of the AWS accounts for which to export Lambda function
    ///             recommendations.</p>
    ///
    ///
    ///
    ///         <p>If your account is the management account of an organization, use this parameter to
    ///             specify the member account for which you want to export recommendations.</p>
    ///         <p>This parameter cannot be specified together with the include member accounts
    ///             parameter. The parameters are mutually exclusive.</p>
    ///         <p>Recommendations for member accounts are not included in the export if this parameter,
    ///             or the include member accounts parameter, is omitted.</p>
    ///         <p>You can specify multiple account IDs per request.</p>
    public let accountIds: [String]?
    /// <p>The recommendations data to include in the export file. For more information about the
    ///             fields that can be exported, see <a href="https://docs.aws.amazon.com/compute-optimizer/latest/ug/exporting-recommendations.html#exported-files">Exported files</a> in the <i>Compute Optimizer User Guide</i>.</p>
    public let fieldsToExport: [ExportableLambdaFunctionField]?
    /// <p>The format of the export file.</p>
    ///         <p>The only export file format currently supported is <code>Csv</code>.</p>
    public let fileFormat: FileFormat?
    /// <p>An array of objects that describe a filter to export a more specific set of Lambda
    ///             function recommendations.</p>
    public let filters: [LambdaFunctionRecommendationFilter]?
    /// <p>Indicates whether to include recommendations for resources in all member accounts of
    ///             the organization if your account is the management account of an organization.</p>
    ///
    ///         <p>The member accounts must also be opted in to Compute Optimizer, and trusted access for
    ///             Compute Optimizer must be enabled in the organization account. For more information, see <a href="https://docs.aws.amazon.com/compute-optimizer/latest/ug/security-iam.html#trusted-service-access">Compute Optimizer and
    ///                 AWS Organizations trusted access</a> in the <i>AWS Compute Optimizer User
    ///                 Guide</i>.</p>
    ///
    ///
    ///
    ///         <p>Recommendations for member accounts of the organization are not included in the export
    ///             file if this parameter is omitted.</p>
    ///         <p>This parameter cannot be specified together with the account IDs parameter. The
    ///             parameters are mutually exclusive.</p>
    ///         <p>Recommendations for member accounts are not included in the export if this parameter,
    ///             or the account IDs parameter, is omitted.</p>
    public let includeMemberAccounts: Bool
    /// <p>Describes the destination Amazon Simple Storage Service (Amazon S3) bucket name and key prefix for a
    ///             recommendations export job.</p>
    ///         <p>You must create the destination Amazon S3 bucket for your recommendations export before you
    ///             create the export job. Compute Optimizer does not create the S3 bucket for you. After you create the
    ///             S3 bucket, ensure that it has the required permission policy to allow Compute Optimizer to write the
    ///             export file to it. If you plan to specify an object prefix when you create the export
    ///             job, you must include the object prefix in the policy that you add to the S3 bucket. For
    ///             more information, see <a href="https://docs.aws.amazon.com/compute-optimizer/latest/ug/create-s3-bucket-policy-for-compute-optimizer.html">Amazon S3 Bucket Policy for Compute Optimizer</a> in the <i>Compute Optimizer user
    ///             guide</i>.</p>
    public let s3DestinationConfig: S3DestinationConfig?

    public init (
        accountIds: [String]? = nil,
        fieldsToExport: [ExportableLambdaFunctionField]? = nil,
        fileFormat: FileFormat? = nil,
        filters: [LambdaFunctionRecommendationFilter]? = nil,
        includeMemberAccounts: Bool = false,
        s3DestinationConfig: S3DestinationConfig? = nil
    )
    {
        self.accountIds = accountIds
        self.fieldsToExport = fieldsToExport
        self.fileFormat = fileFormat
        self.filters = filters
        self.includeMemberAccounts = includeMemberAccounts
        self.s3DestinationConfig = s3DestinationConfig
    }
}

struct ExportLambdaFunctionRecommendationsInputBody: Equatable {
    public let accountIds: [String]?
    public let filters: [LambdaFunctionRecommendationFilter]?
    public let fieldsToExport: [ExportableLambdaFunctionField]?
    public let s3DestinationConfig: S3DestinationConfig?
    public let fileFormat: FileFormat?
    public let includeMemberAccounts: Bool
}

extension ExportLambdaFunctionRecommendationsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accountIds
        case fieldsToExport
        case fileFormat
        case filters
        case includeMemberAccounts
        case s3DestinationConfig
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .accountIds)
        var accountIdsDecoded0:[String]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [String]()
            for string0 in accountIdsContainer {
                if let string0 = string0 {
                    accountIdsDecoded0?.append(string0)
                }
            }
        }
        accountIds = accountIdsDecoded0
        let filtersContainer = try containerValues.decodeIfPresent([LambdaFunctionRecommendationFilter?].self, forKey: .filters)
        var filtersDecoded0:[LambdaFunctionRecommendationFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [LambdaFunctionRecommendationFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let fieldsToExportContainer = try containerValues.decodeIfPresent([ExportableLambdaFunctionField?].self, forKey: .fieldsToExport)
        var fieldsToExportDecoded0:[ExportableLambdaFunctionField]? = nil
        if let fieldsToExportContainer = fieldsToExportContainer {
            fieldsToExportDecoded0 = [ExportableLambdaFunctionField]()
            for string0 in fieldsToExportContainer {
                if let string0 = string0 {
                    fieldsToExportDecoded0?.append(string0)
                }
            }
        }
        fieldsToExport = fieldsToExportDecoded0
        let s3DestinationConfigDecoded = try containerValues.decodeIfPresent(S3DestinationConfig.self, forKey: .s3DestinationConfig)
        s3DestinationConfig = s3DestinationConfigDecoded
        let fileFormatDecoded = try containerValues.decodeIfPresent(FileFormat.self, forKey: .fileFormat)
        fileFormat = fileFormatDecoded
        let includeMemberAccountsDecoded = try containerValues.decode(Bool.self, forKey: .includeMemberAccounts)
        includeMemberAccounts = includeMemberAccountsDecoded
    }
}

extension ExportLambdaFunctionRecommendationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ExportLambdaFunctionRecommendationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingAuthenticationToken" : self = .missingAuthenticationToken(try MissingAuthenticationToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OptInRequiredException" : self = .optInRequiredException(try OptInRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ExportLambdaFunctionRecommendationsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case invalidParameterValueException(InvalidParameterValueException)
    case limitExceededException(LimitExceededException)
    case missingAuthenticationToken(MissingAuthenticationToken)
    case optInRequiredException(OptInRequiredException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ExportLambdaFunctionRecommendationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ExportLambdaFunctionRecommendationsOutputResponse(jobId: \(String(describing: jobId)), s3Destination: \(String(describing: s3Destination)))"}
}

extension ExportLambdaFunctionRecommendationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ExportLambdaFunctionRecommendationsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.jobId = output.jobId
            self.s3Destination = output.s3Destination
        } else {
            self.jobId = nil
            self.s3Destination = nil
        }
    }
}

public struct ExportLambdaFunctionRecommendationsOutputResponse: Equatable {
    /// <p>The identification number of the export job.</p>
    ///         <p>Use the <code>DescribeRecommendationExportJobs</code> action, and specify the job ID
    ///             to view the status of an export job.</p>
    public let jobId: String?
    /// <p>Describes the destination Amazon Simple Storage Service (Amazon S3) bucket name and object keys of a
    ///             recommendations export file, and its associated metadata file.</p>
    public let s3Destination: S3Destination?

    public init (
        jobId: String? = nil,
        s3Destination: S3Destination? = nil
    )
    {
        self.jobId = jobId
        self.s3Destination = s3Destination
    }
}

struct ExportLambdaFunctionRecommendationsOutputResponseBody: Equatable {
    public let jobId: String?
    public let s3Destination: S3Destination?
}

extension ExportLambdaFunctionRecommendationsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobId
        case s3Destination
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let s3DestinationDecoded = try containerValues.decodeIfPresent(S3Destination.self, forKey: .s3Destination)
        s3Destination = s3DestinationDecoded
    }
}

public enum ExportableAutoScalingGroupField {
    case accountId
    case autoScalingGroupArn
    case autoScalingGroupName
    case currentConfigurationDesiredCapacity
    case currentConfigurationInstanceType
    case currentConfigurationMaxSize
    case currentConfigurationMinSize
    case currentMemory
    case currentNetwork
    case currentOnDemandPrice
    case currentStandardOneYearNoUpfrontReservedPrice
    case currentStandardThreeYearNoUpfrontReservedPrice
    case currentStorage
    case currentVcpus
    case finding
    case lastRefreshTimestamp
    case lookbackPeriodInDays
    case recommendationOptionsConfigurationDesiredCapacity
    case recommendationOptionsConfigurationInstanceType
    case recommendationOptionsConfigurationMaxSize
    case recommendationOptionsConfigurationMinSize
    case recommendationOptionsMemory
    case recommendationOptionsNetwork
    case recommendationOptionsOnDemandPrice
    case recommendationOptionsPerformanceRisk
    case recommendationOptionsProjectedUtilizationMetricsCpuMaximum
    case recommendationOptionsProjectedUtilizationMetricsMemoryMaximum
    case recommendationOptionsStandardOneYearNoUpfrontReservedPrice
    case recommendationOptionsStandardThreeYearNoUpfrontReservedPrice
    case recommendationOptionsStorage
    case recommendationOptionsVcpus
    case utilizationMetricsCpuMaximum
    case utilizationMetricsDiskReadBytesPerSecondMaximum
    case utilizationMetricsDiskReadOpsPerSecondMaximum
    case utilizationMetricsDiskWriteBytesPerSecondMaximum
    case utilizationMetricsDiskWriteOpsPerSecondMaximum
    case utilizationMetricsEbsReadBytesPerSecondMaximum
    case utilizationMetricsEbsReadOpsPerSecondMaximum
    case utilizationMetricsEbsWriteBytesPerSecondMaximum
    case utilizationMetricsEbsWriteOpsPerSecondMaximum
    case utilizationMetricsMemoryMaximum
    case utilizationMetricsNetworkInBytesPerSecondMaximum
    case utilizationMetricsNetworkOutBytesPerSecondMaximum
    case utilizationMetricsNetworkPacketsInPerSecondMaximum
    case utilizationMetricsNetworkPacketsOutPerSecondMaximum
    case sdkUnknown(String)
}

extension ExportableAutoScalingGroupField : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ExportableAutoScalingGroupField] {
        return [
            .accountId,
            .autoScalingGroupArn,
            .autoScalingGroupName,
            .currentConfigurationDesiredCapacity,
            .currentConfigurationInstanceType,
            .currentConfigurationMaxSize,
            .currentConfigurationMinSize,
            .currentMemory,
            .currentNetwork,
            .currentOnDemandPrice,
            .currentStandardOneYearNoUpfrontReservedPrice,
            .currentStandardThreeYearNoUpfrontReservedPrice,
            .currentStorage,
            .currentVcpus,
            .finding,
            .lastRefreshTimestamp,
            .lookbackPeriodInDays,
            .recommendationOptionsConfigurationDesiredCapacity,
            .recommendationOptionsConfigurationInstanceType,
            .recommendationOptionsConfigurationMaxSize,
            .recommendationOptionsConfigurationMinSize,
            .recommendationOptionsMemory,
            .recommendationOptionsNetwork,
            .recommendationOptionsOnDemandPrice,
            .recommendationOptionsPerformanceRisk,
            .recommendationOptionsProjectedUtilizationMetricsCpuMaximum,
            .recommendationOptionsProjectedUtilizationMetricsMemoryMaximum,
            .recommendationOptionsStandardOneYearNoUpfrontReservedPrice,
            .recommendationOptionsStandardThreeYearNoUpfrontReservedPrice,
            .recommendationOptionsStorage,
            .recommendationOptionsVcpus,
            .utilizationMetricsCpuMaximum,
            .utilizationMetricsDiskReadBytesPerSecondMaximum,
            .utilizationMetricsDiskReadOpsPerSecondMaximum,
            .utilizationMetricsDiskWriteBytesPerSecondMaximum,
            .utilizationMetricsDiskWriteOpsPerSecondMaximum,
            .utilizationMetricsEbsReadBytesPerSecondMaximum,
            .utilizationMetricsEbsReadOpsPerSecondMaximum,
            .utilizationMetricsEbsWriteBytesPerSecondMaximum,
            .utilizationMetricsEbsWriteOpsPerSecondMaximum,
            .utilizationMetricsMemoryMaximum,
            .utilizationMetricsNetworkInBytesPerSecondMaximum,
            .utilizationMetricsNetworkOutBytesPerSecondMaximum,
            .utilizationMetricsNetworkPacketsInPerSecondMaximum,
            .utilizationMetricsNetworkPacketsOutPerSecondMaximum,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .accountId: return "AccountId"
        case .autoScalingGroupArn: return "AutoScalingGroupArn"
        case .autoScalingGroupName: return "AutoScalingGroupName"
        case .currentConfigurationDesiredCapacity: return "CurrentConfigurationDesiredCapacity"
        case .currentConfigurationInstanceType: return "CurrentConfigurationInstanceType"
        case .currentConfigurationMaxSize: return "CurrentConfigurationMaxSize"
        case .currentConfigurationMinSize: return "CurrentConfigurationMinSize"
        case .currentMemory: return "CurrentMemory"
        case .currentNetwork: return "CurrentNetwork"
        case .currentOnDemandPrice: return "CurrentOnDemandPrice"
        case .currentStandardOneYearNoUpfrontReservedPrice: return "CurrentStandardOneYearNoUpfrontReservedPrice"
        case .currentStandardThreeYearNoUpfrontReservedPrice: return "CurrentStandardThreeYearNoUpfrontReservedPrice"
        case .currentStorage: return "CurrentStorage"
        case .currentVcpus: return "CurrentVCpus"
        case .finding: return "Finding"
        case .lastRefreshTimestamp: return "LastRefreshTimestamp"
        case .lookbackPeriodInDays: return "LookbackPeriodInDays"
        case .recommendationOptionsConfigurationDesiredCapacity: return "RecommendationOptionsConfigurationDesiredCapacity"
        case .recommendationOptionsConfigurationInstanceType: return "RecommendationOptionsConfigurationInstanceType"
        case .recommendationOptionsConfigurationMaxSize: return "RecommendationOptionsConfigurationMaxSize"
        case .recommendationOptionsConfigurationMinSize: return "RecommendationOptionsConfigurationMinSize"
        case .recommendationOptionsMemory: return "RecommendationOptionsMemory"
        case .recommendationOptionsNetwork: return "RecommendationOptionsNetwork"
        case .recommendationOptionsOnDemandPrice: return "RecommendationOptionsOnDemandPrice"
        case .recommendationOptionsPerformanceRisk: return "RecommendationOptionsPerformanceRisk"
        case .recommendationOptionsProjectedUtilizationMetricsCpuMaximum: return "RecommendationOptionsProjectedUtilizationMetricsCpuMaximum"
        case .recommendationOptionsProjectedUtilizationMetricsMemoryMaximum: return "RecommendationOptionsProjectedUtilizationMetricsMemoryMaximum"
        case .recommendationOptionsStandardOneYearNoUpfrontReservedPrice: return "RecommendationOptionsStandardOneYearNoUpfrontReservedPrice"
        case .recommendationOptionsStandardThreeYearNoUpfrontReservedPrice: return "RecommendationOptionsStandardThreeYearNoUpfrontReservedPrice"
        case .recommendationOptionsStorage: return "RecommendationOptionsStorage"
        case .recommendationOptionsVcpus: return "RecommendationOptionsVcpus"
        case .utilizationMetricsCpuMaximum: return "UtilizationMetricsCpuMaximum"
        case .utilizationMetricsDiskReadBytesPerSecondMaximum: return "UtilizationMetricsDiskReadBytesPerSecondMaximum"
        case .utilizationMetricsDiskReadOpsPerSecondMaximum: return "UtilizationMetricsDiskReadOpsPerSecondMaximum"
        case .utilizationMetricsDiskWriteBytesPerSecondMaximum: return "UtilizationMetricsDiskWriteBytesPerSecondMaximum"
        case .utilizationMetricsDiskWriteOpsPerSecondMaximum: return "UtilizationMetricsDiskWriteOpsPerSecondMaximum"
        case .utilizationMetricsEbsReadBytesPerSecondMaximum: return "UtilizationMetricsEbsReadBytesPerSecondMaximum"
        case .utilizationMetricsEbsReadOpsPerSecondMaximum: return "UtilizationMetricsEbsReadOpsPerSecondMaximum"
        case .utilizationMetricsEbsWriteBytesPerSecondMaximum: return "UtilizationMetricsEbsWriteBytesPerSecondMaximum"
        case .utilizationMetricsEbsWriteOpsPerSecondMaximum: return "UtilizationMetricsEbsWriteOpsPerSecondMaximum"
        case .utilizationMetricsMemoryMaximum: return "UtilizationMetricsMemoryMaximum"
        case .utilizationMetricsNetworkInBytesPerSecondMaximum: return "UtilizationMetricsNetworkInBytesPerSecondMaximum"
        case .utilizationMetricsNetworkOutBytesPerSecondMaximum: return "UtilizationMetricsNetworkOutBytesPerSecondMaximum"
        case .utilizationMetricsNetworkPacketsInPerSecondMaximum: return "UtilizationMetricsNetworkPacketsInPerSecondMaximum"
        case .utilizationMetricsNetworkPacketsOutPerSecondMaximum: return "UtilizationMetricsNetworkPacketsOutPerSecondMaximum"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ExportableAutoScalingGroupField(rawValue: rawValue) ?? ExportableAutoScalingGroupField.sdkUnknown(rawValue)
    }
}

public enum ExportableInstanceField {
    case accountId
    case currentInstanceType
    case currentMemory
    case currentNetwork
    case currentOnDemandPrice
    case currentStandardOneYearNoUpfrontReservedPrice
    case currentStandardThreeYearNoUpfrontReservedPrice
    case currentStorage
    case currentVcpus
    case finding
    case findingReasonCodes
    case instanceArn
    case instanceName
    case lastRefreshTimestamp
    case lookbackPeriodInDays
    case recommendationsSourcesRecommendationSourceArn
    case recommendationsSourcesRecommendationSourceType
    case recommendationOptionsInstanceType
    case recommendationOptionsMemory
    case recommendationOptionsNetwork
    case recommendationOptionsOnDemandPrice
    case recommendationOptionsPerformanceRisk
    case recommendationOptionsPlatformDifferences
    case recommendationOptionsProjectedUtilizationMetricsCpuMaximum
    case recommendationOptionsProjectedUtilizationMetricsMemoryMaximum
    case recommendationOptionsStandardOneYearNoUpfrontReservedPrice
    case recommendationOptionsStandardThreeYearNoUpfrontReservedPrice
    case recommendationOptionsStorage
    case recommendationOptionsVcpus
    case utilizationMetricsCpuMaximum
    case utilizationMetricsDiskReadBytesPerSecondMaximum
    case utilizationMetricsDiskReadOpsPerSecondMaximum
    case utilizationMetricsDiskWriteBytesPerSecondMaximum
    case utilizationMetricsDiskWriteOpsPerSecondMaximum
    case utilizationMetricsEbsReadBytesPerSecondMaximum
    case utilizationMetricsEbsReadOpsPerSecondMaximum
    case utilizationMetricsEbsWriteBytesPerSecondMaximum
    case utilizationMetricsEbsWriteOpsPerSecondMaximum
    case utilizationMetricsMemoryMaximum
    case utilizationMetricsNetworkInBytesPerSecondMaximum
    case utilizationMetricsNetworkOutBytesPerSecondMaximum
    case utilizationMetricsNetworkPacketsInPerSecondMaximum
    case utilizationMetricsNetworkPacketsOutPerSecondMaximum
    case sdkUnknown(String)
}

extension ExportableInstanceField : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ExportableInstanceField] {
        return [
            .accountId,
            .currentInstanceType,
            .currentMemory,
            .currentNetwork,
            .currentOnDemandPrice,
            .currentStandardOneYearNoUpfrontReservedPrice,
            .currentStandardThreeYearNoUpfrontReservedPrice,
            .currentStorage,
            .currentVcpus,
            .finding,
            .findingReasonCodes,
            .instanceArn,
            .instanceName,
            .lastRefreshTimestamp,
            .lookbackPeriodInDays,
            .recommendationsSourcesRecommendationSourceArn,
            .recommendationsSourcesRecommendationSourceType,
            .recommendationOptionsInstanceType,
            .recommendationOptionsMemory,
            .recommendationOptionsNetwork,
            .recommendationOptionsOnDemandPrice,
            .recommendationOptionsPerformanceRisk,
            .recommendationOptionsPlatformDifferences,
            .recommendationOptionsProjectedUtilizationMetricsCpuMaximum,
            .recommendationOptionsProjectedUtilizationMetricsMemoryMaximum,
            .recommendationOptionsStandardOneYearNoUpfrontReservedPrice,
            .recommendationOptionsStandardThreeYearNoUpfrontReservedPrice,
            .recommendationOptionsStorage,
            .recommendationOptionsVcpus,
            .utilizationMetricsCpuMaximum,
            .utilizationMetricsDiskReadBytesPerSecondMaximum,
            .utilizationMetricsDiskReadOpsPerSecondMaximum,
            .utilizationMetricsDiskWriteBytesPerSecondMaximum,
            .utilizationMetricsDiskWriteOpsPerSecondMaximum,
            .utilizationMetricsEbsReadBytesPerSecondMaximum,
            .utilizationMetricsEbsReadOpsPerSecondMaximum,
            .utilizationMetricsEbsWriteBytesPerSecondMaximum,
            .utilizationMetricsEbsWriteOpsPerSecondMaximum,
            .utilizationMetricsMemoryMaximum,
            .utilizationMetricsNetworkInBytesPerSecondMaximum,
            .utilizationMetricsNetworkOutBytesPerSecondMaximum,
            .utilizationMetricsNetworkPacketsInPerSecondMaximum,
            .utilizationMetricsNetworkPacketsOutPerSecondMaximum,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .accountId: return "AccountId"
        case .currentInstanceType: return "CurrentInstanceType"
        case .currentMemory: return "CurrentMemory"
        case .currentNetwork: return "CurrentNetwork"
        case .currentOnDemandPrice: return "CurrentOnDemandPrice"
        case .currentStandardOneYearNoUpfrontReservedPrice: return "CurrentStandardOneYearNoUpfrontReservedPrice"
        case .currentStandardThreeYearNoUpfrontReservedPrice: return "CurrentStandardThreeYearNoUpfrontReservedPrice"
        case .currentStorage: return "CurrentStorage"
        case .currentVcpus: return "CurrentVCpus"
        case .finding: return "Finding"
        case .findingReasonCodes: return "FindingReasonCodes"
        case .instanceArn: return "InstanceArn"
        case .instanceName: return "InstanceName"
        case .lastRefreshTimestamp: return "LastRefreshTimestamp"
        case .lookbackPeriodInDays: return "LookbackPeriodInDays"
        case .recommendationsSourcesRecommendationSourceArn: return "RecommendationsSourcesRecommendationSourceArn"
        case .recommendationsSourcesRecommendationSourceType: return "RecommendationsSourcesRecommendationSourceType"
        case .recommendationOptionsInstanceType: return "RecommendationOptionsInstanceType"
        case .recommendationOptionsMemory: return "RecommendationOptionsMemory"
        case .recommendationOptionsNetwork: return "RecommendationOptionsNetwork"
        case .recommendationOptionsOnDemandPrice: return "RecommendationOptionsOnDemandPrice"
        case .recommendationOptionsPerformanceRisk: return "RecommendationOptionsPerformanceRisk"
        case .recommendationOptionsPlatformDifferences: return "RecommendationOptionsPlatformDifferences"
        case .recommendationOptionsProjectedUtilizationMetricsCpuMaximum: return "RecommendationOptionsProjectedUtilizationMetricsCpuMaximum"
        case .recommendationOptionsProjectedUtilizationMetricsMemoryMaximum: return "RecommendationOptionsProjectedUtilizationMetricsMemoryMaximum"
        case .recommendationOptionsStandardOneYearNoUpfrontReservedPrice: return "RecommendationOptionsStandardOneYearNoUpfrontReservedPrice"
        case .recommendationOptionsStandardThreeYearNoUpfrontReservedPrice: return "RecommendationOptionsStandardThreeYearNoUpfrontReservedPrice"
        case .recommendationOptionsStorage: return "RecommendationOptionsStorage"
        case .recommendationOptionsVcpus: return "RecommendationOptionsVcpus"
        case .utilizationMetricsCpuMaximum: return "UtilizationMetricsCpuMaximum"
        case .utilizationMetricsDiskReadBytesPerSecondMaximum: return "UtilizationMetricsDiskReadBytesPerSecondMaximum"
        case .utilizationMetricsDiskReadOpsPerSecondMaximum: return "UtilizationMetricsDiskReadOpsPerSecondMaximum"
        case .utilizationMetricsDiskWriteBytesPerSecondMaximum: return "UtilizationMetricsDiskWriteBytesPerSecondMaximum"
        case .utilizationMetricsDiskWriteOpsPerSecondMaximum: return "UtilizationMetricsDiskWriteOpsPerSecondMaximum"
        case .utilizationMetricsEbsReadBytesPerSecondMaximum: return "UtilizationMetricsEbsReadBytesPerSecondMaximum"
        case .utilizationMetricsEbsReadOpsPerSecondMaximum: return "UtilizationMetricsEbsReadOpsPerSecondMaximum"
        case .utilizationMetricsEbsWriteBytesPerSecondMaximum: return "UtilizationMetricsEbsWriteBytesPerSecondMaximum"
        case .utilizationMetricsEbsWriteOpsPerSecondMaximum: return "UtilizationMetricsEbsWriteOpsPerSecondMaximum"
        case .utilizationMetricsMemoryMaximum: return "UtilizationMetricsMemoryMaximum"
        case .utilizationMetricsNetworkInBytesPerSecondMaximum: return "UtilizationMetricsNetworkInBytesPerSecondMaximum"
        case .utilizationMetricsNetworkOutBytesPerSecondMaximum: return "UtilizationMetricsNetworkOutBytesPerSecondMaximum"
        case .utilizationMetricsNetworkPacketsInPerSecondMaximum: return "UtilizationMetricsNetworkPacketsInPerSecondMaximum"
        case .utilizationMetricsNetworkPacketsOutPerSecondMaximum: return "UtilizationMetricsNetworkPacketsOutPerSecondMaximum"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ExportableInstanceField(rawValue: rawValue) ?? ExportableInstanceField.sdkUnknown(rawValue)
    }
}

public enum ExportableLambdaFunctionField {
    case accountId
    case currentConfigurationMemorySize
    case currentConfigurationTimeout
    case currentCostAverage
    case currentCostTotal
    case finding
    case findingReasonCodes
    case functionArn
    case functionVersion
    case lastRefreshTimestamp
    case lookbackPeriodInDays
    case numberOfInvocations
    case recommendationOptionsConfigurationMemorySize
    case recommendationOptionsCostHigh
    case recommendationOptionsCostLow
    case recommendationOptionsProjectedUtilizationMetricsDurationExpected
    case recommendationOptionsProjectedUtilizationMetricsDurationLowerBound
    case recommendationOptionsProjectedUtilizationMetricsDurationUpperBound
    case utilizationMetricsDurationAverage
    case utilizationMetricsDurationMaximum
    case utilizationMetricsMemoryAverage
    case utilizationMetricsMemoryMaximum
    case sdkUnknown(String)
}

extension ExportableLambdaFunctionField : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ExportableLambdaFunctionField] {
        return [
            .accountId,
            .currentConfigurationMemorySize,
            .currentConfigurationTimeout,
            .currentCostAverage,
            .currentCostTotal,
            .finding,
            .findingReasonCodes,
            .functionArn,
            .functionVersion,
            .lastRefreshTimestamp,
            .lookbackPeriodInDays,
            .numberOfInvocations,
            .recommendationOptionsConfigurationMemorySize,
            .recommendationOptionsCostHigh,
            .recommendationOptionsCostLow,
            .recommendationOptionsProjectedUtilizationMetricsDurationExpected,
            .recommendationOptionsProjectedUtilizationMetricsDurationLowerBound,
            .recommendationOptionsProjectedUtilizationMetricsDurationUpperBound,
            .utilizationMetricsDurationAverage,
            .utilizationMetricsDurationMaximum,
            .utilizationMetricsMemoryAverage,
            .utilizationMetricsMemoryMaximum,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .accountId: return "AccountId"
        case .currentConfigurationMemorySize: return "CurrentConfigurationMemorySize"
        case .currentConfigurationTimeout: return "CurrentConfigurationTimeout"
        case .currentCostAverage: return "CurrentCostAverage"
        case .currentCostTotal: return "CurrentCostTotal"
        case .finding: return "Finding"
        case .findingReasonCodes: return "FindingReasonCodes"
        case .functionArn: return "FunctionArn"
        case .functionVersion: return "FunctionVersion"
        case .lastRefreshTimestamp: return "LastRefreshTimestamp"
        case .lookbackPeriodInDays: return "LookbackPeriodInDays"
        case .numberOfInvocations: return "NumberOfInvocations"
        case .recommendationOptionsConfigurationMemorySize: return "RecommendationOptionsConfigurationMemorySize"
        case .recommendationOptionsCostHigh: return "RecommendationOptionsCostHigh"
        case .recommendationOptionsCostLow: return "RecommendationOptionsCostLow"
        case .recommendationOptionsProjectedUtilizationMetricsDurationExpected: return "RecommendationOptionsProjectedUtilizationMetricsDurationExpected"
        case .recommendationOptionsProjectedUtilizationMetricsDurationLowerBound: return "RecommendationOptionsProjectedUtilizationMetricsDurationLowerBound"
        case .recommendationOptionsProjectedUtilizationMetricsDurationUpperBound: return "RecommendationOptionsProjectedUtilizationMetricsDurationUpperBound"
        case .utilizationMetricsDurationAverage: return "UtilizationMetricsDurationAverage"
        case .utilizationMetricsDurationMaximum: return "UtilizationMetricsDurationMaximum"
        case .utilizationMetricsMemoryAverage: return "UtilizationMetricsMemoryAverage"
        case .utilizationMetricsMemoryMaximum: return "UtilizationMetricsMemoryMaximum"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ExportableLambdaFunctionField(rawValue: rawValue) ?? ExportableLambdaFunctionField.sdkUnknown(rawValue)
    }
}

public enum ExportableVolumeField {
    case accountId
    case currentConfigurationVolumeBaselineIops
    case currentConfigurationVolumeBaselineThroughput
    case currentConfigurationVolumeBurstIops
    case currentConfigurationVolumeBurstThroughput
    case currentConfigurationVolumeSize
    case currentConfigurationVolumeType
    case currentMonthlyPrice
    case finding
    case lastRefreshTimestamp
    case lookbackPeriodInDays
    case recommendationOptionsConfigurationVolumeBaselineIops
    case recommendationOptionsConfigurationVolumeBaselineThroughput
    case recommendationOptionsConfigurationVolumeBurstIops
    case recommendationOptionsConfigurationVolumeBurstThroughput
    case recommendationOptionsConfigurationVolumeSize
    case recommendationOptionsConfigurationVolumeType
    case recommendationOptionsMonthlyPrice
    case recommendationOptionsPerformanceRisk
    case utilizationMetricsVolumeReadBytesPerSecondMaximum
    case utilizationMetricsVolumeReadOpsPerSecondMaximum
    case utilizationMetricsVolumeWriteBytesPerSecondMaximum
    case utilizationMetricsVolumeWriteOpsPerSecondMaximum
    case volumeArn
    case sdkUnknown(String)
}

extension ExportableVolumeField : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ExportableVolumeField] {
        return [
            .accountId,
            .currentConfigurationVolumeBaselineIops,
            .currentConfigurationVolumeBaselineThroughput,
            .currentConfigurationVolumeBurstIops,
            .currentConfigurationVolumeBurstThroughput,
            .currentConfigurationVolumeSize,
            .currentConfigurationVolumeType,
            .currentMonthlyPrice,
            .finding,
            .lastRefreshTimestamp,
            .lookbackPeriodInDays,
            .recommendationOptionsConfigurationVolumeBaselineIops,
            .recommendationOptionsConfigurationVolumeBaselineThroughput,
            .recommendationOptionsConfigurationVolumeBurstIops,
            .recommendationOptionsConfigurationVolumeBurstThroughput,
            .recommendationOptionsConfigurationVolumeSize,
            .recommendationOptionsConfigurationVolumeType,
            .recommendationOptionsMonthlyPrice,
            .recommendationOptionsPerformanceRisk,
            .utilizationMetricsVolumeReadBytesPerSecondMaximum,
            .utilizationMetricsVolumeReadOpsPerSecondMaximum,
            .utilizationMetricsVolumeWriteBytesPerSecondMaximum,
            .utilizationMetricsVolumeWriteOpsPerSecondMaximum,
            .volumeArn,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .accountId: return "AccountId"
        case .currentConfigurationVolumeBaselineIops: return "CurrentConfigurationVolumeBaselineIOPS"
        case .currentConfigurationVolumeBaselineThroughput: return "CurrentConfigurationVolumeBaselineThroughput"
        case .currentConfigurationVolumeBurstIops: return "CurrentConfigurationVolumeBurstIOPS"
        case .currentConfigurationVolumeBurstThroughput: return "CurrentConfigurationVolumeBurstThroughput"
        case .currentConfigurationVolumeSize: return "CurrentConfigurationVolumeSize"
        case .currentConfigurationVolumeType: return "CurrentConfigurationVolumeType"
        case .currentMonthlyPrice: return "CurrentMonthlyPrice"
        case .finding: return "Finding"
        case .lastRefreshTimestamp: return "LastRefreshTimestamp"
        case .lookbackPeriodInDays: return "LookbackPeriodInDays"
        case .recommendationOptionsConfigurationVolumeBaselineIops: return "RecommendationOptionsConfigurationVolumeBaselineIOPS"
        case .recommendationOptionsConfigurationVolumeBaselineThroughput: return "RecommendationOptionsConfigurationVolumeBaselineThroughput"
        case .recommendationOptionsConfigurationVolumeBurstIops: return "RecommendationOptionsConfigurationVolumeBurstIOPS"
        case .recommendationOptionsConfigurationVolumeBurstThroughput: return "RecommendationOptionsConfigurationVolumeBurstThroughput"
        case .recommendationOptionsConfigurationVolumeSize: return "RecommendationOptionsConfigurationVolumeSize"
        case .recommendationOptionsConfigurationVolumeType: return "RecommendationOptionsConfigurationVolumeType"
        case .recommendationOptionsMonthlyPrice: return "RecommendationOptionsMonthlyPrice"
        case .recommendationOptionsPerformanceRisk: return "RecommendationOptionsPerformanceRisk"
        case .utilizationMetricsVolumeReadBytesPerSecondMaximum: return "UtilizationMetricsVolumeReadBytesPerSecondMaximum"
        case .utilizationMetricsVolumeReadOpsPerSecondMaximum: return "UtilizationMetricsVolumeReadOpsPerSecondMaximum"
        case .utilizationMetricsVolumeWriteBytesPerSecondMaximum: return "UtilizationMetricsVolumeWriteBytesPerSecondMaximum"
        case .utilizationMetricsVolumeWriteOpsPerSecondMaximum: return "UtilizationMetricsVolumeWriteOpsPerSecondMaximum"
        case .volumeArn: return "VolumeArn"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ExportableVolumeField(rawValue: rawValue) ?? ExportableVolumeField.sdkUnknown(rawValue)
    }
}

public enum FileFormat {
    case csv
    case sdkUnknown(String)
}

extension FileFormat : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [FileFormat] {
        return [
            .csv,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .csv: return "Csv"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = FileFormat(rawValue: rawValue) ?? FileFormat.sdkUnknown(rawValue)
    }
}

extension Filter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name
        case values
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for filtervalues0 in values {
                try valuesContainer.encode(filtervalues0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(FilterName.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .values)
        var valuesDecoded0:[String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension Filter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Filter(name: \(String(describing: name)), values: \(String(describing: values)))"}
}

/// <p>Describes a filter that returns a more specific list of recommendations. Use this
///             filter with the <code>GetAutoScalingGroupRecommendations</code> and
///                 <code>GetEC2InstanceRecommendations</code> actions.</p>
///
///         <p>You can use <code>EBSFilter</code> with the <code>GetEBSVolumeRecommendations</code>
///             action, <code>LambdaFunctionRecommendationFilter</code> with the
///                 <code>GetLambdaFunctionRecommendations</code> action, and <code>JobFilter</code>
///             with the <code>DescribeRecommendationExportJobs</code> action.</p>
public struct Filter: Equatable {
    /// <p>The name of the filter.</p>
    ///
    ///         <p>Specify <code>Finding</code> to return recommendations with a specific finding
    ///             classification (e.g., <code>Underprovisioned</code>).</p>
    ///
    ///         <p>Specify <code>RecommendationSourceType</code> to return recommendations of a specific
    ///             resource type (e.g., <code>Ec2Instance</code>).</p>
    ///
    ///         <p>Specify <code>FindingReasonCodes</code> to return recommendations with a specific
    ///             finding reason code (e.g., <code>CPUUnderprovisioned</code>).</p>
    public let name: FilterName?
    /// <p>The value of the filter.</p>
    ///
    ///         <p>The valid values for this parameter are as follows, depending on what you specify for
    ///             the <code>name</code> parameter and the resource type that you wish to filter results
    ///             for:</p>
    ///
    ///         <ul>
    ///             <li>
    ///                 <p>Specify <code>Optimized</code> or <code>NotOptimized</code> if you specify the
    ///                         <code>name</code> parameter as <code>Finding</code> and you want to filter
    ///                     results for Auto Scaling groups.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Specify <code>Underprovisioned</code>, <code>Overprovisioned</code>, or
    ///                         <code>Optimized</code> if you specify the <code>name</code> parameter as
    ///                         <code>Finding</code> and you want to filter results for EC2
    ///                     instances.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Specify <code>Ec2Instance</code> or <code>AutoScalingGroup</code> if you
    ///                     specify the <code>name</code> parameter as
    ///                     <code>RecommendationSourceType</code>.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Specify one of the following options if you specify the <code>name</code>
    ///                     parameter as <code>FindingReasonCodes</code>:</p>
    ///
    ///                 <ul>
    ///                   <li>
    ///                         <p>
    ///                         <b>
    ///                            <code>CPUOverprovisioned</code>
    ///                         </b> — The
    ///                             instance’s CPU configuration can be sized down while still meeting the
    ///                             performance requirements of your workload.</p>
    ///                     </li>
    ///                   <li>
    ///                         <p>
    ///                         <b>
    ///                            <code>CPUUnderprovisioned</code>
    ///                         </b> —
    ///                             The instance’s CPU configuration doesn't meet the performance
    ///                             requirements of your workload and there is an alternative instance type
    ///                             that provides better CPU performance.</p>
    ///                     </li>
    ///                   <li>
    ///                         <p>
    ///                         <b>
    ///                            <code>MemoryOverprovisioned</code>
    ///                         </b> —
    ///                             The instance’s memory configuration can be sized down while still
    ///                             meeting the performance requirements of your workload.</p>
    ///                     </li>
    ///                   <li>
    ///                         <p>
    ///                         <b>
    ///                            <code>MemoryUnderprovisioned</code>
    ///                         </b> —
    ///                             The instance’s memory configuration doesn't meet the performance
    ///                             requirements of your workload and there is an alternative instance type
    ///                             that provides better memory performance.</p>
    ///                     </li>
    ///                   <li>
    ///                         <p>
    ///                         <b>
    ///                            <code>EBSThroughputOverprovisioned</code>
    ///                         </b> — The
    ///                             instance’s EBS throughput configuration can be sized down while still
    ///                             meeting the performance requirements of your workload.</p>
    ///                     </li>
    ///                   <li>
    ///                         <p>
    ///                         <b>
    ///                            <code>EBSThroughputUnderprovisioned</code>
    ///                         </b> — The
    ///                             instance’s EBS throughput configuration doesn't meet the performance
    ///                             requirements of your workload and there is an alternative instance type
    ///                             that provides better EBS throughput performance.</p>
    ///                     </li>
    ///                   <li>
    ///                         <p>
    ///                         <b>
    ///                            <code>EBSIOPSOverprovisioned</code>
    ///                         </b> —
    ///                             The instance’s EBS IOPS configuration can be sized down while still
    ///                             meeting the performance requirements of your workload.</p>
    ///                     </li>
    ///                   <li>
    ///                         <p>
    ///                         <b>
    ///                            <code>EBSIOPSUnderprovisioned</code>
    ///                         </b>
    ///                             — The instance’s EBS IOPS configuration doesn't meet the performance
    ///                             requirements of your workload and there is an alternative instance type
    ///                             that provides better EBS IOPS performance.</p>
    ///                     </li>
    ///                   <li>
    ///                         <p>
    ///                         <b>
    ///                            <code>NetworkBandwidthOverprovisioned</code>
    ///                         </b> — The
    ///                             instance’s network bandwidth configuration can be sized down while still
    ///                             meeting the performance requirements of your workload.</p>
    ///                     </li>
    ///                   <li>
    ///                         <p>
    ///                         <b>
    ///                            <code>NetworkBandwidthUnderprovisioned</code>
    ///                         </b> — The
    ///                             instance’s network bandwidth configuration doesn't meet the performance
    ///                             requirements of your workload and there is an alternative instance type
    ///                             that provides better network bandwidth performance. This finding reason
    ///                             happens when the <code>NetworkIn</code> or <code>NetworkOut</code>
    ///                             performance of an instance is impacted.</p>
    ///                     </li>
    ///                   <li>
    ///                         <p>
    ///                         <b>
    ///                            <code>NetworkPPSOverprovisioned</code>
    ///                         </b> — The instance’s
    ///                             network PPS (packets per second) configuration can be sized down while
    ///                             still meeting the performance requirements of your workload.</p>
    ///                     </li>
    ///                   <li>
    ///                         <p>
    ///                         <b>
    ///                            <code>NetworkPPSUnderprovisioned</code>
    ///                         </b> — The instance’s
    ///                             network PPS (packets per second) configuration doesn't meet the
    ///                             performance requirements of your workload and there is an alternative
    ///                             instance type that provides better network PPS performance.</p>
    ///                     </li>
    ///                   <li>
    ///                         <p>
    ///                         <b>
    ///                            <code>DiskIOPSOverprovisioned</code>
    ///                         </b>
    ///                             — The instance’s disk IOPS configuration can be sized down while still
    ///                             meeting the performance requirements of your workload.</p>
    ///                     </li>
    ///                   <li>
    ///                         <p>
    ///                         <b>
    ///                            <code>DiskIOPSUnderprovisioned</code>
    ///                         </b>
    ///                             — The instance’s disk IOPS configuration doesn't meet the performance
    ///                             requirements of your workload and there is an alternative instance type
    ///                             that provides better disk IOPS performance.</p>
    ///                     </li>
    ///                   <li>
    ///                         <p>
    ///                         <b>
    ///                            <code>DiskThroughputOverprovisioned</code>
    ///                         </b> — The
    ///                             instance’s disk throughput configuration can be sized down while still
    ///                             meeting the performance requirements of your workload.</p>
    ///                     </li>
    ///                   <li>
    ///                         <p>
    ///                         <b>
    ///                            <code>DiskThroughputUnderprovisioned</code>
    ///                         </b> — The
    ///                             instance’s disk throughput configuration doesn't meet the performance
    ///                             requirements of your workload and there is an alternative instance type
    ///                             that provides better disk throughput performance.</p>
    ///                     </li>
    ///                </ul>
    ///             </li>
    ///          </ul>
    public let values: [String]?

    public init (
        name: FilterName? = nil,
        values: [String]? = nil
    )
    {
        self.name = name
        self.values = values
    }
}

public enum FilterName {
    case finding
    case findingReasonCodes
    case recommendationSourceType
    case sdkUnknown(String)
}

extension FilterName : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [FilterName] {
        return [
            .finding,
            .findingReasonCodes,
            .recommendationSourceType,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .finding: return "Finding"
        case .findingReasonCodes: return "FindingReasonCodes"
        case .recommendationSourceType: return "RecommendationSourceType"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = FilterName(rawValue: rawValue) ?? FilterName.sdkUnknown(rawValue)
    }
}

public enum Finding {
    case notOptimized
    case optimized
    case overProvisioned
    case underProvisioned
    case sdkUnknown(String)
}

extension Finding : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Finding] {
        return [
            .notOptimized,
            .optimized,
            .overProvisioned,
            .underProvisioned,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .notOptimized: return "NotOptimized"
        case .optimized: return "Optimized"
        case .overProvisioned: return "Overprovisioned"
        case .underProvisioned: return "Underprovisioned"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Finding(rawValue: rawValue) ?? Finding.sdkUnknown(rawValue)
    }
}

public enum FindingReasonCode {
    case memoryOverProvisioned
    case memoryUnderProvisioned
    case sdkUnknown(String)
}

extension FindingReasonCode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [FindingReasonCode] {
        return [
            .memoryOverProvisioned,
            .memoryUnderProvisioned,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .memoryOverProvisioned: return "MemoryOverprovisioned"
        case .memoryUnderProvisioned: return "MemoryUnderprovisioned"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = FindingReasonCode(rawValue: rawValue) ?? FindingReasonCode.sdkUnknown(rawValue)
    }
}

public struct GetAutoScalingGroupRecommendationsInputBodyMiddleware: Middleware {
    public let id: String = "GetAutoScalingGroupRecommendationsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAutoScalingGroupRecommendationsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAutoScalingGroupRecommendationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAutoScalingGroupRecommendationsInput>
    public typealias MOutput = OperationOutput<GetAutoScalingGroupRecommendationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAutoScalingGroupRecommendationsOutputError>
}

extension GetAutoScalingGroupRecommendationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAutoScalingGroupRecommendationsInput(accountIds: \(String(describing: accountIds)), autoScalingGroupArns: \(String(describing: autoScalingGroupArns)), filters: \(String(describing: filters)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension GetAutoScalingGroupRecommendationsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountIds
        case autoScalingGroupArns
        case filters
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountIds = accountIds {
            var accountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountIds)
            for accountids0 in accountIds {
                try accountIdsContainer.encode(accountids0)
            }
        }
        if let autoScalingGroupArns = autoScalingGroupArns {
            var autoScalingGroupArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .autoScalingGroupArns)
            for autoscalinggrouparns0 in autoScalingGroupArns {
                try autoScalingGroupArnsContainer.encode(autoscalinggrouparns0)
            }
        }
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filters0 in filters {
                try filtersContainer.encode(filters0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct GetAutoScalingGroupRecommendationsInputHeadersMiddleware: Middleware {
    public let id: String = "GetAutoScalingGroupRecommendationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAutoScalingGroupRecommendationsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAutoScalingGroupRecommendationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAutoScalingGroupRecommendationsInput>
    public typealias MOutput = OperationOutput<GetAutoScalingGroupRecommendationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAutoScalingGroupRecommendationsOutputError>
}

public struct GetAutoScalingGroupRecommendationsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetAutoScalingGroupRecommendationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAutoScalingGroupRecommendationsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAutoScalingGroupRecommendationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAutoScalingGroupRecommendationsInput>
    public typealias MOutput = OperationOutput<GetAutoScalingGroupRecommendationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAutoScalingGroupRecommendationsOutputError>
}

public struct GetAutoScalingGroupRecommendationsInput: Equatable {
    /// <p>The ID of the AWS account for which to return Auto Scaling group
    ///             recommendations.</p>
    ///
    ///
    ///
    ///         <p>If your account is the management account of an organization, use this parameter to
    ///             specify the member account for which you want to return Auto Scaling group
    ///             recommendations.</p>
    ///         <p>Only one account ID can be specified per request.</p>
    public let accountIds: [String]?
    /// <p>The Amazon Resource Name (ARN) of the Auto Scaling groups for which to return
    ///             recommendations.</p>
    public let autoScalingGroupArns: [String]?
    /// <p>An array of objects that describe a filter that returns a more specific list of Auto Scaling
    ///             group recommendations.</p>
    public let filters: [Filter]?
    /// <p>The maximum number of Auto Scaling group recommendations to return with a single
    ///             request.</p>
    ///         <p>To retrieve the remaining results, make another request with the returned
    ///                 <code>NextToken</code> value.</p>
    public let maxResults: Int?
    /// <p>The token to advance to the next page of Auto Scaling group recommendations.</p>
    public let nextToken: String?

    public init (
        accountIds: [String]? = nil,
        autoScalingGroupArns: [String]? = nil,
        filters: [Filter]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.accountIds = accountIds
        self.autoScalingGroupArns = autoScalingGroupArns
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct GetAutoScalingGroupRecommendationsInputBody: Equatable {
    public let accountIds: [String]?
    public let autoScalingGroupArns: [String]?
    public let nextToken: String?
    public let maxResults: Int?
    public let filters: [Filter]?
}

extension GetAutoScalingGroupRecommendationsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accountIds
        case autoScalingGroupArns
        case filters
        case maxResults
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .accountIds)
        var accountIdsDecoded0:[String]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [String]()
            for string0 in accountIdsContainer {
                if let string0 = string0 {
                    accountIdsDecoded0?.append(string0)
                }
            }
        }
        accountIds = accountIdsDecoded0
        let autoScalingGroupArnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .autoScalingGroupArns)
        var autoScalingGroupArnsDecoded0:[String]? = nil
        if let autoScalingGroupArnsContainer = autoScalingGroupArnsContainer {
            autoScalingGroupArnsDecoded0 = [String]()
            for string0 in autoScalingGroupArnsContainer {
                if let string0 = string0 {
                    autoScalingGroupArnsDecoded0?.append(string0)
                }
            }
        }
        autoScalingGroupArns = autoScalingGroupArnsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([Filter?].self, forKey: .filters)
        var filtersDecoded0:[Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension GetAutoScalingGroupRecommendationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAutoScalingGroupRecommendationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingAuthenticationToken" : self = .missingAuthenticationToken(try MissingAuthenticationToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OptInRequiredException" : self = .optInRequiredException(try OptInRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAutoScalingGroupRecommendationsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case invalidParameterValueException(InvalidParameterValueException)
    case missingAuthenticationToken(MissingAuthenticationToken)
    case optInRequiredException(OptInRequiredException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAutoScalingGroupRecommendationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAutoScalingGroupRecommendationsOutputResponse(autoScalingGroupRecommendations: \(String(describing: autoScalingGroupRecommendations)), errors: \(String(describing: errors)), nextToken: \(String(describing: nextToken)))"}
}

extension GetAutoScalingGroupRecommendationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetAutoScalingGroupRecommendationsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.autoScalingGroupRecommendations = output.autoScalingGroupRecommendations
            self.errors = output.errors
            self.nextToken = output.nextToken
        } else {
            self.autoScalingGroupRecommendations = nil
            self.errors = nil
            self.nextToken = nil
        }
    }
}

public struct GetAutoScalingGroupRecommendationsOutputResponse: Equatable {
    /// <p>An array of objects that describe Auto Scaling group recommendations.</p>
    public let autoScalingGroupRecommendations: [AutoScalingGroupRecommendation]?
    /// <p>An array of objects that describe errors of the request.</p>
    ///         <p>For example, an error is returned if you request recommendations for an unsupported
    ///             Auto Scaling group.</p>
    public let errors: [GetRecommendationError]?
    /// <p>The token to use to advance to the next page of Auto Scaling group recommendations.</p>
    ///         <p>This value is null when there are no more pages of Auto Scaling group recommendations to
    ///             return.</p>
    public let nextToken: String?

    public init (
        autoScalingGroupRecommendations: [AutoScalingGroupRecommendation]? = nil,
        errors: [GetRecommendationError]? = nil,
        nextToken: String? = nil
    )
    {
        self.autoScalingGroupRecommendations = autoScalingGroupRecommendations
        self.errors = errors
        self.nextToken = nextToken
    }
}

struct GetAutoScalingGroupRecommendationsOutputResponseBody: Equatable {
    public let nextToken: String?
    public let autoScalingGroupRecommendations: [AutoScalingGroupRecommendation]?
    public let errors: [GetRecommendationError]?
}

extension GetAutoScalingGroupRecommendationsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case autoScalingGroupRecommendations
        case errors
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let autoScalingGroupRecommendationsContainer = try containerValues.decodeIfPresent([AutoScalingGroupRecommendation?].self, forKey: .autoScalingGroupRecommendations)
        var autoScalingGroupRecommendationsDecoded0:[AutoScalingGroupRecommendation]? = nil
        if let autoScalingGroupRecommendationsContainer = autoScalingGroupRecommendationsContainer {
            autoScalingGroupRecommendationsDecoded0 = [AutoScalingGroupRecommendation]()
            for structure0 in autoScalingGroupRecommendationsContainer {
                if let structure0 = structure0 {
                    autoScalingGroupRecommendationsDecoded0?.append(structure0)
                }
            }
        }
        autoScalingGroupRecommendations = autoScalingGroupRecommendationsDecoded0
        let errorsContainer = try containerValues.decodeIfPresent([GetRecommendationError?].self, forKey: .errors)
        var errorsDecoded0:[GetRecommendationError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [GetRecommendationError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

public struct GetEBSVolumeRecommendationsInputBodyMiddleware: Middleware {
    public let id: String = "GetEBSVolumeRecommendationsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetEBSVolumeRecommendationsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetEBSVolumeRecommendationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetEBSVolumeRecommendationsInput>
    public typealias MOutput = OperationOutput<GetEBSVolumeRecommendationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetEBSVolumeRecommendationsOutputError>
}

extension GetEBSVolumeRecommendationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetEBSVolumeRecommendationsInput(accountIds: \(String(describing: accountIds)), filters: \(String(describing: filters)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), volumeArns: \(String(describing: volumeArns)))"}
}

extension GetEBSVolumeRecommendationsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountIds
        case filters
        case maxResults
        case nextToken
        case volumeArns
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountIds = accountIds {
            var accountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountIds)
            for accountids0 in accountIds {
                try accountIdsContainer.encode(accountids0)
            }
        }
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for ebsfilters0 in filters {
                try filtersContainer.encode(ebsfilters0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let volumeArns = volumeArns {
            var volumeArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .volumeArns)
            for volumearns0 in volumeArns {
                try volumeArnsContainer.encode(volumearns0)
            }
        }
    }
}

public struct GetEBSVolumeRecommendationsInputHeadersMiddleware: Middleware {
    public let id: String = "GetEBSVolumeRecommendationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetEBSVolumeRecommendationsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetEBSVolumeRecommendationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetEBSVolumeRecommendationsInput>
    public typealias MOutput = OperationOutput<GetEBSVolumeRecommendationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetEBSVolumeRecommendationsOutputError>
}

public struct GetEBSVolumeRecommendationsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetEBSVolumeRecommendationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetEBSVolumeRecommendationsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetEBSVolumeRecommendationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetEBSVolumeRecommendationsInput>
    public typealias MOutput = OperationOutput<GetEBSVolumeRecommendationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetEBSVolumeRecommendationsOutputError>
}

public struct GetEBSVolumeRecommendationsInput: Equatable {
    /// <p>The ID of the AWS account for which to return volume
    ///             recommendations.</p>
    ///
    ///
    ///
    ///         <p>If your account is the management account of an organization, use this parameter to
    ///             specify the member account for which you want to return volume recommendations.</p>
    ///         <p>Only one account ID can be specified per request.</p>
    public let accountIds: [String]?
    /// <p>An array of objects that describe a filter that returns a more specific list of volume
    ///             recommendations.</p>
    public let filters: [EBSFilter]?
    /// <p>The maximum number of volume recommendations to return with a single request.</p>
    ///         <p>To retrieve the remaining results, make another request with the returned
    ///                 <code>NextToken</code> value.</p>
    public let maxResults: Int?
    /// <p>The token to advance to the next page of volume recommendations.</p>
    public let nextToken: String?
    /// <p>The Amazon Resource Name (ARN) of the volumes for which to return
    ///             recommendations.</p>
    public let volumeArns: [String]?

    public init (
        accountIds: [String]? = nil,
        filters: [EBSFilter]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        volumeArns: [String]? = nil
    )
    {
        self.accountIds = accountIds
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.volumeArns = volumeArns
    }
}

struct GetEBSVolumeRecommendationsInputBody: Equatable {
    public let volumeArns: [String]?
    public let nextToken: String?
    public let maxResults: Int?
    public let filters: [EBSFilter]?
    public let accountIds: [String]?
}

extension GetEBSVolumeRecommendationsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accountIds
        case filters
        case maxResults
        case nextToken
        case volumeArns
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let volumeArnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .volumeArns)
        var volumeArnsDecoded0:[String]? = nil
        if let volumeArnsContainer = volumeArnsContainer {
            volumeArnsDecoded0 = [String]()
            for string0 in volumeArnsContainer {
                if let string0 = string0 {
                    volumeArnsDecoded0?.append(string0)
                }
            }
        }
        volumeArns = volumeArnsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([EBSFilter?].self, forKey: .filters)
        var filtersDecoded0:[EBSFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [EBSFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let accountIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .accountIds)
        var accountIdsDecoded0:[String]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [String]()
            for string0 in accountIdsContainer {
                if let string0 = string0 {
                    accountIdsDecoded0?.append(string0)
                }
            }
        }
        accountIds = accountIdsDecoded0
    }
}

extension GetEBSVolumeRecommendationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetEBSVolumeRecommendationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingAuthenticationToken" : self = .missingAuthenticationToken(try MissingAuthenticationToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OptInRequiredException" : self = .optInRequiredException(try OptInRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetEBSVolumeRecommendationsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case invalidParameterValueException(InvalidParameterValueException)
    case missingAuthenticationToken(MissingAuthenticationToken)
    case optInRequiredException(OptInRequiredException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetEBSVolumeRecommendationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetEBSVolumeRecommendationsOutputResponse(errors: \(String(describing: errors)), nextToken: \(String(describing: nextToken)), volumeRecommendations: \(String(describing: volumeRecommendations)))"}
}

extension GetEBSVolumeRecommendationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetEBSVolumeRecommendationsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.errors = output.errors
            self.nextToken = output.nextToken
            self.volumeRecommendations = output.volumeRecommendations
        } else {
            self.errors = nil
            self.nextToken = nil
            self.volumeRecommendations = nil
        }
    }
}

public struct GetEBSVolumeRecommendationsOutputResponse: Equatable {
    /// <p>An array of objects that describe errors of the request.</p>
    ///         <p>For example, an error is returned if you request recommendations for an unsupported
    ///             volume.</p>
    public let errors: [GetRecommendationError]?
    /// <p>The token to use to advance to the next page of volume recommendations.</p>
    ///         <p>This value is null when there are no more pages of volume recommendations to
    ///             return.</p>
    public let nextToken: String?
    /// <p>An array of objects that describe volume recommendations.</p>
    public let volumeRecommendations: [VolumeRecommendation]?

    public init (
        errors: [GetRecommendationError]? = nil,
        nextToken: String? = nil,
        volumeRecommendations: [VolumeRecommendation]? = nil
    )
    {
        self.errors = errors
        self.nextToken = nextToken
        self.volumeRecommendations = volumeRecommendations
    }
}

struct GetEBSVolumeRecommendationsOutputResponseBody: Equatable {
    public let nextToken: String?
    public let volumeRecommendations: [VolumeRecommendation]?
    public let errors: [GetRecommendationError]?
}

extension GetEBSVolumeRecommendationsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case errors
        case nextToken
        case volumeRecommendations
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let volumeRecommendationsContainer = try containerValues.decodeIfPresent([VolumeRecommendation?].self, forKey: .volumeRecommendations)
        var volumeRecommendationsDecoded0:[VolumeRecommendation]? = nil
        if let volumeRecommendationsContainer = volumeRecommendationsContainer {
            volumeRecommendationsDecoded0 = [VolumeRecommendation]()
            for structure0 in volumeRecommendationsContainer {
                if let structure0 = structure0 {
                    volumeRecommendationsDecoded0?.append(structure0)
                }
            }
        }
        volumeRecommendations = volumeRecommendationsDecoded0
        let errorsContainer = try containerValues.decodeIfPresent([GetRecommendationError?].self, forKey: .errors)
        var errorsDecoded0:[GetRecommendationError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [GetRecommendationError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

public struct GetEC2InstanceRecommendationsInputBodyMiddleware: Middleware {
    public let id: String = "GetEC2InstanceRecommendationsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetEC2InstanceRecommendationsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetEC2InstanceRecommendationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetEC2InstanceRecommendationsInput>
    public typealias MOutput = OperationOutput<GetEC2InstanceRecommendationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetEC2InstanceRecommendationsOutputError>
}

extension GetEC2InstanceRecommendationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetEC2InstanceRecommendationsInput(accountIds: \(String(describing: accountIds)), filters: \(String(describing: filters)), instanceArns: \(String(describing: instanceArns)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension GetEC2InstanceRecommendationsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountIds
        case filters
        case instanceArns
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountIds = accountIds {
            var accountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountIds)
            for accountids0 in accountIds {
                try accountIdsContainer.encode(accountids0)
            }
        }
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filters0 in filters {
                try filtersContainer.encode(filters0)
            }
        }
        if let instanceArns = instanceArns {
            var instanceArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .instanceArns)
            for instancearns0 in instanceArns {
                try instanceArnsContainer.encode(instancearns0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct GetEC2InstanceRecommendationsInputHeadersMiddleware: Middleware {
    public let id: String = "GetEC2InstanceRecommendationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetEC2InstanceRecommendationsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetEC2InstanceRecommendationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetEC2InstanceRecommendationsInput>
    public typealias MOutput = OperationOutput<GetEC2InstanceRecommendationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetEC2InstanceRecommendationsOutputError>
}

public struct GetEC2InstanceRecommendationsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetEC2InstanceRecommendationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetEC2InstanceRecommendationsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetEC2InstanceRecommendationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetEC2InstanceRecommendationsInput>
    public typealias MOutput = OperationOutput<GetEC2InstanceRecommendationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetEC2InstanceRecommendationsOutputError>
}

public struct GetEC2InstanceRecommendationsInput: Equatable {
    /// <p>The ID of the AWS account for which to return instance
    ///             recommendations.</p>
    ///
    ///
    ///
    ///         <p>If your account is the management account of an organization, use this parameter to
    ///             specify the member account for which you want to return instance recommendations.</p>
    ///         <p>Only one account ID can be specified per request.</p>
    public let accountIds: [String]?
    /// <p>An array of objects that describe a filter that returns a more specific list of
    ///             instance recommendations.</p>
    public let filters: [Filter]?
    /// <p>The Amazon Resource Name (ARN) of the instances for which to return
    ///             recommendations.</p>
    public let instanceArns: [String]?
    /// <p>The maximum number of instance recommendations to return with a single request.</p>
    ///         <p>To retrieve the remaining results, make another request with the returned
    ///                 <code>NextToken</code> value.</p>
    public let maxResults: Int?
    /// <p>The token to advance to the next page of instance recommendations.</p>
    public let nextToken: String?

    public init (
        accountIds: [String]? = nil,
        filters: [Filter]? = nil,
        instanceArns: [String]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.accountIds = accountIds
        self.filters = filters
        self.instanceArns = instanceArns
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct GetEC2InstanceRecommendationsInputBody: Equatable {
    public let instanceArns: [String]?
    public let nextToken: String?
    public let maxResults: Int?
    public let filters: [Filter]?
    public let accountIds: [String]?
}

extension GetEC2InstanceRecommendationsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accountIds
        case filters
        case instanceArns
        case maxResults
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .instanceArns)
        var instanceArnsDecoded0:[String]? = nil
        if let instanceArnsContainer = instanceArnsContainer {
            instanceArnsDecoded0 = [String]()
            for string0 in instanceArnsContainer {
                if let string0 = string0 {
                    instanceArnsDecoded0?.append(string0)
                }
            }
        }
        instanceArns = instanceArnsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([Filter?].self, forKey: .filters)
        var filtersDecoded0:[Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let accountIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .accountIds)
        var accountIdsDecoded0:[String]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [String]()
            for string0 in accountIdsContainer {
                if let string0 = string0 {
                    accountIdsDecoded0?.append(string0)
                }
            }
        }
        accountIds = accountIdsDecoded0
    }
}

extension GetEC2InstanceRecommendationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetEC2InstanceRecommendationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingAuthenticationToken" : self = .missingAuthenticationToken(try MissingAuthenticationToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OptInRequiredException" : self = .optInRequiredException(try OptInRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetEC2InstanceRecommendationsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case invalidParameterValueException(InvalidParameterValueException)
    case missingAuthenticationToken(MissingAuthenticationToken)
    case optInRequiredException(OptInRequiredException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetEC2InstanceRecommendationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetEC2InstanceRecommendationsOutputResponse(errors: \(String(describing: errors)), instanceRecommendations: \(String(describing: instanceRecommendations)), nextToken: \(String(describing: nextToken)))"}
}

extension GetEC2InstanceRecommendationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetEC2InstanceRecommendationsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.errors = output.errors
            self.instanceRecommendations = output.instanceRecommendations
            self.nextToken = output.nextToken
        } else {
            self.errors = nil
            self.instanceRecommendations = nil
            self.nextToken = nil
        }
    }
}

public struct GetEC2InstanceRecommendationsOutputResponse: Equatable {
    /// <p>An array of objects that describe errors of the request.</p>
    ///         <p>For example, an error is returned if you request recommendations for an instance of an
    ///             unsupported instance family.</p>
    public let errors: [GetRecommendationError]?
    /// <p>An array of objects that describe instance recommendations.</p>
    public let instanceRecommendations: [InstanceRecommendation]?
    /// <p>The token to use to advance to the next page of instance recommendations.</p>
    ///         <p>This value is null when there are no more pages of instance recommendations to
    ///             return.</p>
    public let nextToken: String?

    public init (
        errors: [GetRecommendationError]? = nil,
        instanceRecommendations: [InstanceRecommendation]? = nil,
        nextToken: String? = nil
    )
    {
        self.errors = errors
        self.instanceRecommendations = instanceRecommendations
        self.nextToken = nextToken
    }
}

struct GetEC2InstanceRecommendationsOutputResponseBody: Equatable {
    public let nextToken: String?
    public let instanceRecommendations: [InstanceRecommendation]?
    public let errors: [GetRecommendationError]?
}

extension GetEC2InstanceRecommendationsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case errors
        case instanceRecommendations
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let instanceRecommendationsContainer = try containerValues.decodeIfPresent([InstanceRecommendation?].self, forKey: .instanceRecommendations)
        var instanceRecommendationsDecoded0:[InstanceRecommendation]? = nil
        if let instanceRecommendationsContainer = instanceRecommendationsContainer {
            instanceRecommendationsDecoded0 = [InstanceRecommendation]()
            for structure0 in instanceRecommendationsContainer {
                if let structure0 = structure0 {
                    instanceRecommendationsDecoded0?.append(structure0)
                }
            }
        }
        instanceRecommendations = instanceRecommendationsDecoded0
        let errorsContainer = try containerValues.decodeIfPresent([GetRecommendationError?].self, forKey: .errors)
        var errorsDecoded0:[GetRecommendationError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [GetRecommendationError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

public struct GetEC2RecommendationProjectedMetricsInputBodyMiddleware: Middleware {
    public let id: String = "GetEC2RecommendationProjectedMetricsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetEC2RecommendationProjectedMetricsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetEC2RecommendationProjectedMetricsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetEC2RecommendationProjectedMetricsInput>
    public typealias MOutput = OperationOutput<GetEC2RecommendationProjectedMetricsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetEC2RecommendationProjectedMetricsOutputError>
}

extension GetEC2RecommendationProjectedMetricsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetEC2RecommendationProjectedMetricsInput(endTime: \(String(describing: endTime)), instanceArn: \(String(describing: instanceArn)), period: \(String(describing: period)), startTime: \(String(describing: startTime)), stat: \(String(describing: stat)))"}
}

extension GetEC2RecommendationProjectedMetricsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case endTime
        case instanceArn
        case period
        case startTime
        case stat
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let instanceArn = instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
        if period != 0 {
            try encodeContainer.encode(period, forKey: .period)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
        if let stat = stat {
            try encodeContainer.encode(stat.rawValue, forKey: .stat)
        }
    }
}

public struct GetEC2RecommendationProjectedMetricsInputHeadersMiddleware: Middleware {
    public let id: String = "GetEC2RecommendationProjectedMetricsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetEC2RecommendationProjectedMetricsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetEC2RecommendationProjectedMetricsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetEC2RecommendationProjectedMetricsInput>
    public typealias MOutput = OperationOutput<GetEC2RecommendationProjectedMetricsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetEC2RecommendationProjectedMetricsOutputError>
}

public struct GetEC2RecommendationProjectedMetricsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetEC2RecommendationProjectedMetricsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetEC2RecommendationProjectedMetricsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetEC2RecommendationProjectedMetricsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetEC2RecommendationProjectedMetricsInput>
    public typealias MOutput = OperationOutput<GetEC2RecommendationProjectedMetricsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetEC2RecommendationProjectedMetricsOutputError>
}

public struct GetEC2RecommendationProjectedMetricsInput: Equatable {
    /// <p>The time stamp of the last projected metrics data point to return.</p>
    public let endTime: Date?
    /// <p>The Amazon Resource Name (ARN) of the instances for which to return recommendation
    ///             projected metrics.</p>
    public let instanceArn: String?
    /// <p>The granularity, in seconds, of the projected metrics data points.</p>
    public let period: Int
    /// <p>The time stamp of the first projected metrics data point to return.</p>
    public let startTime: Date?
    /// <p>The statistic of the projected metrics.</p>
    public let stat: MetricStatistic?

    public init (
        endTime: Date? = nil,
        instanceArn: String? = nil,
        period: Int = 0,
        startTime: Date? = nil,
        stat: MetricStatistic? = nil
    )
    {
        self.endTime = endTime
        self.instanceArn = instanceArn
        self.period = period
        self.startTime = startTime
        self.stat = stat
    }
}

struct GetEC2RecommendationProjectedMetricsInputBody: Equatable {
    public let instanceArn: String?
    public let stat: MetricStatistic?
    public let period: Int
    public let startTime: Date?
    public let endTime: Date?
}

extension GetEC2RecommendationProjectedMetricsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case endTime
        case instanceArn
        case period
        case startTime
        case stat
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let statDecoded = try containerValues.decodeIfPresent(MetricStatistic.self, forKey: .stat)
        stat = statDecoded
        let periodDecoded = try containerValues.decode(Int.self, forKey: .period)
        period = periodDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .endTime)
        endTime = endTimeDecoded
    }
}

extension GetEC2RecommendationProjectedMetricsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetEC2RecommendationProjectedMetricsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingAuthenticationToken" : self = .missingAuthenticationToken(try MissingAuthenticationToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OptInRequiredException" : self = .optInRequiredException(try OptInRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetEC2RecommendationProjectedMetricsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case invalidParameterValueException(InvalidParameterValueException)
    case missingAuthenticationToken(MissingAuthenticationToken)
    case optInRequiredException(OptInRequiredException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetEC2RecommendationProjectedMetricsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetEC2RecommendationProjectedMetricsOutputResponse(recommendedOptionProjectedMetrics: \(String(describing: recommendedOptionProjectedMetrics)))"}
}

extension GetEC2RecommendationProjectedMetricsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetEC2RecommendationProjectedMetricsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.recommendedOptionProjectedMetrics = output.recommendedOptionProjectedMetrics
        } else {
            self.recommendedOptionProjectedMetrics = nil
        }
    }
}

public struct GetEC2RecommendationProjectedMetricsOutputResponse: Equatable {
    /// <p>An array of objects that describe a projected metrics.</p>
    public let recommendedOptionProjectedMetrics: [RecommendedOptionProjectedMetric]?

    public init (
        recommendedOptionProjectedMetrics: [RecommendedOptionProjectedMetric]? = nil
    )
    {
        self.recommendedOptionProjectedMetrics = recommendedOptionProjectedMetrics
    }
}

struct GetEC2RecommendationProjectedMetricsOutputResponseBody: Equatable {
    public let recommendedOptionProjectedMetrics: [RecommendedOptionProjectedMetric]?
}

extension GetEC2RecommendationProjectedMetricsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case recommendedOptionProjectedMetrics
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recommendedOptionProjectedMetricsContainer = try containerValues.decodeIfPresent([RecommendedOptionProjectedMetric?].self, forKey: .recommendedOptionProjectedMetrics)
        var recommendedOptionProjectedMetricsDecoded0:[RecommendedOptionProjectedMetric]? = nil
        if let recommendedOptionProjectedMetricsContainer = recommendedOptionProjectedMetricsContainer {
            recommendedOptionProjectedMetricsDecoded0 = [RecommendedOptionProjectedMetric]()
            for structure0 in recommendedOptionProjectedMetricsContainer {
                if let structure0 = structure0 {
                    recommendedOptionProjectedMetricsDecoded0?.append(structure0)
                }
            }
        }
        recommendedOptionProjectedMetrics = recommendedOptionProjectedMetricsDecoded0
    }
}

extension GetEnrollmentStatusInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetEnrollmentStatusInput()"}
}

extension GetEnrollmentStatusInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetEnrollmentStatusInputHeadersMiddleware: Middleware {
    public let id: String = "GetEnrollmentStatusInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetEnrollmentStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<GetEnrollmentStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetEnrollmentStatusInput>
    public typealias MOutput = OperationOutput<GetEnrollmentStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetEnrollmentStatusOutputError>
}

public struct GetEnrollmentStatusInputQueryItemMiddleware: Middleware {
    public let id: String = "GetEnrollmentStatusInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetEnrollmentStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<GetEnrollmentStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetEnrollmentStatusInput>
    public typealias MOutput = OperationOutput<GetEnrollmentStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetEnrollmentStatusOutputError>
}

public struct GetEnrollmentStatusInput: Equatable {

    public init() {}
}

struct GetEnrollmentStatusInputBody: Equatable {
}

extension GetEnrollmentStatusInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetEnrollmentStatusOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetEnrollmentStatusOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingAuthenticationToken" : self = .missingAuthenticationToken(try MissingAuthenticationToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetEnrollmentStatusOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case invalidParameterValueException(InvalidParameterValueException)
    case missingAuthenticationToken(MissingAuthenticationToken)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetEnrollmentStatusOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetEnrollmentStatusOutputResponse(memberAccountsEnrolled: \(String(describing: memberAccountsEnrolled)), status: \(String(describing: status)), statusReason: \(String(describing: statusReason)))"}
}

extension GetEnrollmentStatusOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetEnrollmentStatusOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.memberAccountsEnrolled = output.memberAccountsEnrolled
            self.status = output.status
            self.statusReason = output.statusReason
        } else {
            self.memberAccountsEnrolled = false
            self.status = nil
            self.statusReason = nil
        }
    }
}

public struct GetEnrollmentStatusOutputResponse: Equatable {
    /// <p>Confirms the enrollment status of member accounts within the organization, if the
    ///             account is a management account of an organization.</p>
    public let memberAccountsEnrolled: Bool
    /// <p>The enrollment status of the account.</p>
    public let status: Status?
    /// <p>The reason for the enrollment status of the account.</p>
    ///         <p>For example, an account might show a status of <code>Pending</code> because member
    ///             accounts of an organization require more time to be enrolled in the service.</p>
    public let statusReason: String?

    public init (
        memberAccountsEnrolled: Bool = false,
        status: Status? = nil,
        statusReason: String? = nil
    )
    {
        self.memberAccountsEnrolled = memberAccountsEnrolled
        self.status = status
        self.statusReason = statusReason
    }
}

struct GetEnrollmentStatusOutputResponseBody: Equatable {
    public let status: Status?
    public let statusReason: String?
    public let memberAccountsEnrolled: Bool
}

extension GetEnrollmentStatusOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case memberAccountsEnrolled
        case status
        case statusReason
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(Status.self, forKey: .status)
        status = statusDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
        let memberAccountsEnrolledDecoded = try containerValues.decode(Bool.self, forKey: .memberAccountsEnrolled)
        memberAccountsEnrolled = memberAccountsEnrolledDecoded
    }
}

public struct GetLambdaFunctionRecommendationsInputBodyMiddleware: Middleware {
    public let id: String = "GetLambdaFunctionRecommendationsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetLambdaFunctionRecommendationsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetLambdaFunctionRecommendationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetLambdaFunctionRecommendationsInput>
    public typealias MOutput = OperationOutput<GetLambdaFunctionRecommendationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetLambdaFunctionRecommendationsOutputError>
}

extension GetLambdaFunctionRecommendationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetLambdaFunctionRecommendationsInput(accountIds: \(String(describing: accountIds)), filters: \(String(describing: filters)), functionArns: \(String(describing: functionArns)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension GetLambdaFunctionRecommendationsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountIds
        case filters
        case functionArns
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountIds = accountIds {
            var accountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountIds)
            for accountids0 in accountIds {
                try accountIdsContainer.encode(accountids0)
            }
        }
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for lambdafunctionrecommendationfilters0 in filters {
                try filtersContainer.encode(lambdafunctionrecommendationfilters0)
            }
        }
        if let functionArns = functionArns {
            var functionArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .functionArns)
            for functionarns0 in functionArns {
                try functionArnsContainer.encode(functionarns0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct GetLambdaFunctionRecommendationsInputHeadersMiddleware: Middleware {
    public let id: String = "GetLambdaFunctionRecommendationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetLambdaFunctionRecommendationsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetLambdaFunctionRecommendationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetLambdaFunctionRecommendationsInput>
    public typealias MOutput = OperationOutput<GetLambdaFunctionRecommendationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetLambdaFunctionRecommendationsOutputError>
}

public struct GetLambdaFunctionRecommendationsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetLambdaFunctionRecommendationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetLambdaFunctionRecommendationsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetLambdaFunctionRecommendationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetLambdaFunctionRecommendationsInput>
    public typealias MOutput = OperationOutput<GetLambdaFunctionRecommendationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetLambdaFunctionRecommendationsOutputError>
}

public struct GetLambdaFunctionRecommendationsInput: Equatable {
    /// <p>The ID of the AWS account for which to return function
    ///             recommendations.</p>
    ///
    ///
    ///
    ///         <p>If your account is the management account of an organization, use this parameter to
    ///             specify the member account for which you want to return function recommendations.</p>
    ///
    ///         <p>Only one account ID can be specified per request.</p>
    public let accountIds: [String]?
    /// <p>An array of objects that describe a filter that returns a more specific list of
    ///             function recommendations.</p>
    public let filters: [LambdaFunctionRecommendationFilter]?
    /// <p>The Amazon Resource Name (ARN) of the functions for which to return
    ///             recommendations.</p>
    ///
    ///         <p>You can specify a qualified or unqualified ARN. If you specify an
    ///             unqualified ARN without a function version suffix, Compute Optimizer will return recommendations for
    ///             the latest (<code>$LATEST</code>) version of the function. If you specify a qualified
    ///             ARN with a version suffix, Compute Optimizer will return recommendations for the specified function
    ///             version. For more information about using function versions, see <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-versions.html#versioning-versions-using">Using
    ///                 versions</a> in the <i>AWS Lambda Developer Guide</i>.</p>
    public let functionArns: [String]?
    /// <p>The maximum number of function recommendations to return with a single request.</p>
    ///
    ///         <p>To retrieve the remaining results, make another request with the returned
    ///                 <code>NextToken</code> value.</p>
    public let maxResults: Int?
    /// <p>The token to advance to the next page of function recommendations.</p>
    public let nextToken: String?

    public init (
        accountIds: [String]? = nil,
        filters: [LambdaFunctionRecommendationFilter]? = nil,
        functionArns: [String]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.accountIds = accountIds
        self.filters = filters
        self.functionArns = functionArns
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct GetLambdaFunctionRecommendationsInputBody: Equatable {
    public let functionArns: [String]?
    public let accountIds: [String]?
    public let filters: [LambdaFunctionRecommendationFilter]?
    public let nextToken: String?
    public let maxResults: Int?
}

extension GetLambdaFunctionRecommendationsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accountIds
        case filters
        case functionArns
        case maxResults
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionArnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .functionArns)
        var functionArnsDecoded0:[String]? = nil
        if let functionArnsContainer = functionArnsContainer {
            functionArnsDecoded0 = [String]()
            for string0 in functionArnsContainer {
                if let string0 = string0 {
                    functionArnsDecoded0?.append(string0)
                }
            }
        }
        functionArns = functionArnsDecoded0
        let accountIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .accountIds)
        var accountIdsDecoded0:[String]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [String]()
            for string0 in accountIdsContainer {
                if let string0 = string0 {
                    accountIdsDecoded0?.append(string0)
                }
            }
        }
        accountIds = accountIdsDecoded0
        let filtersContainer = try containerValues.decodeIfPresent([LambdaFunctionRecommendationFilter?].self, forKey: .filters)
        var filtersDecoded0:[LambdaFunctionRecommendationFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [LambdaFunctionRecommendationFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension GetLambdaFunctionRecommendationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetLambdaFunctionRecommendationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingAuthenticationToken" : self = .missingAuthenticationToken(try MissingAuthenticationToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OptInRequiredException" : self = .optInRequiredException(try OptInRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetLambdaFunctionRecommendationsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case invalidParameterValueException(InvalidParameterValueException)
    case limitExceededException(LimitExceededException)
    case missingAuthenticationToken(MissingAuthenticationToken)
    case optInRequiredException(OptInRequiredException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetLambdaFunctionRecommendationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetLambdaFunctionRecommendationsOutputResponse(lambdaFunctionRecommendations: \(String(describing: lambdaFunctionRecommendations)), nextToken: \(String(describing: nextToken)))"}
}

extension GetLambdaFunctionRecommendationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetLambdaFunctionRecommendationsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.lambdaFunctionRecommendations = output.lambdaFunctionRecommendations
            self.nextToken = output.nextToken
        } else {
            self.lambdaFunctionRecommendations = nil
            self.nextToken = nil
        }
    }
}

public struct GetLambdaFunctionRecommendationsOutputResponse: Equatable {
    /// <p>An array of objects that describe function recommendations.</p>
    public let lambdaFunctionRecommendations: [LambdaFunctionRecommendation]?
    /// <p>The token to use to advance to the next page of function recommendations.</p>
    ///
    ///         <p>This value is null when there are no more pages of function recommendations to
    ///             return.</p>
    public let nextToken: String?

    public init (
        lambdaFunctionRecommendations: [LambdaFunctionRecommendation]? = nil,
        nextToken: String? = nil
    )
    {
        self.lambdaFunctionRecommendations = lambdaFunctionRecommendations
        self.nextToken = nextToken
    }
}

struct GetLambdaFunctionRecommendationsOutputResponseBody: Equatable {
    public let nextToken: String?
    public let lambdaFunctionRecommendations: [LambdaFunctionRecommendation]?
}

extension GetLambdaFunctionRecommendationsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case lambdaFunctionRecommendations
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let lambdaFunctionRecommendationsContainer = try containerValues.decodeIfPresent([LambdaFunctionRecommendation?].self, forKey: .lambdaFunctionRecommendations)
        var lambdaFunctionRecommendationsDecoded0:[LambdaFunctionRecommendation]? = nil
        if let lambdaFunctionRecommendationsContainer = lambdaFunctionRecommendationsContainer {
            lambdaFunctionRecommendationsDecoded0 = [LambdaFunctionRecommendation]()
            for structure0 in lambdaFunctionRecommendationsContainer {
                if let structure0 = structure0 {
                    lambdaFunctionRecommendationsDecoded0?.append(structure0)
                }
            }
        }
        lambdaFunctionRecommendations = lambdaFunctionRecommendationsDecoded0
    }
}

extension GetRecommendationError: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case code
        case identifier
        case message
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = code {
            try encodeContainer.encode(code, forKey: .code)
        }
        if let identifier = identifier {
            try encodeContainer.encode(identifier, forKey: .identifier)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .identifier)
        identifier = identifierDecoded
        let codeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension GetRecommendationError: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetRecommendationError(code: \(String(describing: code)), identifier: \(String(describing: identifier)), message: \(String(describing: message)))"}
}

/// <p>Describes an error experienced when getting recommendations.</p>
///         <p>For example, an error is returned if you request recommendations for an unsupported
///             Auto Scaling group, or if you request recommendations for an instance of an unsupported instance
///             family.</p>
public struct GetRecommendationError: Equatable {
    /// <p>The error code.</p>
    public let code: String?
    /// <p>The ID of the error.</p>
    public let identifier: String?
    /// <p>The message, or reason, for the error.</p>
    public let message: String?

    public init (
        code: String? = nil,
        identifier: String? = nil,
        message: String? = nil
    )
    {
        self.code = code
        self.identifier = identifier
        self.message = message
    }
}

public struct GetRecommendationSummariesInputBodyMiddleware: Middleware {
    public let id: String = "GetRecommendationSummariesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRecommendationSummariesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRecommendationSummariesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRecommendationSummariesInput>
    public typealias MOutput = OperationOutput<GetRecommendationSummariesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRecommendationSummariesOutputError>
}

extension GetRecommendationSummariesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetRecommendationSummariesInput(accountIds: \(String(describing: accountIds)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension GetRecommendationSummariesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountIds
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountIds = accountIds {
            var accountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountIds)
            for accountids0 in accountIds {
                try accountIdsContainer.encode(accountids0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct GetRecommendationSummariesInputHeadersMiddleware: Middleware {
    public let id: String = "GetRecommendationSummariesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRecommendationSummariesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRecommendationSummariesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRecommendationSummariesInput>
    public typealias MOutput = OperationOutput<GetRecommendationSummariesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRecommendationSummariesOutputError>
}

public struct GetRecommendationSummariesInputQueryItemMiddleware: Middleware {
    public let id: String = "GetRecommendationSummariesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRecommendationSummariesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRecommendationSummariesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRecommendationSummariesInput>
    public typealias MOutput = OperationOutput<GetRecommendationSummariesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRecommendationSummariesOutputError>
}

public struct GetRecommendationSummariesInput: Equatable {
    /// <p>The ID of the AWS account for which to return recommendation
    ///             summaries.</p>
    ///
    ///
    ///
    ///         <p>If your account is the management account of an organization, use this parameter to
    ///             specify the member account for which you want to return recommendation summaries.</p>
    ///         <p>Only one account ID can be specified per request.</p>
    public let accountIds: [String]?
    /// <p>The maximum number of recommendation summaries to return with a single request.</p>
    ///         <p>To retrieve the remaining results, make another request with the returned
    ///                 <code>NextToken</code> value.</p>
    public let maxResults: Int?
    /// <p>The token to advance to the next page of recommendation summaries.</p>
    public let nextToken: String?

    public init (
        accountIds: [String]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.accountIds = accountIds
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct GetRecommendationSummariesInputBody: Equatable {
    public let accountIds: [String]?
    public let nextToken: String?
    public let maxResults: Int?
}

extension GetRecommendationSummariesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accountIds
        case maxResults
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .accountIds)
        var accountIdsDecoded0:[String]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [String]()
            for string0 in accountIdsContainer {
                if let string0 = string0 {
                    accountIdsDecoded0?.append(string0)
                }
            }
        }
        accountIds = accountIdsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension GetRecommendationSummariesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetRecommendationSummariesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingAuthenticationToken" : self = .missingAuthenticationToken(try MissingAuthenticationToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OptInRequiredException" : self = .optInRequiredException(try OptInRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetRecommendationSummariesOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case invalidParameterValueException(InvalidParameterValueException)
    case missingAuthenticationToken(MissingAuthenticationToken)
    case optInRequiredException(OptInRequiredException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRecommendationSummariesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetRecommendationSummariesOutputResponse(nextToken: \(String(describing: nextToken)), recommendationSummaries: \(String(describing: recommendationSummaries)))"}
}

extension GetRecommendationSummariesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetRecommendationSummariesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.recommendationSummaries = output.recommendationSummaries
        } else {
            self.nextToken = nil
            self.recommendationSummaries = nil
        }
    }
}

public struct GetRecommendationSummariesOutputResponse: Equatable {
    /// <p>The token to use to advance to the next page of recommendation summaries.</p>
    ///         <p>This value is null when there are no more pages of recommendation summaries to
    ///             return.</p>
    public let nextToken: String?
    /// <p>An array of objects that summarize a recommendation.</p>
    public let recommendationSummaries: [RecommendationSummary]?

    public init (
        nextToken: String? = nil,
        recommendationSummaries: [RecommendationSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.recommendationSummaries = recommendationSummaries
    }
}

struct GetRecommendationSummariesOutputResponseBody: Equatable {
    public let nextToken: String?
    public let recommendationSummaries: [RecommendationSummary]?
}

extension GetRecommendationSummariesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case recommendationSummaries
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let recommendationSummariesContainer = try containerValues.decodeIfPresent([RecommendationSummary?].self, forKey: .recommendationSummaries)
        var recommendationSummariesDecoded0:[RecommendationSummary]? = nil
        if let recommendationSummariesContainer = recommendationSummariesContainer {
            recommendationSummariesDecoded0 = [RecommendationSummary]()
            for structure0 in recommendationSummariesContainer {
                if let structure0 = structure0 {
                    recommendationSummariesDecoded0?.append(structure0)
                }
            }
        }
        recommendationSummaries = recommendationSummariesDecoded0
    }
}

extension InstanceRecommendation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountId
        case currentInstanceType
        case finding
        case findingReasonCodes
        case instanceArn
        case instanceName
        case lastRefreshTimestamp
        case lookBackPeriodInDays
        case recommendationOptions
        case recommendationSources
        case utilizationMetrics
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let currentInstanceType = currentInstanceType {
            try encodeContainer.encode(currentInstanceType, forKey: .currentInstanceType)
        }
        if let finding = finding {
            try encodeContainer.encode(finding.rawValue, forKey: .finding)
        }
        if let findingReasonCodes = findingReasonCodes {
            var findingReasonCodesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .findingReasonCodes)
            for instancerecommendationfindingreasoncodes0 in findingReasonCodes {
                try findingReasonCodesContainer.encode(instancerecommendationfindingreasoncodes0.rawValue)
            }
        }
        if let instanceArn = instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
        if let instanceName = instanceName {
            try encodeContainer.encode(instanceName, forKey: .instanceName)
        }
        if let lastRefreshTimestamp = lastRefreshTimestamp {
            try encodeContainer.encode(lastRefreshTimestamp.timeIntervalSince1970, forKey: .lastRefreshTimestamp)
        }
        if lookBackPeriodInDays != 0.0 {
            try encodeContainer.encode(lookBackPeriodInDays, forKey: .lookBackPeriodInDays)
        }
        if let recommendationOptions = recommendationOptions {
            var recommendationOptionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .recommendationOptions)
            for recommendationoptions0 in recommendationOptions {
                try recommendationOptionsContainer.encode(recommendationoptions0)
            }
        }
        if let recommendationSources = recommendationSources {
            var recommendationSourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .recommendationSources)
            for recommendationsources0 in recommendationSources {
                try recommendationSourcesContainer.encode(recommendationsources0)
            }
        }
        if let utilizationMetrics = utilizationMetrics {
            var utilizationMetricsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .utilizationMetrics)
            for utilizationmetrics0 in utilizationMetrics {
                try utilizationMetricsContainer.encode(utilizationmetrics0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let instanceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceName)
        instanceName = instanceNameDecoded
        let currentInstanceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .currentInstanceType)
        currentInstanceType = currentInstanceTypeDecoded
        let findingDecoded = try containerValues.decodeIfPresent(Finding.self, forKey: .finding)
        finding = findingDecoded
        let findingReasonCodesContainer = try containerValues.decodeIfPresent([InstanceRecommendationFindingReasonCode?].self, forKey: .findingReasonCodes)
        var findingReasonCodesDecoded0:[InstanceRecommendationFindingReasonCode]? = nil
        if let findingReasonCodesContainer = findingReasonCodesContainer {
            findingReasonCodesDecoded0 = [InstanceRecommendationFindingReasonCode]()
            for string0 in findingReasonCodesContainer {
                if let string0 = string0 {
                    findingReasonCodesDecoded0?.append(string0)
                }
            }
        }
        findingReasonCodes = findingReasonCodesDecoded0
        let utilizationMetricsContainer = try containerValues.decodeIfPresent([UtilizationMetric?].self, forKey: .utilizationMetrics)
        var utilizationMetricsDecoded0:[UtilizationMetric]? = nil
        if let utilizationMetricsContainer = utilizationMetricsContainer {
            utilizationMetricsDecoded0 = [UtilizationMetric]()
            for structure0 in utilizationMetricsContainer {
                if let structure0 = structure0 {
                    utilizationMetricsDecoded0?.append(structure0)
                }
            }
        }
        utilizationMetrics = utilizationMetricsDecoded0
        let lookBackPeriodInDaysDecoded = try containerValues.decode(Double.self, forKey: .lookBackPeriodInDays)
        lookBackPeriodInDays = lookBackPeriodInDaysDecoded
        let recommendationOptionsContainer = try containerValues.decodeIfPresent([InstanceRecommendationOption?].self, forKey: .recommendationOptions)
        var recommendationOptionsDecoded0:[InstanceRecommendationOption]? = nil
        if let recommendationOptionsContainer = recommendationOptionsContainer {
            recommendationOptionsDecoded0 = [InstanceRecommendationOption]()
            for structure0 in recommendationOptionsContainer {
                if let structure0 = structure0 {
                    recommendationOptionsDecoded0?.append(structure0)
                }
            }
        }
        recommendationOptions = recommendationOptionsDecoded0
        let recommendationSourcesContainer = try containerValues.decodeIfPresent([RecommendationSource?].self, forKey: .recommendationSources)
        var recommendationSourcesDecoded0:[RecommendationSource]? = nil
        if let recommendationSourcesContainer = recommendationSourcesContainer {
            recommendationSourcesDecoded0 = [RecommendationSource]()
            for structure0 in recommendationSourcesContainer {
                if let structure0 = structure0 {
                    recommendationSourcesDecoded0?.append(structure0)
                }
            }
        }
        recommendationSources = recommendationSourcesDecoded0
        let lastRefreshTimestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastRefreshTimestamp)
        lastRefreshTimestamp = lastRefreshTimestampDecoded
    }
}

extension InstanceRecommendation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InstanceRecommendation(accountId: \(String(describing: accountId)), currentInstanceType: \(String(describing: currentInstanceType)), finding: \(String(describing: finding)), findingReasonCodes: \(String(describing: findingReasonCodes)), instanceArn: \(String(describing: instanceArn)), instanceName: \(String(describing: instanceName)), lastRefreshTimestamp: \(String(describing: lastRefreshTimestamp)), lookBackPeriodInDays: \(String(describing: lookBackPeriodInDays)), recommendationOptions: \(String(describing: recommendationOptions)), recommendationSources: \(String(describing: recommendationSources)), utilizationMetrics: \(String(describing: utilizationMetrics)))"}
}

/// <p>Describes an Amazon EC2 instance recommendation.</p>
public struct InstanceRecommendation: Equatable {
    /// <p>The AWS account ID of the instance.</p>
    public let accountId: String?
    /// <p>The instance type of the current instance.</p>
    public let currentInstanceType: String?
    /// <p>The finding classification of the instance.</p>
    ///         <p>Findings for instances include:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <b>
    ///                      <code>Underprovisioned</code>
    ///                   </b>—An instance is
    ///                     considered under-provisioned when at least one specification of your instance,
    ///                     such as CPU, memory, or network, does not meet the performance requirements of
    ///                     your workload. Under-provisioned instances may lead to poor application
    ///                     performance.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <b>
    ///                      <code>Overprovisioned</code>
    ///                   </b>—An instance is
    ///                     considered over-provisioned when at least one specification of your instance,
    ///                     such as CPU, memory, or network, can be sized down while still meeting the
    ///                     performance requirements of your workload, and no specification is
    ///                     under-provisioned. Over-provisioned instances may lead to unnecessary
    ///                     infrastructure cost.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <b>
    ///                      <code>Optimized</code>
    ///                   </b>—An instance
    ///                     is considered optimized when all specifications of your instance, such as CPU,
    ///                     memory, and network, meet the performance requirements of your workload and is
    ///                     not over provisioned. For optimized resources, AWS Compute Optimizer might recommend a new
    ///                     generation instance type.</p>
    ///
    ///
    ///             </li>
    ///          </ul>
    public let finding: Finding?
    /// <p>The reason for the finding classification of the instance.</p>
    ///         <p>Finding reason codes for instances include:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <b>
    ///                      <code>CPUOverprovisioned</code>
    ///                   </b> — The
    ///                     instance’s CPU configuration can be sized down while still meeting the
    ///                     performance requirements of your workload. This is identified by analyzing the
    ///                         <code>CPUUtilization</code> metric of the current instance during the
    ///                     look-back period.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <b>
    ///                      <code>CPUUnderprovisioned</code>
    ///                   </b> — The
    ///                     instance’s CPU configuration doesn't meet the performance requirements of your
    ///                     workload and there is an alternative instance type that provides better CPU
    ///                     performance. This is identified by analyzing the <code>CPUUtilization</code>
    ///                     metric of the current instance during the look-back period.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <b>
    ///                      <code>MemoryOverprovisioned</code>
    ///                   </b> — The
    ///                     instance’s memory configuration can be sized down while still meeting the
    ///                     performance requirements of your workload. This is identified by analyzing the
    ///                     memory utilization metric of the current instance during the look-back
    ///                     period.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <b>
    ///                      <code>MemoryUnderprovisioned</code>
    ///                   </b> — The
    ///                     instance’s memory configuration doesn't meet the performance requirements of
    ///                     your workload and there is an alternative instance type that provides better
    ///                     memory performance. This is identified by analyzing the memory utilization
    ///                     metric of the current instance during the look-back period.</p>
    ///                 <note>
    ///                     <p>Memory utilization is analyzed only for resources that have the
    ///                         unified CloudWatch agent installed on them. For more information, see <a href="https://docs.aws.amazon.com/compute-optimizer/latest/ug/metrics.html#cw-agent">Enabling memory
    ///                             utilization with the Amazon CloudWatch Agent</a> in the <i>AWS Compute Optimizer
    ///                             User Guide</i>. On Linux instances, Compute Optimizer analyses the
    ///                             <code>mem_used_percent</code> metric in the <code>CWAgent</code>
    ///                         namespace, or the legacy <code>MemoryUtilization</code> metric in the
    ///                             <code>System/Linux</code> namespace. On Windows instances, Compute Optimizer analyses
    ///                         the <code>Memory % Committed Bytes In Use</code> metric in the
    ///                             <code>CWAgent</code> namespace.</p>
    ///
    ///
    ///                 </note>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <b>
    ///                      <code>EBSThroughputOverprovisioned</code>
    ///                   </b> —
    ///                     The instance’s EBS throughput configuration can be sized down while still
    ///                     meeting the performance requirements of your workload. This is identified by
    ///                     analyzing the <code>VolumeReadOps</code> and <code>VolumeWriteOps</code> metrics
    ///                     of EBS volumes attached to the current instance during the look-back
    ///                     period.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <b>
    ///                      <code>EBSThroughputUnderprovisioned</code>
    ///                   </b> —
    ///                     The instance’s EBS throughput configuration doesn't meet the performance
    ///                     requirements of your workload and there is an alternative instance type that
    ///                     provides better EBS throughput performance. This is identified by analyzing the
    ///                         <code>VolumeReadOps</code> and <code>VolumeWriteOps</code> metrics of EBS
    ///                     volumes attached to the current instance during the look-back period.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <b>
    ///                      <code>EBSIOPSOverprovisioned</code>
    ///                   </b> — The
    ///                     instance’s EBS IOPS configuration can be sized down while still meeting the
    ///                     performance requirements of your workload. This is identified by analyzing the
    ///                         <code>VolumeReadBytes</code> and <code>VolumeWriteBytes</code> metric of EBS
    ///                     volumes attached to the current instance during the look-back period.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <b>
    ///                      <code>EBSIOPSUnderprovisioned</code>
    ///                   </b> — The
    ///                     instance’s EBS IOPS configuration doesn't meet the performance requirements of
    ///                     your workload and there is an alternative instance type that provides better EBS
    ///                     IOPS performance. This is identified by analyzing the
    ///                         <code>VolumeReadBytes</code> and <code>VolumeWriteBytes</code> metric of EBS
    ///                     volumes attached to the current instance during the look-back period.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <b>
    ///                      <code>NetworkBandwidthOverprovisioned</code>
    ///                   </b>
    ///                     — The instance’s network bandwidth configuration can be sized down while still
    ///                     meeting the performance requirements of your workload. This is identified by
    ///                     analyzing the <code>NetworkIn</code> and <code>NetworkOut</code> metrics of the
    ///                     current instance during the look-back period.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <b>
    ///                      <code>NetworkBandwidthUnderprovisioned</code>
    ///                   </b>
    ///                     — The instance’s network bandwidth configuration doesn't meet the performance
    ///                     requirements of your workload and there is an alternative instance type that
    ///                     provides better network bandwidth performance. This is identified by analyzing
    ///                     the <code>NetworkIn</code> and <code>NetworkOut</code> metrics of the current
    ///                     instance during the look-back period. This finding reason happens when the
    ///                         <code>NetworkIn</code> or <code>NetworkOut</code> performance of an instance
    ///                     is impacted.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <b>
    ///                      <code>NetworkPPSOverprovisioned</code>
    ///                   </b> — The
    ///                     instance’s network PPS (packets per second) configuration can be sized down
    ///                     while still meeting the performance requirements of your workload. This is
    ///                     identified by analyzing the <code>NetworkPacketsIn</code> and
    ///                         <code>NetworkPacketsIn</code> metrics of the current instance during the
    ///                     look-back period.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <b>
    ///                      <code>NetworkPPSUnderprovisioned</code>
    ///                   </b> — The
    ///                     instance’s network PPS (packets per second) configuration doesn't meet the
    ///                     performance requirements of your workload and there is an alternative instance
    ///                     type that provides better network PPS performance. This is identified by
    ///                     analyzing the <code>NetworkPacketsIn</code> and <code>NetworkPacketsIn</code>
    ///                     metrics of the current instance during the look-back period.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <b>
    ///                      <code>DiskIOPSOverprovisioned</code>
    ///                   </b> — The
    ///                     instance’s disk IOPS configuration can be sized down while still meeting the
    ///                     performance requirements of your workload. This is identified by analyzing the
    ///                         <code>DiskReadOps</code> and <code>DiskWriteOps</code> metrics of the
    ///                     current instance during the look-back period.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <b>
    ///                      <code>DiskIOPSUnderprovisioned</code>
    ///                   </b> — The
    ///                     instance’s disk IOPS configuration doesn't meet the performance requirements of
    ///                     your workload and there is an alternative instance type that provides better
    ///                     disk IOPS performance. This is identified by analyzing the
    ///                         <code>DiskReadOps</code> and <code>DiskWriteOps</code> metrics of the
    ///                     current instance during the look-back period.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <b>
    ///                      <code>DiskThroughputOverprovisioned</code>
    ///                   </b> —
    ///                     The instance’s disk throughput configuration can be sized down while still
    ///                     meeting the performance requirements of your workload. This is identified by
    ///                     analyzing the <code>DiskReadBytes</code> and <code>DiskWriteBytes</code> metrics
    ///                     of the current instance during the look-back period.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <b>
    ///                      <code>DiskThroughputUnderprovisioned</code>
    ///                   </b> —
    ///                     The instance’s disk throughput configuration doesn't meet the performance
    ///                     requirements of your workload and there is an alternative instance type that
    ///                     provides better disk throughput performance. This is identified by analyzing the
    ///                         <code>DiskReadBytes</code> and <code>DiskWriteBytes</code> metrics of the
    ///                     current instance during the look-back period.</p>
    ///             </li>
    ///          </ul>
    ///         <note>
    ///             <p>For more information about instance metrics, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/viewing_metrics_with_cloudwatch.html">List the
    ///                     available CloudWatch metrics for your instances</a> in the <i>Amazon Elastic Compute Cloud
    ///                     User Guide</i>. For more information about EBS volume metrics, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using_cloudwatch_ebs.html">Amazon CloudWatch metrics for Amazon EBS</a> in the <i>Amazon Elastic Compute Cloud User
    ///                     Guide</i>.</p>
    ///         </note>
    public let findingReasonCodes: [InstanceRecommendationFindingReasonCode]?
    /// <p>The Amazon Resource Name (ARN) of the current instance.</p>
    public let instanceArn: String?
    /// <p>The name of the current instance.</p>
    public let instanceName: String?
    /// <p>The time stamp of when the instance recommendation was last refreshed.</p>
    public let lastRefreshTimestamp: Date?
    /// <p>The number of days for which utilization metrics were analyzed for the
    ///             instance.</p>
    public let lookBackPeriodInDays: Double
    /// <p>An array of objects that describe the recommendation options for the instance.</p>
    public let recommendationOptions: [InstanceRecommendationOption]?
    /// <p>An array of objects that describe the source resource of the recommendation.</p>
    public let recommendationSources: [RecommendationSource]?
    /// <p>An array of objects that describe the utilization metrics of the instance.</p>
    public let utilizationMetrics: [UtilizationMetric]?

    public init (
        accountId: String? = nil,
        currentInstanceType: String? = nil,
        finding: Finding? = nil,
        findingReasonCodes: [InstanceRecommendationFindingReasonCode]? = nil,
        instanceArn: String? = nil,
        instanceName: String? = nil,
        lastRefreshTimestamp: Date? = nil,
        lookBackPeriodInDays: Double = 0.0,
        recommendationOptions: [InstanceRecommendationOption]? = nil,
        recommendationSources: [RecommendationSource]? = nil,
        utilizationMetrics: [UtilizationMetric]? = nil
    )
    {
        self.accountId = accountId
        self.currentInstanceType = currentInstanceType
        self.finding = finding
        self.findingReasonCodes = findingReasonCodes
        self.instanceArn = instanceArn
        self.instanceName = instanceName
        self.lastRefreshTimestamp = lastRefreshTimestamp
        self.lookBackPeriodInDays = lookBackPeriodInDays
        self.recommendationOptions = recommendationOptions
        self.recommendationSources = recommendationSources
        self.utilizationMetrics = utilizationMetrics
    }
}

public enum InstanceRecommendationFindingReasonCode {
    case cpuOverProvisioned
    case cpuUnderProvisioned
    case diskIopsOverProvisioned
    case diskIopsUnderProvisioned
    case diskThroughputOverProvisioned
    case diskThroughputUnderProvisioned
    case ebsIopsOverProvisioned
    case ebsIopsUnderProvisioned
    case ebsThroughputOverProvisioned
    case ebsThroughputUnderProvisioned
    case memoryOverProvisioned
    case memoryUnderProvisioned
    case networkBandwidthOverProvisioned
    case networkBandwidthUnderProvisioned
    case networkPpsOverProvisioned
    case networkPpsUnderProvisioned
    case sdkUnknown(String)
}

extension InstanceRecommendationFindingReasonCode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [InstanceRecommendationFindingReasonCode] {
        return [
            .cpuOverProvisioned,
            .cpuUnderProvisioned,
            .diskIopsOverProvisioned,
            .diskIopsUnderProvisioned,
            .diskThroughputOverProvisioned,
            .diskThroughputUnderProvisioned,
            .ebsIopsOverProvisioned,
            .ebsIopsUnderProvisioned,
            .ebsThroughputOverProvisioned,
            .ebsThroughputUnderProvisioned,
            .memoryOverProvisioned,
            .memoryUnderProvisioned,
            .networkBandwidthOverProvisioned,
            .networkBandwidthUnderProvisioned,
            .networkPpsOverProvisioned,
            .networkPpsUnderProvisioned,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .cpuOverProvisioned: return "CPUOverprovisioned"
        case .cpuUnderProvisioned: return "CPUUnderprovisioned"
        case .diskIopsOverProvisioned: return "DiskIOPSOverprovisioned"
        case .diskIopsUnderProvisioned: return "DiskIOPSUnderprovisioned"
        case .diskThroughputOverProvisioned: return "DiskThroughputOverprovisioned"
        case .diskThroughputUnderProvisioned: return "DiskThroughputUnderprovisioned"
        case .ebsIopsOverProvisioned: return "EBSIOPSOverprovisioned"
        case .ebsIopsUnderProvisioned: return "EBSIOPSUnderprovisioned"
        case .ebsThroughputOverProvisioned: return "EBSThroughputOverprovisioned"
        case .ebsThroughputUnderProvisioned: return "EBSThroughputUnderprovisioned"
        case .memoryOverProvisioned: return "MemoryOverprovisioned"
        case .memoryUnderProvisioned: return "MemoryUnderprovisioned"
        case .networkBandwidthOverProvisioned: return "NetworkBandwidthOverprovisioned"
        case .networkBandwidthUnderProvisioned: return "NetworkBandwidthUnderprovisioned"
        case .networkPpsOverProvisioned: return "NetworkPPSOverprovisioned"
        case .networkPpsUnderProvisioned: return "NetworkPPSUnderprovisioned"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = InstanceRecommendationFindingReasonCode(rawValue: rawValue) ?? InstanceRecommendationFindingReasonCode.sdkUnknown(rawValue)
    }
}

extension InstanceRecommendationOption: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case instanceType
        case performanceRisk
        case platformDifferences
        case projectedUtilizationMetrics
        case rank
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceType = instanceType {
            try encodeContainer.encode(instanceType, forKey: .instanceType)
        }
        if performanceRisk != 0.0 {
            try encodeContainer.encode(performanceRisk, forKey: .performanceRisk)
        }
        if let platformDifferences = platformDifferences {
            var platformDifferencesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .platformDifferences)
            for platformdifferences0 in platformDifferences {
                try platformDifferencesContainer.encode(platformdifferences0.rawValue)
            }
        }
        if let projectedUtilizationMetrics = projectedUtilizationMetrics {
            var projectedUtilizationMetricsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .projectedUtilizationMetrics)
            for projectedutilizationmetrics0 in projectedUtilizationMetrics {
                try projectedUtilizationMetricsContainer.encode(projectedutilizationmetrics0)
            }
        }
        if rank != 0 {
            try encodeContainer.encode(rank, forKey: .rank)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceType)
        instanceType = instanceTypeDecoded
        let projectedUtilizationMetricsContainer = try containerValues.decodeIfPresent([UtilizationMetric?].self, forKey: .projectedUtilizationMetrics)
        var projectedUtilizationMetricsDecoded0:[UtilizationMetric]? = nil
        if let projectedUtilizationMetricsContainer = projectedUtilizationMetricsContainer {
            projectedUtilizationMetricsDecoded0 = [UtilizationMetric]()
            for structure0 in projectedUtilizationMetricsContainer {
                if let structure0 = structure0 {
                    projectedUtilizationMetricsDecoded0?.append(structure0)
                }
            }
        }
        projectedUtilizationMetrics = projectedUtilizationMetricsDecoded0
        let platformDifferencesContainer = try containerValues.decodeIfPresent([PlatformDifference?].self, forKey: .platformDifferences)
        var platformDifferencesDecoded0:[PlatformDifference]? = nil
        if let platformDifferencesContainer = platformDifferencesContainer {
            platformDifferencesDecoded0 = [PlatformDifference]()
            for string0 in platformDifferencesContainer {
                if let string0 = string0 {
                    platformDifferencesDecoded0?.append(string0)
                }
            }
        }
        platformDifferences = platformDifferencesDecoded0
        let performanceRiskDecoded = try containerValues.decode(Double.self, forKey: .performanceRisk)
        performanceRisk = performanceRiskDecoded
        let rankDecoded = try containerValues.decode(Int.self, forKey: .rank)
        rank = rankDecoded
    }
}

extension InstanceRecommendationOption: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InstanceRecommendationOption(instanceType: \(String(describing: instanceType)), performanceRisk: \(String(describing: performanceRisk)), platformDifferences: \(String(describing: platformDifferences)), projectedUtilizationMetrics: \(String(describing: projectedUtilizationMetrics)), rank: \(String(describing: rank)))"}
}

/// <p>Describes a recommendation option for an Amazon EC2 instance.</p>
public struct InstanceRecommendationOption: Equatable {
    /// <p>The instance type of the instance recommendation.</p>
    public let instanceType: String?
    /// <p>The performance risk of the instance recommendation option.</p>
    ///         <p>Performance risk indicates the likelihood of the recommended instance type not meeting
    ///             the resource needs of your workload. Compute Optimizer calculates an individual performance risk
    ///             score for each specification of the recommended instance, including CPU, memory, EBS
    ///             throughput, EBS IOPS, disk throughput, disk IOPS, network throughput, and network PPS.
    ///             The performance
    ///             risk of the recommended instance is calculated as the maximum performance risk score
    ///             across the analyzed resource specifications.</p>
    ///         <p>The value ranges from <code>0</code> to <code>5</code>, with <code>0</code> meaning
    ///             that the recommended resource is predicted to always provide enough hardware capability.
    ///             The higher the performance risk is, the more likely you should validate whether the
    ///             recommendation will meet the performance requirements of your workload before migrating
    ///             your resource.</p>
    public let performanceRisk: Double
    /// <p>Describes the configuration differences between the current instance and the
    ///             recommended instance type. You should consider the configuration differences before
    ///             migrating your workloads from the current instance to the recommended instance type. The
    ///                 <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-resize.html">Change the instance type guide for Linux</a> and <a href="https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/ec2-instance-resize.html">Change the instance type
    ///                 guide for Windows</a> provide general guidance for getting started with an
    ///             instance migration.</p>
    ///
    ///         <p>Platform differences include:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <b>
    ///                      <code>Hypervisor</code>
    ///                   </b> — The
    ///                     hypervisor of the recommended instance type is different than that of the
    ///                     current instance. For example, the recommended instance type uses a Nitro
    ///                     hypervisor and the current instance uses a Xen hypervisor. The differences that
    ///                     you should consider between these hypervisors are covered in the <a href="http://aws.amazon.com/ec2/faqs/#Nitro_Hypervisor">Nitro Hypervisor</a>
    ///                     section of the Amazon EC2 frequently asked questions. For more information, see
    ///                         <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html#ec2-nitro-instances">Instances built on the Nitro System</a> in the <i>Amazon EC2
    ///                         User Guide for Linux</i>, or <a href="https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/instance-types.html#ec2-nitro-instances">Instances built on the Nitro System</a> in the <i>Amazon EC2
    ///                         User Guide for Windows</i>.</p>
    ///
    ///
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <b>
    ///                      <code>NetworkInterface</code>
    ///                   </b> — The network
    ///                     interface of the recommended instance type is different than that of the current
    ///                     instance. For example, the recommended instance type supports enhanced
    ///                     networking and the current instance might not. To enable enhanced networking for
    ///                     the recommended instance type, you will need to install the Elastic Network
    ///                     Adapter (ENA) driver or the Intel 82599 Virtual Function driver. For more
    ///                     information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html#instance-networking-storage">Networking and storage features</a> and <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/enhanced-networking.html">Enhanced networking
    ///                         on Linux</a> in the <i>Amazon EC2 User Guide for
    ///                     Linux</i>, or <a href="https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/instance-types.html#instance-networking-storage">Networking and storage features</a> and <a href="https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/enhanced-networking.html">Enhanced
    ///                         networking on Windows</a> in the <i>Amazon EC2 User Guide for
    ///                         Windows</i>.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <b>
    ///                      <code>StorageInterface</code>
    ///                   </b> — The storage
    ///                     interface of the recommended instance type is different than that of the current
    ///                     instance. For example, the recommended instance type uses an NVMe storage
    ///                     interface and the current instance does not. To access NVMe volumes for the
    ///                     recommended instance type, you will need to install or upgrade the NVMe driver.
    ///                     For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html#instance-networking-storage">Networking and storage features</a> and <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/nvme-ebs-volumes.html">Amazon EBS and NVMe on
    ///                         Linux instances</a> in the <i>Amazon EC2 User Guide for
    ///                         Linux</i>, or <a href="https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/instance-types.html#instance-networking-storage">Networking and storage features</a> and <a href="https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/nvme-ebs-volumes.html">Amazon EBS and NVMe
    ///                         on Windows instances</a> in the <i>Amazon EC2 User Guide for
    ///                         Windows</i>.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <b>
    ///                      <code>InstanceStoreAvailability</code>
    ///                   </b> — The recommended
    ///                     instance type does not support instance store volumes and the current instance
    ///                     does. Before migrating, you might need to back up the data on your instance
    ///                     store volumes if you want to preserve them. For more information, see <a href="https://aws.amazon.com/premiumsupport/knowledge-center/back-up-instance-store-ebs/">How do I back up an instance store volume on my Amazon EC2 instance to
    ///                         Amazon EBS?</a> in the <i>AWS Premium Support Knowledge
    ///                         Base</i>. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html#instance-networking-storage">Networking and storage features</a> and <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html">Amazon EC2 instance
    ///                         store</a> in the <i>Amazon EC2 User Guide for Linux</i>, or see
    ///                         <a href="https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/instance-types.html#instance-networking-storage">Networking and storage features</a> and <a href="https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/InstanceStorage.html">Amazon EC2 instance
    ///                         store</a> in the <i>Amazon EC2 User Guide for
    ///                     Windows</i>.</p>
    ///
    ///
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <b>
    ///                      <code>VirtualizationType</code>
    ///                   </b> — The
    ///                     recommended instance type uses the hardware virtual machine (HVM) virtualization
    ///                     type and the current instance uses the paravirtual (PV) virtualization type. For
    ///                     more information about the differences between these virtualization types, see
    ///                         <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/virtualization_types.html">Linux AMI
    ///                         virtualization types</a> in the <i>Amazon EC2 User Guide for
    ///                         Linux</i>, or <a href="https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/windows-ami-version-history.html#virtualization-types">Windows AMI virtualization types</a> in the <i>Amazon EC2 User
    ///                         Guide for Windows</i>.</p>
    ///             </li>
    ///          </ul>
    public let platformDifferences: [PlatformDifference]?
    /// <p>An array of objects that describe the projected utilization metrics of the instance
    ///             recommendation option.</p>
    ///
    ///         <note>
    ///             <p>The <code>Cpu</code> and <code>Memory</code> metrics are the only projected
    ///                 utilization metrics returned. Additionally, the <code>Memory</code> metric is
    ///                 returned only for resources that have the unified CloudWatch agent installed on them. For
    ///                 more information, see <a href="https://docs.aws.amazon.com/compute-optimizer/latest/ug/metrics.html#cw-agent">Enabling Memory
    ///                     Utilization with the CloudWatch Agent</a>.</p>
    ///         </note>
    public let projectedUtilizationMetrics: [UtilizationMetric]?
    /// <p>The rank of the instance recommendation option.</p>
    ///         <p>The top recommendation option is ranked as <code>1</code>.</p>
    public let rank: Int

    public init (
        instanceType: String? = nil,
        performanceRisk: Double = 0.0,
        platformDifferences: [PlatformDifference]? = nil,
        projectedUtilizationMetrics: [UtilizationMetric]? = nil,
        rank: Int = 0
    )
    {
        self.instanceType = instanceType
        self.performanceRisk = performanceRisk
        self.platformDifferences = platformDifferences
        self.projectedUtilizationMetrics = projectedUtilizationMetrics
        self.rank = rank
    }
}

extension InternalServerException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalServerException(message: \(String(describing: message)))"}
}

extension InternalServerException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An internal error has occurred. Try your call again.</p>
public struct InternalServerException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Equatable {
    public let message: String?
}

extension InternalServerExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidParameterValueException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidParameterValueException(message: \(String(describing: message)))"}
}

extension InvalidParameterValueException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidParameterValueExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An invalid or out-of-range value was supplied for the input parameter.</p>
public struct InvalidParameterValueException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidParameterValueExceptionBody: Equatable {
    public let message: String?
}

extension InvalidParameterValueExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension JobFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name
        case values
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for filtervalues0 in values {
                try valuesContainer.encode(filtervalues0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(JobFilterName.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .values)
        var valuesDecoded0:[String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension JobFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "JobFilter(name: \(String(describing: name)), values: \(String(describing: values)))"}
}

/// <p>Describes a filter that returns a more specific list of recommendation export jobs.
///             Use this filter with the <code>DescribeRecommendationExportJobs</code> action.</p>
///
///         <p>You can use <code>EBSFilter</code> with the <code>GetEBSVolumeRecommendations</code>
///             action, <code>LambdaFunctionRecommendationFilter</code> with the
///                 <code>GetLambdaFunctionRecommendations</code> action, and <code>Filter</code> with
///             the <code>GetAutoScalingGroupRecommendations</code> and
///                 <code>GetEC2InstanceRecommendations</code> actions.</p>
public struct JobFilter: Equatable {
    /// <p>The name of the filter.</p>
    ///
    ///         <p>Specify <code>ResourceType</code> to return export jobs of a specific resource type
    ///             (e.g., <code>Ec2Instance</code>).</p>
    ///
    ///         <p>Specify <code>JobStatus</code> to return export jobs with a specific status (e.g,
    ///                 <code>Complete</code>).</p>
    public let name: JobFilterName?
    /// <p>The value of the filter.</p>
    ///
    ///         <p>The valid values for this parameter are as follows, depending on what you specify for
    ///             the <code>name</code> parameter:</p>
    ///
    ///         <ul>
    ///             <li>
    ///                 <p>Specify <code>Ec2Instance</code> or <code>AutoScalingGroup</code> if you
    ///                     specify the <code>name</code> parameter as <code>ResourceType</code>. There is
    ///                     no filter for EBS volumes because volume recommendations cannot be exported at
    ///                     this time.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Specify <code>Queued</code>, <code>InProgress</code>, <code>Complete</code>,
    ///                     or <code>Failed</code> if you specify the <code>name</code> parameter as
    ///                         <code>JobStatus</code>.</p>
    ///             </li>
    ///          </ul>
    public let values: [String]?

    public init (
        name: JobFilterName? = nil,
        values: [String]? = nil
    )
    {
        self.name = name
        self.values = values
    }
}

public enum JobFilterName {
    case jobStatus
    case resourceType
    case sdkUnknown(String)
}

extension JobFilterName : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [JobFilterName] {
        return [
            .jobStatus,
            .resourceType,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .jobStatus: return "JobStatus"
        case .resourceType: return "ResourceType"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = JobFilterName(rawValue: rawValue) ?? JobFilterName.sdkUnknown(rawValue)
    }
}

public enum JobStatus {
    case complete
    case failed
    case inProgress
    case queued
    case sdkUnknown(String)
}

extension JobStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [JobStatus] {
        return [
            .complete,
            .failed,
            .inProgress,
            .queued,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .complete: return "Complete"
        case .failed: return "Failed"
        case .inProgress: return "InProgress"
        case .queued: return "Queued"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = JobStatus(rawValue: rawValue) ?? JobStatus.sdkUnknown(rawValue)
    }
}

public enum LambdaFunctionMemoryMetricName {
    case duration
    case sdkUnknown(String)
}

extension LambdaFunctionMemoryMetricName : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [LambdaFunctionMemoryMetricName] {
        return [
            .duration,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .duration: return "Duration"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = LambdaFunctionMemoryMetricName(rawValue: rawValue) ?? LambdaFunctionMemoryMetricName.sdkUnknown(rawValue)
    }
}

public enum LambdaFunctionMemoryMetricStatistic {
    case expected
    case lowerBound
    case upperBound
    case sdkUnknown(String)
}

extension LambdaFunctionMemoryMetricStatistic : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [LambdaFunctionMemoryMetricStatistic] {
        return [
            .expected,
            .lowerBound,
            .upperBound,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .expected: return "Expected"
        case .lowerBound: return "LowerBound"
        case .upperBound: return "UpperBound"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = LambdaFunctionMemoryMetricStatistic(rawValue: rawValue) ?? LambdaFunctionMemoryMetricStatistic.sdkUnknown(rawValue)
    }
}

extension LambdaFunctionMemoryProjectedMetric: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name
        case statistic
        case value
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let statistic = statistic {
            try encodeContainer.encode(statistic.rawValue, forKey: .statistic)
        }
        if value != 0.0 {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(LambdaFunctionMemoryMetricName.self, forKey: .name)
        name = nameDecoded
        let statisticDecoded = try containerValues.decodeIfPresent(LambdaFunctionMemoryMetricStatistic.self, forKey: .statistic)
        statistic = statisticDecoded
        let valueDecoded = try containerValues.decode(Double.self, forKey: .value)
        value = valueDecoded
    }
}

extension LambdaFunctionMemoryProjectedMetric: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LambdaFunctionMemoryProjectedMetric(name: \(String(describing: name)), statistic: \(String(describing: statistic)), value: \(String(describing: value)))"}
}

/// <p>Describes a projected utilization metric of an AWS Lambda function
///             recommendation option.</p>
public struct LambdaFunctionMemoryProjectedMetric: Equatable {
    /// <p>The name of the projected utilization metric.</p>
    public let name: LambdaFunctionMemoryMetricName?
    /// <p>The statistic of the projected utilization metric.</p>
    public let statistic: LambdaFunctionMemoryMetricStatistic?
    /// <p>The values of the projected utilization metrics.</p>
    public let value: Double

    public init (
        name: LambdaFunctionMemoryMetricName? = nil,
        statistic: LambdaFunctionMemoryMetricStatistic? = nil,
        value: Double = 0.0
    )
    {
        self.name = name
        self.statistic = statistic
        self.value = value
    }
}

extension LambdaFunctionMemoryRecommendationOption: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case memorySize
        case projectedUtilizationMetrics
        case rank
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if memorySize != 0 {
            try encodeContainer.encode(memorySize, forKey: .memorySize)
        }
        if let projectedUtilizationMetrics = projectedUtilizationMetrics {
            var projectedUtilizationMetricsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .projectedUtilizationMetrics)
            for lambdafunctionmemoryprojectedmetrics0 in projectedUtilizationMetrics {
                try projectedUtilizationMetricsContainer.encode(lambdafunctionmemoryprojectedmetrics0)
            }
        }
        if rank != 0 {
            try encodeContainer.encode(rank, forKey: .rank)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rankDecoded = try containerValues.decode(Int.self, forKey: .rank)
        rank = rankDecoded
        let memorySizeDecoded = try containerValues.decode(Int.self, forKey: .memorySize)
        memorySize = memorySizeDecoded
        let projectedUtilizationMetricsContainer = try containerValues.decodeIfPresent([LambdaFunctionMemoryProjectedMetric?].self, forKey: .projectedUtilizationMetrics)
        var projectedUtilizationMetricsDecoded0:[LambdaFunctionMemoryProjectedMetric]? = nil
        if let projectedUtilizationMetricsContainer = projectedUtilizationMetricsContainer {
            projectedUtilizationMetricsDecoded0 = [LambdaFunctionMemoryProjectedMetric]()
            for structure0 in projectedUtilizationMetricsContainer {
                if let structure0 = structure0 {
                    projectedUtilizationMetricsDecoded0?.append(structure0)
                }
            }
        }
        projectedUtilizationMetrics = projectedUtilizationMetricsDecoded0
    }
}

extension LambdaFunctionMemoryRecommendationOption: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LambdaFunctionMemoryRecommendationOption(memorySize: \(String(describing: memorySize)), projectedUtilizationMetrics: \(String(describing: projectedUtilizationMetrics)), rank: \(String(describing: rank)))"}
}

/// <p>Describes a recommendation option for an AWS Lambda function.</p>
public struct LambdaFunctionMemoryRecommendationOption: Equatable {
    /// <p>The memory size, in MB, of the function recommendation option.</p>
    public let memorySize: Int
    /// <p>An array of objects that describe the projected utilization metrics of the function
    ///             recommendation option.</p>
    public let projectedUtilizationMetrics: [LambdaFunctionMemoryProjectedMetric]?
    /// <p>The rank of the function recommendation option.</p>
    ///
    ///         <p>The top recommendation option is ranked as <code>1</code>.</p>
    public let rank: Int

    public init (
        memorySize: Int = 0,
        projectedUtilizationMetrics: [LambdaFunctionMemoryProjectedMetric]? = nil,
        rank: Int = 0
    )
    {
        self.memorySize = memorySize
        self.projectedUtilizationMetrics = projectedUtilizationMetrics
        self.rank = rank
    }
}

public enum LambdaFunctionMetricName {
    case duration
    case memory
    case sdkUnknown(String)
}

extension LambdaFunctionMetricName : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [LambdaFunctionMetricName] {
        return [
            .duration,
            .memory,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .duration: return "Duration"
        case .memory: return "Memory"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = LambdaFunctionMetricName(rawValue: rawValue) ?? LambdaFunctionMetricName.sdkUnknown(rawValue)
    }
}

public enum LambdaFunctionMetricStatistic {
    case average
    case maximum
    case sdkUnknown(String)
}

extension LambdaFunctionMetricStatistic : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [LambdaFunctionMetricStatistic] {
        return [
            .average,
            .maximum,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .average: return "Average"
        case .maximum: return "Maximum"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = LambdaFunctionMetricStatistic(rawValue: rawValue) ?? LambdaFunctionMetricStatistic.sdkUnknown(rawValue)
    }
}

extension LambdaFunctionRecommendation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountId
        case currentMemorySize
        case finding
        case findingReasonCodes
        case functionArn
        case functionVersion
        case lastRefreshTimestamp
        case lookbackPeriodInDays
        case memorySizeRecommendationOptions
        case numberOfInvocations
        case utilizationMetrics
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if currentMemorySize != 0 {
            try encodeContainer.encode(currentMemorySize, forKey: .currentMemorySize)
        }
        if let finding = finding {
            try encodeContainer.encode(finding.rawValue, forKey: .finding)
        }
        if let findingReasonCodes = findingReasonCodes {
            var findingReasonCodesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .findingReasonCodes)
            for lambdafunctionrecommendationfindingreasoncodes0 in findingReasonCodes {
                try findingReasonCodesContainer.encode(lambdafunctionrecommendationfindingreasoncodes0.rawValue)
            }
        }
        if let functionArn = functionArn {
            try encodeContainer.encode(functionArn, forKey: .functionArn)
        }
        if let functionVersion = functionVersion {
            try encodeContainer.encode(functionVersion, forKey: .functionVersion)
        }
        if let lastRefreshTimestamp = lastRefreshTimestamp {
            try encodeContainer.encode(lastRefreshTimestamp.timeIntervalSince1970, forKey: .lastRefreshTimestamp)
        }
        if lookbackPeriodInDays != 0.0 {
            try encodeContainer.encode(lookbackPeriodInDays, forKey: .lookbackPeriodInDays)
        }
        if let memorySizeRecommendationOptions = memorySizeRecommendationOptions {
            var memorySizeRecommendationOptionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .memorySizeRecommendationOptions)
            for lambdafunctionmemoryrecommendationoptions0 in memorySizeRecommendationOptions {
                try memorySizeRecommendationOptionsContainer.encode(lambdafunctionmemoryrecommendationoptions0)
            }
        }
        if numberOfInvocations != 0 {
            try encodeContainer.encode(numberOfInvocations, forKey: .numberOfInvocations)
        }
        if let utilizationMetrics = utilizationMetrics {
            var utilizationMetricsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .utilizationMetrics)
            for lambdafunctionutilizationmetrics0 in utilizationMetrics {
                try utilizationMetricsContainer.encode(lambdafunctionutilizationmetrics0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .functionArn)
        functionArn = functionArnDecoded
        let functionVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .functionVersion)
        functionVersion = functionVersionDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let currentMemorySizeDecoded = try containerValues.decode(Int.self, forKey: .currentMemorySize)
        currentMemorySize = currentMemorySizeDecoded
        let numberOfInvocationsDecoded = try containerValues.decode(Int.self, forKey: .numberOfInvocations)
        numberOfInvocations = numberOfInvocationsDecoded
        let utilizationMetricsContainer = try containerValues.decodeIfPresent([LambdaFunctionUtilizationMetric?].self, forKey: .utilizationMetrics)
        var utilizationMetricsDecoded0:[LambdaFunctionUtilizationMetric]? = nil
        if let utilizationMetricsContainer = utilizationMetricsContainer {
            utilizationMetricsDecoded0 = [LambdaFunctionUtilizationMetric]()
            for structure0 in utilizationMetricsContainer {
                if let structure0 = structure0 {
                    utilizationMetricsDecoded0?.append(structure0)
                }
            }
        }
        utilizationMetrics = utilizationMetricsDecoded0
        let lookbackPeriodInDaysDecoded = try containerValues.decode(Double.self, forKey: .lookbackPeriodInDays)
        lookbackPeriodInDays = lookbackPeriodInDaysDecoded
        let lastRefreshTimestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastRefreshTimestamp)
        lastRefreshTimestamp = lastRefreshTimestampDecoded
        let findingDecoded = try containerValues.decodeIfPresent(LambdaFunctionRecommendationFinding.self, forKey: .finding)
        finding = findingDecoded
        let findingReasonCodesContainer = try containerValues.decodeIfPresent([LambdaFunctionRecommendationFindingReasonCode?].self, forKey: .findingReasonCodes)
        var findingReasonCodesDecoded0:[LambdaFunctionRecommendationFindingReasonCode]? = nil
        if let findingReasonCodesContainer = findingReasonCodesContainer {
            findingReasonCodesDecoded0 = [LambdaFunctionRecommendationFindingReasonCode]()
            for string0 in findingReasonCodesContainer {
                if let string0 = string0 {
                    findingReasonCodesDecoded0?.append(string0)
                }
            }
        }
        findingReasonCodes = findingReasonCodesDecoded0
        let memorySizeRecommendationOptionsContainer = try containerValues.decodeIfPresent([LambdaFunctionMemoryRecommendationOption?].self, forKey: .memorySizeRecommendationOptions)
        var memorySizeRecommendationOptionsDecoded0:[LambdaFunctionMemoryRecommendationOption]? = nil
        if let memorySizeRecommendationOptionsContainer = memorySizeRecommendationOptionsContainer {
            memorySizeRecommendationOptionsDecoded0 = [LambdaFunctionMemoryRecommendationOption]()
            for structure0 in memorySizeRecommendationOptionsContainer {
                if let structure0 = structure0 {
                    memorySizeRecommendationOptionsDecoded0?.append(structure0)
                }
            }
        }
        memorySizeRecommendationOptions = memorySizeRecommendationOptionsDecoded0
    }
}

extension LambdaFunctionRecommendation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LambdaFunctionRecommendation(accountId: \(String(describing: accountId)), currentMemorySize: \(String(describing: currentMemorySize)), finding: \(String(describing: finding)), findingReasonCodes: \(String(describing: findingReasonCodes)), functionArn: \(String(describing: functionArn)), functionVersion: \(String(describing: functionVersion)), lastRefreshTimestamp: \(String(describing: lastRefreshTimestamp)), lookbackPeriodInDays: \(String(describing: lookbackPeriodInDays)), memorySizeRecommendationOptions: \(String(describing: memorySizeRecommendationOptions)), numberOfInvocations: \(String(describing: numberOfInvocations)), utilizationMetrics: \(String(describing: utilizationMetrics)))"}
}

/// <p>Describes an AWS Lambda function recommendation.</p>
public struct LambdaFunctionRecommendation: Equatable {
    /// <p>The AWS account ID of the function.</p>
    public let accountId: String?
    /// <p>The amount of memory, in MB, that's allocated to the current function.</p>
    public let currentMemorySize: Int
    /// <p>The finding classification of the function.</p>
    ///         <p>Findings for functions include:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <b>
    ///                      <code>Optimized</code>
    ///                   </b> — The function is
    ///                     correctly provisioned to run your workload based on its current configuration
    ///                     and its utilization history. This finding classification does not include
    ///                     finding reason codes.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <b>
    ///                      <code>NotOptimized</code>
    ///                   </b> — The function is
    ///                     performing at a higher level (over-provisioned) or at a lower level
    ///                     (under-provisioned) than required for your workload because its current
    ///                     configuration is not optimal. Over-provisioned resources might lead to
    ///                     unnecessary infrastructure cost, and under-provisioned resources might lead to
    ///                     poor application performance. This finding classification can include the
    ///                         <code>MemoryUnderprovisioned</code> and <code>MemoryUnderprovisioned</code>
    ///                     finding reason codes.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <b>
    ///                      <code>Unavailable</code>
    ///                   </b> — Compute Optimizer was unable to
    ///                     generate a recommendation for the function. This could be because the function
    ///                     has not accumulated sufficient metric data, or the function does not qualify for
    ///                     a recommendation. This finding classification can include the
    ///                         <code>InsufficientData</code> and <code>Inconclusive</code> finding reason
    ///                     codes.</p>
    ///                 <note>
    ///                     <p>Functions with a finding of unavailable are not returned unless you
    ///                         specify the <code>filter</code> parameter with a value of
    ///                             <code>Unavailable</code> in your
    ///                             <code>GetLambdaFunctionRecommendations</code> request.</p>
    ///                 </note>
    ///             </li>
    ///          </ul>
    public let finding: LambdaFunctionRecommendationFinding?
    /// <p>The reason for the finding classification of the function.</p>
    ///         <note>
    ///             <p>Functions that have a finding classification of <code>Optimized</code> don't have
    ///                 a finding reason code.</p>
    ///         </note>
    ///         <p>Finding reason codes for functions include:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <b>
    ///                      <code>MemoryOverprovisioned</code>
    ///                   </b> — The
    ///                     function is over-provisioned when its memory configuration can be sized down
    ///                     while still meeting the performance requirements of your workload. An
    ///                     over-provisioned function might lead to unnecessary infrastructure cost. This
    ///                     finding reason code is part of the <code>NotOptimized</code> finding
    ///                     classification.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <b>
    ///                      <code>MemoryUnderprovisioned</code>
    ///                   </b> — The
    ///                     function is under-provisioned when its memory configuration doesn't meet the
    ///                     performance requirements of the workload. An under-provisioned function might
    ///                     lead to poor application performance. This finding reason code is part of the
    ///                         <code>NotOptimized</code> finding classification.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <b>
    ///                      <code>InsufficientData</code>
    ///                   </b> — The
    ///                     function does not have sufficient metric data for Compute Optimizer to generate a
    ///                     recommendation. For more information, see the <a href="https://docs.aws.amazon.com/compute-optimizer/latest/ug/requirements.html">Supported resources and
    ///                         requirements</a> in the <i>AWS Compute Optimizer User Guide</i>. This
    ///                     finding reason code is part of the <code>Unavailable</code> finding
    ///                     classification.</p>
    ///
    ///
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <b>
    ///                      <code>Inconclusive</code>
    ///                   </b> — The function does
    ///                     not qualify for a recommendation because Compute Optimizer cannot generate a recommendation
    ///                     with a high degree of confidence. This finding reason code is part of the
    ///                         <code>Unavailable</code> finding classification.</p>
    ///             </li>
    ///          </ul>
    public let findingReasonCodes: [LambdaFunctionRecommendationFindingReasonCode]?
    /// <p>The Amazon Resource Name (ARN) of the current function.</p>
    public let functionArn: String?
    /// <p>The version number of the current function.</p>
    public let functionVersion: String?
    /// <p>The time stamp of when the function recommendation was last refreshed.</p>
    public let lastRefreshTimestamp: Date?
    /// <p>The number of days for which utilization metrics were analyzed for the
    ///             function.</p>
    public let lookbackPeriodInDays: Double
    /// <p>An array of objects that describe the memory configuration recommendation options for
    ///             the function.</p>
    public let memorySizeRecommendationOptions: [LambdaFunctionMemoryRecommendationOption]?
    /// <p>The number of times your function code was executed during the look-back
    ///             period.</p>
    public let numberOfInvocations: Int
    /// <p>An array of objects that describe the utilization metrics of the function.</p>
    public let utilizationMetrics: [LambdaFunctionUtilizationMetric]?

    public init (
        accountId: String? = nil,
        currentMemorySize: Int = 0,
        finding: LambdaFunctionRecommendationFinding? = nil,
        findingReasonCodes: [LambdaFunctionRecommendationFindingReasonCode]? = nil,
        functionArn: String? = nil,
        functionVersion: String? = nil,
        lastRefreshTimestamp: Date? = nil,
        lookbackPeriodInDays: Double = 0.0,
        memorySizeRecommendationOptions: [LambdaFunctionMemoryRecommendationOption]? = nil,
        numberOfInvocations: Int = 0,
        utilizationMetrics: [LambdaFunctionUtilizationMetric]? = nil
    )
    {
        self.accountId = accountId
        self.currentMemorySize = currentMemorySize
        self.finding = finding
        self.findingReasonCodes = findingReasonCodes
        self.functionArn = functionArn
        self.functionVersion = functionVersion
        self.lastRefreshTimestamp = lastRefreshTimestamp
        self.lookbackPeriodInDays = lookbackPeriodInDays
        self.memorySizeRecommendationOptions = memorySizeRecommendationOptions
        self.numberOfInvocations = numberOfInvocations
        self.utilizationMetrics = utilizationMetrics
    }
}

extension LambdaFunctionRecommendationFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name
        case values
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for filtervalues0 in values {
                try valuesContainer.encode(filtervalues0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(LambdaFunctionRecommendationFilterName.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .values)
        var valuesDecoded0:[String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension LambdaFunctionRecommendationFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LambdaFunctionRecommendationFilter(name: \(String(describing: name)), values: \(String(describing: values)))"}
}

/// <p>Describes a filter that returns a more specific list of AWS Lambda function
///             recommendations. Use this filter with the <code>GetLambdaFunctionRecommendations</code>
///             action.</p>
///
///
///
///         <p>You can use <code>EBSFilter</code> with the <code>GetEBSVolumeRecommendations</code>
///             action, <code>JobFilter</code> with the <code>DescribeRecommendationExportJobs</code>
///             action, and <code>Filter</code> with the <code>GetAutoScalingGroupRecommendations</code>
///             and <code>GetEC2InstanceRecommendations</code> actions.</p>
public struct LambdaFunctionRecommendationFilter: Equatable {
    /// <p>The name of the filter.</p>
    ///
    ///         <p>Specify <code>Finding</code> to return recommendations with a specific finding
    ///             classification (e.g., <code>NotOptimized</code>).</p>
    ///
    ///         <p>Specify <code>FindingReasonCode</code> to return recommendations with a specific
    ///             finding reason code (e.g., <code>MemoryUnderprovisioned</code>).</p>
    public let name: LambdaFunctionRecommendationFilterName?
    /// <p>The value of the filter.</p>
    ///
    ///         <p>The valid values for this parameter are as follows, depending on what you specify for
    ///             the <code>name</code> parameter:</p>
    ///
    ///         <ul>
    ///             <li>
    ///                 <p>Specify <code>Optimized</code>, <code>NotOptimized</code>, or
    ///                         <code>Unavailable</code> if you specify the <code>name</code> parameter as
    ///                         <code>Finding</code>.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Specify <code>MemoryOverprovisioned</code>,
    ///                         <code>MemoryUnderprovisioned</code>, <code>InsufficientData</code>, or
    ///                         <code>Inconclusive</code> if you specify the <code>name</code> parameter as
    ///                         <code>FindingReasonCode</code>.</p>
    ///             </li>
    ///          </ul>
    public let values: [String]?

    public init (
        name: LambdaFunctionRecommendationFilterName? = nil,
        values: [String]? = nil
    )
    {
        self.name = name
        self.values = values
    }
}

public enum LambdaFunctionRecommendationFilterName {
    case finding
    case findingReasonCode
    case sdkUnknown(String)
}

extension LambdaFunctionRecommendationFilterName : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [LambdaFunctionRecommendationFilterName] {
        return [
            .finding,
            .findingReasonCode,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .finding: return "Finding"
        case .findingReasonCode: return "FindingReasonCode"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = LambdaFunctionRecommendationFilterName(rawValue: rawValue) ?? LambdaFunctionRecommendationFilterName.sdkUnknown(rawValue)
    }
}

public enum LambdaFunctionRecommendationFinding {
    case notOptimized
    case optimized
    case unavailable
    case sdkUnknown(String)
}

extension LambdaFunctionRecommendationFinding : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [LambdaFunctionRecommendationFinding] {
        return [
            .notOptimized,
            .optimized,
            .unavailable,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .notOptimized: return "NotOptimized"
        case .optimized: return "Optimized"
        case .unavailable: return "Unavailable"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = LambdaFunctionRecommendationFinding(rawValue: rawValue) ?? LambdaFunctionRecommendationFinding.sdkUnknown(rawValue)
    }
}

public enum LambdaFunctionRecommendationFindingReasonCode {
    case inconclusive
    case insufficientData
    case memoryOverProvisioned
    case memoryUnderProvisioned
    case sdkUnknown(String)
}

extension LambdaFunctionRecommendationFindingReasonCode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [LambdaFunctionRecommendationFindingReasonCode] {
        return [
            .inconclusive,
            .insufficientData,
            .memoryOverProvisioned,
            .memoryUnderProvisioned,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .inconclusive: return "Inconclusive"
        case .insufficientData: return "InsufficientData"
        case .memoryOverProvisioned: return "MemoryOverprovisioned"
        case .memoryUnderProvisioned: return "MemoryUnderprovisioned"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = LambdaFunctionRecommendationFindingReasonCode(rawValue: rawValue) ?? LambdaFunctionRecommendationFindingReasonCode.sdkUnknown(rawValue)
    }
}

extension LambdaFunctionUtilizationMetric: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name
        case statistic
        case value
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let statistic = statistic {
            try encodeContainer.encode(statistic.rawValue, forKey: .statistic)
        }
        if value != 0.0 {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(LambdaFunctionMetricName.self, forKey: .name)
        name = nameDecoded
        let statisticDecoded = try containerValues.decodeIfPresent(LambdaFunctionMetricStatistic.self, forKey: .statistic)
        statistic = statisticDecoded
        let valueDecoded = try containerValues.decode(Double.self, forKey: .value)
        value = valueDecoded
    }
}

extension LambdaFunctionUtilizationMetric: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LambdaFunctionUtilizationMetric(name: \(String(describing: name)), statistic: \(String(describing: statistic)), value: \(String(describing: value)))"}
}

/// <p>Describes a utilization metric of an AWS Lambda function.</p>
public struct LambdaFunctionUtilizationMetric: Equatable {
    /// <p>The name of the utilization metric.</p>
    ///         <p>The following utilization metrics are available:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <code>Duration</code> - The amount of time that your function code spends
    ///                     processing an event.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>Memory</code> - The amount of memory used per invocation.</p>
    ///             </li>
    ///          </ul>
    public let name: LambdaFunctionMetricName?
    /// <p>The statistic of the utilization metric.</p>
    ///
    ///         <p>The Compute Optimizer API, AWS Command Line Interface (AWS CLI), and SDKs return utilization metrics using
    ///             only the <code>Maximum</code> statistic, which is the highest value observed during the
    ///             specified period.</p>
    ///
    ///
    ///
    ///         <p>The Compute Optimizer console displays graphs for some utilization metrics using the
    ///                 <code>Average</code> statistic, which is the value of <code>Sum</code> /
    ///                 <code>SampleCount</code> during the specified period. For more information, see
    ///                 <a href="https://docs.aws.amazon.com/compute-optimizer/latest/ug/viewing-recommendations.html">Viewing resource
    ///                 recommendations</a> in the <i>AWS Compute Optimizer User Guide</i>. You can
    ///             also get averaged utilization metric data for your resources using Amazon CloudWatch. For more
    ///             information, see the <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/WhatIsCloudWatch.html">Amazon CloudWatch User
    ///                 Guide</a>.</p>
    public let statistic: LambdaFunctionMetricStatistic?
    /// <p>The value of the utilization metric.</p>
    public let value: Double

    public init (
        name: LambdaFunctionMetricName? = nil,
        statistic: LambdaFunctionMetricStatistic? = nil,
        value: Double = 0.0
    )
    {
        self.name = name
        self.statistic = statistic
        self.value = value
    }
}

extension LimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LimitExceededException(message: \(String(describing: message)))"}
}

extension LimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request exceeds a limit of the service.</p>
public struct LimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct LimitExceededExceptionBody: Equatable {
    public let message: String?
}

extension LimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum MetricName {
    case cpu
    case diskReadBytesPerSecond
    case diskReadOpsPerSecond
    case diskWriteBytesPerSecond
    case diskWriteOpsPerSecond
    case ebsReadBytesPerSecond
    case ebsReadOpsPerSecond
    case ebsWriteBytesPerSecond
    case ebsWriteOpsPerSecond
    case memory
    case networkInBytesPerSecond
    case networkOutBytesPerSecond
    case networkPacketsInPerSecond
    case networkPacketsOutPerSecond
    case sdkUnknown(String)
}

extension MetricName : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [MetricName] {
        return [
            .cpu,
            .diskReadBytesPerSecond,
            .diskReadOpsPerSecond,
            .diskWriteBytesPerSecond,
            .diskWriteOpsPerSecond,
            .ebsReadBytesPerSecond,
            .ebsReadOpsPerSecond,
            .ebsWriteBytesPerSecond,
            .ebsWriteOpsPerSecond,
            .memory,
            .networkInBytesPerSecond,
            .networkOutBytesPerSecond,
            .networkPacketsInPerSecond,
            .networkPacketsOutPerSecond,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .cpu: return "Cpu"
        case .diskReadBytesPerSecond: return "DISK_READ_BYTES_PER_SECOND"
        case .diskReadOpsPerSecond: return "DISK_READ_OPS_PER_SECOND"
        case .diskWriteBytesPerSecond: return "DISK_WRITE_BYTES_PER_SECOND"
        case .diskWriteOpsPerSecond: return "DISK_WRITE_OPS_PER_SECOND"
        case .ebsReadBytesPerSecond: return "EBS_READ_BYTES_PER_SECOND"
        case .ebsReadOpsPerSecond: return "EBS_READ_OPS_PER_SECOND"
        case .ebsWriteBytesPerSecond: return "EBS_WRITE_BYTES_PER_SECOND"
        case .ebsWriteOpsPerSecond: return "EBS_WRITE_OPS_PER_SECOND"
        case .memory: return "Memory"
        case .networkInBytesPerSecond: return "NETWORK_IN_BYTES_PER_SECOND"
        case .networkOutBytesPerSecond: return "NETWORK_OUT_BYTES_PER_SECOND"
        case .networkPacketsInPerSecond: return "NETWORK_PACKETS_IN_PER_SECOND"
        case .networkPacketsOutPerSecond: return "NETWORK_PACKETS_OUT_PER_SECOND"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = MetricName(rawValue: rawValue) ?? MetricName.sdkUnknown(rawValue)
    }
}

public enum MetricStatistic {
    case average
    case maximum
    case sdkUnknown(String)
}

extension MetricStatistic : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [MetricStatistic] {
        return [
            .average,
            .maximum,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .average: return "Average"
        case .maximum: return "Maximum"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = MetricStatistic(rawValue: rawValue) ?? MetricStatistic.sdkUnknown(rawValue)
    }
}

extension MissingAuthenticationToken: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MissingAuthenticationToken(message: \(String(describing: message)))"}
}

extension MissingAuthenticationToken: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: MissingAuthenticationTokenBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request must contain either a valid (registered) AWS access key ID or
///             X.509 certificate.</p>
public struct MissingAuthenticationToken: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct MissingAuthenticationTokenBody: Equatable {
    public let message: String?
}

extension MissingAuthenticationTokenBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OptInRequiredException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OptInRequiredException(message: \(String(describing: message)))"}
}

extension OptInRequiredException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: OptInRequiredExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The account is not opted in to AWS Compute Optimizer.</p>
public struct OptInRequiredException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct OptInRequiredExceptionBody: Equatable {
    public let message: String?
}

extension OptInRequiredExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum PlatformDifference {
    case hypervisor
    case instanceStoreAvailability
    case networkInterface
    case storageInterface
    case virtualizationType
    case sdkUnknown(String)
}

extension PlatformDifference : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [PlatformDifference] {
        return [
            .hypervisor,
            .instanceStoreAvailability,
            .networkInterface,
            .storageInterface,
            .virtualizationType,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .hypervisor: return "Hypervisor"
        case .instanceStoreAvailability: return "InstanceStoreAvailability"
        case .networkInterface: return "NetworkInterface"
        case .storageInterface: return "StorageInterface"
        case .virtualizationType: return "VirtualizationType"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = PlatformDifference(rawValue: rawValue) ?? PlatformDifference.sdkUnknown(rawValue)
    }
}

extension ProjectedMetric: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name
        case timestamps
        case values
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let timestamps = timestamps {
            var timestampsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .timestamps)
            for timestamps0 in timestamps {
                try timestampsContainer.encode(timestamps0.timeIntervalSince1970)
            }
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for metricvalues0 in values {
                try valuesContainer.encode(metricvalues0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(MetricName.self, forKey: .name)
        name = nameDecoded
        let timestampsContainer = try containerValues.decodeIfPresent([Date?].self, forKey: .timestamps)
        var timestampsDecoded0:[Date]? = nil
        if let timestampsContainer = timestampsContainer {
            timestampsDecoded0 = [Date]()
            for timestamp0 in timestampsContainer {
                if let timestamp0 = timestamp0 {
                    timestampsDecoded0?.append(timestamp0)
                }
            }
        }
        timestamps = timestampsDecoded0
        let valuesContainer = try containerValues.decodeIfPresent([Double?].self, forKey: .values)
        var valuesDecoded0:[Double]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Double]()
            for double0 in valuesContainer {
                if let double0 = double0 {
                    valuesDecoded0?.append(double0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension ProjectedMetric: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ProjectedMetric(name: \(String(describing: name)), timestamps: \(String(describing: timestamps)), values: \(String(describing: values)))"}
}

/// <p>Describes a projected utilization metric of a recommendation option, such as an Amazon EC2
///             instance. This represents the projected utilization of a recommendation option had you
///             used that resource during the analyzed period.</p>
///
///         <p>Compare the utilization metric data of your resource against its projected utilization
///             metric data to determine the performance difference between your current resource and
///             the recommended option.</p>
///
///         <note>
///             <p>The <code>Cpu</code> and <code>Memory</code> metrics are the only projected
///                 utilization metrics returned when you run the
///                     <code>GetEC2RecommendationProjectedMetrics</code> action. Additionally, the
///                     <code>Memory</code> metric is returned only for resources that have the unified
///                 CloudWatch agent installed on them. For more information, see <a href="https://docs.aws.amazon.com/compute-optimizer/latest/ug/metrics.html#cw-agent">Enabling Memory
///                     Utilization with the CloudWatch Agent</a>.</p>
///         </note>
public struct ProjectedMetric: Equatable {
    /// <p>The name of the projected utilization metric.</p>
    ///         <p>The following projected utilization metrics are returned:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <code>Cpu</code> - The projected percentage of allocated EC2 compute units
    ///                     that would be in use on the recommendation option had you used that resource
    ///                     during the analyzed period. This metric identifies the processing power required
    ///                     to run an application on the recommendation option.</p>
    ///                 <p>Depending on the instance type, tools in your operating system can show a
    ///                     lower percentage than CloudWatch when the instance is not allocated a full
    ///                     processor core.</p>
    ///                 <p>Units: Percent</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>Memory</code> - The percentage of memory that would be in use on the
    ///                     recommendation option had you used that resource during the analyzed period.
    ///                     This metric identifies the amount of memory required to run an application on
    ///                     the recommendation option.</p>
    ///                 <p>Units: Percent</p>
    ///                 <note>
    ///                     <p>The <code>Memory</code> metric is returned only for resources that have
    ///                         the unified CloudWatch agent installed on them. For more information, see <a href="https://docs.aws.amazon.com/compute-optimizer/latest/ug/metrics.html#cw-agent">Enabling Memory
    ///                             Utilization with the CloudWatch Agent</a>.</p>
    ///                 </note>
    ///             </li>
    ///          </ul>
    public let name: MetricName?
    /// <p>The time stamps of the projected utilization metric.</p>
    public let timestamps: [Date]?
    /// <p>The values of the projected utilization metrics.</p>
    public let values: [Double]?

    public init (
        name: MetricName? = nil,
        timestamps: [Date]? = nil,
        values: [Double]? = nil
    )
    {
        self.name = name
        self.timestamps = timestamps
        self.values = values
    }
}

extension ReasonCodeSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name
        case value
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if value != 0.0 {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(FindingReasonCode.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decode(Double.self, forKey: .value)
        value = valueDecoded
    }
}

extension ReasonCodeSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReasonCodeSummary(name: \(String(describing: name)), value: \(String(describing: value)))"}
}

/// <p>A summary of a finding reason code.</p>
public struct ReasonCodeSummary: Equatable {
    /// <p>The name of the finding reason code.</p>
    public let name: FindingReasonCode?
    /// <p>The value of the finding reason code summary.</p>
    public let value: Double

    public init (
        name: FindingReasonCode? = nil,
        value: Double = 0.0
    )
    {
        self.name = name
        self.value = value
    }
}

extension RecommendationExportJob: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case creationTimestamp
        case destination
        case failureReason
        case jobId
        case lastUpdatedTimestamp
        case resourceType
        case status
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTimestamp = creationTimestamp {
            try encodeContainer.encode(creationTimestamp.timeIntervalSince1970, forKey: .creationTimestamp)
        }
        if let destination = destination {
            try encodeContainer.encode(destination, forKey: .destination)
        }
        if let failureReason = failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let lastUpdatedTimestamp = lastUpdatedTimestamp {
            try encodeContainer.encode(lastUpdatedTimestamp.timeIntervalSince1970, forKey: .lastUpdatedTimestamp)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(ExportDestination.self, forKey: .destination)
        destination = destinationDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(JobStatus.self, forKey: .status)
        status = statusDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let lastUpdatedTimestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedTimestamp)
        lastUpdatedTimestamp = lastUpdatedTimestampDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
    }
}

extension RecommendationExportJob: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RecommendationExportJob(creationTimestamp: \(String(describing: creationTimestamp)), destination: \(String(describing: destination)), failureReason: \(String(describing: failureReason)), jobId: \(String(describing: jobId)), lastUpdatedTimestamp: \(String(describing: lastUpdatedTimestamp)), resourceType: \(String(describing: resourceType)), status: \(String(describing: status)))"}
}

/// <p>Describes a recommendation export job.</p>
///
///
///         <p>Use the <code>DescribeRecommendationExportJobs</code> action to view your
///             recommendation export jobs.</p>
///
///
///         <p>Use the <code>ExportAutoScalingGroupRecommendations</code> or
///                 <code>ExportEC2InstanceRecommendations</code> actions to request an export of your
///             recommendations.</p>
public struct RecommendationExportJob: Equatable {
    /// <p>The timestamp of when the export job was created.</p>
    public let creationTimestamp: Date?
    /// <p>An object that describes the destination of the export file.</p>
    public let destination: ExportDestination?
    /// <p>The reason for an export job failure.</p>
    public let failureReason: String?
    /// <p>The identification number of the export job.</p>
    public let jobId: String?
    /// <p>The timestamp of when the export job was last updated.</p>
    public let lastUpdatedTimestamp: Date?
    /// <p>The resource type of the exported recommendations.</p>
    public let resourceType: ResourceType?
    /// <p>The status of the export job.</p>
    public let status: JobStatus?

    public init (
        creationTimestamp: Date? = nil,
        destination: ExportDestination? = nil,
        failureReason: String? = nil,
        jobId: String? = nil,
        lastUpdatedTimestamp: Date? = nil,
        resourceType: ResourceType? = nil,
        status: JobStatus? = nil
    )
    {
        self.creationTimestamp = creationTimestamp
        self.destination = destination
        self.failureReason = failureReason
        self.jobId = jobId
        self.lastUpdatedTimestamp = lastUpdatedTimestamp
        self.resourceType = resourceType
        self.status = status
    }
}

extension RecommendationSource: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case recommendationSourceArn
        case recommendationSourceType
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let recommendationSourceArn = recommendationSourceArn {
            try encodeContainer.encode(recommendationSourceArn, forKey: .recommendationSourceArn)
        }
        if let recommendationSourceType = recommendationSourceType {
            try encodeContainer.encode(recommendationSourceType.rawValue, forKey: .recommendationSourceType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recommendationSourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .recommendationSourceArn)
        recommendationSourceArn = recommendationSourceArnDecoded
        let recommendationSourceTypeDecoded = try containerValues.decodeIfPresent(RecommendationSourceType.self, forKey: .recommendationSourceType)
        recommendationSourceType = recommendationSourceTypeDecoded
    }
}

extension RecommendationSource: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RecommendationSource(recommendationSourceArn: \(String(describing: recommendationSourceArn)), recommendationSourceType: \(String(describing: recommendationSourceType)))"}
}

/// <p>Describes the source of a recommendation, such as an Amazon EC2 instance or Auto Scaling
///             group.</p>
public struct RecommendationSource: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the recommendation source.</p>
    public let recommendationSourceArn: String?
    /// <p>The resource type of the recommendation source.</p>
    public let recommendationSourceType: RecommendationSourceType?

    public init (
        recommendationSourceArn: String? = nil,
        recommendationSourceType: RecommendationSourceType? = nil
    )
    {
        self.recommendationSourceArn = recommendationSourceArn
        self.recommendationSourceType = recommendationSourceType
    }
}

public enum RecommendationSourceType {
    case autoScalingGroup
    case ebsVolume
    case ec2Instance
    case lambdaFunction
    case sdkUnknown(String)
}

extension RecommendationSourceType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [RecommendationSourceType] {
        return [
            .autoScalingGroup,
            .ebsVolume,
            .ec2Instance,
            .lambdaFunction,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .autoScalingGroup: return "AutoScalingGroup"
        case .ebsVolume: return "EbsVolume"
        case .ec2Instance: return "Ec2Instance"
        case .lambdaFunction: return "LambdaFunction"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = RecommendationSourceType(rawValue: rawValue) ?? RecommendationSourceType.sdkUnknown(rawValue)
    }
}

extension RecommendationSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountId
        case recommendationResourceType
        case summaries
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let recommendationResourceType = recommendationResourceType {
            try encodeContainer.encode(recommendationResourceType.rawValue, forKey: .recommendationResourceType)
        }
        if let summaries = summaries {
            var summariesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .summaries)
            for summaries0 in summaries {
                try summariesContainer.encode(summaries0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let summariesContainer = try containerValues.decodeIfPresent([Summary?].self, forKey: .summaries)
        var summariesDecoded0:[Summary]? = nil
        if let summariesContainer = summariesContainer {
            summariesDecoded0 = [Summary]()
            for structure0 in summariesContainer {
                if let structure0 = structure0 {
                    summariesDecoded0?.append(structure0)
                }
            }
        }
        summaries = summariesDecoded0
        let recommendationResourceTypeDecoded = try containerValues.decodeIfPresent(RecommendationSourceType.self, forKey: .recommendationResourceType)
        recommendationResourceType = recommendationResourceTypeDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountId)
        accountId = accountIdDecoded
    }
}

extension RecommendationSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RecommendationSummary(accountId: \(String(describing: accountId)), recommendationResourceType: \(String(describing: recommendationResourceType)), summaries: \(String(describing: summaries)))"}
}

/// <p>A summary of a recommendation.</p>
public struct RecommendationSummary: Equatable {
    /// <p>The AWS account ID of the recommendation summary.</p>
    public let accountId: String?
    /// <p>The resource type of the recommendation.</p>
    public let recommendationResourceType: RecommendationSourceType?
    /// <p>An array of objects that describe a recommendation summary.</p>
    public let summaries: [Summary]?

    public init (
        accountId: String? = nil,
        recommendationResourceType: RecommendationSourceType? = nil,
        summaries: [Summary]? = nil
    )
    {
        self.accountId = accountId
        self.recommendationResourceType = recommendationResourceType
        self.summaries = summaries
    }
}

extension RecommendedOptionProjectedMetric: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case projectedMetrics
        case rank
        case recommendedInstanceType
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let projectedMetrics = projectedMetrics {
            var projectedMetricsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .projectedMetrics)
            for projectedmetrics0 in projectedMetrics {
                try projectedMetricsContainer.encode(projectedmetrics0)
            }
        }
        if rank != 0 {
            try encodeContainer.encode(rank, forKey: .rank)
        }
        if let recommendedInstanceType = recommendedInstanceType {
            try encodeContainer.encode(recommendedInstanceType, forKey: .recommendedInstanceType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recommendedInstanceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .recommendedInstanceType)
        recommendedInstanceType = recommendedInstanceTypeDecoded
        let rankDecoded = try containerValues.decode(Int.self, forKey: .rank)
        rank = rankDecoded
        let projectedMetricsContainer = try containerValues.decodeIfPresent([ProjectedMetric?].self, forKey: .projectedMetrics)
        var projectedMetricsDecoded0:[ProjectedMetric]? = nil
        if let projectedMetricsContainer = projectedMetricsContainer {
            projectedMetricsDecoded0 = [ProjectedMetric]()
            for structure0 in projectedMetricsContainer {
                if let structure0 = structure0 {
                    projectedMetricsDecoded0?.append(structure0)
                }
            }
        }
        projectedMetrics = projectedMetricsDecoded0
    }
}

extension RecommendedOptionProjectedMetric: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RecommendedOptionProjectedMetric(projectedMetrics: \(String(describing: projectedMetrics)), rank: \(String(describing: rank)), recommendedInstanceType: \(String(describing: recommendedInstanceType)))"}
}

/// <p>Describes a projected utilization metric of a recommendation option.</p>
///
///         <note>
///             <p>The <code>Cpu</code> and <code>Memory</code> metrics are the only projected
///                 utilization metrics returned when you run the
///                     <code>GetEC2RecommendationProjectedMetrics</code> action. Additionally, the
///                     <code>Memory</code> metric is returned only for resources that have the unified
///                 CloudWatch agent installed on them. For more information, see <a href="https://docs.aws.amazon.com/compute-optimizer/latest/ug/metrics.html#cw-agent">Enabling Memory
///                     Utilization with the CloudWatch Agent</a>.</p>
///         </note>
public struct RecommendedOptionProjectedMetric: Equatable {
    /// <p>An array of objects that describe a projected utilization metric.</p>
    public let projectedMetrics: [ProjectedMetric]?
    /// <p>The rank of the recommendation option projected metric.</p>
    ///         <p>The top recommendation option is ranked as <code>1</code>.</p>
    ///         <p>The projected metric rank correlates to the recommendation option rank. For example,
    ///             the projected metric ranked as <code>1</code> is related to the recommendation option
    ///             that is also ranked as <code>1</code> in the same response.</p>
    public let rank: Int
    /// <p>The recommended instance type.</p>
    public let recommendedInstanceType: String?

    public init (
        projectedMetrics: [ProjectedMetric]? = nil,
        rank: Int = 0,
        recommendedInstanceType: String? = nil
    )
    {
        self.projectedMetrics = projectedMetrics
        self.rank = rank
        self.recommendedInstanceType = recommendedInstanceType
    }
}

extension ResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundException(message: \(String(describing: message)))"}
}

extension ResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A resource that is required for the action doesn't exist.</p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension ResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum ResourceType {
    case autoScalingGroup
    case ebsVolume
    case ec2Instance
    case lambdaFunction
    case sdkUnknown(String)
}

extension ResourceType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ResourceType] {
        return [
            .autoScalingGroup,
            .ebsVolume,
            .ec2Instance,
            .lambdaFunction,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .autoScalingGroup: return "AutoScalingGroup"
        case .ebsVolume: return "EbsVolume"
        case .ec2Instance: return "Ec2Instance"
        case .lambdaFunction: return "LambdaFunction"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ResourceType(rawValue: rawValue) ?? ResourceType.sdkUnknown(rawValue)
    }
}

extension S3Destination: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bucket
        case key
        case metadataKey
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucket = bucket {
            try encodeContainer.encode(bucket, forKey: .bucket)
        }
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let metadataKey = metadataKey {
            try encodeContainer.encode(metadataKey, forKey: .metadataKey)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucket)
        bucket = bucketDecoded
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let metadataKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .metadataKey)
        metadataKey = metadataKeyDecoded
    }
}

extension S3Destination: CustomDebugStringConvertible {
    public var debugDescription: String {
        "S3Destination(bucket: \(String(describing: bucket)), key: \(String(describing: key)), metadataKey: \(String(describing: metadataKey)))"}
}

/// <p>Describes the destination Amazon Simple Storage Service (Amazon S3) bucket name and object keys of a
///             recommendations export file, and its associated metadata file.</p>
public struct S3Destination: Equatable {
    /// <p>The name of the Amazon S3 bucket used as the destination of an export file.</p>
    public let bucket: String?
    /// <p>The Amazon S3 bucket key of an export file.</p>
    ///         <p>The key uniquely identifies the object, or export file, in the S3 bucket.</p>
    public let key: String?
    /// <p>The Amazon S3 bucket key of a metadata file.</p>
    ///         <p>The key uniquely identifies the object, or metadata file, in the S3 bucket.</p>
    public let metadataKey: String?

    public init (
        bucket: String? = nil,
        key: String? = nil,
        metadataKey: String? = nil
    )
    {
        self.bucket = bucket
        self.key = key
        self.metadataKey = metadataKey
    }
}

extension S3DestinationConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bucket
        case keyPrefix
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucket = bucket {
            try encodeContainer.encode(bucket, forKey: .bucket)
        }
        if let keyPrefix = keyPrefix {
            try encodeContainer.encode(keyPrefix, forKey: .keyPrefix)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucket)
        bucket = bucketDecoded
        let keyPrefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keyPrefix)
        keyPrefix = keyPrefixDecoded
    }
}

extension S3DestinationConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "S3DestinationConfig(bucket: \(String(describing: bucket)), keyPrefix: \(String(describing: keyPrefix)))"}
}

/// <p>Describes the destination Amazon Simple Storage Service (Amazon S3) bucket name and key prefix for a
///             recommendations export job.</p>
///         <p>You must create the destination Amazon S3 bucket for your recommendations export before you
///             create the export job. Compute Optimizer does not create the S3 bucket for you. After you create the
///             S3 bucket, ensure that it has the required permission policy to allow Compute Optimizer to write the
///             export file to it. If you plan to specify an object prefix when you create the export
///             job, you must include the object prefix in the policy that you add to the S3 bucket. For
///             more information, see <a href="https://docs.aws.amazon.com/compute-optimizer/latest/ug/create-s3-bucket-policy-for-compute-optimizer.html">Amazon S3 Bucket Policy for Compute Optimizer</a> in the <i>Compute Optimizer user
///             guide</i>.</p>
public struct S3DestinationConfig: Equatable {
    /// <p>The name of the Amazon S3 bucket to use as the destination for an export job.</p>
    public let bucket: String?
    /// <p>The Amazon S3 bucket prefix for an export job.</p>
    public let keyPrefix: String?

    public init (
        bucket: String? = nil,
        keyPrefix: String? = nil
    )
    {
        self.bucket = bucket
        self.keyPrefix = keyPrefix
    }
}

extension ServiceUnavailableException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceUnavailableException(message: \(String(describing: message)))"}
}

extension ServiceUnavailableException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ServiceUnavailableExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request has failed due to a temporary failure of the server.</p>
public struct ServiceUnavailableException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceUnavailableExceptionBody: Equatable {
    public let message: String?
}

extension ServiceUnavailableExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum Status {
    case active
    case failed
    case inactive
    case pending
    case sdkUnknown(String)
}

extension Status : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Status] {
        return [
            .active,
            .failed,
            .inactive,
            .pending,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .active: return "Active"
        case .failed: return "Failed"
        case .inactive: return "Inactive"
        case .pending: return "Pending"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Status(rawValue: rawValue) ?? Status.sdkUnknown(rawValue)
    }
}

extension Summary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name
        case reasonCodeSummaries
        case value
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let reasonCodeSummaries = reasonCodeSummaries {
            var reasonCodeSummariesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .reasonCodeSummaries)
            for reasoncodesummaries0 in reasonCodeSummaries {
                try reasonCodeSummariesContainer.encode(reasoncodesummaries0)
            }
        }
        if value != 0.0 {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Finding.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decode(Double.self, forKey: .value)
        value = valueDecoded
        let reasonCodeSummariesContainer = try containerValues.decodeIfPresent([ReasonCodeSummary?].self, forKey: .reasonCodeSummaries)
        var reasonCodeSummariesDecoded0:[ReasonCodeSummary]? = nil
        if let reasonCodeSummariesContainer = reasonCodeSummariesContainer {
            reasonCodeSummariesDecoded0 = [ReasonCodeSummary]()
            for structure0 in reasonCodeSummariesContainer {
                if let structure0 = structure0 {
                    reasonCodeSummariesDecoded0?.append(structure0)
                }
            }
        }
        reasonCodeSummaries = reasonCodeSummariesDecoded0
    }
}

extension Summary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Summary(name: \(String(describing: name)), reasonCodeSummaries: \(String(describing: reasonCodeSummaries)), value: \(String(describing: value)))"}
}

/// <p>The summary of a recommendation.</p>
public struct Summary: Equatable {
    /// <p>The finding classification of the recommendation.</p>
    public let name: Finding?
    /// <p>An array of objects that summarize a finding reason code.</p>
    public let reasonCodeSummaries: [ReasonCodeSummary]?
    /// <p>The value of the recommendation summary.</p>
    public let value: Double

    public init (
        name: Finding? = nil,
        reasonCodeSummaries: [ReasonCodeSummary]? = nil,
        value: Double = 0.0
    )
    {
        self.name = name
        self.reasonCodeSummaries = reasonCodeSummaries
        self.value = value
    }
}

extension ThrottlingException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ThrottlingException(message: \(String(describing: message)))"}
}

extension ThrottlingException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request was denied due to request throttling.</p>
public struct ThrottlingException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ThrottlingExceptionBody: Equatable {
    public let message: String?
}

extension ThrottlingExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct UpdateEnrollmentStatusInputBodyMiddleware: Middleware {
    public let id: String = "UpdateEnrollmentStatusInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateEnrollmentStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateEnrollmentStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateEnrollmentStatusInput>
    public typealias MOutput = OperationOutput<UpdateEnrollmentStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateEnrollmentStatusOutputError>
}

extension UpdateEnrollmentStatusInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateEnrollmentStatusInput(includeMemberAccounts: \(String(describing: includeMemberAccounts)), status: \(String(describing: status)))"}
}

extension UpdateEnrollmentStatusInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case includeMemberAccounts
        case status
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if includeMemberAccounts != false {
            try encodeContainer.encode(includeMemberAccounts, forKey: .includeMemberAccounts)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }
}

public struct UpdateEnrollmentStatusInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateEnrollmentStatusInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateEnrollmentStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateEnrollmentStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateEnrollmentStatusInput>
    public typealias MOutput = OperationOutput<UpdateEnrollmentStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateEnrollmentStatusOutputError>
}

public struct UpdateEnrollmentStatusInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateEnrollmentStatusInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateEnrollmentStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateEnrollmentStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateEnrollmentStatusInput>
    public typealias MOutput = OperationOutput<UpdateEnrollmentStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateEnrollmentStatusOutputError>
}

public struct UpdateEnrollmentStatusInput: Equatable {
    /// <p>Indicates whether to enroll member accounts of the organization if the account is the
    ///             management account of an organization.</p>
    public let includeMemberAccounts: Bool
    /// <p>The new enrollment status of the account.</p>
    ///         <p>The following status options are available:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <code>Active</code> - Opts in your account to the Compute Optimizer service. Compute Optimizer
    ///                     begins analyzing the configuration and utilization metrics of your AWS
    ///                     resources after you opt in. For more information, see <a href="https://docs.aws.amazon.com/compute-optimizer/latest/ug/metrics.html">Metrics
    ///                         analyzed by AWS Compute Optimizer</a> in the <i>AWS Compute Optimizer User
    ///                     Guide</i>.</p>
    ///
    ///
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>Inactive</code> - Opts out your account from the Compute Optimizer service. Your
    ///                     account's recommendations and related metrics data will be deleted from Compute Optimizer
    ///                     after you opt out.</p>
    ///             </li>
    ///          </ul>
    ///         <note>
    ///             <p>The <code>Pending</code> and <code>Failed</code> options cannot be used to update
    ///                 the enrollment status of an account. They are returned in the response of a request
    ///                 to update the enrollment status of an account.</p>
    ///         </note>
    public let status: Status?

    public init (
        includeMemberAccounts: Bool = false,
        status: Status? = nil
    )
    {
        self.includeMemberAccounts = includeMemberAccounts
        self.status = status
    }
}

struct UpdateEnrollmentStatusInputBody: Equatable {
    public let status: Status?
    public let includeMemberAccounts: Bool
}

extension UpdateEnrollmentStatusInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case includeMemberAccounts
        case status
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(Status.self, forKey: .status)
        status = statusDecoded
        let includeMemberAccountsDecoded = try containerValues.decode(Bool.self, forKey: .includeMemberAccounts)
        includeMemberAccounts = includeMemberAccountsDecoded
    }
}

extension UpdateEnrollmentStatusOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateEnrollmentStatusOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingAuthenticationToken" : self = .missingAuthenticationToken(try MissingAuthenticationToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateEnrollmentStatusOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case invalidParameterValueException(InvalidParameterValueException)
    case missingAuthenticationToken(MissingAuthenticationToken)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateEnrollmentStatusOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateEnrollmentStatusOutputResponse(status: \(String(describing: status)), statusReason: \(String(describing: statusReason)))"}
}

extension UpdateEnrollmentStatusOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateEnrollmentStatusOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.status = output.status
            self.statusReason = output.statusReason
        } else {
            self.status = nil
            self.statusReason = nil
        }
    }
}

public struct UpdateEnrollmentStatusOutputResponse: Equatable {
    /// <p>The enrollment status of the account.</p>
    public let status: Status?
    /// <p>The reason for the enrollment status of the account. For example, an account might
    ///             show a status of <code>Pending</code> because member accounts of an organization require
    ///             more time to be enrolled in the service.</p>
    public let statusReason: String?

    public init (
        status: Status? = nil,
        statusReason: String? = nil
    )
    {
        self.status = status
        self.statusReason = statusReason
    }
}

struct UpdateEnrollmentStatusOutputResponseBody: Equatable {
    public let status: Status?
    public let statusReason: String?
}

extension UpdateEnrollmentStatusOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case status
        case statusReason
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(Status.self, forKey: .status)
        status = statusDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
    }
}

extension UtilizationMetric: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name
        case statistic
        case value
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let statistic = statistic {
            try encodeContainer.encode(statistic.rawValue, forKey: .statistic)
        }
        if value != 0.0 {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(MetricName.self, forKey: .name)
        name = nameDecoded
        let statisticDecoded = try containerValues.decodeIfPresent(MetricStatistic.self, forKey: .statistic)
        statistic = statisticDecoded
        let valueDecoded = try containerValues.decode(Double.self, forKey: .value)
        value = valueDecoded
    }
}

extension UtilizationMetric: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UtilizationMetric(name: \(String(describing: name)), statistic: \(String(describing: statistic)), value: \(String(describing: value)))"}
}

/// <p>Describes a utilization metric of a resource, such as an Amazon EC2 instance.</p>
///
///         <p>Compare the utilization metric data of your resource against its projected utilization
///             metric data to determine the performance difference between your current resource and
///             the recommended option.</p>
public struct UtilizationMetric: Equatable {
    /// <p>The name of the utilization metric.</p>
    ///         <p>The following utilization metrics are available:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <code>Cpu</code> - The percentage of allocated EC2 compute units that are
    ///                     currently in use on the instance. This metric identifies the processing power
    ///                     required to run an application on the instance.</p>
    ///                 <p>Depending on the instance type, tools in your operating system can show a
    ///                     lower percentage than CloudWatch when the instance is not allocated a full
    ///                     processor core.</p>
    ///                 <p>Units: Percent</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>Memory</code> - The percentage of memory that is currently in use on the
    ///                     instance. This metric identifies the amount of memory required to run an
    ///                     application on the instance.</p>
    ///                 <p>Units: Percent</p>
    ///                 <note>
    ///                     <p>The <code>Memory</code> metric is returned only for resources that have
    ///                         the unified CloudWatch agent installed on them. For more information, see <a href="https://docs.aws.amazon.com/compute-optimizer/latest/ug/metrics.html#cw-agent">Enabling Memory
    ///                             Utilization with the CloudWatch Agent</a>.</p>
    ///                 </note>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>EBS_READ_OPS_PER_SECOND</code> - The completed read operations from all
    ///                     EBS volumes attached to the instance in a specified period of time.</p>
    ///                 <p>Unit: Count</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>EBS_WRITE_OPS_PER_SECOND</code> - The completed write operations to all
    ///                     EBS volumes attached to the instance in a specified period of time.</p>
    ///                 <p>Unit: Count</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>EBS_READ_BYTES_PER_SECOND</code> - The bytes read from all EBS volumes
    ///                     attached to the instance in a specified period of time.</p>
    ///                 <p>Unit: Bytes</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>EBS_WRITE_BYTES_PER_SECOND</code> - The bytes written to all EBS volumes
    ///                     attached to the instance in a specified period of time.</p>
    ///                 <p>Unit: Bytes</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>DISK_READ_OPS_PER_SECOND</code> - The completed read operations from all
    ///                     instance store volumes available to the instance in a specified period of
    ///                     time.</p>
    ///                 <p>If there are no instance store volumes, either the value is <code>0</code> or
    ///                     the metric is not reported.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>DISK_WRITE_OPS_PER_SECOND</code> - The completed write operations from
    ///                     all instance store volumes available to the instance in a specified period of
    ///                     time.</p>
    ///                 <p>If there are no instance store volumes, either the value is <code>0</code> or
    ///                     the metric is not reported.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>DISK_READ_BYTES_PER_SECOND</code> - The bytes read from all instance
    ///                     store volumes available to the instance. This metric is used to determine the
    ///                     volume of the data the application reads from the disk of the instance. This can
    ///                     be used to determine the speed of the application.</p>
    ///                 <p>If there are no instance store volumes, either the value is <code>0</code> or
    ///                     the metric is not reported.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>DISK_WRITE_BYTES_PER_SECOND</code> - The bytes written to all instance
    ///                     store volumes available to the instance. This metric is used to determine the
    ///                     volume of the data the application writes onto the disk of the instance. This
    ///                     can be used to determine the speed of the application.</p>
    ///                 <p>If there are no instance store volumes, either the value is <code>0</code> or
    ///                     the metric is not reported.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>NETWORK_IN_BYTES_PER_SECOND</code> - The number of bytes received by the
    ///                     instance on all network interfaces. This metric identifies the volume of
    ///                     incoming network traffic to a single instance.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>NETWORK_OUT_BYTES_PER_SECOND</code> - The number of bytes sent out by
    ///                     the instance on all network interfaces. This metric identifies the volume of
    ///                     outgoing network traffic from a single instance.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>NETWORK_PACKETS_IN_PER_SECOND</code> - The number of packets received by
    ///                     the instance on all network interfaces. This metric identifies the volume of
    ///                     incoming traffic in terms of the number of packets on a single instance.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>NETWORK_PACKETS_OUT_PER_SECOND</code> - The number of packets sent out
    ///                     by the instance on all network interfaces. This metric identifies the volume of
    ///                     outgoing traffic in terms of the number of packets on a single instance.</p>
    ///             </li>
    ///          </ul>
    public let name: MetricName?
    /// <p>The statistic of the utilization metric.</p>
    ///
    ///         <p>The Compute Optimizer API, AWS Command Line Interface (AWS CLI), and SDKs return utilization metrics using
    ///             only the <code>Maximum</code> statistic, which is the highest value observed during the
    ///             specified period.</p>
    ///
    ///
    ///
    ///         <p>The Compute Optimizer console displays graphs for some utilization metrics using the
    ///                 <code>Average</code> statistic, which is the value of <code>Sum</code> /
    ///                 <code>SampleCount</code> during the specified period. For more information, see
    ///                 <a href="https://docs.aws.amazon.com/compute-optimizer/latest/ug/viewing-recommendations.html">Viewing resource
    ///                 recommendations</a> in the <i>AWS Compute Optimizer User Guide</i>. You can
    ///             also get averaged utilization metric data for your resources using Amazon CloudWatch. For more
    ///             information, see the <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/WhatIsCloudWatch.html">Amazon CloudWatch User
    ///                 Guide</a>.</p>
    public let statistic: MetricStatistic?
    /// <p>The value of the utilization metric.</p>
    public let value: Double

    public init (
        name: MetricName? = nil,
        statistic: MetricStatistic? = nil,
        value: Double = 0.0
    )
    {
        self.name = name
        self.statistic = statistic
        self.value = value
    }
}

extension VolumeConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case volumeBaselineIOPS
        case volumeBaselineThroughput
        case volumeBurstIOPS
        case volumeBurstThroughput
        case volumeSize
        case volumeType
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if volumeBaselineIOPS != 0 {
            try encodeContainer.encode(volumeBaselineIOPS, forKey: .volumeBaselineIOPS)
        }
        if volumeBaselineThroughput != 0 {
            try encodeContainer.encode(volumeBaselineThroughput, forKey: .volumeBaselineThroughput)
        }
        if volumeBurstIOPS != 0 {
            try encodeContainer.encode(volumeBurstIOPS, forKey: .volumeBurstIOPS)
        }
        if volumeBurstThroughput != 0 {
            try encodeContainer.encode(volumeBurstThroughput, forKey: .volumeBurstThroughput)
        }
        if volumeSize != 0 {
            try encodeContainer.encode(volumeSize, forKey: .volumeSize)
        }
        if let volumeType = volumeType {
            try encodeContainer.encode(volumeType, forKey: .volumeType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let volumeTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .volumeType)
        volumeType = volumeTypeDecoded
        let volumeSizeDecoded = try containerValues.decode(Int.self, forKey: .volumeSize)
        volumeSize = volumeSizeDecoded
        let volumeBaselineIOPSDecoded = try containerValues.decode(Int.self, forKey: .volumeBaselineIOPS)
        volumeBaselineIOPS = volumeBaselineIOPSDecoded
        let volumeBurstIOPSDecoded = try containerValues.decode(Int.self, forKey: .volumeBurstIOPS)
        volumeBurstIOPS = volumeBurstIOPSDecoded
        let volumeBaselineThroughputDecoded = try containerValues.decode(Int.self, forKey: .volumeBaselineThroughput)
        volumeBaselineThroughput = volumeBaselineThroughputDecoded
        let volumeBurstThroughputDecoded = try containerValues.decode(Int.self, forKey: .volumeBurstThroughput)
        volumeBurstThroughput = volumeBurstThroughputDecoded
    }
}

extension VolumeConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VolumeConfiguration(volumeBaselineIOPS: \(String(describing: volumeBaselineIOPS)), volumeBaselineThroughput: \(String(describing: volumeBaselineThroughput)), volumeBurstIOPS: \(String(describing: volumeBurstIOPS)), volumeBurstThroughput: \(String(describing: volumeBurstThroughput)), volumeSize: \(String(describing: volumeSize)), volumeType: \(String(describing: volumeType)))"}
}

/// <p>Describes the configuration of an Amazon Elastic Block Store (Amazon EBS) volume.</p>
public struct VolumeConfiguration: Equatable {
    /// <p>The baseline IOPS of the volume.</p>
    public let volumeBaselineIOPS: Int
    /// <p>The baseline throughput of the volume.</p>
    public let volumeBaselineThroughput: Int
    /// <p>The burst IOPS of the volume.</p>
    public let volumeBurstIOPS: Int
    /// <p>The burst throughput of the volume.</p>
    public let volumeBurstThroughput: Int
    /// <p>The size of the volume, in GiB.</p>
    public let volumeSize: Int
    /// <p>The volume type.</p>
    ///         <p>This can be <code>gp2</code> for General Purpose SSD, <code>io1</code> or
    ///                 <code>io2</code> for Provisioned IOPS SSD, <code>st1</code> for Throughput Optimized
    ///             HDD, <code>sc1</code> for Cold HDD, or <code>standard</code> for Magnetic
    ///             volumes.</p>
    public let volumeType: String?

    public init (
        volumeBaselineIOPS: Int = 0,
        volumeBaselineThroughput: Int = 0,
        volumeBurstIOPS: Int = 0,
        volumeBurstThroughput: Int = 0,
        volumeSize: Int = 0,
        volumeType: String? = nil
    )
    {
        self.volumeBaselineIOPS = volumeBaselineIOPS
        self.volumeBaselineThroughput = volumeBaselineThroughput
        self.volumeBurstIOPS = volumeBurstIOPS
        self.volumeBurstThroughput = volumeBurstThroughput
        self.volumeSize = volumeSize
        self.volumeType = volumeType
    }
}

extension VolumeRecommendation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountId
        case currentConfiguration
        case finding
        case lastRefreshTimestamp
        case lookBackPeriodInDays
        case utilizationMetrics
        case volumeArn
        case volumeRecommendationOptions
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let currentConfiguration = currentConfiguration {
            try encodeContainer.encode(currentConfiguration, forKey: .currentConfiguration)
        }
        if let finding = finding {
            try encodeContainer.encode(finding.rawValue, forKey: .finding)
        }
        if let lastRefreshTimestamp = lastRefreshTimestamp {
            try encodeContainer.encode(lastRefreshTimestamp.timeIntervalSince1970, forKey: .lastRefreshTimestamp)
        }
        if lookBackPeriodInDays != 0.0 {
            try encodeContainer.encode(lookBackPeriodInDays, forKey: .lookBackPeriodInDays)
        }
        if let utilizationMetrics = utilizationMetrics {
            var utilizationMetricsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .utilizationMetrics)
            for ebsutilizationmetrics0 in utilizationMetrics {
                try utilizationMetricsContainer.encode(ebsutilizationmetrics0)
            }
        }
        if let volumeArn = volumeArn {
            try encodeContainer.encode(volumeArn, forKey: .volumeArn)
        }
        if let volumeRecommendationOptions = volumeRecommendationOptions {
            var volumeRecommendationOptionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .volumeRecommendationOptions)
            for volumerecommendationoptions0 in volumeRecommendationOptions {
                try volumeRecommendationOptionsContainer.encode(volumerecommendationoptions0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let volumeArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .volumeArn)
        volumeArn = volumeArnDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let currentConfigurationDecoded = try containerValues.decodeIfPresent(VolumeConfiguration.self, forKey: .currentConfiguration)
        currentConfiguration = currentConfigurationDecoded
        let findingDecoded = try containerValues.decodeIfPresent(EBSFinding.self, forKey: .finding)
        finding = findingDecoded
        let utilizationMetricsContainer = try containerValues.decodeIfPresent([EBSUtilizationMetric?].self, forKey: .utilizationMetrics)
        var utilizationMetricsDecoded0:[EBSUtilizationMetric]? = nil
        if let utilizationMetricsContainer = utilizationMetricsContainer {
            utilizationMetricsDecoded0 = [EBSUtilizationMetric]()
            for structure0 in utilizationMetricsContainer {
                if let structure0 = structure0 {
                    utilizationMetricsDecoded0?.append(structure0)
                }
            }
        }
        utilizationMetrics = utilizationMetricsDecoded0
        let lookBackPeriodInDaysDecoded = try containerValues.decode(Double.self, forKey: .lookBackPeriodInDays)
        lookBackPeriodInDays = lookBackPeriodInDaysDecoded
        let volumeRecommendationOptionsContainer = try containerValues.decodeIfPresent([VolumeRecommendationOption?].self, forKey: .volumeRecommendationOptions)
        var volumeRecommendationOptionsDecoded0:[VolumeRecommendationOption]? = nil
        if let volumeRecommendationOptionsContainer = volumeRecommendationOptionsContainer {
            volumeRecommendationOptionsDecoded0 = [VolumeRecommendationOption]()
            for structure0 in volumeRecommendationOptionsContainer {
                if let structure0 = structure0 {
                    volumeRecommendationOptionsDecoded0?.append(structure0)
                }
            }
        }
        volumeRecommendationOptions = volumeRecommendationOptionsDecoded0
        let lastRefreshTimestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastRefreshTimestamp)
        lastRefreshTimestamp = lastRefreshTimestampDecoded
    }
}

extension VolumeRecommendation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VolumeRecommendation(accountId: \(String(describing: accountId)), currentConfiguration: \(String(describing: currentConfiguration)), finding: \(String(describing: finding)), lastRefreshTimestamp: \(String(describing: lastRefreshTimestamp)), lookBackPeriodInDays: \(String(describing: lookBackPeriodInDays)), utilizationMetrics: \(String(describing: utilizationMetrics)), volumeArn: \(String(describing: volumeArn)), volumeRecommendationOptions: \(String(describing: volumeRecommendationOptions)))"}
}

/// <p>Describes an Amazon Elastic Block Store (Amazon EBS) volume recommendation.</p>
public struct VolumeRecommendation: Equatable {
    /// <p>The AWS account ID of the volume.</p>
    public let accountId: String?
    /// <p>An array of objects that describe the current configuration of the volume.</p>
    public let currentConfiguration: VolumeConfiguration?
    /// <p>The finding classification of the volume.</p>
    ///         <p>Findings for volumes include:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <b>
    ///                      <code>NotOptimized</code>
    ///                   </b>—A volume
    ///                     is considered not optimized when AWS Compute Optimizer identifies a recommendation that can
    ///                     provide better performance for your workload.</p>
    ///
    ///
    ///
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <b>
    ///                      <code>Optimized</code>
    ///                   </b>—An volume is
    ///                     considered optimized when Compute Optimizer determines that the volume is correctly
    ///                     provisioned to run your workload based on the chosen volume type. For optimized
    ///                     resources, Compute Optimizer might recommend a new generation volume type.</p>
    ///
    ///             </li>
    ///          </ul>
    public let finding: EBSFinding?
    /// <p>The time stamp of when the volume recommendation was last refreshed.</p>
    public let lastRefreshTimestamp: Date?
    /// <p>The number of days for which utilization metrics were analyzed for the volume.</p>
    public let lookBackPeriodInDays: Double
    /// <p>An array of objects that describe the utilization metrics of the volume.</p>
    public let utilizationMetrics: [EBSUtilizationMetric]?
    /// <p>The Amazon Resource Name (ARN) of the current volume.</p>
    public let volumeArn: String?
    /// <p>An array of objects that describe the recommendation options for the volume.</p>
    public let volumeRecommendationOptions: [VolumeRecommendationOption]?

    public init (
        accountId: String? = nil,
        currentConfiguration: VolumeConfiguration? = nil,
        finding: EBSFinding? = nil,
        lastRefreshTimestamp: Date? = nil,
        lookBackPeriodInDays: Double = 0.0,
        utilizationMetrics: [EBSUtilizationMetric]? = nil,
        volumeArn: String? = nil,
        volumeRecommendationOptions: [VolumeRecommendationOption]? = nil
    )
    {
        self.accountId = accountId
        self.currentConfiguration = currentConfiguration
        self.finding = finding
        self.lastRefreshTimestamp = lastRefreshTimestamp
        self.lookBackPeriodInDays = lookBackPeriodInDays
        self.utilizationMetrics = utilizationMetrics
        self.volumeArn = volumeArn
        self.volumeRecommendationOptions = volumeRecommendationOptions
    }
}

extension VolumeRecommendationOption: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case configuration
        case performanceRisk
        case rank
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configuration = configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
        if performanceRisk != 0.0 {
            try encodeContainer.encode(performanceRisk, forKey: .performanceRisk)
        }
        if rank != 0 {
            try encodeContainer.encode(rank, forKey: .rank)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationDecoded = try containerValues.decodeIfPresent(VolumeConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
        let performanceRiskDecoded = try containerValues.decode(Double.self, forKey: .performanceRisk)
        performanceRisk = performanceRiskDecoded
        let rankDecoded = try containerValues.decode(Int.self, forKey: .rank)
        rank = rankDecoded
    }
}

extension VolumeRecommendationOption: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VolumeRecommendationOption(configuration: \(String(describing: configuration)), performanceRisk: \(String(describing: performanceRisk)), rank: \(String(describing: rank)))"}
}

/// <p>Describes a recommendation option for an Amazon Elastic Block Store (Amazon EBS) instance.</p>
public struct VolumeRecommendationOption: Equatable {
    /// <p>An array of objects that describe a volume configuration.</p>
    public let configuration: VolumeConfiguration?
    /// <p>The performance risk of the volume recommendation option.</p>
    ///         <p>Performance risk is the likelihood of the recommended volume type meeting the
    ///             performance requirement of your workload.</p>
    ///         <p>The value ranges from <code>0</code> to <code>5</code>, with <code>0</code> meaning
    ///             that the recommended resource is predicted to always provide enough hardware capability.
    ///             The higher the performance risk is, the more likely you should validate whether the
    ///             recommendation will meet the performance requirements of your workload before migrating
    ///             your resource.</p>
    public let performanceRisk: Double
    /// <p>The rank of the volume recommendation option.</p>
    ///         <p>The top recommendation option is ranked as <code>1</code>.</p>
    public let rank: Int

    public init (
        configuration: VolumeConfiguration? = nil,
        performanceRisk: Double = 0.0,
        rank: Int = 0
    )
    {
        self.configuration = configuration
        self.performanceRisk = performanceRisk
        self.rank = rank
    }
}
