// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension Entitlement: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case customerIdentifier = "CustomerIdentifier"
        case dimension = "Dimension"
        case expirationDate = "ExpirationDate"
        case productCode = "ProductCode"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customerIdentifier = customerIdentifier {
            try encodeContainer.encode(customerIdentifier, forKey: .customerIdentifier)
        }
        if let dimension = dimension {
            try encodeContainer.encode(dimension, forKey: .dimension)
        }
        if let expirationDate = expirationDate {
            try encodeContainer.encode(expirationDate.timeIntervalSince1970, forKey: .expirationDate)
        }
        if let productCode = productCode {
            try encodeContainer.encode(productCode, forKey: .productCode)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let productCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .productCode)
        productCode = productCodeDecoded
        let dimensionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dimension)
        dimension = dimensionDecoded
        let customerIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .customerIdentifier)
        customerIdentifier = customerIdentifierDecoded
        let valueDecoded = try containerValues.decodeIfPresent(EntitlementValue.self, forKey: .value)
        value = valueDecoded
        let expirationDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .expirationDate)
        expirationDate = expirationDateDecoded
    }
}

extension Entitlement: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Entitlement(customerIdentifier: \(String(describing: customerIdentifier)), dimension: \(String(describing: dimension)), expirationDate: \(String(describing: expirationDate)), productCode: \(String(describing: productCode)), value: \(String(describing: value)))"}
}

/// <p>An entitlement represents capacity in a product owned by the customer. For example, a
///       customer might own some number of users or seats in an SaaS application or  some amount of
///       data capacity in a multi-tenant database.</p>
public struct Entitlement: Equatable {
    /// <p>The customer identifier is a handle to each unique customer in an application. Customer
    ///    identifiers are obtained through the ResolveCustomer operation in AWS Marketplace Metering
    ///    Service.</p>
    public let customerIdentifier: String?
    /// <p>The dimension for which the given entitlement applies. Dimensions represent categories of
    ///       capacity in a product and are specified when the product is listed in AWS
    ///       Marketplace.</p>
    public let dimension: String?
    /// <p>The expiration date represents the minimum date through which this entitlement is
    ///    expected to remain valid. For contractual products listed on AWS Marketplace, the expiration date
    ///    is the date at which the customer will renew or cancel their contract. Customers who are opting
    ///    to renew their contract will still have entitlements with an expiration date.</p>
    public let expirationDate: Date?
    /// <p>The product code for which the given entitlement applies. Product codes are provided by
    ///    AWS Marketplace when the product listing is created.</p>
    public let productCode: String?
    /// <p>The EntitlementValue represents the amount of capacity that the customer is entitled to
    ///    for the product.</p>
    public let value: EntitlementValue?

    public init (
        customerIdentifier: String? = nil,
        dimension: String? = nil,
        expirationDate: Date? = nil,
        productCode: String? = nil,
        value: EntitlementValue? = nil
    )
    {
        self.customerIdentifier = customerIdentifier
        self.dimension = dimension
        self.expirationDate = expirationDate
        self.productCode = productCode
        self.value = value
    }
}

extension EntitlementValue: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case booleanvalue = "BooleanValue"
        case doublevalue = "DoubleValue"
        case integervalue = "IntegerValue"
        case stringvalue = "StringValue"
        case sdkUnknown
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .booleanvalue(booleanvalue):
                try container.encode(booleanvalue, forKey: .booleanvalue)
            case let .doublevalue(doublevalue):
                try container.encode(doublevalue, forKey: .doublevalue)
            case let .integervalue(integervalue):
                try container.encode(integervalue, forKey: .integervalue)
            case let .stringvalue(stringvalue):
                try container.encode(stringvalue, forKey: .stringvalue)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let integervalueDecoded = try values.decodeIfPresent(Int.self, forKey: .integervalue)
        if let integervalue = integervalueDecoded {
            self = .integervalue(integervalue)
            return
        }
        let doublevalueDecoded = try values.decodeIfPresent(Double.self, forKey: .doublevalue)
        if let doublevalue = doublevalueDecoded {
            self = .doublevalue(doublevalue)
            return
        }
        let booleanvalueDecoded = try values.decodeIfPresent(Bool.self, forKey: .booleanvalue)
        if let booleanvalue = booleanvalueDecoded {
            self = .booleanvalue(booleanvalue)
            return
        }
        let stringvalueDecoded = try values.decodeIfPresent(String.self, forKey: .stringvalue)
        if let stringvalue = stringvalueDecoded {
            self = .stringvalue(stringvalue)
            return
        }
        self = .sdkUnknown("")
    }
}

/// <p>The EntitlementValue represents the amount of capacity that the customer is entitled to
///    for the product.</p>
public enum EntitlementValue: Equatable {
    /// <p>The IntegerValue field will be populated with an integer value when the entitlement is an
    ///    integer type. Otherwise, the field will not be set.</p>
    case integervalue(Int)
    /// <p>The DoubleValue field will be populated with a double value when the entitlement is a
    ///    double type. Otherwise, the field will not be set.</p>
    case doublevalue(Double)
    /// <p>The BooleanValue field will be populated with a boolean value when the entitlement is a
    ///       boolean type. Otherwise, the field will not be set.</p>
    case booleanvalue(Bool)
    /// <p>The StringValue field will be populated with a string value when the entitlement is a
    ///    string type. Otherwise, the field will not be set.</p>
    case stringvalue(String)
    case sdkUnknown(String)
}

public enum GetEntitlementFilterName {
    case customerIdentifier
    case dimension
    case sdkUnknown(String)
}

extension GetEntitlementFilterName : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [GetEntitlementFilterName] {
        return [
            .customerIdentifier,
            .dimension,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .customerIdentifier: return "CUSTOMER_IDENTIFIER"
        case .dimension: return "DIMENSION"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = GetEntitlementFilterName(rawValue: rawValue) ?? GetEntitlementFilterName.sdkUnknown(rawValue)
    }
}

public struct GetEntitlementsInputBodyMiddleware: Middleware {
    public let id: String = "GetEntitlementsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetEntitlementsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetEntitlementsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetEntitlementsInput>
    public typealias MOutput = OperationOutput<GetEntitlementsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetEntitlementsOutputError>
}

extension GetEntitlementsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetEntitlementsInput(filter: \(String(describing: filter)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), productCode: \(String(describing: productCode)))"}
}

extension GetEntitlementsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filter = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case productCode = "ProductCode"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = filter {
            var filterContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .filter)
            for (dictKey0, getentitlementfilters0) in filter {
                try filterContainer.encode(getentitlementfilters0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let productCode = productCode {
            try encodeContainer.encode(productCode, forKey: .productCode)
        }
    }
}

public struct GetEntitlementsInputHeadersMiddleware: Middleware {
    public let id: String = "GetEntitlementsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetEntitlementsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetEntitlementsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetEntitlementsInput>
    public typealias MOutput = OperationOutput<GetEntitlementsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetEntitlementsOutputError>
}

public struct GetEntitlementsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetEntitlementsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetEntitlementsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetEntitlementsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetEntitlementsInput>
    public typealias MOutput = OperationOutput<GetEntitlementsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetEntitlementsOutputError>
}

/// <p>The GetEntitlementsRequest contains parameters for the GetEntitlements
///    operation.</p>
public struct GetEntitlementsInput: Equatable {
    /// <p>Filter is used to return entitlements for a specific customer or for a specific
    ///       dimension. Filters are described as keys mapped to a lists of values. Filtered requests are
    ///         <i>unioned</i> for each value in the value list, and then
    ///         <i>intersected</i> for each filter key.</p>
    public let filter: [String:[String]]?
    /// <p>The maximum number of items to retrieve from the GetEntitlements operation. For
    ///    pagination, use the NextToken field in subsequent calls to GetEntitlements.</p>
    public let maxResults: Int?
    /// <p>For paginated calls to GetEntitlements, pass the NextToken from the previous
    ///    GetEntitlementsResult.</p>
    public let nextToken: String?
    /// <p>Product code is used to uniquely identify a product in AWS Marketplace. The product code
    ///    will be provided by AWS Marketplace when the product listing is created.</p>
    public let productCode: String?

    public init (
        filter: [String:[String]]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        productCode: String? = nil
    )
    {
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.productCode = productCode
    }
}

struct GetEntitlementsInputBody: Equatable {
    public let productCode: String?
    public let filter: [String:[String]]?
    public let nextToken: String?
    public let maxResults: Int?
}

extension GetEntitlementsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filter = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case productCode = "ProductCode"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let productCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .productCode)
        productCode = productCodeDecoded
        let filterContainer = try containerValues.decodeIfPresent([String: [String?]?].self, forKey: .filter)
        var filterDecoded0: [String:[String]]? = nil
        if let filterContainer = filterContainer {
            filterDecoded0 = [String:[String]]()
            for (key0, filtervaluelist0) in filterContainer {
                var filtervaluelist0Decoded0: [String]? = nil
                if let filtervaluelist0 = filtervaluelist0 {
                    filtervaluelist0Decoded0 = [String]()
                    for string1 in filtervaluelist0 {
                        if let string1 = string1 {
                            filtervaluelist0Decoded0?.append(string1)
                        }
                    }
                }
                filterDecoded0?[key0] = filtervaluelist0Decoded0
            }
        }
        filter = filterDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension GetEntitlementsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetEntitlementsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetEntitlementsOutputError: Swift.Error, Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidParameterException(InvalidParameterException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetEntitlementsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetEntitlementsOutputResponse(entitlements: \(String(describing: entitlements)), nextToken: \(String(describing: nextToken)))"}
}

extension GetEntitlementsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetEntitlementsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.entitlements = output.entitlements
            self.nextToken = output.nextToken
        } else {
            self.entitlements = nil
            self.nextToken = nil
        }
    }
}

/// <p>The GetEntitlementsRequest contains results from the GetEntitlements operation.</p>
public struct GetEntitlementsOutputResponse: Equatable {
    /// <p>The set of entitlements found through the GetEntitlements operation. If the result
    ///       contains an empty set of entitlements, NextToken might still be present and should be
    ///       used.</p>
    public let entitlements: [Entitlement]?
    /// <p>For paginated results, use NextToken in subsequent calls to GetEntitlements. If the
    ///       result contains an empty set of entitlements, NextToken might still be present and should be
    ///       used.</p>
    public let nextToken: String?

    public init (
        entitlements: [Entitlement]? = nil,
        nextToken: String? = nil
    )
    {
        self.entitlements = entitlements
        self.nextToken = nextToken
    }
}

struct GetEntitlementsOutputResponseBody: Equatable {
    public let entitlements: [Entitlement]?
    public let nextToken: String?
}

extension GetEntitlementsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case entitlements = "Entitlements"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entitlementsContainer = try containerValues.decodeIfPresent([Entitlement?].self, forKey: .entitlements)
        var entitlementsDecoded0:[Entitlement]? = nil
        if let entitlementsContainer = entitlementsContainer {
            entitlementsDecoded0 = [Entitlement]()
            for structure0 in entitlementsContainer {
                if let structure0 = structure0 {
                    entitlementsDecoded0?.append(structure0)
                }
            }
        }
        entitlements = entitlementsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension InternalServiceErrorException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalServiceErrorException(message: \(String(describing: message)))"}
}

extension InternalServiceErrorException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServiceErrorExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An internal error has occurred. Retry your request. If the problem persists, post a
///    message with details on the AWS forums.</p>
public struct InternalServiceErrorException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServiceErrorExceptionBody: Equatable {
    public let message: String?
}

extension InternalServiceErrorExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidParameterException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidParameterException(message: \(String(describing: message)))"}
}

extension InvalidParameterException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidParameterExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>One or more parameters in your request was invalid.</p>
public struct InvalidParameterException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidParameterExceptionBody: Equatable {
    public let message: String?
}

extension InvalidParameterExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ThrottlingException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ThrottlingException(message: \(String(describing: message)))"}
}

extension ThrottlingException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The calls to the GetEntitlements API are throttled.</p>
public struct ThrottlingException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ThrottlingExceptionBody: Equatable {
    public let message: String?
}

extension ThrottlingExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}
