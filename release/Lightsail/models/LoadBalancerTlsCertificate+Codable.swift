// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension LoadBalancerTlsCertificate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case createdAt
        case domainName
        case domainValidationRecords
        case failureReason
        case isAttached
        case issuedAt
        case issuer
        case keyAlgorithm
        case loadBalancerName
        case location
        case name
        case notAfter
        case notBefore
        case renewalSummary
        case resourceType
        case revocationReason
        case revokedAt
        case serial
        case signatureAlgorithm
        case status
        case subject
        case subjectAlternativeNames
        case supportCode
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let domainName = domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let domainValidationRecords = domainValidationRecords {
            var domainValidationRecordsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .domainValidationRecords)
            for loadbalancertlscertificatedomainvalidationrecordlist0 in domainValidationRecords {
                try domainValidationRecordsContainer.encode(loadbalancertlscertificatedomainvalidationrecordlist0)
            }
        }
        if let failureReason = failureReason {
            try encodeContainer.encode(failureReason.rawValue, forKey: .failureReason)
        }
        if let isAttached = isAttached {
            try encodeContainer.encode(isAttached, forKey: .isAttached)
        }
        if let issuedAt = issuedAt {
            try encodeContainer.encode(issuedAt.timeIntervalSince1970, forKey: .issuedAt)
        }
        if let issuer = issuer {
            try encodeContainer.encode(issuer, forKey: .issuer)
        }
        if let keyAlgorithm = keyAlgorithm {
            try encodeContainer.encode(keyAlgorithm, forKey: .keyAlgorithm)
        }
        if let loadBalancerName = loadBalancerName {
            try encodeContainer.encode(loadBalancerName, forKey: .loadBalancerName)
        }
        if let location = location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let notAfter = notAfter {
            try encodeContainer.encode(notAfter.timeIntervalSince1970, forKey: .notAfter)
        }
        if let notBefore = notBefore {
            try encodeContainer.encode(notBefore.timeIntervalSince1970, forKey: .notBefore)
        }
        if let renewalSummary = renewalSummary {
            try encodeContainer.encode(renewalSummary, forKey: .renewalSummary)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
        if let revocationReason = revocationReason {
            try encodeContainer.encode(revocationReason.rawValue, forKey: .revocationReason)
        }
        if let revokedAt = revokedAt {
            try encodeContainer.encode(revokedAt.timeIntervalSince1970, forKey: .revokedAt)
        }
        if let serial = serial {
            try encodeContainer.encode(serial, forKey: .serial)
        }
        if let signatureAlgorithm = signatureAlgorithm {
            try encodeContainer.encode(signatureAlgorithm, forKey: .signatureAlgorithm)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let subject = subject {
            try encodeContainer.encode(subject, forKey: .subject)
        }
        if let subjectAlternativeNames = subjectAlternativeNames {
            var subjectAlternativeNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subjectAlternativeNames)
            for stringlist0 in subjectAlternativeNames {
                try subjectAlternativeNamesContainer.encode(stringlist0)
            }
        }
        if let supportCode = supportCode {
            try encodeContainer.encode(supportCode, forKey: .supportCode)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let supportCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .supportCode)
        supportCode = supportCodeDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let locationDecoded = try containerValues.decodeIfPresent(ResourceLocation.self, forKey: .location)
        location = locationDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                tagsDecoded0?.append(structure0)
            }
        }
        tags = tagsDecoded0
        let loadBalancerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .loadBalancerName)
        loadBalancerName = loadBalancerNameDecoded
        let isAttachedDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .isAttached)
        isAttached = isAttachedDecoded
        let statusDecoded = try containerValues.decodeIfPresent(LoadBalancerTlsCertificateStatus.self, forKey: .status)
        status = statusDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let domainValidationRecordsContainer = try containerValues.decodeIfPresent([LoadBalancerTlsCertificateDomainValidationRecord].self, forKey: .domainValidationRecords)
        var domainValidationRecordsDecoded0:[LoadBalancerTlsCertificateDomainValidationRecord]? = nil
        if let domainValidationRecordsContainer = domainValidationRecordsContainer {
            domainValidationRecordsDecoded0 = [LoadBalancerTlsCertificateDomainValidationRecord]()
            for structure0 in domainValidationRecordsContainer {
                domainValidationRecordsDecoded0?.append(structure0)
            }
        }
        domainValidationRecords = domainValidationRecordsDecoded0
        let failureReasonDecoded = try containerValues.decodeIfPresent(LoadBalancerTlsCertificateFailureReason.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let issuedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .issuedAt)
        issuedAt = issuedAtDecoded
        let issuerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .issuer)
        issuer = issuerDecoded
        let keyAlgorithmDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keyAlgorithm)
        keyAlgorithm = keyAlgorithmDecoded
        let notAfterDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .notAfter)
        notAfter = notAfterDecoded
        let notBeforeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .notBefore)
        notBefore = notBeforeDecoded
        let renewalSummaryDecoded = try containerValues.decodeIfPresent(LoadBalancerTlsCertificateRenewalSummary.self, forKey: .renewalSummary)
        renewalSummary = renewalSummaryDecoded
        let revocationReasonDecoded = try containerValues.decodeIfPresent(LoadBalancerTlsCertificateRevocationReason.self, forKey: .revocationReason)
        revocationReason = revocationReasonDecoded
        let revokedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .revokedAt)
        revokedAt = revokedAtDecoded
        let serialDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serial)
        serial = serialDecoded
        let signatureAlgorithmDecoded = try containerValues.decodeIfPresent(String.self, forKey: .signatureAlgorithm)
        signatureAlgorithm = signatureAlgorithmDecoded
        let subjectDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subject)
        subject = subjectDecoded
        let subjectAlternativeNamesContainer = try containerValues.decodeIfPresent([String].self, forKey: .subjectAlternativeNames)
        var subjectAlternativeNamesDecoded0:[String]? = nil
        if let subjectAlternativeNamesContainer = subjectAlternativeNamesContainer {
            subjectAlternativeNamesDecoded0 = [String]()
            for string0 in subjectAlternativeNamesContainer {
                subjectAlternativeNamesDecoded0?.append(string0)
            }
        }
        subjectAlternativeNames = subjectAlternativeNamesDecoded0
    }
}
