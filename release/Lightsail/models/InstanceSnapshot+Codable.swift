// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension InstanceSnapshot: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case createdAt
        case fromAttachedDisks
        case fromBlueprintId
        case fromBundleId
        case fromInstanceArn
        case fromInstanceName
        case isFromAutoSnapshot
        case location
        case name
        case progress
        case resourceType
        case sizeInGb
        case state
        case supportCode
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let fromAttachedDisks = fromAttachedDisks {
            var fromAttachedDisksContainer = encodeContainer.nestedUnkeyedContainer(forKey: .fromAttachedDisks)
            for disklist0 in fromAttachedDisks {
                try fromAttachedDisksContainer.encode(disklist0)
            }
        }
        if let fromBlueprintId = fromBlueprintId {
            try encodeContainer.encode(fromBlueprintId, forKey: .fromBlueprintId)
        }
        if let fromBundleId = fromBundleId {
            try encodeContainer.encode(fromBundleId, forKey: .fromBundleId)
        }
        if let fromInstanceArn = fromInstanceArn {
            try encodeContainer.encode(fromInstanceArn, forKey: .fromInstanceArn)
        }
        if let fromInstanceName = fromInstanceName {
            try encodeContainer.encode(fromInstanceName, forKey: .fromInstanceName)
        }
        if let isFromAutoSnapshot = isFromAutoSnapshot {
            try encodeContainer.encode(isFromAutoSnapshot, forKey: .isFromAutoSnapshot)
        }
        if let location = location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let progress = progress {
            try encodeContainer.encode(progress, forKey: .progress)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
        if let sizeInGb = sizeInGb {
            try encodeContainer.encode(sizeInGb, forKey: .sizeInGb)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let supportCode = supportCode {
            try encodeContainer.encode(supportCode, forKey: .supportCode)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let supportCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .supportCode)
        supportCode = supportCodeDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let locationDecoded = try containerValues.decodeIfPresent(ResourceLocation.self, forKey: .location)
        location = locationDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                tagsDecoded0?.append(structure0)
            }
        }
        tags = tagsDecoded0
        let stateDecoded = try containerValues.decodeIfPresent(InstanceSnapshotState.self, forKey: .state)
        state = stateDecoded
        let progressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .progress)
        progress = progressDecoded
        let fromAttachedDisksContainer = try containerValues.decodeIfPresent([Disk].self, forKey: .fromAttachedDisks)
        var fromAttachedDisksDecoded0:[Disk]? = nil
        if let fromAttachedDisksContainer = fromAttachedDisksContainer {
            fromAttachedDisksDecoded0 = [Disk]()
            for structure0 in fromAttachedDisksContainer {
                fromAttachedDisksDecoded0?.append(structure0)
            }
        }
        fromAttachedDisks = fromAttachedDisksDecoded0
        let fromInstanceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fromInstanceName)
        fromInstanceName = fromInstanceNameDecoded
        let fromInstanceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fromInstanceArn)
        fromInstanceArn = fromInstanceArnDecoded
        let fromBlueprintIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fromBlueprintId)
        fromBlueprintId = fromBlueprintIdDecoded
        let fromBundleIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fromBundleId)
        fromBundleId = fromBundleIdDecoded
        let isFromAutoSnapshotDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .isFromAutoSnapshot)
        isFromAutoSnapshot = isFromAutoSnapshotDecoded
        let sizeInGbDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .sizeInGb)
        sizeInGb = sizeInGbDecoded
    }
}
