// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension Alarm: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case comparisonOperator
        case contactProtocols
        case createdAt
        case datapointsToAlarm
        case evaluationPeriods
        case location
        case metricName
        case monitoredResourceInfo
        case name
        case notificationEnabled
        case notificationTriggers
        case period
        case resourceType
        case state
        case statistic
        case supportCode
        case threshold
        case treatMissingData
        case unit
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let comparisonOperator = comparisonOperator {
            try encodeContainer.encode(comparisonOperator.rawValue, forKey: .comparisonOperator)
        }
        if let contactProtocols = contactProtocols {
            var contactProtocolsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .contactProtocols)
            for contactprotocolslist0 in contactProtocols {
                try contactProtocolsContainer.encode(contactprotocolslist0.rawValue)
            }
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let datapointsToAlarm = datapointsToAlarm {
            try encodeContainer.encode(datapointsToAlarm, forKey: .datapointsToAlarm)
        }
        if let evaluationPeriods = evaluationPeriods {
            try encodeContainer.encode(evaluationPeriods, forKey: .evaluationPeriods)
        }
        if let location = location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let metricName = metricName {
            try encodeContainer.encode(metricName.rawValue, forKey: .metricName)
        }
        if let monitoredResourceInfo = monitoredResourceInfo {
            try encodeContainer.encode(monitoredResourceInfo, forKey: .monitoredResourceInfo)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let notificationEnabled = notificationEnabled {
            try encodeContainer.encode(notificationEnabled, forKey: .notificationEnabled)
        }
        if let notificationTriggers = notificationTriggers {
            var notificationTriggersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notificationTriggers)
            for notificationtriggerlist0 in notificationTriggers {
                try notificationTriggersContainer.encode(notificationtriggerlist0.rawValue)
            }
        }
        if period != 0 {
            try encodeContainer.encode(period, forKey: .period)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let statistic = statistic {
            try encodeContainer.encode(statistic.rawValue, forKey: .statistic)
        }
        if let supportCode = supportCode {
            try encodeContainer.encode(supportCode, forKey: .supportCode)
        }
        if let threshold = threshold {
            try encodeContainer.encode(threshold, forKey: .threshold)
        }
        if let treatMissingData = treatMissingData {
            try encodeContainer.encode(treatMissingData.rawValue, forKey: .treatMissingData)
        }
        if let unit = unit {
            try encodeContainer.encode(unit.rawValue, forKey: .unit)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let locationDecoded = try containerValues.decodeIfPresent(ResourceLocation.self, forKey: .location)
        location = locationDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let supportCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .supportCode)
        supportCode = supportCodeDecoded
        let monitoredResourceInfoDecoded = try containerValues.decodeIfPresent(MonitoredResourceInfo.self, forKey: .monitoredResourceInfo)
        monitoredResourceInfo = monitoredResourceInfoDecoded
        let comparisonOperatorDecoded = try containerValues.decodeIfPresent(ComparisonOperator.self, forKey: .comparisonOperator)
        comparisonOperator = comparisonOperatorDecoded
        let evaluationPeriodsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .evaluationPeriods)
        evaluationPeriods = evaluationPeriodsDecoded
        let periodDecoded = try containerValues.decode(Int.self, forKey: .period)
        period = periodDecoded
        let thresholdDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .threshold)
        threshold = thresholdDecoded
        let datapointsToAlarmDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .datapointsToAlarm)
        datapointsToAlarm = datapointsToAlarmDecoded
        let treatMissingDataDecoded = try containerValues.decodeIfPresent(TreatMissingData.self, forKey: .treatMissingData)
        treatMissingData = treatMissingDataDecoded
        let statisticDecoded = try containerValues.decodeIfPresent(MetricStatistic.self, forKey: .statistic)
        statistic = statisticDecoded
        let metricNameDecoded = try containerValues.decodeIfPresent(MetricName.self, forKey: .metricName)
        metricName = metricNameDecoded
        let stateDecoded = try containerValues.decodeIfPresent(AlarmState.self, forKey: .state)
        state = stateDecoded
        let unitDecoded = try containerValues.decodeIfPresent(MetricUnit.self, forKey: .unit)
        unit = unitDecoded
        let contactProtocolsContainer = try containerValues.decodeIfPresent([ContactProtocol].self, forKey: .contactProtocols)
        var contactProtocolsDecoded0:[ContactProtocol]? = nil
        if let contactProtocolsContainer = contactProtocolsContainer {
            contactProtocolsDecoded0 = [ContactProtocol]()
            for string0 in contactProtocolsContainer {
                contactProtocolsDecoded0?.append(string0)
            }
        }
        contactProtocols = contactProtocolsDecoded0
        let notificationTriggersContainer = try containerValues.decodeIfPresent([AlarmState].self, forKey: .notificationTriggers)
        var notificationTriggersDecoded0:[AlarmState]? = nil
        if let notificationTriggersContainer = notificationTriggersContainer {
            notificationTriggersDecoded0 = [AlarmState]()
            for string0 in notificationTriggersContainer {
                notificationTriggersDecoded0?.append(string0)
            }
        }
        notificationTriggers = notificationTriggersDecoded0
        let notificationEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .notificationEnabled)
        notificationEnabled = notificationEnabledDecoded
    }
}
