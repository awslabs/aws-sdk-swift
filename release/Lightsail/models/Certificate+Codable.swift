// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension Certificate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case createdAt
        case domainName
        case domainValidationRecords
        case eligibleToRenew
        case inUseResourceCount
        case issuedAt
        case issuerCA
        case keyAlgorithm
        case name
        case notAfter
        case notBefore
        case renewalSummary
        case requestFailureReason
        case revocationReason
        case revokedAt
        case serialNumber
        case status
        case subjectAlternativeNames
        case supportCode
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let domainName = domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let domainValidationRecords = domainValidationRecords {
            var domainValidationRecordsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .domainValidationRecords)
            for domainvalidationrecordlist0 in domainValidationRecords {
                try domainValidationRecordsContainer.encode(domainvalidationrecordlist0)
            }
        }
        if let eligibleToRenew = eligibleToRenew {
            try encodeContainer.encode(eligibleToRenew, forKey: .eligibleToRenew)
        }
        if inUseResourceCount != 0 {
            try encodeContainer.encode(inUseResourceCount, forKey: .inUseResourceCount)
        }
        if let issuedAt = issuedAt {
            try encodeContainer.encode(issuedAt.timeIntervalSince1970, forKey: .issuedAt)
        }
        if let issuerCA = issuerCA {
            try encodeContainer.encode(issuerCA, forKey: .issuerCA)
        }
        if let keyAlgorithm = keyAlgorithm {
            try encodeContainer.encode(keyAlgorithm, forKey: .keyAlgorithm)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let notAfter = notAfter {
            try encodeContainer.encode(notAfter.timeIntervalSince1970, forKey: .notAfter)
        }
        if let notBefore = notBefore {
            try encodeContainer.encode(notBefore.timeIntervalSince1970, forKey: .notBefore)
        }
        if let renewalSummary = renewalSummary {
            try encodeContainer.encode(renewalSummary, forKey: .renewalSummary)
        }
        if let requestFailureReason = requestFailureReason {
            try encodeContainer.encode(requestFailureReason, forKey: .requestFailureReason)
        }
        if let revocationReason = revocationReason {
            try encodeContainer.encode(revocationReason, forKey: .revocationReason)
        }
        if let revokedAt = revokedAt {
            try encodeContainer.encode(revokedAt.timeIntervalSince1970, forKey: .revokedAt)
        }
        if let serialNumber = serialNumber {
            try encodeContainer.encode(serialNumber, forKey: .serialNumber)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let subjectAlternativeNames = subjectAlternativeNames {
            var subjectAlternativeNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subjectAlternativeNames)
            for subjectalternativenamelist0 in subjectAlternativeNames {
                try subjectAlternativeNamesContainer.encode(subjectalternativenamelist0)
            }
        }
        if let supportCode = supportCode {
            try encodeContainer.encode(supportCode, forKey: .supportCode)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(CertificateStatus.self, forKey: .status)
        status = statusDecoded
        let serialNumberDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serialNumber)
        serialNumber = serialNumberDecoded
        let subjectAlternativeNamesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .subjectAlternativeNames)
        var subjectAlternativeNamesDecoded0:[String]? = nil
        if let subjectAlternativeNamesContainer = subjectAlternativeNamesContainer {
            subjectAlternativeNamesDecoded0 = [String]()
            for string0 in subjectAlternativeNamesContainer {
                if let string0 = string0 {
                    subjectAlternativeNamesDecoded0?.append(string0)
                }
            }
        }
        subjectAlternativeNames = subjectAlternativeNamesDecoded0
        let domainValidationRecordsContainer = try containerValues.decodeIfPresent([DomainValidationRecord?].self, forKey: .domainValidationRecords)
        var domainValidationRecordsDecoded0:[DomainValidationRecord]? = nil
        if let domainValidationRecordsContainer = domainValidationRecordsContainer {
            domainValidationRecordsDecoded0 = [DomainValidationRecord]()
            for structure0 in domainValidationRecordsContainer {
                if let structure0 = structure0 {
                    domainValidationRecordsDecoded0?.append(structure0)
                }
            }
        }
        domainValidationRecords = domainValidationRecordsDecoded0
        let requestFailureReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestFailureReason)
        requestFailureReason = requestFailureReasonDecoded
        let inUseResourceCountDecoded = try containerValues.decode(Int.self, forKey: .inUseResourceCount)
        inUseResourceCount = inUseResourceCountDecoded
        let keyAlgorithmDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keyAlgorithm)
        keyAlgorithm = keyAlgorithmDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let issuedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .issuedAt)
        issuedAt = issuedAtDecoded
        let issuerCADecoded = try containerValues.decodeIfPresent(String.self, forKey: .issuerCA)
        issuerCA = issuerCADecoded
        let notBeforeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .notBefore)
        notBefore = notBeforeDecoded
        let notAfterDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .notAfter)
        notAfter = notAfterDecoded
        let eligibleToRenewDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eligibleToRenew)
        eligibleToRenew = eligibleToRenewDecoded
        let renewalSummaryDecoded = try containerValues.decodeIfPresent(RenewalSummary.self, forKey: .renewalSummary)
        renewalSummary = renewalSummaryDecoded
        let revokedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .revokedAt)
        revokedAt = revokedAtDecoded
        let revocationReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .revocationReason)
        revocationReason = revocationReasonDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let supportCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .supportCode)
        supportCode = supportCodeDecoded
    }
}
