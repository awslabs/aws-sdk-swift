// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension Disk: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case addOns
        case arn
        case attachedTo
        case attachmentState
        case createdAt
        case gbInUse
        case iops
        case isAttached
        case isSystemDisk
        case location
        case name
        case path
        case resourceType
        case sizeInGb
        case state
        case supportCode
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addOns = addOns {
            var addOnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .addOns)
            for addonlist0 in addOns {
                try addOnsContainer.encode(addonlist0)
            }
        }
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let attachedTo = attachedTo {
            try encodeContainer.encode(attachedTo, forKey: .attachedTo)
        }
        if let attachmentState = attachmentState {
            try encodeContainer.encode(attachmentState, forKey: .attachmentState)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let gbInUse = gbInUse {
            try encodeContainer.encode(gbInUse, forKey: .gbInUse)
        }
        if let iops = iops {
            try encodeContainer.encode(iops, forKey: .iops)
        }
        if let isAttached = isAttached {
            try encodeContainer.encode(isAttached, forKey: .isAttached)
        }
        if let isSystemDisk = isSystemDisk {
            try encodeContainer.encode(isSystemDisk, forKey: .isSystemDisk)
        }
        if let location = location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let path = path {
            try encodeContainer.encode(path, forKey: .path)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
        if let sizeInGb = sizeInGb {
            try encodeContainer.encode(sizeInGb, forKey: .sizeInGb)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let supportCode = supportCode {
            try encodeContainer.encode(supportCode, forKey: .supportCode)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let supportCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .supportCode)
        supportCode = supportCodeDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let locationDecoded = try containerValues.decodeIfPresent(ResourceLocation.self, forKey: .location)
        location = locationDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let addOnsContainer = try containerValues.decodeIfPresent([AddOn?].self, forKey: .addOns)
        var addOnsDecoded0:[AddOn]? = nil
        if let addOnsContainer = addOnsContainer {
            addOnsDecoded0 = [AddOn]()
            for structure0 in addOnsContainer {
                if let structure0 = structure0 {
                    addOnsDecoded0?.append(structure0)
                }
            }
        }
        addOns = addOnsDecoded0
        let sizeInGbDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .sizeInGb)
        sizeInGb = sizeInGbDecoded
        let isSystemDiskDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .isSystemDisk)
        isSystemDisk = isSystemDiskDecoded
        let iopsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .iops)
        iops = iopsDecoded
        let pathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .path)
        path = pathDecoded
        let stateDecoded = try containerValues.decodeIfPresent(DiskState.self, forKey: .state)
        state = stateDecoded
        let attachedToDecoded = try containerValues.decodeIfPresent(String.self, forKey: .attachedTo)
        attachedTo = attachedToDecoded
        let isAttachedDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .isAttached)
        isAttached = isAttachedDecoded
        let attachmentStateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .attachmentState)
        attachmentState = attachmentStateDecoded
        let gbInUseDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .gbInUse)
        gbInUse = gbInUseDecoded
    }
}
