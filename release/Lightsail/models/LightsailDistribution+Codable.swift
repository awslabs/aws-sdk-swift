// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension LightsailDistribution: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case ableToUpdateBundle
        case alternativeDomainNames
        case arn
        case bundleId
        case cacheBehaviorSettings
        case cacheBehaviors
        case certificateName
        case createdAt
        case defaultCacheBehavior
        case domainName
        case ipAddressType
        case isEnabled
        case location
        case name
        case origin
        case originPublicDNS
        case resourceType
        case status
        case supportCode
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ableToUpdateBundle = ableToUpdateBundle {
            try encodeContainer.encode(ableToUpdateBundle, forKey: .ableToUpdateBundle)
        }
        if let alternativeDomainNames = alternativeDomainNames {
            var alternativeDomainNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .alternativeDomainNames)
            for stringlist0 in alternativeDomainNames {
                try alternativeDomainNamesContainer.encode(stringlist0)
            }
        }
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let bundleId = bundleId {
            try encodeContainer.encode(bundleId, forKey: .bundleId)
        }
        if let cacheBehaviorSettings = cacheBehaviorSettings {
            try encodeContainer.encode(cacheBehaviorSettings, forKey: .cacheBehaviorSettings)
        }
        if let cacheBehaviors = cacheBehaviors {
            var cacheBehaviorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .cacheBehaviors)
            for cachebehaviorlist0 in cacheBehaviors {
                try cacheBehaviorsContainer.encode(cachebehaviorlist0)
            }
        }
        if let certificateName = certificateName {
            try encodeContainer.encode(certificateName, forKey: .certificateName)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let defaultCacheBehavior = defaultCacheBehavior {
            try encodeContainer.encode(defaultCacheBehavior, forKey: .defaultCacheBehavior)
        }
        if let domainName = domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let ipAddressType = ipAddressType {
            try encodeContainer.encode(ipAddressType.rawValue, forKey: .ipAddressType)
        }
        if let isEnabled = isEnabled {
            try encodeContainer.encode(isEnabled, forKey: .isEnabled)
        }
        if let location = location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let origin = origin {
            try encodeContainer.encode(origin, forKey: .origin)
        }
        if let originPublicDNS = originPublicDNS {
            try encodeContainer.encode(originPublicDNS, forKey: .originPublicDNS)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let supportCode = supportCode {
            try encodeContainer.encode(supportCode, forKey: .supportCode)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let supportCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .supportCode)
        supportCode = supportCodeDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let locationDecoded = try containerValues.decodeIfPresent(ResourceLocation.self, forKey: .location)
        location = locationDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let alternativeDomainNamesContainer = try containerValues.decodeIfPresent([String].self, forKey: .alternativeDomainNames)
        var alternativeDomainNamesDecoded0:[String]? = nil
        if let alternativeDomainNamesContainer = alternativeDomainNamesContainer {
            alternativeDomainNamesDecoded0 = [String]()
            for string0 in alternativeDomainNamesContainer {
                alternativeDomainNamesDecoded0?.append(string0)
            }
        }
        alternativeDomainNames = alternativeDomainNamesDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let isEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .isEnabled)
        isEnabled = isEnabledDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let bundleIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bundleId)
        bundleId = bundleIdDecoded
        let certificateNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificateName)
        certificateName = certificateNameDecoded
        let originDecoded = try containerValues.decodeIfPresent(Origin.self, forKey: .origin)
        origin = originDecoded
        let originPublicDNSDecoded = try containerValues.decodeIfPresent(String.self, forKey: .originPublicDNS)
        originPublicDNS = originPublicDNSDecoded
        let defaultCacheBehaviorDecoded = try containerValues.decodeIfPresent(CacheBehavior.self, forKey: .defaultCacheBehavior)
        defaultCacheBehavior = defaultCacheBehaviorDecoded
        let cacheBehaviorSettingsDecoded = try containerValues.decodeIfPresent(CacheSettings.self, forKey: .cacheBehaviorSettings)
        cacheBehaviorSettings = cacheBehaviorSettingsDecoded
        let cacheBehaviorsContainer = try containerValues.decodeIfPresent([CacheBehaviorPerPath].self, forKey: .cacheBehaviors)
        var cacheBehaviorsDecoded0:[CacheBehaviorPerPath]? = nil
        if let cacheBehaviorsContainer = cacheBehaviorsContainer {
            cacheBehaviorsDecoded0 = [CacheBehaviorPerPath]()
            for structure0 in cacheBehaviorsContainer {
                cacheBehaviorsDecoded0?.append(structure0)
            }
        }
        cacheBehaviors = cacheBehaviorsDecoded0
        let ableToUpdateBundleDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .ableToUpdateBundle)
        ableToUpdateBundle = ableToUpdateBundleDecoded
        let ipAddressTypeDecoded = try containerValues.decodeIfPresent(IpAddressType.self, forKey: .ipAddressType)
        ipAddressType = ipAddressTypeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                tagsDecoded0?.append(structure0)
            }
        }
        tags = tagsDecoded0
    }
}
