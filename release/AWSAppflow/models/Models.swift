// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AppflowClientTypes.AggregationConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aggregationType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aggregationType = aggregationType {
            try encodeContainer.encode(aggregationType.rawValue, forKey: .aggregationType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aggregationTypeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.AggregationType.self, forKey: .aggregationType)
        aggregationType = aggregationTypeDecoded
    }
}

extension AppflowClientTypes {
    /// The aggregation settings that you can use to customize the output format of your flow data.
    public struct AggregationConfig: Swift.Equatable {
        /// Specifies whether Amazon AppFlow aggregates the flow records into a single file, or leave them unaggregated.
        public var aggregationType: AppflowClientTypes.AggregationType?

        public init (
            aggregationType: AppflowClientTypes.AggregationType? = nil
        )
        {
            self.aggregationType = aggregationType
        }
    }

}

extension AppflowClientTypes {
    public enum AggregationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `none`
        case singleFile
        case sdkUnknown(Swift.String)

        public static var allCases: [AggregationType] {
            return [
                .none,
                .singleFile,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .none: return "None"
            case .singleFile: return "SingleFile"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AggregationType(rawValue: rawValue) ?? AggregationType.sdkUnknown(rawValue)
        }
    }
}

extension AppflowClientTypes {
    public enum AmplitudeConnectorOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case between
        case sdkUnknown(Swift.String)

        public static var allCases: [AmplitudeConnectorOperator] {
            return [
                .between,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .between: return "BETWEEN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AmplitudeConnectorOperator(rawValue: rawValue) ?? AmplitudeConnectorOperator.sdkUnknown(rawValue)
        }
    }
}

extension AppflowClientTypes.AmplitudeConnectorProfileCredentials: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiKey
        case secretKey
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiKey = apiKey {
            try encodeContainer.encode(apiKey, forKey: .apiKey)
        }
        if let secretKey = secretKey {
            try encodeContainer.encode(secretKey, forKey: .secretKey)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiKey)
        apiKey = apiKeyDecoded
        let secretKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretKey)
        secretKey = secretKeyDecoded
    }
}

extension AppflowClientTypes {
    /// The connector-specific credentials required when using Amplitude.
    public struct AmplitudeConnectorProfileCredentials: Swift.Equatable {
        /// A unique alphanumeric identifier used to authenticate a user, developer, or calling program to your API.
        /// This member is required.
        public var apiKey: Swift.String?
        /// The Secret Access Key portion of the credentials.
        /// This member is required.
        public var secretKey: Swift.String?

        public init (
            apiKey: Swift.String? = nil,
            secretKey: Swift.String? = nil
        )
        {
            self.apiKey = apiKey
            self.secretKey = secretKey
        }
    }

}

extension AppflowClientTypes.AmplitudeConnectorProfileProperties: Swift.Codable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension AppflowClientTypes {
    /// The connector-specific profile properties required when using Amplitude.
    public struct AmplitudeConnectorProfileProperties: Swift.Equatable {

    }

}

extension AppflowClientTypes.AmplitudeMetadata: Swift.Codable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension AppflowClientTypes {
    /// The connector metadata specific to Amplitude.
    public struct AmplitudeMetadata: Swift.Equatable {

    }

}

extension AppflowClientTypes.AmplitudeSourceProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case object
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let object = object {
            try encodeContainer.encode(object, forKey: .object)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .object)
        object = objectDecoded
    }
}

extension AppflowClientTypes {
    /// The properties that are applied when Amplitude is being used as a source.
    public struct AmplitudeSourceProperties: Swift.Equatable {
        /// The object specified in the Amplitude flow source.
        /// This member is required.
        public var object: Swift.String?

        public init (
            object: Swift.String? = nil
        )
        {
            self.object = object
        }
    }

}

extension AppflowClientTypes.BasicAuthCredentials: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case password
        case username
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let password = password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let username = username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .username)
        username = usernameDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .password)
        password = passwordDecoded
    }
}

extension AppflowClientTypes {
    /// The basic auth credentials required for basic authentication.
    public struct BasicAuthCredentials: Swift.Equatable {
        /// The password to use to connect to a resource.
        /// This member is required.
        public var password: Swift.String?
        /// The username to use to connect to a resource.
        /// This member is required.
        public var username: Swift.String?

        public init (
            password: Swift.String? = nil,
            username: Swift.String? = nil
        )
        {
            self.password = password
            self.username = username
        }
    }

}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// There was a conflict when processing the request (for example, a flow with the given name already exists within the account. Check for conflicting resource names and try again.
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AppflowClientTypes {
    public enum ConnectionMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `private`
        case `public`
        case sdkUnknown(Swift.String)

        public static var allCases: [ConnectionMode] {
            return [
                .private,
                .public,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .private: return "Private"
            case .public: return "Public"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConnectionMode(rawValue: rawValue) ?? ConnectionMode.sdkUnknown(rawValue)
        }
    }
}

extension ConnectorAuthenticationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConnectorAuthenticationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An error occurred when authenticating with the connector endpoint.
public struct ConnectorAuthenticationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ConnectorAuthenticationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConnectorAuthenticationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AppflowClientTypes.ConnectorConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case canUseAsDestination
        case canUseAsSource
        case connectorMetadata
        case isPrivateLinkEnabled
        case isPrivateLinkEndpointUrlRequired
        case supportedDestinationConnectors
        case supportedSchedulingFrequencies
        case supportedTriggerTypes
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if canUseAsDestination != false {
            try encodeContainer.encode(canUseAsDestination, forKey: .canUseAsDestination)
        }
        if canUseAsSource != false {
            try encodeContainer.encode(canUseAsSource, forKey: .canUseAsSource)
        }
        if let connectorMetadata = connectorMetadata {
            try encodeContainer.encode(connectorMetadata, forKey: .connectorMetadata)
        }
        if isPrivateLinkEnabled != false {
            try encodeContainer.encode(isPrivateLinkEnabled, forKey: .isPrivateLinkEnabled)
        }
        if isPrivateLinkEndpointUrlRequired != false {
            try encodeContainer.encode(isPrivateLinkEndpointUrlRequired, forKey: .isPrivateLinkEndpointUrlRequired)
        }
        if let supportedDestinationConnectors = supportedDestinationConnectors {
            var supportedDestinationConnectorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .supportedDestinationConnectors)
            for connectortypelist0 in supportedDestinationConnectors {
                try supportedDestinationConnectorsContainer.encode(connectortypelist0.rawValue)
            }
        }
        if let supportedSchedulingFrequencies = supportedSchedulingFrequencies {
            var supportedSchedulingFrequenciesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .supportedSchedulingFrequencies)
            for schedulingfrequencytypelist0 in supportedSchedulingFrequencies {
                try supportedSchedulingFrequenciesContainer.encode(schedulingfrequencytypelist0.rawValue)
            }
        }
        if let supportedTriggerTypes = supportedTriggerTypes {
            var supportedTriggerTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .supportedTriggerTypes)
            for triggertypelist0 in supportedTriggerTypes {
                try supportedTriggerTypesContainer.encode(triggertypelist0.rawValue)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let canUseAsSourceDecoded = try containerValues.decode(Swift.Bool.self, forKey: .canUseAsSource)
        canUseAsSource = canUseAsSourceDecoded
        let canUseAsDestinationDecoded = try containerValues.decode(Swift.Bool.self, forKey: .canUseAsDestination)
        canUseAsDestination = canUseAsDestinationDecoded
        let supportedDestinationConnectorsContainer = try containerValues.decodeIfPresent([AppflowClientTypes.ConnectorType?].self, forKey: .supportedDestinationConnectors)
        var supportedDestinationConnectorsDecoded0:[AppflowClientTypes.ConnectorType]? = nil
        if let supportedDestinationConnectorsContainer = supportedDestinationConnectorsContainer {
            supportedDestinationConnectorsDecoded0 = [AppflowClientTypes.ConnectorType]()
            for string0 in supportedDestinationConnectorsContainer {
                if let string0 = string0 {
                    supportedDestinationConnectorsDecoded0?.append(string0)
                }
            }
        }
        supportedDestinationConnectors = supportedDestinationConnectorsDecoded0
        let supportedSchedulingFrequenciesContainer = try containerValues.decodeIfPresent([AppflowClientTypes.ScheduleFrequencyType?].self, forKey: .supportedSchedulingFrequencies)
        var supportedSchedulingFrequenciesDecoded0:[AppflowClientTypes.ScheduleFrequencyType]? = nil
        if let supportedSchedulingFrequenciesContainer = supportedSchedulingFrequenciesContainer {
            supportedSchedulingFrequenciesDecoded0 = [AppflowClientTypes.ScheduleFrequencyType]()
            for string0 in supportedSchedulingFrequenciesContainer {
                if let string0 = string0 {
                    supportedSchedulingFrequenciesDecoded0?.append(string0)
                }
            }
        }
        supportedSchedulingFrequencies = supportedSchedulingFrequenciesDecoded0
        let isPrivateLinkEnabledDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isPrivateLinkEnabled)
        isPrivateLinkEnabled = isPrivateLinkEnabledDecoded
        let isPrivateLinkEndpointUrlRequiredDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isPrivateLinkEndpointUrlRequired)
        isPrivateLinkEndpointUrlRequired = isPrivateLinkEndpointUrlRequiredDecoded
        let supportedTriggerTypesContainer = try containerValues.decodeIfPresent([AppflowClientTypes.TriggerType?].self, forKey: .supportedTriggerTypes)
        var supportedTriggerTypesDecoded0:[AppflowClientTypes.TriggerType]? = nil
        if let supportedTriggerTypesContainer = supportedTriggerTypesContainer {
            supportedTriggerTypesDecoded0 = [AppflowClientTypes.TriggerType]()
            for string0 in supportedTriggerTypesContainer {
                if let string0 = string0 {
                    supportedTriggerTypesDecoded0?.append(string0)
                }
            }
        }
        supportedTriggerTypes = supportedTriggerTypesDecoded0
        let connectorMetadataDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ConnectorMetadata.self, forKey: .connectorMetadata)
        connectorMetadata = connectorMetadataDecoded
    }
}

extension AppflowClientTypes {
    /// The configuration settings related to a given connector.
    public struct ConnectorConfiguration: Swift.Equatable {
        /// Specifies whether the connector can be used as a destination.
        public var canUseAsDestination: Swift.Bool
        /// Specifies whether the connector can be used as a source.
        public var canUseAsSource: Swift.Bool
        /// Specifies connector-specific metadata such as oAuthScopes, supportedRegions, privateLinkServiceUrl, and so on.
        public var connectorMetadata: AppflowClientTypes.ConnectorMetadata?
        /// Specifies if PrivateLink is enabled for that connector.
        public var isPrivateLinkEnabled: Swift.Bool
        /// Specifies if a PrivateLink endpoint URL is required.
        public var isPrivateLinkEndpointUrlRequired: Swift.Bool
        /// Lists the connectors that are available for use as destinations.
        public var supportedDestinationConnectors: [AppflowClientTypes.ConnectorType]?
        /// Specifies the supported flow frequency for that connector.
        public var supportedSchedulingFrequencies: [AppflowClientTypes.ScheduleFrequencyType]?
        /// Specifies the supported trigger types for the flow.
        public var supportedTriggerTypes: [AppflowClientTypes.TriggerType]?

        public init (
            canUseAsDestination: Swift.Bool = false,
            canUseAsSource: Swift.Bool = false,
            connectorMetadata: AppflowClientTypes.ConnectorMetadata? = nil,
            isPrivateLinkEnabled: Swift.Bool = false,
            isPrivateLinkEndpointUrlRequired: Swift.Bool = false,
            supportedDestinationConnectors: [AppflowClientTypes.ConnectorType]? = nil,
            supportedSchedulingFrequencies: [AppflowClientTypes.ScheduleFrequencyType]? = nil,
            supportedTriggerTypes: [AppflowClientTypes.TriggerType]? = nil
        )
        {
            self.canUseAsDestination = canUseAsDestination
            self.canUseAsSource = canUseAsSource
            self.connectorMetadata = connectorMetadata
            self.isPrivateLinkEnabled = isPrivateLinkEnabled
            self.isPrivateLinkEndpointUrlRequired = isPrivateLinkEndpointUrlRequired
            self.supportedDestinationConnectors = supportedDestinationConnectors
            self.supportedSchedulingFrequencies = supportedSchedulingFrequencies
            self.supportedTriggerTypes = supportedTriggerTypes
        }
    }

}

extension AppflowClientTypes.ConnectorEntity: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hasNestedEntities
        case label
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if hasNestedEntities != false {
            try encodeContainer.encode(hasNestedEntities, forKey: .hasNestedEntities)
        }
        if let label = label {
            try encodeContainer.encode(label, forKey: .label)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let labelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .label)
        label = labelDecoded
        let hasNestedEntitiesDecoded = try containerValues.decode(Swift.Bool.self, forKey: .hasNestedEntities)
        hasNestedEntities = hasNestedEntitiesDecoded
    }
}

extension AppflowClientTypes {
    /// The high-level entity that can be queried in Amazon AppFlow. For example, a Salesforce entity might be an Account or Opportunity, whereas a ServiceNow entity might be an Incident.
    public struct ConnectorEntity: Swift.Equatable {
        /// Specifies whether the connector entity is a parent or a category and has more entities nested underneath it. If another call is made with entitiesPath = "the_current_entity_name_with_hasNestedEntities_true", then it returns the nested entities underneath it. This provides a way to retrieve all supported entities in a recursive fashion.
        public var hasNestedEntities: Swift.Bool
        /// The label applied to the connector entity.
        public var label: Swift.String?
        /// The name of the connector entity.
        /// This member is required.
        public var name: Swift.String?

        public init (
            hasNestedEntities: Swift.Bool = false,
            label: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.hasNestedEntities = hasNestedEntities
            self.label = label
            self.name = name
        }
    }

}

extension AppflowClientTypes.ConnectorEntityField: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case destinationProperties
        case identifier
        case label
        case sourceProperties
        case supportedFieldTypeDetails
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let destinationProperties = destinationProperties {
            try encodeContainer.encode(destinationProperties, forKey: .destinationProperties)
        }
        if let identifier = identifier {
            try encodeContainer.encode(identifier, forKey: .identifier)
        }
        if let label = label {
            try encodeContainer.encode(label, forKey: .label)
        }
        if let sourceProperties = sourceProperties {
            try encodeContainer.encode(sourceProperties, forKey: .sourceProperties)
        }
        if let supportedFieldTypeDetails = supportedFieldTypeDetails {
            try encodeContainer.encode(supportedFieldTypeDetails, forKey: .supportedFieldTypeDetails)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identifier)
        identifier = identifierDecoded
        let labelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .label)
        label = labelDecoded
        let supportedFieldTypeDetailsDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.SupportedFieldTypeDetails.self, forKey: .supportedFieldTypeDetails)
        supportedFieldTypeDetails = supportedFieldTypeDetailsDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let sourcePropertiesDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.SourceFieldProperties.self, forKey: .sourceProperties)
        sourceProperties = sourcePropertiesDecoded
        let destinationPropertiesDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.DestinationFieldProperties.self, forKey: .destinationProperties)
        destinationProperties = destinationPropertiesDecoded
    }
}

extension AppflowClientTypes {
    /// Describes the data model of a connector field. For example, for an account entity, the fields would be account name, account ID, and so on.
    public struct ConnectorEntityField: Swift.Equatable {
        /// A description of the connector entity field.
        public var description: Swift.String?
        /// The properties applied to a field when the connector is being used as a destination.
        public var destinationProperties: AppflowClientTypes.DestinationFieldProperties?
        /// The unique identifier of the connector field.
        /// This member is required.
        public var identifier: Swift.String?
        /// The label applied to a connector entity field.
        public var label: Swift.String?
        /// The properties that can be applied to a field when the connector is being used as a source.
        public var sourceProperties: AppflowClientTypes.SourceFieldProperties?
        /// Contains details regarding the supported FieldType, including the corresponding filterOperators and supportedValues.
        public var supportedFieldTypeDetails: AppflowClientTypes.SupportedFieldTypeDetails?

        public init (
            description: Swift.String? = nil,
            destinationProperties: AppflowClientTypes.DestinationFieldProperties? = nil,
            identifier: Swift.String? = nil,
            label: Swift.String? = nil,
            sourceProperties: AppflowClientTypes.SourceFieldProperties? = nil,
            supportedFieldTypeDetails: AppflowClientTypes.SupportedFieldTypeDetails? = nil
        )
        {
            self.description = description
            self.destinationProperties = destinationProperties
            self.identifier = identifier
            self.label = label
            self.sourceProperties = sourceProperties
            self.supportedFieldTypeDetails = supportedFieldTypeDetails
        }
    }

}

extension AppflowClientTypes.ConnectorMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amplitude = "Amplitude"
        case customerProfiles = "CustomerProfiles"
        case datadog = "Datadog"
        case dynatrace = "Dynatrace"
        case eventBridge = "EventBridge"
        case googleAnalytics = "GoogleAnalytics"
        case honeycode = "Honeycode"
        case inforNexus = "InforNexus"
        case marketo = "Marketo"
        case redshift = "Redshift"
        case s3 = "S3"
        case sAPOData = "SAPOData"
        case salesforce = "Salesforce"
        case serviceNow = "ServiceNow"
        case singular = "Singular"
        case slack = "Slack"
        case snowflake = "Snowflake"
        case trendmicro = "Trendmicro"
        case upsolver = "Upsolver"
        case veeva = "Veeva"
        case zendesk = "Zendesk"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amplitude = amplitude {
            try encodeContainer.encode(amplitude, forKey: .amplitude)
        }
        if let customerProfiles = customerProfiles {
            try encodeContainer.encode(customerProfiles, forKey: .customerProfiles)
        }
        if let datadog = datadog {
            try encodeContainer.encode(datadog, forKey: .datadog)
        }
        if let dynatrace = dynatrace {
            try encodeContainer.encode(dynatrace, forKey: .dynatrace)
        }
        if let eventBridge = eventBridge {
            try encodeContainer.encode(eventBridge, forKey: .eventBridge)
        }
        if let googleAnalytics = googleAnalytics {
            try encodeContainer.encode(googleAnalytics, forKey: .googleAnalytics)
        }
        if let honeycode = honeycode {
            try encodeContainer.encode(honeycode, forKey: .honeycode)
        }
        if let inforNexus = inforNexus {
            try encodeContainer.encode(inforNexus, forKey: .inforNexus)
        }
        if let marketo = marketo {
            try encodeContainer.encode(marketo, forKey: .marketo)
        }
        if let redshift = redshift {
            try encodeContainer.encode(redshift, forKey: .redshift)
        }
        if let s3 = s3 {
            try encodeContainer.encode(s3, forKey: .s3)
        }
        if let sAPOData = sAPOData {
            try encodeContainer.encode(sAPOData, forKey: .sAPOData)
        }
        if let salesforce = salesforce {
            try encodeContainer.encode(salesforce, forKey: .salesforce)
        }
        if let serviceNow = serviceNow {
            try encodeContainer.encode(serviceNow, forKey: .serviceNow)
        }
        if let singular = singular {
            try encodeContainer.encode(singular, forKey: .singular)
        }
        if let slack = slack {
            try encodeContainer.encode(slack, forKey: .slack)
        }
        if let snowflake = snowflake {
            try encodeContainer.encode(snowflake, forKey: .snowflake)
        }
        if let trendmicro = trendmicro {
            try encodeContainer.encode(trendmicro, forKey: .trendmicro)
        }
        if let upsolver = upsolver {
            try encodeContainer.encode(upsolver, forKey: .upsolver)
        }
        if let veeva = veeva {
            try encodeContainer.encode(veeva, forKey: .veeva)
        }
        if let zendesk = zendesk {
            try encodeContainer.encode(zendesk, forKey: .zendesk)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let amplitudeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.AmplitudeMetadata.self, forKey: .amplitude)
        amplitude = amplitudeDecoded
        let datadogDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.DatadogMetadata.self, forKey: .datadog)
        datadog = datadogDecoded
        let dynatraceDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.DynatraceMetadata.self, forKey: .dynatrace)
        dynatrace = dynatraceDecoded
        let googleAnalyticsDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.GoogleAnalyticsMetadata.self, forKey: .googleAnalytics)
        googleAnalytics = googleAnalyticsDecoded
        let inforNexusDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.InforNexusMetadata.self, forKey: .inforNexus)
        inforNexus = inforNexusDecoded
        let marketoDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.MarketoMetadata.self, forKey: .marketo)
        marketo = marketoDecoded
        let redshiftDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.RedshiftMetadata.self, forKey: .redshift)
        redshift = redshiftDecoded
        let s3Decoded = try containerValues.decodeIfPresent(AppflowClientTypes.S3Metadata.self, forKey: .s3)
        s3 = s3Decoded
        let salesforceDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.SalesforceMetadata.self, forKey: .salesforce)
        salesforce = salesforceDecoded
        let serviceNowDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ServiceNowMetadata.self, forKey: .serviceNow)
        serviceNow = serviceNowDecoded
        let singularDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.SingularMetadata.self, forKey: .singular)
        singular = singularDecoded
        let slackDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.SlackMetadata.self, forKey: .slack)
        slack = slackDecoded
        let snowflakeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.SnowflakeMetadata.self, forKey: .snowflake)
        snowflake = snowflakeDecoded
        let trendmicroDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.TrendmicroMetadata.self, forKey: .trendmicro)
        trendmicro = trendmicroDecoded
        let veevaDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.VeevaMetadata.self, forKey: .veeva)
        veeva = veevaDecoded
        let zendeskDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ZendeskMetadata.self, forKey: .zendesk)
        zendesk = zendeskDecoded
        let eventBridgeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.EventBridgeMetadata.self, forKey: .eventBridge)
        eventBridge = eventBridgeDecoded
        let upsolverDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.UpsolverMetadata.self, forKey: .upsolver)
        upsolver = upsolverDecoded
        let customerProfilesDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.CustomerProfilesMetadata.self, forKey: .customerProfiles)
        customerProfiles = customerProfilesDecoded
        let honeycodeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.HoneycodeMetadata.self, forKey: .honeycode)
        honeycode = honeycodeDecoded
        let sAPODataDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.SAPODataMetadata.self, forKey: .sAPOData)
        sAPOData = sAPODataDecoded
    }
}

extension AppflowClientTypes {
    /// A structure to specify connector-specific metadata such as oAuthScopes, supportedRegions, privateLinkServiceUrl, and so on.
    public struct ConnectorMetadata: Swift.Equatable {
        /// The connector metadata specific to Amplitude.
        public var amplitude: AppflowClientTypes.AmplitudeMetadata?
        /// The connector metadata specific to Amazon Connect Customer Profiles.
        public var customerProfiles: AppflowClientTypes.CustomerProfilesMetadata?
        /// The connector metadata specific to Datadog.
        public var datadog: AppflowClientTypes.DatadogMetadata?
        /// The connector metadata specific to Dynatrace.
        public var dynatrace: AppflowClientTypes.DynatraceMetadata?
        /// The connector metadata specific to Amazon EventBridge.
        public var eventBridge: AppflowClientTypes.EventBridgeMetadata?
        /// The connector metadata specific to Google Analytics.
        public var googleAnalytics: AppflowClientTypes.GoogleAnalyticsMetadata?
        /// The connector metadata specific to Amazon Honeycode.
        public var honeycode: AppflowClientTypes.HoneycodeMetadata?
        /// The connector metadata specific to Infor Nexus.
        public var inforNexus: AppflowClientTypes.InforNexusMetadata?
        /// The connector metadata specific to Marketo.
        public var marketo: AppflowClientTypes.MarketoMetadata?
        /// The connector metadata specific to Amazon Redshift.
        public var redshift: AppflowClientTypes.RedshiftMetadata?
        /// The connector metadata specific to Amazon S3.
        public var s3: AppflowClientTypes.S3Metadata?
        /// The connector metadata specific to SAPOData.
        public var sAPOData: AppflowClientTypes.SAPODataMetadata?
        /// The connector metadata specific to Salesforce.
        public var salesforce: AppflowClientTypes.SalesforceMetadata?
        /// The connector metadata specific to ServiceNow.
        public var serviceNow: AppflowClientTypes.ServiceNowMetadata?
        /// The connector metadata specific to Singular.
        public var singular: AppflowClientTypes.SingularMetadata?
        /// The connector metadata specific to Slack.
        public var slack: AppflowClientTypes.SlackMetadata?
        /// The connector metadata specific to Snowflake.
        public var snowflake: AppflowClientTypes.SnowflakeMetadata?
        /// The connector metadata specific to Trend Micro.
        public var trendmicro: AppflowClientTypes.TrendmicroMetadata?
        /// The connector metadata specific to Upsolver.
        public var upsolver: AppflowClientTypes.UpsolverMetadata?
        /// The connector metadata specific to Veeva.
        public var veeva: AppflowClientTypes.VeevaMetadata?
        /// The connector metadata specific to Zendesk.
        public var zendesk: AppflowClientTypes.ZendeskMetadata?

        public init (
            amplitude: AppflowClientTypes.AmplitudeMetadata? = nil,
            customerProfiles: AppflowClientTypes.CustomerProfilesMetadata? = nil,
            datadog: AppflowClientTypes.DatadogMetadata? = nil,
            dynatrace: AppflowClientTypes.DynatraceMetadata? = nil,
            eventBridge: AppflowClientTypes.EventBridgeMetadata? = nil,
            googleAnalytics: AppflowClientTypes.GoogleAnalyticsMetadata? = nil,
            honeycode: AppflowClientTypes.HoneycodeMetadata? = nil,
            inforNexus: AppflowClientTypes.InforNexusMetadata? = nil,
            marketo: AppflowClientTypes.MarketoMetadata? = nil,
            redshift: AppflowClientTypes.RedshiftMetadata? = nil,
            s3: AppflowClientTypes.S3Metadata? = nil,
            sAPOData: AppflowClientTypes.SAPODataMetadata? = nil,
            salesforce: AppflowClientTypes.SalesforceMetadata? = nil,
            serviceNow: AppflowClientTypes.ServiceNowMetadata? = nil,
            singular: AppflowClientTypes.SingularMetadata? = nil,
            slack: AppflowClientTypes.SlackMetadata? = nil,
            snowflake: AppflowClientTypes.SnowflakeMetadata? = nil,
            trendmicro: AppflowClientTypes.TrendmicroMetadata? = nil,
            upsolver: AppflowClientTypes.UpsolverMetadata? = nil,
            veeva: AppflowClientTypes.VeevaMetadata? = nil,
            zendesk: AppflowClientTypes.ZendeskMetadata? = nil
        )
        {
            self.amplitude = amplitude
            self.customerProfiles = customerProfiles
            self.datadog = datadog
            self.dynatrace = dynatrace
            self.eventBridge = eventBridge
            self.googleAnalytics = googleAnalytics
            self.honeycode = honeycode
            self.inforNexus = inforNexus
            self.marketo = marketo
            self.redshift = redshift
            self.s3 = s3
            self.sAPOData = sAPOData
            self.salesforce = salesforce
            self.serviceNow = serviceNow
            self.singular = singular
            self.slack = slack
            self.snowflake = snowflake
            self.trendmicro = trendmicro
            self.upsolver = upsolver
            self.veeva = veeva
            self.zendesk = zendesk
        }
    }

}

extension AppflowClientTypes.ConnectorOAuthRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authCode
        case redirectUri
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authCode = authCode {
            try encodeContainer.encode(authCode, forKey: .authCode)
        }
        if let redirectUri = redirectUri {
            try encodeContainer.encode(redirectUri, forKey: .redirectUri)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authCode)
        authCode = authCodeDecoded
        let redirectUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .redirectUri)
        redirectUri = redirectUriDecoded
    }
}

extension AppflowClientTypes {
    /// Used by select connectors for which the OAuth workflow is supported, such as Salesforce, Google Analytics, Marketo, Zendesk, and Slack.
    public struct ConnectorOAuthRequest: Swift.Equatable {
        /// The code provided by the connector when it has been authenticated via the connected app.
        public var authCode: Swift.String?
        /// The URL to which the authentication server redirects the browser after authorization has been granted.
        public var redirectUri: Swift.String?

        public init (
            authCode: Swift.String? = nil,
            redirectUri: Swift.String? = nil
        )
        {
            self.authCode = authCode
            self.redirectUri = redirectUri
        }
    }

}

extension AppflowClientTypes.ConnectorOperator: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amplitude = "Amplitude"
        case datadog = "Datadog"
        case dynatrace = "Dynatrace"
        case googleAnalytics = "GoogleAnalytics"
        case inforNexus = "InforNexus"
        case marketo = "Marketo"
        case s3 = "S3"
        case sAPOData = "SAPOData"
        case salesforce = "Salesforce"
        case serviceNow = "ServiceNow"
        case singular = "Singular"
        case slack = "Slack"
        case trendmicro = "Trendmicro"
        case veeva = "Veeva"
        case zendesk = "Zendesk"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amplitude = amplitude {
            try encodeContainer.encode(amplitude.rawValue, forKey: .amplitude)
        }
        if let datadog = datadog {
            try encodeContainer.encode(datadog.rawValue, forKey: .datadog)
        }
        if let dynatrace = dynatrace {
            try encodeContainer.encode(dynatrace.rawValue, forKey: .dynatrace)
        }
        if let googleAnalytics = googleAnalytics {
            try encodeContainer.encode(googleAnalytics.rawValue, forKey: .googleAnalytics)
        }
        if let inforNexus = inforNexus {
            try encodeContainer.encode(inforNexus.rawValue, forKey: .inforNexus)
        }
        if let marketo = marketo {
            try encodeContainer.encode(marketo.rawValue, forKey: .marketo)
        }
        if let s3 = s3 {
            try encodeContainer.encode(s3.rawValue, forKey: .s3)
        }
        if let sAPOData = sAPOData {
            try encodeContainer.encode(sAPOData.rawValue, forKey: .sAPOData)
        }
        if let salesforce = salesforce {
            try encodeContainer.encode(salesforce.rawValue, forKey: .salesforce)
        }
        if let serviceNow = serviceNow {
            try encodeContainer.encode(serviceNow.rawValue, forKey: .serviceNow)
        }
        if let singular = singular {
            try encodeContainer.encode(singular.rawValue, forKey: .singular)
        }
        if let slack = slack {
            try encodeContainer.encode(slack.rawValue, forKey: .slack)
        }
        if let trendmicro = trendmicro {
            try encodeContainer.encode(trendmicro.rawValue, forKey: .trendmicro)
        }
        if let veeva = veeva {
            try encodeContainer.encode(veeva.rawValue, forKey: .veeva)
        }
        if let zendesk = zendesk {
            try encodeContainer.encode(zendesk.rawValue, forKey: .zendesk)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let amplitudeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.AmplitudeConnectorOperator.self, forKey: .amplitude)
        amplitude = amplitudeDecoded
        let datadogDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.DatadogConnectorOperator.self, forKey: .datadog)
        datadog = datadogDecoded
        let dynatraceDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.DynatraceConnectorOperator.self, forKey: .dynatrace)
        dynatrace = dynatraceDecoded
        let googleAnalyticsDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.GoogleAnalyticsConnectorOperator.self, forKey: .googleAnalytics)
        googleAnalytics = googleAnalyticsDecoded
        let inforNexusDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.InforNexusConnectorOperator.self, forKey: .inforNexus)
        inforNexus = inforNexusDecoded
        let marketoDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.MarketoConnectorOperator.self, forKey: .marketo)
        marketo = marketoDecoded
        let s3Decoded = try containerValues.decodeIfPresent(AppflowClientTypes.S3ConnectorOperator.self, forKey: .s3)
        s3 = s3Decoded
        let salesforceDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.SalesforceConnectorOperator.self, forKey: .salesforce)
        salesforce = salesforceDecoded
        let serviceNowDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ServiceNowConnectorOperator.self, forKey: .serviceNow)
        serviceNow = serviceNowDecoded
        let singularDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.SingularConnectorOperator.self, forKey: .singular)
        singular = singularDecoded
        let slackDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.SlackConnectorOperator.self, forKey: .slack)
        slack = slackDecoded
        let trendmicroDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.TrendmicroConnectorOperator.self, forKey: .trendmicro)
        trendmicro = trendmicroDecoded
        let veevaDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.VeevaConnectorOperator.self, forKey: .veeva)
        veeva = veevaDecoded
        let zendeskDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ZendeskConnectorOperator.self, forKey: .zendesk)
        zendesk = zendeskDecoded
        let sAPODataDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.SAPODataConnectorOperator.self, forKey: .sAPOData)
        sAPOData = sAPODataDecoded
    }
}

extension AppflowClientTypes {
    /// The operation to be performed on the provided source fields.
    public struct ConnectorOperator: Swift.Equatable {
        /// The operation to be performed on the provided Amplitude source fields.
        public var amplitude: AppflowClientTypes.AmplitudeConnectorOperator?
        /// The operation to be performed on the provided Datadog source fields.
        public var datadog: AppflowClientTypes.DatadogConnectorOperator?
        /// The operation to be performed on the provided Dynatrace source fields.
        public var dynatrace: AppflowClientTypes.DynatraceConnectorOperator?
        /// The operation to be performed on the provided Google Analytics source fields.
        public var googleAnalytics: AppflowClientTypes.GoogleAnalyticsConnectorOperator?
        /// The operation to be performed on the provided Infor Nexus source fields.
        public var inforNexus: AppflowClientTypes.InforNexusConnectorOperator?
        /// The operation to be performed on the provided Marketo source fields.
        public var marketo: AppflowClientTypes.MarketoConnectorOperator?
        /// The operation to be performed on the provided Amazon S3 source fields.
        public var s3: AppflowClientTypes.S3ConnectorOperator?
        /// The operation to be performed on the provided SAPOData source fields.
        public var sAPOData: AppflowClientTypes.SAPODataConnectorOperator?
        /// The operation to be performed on the provided Salesforce source fields.
        public var salesforce: AppflowClientTypes.SalesforceConnectorOperator?
        /// The operation to be performed on the provided ServiceNow source fields.
        public var serviceNow: AppflowClientTypes.ServiceNowConnectorOperator?
        /// The operation to be performed on the provided Singular source fields.
        public var singular: AppflowClientTypes.SingularConnectorOperator?
        /// The operation to be performed on the provided Slack source fields.
        public var slack: AppflowClientTypes.SlackConnectorOperator?
        /// The operation to be performed on the provided Trend Micro source fields.
        public var trendmicro: AppflowClientTypes.TrendmicroConnectorOperator?
        /// The operation to be performed on the provided Veeva source fields.
        public var veeva: AppflowClientTypes.VeevaConnectorOperator?
        /// The operation to be performed on the provided Zendesk source fields.
        public var zendesk: AppflowClientTypes.ZendeskConnectorOperator?

        public init (
            amplitude: AppflowClientTypes.AmplitudeConnectorOperator? = nil,
            datadog: AppflowClientTypes.DatadogConnectorOperator? = nil,
            dynatrace: AppflowClientTypes.DynatraceConnectorOperator? = nil,
            googleAnalytics: AppflowClientTypes.GoogleAnalyticsConnectorOperator? = nil,
            inforNexus: AppflowClientTypes.InforNexusConnectorOperator? = nil,
            marketo: AppflowClientTypes.MarketoConnectorOperator? = nil,
            s3: AppflowClientTypes.S3ConnectorOperator? = nil,
            sAPOData: AppflowClientTypes.SAPODataConnectorOperator? = nil,
            salesforce: AppflowClientTypes.SalesforceConnectorOperator? = nil,
            serviceNow: AppflowClientTypes.ServiceNowConnectorOperator? = nil,
            singular: AppflowClientTypes.SingularConnectorOperator? = nil,
            slack: AppflowClientTypes.SlackConnectorOperator? = nil,
            trendmicro: AppflowClientTypes.TrendmicroConnectorOperator? = nil,
            veeva: AppflowClientTypes.VeevaConnectorOperator? = nil,
            zendesk: AppflowClientTypes.ZendeskConnectorOperator? = nil
        )
        {
            self.amplitude = amplitude
            self.datadog = datadog
            self.dynatrace = dynatrace
            self.googleAnalytics = googleAnalytics
            self.inforNexus = inforNexus
            self.marketo = marketo
            self.s3 = s3
            self.sAPOData = sAPOData
            self.salesforce = salesforce
            self.serviceNow = serviceNow
            self.singular = singular
            self.slack = slack
            self.trendmicro = trendmicro
            self.veeva = veeva
            self.zendesk = zendesk
        }
    }

}

extension AppflowClientTypes.ConnectorProfile: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionMode
        case connectorProfileArn
        case connectorProfileName
        case connectorProfileProperties
        case connectorType
        case createdAt
        case credentialsArn
        case lastUpdatedAt
        case privateConnectionProvisioningState
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionMode = connectionMode {
            try encodeContainer.encode(connectionMode.rawValue, forKey: .connectionMode)
        }
        if let connectorProfileArn = connectorProfileArn {
            try encodeContainer.encode(connectorProfileArn, forKey: .connectorProfileArn)
        }
        if let connectorProfileName = connectorProfileName {
            try encodeContainer.encode(connectorProfileName, forKey: .connectorProfileName)
        }
        if let connectorProfileProperties = connectorProfileProperties {
            try encodeContainer.encode(connectorProfileProperties, forKey: .connectorProfileProperties)
        }
        if let connectorType = connectorType {
            try encodeContainer.encode(connectorType.rawValue, forKey: .connectorType)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let credentialsArn = credentialsArn {
            try encodeContainer.encode(credentialsArn, forKey: .credentialsArn)
        }
        if let lastUpdatedAt = lastUpdatedAt {
            try encodeContainer.encode(lastUpdatedAt.timeIntervalSince1970, forKey: .lastUpdatedAt)
        }
        if let privateConnectionProvisioningState = privateConnectionProvisioningState {
            try encodeContainer.encode(privateConnectionProvisioningState, forKey: .privateConnectionProvisioningState)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorProfileArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectorProfileArn)
        connectorProfileArn = connectorProfileArnDecoded
        let connectorProfileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectorProfileName)
        connectorProfileName = connectorProfileNameDecoded
        let connectorTypeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ConnectorType.self, forKey: .connectorType)
        connectorType = connectorTypeDecoded
        let connectionModeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ConnectionMode.self, forKey: .connectionMode)
        connectionMode = connectionModeDecoded
        let credentialsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .credentialsArn)
        credentialsArn = credentialsArnDecoded
        let connectorProfilePropertiesDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ConnectorProfileProperties.self, forKey: .connectorProfileProperties)
        connectorProfileProperties = connectorProfilePropertiesDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let privateConnectionProvisioningStateDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.PrivateConnectionProvisioningState.self, forKey: .privateConnectionProvisioningState)
        privateConnectionProvisioningState = privateConnectionProvisioningStateDecoded
    }
}

extension AppflowClientTypes {
    /// Describes an instance of a connector. This includes the provided name, credentials ARN, connection-mode, and so on. To keep the API intuitive and extensible, the fields that are common to all types of connector profiles are explicitly specified at the top level. The rest of the connector-specific properties are available via the connectorProfileProperties field.
    public struct ConnectorProfile: Swift.Equatable {
        /// Indicates the connection mode and if it is public or private.
        public var connectionMode: AppflowClientTypes.ConnectionMode?
        /// The Amazon Resource Name (ARN) of the connector profile.
        public var connectorProfileArn: Swift.String?
        /// The name of the connector profile. The name is unique for each ConnectorProfile in the Amazon Web Services account.
        public var connectorProfileName: Swift.String?
        /// The connector-specific properties of the profile configuration.
        public var connectorProfileProperties: AppflowClientTypes.ConnectorProfileProperties?
        /// The type of connector, such as Salesforce, Amplitude, and so on.
        public var connectorType: AppflowClientTypes.ConnectorType?
        /// Specifies when the connector profile was created.
        public var createdAt: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the connector profile credentials.
        public var credentialsArn: Swift.String?
        /// Specifies when the connector profile was last updated.
        public var lastUpdatedAt: ClientRuntime.Date?
        /// Specifies the private connection provisioning state.
        public var privateConnectionProvisioningState: AppflowClientTypes.PrivateConnectionProvisioningState?

        public init (
            connectionMode: AppflowClientTypes.ConnectionMode? = nil,
            connectorProfileArn: Swift.String? = nil,
            connectorProfileName: Swift.String? = nil,
            connectorProfileProperties: AppflowClientTypes.ConnectorProfileProperties? = nil,
            connectorType: AppflowClientTypes.ConnectorType? = nil,
            createdAt: ClientRuntime.Date? = nil,
            credentialsArn: Swift.String? = nil,
            lastUpdatedAt: ClientRuntime.Date? = nil,
            privateConnectionProvisioningState: AppflowClientTypes.PrivateConnectionProvisioningState? = nil
        )
        {
            self.connectionMode = connectionMode
            self.connectorProfileArn = connectorProfileArn
            self.connectorProfileName = connectorProfileName
            self.connectorProfileProperties = connectorProfileProperties
            self.connectorType = connectorType
            self.createdAt = createdAt
            self.credentialsArn = credentialsArn
            self.lastUpdatedAt = lastUpdatedAt
            self.privateConnectionProvisioningState = privateConnectionProvisioningState
        }
    }

}

extension AppflowClientTypes.ConnectorProfileConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectorProfileCredentials
        case connectorProfileProperties
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectorProfileCredentials = connectorProfileCredentials {
            try encodeContainer.encode(connectorProfileCredentials, forKey: .connectorProfileCredentials)
        }
        if let connectorProfileProperties = connectorProfileProperties {
            try encodeContainer.encode(connectorProfileProperties, forKey: .connectorProfileProperties)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorProfilePropertiesDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ConnectorProfileProperties.self, forKey: .connectorProfileProperties)
        connectorProfileProperties = connectorProfilePropertiesDecoded
        let connectorProfileCredentialsDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ConnectorProfileCredentials.self, forKey: .connectorProfileCredentials)
        connectorProfileCredentials = connectorProfileCredentialsDecoded
    }
}

extension AppflowClientTypes {
    /// Defines the connector-specific configuration and credentials for the connector profile.
    public struct ConnectorProfileConfig: Swift.Equatable {
        /// The connector-specific credentials required by each connector.
        /// This member is required.
        public var connectorProfileCredentials: AppflowClientTypes.ConnectorProfileCredentials?
        /// The connector-specific properties of the profile configuration.
        /// This member is required.
        public var connectorProfileProperties: AppflowClientTypes.ConnectorProfileProperties?

        public init (
            connectorProfileCredentials: AppflowClientTypes.ConnectorProfileCredentials? = nil,
            connectorProfileProperties: AppflowClientTypes.ConnectorProfileProperties? = nil
        )
        {
            self.connectorProfileCredentials = connectorProfileCredentials
            self.connectorProfileProperties = connectorProfileProperties
        }
    }

}

extension AppflowClientTypes.ConnectorProfileCredentials: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amplitude = "Amplitude"
        case datadog = "Datadog"
        case dynatrace = "Dynatrace"
        case googleAnalytics = "GoogleAnalytics"
        case honeycode = "Honeycode"
        case inforNexus = "InforNexus"
        case marketo = "Marketo"
        case redshift = "Redshift"
        case sAPOData = "SAPOData"
        case salesforce = "Salesforce"
        case serviceNow = "ServiceNow"
        case singular = "Singular"
        case slack = "Slack"
        case snowflake = "Snowflake"
        case trendmicro = "Trendmicro"
        case veeva = "Veeva"
        case zendesk = "Zendesk"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amplitude = amplitude {
            try encodeContainer.encode(amplitude, forKey: .amplitude)
        }
        if let datadog = datadog {
            try encodeContainer.encode(datadog, forKey: .datadog)
        }
        if let dynatrace = dynatrace {
            try encodeContainer.encode(dynatrace, forKey: .dynatrace)
        }
        if let googleAnalytics = googleAnalytics {
            try encodeContainer.encode(googleAnalytics, forKey: .googleAnalytics)
        }
        if let honeycode = honeycode {
            try encodeContainer.encode(honeycode, forKey: .honeycode)
        }
        if let inforNexus = inforNexus {
            try encodeContainer.encode(inforNexus, forKey: .inforNexus)
        }
        if let marketo = marketo {
            try encodeContainer.encode(marketo, forKey: .marketo)
        }
        if let redshift = redshift {
            try encodeContainer.encode(redshift, forKey: .redshift)
        }
        if let sAPOData = sAPOData {
            try encodeContainer.encode(sAPOData, forKey: .sAPOData)
        }
        if let salesforce = salesforce {
            try encodeContainer.encode(salesforce, forKey: .salesforce)
        }
        if let serviceNow = serviceNow {
            try encodeContainer.encode(serviceNow, forKey: .serviceNow)
        }
        if let singular = singular {
            try encodeContainer.encode(singular, forKey: .singular)
        }
        if let slack = slack {
            try encodeContainer.encode(slack, forKey: .slack)
        }
        if let snowflake = snowflake {
            try encodeContainer.encode(snowflake, forKey: .snowflake)
        }
        if let trendmicro = trendmicro {
            try encodeContainer.encode(trendmicro, forKey: .trendmicro)
        }
        if let veeva = veeva {
            try encodeContainer.encode(veeva, forKey: .veeva)
        }
        if let zendesk = zendesk {
            try encodeContainer.encode(zendesk, forKey: .zendesk)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let amplitudeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.AmplitudeConnectorProfileCredentials.self, forKey: .amplitude)
        amplitude = amplitudeDecoded
        let datadogDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.DatadogConnectorProfileCredentials.self, forKey: .datadog)
        datadog = datadogDecoded
        let dynatraceDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.DynatraceConnectorProfileCredentials.self, forKey: .dynatrace)
        dynatrace = dynatraceDecoded
        let googleAnalyticsDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.GoogleAnalyticsConnectorProfileCredentials.self, forKey: .googleAnalytics)
        googleAnalytics = googleAnalyticsDecoded
        let honeycodeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.HoneycodeConnectorProfileCredentials.self, forKey: .honeycode)
        honeycode = honeycodeDecoded
        let inforNexusDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.InforNexusConnectorProfileCredentials.self, forKey: .inforNexus)
        inforNexus = inforNexusDecoded
        let marketoDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.MarketoConnectorProfileCredentials.self, forKey: .marketo)
        marketo = marketoDecoded
        let redshiftDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.RedshiftConnectorProfileCredentials.self, forKey: .redshift)
        redshift = redshiftDecoded
        let salesforceDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.SalesforceConnectorProfileCredentials.self, forKey: .salesforce)
        salesforce = salesforceDecoded
        let serviceNowDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ServiceNowConnectorProfileCredentials.self, forKey: .serviceNow)
        serviceNow = serviceNowDecoded
        let singularDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.SingularConnectorProfileCredentials.self, forKey: .singular)
        singular = singularDecoded
        let slackDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.SlackConnectorProfileCredentials.self, forKey: .slack)
        slack = slackDecoded
        let snowflakeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.SnowflakeConnectorProfileCredentials.self, forKey: .snowflake)
        snowflake = snowflakeDecoded
        let trendmicroDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.TrendmicroConnectorProfileCredentials.self, forKey: .trendmicro)
        trendmicro = trendmicroDecoded
        let veevaDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.VeevaConnectorProfileCredentials.self, forKey: .veeva)
        veeva = veevaDecoded
        let zendeskDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ZendeskConnectorProfileCredentials.self, forKey: .zendesk)
        zendesk = zendeskDecoded
        let sAPODataDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.SAPODataConnectorProfileCredentials.self, forKey: .sAPOData)
        sAPOData = sAPODataDecoded
    }
}

extension AppflowClientTypes {
    /// The connector-specific credentials required by a connector.
    public struct ConnectorProfileCredentials: Swift.Equatable {
        /// The connector-specific credentials required when using Amplitude.
        public var amplitude: AppflowClientTypes.AmplitudeConnectorProfileCredentials?
        /// The connector-specific credentials required when using Datadog.
        public var datadog: AppflowClientTypes.DatadogConnectorProfileCredentials?
        /// The connector-specific credentials required when using Dynatrace.
        public var dynatrace: AppflowClientTypes.DynatraceConnectorProfileCredentials?
        /// The connector-specific credentials required when using Google Analytics.
        public var googleAnalytics: AppflowClientTypes.GoogleAnalyticsConnectorProfileCredentials?
        /// The connector-specific credentials required when using Amazon Honeycode.
        public var honeycode: AppflowClientTypes.HoneycodeConnectorProfileCredentials?
        /// The connector-specific credentials required when using Infor Nexus.
        public var inforNexus: AppflowClientTypes.InforNexusConnectorProfileCredentials?
        /// The connector-specific credentials required when using Marketo.
        public var marketo: AppflowClientTypes.MarketoConnectorProfileCredentials?
        /// The connector-specific credentials required when using Amazon Redshift.
        public var redshift: AppflowClientTypes.RedshiftConnectorProfileCredentials?
        /// The connector-specific profile credentials required when using SAPOData.
        public var sAPOData: AppflowClientTypes.SAPODataConnectorProfileCredentials?
        /// The connector-specific credentials required when using Salesforce.
        public var salesforce: AppflowClientTypes.SalesforceConnectorProfileCredentials?
        /// The connector-specific credentials required when using ServiceNow.
        public var serviceNow: AppflowClientTypes.ServiceNowConnectorProfileCredentials?
        /// The connector-specific credentials required when using Singular.
        public var singular: AppflowClientTypes.SingularConnectorProfileCredentials?
        /// The connector-specific credentials required when using Slack.
        public var slack: AppflowClientTypes.SlackConnectorProfileCredentials?
        /// The connector-specific credentials required when using Snowflake.
        public var snowflake: AppflowClientTypes.SnowflakeConnectorProfileCredentials?
        /// The connector-specific credentials required when using Trend Micro.
        public var trendmicro: AppflowClientTypes.TrendmicroConnectorProfileCredentials?
        /// The connector-specific credentials required when using Veeva.
        public var veeva: AppflowClientTypes.VeevaConnectorProfileCredentials?
        /// The connector-specific credentials required when using Zendesk.
        public var zendesk: AppflowClientTypes.ZendeskConnectorProfileCredentials?

        public init (
            amplitude: AppflowClientTypes.AmplitudeConnectorProfileCredentials? = nil,
            datadog: AppflowClientTypes.DatadogConnectorProfileCredentials? = nil,
            dynatrace: AppflowClientTypes.DynatraceConnectorProfileCredentials? = nil,
            googleAnalytics: AppflowClientTypes.GoogleAnalyticsConnectorProfileCredentials? = nil,
            honeycode: AppflowClientTypes.HoneycodeConnectorProfileCredentials? = nil,
            inforNexus: AppflowClientTypes.InforNexusConnectorProfileCredentials? = nil,
            marketo: AppflowClientTypes.MarketoConnectorProfileCredentials? = nil,
            redshift: AppflowClientTypes.RedshiftConnectorProfileCredentials? = nil,
            sAPOData: AppflowClientTypes.SAPODataConnectorProfileCredentials? = nil,
            salesforce: AppflowClientTypes.SalesforceConnectorProfileCredentials? = nil,
            serviceNow: AppflowClientTypes.ServiceNowConnectorProfileCredentials? = nil,
            singular: AppflowClientTypes.SingularConnectorProfileCredentials? = nil,
            slack: AppflowClientTypes.SlackConnectorProfileCredentials? = nil,
            snowflake: AppflowClientTypes.SnowflakeConnectorProfileCredentials? = nil,
            trendmicro: AppflowClientTypes.TrendmicroConnectorProfileCredentials? = nil,
            veeva: AppflowClientTypes.VeevaConnectorProfileCredentials? = nil,
            zendesk: AppflowClientTypes.ZendeskConnectorProfileCredentials? = nil
        )
        {
            self.amplitude = amplitude
            self.datadog = datadog
            self.dynatrace = dynatrace
            self.googleAnalytics = googleAnalytics
            self.honeycode = honeycode
            self.inforNexus = inforNexus
            self.marketo = marketo
            self.redshift = redshift
            self.sAPOData = sAPOData
            self.salesforce = salesforce
            self.serviceNow = serviceNow
            self.singular = singular
            self.slack = slack
            self.snowflake = snowflake
            self.trendmicro = trendmicro
            self.veeva = veeva
            self.zendesk = zendesk
        }
    }

}

extension AppflowClientTypes.ConnectorProfileProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amplitude = "Amplitude"
        case datadog = "Datadog"
        case dynatrace = "Dynatrace"
        case googleAnalytics = "GoogleAnalytics"
        case honeycode = "Honeycode"
        case inforNexus = "InforNexus"
        case marketo = "Marketo"
        case redshift = "Redshift"
        case sAPOData = "SAPOData"
        case salesforce = "Salesforce"
        case serviceNow = "ServiceNow"
        case singular = "Singular"
        case slack = "Slack"
        case snowflake = "Snowflake"
        case trendmicro = "Trendmicro"
        case veeva = "Veeva"
        case zendesk = "Zendesk"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amplitude = amplitude {
            try encodeContainer.encode(amplitude, forKey: .amplitude)
        }
        if let datadog = datadog {
            try encodeContainer.encode(datadog, forKey: .datadog)
        }
        if let dynatrace = dynatrace {
            try encodeContainer.encode(dynatrace, forKey: .dynatrace)
        }
        if let googleAnalytics = googleAnalytics {
            try encodeContainer.encode(googleAnalytics, forKey: .googleAnalytics)
        }
        if let honeycode = honeycode {
            try encodeContainer.encode(honeycode, forKey: .honeycode)
        }
        if let inforNexus = inforNexus {
            try encodeContainer.encode(inforNexus, forKey: .inforNexus)
        }
        if let marketo = marketo {
            try encodeContainer.encode(marketo, forKey: .marketo)
        }
        if let redshift = redshift {
            try encodeContainer.encode(redshift, forKey: .redshift)
        }
        if let sAPOData = sAPOData {
            try encodeContainer.encode(sAPOData, forKey: .sAPOData)
        }
        if let salesforce = salesforce {
            try encodeContainer.encode(salesforce, forKey: .salesforce)
        }
        if let serviceNow = serviceNow {
            try encodeContainer.encode(serviceNow, forKey: .serviceNow)
        }
        if let singular = singular {
            try encodeContainer.encode(singular, forKey: .singular)
        }
        if let slack = slack {
            try encodeContainer.encode(slack, forKey: .slack)
        }
        if let snowflake = snowflake {
            try encodeContainer.encode(snowflake, forKey: .snowflake)
        }
        if let trendmicro = trendmicro {
            try encodeContainer.encode(trendmicro, forKey: .trendmicro)
        }
        if let veeva = veeva {
            try encodeContainer.encode(veeva, forKey: .veeva)
        }
        if let zendesk = zendesk {
            try encodeContainer.encode(zendesk, forKey: .zendesk)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let amplitudeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.AmplitudeConnectorProfileProperties.self, forKey: .amplitude)
        amplitude = amplitudeDecoded
        let datadogDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.DatadogConnectorProfileProperties.self, forKey: .datadog)
        datadog = datadogDecoded
        let dynatraceDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.DynatraceConnectorProfileProperties.self, forKey: .dynatrace)
        dynatrace = dynatraceDecoded
        let googleAnalyticsDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.GoogleAnalyticsConnectorProfileProperties.self, forKey: .googleAnalytics)
        googleAnalytics = googleAnalyticsDecoded
        let honeycodeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.HoneycodeConnectorProfileProperties.self, forKey: .honeycode)
        honeycode = honeycodeDecoded
        let inforNexusDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.InforNexusConnectorProfileProperties.self, forKey: .inforNexus)
        inforNexus = inforNexusDecoded
        let marketoDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.MarketoConnectorProfileProperties.self, forKey: .marketo)
        marketo = marketoDecoded
        let redshiftDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.RedshiftConnectorProfileProperties.self, forKey: .redshift)
        redshift = redshiftDecoded
        let salesforceDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.SalesforceConnectorProfileProperties.self, forKey: .salesforce)
        salesforce = salesforceDecoded
        let serviceNowDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ServiceNowConnectorProfileProperties.self, forKey: .serviceNow)
        serviceNow = serviceNowDecoded
        let singularDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.SingularConnectorProfileProperties.self, forKey: .singular)
        singular = singularDecoded
        let slackDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.SlackConnectorProfileProperties.self, forKey: .slack)
        slack = slackDecoded
        let snowflakeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.SnowflakeConnectorProfileProperties.self, forKey: .snowflake)
        snowflake = snowflakeDecoded
        let trendmicroDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.TrendmicroConnectorProfileProperties.self, forKey: .trendmicro)
        trendmicro = trendmicroDecoded
        let veevaDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.VeevaConnectorProfileProperties.self, forKey: .veeva)
        veeva = veevaDecoded
        let zendeskDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ZendeskConnectorProfileProperties.self, forKey: .zendesk)
        zendesk = zendeskDecoded
        let sAPODataDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.SAPODataConnectorProfileProperties.self, forKey: .sAPOData)
        sAPOData = sAPODataDecoded
    }
}

extension AppflowClientTypes {
    /// The connector-specific profile properties required by each connector.
    public struct ConnectorProfileProperties: Swift.Equatable {
        /// The connector-specific properties required by Amplitude.
        public var amplitude: AppflowClientTypes.AmplitudeConnectorProfileProperties?
        /// The connector-specific properties required by Datadog.
        public var datadog: AppflowClientTypes.DatadogConnectorProfileProperties?
        /// The connector-specific properties required by Dynatrace.
        public var dynatrace: AppflowClientTypes.DynatraceConnectorProfileProperties?
        /// The connector-specific properties required Google Analytics.
        public var googleAnalytics: AppflowClientTypes.GoogleAnalyticsConnectorProfileProperties?
        /// The connector-specific properties required by Amazon Honeycode.
        public var honeycode: AppflowClientTypes.HoneycodeConnectorProfileProperties?
        /// The connector-specific properties required by Infor Nexus.
        public var inforNexus: AppflowClientTypes.InforNexusConnectorProfileProperties?
        /// The connector-specific properties required by Marketo.
        public var marketo: AppflowClientTypes.MarketoConnectorProfileProperties?
        /// The connector-specific properties required by Amazon Redshift.
        public var redshift: AppflowClientTypes.RedshiftConnectorProfileProperties?
        /// The connector-specific profile properties required when using SAPOData.
        public var sAPOData: AppflowClientTypes.SAPODataConnectorProfileProperties?
        /// The connector-specific properties required by Salesforce.
        public var salesforce: AppflowClientTypes.SalesforceConnectorProfileProperties?
        /// The connector-specific properties required by serviceNow.
        public var serviceNow: AppflowClientTypes.ServiceNowConnectorProfileProperties?
        /// The connector-specific properties required by Singular.
        public var singular: AppflowClientTypes.SingularConnectorProfileProperties?
        /// The connector-specific properties required by Slack.
        public var slack: AppflowClientTypes.SlackConnectorProfileProperties?
        /// The connector-specific properties required by Snowflake.
        public var snowflake: AppflowClientTypes.SnowflakeConnectorProfileProperties?
        /// The connector-specific properties required by Trend Micro.
        public var trendmicro: AppflowClientTypes.TrendmicroConnectorProfileProperties?
        /// The connector-specific properties required by Veeva.
        public var veeva: AppflowClientTypes.VeevaConnectorProfileProperties?
        /// The connector-specific properties required by Zendesk.
        public var zendesk: AppflowClientTypes.ZendeskConnectorProfileProperties?

        public init (
            amplitude: AppflowClientTypes.AmplitudeConnectorProfileProperties? = nil,
            datadog: AppflowClientTypes.DatadogConnectorProfileProperties? = nil,
            dynatrace: AppflowClientTypes.DynatraceConnectorProfileProperties? = nil,
            googleAnalytics: AppflowClientTypes.GoogleAnalyticsConnectorProfileProperties? = nil,
            honeycode: AppflowClientTypes.HoneycodeConnectorProfileProperties? = nil,
            inforNexus: AppflowClientTypes.InforNexusConnectorProfileProperties? = nil,
            marketo: AppflowClientTypes.MarketoConnectorProfileProperties? = nil,
            redshift: AppflowClientTypes.RedshiftConnectorProfileProperties? = nil,
            sAPOData: AppflowClientTypes.SAPODataConnectorProfileProperties? = nil,
            salesforce: AppflowClientTypes.SalesforceConnectorProfileProperties? = nil,
            serviceNow: AppflowClientTypes.ServiceNowConnectorProfileProperties? = nil,
            singular: AppflowClientTypes.SingularConnectorProfileProperties? = nil,
            slack: AppflowClientTypes.SlackConnectorProfileProperties? = nil,
            snowflake: AppflowClientTypes.SnowflakeConnectorProfileProperties? = nil,
            trendmicro: AppflowClientTypes.TrendmicroConnectorProfileProperties? = nil,
            veeva: AppflowClientTypes.VeevaConnectorProfileProperties? = nil,
            zendesk: AppflowClientTypes.ZendeskConnectorProfileProperties? = nil
        )
        {
            self.amplitude = amplitude
            self.datadog = datadog
            self.dynatrace = dynatrace
            self.googleAnalytics = googleAnalytics
            self.honeycode = honeycode
            self.inforNexus = inforNexus
            self.marketo = marketo
            self.redshift = redshift
            self.sAPOData = sAPOData
            self.salesforce = salesforce
            self.serviceNow = serviceNow
            self.singular = singular
            self.slack = slack
            self.snowflake = snowflake
            self.trendmicro = trendmicro
            self.veeva = veeva
            self.zendesk = zendesk
        }
    }

}

extension ConnectorServerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConnectorServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An error occurred when retrieving data from the connector endpoint.
public struct ConnectorServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ConnectorServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConnectorServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AppflowClientTypes {
    public enum ConnectorType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case amplitude
        case customerprofiles
        case datadog
        case dynatrace
        case eventbridge
        case googleanalytics
        case honeycode
        case infornexus
        case lookoutmetrics
        case marketo
        case redshift
        case s3
        case salesforce
        case sapodata
        case servicenow
        case singular
        case slack
        case snowflake
        case trendmicro
        case upsolver
        case veeva
        case zendesk
        case sdkUnknown(Swift.String)

        public static var allCases: [ConnectorType] {
            return [
                .amplitude,
                .customerprofiles,
                .datadog,
                .dynatrace,
                .eventbridge,
                .googleanalytics,
                .honeycode,
                .infornexus,
                .lookoutmetrics,
                .marketo,
                .redshift,
                .s3,
                .salesforce,
                .sapodata,
                .servicenow,
                .singular,
                .slack,
                .snowflake,
                .trendmicro,
                .upsolver,
                .veeva,
                .zendesk,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .amplitude: return "Amplitude"
            case .customerprofiles: return "CustomerProfiles"
            case .datadog: return "Datadog"
            case .dynatrace: return "Dynatrace"
            case .eventbridge: return "EventBridge"
            case .googleanalytics: return "Googleanalytics"
            case .honeycode: return "Honeycode"
            case .infornexus: return "Infornexus"
            case .lookoutmetrics: return "LookoutMetrics"
            case .marketo: return "Marketo"
            case .redshift: return "Redshift"
            case .s3: return "S3"
            case .salesforce: return "Salesforce"
            case .sapodata: return "SAPOData"
            case .servicenow: return "Servicenow"
            case .singular: return "Singular"
            case .slack: return "Slack"
            case .snowflake: return "Snowflake"
            case .trendmicro: return "Trendmicro"
            case .upsolver: return "Upsolver"
            case .veeva: return "Veeva"
            case .zendesk: return "Zendesk"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConnectorType(rawValue: rawValue) ?? ConnectorType.sdkUnknown(rawValue)
        }
    }
}

extension CreateConnectorProfileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionMode
        case connectorProfileConfig
        case connectorProfileName
        case connectorType
        case kmsArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionMode = connectionMode {
            try encodeContainer.encode(connectionMode.rawValue, forKey: .connectionMode)
        }
        if let connectorProfileConfig = connectorProfileConfig {
            try encodeContainer.encode(connectorProfileConfig, forKey: .connectorProfileConfig)
        }
        if let connectorProfileName = connectorProfileName {
            try encodeContainer.encode(connectorProfileName, forKey: .connectorProfileName)
        }
        if let connectorType = connectorType {
            try encodeContainer.encode(connectorType.rawValue, forKey: .connectorType)
        }
        if let kmsArn = kmsArn {
            try encodeContainer.encode(kmsArn, forKey: .kmsArn)
        }
    }
}

extension CreateConnectorProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/create-connector-profile"
    }
}

public struct CreateConnectorProfileInput: Swift.Equatable {
    /// Indicates the connection mode and specifies whether it is public or private. Private flows use Amazon Web Services PrivateLink to route data over Amazon Web Services infrastructure without exposing it to the public internet.
    /// This member is required.
    public var connectionMode: AppflowClientTypes.ConnectionMode?
    /// Defines the connector-specific configuration and credentials.
    /// This member is required.
    public var connectorProfileConfig: AppflowClientTypes.ConnectorProfileConfig?
    /// The name of the connector profile. The name is unique for each ConnectorProfile in your Amazon Web Services account.
    /// This member is required.
    public var connectorProfileName: Swift.String?
    /// The type of connector, such as Salesforce, Amplitude, and so on.
    /// This member is required.
    public var connectorType: AppflowClientTypes.ConnectorType?
    /// The ARN (Amazon Resource Name) of the Key Management Service (KMS) key you provide for encryption. This is required if you do not want to use the Amazon AppFlow-managed KMS key. If you don't provide anything here, Amazon AppFlow uses the Amazon AppFlow-managed KMS key.
    public var kmsArn: Swift.String?

    public init (
        connectionMode: AppflowClientTypes.ConnectionMode? = nil,
        connectorProfileConfig: AppflowClientTypes.ConnectorProfileConfig? = nil,
        connectorProfileName: Swift.String? = nil,
        connectorType: AppflowClientTypes.ConnectorType? = nil,
        kmsArn: Swift.String? = nil
    )
    {
        self.connectionMode = connectionMode
        self.connectorProfileConfig = connectorProfileConfig
        self.connectorProfileName = connectorProfileName
        self.connectorType = connectorType
        self.kmsArn = kmsArn
    }
}

struct CreateConnectorProfileInputBody: Swift.Equatable {
    let connectorProfileName: Swift.String?
    let kmsArn: Swift.String?
    let connectorType: AppflowClientTypes.ConnectorType?
    let connectionMode: AppflowClientTypes.ConnectionMode?
    let connectorProfileConfig: AppflowClientTypes.ConnectorProfileConfig?
}

extension CreateConnectorProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionMode
        case connectorProfileConfig
        case connectorProfileName
        case connectorType
        case kmsArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorProfileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectorProfileName)
        connectorProfileName = connectorProfileNameDecoded
        let kmsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsArn)
        kmsArn = kmsArnDecoded
        let connectorTypeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ConnectorType.self, forKey: .connectorType)
        connectorType = connectorTypeDecoded
        let connectionModeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ConnectionMode.self, forKey: .connectionMode)
        connectionMode = connectionModeDecoded
        let connectorProfileConfigDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ConnectorProfileConfig.self, forKey: .connectorProfileConfig)
        connectorProfileConfig = connectorProfileConfigDecoded
    }
}

extension CreateConnectorProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateConnectorProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConnectorAuthenticationException" : self = .connectorAuthenticationException(try ConnectorAuthenticationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateConnectorProfileOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case connectorAuthenticationException(ConnectorAuthenticationException)
    case internalServerException(InternalServerException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateConnectorProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateConnectorProfileOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.connectorProfileArn = output.connectorProfileArn
        } else {
            self.connectorProfileArn = nil
        }
    }
}

public struct CreateConnectorProfileOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the connector profile.
    public var connectorProfileArn: Swift.String?

    public init (
        connectorProfileArn: Swift.String? = nil
    )
    {
        self.connectorProfileArn = connectorProfileArn
    }
}

struct CreateConnectorProfileOutputResponseBody: Swift.Equatable {
    let connectorProfileArn: Swift.String?
}

extension CreateConnectorProfileOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectorProfileArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorProfileArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectorProfileArn)
        connectorProfileArn = connectorProfileArnDecoded
    }
}

extension CreateFlowInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case destinationFlowConfigList
        case flowName
        case kmsArn
        case sourceFlowConfig
        case tags
        case tasks
        case triggerConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let destinationFlowConfigList = destinationFlowConfigList {
            var destinationFlowConfigListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .destinationFlowConfigList)
            for destinationflowconfiglist0 in destinationFlowConfigList {
                try destinationFlowConfigListContainer.encode(destinationflowconfiglist0)
            }
        }
        if let flowName = flowName {
            try encodeContainer.encode(flowName, forKey: .flowName)
        }
        if let kmsArn = kmsArn {
            try encodeContainer.encode(kmsArn, forKey: .kmsArn)
        }
        if let sourceFlowConfig = sourceFlowConfig {
            try encodeContainer.encode(sourceFlowConfig, forKey: .sourceFlowConfig)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let tasks = tasks {
            var tasksContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tasks)
            for tasks0 in tasks {
                try tasksContainer.encode(tasks0)
            }
        }
        if let triggerConfig = triggerConfig {
            try encodeContainer.encode(triggerConfig, forKey: .triggerConfig)
        }
    }
}

extension CreateFlowInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/create-flow"
    }
}

public struct CreateFlowInput: Swift.Equatable {
    /// A description of the flow you want to create.
    public var description: Swift.String?
    /// The configuration that controls how Amazon AppFlow places data in the destination connector.
    /// This member is required.
    public var destinationFlowConfigList: [AppflowClientTypes.DestinationFlowConfig]?
    /// The specified name of the flow. Spaces are not allowed. Use underscores (_) or hyphens (-) only.
    /// This member is required.
    public var flowName: Swift.String?
    /// The ARN (Amazon Resource Name) of the Key Management Service (KMS) key you provide for encryption. This is required if you do not want to use the Amazon AppFlow-managed KMS key. If you don't provide anything here, Amazon AppFlow uses the Amazon AppFlow-managed KMS key.
    public var kmsArn: Swift.String?
    /// The configuration that controls how Amazon AppFlow retrieves data from the source connector.
    /// This member is required.
    public var sourceFlowConfig: AppflowClientTypes.SourceFlowConfig?
    /// The tags used to organize, track, or control access for your flow.
    public var tags: [Swift.String:Swift.String]?
    /// A list of tasks that Amazon AppFlow performs while transferring the data in the flow run.
    /// This member is required.
    public var tasks: [AppflowClientTypes.Task]?
    /// The trigger settings that determine how and when the flow runs.
    /// This member is required.
    public var triggerConfig: AppflowClientTypes.TriggerConfig?

    public init (
        description: Swift.String? = nil,
        destinationFlowConfigList: [AppflowClientTypes.DestinationFlowConfig]? = nil,
        flowName: Swift.String? = nil,
        kmsArn: Swift.String? = nil,
        sourceFlowConfig: AppflowClientTypes.SourceFlowConfig? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        tasks: [AppflowClientTypes.Task]? = nil,
        triggerConfig: AppflowClientTypes.TriggerConfig? = nil
    )
    {
        self.description = description
        self.destinationFlowConfigList = destinationFlowConfigList
        self.flowName = flowName
        self.kmsArn = kmsArn
        self.sourceFlowConfig = sourceFlowConfig
        self.tags = tags
        self.tasks = tasks
        self.triggerConfig = triggerConfig
    }
}

struct CreateFlowInputBody: Swift.Equatable {
    let flowName: Swift.String?
    let description: Swift.String?
    let kmsArn: Swift.String?
    let triggerConfig: AppflowClientTypes.TriggerConfig?
    let sourceFlowConfig: AppflowClientTypes.SourceFlowConfig?
    let destinationFlowConfigList: [AppflowClientTypes.DestinationFlowConfig]?
    let tasks: [AppflowClientTypes.Task]?
    let tags: [Swift.String:Swift.String]?
}

extension CreateFlowInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case destinationFlowConfigList
        case flowName
        case kmsArn
        case sourceFlowConfig
        case tags
        case tasks
        case triggerConfig
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowName)
        flowName = flowNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let kmsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsArn)
        kmsArn = kmsArnDecoded
        let triggerConfigDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.TriggerConfig.self, forKey: .triggerConfig)
        triggerConfig = triggerConfigDecoded
        let sourceFlowConfigDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.SourceFlowConfig.self, forKey: .sourceFlowConfig)
        sourceFlowConfig = sourceFlowConfigDecoded
        let destinationFlowConfigListContainer = try containerValues.decodeIfPresent([AppflowClientTypes.DestinationFlowConfig?].self, forKey: .destinationFlowConfigList)
        var destinationFlowConfigListDecoded0:[AppflowClientTypes.DestinationFlowConfig]? = nil
        if let destinationFlowConfigListContainer = destinationFlowConfigListContainer {
            destinationFlowConfigListDecoded0 = [AppflowClientTypes.DestinationFlowConfig]()
            for structure0 in destinationFlowConfigListContainer {
                if let structure0 = structure0 {
                    destinationFlowConfigListDecoded0?.append(structure0)
                }
            }
        }
        destinationFlowConfigList = destinationFlowConfigListDecoded0
        let tasksContainer = try containerValues.decodeIfPresent([AppflowClientTypes.Task?].self, forKey: .tasks)
        var tasksDecoded0:[AppflowClientTypes.Task]? = nil
        if let tasksContainer = tasksContainer {
            tasksDecoded0 = [AppflowClientTypes.Task]()
            for structure0 in tasksContainer {
                if let structure0 = structure0 {
                    tasksDecoded0?.append(structure0)
                }
            }
        }
        tasks = tasksDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateFlowOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateFlowOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConnectorAuthenticationException" : self = .connectorAuthenticationException(try ConnectorAuthenticationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConnectorServerException" : self = .connectorServerException(try ConnectorServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateFlowOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case connectorAuthenticationException(ConnectorAuthenticationException)
    case connectorServerException(ConnectorServerException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateFlowOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateFlowOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.flowArn = output.flowArn
            self.flowStatus = output.flowStatus
        } else {
            self.flowArn = nil
            self.flowStatus = nil
        }
    }
}

public struct CreateFlowOutputResponse: Swift.Equatable {
    /// The flow's Amazon Resource Name (ARN).
    public var flowArn: Swift.String?
    /// Indicates the current status of the flow.
    public var flowStatus: AppflowClientTypes.FlowStatus?

    public init (
        flowArn: Swift.String? = nil,
        flowStatus: AppflowClientTypes.FlowStatus? = nil
    )
    {
        self.flowArn = flowArn
        self.flowStatus = flowStatus
    }
}

struct CreateFlowOutputResponseBody: Swift.Equatable {
    let flowArn: Swift.String?
    let flowStatus: AppflowClientTypes.FlowStatus?
}

extension CreateFlowOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case flowArn
        case flowStatus
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowArn)
        flowArn = flowArnDecoded
        let flowStatusDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.FlowStatus.self, forKey: .flowStatus)
        flowStatus = flowStatusDecoded
    }
}

extension AppflowClientTypes.CustomerProfilesDestinationProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName
        case objectTypeName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainName = domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let objectTypeName = objectTypeName {
            try encodeContainer.encode(objectTypeName, forKey: .objectTypeName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let objectTypeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .objectTypeName)
        objectTypeName = objectTypeNameDecoded
    }
}

extension AppflowClientTypes {
    /// The properties that are applied when Amazon Connect Customer Profiles is used as a destination.
    public struct CustomerProfilesDestinationProperties: Swift.Equatable {
        /// The unique name of the Amazon Connect Customer Profiles domain.
        /// This member is required.
        public var domainName: Swift.String?
        /// The object specified in the Amazon Connect Customer Profiles flow destination.
        public var objectTypeName: Swift.String?

        public init (
            domainName: Swift.String? = nil,
            objectTypeName: Swift.String? = nil
        )
        {
            self.domainName = domainName
            self.objectTypeName = objectTypeName
        }
    }

}

extension AppflowClientTypes.CustomerProfilesMetadata: Swift.Codable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension AppflowClientTypes {
    /// The connector metadata specific to Amazon Connect Customer Profiles.
    public struct CustomerProfilesMetadata: Swift.Equatable {

    }

}

extension AppflowClientTypes {
    public enum DataPullMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case complete
        case incremental
        case sdkUnknown(Swift.String)

        public static var allCases: [DataPullMode] {
            return [
                .complete,
                .incremental,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .complete: return "Complete"
            case .incremental: return "Incremental"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DataPullMode(rawValue: rawValue) ?? DataPullMode.sdkUnknown(rawValue)
        }
    }
}

extension AppflowClientTypes {
    public enum DatadogConnectorOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case addition
        case between
        case division
        case equalTo
        case maskAll
        case maskFirstN
        case maskLastN
        case multiplication
        case noOp
        case projection
        case subtraction
        case validateNonNegative
        case validateNonNull
        case validateNonZero
        case validateNumeric
        case sdkUnknown(Swift.String)

        public static var allCases: [DatadogConnectorOperator] {
            return [
                .addition,
                .between,
                .division,
                .equalTo,
                .maskAll,
                .maskFirstN,
                .maskLastN,
                .multiplication,
                .noOp,
                .projection,
                .subtraction,
                .validateNonNegative,
                .validateNonNull,
                .validateNonZero,
                .validateNumeric,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .addition: return "ADDITION"
            case .between: return "BETWEEN"
            case .division: return "DIVISION"
            case .equalTo: return "EQUAL_TO"
            case .maskAll: return "MASK_ALL"
            case .maskFirstN: return "MASK_FIRST_N"
            case .maskLastN: return "MASK_LAST_N"
            case .multiplication: return "MULTIPLICATION"
            case .noOp: return "NO_OP"
            case .projection: return "PROJECTION"
            case .subtraction: return "SUBTRACTION"
            case .validateNonNegative: return "VALIDATE_NON_NEGATIVE"
            case .validateNonNull: return "VALIDATE_NON_NULL"
            case .validateNonZero: return "VALIDATE_NON_ZERO"
            case .validateNumeric: return "VALIDATE_NUMERIC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DatadogConnectorOperator(rawValue: rawValue) ?? DatadogConnectorOperator.sdkUnknown(rawValue)
        }
    }
}

extension AppflowClientTypes.DatadogConnectorProfileCredentials: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiKey
        case applicationKey
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiKey = apiKey {
            try encodeContainer.encode(apiKey, forKey: .apiKey)
        }
        if let applicationKey = applicationKey {
            try encodeContainer.encode(applicationKey, forKey: .applicationKey)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiKey)
        apiKey = apiKeyDecoded
        let applicationKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationKey)
        applicationKey = applicationKeyDecoded
    }
}

extension AppflowClientTypes {
    /// The connector-specific credentials required by Datadog.
    public struct DatadogConnectorProfileCredentials: Swift.Equatable {
        /// A unique alphanumeric identifier used to authenticate a user, developer, or calling program to your API.
        /// This member is required.
        public var apiKey: Swift.String?
        /// Application keys, in conjunction with your API key, give you full access to Datadogs programmatic API. Application keys are associated with the user account that created them. The application key is used to log all requests made to the API.
        /// This member is required.
        public var applicationKey: Swift.String?

        public init (
            apiKey: Swift.String? = nil,
            applicationKey: Swift.String? = nil
        )
        {
            self.apiKey = apiKey
            self.applicationKey = applicationKey
        }
    }

}

extension AppflowClientTypes.DatadogConnectorProfileProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceUrl
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceUrl = instanceUrl {
            try encodeContainer.encode(instanceUrl, forKey: .instanceUrl)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceUrl)
        instanceUrl = instanceUrlDecoded
    }
}

extension AppflowClientTypes {
    /// The connector-specific profile properties required by Datadog.
    public struct DatadogConnectorProfileProperties: Swift.Equatable {
        /// The location of the Datadog resource.
        /// This member is required.
        public var instanceUrl: Swift.String?

        public init (
            instanceUrl: Swift.String? = nil
        )
        {
            self.instanceUrl = instanceUrl
        }
    }

}

extension AppflowClientTypes.DatadogMetadata: Swift.Codable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension AppflowClientTypes {
    /// The connector metadata specific to Datadog.
    public struct DatadogMetadata: Swift.Equatable {

    }

}

extension AppflowClientTypes.DatadogSourceProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case object
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let object = object {
            try encodeContainer.encode(object, forKey: .object)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .object)
        object = objectDecoded
    }
}

extension AppflowClientTypes {
    /// The properties that are applied when Datadog is being used as a source.
    public struct DatadogSourceProperties: Swift.Equatable {
        /// The object specified in the Datadog flow source.
        /// This member is required.
        public var object: Swift.String?

        public init (
            object: Swift.String? = nil
        )
        {
            self.object = object
        }
    }

}

extension DeleteConnectorProfileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectorProfileName
        case forceDelete
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectorProfileName = connectorProfileName {
            try encodeContainer.encode(connectorProfileName, forKey: .connectorProfileName)
        }
        if forceDelete != false {
            try encodeContainer.encode(forceDelete, forKey: .forceDelete)
        }
    }
}

extension DeleteConnectorProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/delete-connector-profile"
    }
}

public struct DeleteConnectorProfileInput: Swift.Equatable {
    /// The name of the connector profile. The name is unique for each ConnectorProfile in your account.
    /// This member is required.
    public var connectorProfileName: Swift.String?
    /// Indicates whether Amazon AppFlow should delete the profile, even if it is currently in use in one or more flows.
    public var forceDelete: Swift.Bool

    public init (
        connectorProfileName: Swift.String? = nil,
        forceDelete: Swift.Bool = false
    )
    {
        self.connectorProfileName = connectorProfileName
        self.forceDelete = forceDelete
    }
}

struct DeleteConnectorProfileInputBody: Swift.Equatable {
    let connectorProfileName: Swift.String?
    let forceDelete: Swift.Bool
}

extension DeleteConnectorProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectorProfileName
        case forceDelete
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorProfileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectorProfileName)
        connectorProfileName = connectorProfileNameDecoded
        let forceDeleteDecoded = try containerValues.decode(Swift.Bool.self, forKey: .forceDelete)
        forceDelete = forceDeleteDecoded
    }
}

extension DeleteConnectorProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteConnectorProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteConnectorProfileOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteConnectorProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteConnectorProfileOutputResponse: Swift.Equatable {

}

extension DeleteFlowInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case flowName
        case forceDelete
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let flowName = flowName {
            try encodeContainer.encode(flowName, forKey: .flowName)
        }
        if forceDelete != false {
            try encodeContainer.encode(forceDelete, forKey: .forceDelete)
        }
    }
}

extension DeleteFlowInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/delete-flow"
    }
}

public struct DeleteFlowInput: Swift.Equatable {
    /// The specified name of the flow. Spaces are not allowed. Use underscores (_) or hyphens (-) only.
    /// This member is required.
    public var flowName: Swift.String?
    /// Indicates whether Amazon AppFlow should delete the flow, even if it is currently in use.
    public var forceDelete: Swift.Bool

    public init (
        flowName: Swift.String? = nil,
        forceDelete: Swift.Bool = false
    )
    {
        self.flowName = flowName
        self.forceDelete = forceDelete
    }
}

struct DeleteFlowInputBody: Swift.Equatable {
    let flowName: Swift.String?
    let forceDelete: Swift.Bool
}

extension DeleteFlowInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case flowName
        case forceDelete
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowName)
        flowName = flowNameDecoded
        let forceDeleteDecoded = try containerValues.decode(Swift.Bool.self, forKey: .forceDelete)
        forceDelete = forceDeleteDecoded
    }
}

extension DeleteFlowOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteFlowOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteFlowOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteFlowOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteFlowOutputResponse: Swift.Equatable {

}

extension DescribeConnectorEntityInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectorEntityName
        case connectorProfileName
        case connectorType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectorEntityName = connectorEntityName {
            try encodeContainer.encode(connectorEntityName, forKey: .connectorEntityName)
        }
        if let connectorProfileName = connectorProfileName {
            try encodeContainer.encode(connectorProfileName, forKey: .connectorProfileName)
        }
        if let connectorType = connectorType {
            try encodeContainer.encode(connectorType.rawValue, forKey: .connectorType)
        }
    }
}

extension DescribeConnectorEntityInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/describe-connector-entity"
    }
}

public struct DescribeConnectorEntityInput: Swift.Equatable {
    /// The entity name for that connector.
    /// This member is required.
    public var connectorEntityName: Swift.String?
    /// The name of the connector profile. The name is unique for each ConnectorProfile in the Amazon Web Services account.
    public var connectorProfileName: Swift.String?
    /// The type of connector application, such as Salesforce, Amplitude, and so on.
    public var connectorType: AppflowClientTypes.ConnectorType?

    public init (
        connectorEntityName: Swift.String? = nil,
        connectorProfileName: Swift.String? = nil,
        connectorType: AppflowClientTypes.ConnectorType? = nil
    )
    {
        self.connectorEntityName = connectorEntityName
        self.connectorProfileName = connectorProfileName
        self.connectorType = connectorType
    }
}

struct DescribeConnectorEntityInputBody: Swift.Equatable {
    let connectorEntityName: Swift.String?
    let connectorType: AppflowClientTypes.ConnectorType?
    let connectorProfileName: Swift.String?
}

extension DescribeConnectorEntityInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectorEntityName
        case connectorProfileName
        case connectorType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorEntityNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectorEntityName)
        connectorEntityName = connectorEntityNameDecoded
        let connectorTypeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ConnectorType.self, forKey: .connectorType)
        connectorType = connectorTypeDecoded
        let connectorProfileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectorProfileName)
        connectorProfileName = connectorProfileNameDecoded
    }
}

extension DescribeConnectorEntityOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeConnectorEntityOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConnectorAuthenticationException" : self = .connectorAuthenticationException(try ConnectorAuthenticationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConnectorServerException" : self = .connectorServerException(try ConnectorServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeConnectorEntityOutputError: Swift.Error, Swift.Equatable {
    case connectorAuthenticationException(ConnectorAuthenticationException)
    case connectorServerException(ConnectorServerException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeConnectorEntityOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeConnectorEntityOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.connectorEntityFields = output.connectorEntityFields
        } else {
            self.connectorEntityFields = nil
        }
    }
}

public struct DescribeConnectorEntityOutputResponse: Swift.Equatable {
    /// Describes the fields for that connector entity. For example, for an account entity, the fields would be account name, account ID, and so on.
    /// This member is required.
    public var connectorEntityFields: [AppflowClientTypes.ConnectorEntityField]?

    public init (
        connectorEntityFields: [AppflowClientTypes.ConnectorEntityField]? = nil
    )
    {
        self.connectorEntityFields = connectorEntityFields
    }
}

struct DescribeConnectorEntityOutputResponseBody: Swift.Equatable {
    let connectorEntityFields: [AppflowClientTypes.ConnectorEntityField]?
}

extension DescribeConnectorEntityOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectorEntityFields
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorEntityFieldsContainer = try containerValues.decodeIfPresent([AppflowClientTypes.ConnectorEntityField?].self, forKey: .connectorEntityFields)
        var connectorEntityFieldsDecoded0:[AppflowClientTypes.ConnectorEntityField]? = nil
        if let connectorEntityFieldsContainer = connectorEntityFieldsContainer {
            connectorEntityFieldsDecoded0 = [AppflowClientTypes.ConnectorEntityField]()
            for structure0 in connectorEntityFieldsContainer {
                if let structure0 = structure0 {
                    connectorEntityFieldsDecoded0?.append(structure0)
                }
            }
        }
        connectorEntityFields = connectorEntityFieldsDecoded0
    }
}

extension DescribeConnectorProfilesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectorProfileNames
        case connectorType
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectorProfileNames = connectorProfileNames {
            var connectorProfileNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .connectorProfileNames)
            for connectorprofilenamelist0 in connectorProfileNames {
                try connectorProfileNamesContainer.encode(connectorprofilenamelist0)
            }
        }
        if let connectorType = connectorType {
            try encodeContainer.encode(connectorType.rawValue, forKey: .connectorType)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeConnectorProfilesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/describe-connector-profiles"
    }
}

public struct DescribeConnectorProfilesInput: Swift.Equatable {
    /// The name of the connector profile. The name is unique for each ConnectorProfile in the Amazon Web Services account.
    public var connectorProfileNames: [Swift.String]?
    /// The type of connector, such as Salesforce, Amplitude, and so on.
    public var connectorType: AppflowClientTypes.ConnectorType?
    /// Specifies the maximum number of items that should be returned in the result set. The default for maxResults is 20 (for all paginated API operations).
    public var maxResults: Swift.Int?
    /// The pagination token for the next page of data.
    public var nextToken: Swift.String?

    public init (
        connectorProfileNames: [Swift.String]? = nil,
        connectorType: AppflowClientTypes.ConnectorType? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.connectorProfileNames = connectorProfileNames
        self.connectorType = connectorType
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeConnectorProfilesInputBody: Swift.Equatable {
    let connectorProfileNames: [Swift.String]?
    let connectorType: AppflowClientTypes.ConnectorType?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension DescribeConnectorProfilesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectorProfileNames
        case connectorType
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorProfileNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .connectorProfileNames)
        var connectorProfileNamesDecoded0:[Swift.String]? = nil
        if let connectorProfileNamesContainer = connectorProfileNamesContainer {
            connectorProfileNamesDecoded0 = [Swift.String]()
            for string0 in connectorProfileNamesContainer {
                if let string0 = string0 {
                    connectorProfileNamesDecoded0?.append(string0)
                }
            }
        }
        connectorProfileNames = connectorProfileNamesDecoded0
        let connectorTypeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ConnectorType.self, forKey: .connectorType)
        connectorType = connectorTypeDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeConnectorProfilesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeConnectorProfilesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeConnectorProfilesOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeConnectorProfilesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeConnectorProfilesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.connectorProfileDetails = output.connectorProfileDetails
            self.nextToken = output.nextToken
        } else {
            self.connectorProfileDetails = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeConnectorProfilesOutputResponse: Swift.Equatable {
    /// Returns information about the connector profiles associated with the flow.
    public var connectorProfileDetails: [AppflowClientTypes.ConnectorProfile]?
    /// The pagination token for the next page of data. If nextToken=null, this means that all records have been fetched.
    public var nextToken: Swift.String?

    public init (
        connectorProfileDetails: [AppflowClientTypes.ConnectorProfile]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.connectorProfileDetails = connectorProfileDetails
        self.nextToken = nextToken
    }
}

struct DescribeConnectorProfilesOutputResponseBody: Swift.Equatable {
    let connectorProfileDetails: [AppflowClientTypes.ConnectorProfile]?
    let nextToken: Swift.String?
}

extension DescribeConnectorProfilesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectorProfileDetails
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorProfileDetailsContainer = try containerValues.decodeIfPresent([AppflowClientTypes.ConnectorProfile?].self, forKey: .connectorProfileDetails)
        var connectorProfileDetailsDecoded0:[AppflowClientTypes.ConnectorProfile]? = nil
        if let connectorProfileDetailsContainer = connectorProfileDetailsContainer {
            connectorProfileDetailsDecoded0 = [AppflowClientTypes.ConnectorProfile]()
            for structure0 in connectorProfileDetailsContainer {
                if let structure0 = structure0 {
                    connectorProfileDetailsDecoded0?.append(structure0)
                }
            }
        }
        connectorProfileDetails = connectorProfileDetailsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeConnectorsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectorTypes
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectorTypes = connectorTypes {
            var connectorTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .connectorTypes)
            for connectortypelist0 in connectorTypes {
                try connectorTypesContainer.encode(connectortypelist0.rawValue)
            }
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeConnectorsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/describe-connectors"
    }
}

public struct DescribeConnectorsInput: Swift.Equatable {
    /// The type of connector, such as Salesforce, Amplitude, and so on.
    public var connectorTypes: [AppflowClientTypes.ConnectorType]?
    /// The pagination token for the next page of data.
    public var nextToken: Swift.String?

    public init (
        connectorTypes: [AppflowClientTypes.ConnectorType]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.connectorTypes = connectorTypes
        self.nextToken = nextToken
    }
}

struct DescribeConnectorsInputBody: Swift.Equatable {
    let connectorTypes: [AppflowClientTypes.ConnectorType]?
    let nextToken: Swift.String?
}

extension DescribeConnectorsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectorTypes
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorTypesContainer = try containerValues.decodeIfPresent([AppflowClientTypes.ConnectorType?].self, forKey: .connectorTypes)
        var connectorTypesDecoded0:[AppflowClientTypes.ConnectorType]? = nil
        if let connectorTypesContainer = connectorTypesContainer {
            connectorTypesDecoded0 = [AppflowClientTypes.ConnectorType]()
            for string0 in connectorTypesContainer {
                if let string0 = string0 {
                    connectorTypesDecoded0?.append(string0)
                }
            }
        }
        connectorTypes = connectorTypesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeConnectorsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeConnectorsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeConnectorsOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeConnectorsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeConnectorsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.connectorConfigurations = output.connectorConfigurations
            self.nextToken = output.nextToken
        } else {
            self.connectorConfigurations = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeConnectorsOutputResponse: Swift.Equatable {
    /// The configuration that is applied to the connectors used in the flow.
    public var connectorConfigurations: [Swift.String:AppflowClientTypes.ConnectorConfiguration]?
    /// The pagination token for the next page of data.
    public var nextToken: Swift.String?

    public init (
        connectorConfigurations: [Swift.String:AppflowClientTypes.ConnectorConfiguration]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.connectorConfigurations = connectorConfigurations
        self.nextToken = nextToken
    }
}

struct DescribeConnectorsOutputResponseBody: Swift.Equatable {
    let connectorConfigurations: [Swift.String:AppflowClientTypes.ConnectorConfiguration]?
    let nextToken: Swift.String?
}

extension DescribeConnectorsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectorConfigurations
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorConfigurationsContainer = try containerValues.decodeIfPresent([Swift.String: AppflowClientTypes.ConnectorConfiguration?].self, forKey: .connectorConfigurations)
        var connectorConfigurationsDecoded0: [Swift.String:AppflowClientTypes.ConnectorConfiguration]? = nil
        if let connectorConfigurationsContainer = connectorConfigurationsContainer {
            connectorConfigurationsDecoded0 = [Swift.String:AppflowClientTypes.ConnectorConfiguration]()
            for (key0, connectorconfiguration0) in connectorConfigurationsContainer {
                if let connectorconfiguration0 = connectorconfiguration0 {
                    connectorConfigurationsDecoded0?[key0] = connectorconfiguration0
                }
            }
        }
        connectorConfigurations = connectorConfigurationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeFlowExecutionRecordsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case flowName
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let flowName = flowName {
            try encodeContainer.encode(flowName, forKey: .flowName)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeFlowExecutionRecordsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/describe-flow-execution-records"
    }
}

public struct DescribeFlowExecutionRecordsInput: Swift.Equatable {
    /// The specified name of the flow. Spaces are not allowed. Use underscores (_) or hyphens (-) only.
    /// This member is required.
    public var flowName: Swift.String?
    /// Specifies the maximum number of items that should be returned in the result set. The default for maxResults is 20 (for all paginated API operations).
    public var maxResults: Swift.Int?
    /// The pagination token for the next page of data.
    public var nextToken: Swift.String?

    public init (
        flowName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.flowName = flowName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeFlowExecutionRecordsInputBody: Swift.Equatable {
    let flowName: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension DescribeFlowExecutionRecordsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case flowName
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowName)
        flowName = flowNameDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeFlowExecutionRecordsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeFlowExecutionRecordsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeFlowExecutionRecordsOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeFlowExecutionRecordsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeFlowExecutionRecordsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.flowExecutions = output.flowExecutions
            self.nextToken = output.nextToken
        } else {
            self.flowExecutions = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeFlowExecutionRecordsOutputResponse: Swift.Equatable {
    /// Returns a list of all instances when this flow was run.
    public var flowExecutions: [AppflowClientTypes.ExecutionRecord]?
    /// The pagination token for the next page of data.
    public var nextToken: Swift.String?

    public init (
        flowExecutions: [AppflowClientTypes.ExecutionRecord]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.flowExecutions = flowExecutions
        self.nextToken = nextToken
    }
}

struct DescribeFlowExecutionRecordsOutputResponseBody: Swift.Equatable {
    let flowExecutions: [AppflowClientTypes.ExecutionRecord]?
    let nextToken: Swift.String?
}

extension DescribeFlowExecutionRecordsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case flowExecutions
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowExecutionsContainer = try containerValues.decodeIfPresent([AppflowClientTypes.ExecutionRecord?].self, forKey: .flowExecutions)
        var flowExecutionsDecoded0:[AppflowClientTypes.ExecutionRecord]? = nil
        if let flowExecutionsContainer = flowExecutionsContainer {
            flowExecutionsDecoded0 = [AppflowClientTypes.ExecutionRecord]()
            for structure0 in flowExecutionsContainer {
                if let structure0 = structure0 {
                    flowExecutionsDecoded0?.append(structure0)
                }
            }
        }
        flowExecutions = flowExecutionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeFlowInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case flowName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let flowName = flowName {
            try encodeContainer.encode(flowName, forKey: .flowName)
        }
    }
}

extension DescribeFlowInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/describe-flow"
    }
}

public struct DescribeFlowInput: Swift.Equatable {
    /// The specified name of the flow. Spaces are not allowed. Use underscores (_) or hyphens (-) only.
    /// This member is required.
    public var flowName: Swift.String?

    public init (
        flowName: Swift.String? = nil
    )
    {
        self.flowName = flowName
    }
}

struct DescribeFlowInputBody: Swift.Equatable {
    let flowName: Swift.String?
}

extension DescribeFlowInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case flowName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowName)
        flowName = flowNameDecoded
    }
}

extension DescribeFlowOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeFlowOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeFlowOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeFlowOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeFlowOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.createdAt = output.createdAt
            self.createdBy = output.createdBy
            self.description = output.description
            self.destinationFlowConfigList = output.destinationFlowConfigList
            self.flowArn = output.flowArn
            self.flowName = output.flowName
            self.flowStatus = output.flowStatus
            self.flowStatusMessage = output.flowStatusMessage
            self.kmsArn = output.kmsArn
            self.lastRunExecutionDetails = output.lastRunExecutionDetails
            self.lastUpdatedAt = output.lastUpdatedAt
            self.lastUpdatedBy = output.lastUpdatedBy
            self.sourceFlowConfig = output.sourceFlowConfig
            self.tags = output.tags
            self.tasks = output.tasks
            self.triggerConfig = output.triggerConfig
        } else {
            self.createdAt = nil
            self.createdBy = nil
            self.description = nil
            self.destinationFlowConfigList = nil
            self.flowArn = nil
            self.flowName = nil
            self.flowStatus = nil
            self.flowStatusMessage = nil
            self.kmsArn = nil
            self.lastRunExecutionDetails = nil
            self.lastUpdatedAt = nil
            self.lastUpdatedBy = nil
            self.sourceFlowConfig = nil
            self.tags = nil
            self.tasks = nil
            self.triggerConfig = nil
        }
    }
}

public struct DescribeFlowOutputResponse: Swift.Equatable {
    /// Specifies when the flow was created.
    public var createdAt: ClientRuntime.Date?
    /// The ARN of the user who created the flow.
    public var createdBy: Swift.String?
    /// A description of the flow.
    public var description: Swift.String?
    /// The configuration that controls how Amazon AppFlow transfers data to the destination connector.
    public var destinationFlowConfigList: [AppflowClientTypes.DestinationFlowConfig]?
    /// The flow's Amazon Resource Name (ARN).
    public var flowArn: Swift.String?
    /// The specified name of the flow. Spaces are not allowed. Use underscores (_) or hyphens (-) only.
    public var flowName: Swift.String?
    /// Indicates the current status of the flow.
    public var flowStatus: AppflowClientTypes.FlowStatus?
    /// Contains an error message if the flow status is in a suspended or error state. This applies only to scheduled or event-triggered flows.
    public var flowStatusMessage: Swift.String?
    /// The ARN (Amazon Resource Name) of the Key Management Service (KMS) key you provide for encryption. This is required if you do not want to use the Amazon AppFlow-managed KMS key. If you don't provide anything here, Amazon AppFlow uses the Amazon AppFlow-managed KMS key.
    public var kmsArn: Swift.String?
    /// Describes the details of the most recent flow run.
    public var lastRunExecutionDetails: AppflowClientTypes.ExecutionDetails?
    /// Specifies when the flow was last updated.
    public var lastUpdatedAt: ClientRuntime.Date?
    /// Specifies the user name of the account that performed the most recent update.
    public var lastUpdatedBy: Swift.String?
    /// The configuration that controls how Amazon AppFlow retrieves data from the source connector.
    public var sourceFlowConfig: AppflowClientTypes.SourceFlowConfig?
    /// The tags used to organize, track, or control access for your flow.
    public var tags: [Swift.String:Swift.String]?
    /// A list of tasks that Amazon AppFlow performs while transferring the data in the flow run.
    public var tasks: [AppflowClientTypes.Task]?
    /// The trigger settings that determine how and when the flow runs.
    public var triggerConfig: AppflowClientTypes.TriggerConfig?

    public init (
        createdAt: ClientRuntime.Date? = nil,
        createdBy: Swift.String? = nil,
        description: Swift.String? = nil,
        destinationFlowConfigList: [AppflowClientTypes.DestinationFlowConfig]? = nil,
        flowArn: Swift.String? = nil,
        flowName: Swift.String? = nil,
        flowStatus: AppflowClientTypes.FlowStatus? = nil,
        flowStatusMessage: Swift.String? = nil,
        kmsArn: Swift.String? = nil,
        lastRunExecutionDetails: AppflowClientTypes.ExecutionDetails? = nil,
        lastUpdatedAt: ClientRuntime.Date? = nil,
        lastUpdatedBy: Swift.String? = nil,
        sourceFlowConfig: AppflowClientTypes.SourceFlowConfig? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        tasks: [AppflowClientTypes.Task]? = nil,
        triggerConfig: AppflowClientTypes.TriggerConfig? = nil
    )
    {
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.description = description
        self.destinationFlowConfigList = destinationFlowConfigList
        self.flowArn = flowArn
        self.flowName = flowName
        self.flowStatus = flowStatus
        self.flowStatusMessage = flowStatusMessage
        self.kmsArn = kmsArn
        self.lastRunExecutionDetails = lastRunExecutionDetails
        self.lastUpdatedAt = lastUpdatedAt
        self.lastUpdatedBy = lastUpdatedBy
        self.sourceFlowConfig = sourceFlowConfig
        self.tags = tags
        self.tasks = tasks
        self.triggerConfig = triggerConfig
    }
}

struct DescribeFlowOutputResponseBody: Swift.Equatable {
    let flowArn: Swift.String?
    let description: Swift.String?
    let flowName: Swift.String?
    let kmsArn: Swift.String?
    let flowStatus: AppflowClientTypes.FlowStatus?
    let flowStatusMessage: Swift.String?
    let sourceFlowConfig: AppflowClientTypes.SourceFlowConfig?
    let destinationFlowConfigList: [AppflowClientTypes.DestinationFlowConfig]?
    let lastRunExecutionDetails: AppflowClientTypes.ExecutionDetails?
    let triggerConfig: AppflowClientTypes.TriggerConfig?
    let tasks: [AppflowClientTypes.Task]?
    let createdAt: ClientRuntime.Date?
    let lastUpdatedAt: ClientRuntime.Date?
    let createdBy: Swift.String?
    let lastUpdatedBy: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension DescribeFlowOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case createdBy
        case description
        case destinationFlowConfigList
        case flowArn
        case flowName
        case flowStatus
        case flowStatusMessage
        case kmsArn
        case lastRunExecutionDetails
        case lastUpdatedAt
        case lastUpdatedBy
        case sourceFlowConfig
        case tags
        case tasks
        case triggerConfig
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowArn)
        flowArn = flowArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let flowNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowName)
        flowName = flowNameDecoded
        let kmsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsArn)
        kmsArn = kmsArnDecoded
        let flowStatusDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.FlowStatus.self, forKey: .flowStatus)
        flowStatus = flowStatusDecoded
        let flowStatusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowStatusMessage)
        flowStatusMessage = flowStatusMessageDecoded
        let sourceFlowConfigDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.SourceFlowConfig.self, forKey: .sourceFlowConfig)
        sourceFlowConfig = sourceFlowConfigDecoded
        let destinationFlowConfigListContainer = try containerValues.decodeIfPresent([AppflowClientTypes.DestinationFlowConfig?].self, forKey: .destinationFlowConfigList)
        var destinationFlowConfigListDecoded0:[AppflowClientTypes.DestinationFlowConfig]? = nil
        if let destinationFlowConfigListContainer = destinationFlowConfigListContainer {
            destinationFlowConfigListDecoded0 = [AppflowClientTypes.DestinationFlowConfig]()
            for structure0 in destinationFlowConfigListContainer {
                if let structure0 = structure0 {
                    destinationFlowConfigListDecoded0?.append(structure0)
                }
            }
        }
        destinationFlowConfigList = destinationFlowConfigListDecoded0
        let lastRunExecutionDetailsDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ExecutionDetails.self, forKey: .lastRunExecutionDetails)
        lastRunExecutionDetails = lastRunExecutionDetailsDecoded
        let triggerConfigDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.TriggerConfig.self, forKey: .triggerConfig)
        triggerConfig = triggerConfigDecoded
        let tasksContainer = try containerValues.decodeIfPresent([AppflowClientTypes.Task?].self, forKey: .tasks)
        var tasksDecoded0:[AppflowClientTypes.Task]? = nil
        if let tasksContainer = tasksContainer {
            tasksDecoded0 = [AppflowClientTypes.Task]()
            for structure0 in tasksContainer {
                if let structure0 = structure0 {
                    tasksDecoded0?.append(structure0)
                }
            }
        }
        tasks = tasksDecoded0
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let lastUpdatedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUpdatedBy)
        lastUpdatedBy = lastUpdatedByDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension AppflowClientTypes.DestinationConnectorProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customerProfiles = "CustomerProfiles"
        case eventBridge = "EventBridge"
        case honeycode = "Honeycode"
        case lookoutMetrics = "LookoutMetrics"
        case redshift = "Redshift"
        case s3 = "S3"
        case salesforce = "Salesforce"
        case snowflake = "Snowflake"
        case upsolver = "Upsolver"
        case zendesk = "Zendesk"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customerProfiles = customerProfiles {
            try encodeContainer.encode(customerProfiles, forKey: .customerProfiles)
        }
        if let eventBridge = eventBridge {
            try encodeContainer.encode(eventBridge, forKey: .eventBridge)
        }
        if let honeycode = honeycode {
            try encodeContainer.encode(honeycode, forKey: .honeycode)
        }
        if let lookoutMetrics = lookoutMetrics {
            try encodeContainer.encode(lookoutMetrics, forKey: .lookoutMetrics)
        }
        if let redshift = redshift {
            try encodeContainer.encode(redshift, forKey: .redshift)
        }
        if let s3 = s3 {
            try encodeContainer.encode(s3, forKey: .s3)
        }
        if let salesforce = salesforce {
            try encodeContainer.encode(salesforce, forKey: .salesforce)
        }
        if let snowflake = snowflake {
            try encodeContainer.encode(snowflake, forKey: .snowflake)
        }
        if let upsolver = upsolver {
            try encodeContainer.encode(upsolver, forKey: .upsolver)
        }
        if let zendesk = zendesk {
            try encodeContainer.encode(zendesk, forKey: .zendesk)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let redshiftDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.RedshiftDestinationProperties.self, forKey: .redshift)
        redshift = redshiftDecoded
        let s3Decoded = try containerValues.decodeIfPresent(AppflowClientTypes.S3DestinationProperties.self, forKey: .s3)
        s3 = s3Decoded
        let salesforceDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.SalesforceDestinationProperties.self, forKey: .salesforce)
        salesforce = salesforceDecoded
        let snowflakeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.SnowflakeDestinationProperties.self, forKey: .snowflake)
        snowflake = snowflakeDecoded
        let eventBridgeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.EventBridgeDestinationProperties.self, forKey: .eventBridge)
        eventBridge = eventBridgeDecoded
        let lookoutMetricsDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.LookoutMetricsDestinationProperties.self, forKey: .lookoutMetrics)
        lookoutMetrics = lookoutMetricsDecoded
        let upsolverDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.UpsolverDestinationProperties.self, forKey: .upsolver)
        upsolver = upsolverDecoded
        let honeycodeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.HoneycodeDestinationProperties.self, forKey: .honeycode)
        honeycode = honeycodeDecoded
        let customerProfilesDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.CustomerProfilesDestinationProperties.self, forKey: .customerProfiles)
        customerProfiles = customerProfilesDecoded
        let zendeskDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ZendeskDestinationProperties.self, forKey: .zendesk)
        zendesk = zendeskDecoded
    }
}

extension AppflowClientTypes {
    /// This stores the information that is required to query a particular connector.
    public struct DestinationConnectorProperties: Swift.Equatable {
        /// The properties required to query Amazon Connect Customer Profiles.
        public var customerProfiles: AppflowClientTypes.CustomerProfilesDestinationProperties?
        /// The properties required to query Amazon EventBridge.
        public var eventBridge: AppflowClientTypes.EventBridgeDestinationProperties?
        /// The properties required to query Amazon Honeycode.
        public var honeycode: AppflowClientTypes.HoneycodeDestinationProperties?
        /// The properties required to query Amazon Lookout for Metrics.
        public var lookoutMetrics: AppflowClientTypes.LookoutMetricsDestinationProperties?
        /// The properties required to query Amazon Redshift.
        public var redshift: AppflowClientTypes.RedshiftDestinationProperties?
        /// The properties required to query Amazon S3.
        public var s3: AppflowClientTypes.S3DestinationProperties?
        /// The properties required to query Salesforce.
        public var salesforce: AppflowClientTypes.SalesforceDestinationProperties?
        /// The properties required to query Snowflake.
        public var snowflake: AppflowClientTypes.SnowflakeDestinationProperties?
        /// The properties required to query Upsolver.
        public var upsolver: AppflowClientTypes.UpsolverDestinationProperties?
        /// The properties required to query Zendesk.
        public var zendesk: AppflowClientTypes.ZendeskDestinationProperties?

        public init (
            customerProfiles: AppflowClientTypes.CustomerProfilesDestinationProperties? = nil,
            eventBridge: AppflowClientTypes.EventBridgeDestinationProperties? = nil,
            honeycode: AppflowClientTypes.HoneycodeDestinationProperties? = nil,
            lookoutMetrics: AppflowClientTypes.LookoutMetricsDestinationProperties? = nil,
            redshift: AppflowClientTypes.RedshiftDestinationProperties? = nil,
            s3: AppflowClientTypes.S3DestinationProperties? = nil,
            salesforce: AppflowClientTypes.SalesforceDestinationProperties? = nil,
            snowflake: AppflowClientTypes.SnowflakeDestinationProperties? = nil,
            upsolver: AppflowClientTypes.UpsolverDestinationProperties? = nil,
            zendesk: AppflowClientTypes.ZendeskDestinationProperties? = nil
        )
        {
            self.customerProfiles = customerProfiles
            self.eventBridge = eventBridge
            self.honeycode = honeycode
            self.lookoutMetrics = lookoutMetrics
            self.redshift = redshift
            self.s3 = s3
            self.salesforce = salesforce
            self.snowflake = snowflake
            self.upsolver = upsolver
            self.zendesk = zendesk
        }
    }

}

extension AppflowClientTypes.DestinationFieldProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isCreatable
        case isNullable
        case isUpdatable
        case isUpsertable
        case supportedWriteOperations
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if isCreatable != false {
            try encodeContainer.encode(isCreatable, forKey: .isCreatable)
        }
        if isNullable != false {
            try encodeContainer.encode(isNullable, forKey: .isNullable)
        }
        if isUpdatable != false {
            try encodeContainer.encode(isUpdatable, forKey: .isUpdatable)
        }
        if isUpsertable != false {
            try encodeContainer.encode(isUpsertable, forKey: .isUpsertable)
        }
        if let supportedWriteOperations = supportedWriteOperations {
            var supportedWriteOperationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .supportedWriteOperations)
            for supportedwriteoperationlist0 in supportedWriteOperations {
                try supportedWriteOperationsContainer.encode(supportedwriteoperationlist0.rawValue)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let isCreatableDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isCreatable)
        isCreatable = isCreatableDecoded
        let isNullableDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isNullable)
        isNullable = isNullableDecoded
        let isUpsertableDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isUpsertable)
        isUpsertable = isUpsertableDecoded
        let isUpdatableDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isUpdatable)
        isUpdatable = isUpdatableDecoded
        let supportedWriteOperationsContainer = try containerValues.decodeIfPresent([AppflowClientTypes.WriteOperationType?].self, forKey: .supportedWriteOperations)
        var supportedWriteOperationsDecoded0:[AppflowClientTypes.WriteOperationType]? = nil
        if let supportedWriteOperationsContainer = supportedWriteOperationsContainer {
            supportedWriteOperationsDecoded0 = [AppflowClientTypes.WriteOperationType]()
            for string0 in supportedWriteOperationsContainer {
                if let string0 = string0 {
                    supportedWriteOperationsDecoded0?.append(string0)
                }
            }
        }
        supportedWriteOperations = supportedWriteOperationsDecoded0
    }
}

extension AppflowClientTypes {
    /// The properties that can be applied to a field when connector is being used as a destination.
    public struct DestinationFieldProperties: Swift.Equatable {
        /// Specifies if the destination field can be created by the current user.
        public var isCreatable: Swift.Bool
        /// Specifies if the destination field can have a null value.
        public var isNullable: Swift.Bool
        /// Specifies whether the field can be updated during an UPDATE or UPSERT write operation.
        public var isUpdatable: Swift.Bool
        /// Specifies if the flow run can either insert new rows in the destination field if they do not already exist, or update them if they do.
        public var isUpsertable: Swift.Bool
        /// A list of supported write operations. For each write operation listed, this field can be used in idFieldNames when that write operation is present as a destination option.
        public var supportedWriteOperations: [AppflowClientTypes.WriteOperationType]?

        public init (
            isCreatable: Swift.Bool = false,
            isNullable: Swift.Bool = false,
            isUpdatable: Swift.Bool = false,
            isUpsertable: Swift.Bool = false,
            supportedWriteOperations: [AppflowClientTypes.WriteOperationType]? = nil
        )
        {
            self.isCreatable = isCreatable
            self.isNullable = isNullable
            self.isUpdatable = isUpdatable
            self.isUpsertable = isUpsertable
            self.supportedWriteOperations = supportedWriteOperations
        }
    }

}

extension AppflowClientTypes.DestinationFlowConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectorProfileName
        case connectorType
        case destinationConnectorProperties
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectorProfileName = connectorProfileName {
            try encodeContainer.encode(connectorProfileName, forKey: .connectorProfileName)
        }
        if let connectorType = connectorType {
            try encodeContainer.encode(connectorType.rawValue, forKey: .connectorType)
        }
        if let destinationConnectorProperties = destinationConnectorProperties {
            try encodeContainer.encode(destinationConnectorProperties, forKey: .destinationConnectorProperties)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorTypeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ConnectorType.self, forKey: .connectorType)
        connectorType = connectorTypeDecoded
        let connectorProfileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectorProfileName)
        connectorProfileName = connectorProfileNameDecoded
        let destinationConnectorPropertiesDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.DestinationConnectorProperties.self, forKey: .destinationConnectorProperties)
        destinationConnectorProperties = destinationConnectorPropertiesDecoded
    }
}

extension AppflowClientTypes {
    /// Contains information about the configuration of destination connectors present in the flow.
    public struct DestinationFlowConfig: Swift.Equatable {
        /// The name of the connector profile. This name must be unique for each connector profile in the Amazon Web Services account.
        public var connectorProfileName: Swift.String?
        /// The type of connector, such as Salesforce, Amplitude, and so on.
        /// This member is required.
        public var connectorType: AppflowClientTypes.ConnectorType?
        /// This stores the information that is required to query a particular connector.
        /// This member is required.
        public var destinationConnectorProperties: AppflowClientTypes.DestinationConnectorProperties?

        public init (
            connectorProfileName: Swift.String? = nil,
            connectorType: AppflowClientTypes.ConnectorType? = nil,
            destinationConnectorProperties: AppflowClientTypes.DestinationConnectorProperties? = nil
        )
        {
            self.connectorProfileName = connectorProfileName
            self.connectorType = connectorType
            self.destinationConnectorProperties = destinationConnectorProperties
        }
    }

}

extension AppflowClientTypes {
    public enum DynatraceConnectorOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case addition
        case between
        case division
        case equalTo
        case maskAll
        case maskFirstN
        case maskLastN
        case multiplication
        case noOp
        case projection
        case subtraction
        case validateNonNegative
        case validateNonNull
        case validateNonZero
        case validateNumeric
        case sdkUnknown(Swift.String)

        public static var allCases: [DynatraceConnectorOperator] {
            return [
                .addition,
                .between,
                .division,
                .equalTo,
                .maskAll,
                .maskFirstN,
                .maskLastN,
                .multiplication,
                .noOp,
                .projection,
                .subtraction,
                .validateNonNegative,
                .validateNonNull,
                .validateNonZero,
                .validateNumeric,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .addition: return "ADDITION"
            case .between: return "BETWEEN"
            case .division: return "DIVISION"
            case .equalTo: return "EQUAL_TO"
            case .maskAll: return "MASK_ALL"
            case .maskFirstN: return "MASK_FIRST_N"
            case .maskLastN: return "MASK_LAST_N"
            case .multiplication: return "MULTIPLICATION"
            case .noOp: return "NO_OP"
            case .projection: return "PROJECTION"
            case .subtraction: return "SUBTRACTION"
            case .validateNonNegative: return "VALIDATE_NON_NEGATIVE"
            case .validateNonNull: return "VALIDATE_NON_NULL"
            case .validateNonZero: return "VALIDATE_NON_ZERO"
            case .validateNumeric: return "VALIDATE_NUMERIC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DynatraceConnectorOperator(rawValue: rawValue) ?? DynatraceConnectorOperator.sdkUnknown(rawValue)
        }
    }
}

extension AppflowClientTypes.DynatraceConnectorProfileCredentials: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiToken = apiToken {
            try encodeContainer.encode(apiToken, forKey: .apiToken)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiToken)
        apiToken = apiTokenDecoded
    }
}

extension AppflowClientTypes {
    /// The connector-specific profile credentials required by Dynatrace.
    public struct DynatraceConnectorProfileCredentials: Swift.Equatable {
        /// The API tokens used by Dynatrace API to authenticate various API calls.
        /// This member is required.
        public var apiToken: Swift.String?

        public init (
            apiToken: Swift.String? = nil
        )
        {
            self.apiToken = apiToken
        }
    }

}

extension AppflowClientTypes.DynatraceConnectorProfileProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceUrl
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceUrl = instanceUrl {
            try encodeContainer.encode(instanceUrl, forKey: .instanceUrl)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceUrl)
        instanceUrl = instanceUrlDecoded
    }
}

extension AppflowClientTypes {
    /// The connector-specific profile properties required by Dynatrace.
    public struct DynatraceConnectorProfileProperties: Swift.Equatable {
        /// The location of the Dynatrace resource.
        /// This member is required.
        public var instanceUrl: Swift.String?

        public init (
            instanceUrl: Swift.String? = nil
        )
        {
            self.instanceUrl = instanceUrl
        }
    }

}

extension AppflowClientTypes.DynatraceMetadata: Swift.Codable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension AppflowClientTypes {
    /// The connector metadata specific to Dynatrace.
    public struct DynatraceMetadata: Swift.Equatable {

    }

}

extension AppflowClientTypes.DynatraceSourceProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case object
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let object = object {
            try encodeContainer.encode(object, forKey: .object)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .object)
        object = objectDecoded
    }
}

extension AppflowClientTypes {
    /// The properties that are applied when Dynatrace is being used as a source.
    public struct DynatraceSourceProperties: Swift.Equatable {
        /// The object specified in the Dynatrace flow source.
        /// This member is required.
        public var object: Swift.String?

        public init (
            object: Swift.String? = nil
        )
        {
            self.object = object
        }
    }

}

extension AppflowClientTypes.ErrorHandlingConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketName
        case bucketPrefix
        case failOnFirstDestinationError
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketName = bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
        if let bucketPrefix = bucketPrefix {
            try encodeContainer.encode(bucketPrefix, forKey: .bucketPrefix)
        }
        if failOnFirstDestinationError != false {
            try encodeContainer.encode(failOnFirstDestinationError, forKey: .failOnFirstDestinationError)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failOnFirstDestinationErrorDecoded = try containerValues.decode(Swift.Bool.self, forKey: .failOnFirstDestinationError)
        failOnFirstDestinationError = failOnFirstDestinationErrorDecoded
        let bucketPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketPrefix)
        bucketPrefix = bucketPrefixDecoded
        let bucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
    }
}

extension AppflowClientTypes {
    /// The settings that determine how Amazon AppFlow handles an error when placing data in the destination. For example, this setting would determine if the flow should fail after one insertion error, or continue and attempt to insert every record regardless of the initial failure. ErrorHandlingConfig is a part of the destination connector details.
    public struct ErrorHandlingConfig: Swift.Equatable {
        /// Specifies the name of the Amazon S3 bucket.
        public var bucketName: Swift.String?
        /// Specifies the Amazon S3 bucket prefix.
        public var bucketPrefix: Swift.String?
        /// Specifies if the flow should fail after the first instance of a failure when attempting to place data in the destination.
        public var failOnFirstDestinationError: Swift.Bool

        public init (
            bucketName: Swift.String? = nil,
            bucketPrefix: Swift.String? = nil,
            failOnFirstDestinationError: Swift.Bool = false
        )
        {
            self.bucketName = bucketName
            self.bucketPrefix = bucketPrefix
            self.failOnFirstDestinationError = failOnFirstDestinationError
        }
    }

}

extension AppflowClientTypes.ErrorInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case executionMessage
        case putFailuresCount
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let executionMessage = executionMessage {
            try encodeContainer.encode(executionMessage, forKey: .executionMessage)
        }
        if let putFailuresCount = putFailuresCount {
            try encodeContainer.encode(putFailuresCount, forKey: .putFailuresCount)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let putFailuresCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .putFailuresCount)
        putFailuresCount = putFailuresCountDecoded
        let executionMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionMessage)
        executionMessage = executionMessageDecoded
    }
}

extension AppflowClientTypes {
    /// Provides details in the event of a failed flow, including the failure count and the related error messages.
    public struct ErrorInfo: Swift.Equatable {
        /// Specifies the error message that appears if a flow fails.
        public var executionMessage: Swift.String?
        /// Specifies the failure count for the attempted flow.
        public var putFailuresCount: Swift.Int?

        public init (
            executionMessage: Swift.String? = nil,
            putFailuresCount: Swift.Int? = nil
        )
        {
            self.executionMessage = executionMessage
            self.putFailuresCount = putFailuresCount
        }
    }

}

extension AppflowClientTypes.EventBridgeDestinationProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorHandlingConfig
        case object
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorHandlingConfig = errorHandlingConfig {
            try encodeContainer.encode(errorHandlingConfig, forKey: .errorHandlingConfig)
        }
        if let object = object {
            try encodeContainer.encode(object, forKey: .object)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .object)
        object = objectDecoded
        let errorHandlingConfigDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ErrorHandlingConfig.self, forKey: .errorHandlingConfig)
        errorHandlingConfig = errorHandlingConfigDecoded
    }
}

extension AppflowClientTypes {
    /// The properties that are applied when Amazon EventBridge is being used as a destination.
    public struct EventBridgeDestinationProperties: Swift.Equatable {
        /// The settings that determine how Amazon AppFlow handles an error when placing data in the destination. For example, this setting would determine if the flow should fail after one insertion error, or continue and attempt to insert every record regardless of the initial failure. ErrorHandlingConfig is a part of the destination connector details.
        public var errorHandlingConfig: AppflowClientTypes.ErrorHandlingConfig?
        /// The object specified in the Amazon EventBridge flow destination.
        /// This member is required.
        public var object: Swift.String?

        public init (
            errorHandlingConfig: AppflowClientTypes.ErrorHandlingConfig? = nil,
            object: Swift.String? = nil
        )
        {
            self.errorHandlingConfig = errorHandlingConfig
            self.object = object
        }
    }

}

extension AppflowClientTypes.EventBridgeMetadata: Swift.Codable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension AppflowClientTypes {
    /// The connector metadata specific to Amazon EventBridge.
    public struct EventBridgeMetadata: Swift.Equatable {

    }

}

extension AppflowClientTypes.ExecutionDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mostRecentExecutionMessage
        case mostRecentExecutionStatus
        case mostRecentExecutionTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let mostRecentExecutionMessage = mostRecentExecutionMessage {
            try encodeContainer.encode(mostRecentExecutionMessage, forKey: .mostRecentExecutionMessage)
        }
        if let mostRecentExecutionStatus = mostRecentExecutionStatus {
            try encodeContainer.encode(mostRecentExecutionStatus.rawValue, forKey: .mostRecentExecutionStatus)
        }
        if let mostRecentExecutionTime = mostRecentExecutionTime {
            try encodeContainer.encode(mostRecentExecutionTime.timeIntervalSince1970, forKey: .mostRecentExecutionTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mostRecentExecutionMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mostRecentExecutionMessage)
        mostRecentExecutionMessage = mostRecentExecutionMessageDecoded
        let mostRecentExecutionTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .mostRecentExecutionTime)
        mostRecentExecutionTime = mostRecentExecutionTimeDecoded
        let mostRecentExecutionStatusDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ExecutionStatus.self, forKey: .mostRecentExecutionStatus)
        mostRecentExecutionStatus = mostRecentExecutionStatusDecoded
    }
}

extension AppflowClientTypes {
    /// Describes the details of the flow run, including the timestamp, status, and message.
    public struct ExecutionDetails: Swift.Equatable {
        /// Describes the details of the most recent flow run.
        public var mostRecentExecutionMessage: Swift.String?
        /// Specifies the status of the most recent flow run.
        public var mostRecentExecutionStatus: AppflowClientTypes.ExecutionStatus?
        /// Specifies the time of the most recent flow run.
        public var mostRecentExecutionTime: ClientRuntime.Date?

        public init (
            mostRecentExecutionMessage: Swift.String? = nil,
            mostRecentExecutionStatus: AppflowClientTypes.ExecutionStatus? = nil,
            mostRecentExecutionTime: ClientRuntime.Date? = nil
        )
        {
            self.mostRecentExecutionMessage = mostRecentExecutionMessage
            self.mostRecentExecutionStatus = mostRecentExecutionStatus
            self.mostRecentExecutionTime = mostRecentExecutionTime
        }
    }

}

extension AppflowClientTypes.ExecutionRecord: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataPullEndTime
        case dataPullStartTime
        case executionId
        case executionResult
        case executionStatus
        case lastUpdatedAt
        case startedAt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataPullEndTime = dataPullEndTime {
            try encodeContainer.encode(dataPullEndTime.timeIntervalSince1970, forKey: .dataPullEndTime)
        }
        if let dataPullStartTime = dataPullStartTime {
            try encodeContainer.encode(dataPullStartTime.timeIntervalSince1970, forKey: .dataPullStartTime)
        }
        if let executionId = executionId {
            try encodeContainer.encode(executionId, forKey: .executionId)
        }
        if let executionResult = executionResult {
            try encodeContainer.encode(executionResult, forKey: .executionResult)
        }
        if let executionStatus = executionStatus {
            try encodeContainer.encode(executionStatus.rawValue, forKey: .executionStatus)
        }
        if let lastUpdatedAt = lastUpdatedAt {
            try encodeContainer.encode(lastUpdatedAt.timeIntervalSince1970, forKey: .lastUpdatedAt)
        }
        if let startedAt = startedAt {
            try encodeContainer.encode(startedAt.timeIntervalSince1970, forKey: .startedAt)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let executionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionId)
        executionId = executionIdDecoded
        let executionStatusDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ExecutionStatus.self, forKey: .executionStatus)
        executionStatus = executionStatusDecoded
        let executionResultDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ExecutionResult.self, forKey: .executionResult)
        executionResult = executionResultDecoded
        let startedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startedAt)
        startedAt = startedAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let dataPullStartTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .dataPullStartTime)
        dataPullStartTime = dataPullStartTimeDecoded
        let dataPullEndTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .dataPullEndTime)
        dataPullEndTime = dataPullEndTimeDecoded
    }
}

extension AppflowClientTypes {
    /// Specifies information about the past flow run instances for a given flow.
    public struct ExecutionRecord: Swift.Equatable {
        /// The timestamp that indicates the last new or updated record to be transferred in the flow run.
        public var dataPullEndTime: ClientRuntime.Date?
        /// The timestamp that determines the first new or updated record to be transferred in the flow run.
        public var dataPullStartTime: ClientRuntime.Date?
        /// Specifies the identifier of the given flow run.
        public var executionId: Swift.String?
        /// Describes the result of the given flow run.
        public var executionResult: AppflowClientTypes.ExecutionResult?
        /// Specifies the flow run status and whether it is in progress, has completed successfully, or has failed.
        public var executionStatus: AppflowClientTypes.ExecutionStatus?
        /// Specifies the time of the most recent update.
        public var lastUpdatedAt: ClientRuntime.Date?
        /// Specifies the start time of the flow run.
        public var startedAt: ClientRuntime.Date?

        public init (
            dataPullEndTime: ClientRuntime.Date? = nil,
            dataPullStartTime: ClientRuntime.Date? = nil,
            executionId: Swift.String? = nil,
            executionResult: AppflowClientTypes.ExecutionResult? = nil,
            executionStatus: AppflowClientTypes.ExecutionStatus? = nil,
            lastUpdatedAt: ClientRuntime.Date? = nil,
            startedAt: ClientRuntime.Date? = nil
        )
        {
            self.dataPullEndTime = dataPullEndTime
            self.dataPullStartTime = dataPullStartTime
            self.executionId = executionId
            self.executionResult = executionResult
            self.executionStatus = executionStatus
            self.lastUpdatedAt = lastUpdatedAt
            self.startedAt = startedAt
        }
    }

}

extension AppflowClientTypes.ExecutionResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bytesProcessed
        case bytesWritten
        case errorInfo
        case recordsProcessed
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bytesProcessed = bytesProcessed {
            try encodeContainer.encode(bytesProcessed, forKey: .bytesProcessed)
        }
        if let bytesWritten = bytesWritten {
            try encodeContainer.encode(bytesWritten, forKey: .bytesWritten)
        }
        if let errorInfo = errorInfo {
            try encodeContainer.encode(errorInfo, forKey: .errorInfo)
        }
        if let recordsProcessed = recordsProcessed {
            try encodeContainer.encode(recordsProcessed, forKey: .recordsProcessed)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorInfoDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ErrorInfo.self, forKey: .errorInfo)
        errorInfo = errorInfoDecoded
        let bytesProcessedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .bytesProcessed)
        bytesProcessed = bytesProcessedDecoded
        let bytesWrittenDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .bytesWritten)
        bytesWritten = bytesWrittenDecoded
        let recordsProcessedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .recordsProcessed)
        recordsProcessed = recordsProcessedDecoded
    }
}

extension AppflowClientTypes {
    /// Specifies the end result of the flow run.
    public struct ExecutionResult: Swift.Equatable {
        /// The total number of bytes processed by the flow run.
        public var bytesProcessed: Swift.Int?
        /// The total number of bytes written as a result of the flow run.
        public var bytesWritten: Swift.Int?
        /// Provides any error message information related to the flow run.
        public var errorInfo: AppflowClientTypes.ErrorInfo?
        /// The number of records processed in the flow run.
        public var recordsProcessed: Swift.Int?

        public init (
            bytesProcessed: Swift.Int? = nil,
            bytesWritten: Swift.Int? = nil,
            errorInfo: AppflowClientTypes.ErrorInfo? = nil,
            recordsProcessed: Swift.Int? = nil
        )
        {
            self.bytesProcessed = bytesProcessed
            self.bytesWritten = bytesWritten
            self.errorInfo = errorInfo
            self.recordsProcessed = recordsProcessed
        }
    }

}

extension AppflowClientTypes {
    public enum ExecutionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case error
        case inprogress
        case successful
        case sdkUnknown(Swift.String)

        public static var allCases: [ExecutionStatus] {
            return [
                .error,
                .inprogress,
                .successful,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .error: return "Error"
            case .inprogress: return "InProgress"
            case .successful: return "Successful"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ExecutionStatus(rawValue: rawValue) ?? ExecutionStatus.sdkUnknown(rawValue)
        }
    }
}

extension AppflowClientTypes.FieldTypeDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldType
        case filterOperators
        case supportedValues
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fieldType = fieldType {
            try encodeContainer.encode(fieldType, forKey: .fieldType)
        }
        if let filterOperators = filterOperators {
            var filterOperatorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filterOperators)
            for filteroperatorlist0 in filterOperators {
                try filterOperatorsContainer.encode(filteroperatorlist0.rawValue)
            }
        }
        if let supportedValues = supportedValues {
            var supportedValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .supportedValues)
            for supportedvaluelist0 in supportedValues {
                try supportedValuesContainer.encode(supportedvaluelist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fieldType)
        fieldType = fieldTypeDecoded
        let filterOperatorsContainer = try containerValues.decodeIfPresent([AppflowClientTypes.Operator?].self, forKey: .filterOperators)
        var filterOperatorsDecoded0:[AppflowClientTypes.Operator]? = nil
        if let filterOperatorsContainer = filterOperatorsContainer {
            filterOperatorsDecoded0 = [AppflowClientTypes.Operator]()
            for string0 in filterOperatorsContainer {
                if let string0 = string0 {
                    filterOperatorsDecoded0?.append(string0)
                }
            }
        }
        filterOperators = filterOperatorsDecoded0
        let supportedValuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .supportedValues)
        var supportedValuesDecoded0:[Swift.String]? = nil
        if let supportedValuesContainer = supportedValuesContainer {
            supportedValuesDecoded0 = [Swift.String]()
            for string0 in supportedValuesContainer {
                if let string0 = string0 {
                    supportedValuesDecoded0?.append(string0)
                }
            }
        }
        supportedValues = supportedValuesDecoded0
    }
}

extension AppflowClientTypes {
    /// Contains details regarding the supported field type and the operators that can be applied for filtering.
    public struct FieldTypeDetails: Swift.Equatable {
        /// The type of field, such as string, integer, date, and so on.
        /// This member is required.
        public var fieldType: Swift.String?
        /// The list of operators supported by a field.
        /// This member is required.
        public var filterOperators: [AppflowClientTypes.Operator]?
        /// The list of values that a field can contain. For example, a Boolean fieldType can have two values: "true" and "false".
        public var supportedValues: [Swift.String]?

        public init (
            fieldType: Swift.String? = nil,
            filterOperators: [AppflowClientTypes.Operator]? = nil,
            supportedValues: [Swift.String]? = nil
        )
        {
            self.fieldType = fieldType
            self.filterOperators = filterOperators
            self.supportedValues = supportedValues
        }
    }

}

extension AppflowClientTypes {
    public enum FileType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case csv
        case json
        case parquet
        case sdkUnknown(Swift.String)

        public static var allCases: [FileType] {
            return [
                .csv,
                .json,
                .parquet,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .csv: return "CSV"
            case .json: return "JSON"
            case .parquet: return "PARQUET"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FileType(rawValue: rawValue) ?? FileType.sdkUnknown(rawValue)
        }
    }
}

extension AppflowClientTypes.FlowDefinition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case createdBy
        case description
        case destinationConnectorType
        case flowArn
        case flowName
        case flowStatus
        case lastRunExecutionDetails
        case lastUpdatedAt
        case lastUpdatedBy
        case sourceConnectorType
        case tags
        case triggerType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let createdBy = createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let destinationConnectorType = destinationConnectorType {
            try encodeContainer.encode(destinationConnectorType.rawValue, forKey: .destinationConnectorType)
        }
        if let flowArn = flowArn {
            try encodeContainer.encode(flowArn, forKey: .flowArn)
        }
        if let flowName = flowName {
            try encodeContainer.encode(flowName, forKey: .flowName)
        }
        if let flowStatus = flowStatus {
            try encodeContainer.encode(flowStatus.rawValue, forKey: .flowStatus)
        }
        if let lastRunExecutionDetails = lastRunExecutionDetails {
            try encodeContainer.encode(lastRunExecutionDetails, forKey: .lastRunExecutionDetails)
        }
        if let lastUpdatedAt = lastUpdatedAt {
            try encodeContainer.encode(lastUpdatedAt.timeIntervalSince1970, forKey: .lastUpdatedAt)
        }
        if let lastUpdatedBy = lastUpdatedBy {
            try encodeContainer.encode(lastUpdatedBy, forKey: .lastUpdatedBy)
        }
        if let sourceConnectorType = sourceConnectorType {
            try encodeContainer.encode(sourceConnectorType.rawValue, forKey: .sourceConnectorType)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let triggerType = triggerType {
            try encodeContainer.encode(triggerType.rawValue, forKey: .triggerType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowArn)
        flowArn = flowArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let flowNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowName)
        flowName = flowNameDecoded
        let flowStatusDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.FlowStatus.self, forKey: .flowStatus)
        flowStatus = flowStatusDecoded
        let sourceConnectorTypeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ConnectorType.self, forKey: .sourceConnectorType)
        sourceConnectorType = sourceConnectorTypeDecoded
        let destinationConnectorTypeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ConnectorType.self, forKey: .destinationConnectorType)
        destinationConnectorType = destinationConnectorTypeDecoded
        let triggerTypeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.TriggerType.self, forKey: .triggerType)
        triggerType = triggerTypeDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let lastUpdatedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUpdatedBy)
        lastUpdatedBy = lastUpdatedByDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let lastRunExecutionDetailsDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ExecutionDetails.self, forKey: .lastRunExecutionDetails)
        lastRunExecutionDetails = lastRunExecutionDetailsDecoded
    }
}

extension AppflowClientTypes {
    /// The properties of the flow, such as its source, destination, trigger type, and so on.
    public struct FlowDefinition: Swift.Equatable {
        /// Specifies when the flow was created.
        public var createdAt: ClientRuntime.Date?
        /// The ARN of the user who created the flow.
        public var createdBy: Swift.String?
        /// A user-entered description of the flow.
        public var description: Swift.String?
        /// Specifies the destination connector type, such as Salesforce, Amazon S3, Amplitude, and so on.
        public var destinationConnectorType: AppflowClientTypes.ConnectorType?
        /// The flow's Amazon Resource Name (ARN).
        public var flowArn: Swift.String?
        /// The specified name of the flow. Spaces are not allowed. Use underscores (_) or hyphens (-) only.
        public var flowName: Swift.String?
        /// Indicates the current status of the flow.
        public var flowStatus: AppflowClientTypes.FlowStatus?
        /// Describes the details of the most recent flow run.
        public var lastRunExecutionDetails: AppflowClientTypes.ExecutionDetails?
        /// Specifies when the flow was last updated.
        public var lastUpdatedAt: ClientRuntime.Date?
        /// Specifies the account user name that most recently updated the flow.
        public var lastUpdatedBy: Swift.String?
        /// Specifies the source connector type, such as Salesforce, Amazon S3, Amplitude, and so on.
        public var sourceConnectorType: AppflowClientTypes.ConnectorType?
        /// The tags used to organize, track, or control access for your flow.
        public var tags: [Swift.String:Swift.String]?
        /// Specifies the type of flow trigger. This can be OnDemand, Scheduled, or Event.
        public var triggerType: AppflowClientTypes.TriggerType?

        public init (
            createdAt: ClientRuntime.Date? = nil,
            createdBy: Swift.String? = nil,
            description: Swift.String? = nil,
            destinationConnectorType: AppflowClientTypes.ConnectorType? = nil,
            flowArn: Swift.String? = nil,
            flowName: Swift.String? = nil,
            flowStatus: AppflowClientTypes.FlowStatus? = nil,
            lastRunExecutionDetails: AppflowClientTypes.ExecutionDetails? = nil,
            lastUpdatedAt: ClientRuntime.Date? = nil,
            lastUpdatedBy: Swift.String? = nil,
            sourceConnectorType: AppflowClientTypes.ConnectorType? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            triggerType: AppflowClientTypes.TriggerType? = nil
        )
        {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.destinationConnectorType = destinationConnectorType
            self.flowArn = flowArn
            self.flowName = flowName
            self.flowStatus = flowStatus
            self.lastRunExecutionDetails = lastRunExecutionDetails
            self.lastUpdatedAt = lastUpdatedAt
            self.lastUpdatedBy = lastUpdatedBy
            self.sourceConnectorType = sourceConnectorType
            self.tags = tags
            self.triggerType = triggerType
        }
    }

}

extension AppflowClientTypes {
    public enum FlowStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case deleted
        case deprecated
        case draft
        case errored
        case suspended
        case sdkUnknown(Swift.String)

        public static var allCases: [FlowStatus] {
            return [
                .active,
                .deleted,
                .deprecated,
                .draft,
                .errored,
                .suspended,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "Active"
            case .deleted: return "Deleted"
            case .deprecated: return "Deprecated"
            case .draft: return "Draft"
            case .errored: return "Errored"
            case .suspended: return "Suspended"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FlowStatus(rawValue: rawValue) ?? FlowStatus.sdkUnknown(rawValue)
        }
    }
}

extension AppflowClientTypes {
    public enum GoogleAnalyticsConnectorOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case between
        case projection
        case sdkUnknown(Swift.String)

        public static var allCases: [GoogleAnalyticsConnectorOperator] {
            return [
                .between,
                .projection,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .between: return "BETWEEN"
            case .projection: return "PROJECTION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = GoogleAnalyticsConnectorOperator(rawValue: rawValue) ?? GoogleAnalyticsConnectorOperator.sdkUnknown(rawValue)
        }
    }
}

extension AppflowClientTypes.GoogleAnalyticsConnectorProfileCredentials: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessToken
        case clientId
        case clientSecret
        case oAuthRequest
        case refreshToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessToken = accessToken {
            try encodeContainer.encode(accessToken, forKey: .accessToken)
        }
        if let clientId = clientId {
            try encodeContainer.encode(clientId, forKey: .clientId)
        }
        if let clientSecret = clientSecret {
            try encodeContainer.encode(clientSecret, forKey: .clientSecret)
        }
        if let oAuthRequest = oAuthRequest {
            try encodeContainer.encode(oAuthRequest, forKey: .oAuthRequest)
        }
        if let refreshToken = refreshToken {
            try encodeContainer.encode(refreshToken, forKey: .refreshToken)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientId)
        clientId = clientIdDecoded
        let clientSecretDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientSecret)
        clientSecret = clientSecretDecoded
        let accessTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessToken)
        accessToken = accessTokenDecoded
        let refreshTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .refreshToken)
        refreshToken = refreshTokenDecoded
        let oAuthRequestDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ConnectorOAuthRequest.self, forKey: .oAuthRequest)
        oAuthRequest = oAuthRequestDecoded
    }
}

extension AppflowClientTypes {
    /// The connector-specific profile credentials required by Google Analytics.
    public struct GoogleAnalyticsConnectorProfileCredentials: Swift.Equatable {
        /// The credentials used to access protected Google Analytics resources.
        public var accessToken: Swift.String?
        /// The identifier for the desired client.
        /// This member is required.
        public var clientId: Swift.String?
        /// The client secret used by the OAuth client to authenticate to the authorization server.
        /// This member is required.
        public var clientSecret: Swift.String?
        /// The OAuth requirement needed to request security tokens from the connector endpoint.
        public var oAuthRequest: AppflowClientTypes.ConnectorOAuthRequest?
        /// The credentials used to acquire new access tokens. This is required only for OAuth2 access tokens, and is not required for OAuth1 access tokens.
        public var refreshToken: Swift.String?

        public init (
            accessToken: Swift.String? = nil,
            clientId: Swift.String? = nil,
            clientSecret: Swift.String? = nil,
            oAuthRequest: AppflowClientTypes.ConnectorOAuthRequest? = nil,
            refreshToken: Swift.String? = nil
        )
        {
            self.accessToken = accessToken
            self.clientId = clientId
            self.clientSecret = clientSecret
            self.oAuthRequest = oAuthRequest
            self.refreshToken = refreshToken
        }
    }

}

extension AppflowClientTypes.GoogleAnalyticsConnectorProfileProperties: Swift.Codable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension AppflowClientTypes {
    /// The connector-specific profile properties required by Google Analytics.
    public struct GoogleAnalyticsConnectorProfileProperties: Swift.Equatable {

    }

}

extension AppflowClientTypes.GoogleAnalyticsMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case oAuthScopes
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let oAuthScopes = oAuthScopes {
            var oAuthScopesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .oAuthScopes)
            for oauthscopelist0 in oAuthScopes {
                try oAuthScopesContainer.encode(oauthscopelist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let oAuthScopesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .oAuthScopes)
        var oAuthScopesDecoded0:[Swift.String]? = nil
        if let oAuthScopesContainer = oAuthScopesContainer {
            oAuthScopesDecoded0 = [Swift.String]()
            for string0 in oAuthScopesContainer {
                if let string0 = string0 {
                    oAuthScopesDecoded0?.append(string0)
                }
            }
        }
        oAuthScopes = oAuthScopesDecoded0
    }
}

extension AppflowClientTypes {
    /// The connector metadata specific to Google Analytics.
    public struct GoogleAnalyticsMetadata: Swift.Equatable {
        /// The desired authorization scope for the Google Analytics account.
        public var oAuthScopes: [Swift.String]?

        public init (
            oAuthScopes: [Swift.String]? = nil
        )
        {
            self.oAuthScopes = oAuthScopes
        }
    }

}

extension AppflowClientTypes.GoogleAnalyticsSourceProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case object
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let object = object {
            try encodeContainer.encode(object, forKey: .object)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .object)
        object = objectDecoded
    }
}

extension AppflowClientTypes {
    /// The properties that are applied when Google Analytics is being used as a source.
    public struct GoogleAnalyticsSourceProperties: Swift.Equatable {
        /// The object specified in the Google Analytics flow source.
        /// This member is required.
        public var object: Swift.String?

        public init (
            object: Swift.String? = nil
        )
        {
            self.object = object
        }
    }

}

extension AppflowClientTypes.HoneycodeConnectorProfileCredentials: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessToken
        case oAuthRequest
        case refreshToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessToken = accessToken {
            try encodeContainer.encode(accessToken, forKey: .accessToken)
        }
        if let oAuthRequest = oAuthRequest {
            try encodeContainer.encode(oAuthRequest, forKey: .oAuthRequest)
        }
        if let refreshToken = refreshToken {
            try encodeContainer.encode(refreshToken, forKey: .refreshToken)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessToken)
        accessToken = accessTokenDecoded
        let refreshTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .refreshToken)
        refreshToken = refreshTokenDecoded
        let oAuthRequestDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ConnectorOAuthRequest.self, forKey: .oAuthRequest)
        oAuthRequest = oAuthRequestDecoded
    }
}

extension AppflowClientTypes {
    /// The connector-specific credentials required when using Amazon Honeycode.
    public struct HoneycodeConnectorProfileCredentials: Swift.Equatable {
        /// The credentials used to access protected Amazon Honeycode resources.
        public var accessToken: Swift.String?
        /// Used by select connectors for which the OAuth workflow is supported, such as Salesforce, Google Analytics, Marketo, Zendesk, and Slack.
        public var oAuthRequest: AppflowClientTypes.ConnectorOAuthRequest?
        /// The credentials used to acquire new access tokens.
        public var refreshToken: Swift.String?

        public init (
            accessToken: Swift.String? = nil,
            oAuthRequest: AppflowClientTypes.ConnectorOAuthRequest? = nil,
            refreshToken: Swift.String? = nil
        )
        {
            self.accessToken = accessToken
            self.oAuthRequest = oAuthRequest
            self.refreshToken = refreshToken
        }
    }

}

extension AppflowClientTypes.HoneycodeConnectorProfileProperties: Swift.Codable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension AppflowClientTypes {
    /// The connector-specific properties required when using Amazon Honeycode.
    public struct HoneycodeConnectorProfileProperties: Swift.Equatable {

    }

}

extension AppflowClientTypes.HoneycodeDestinationProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorHandlingConfig
        case object
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorHandlingConfig = errorHandlingConfig {
            try encodeContainer.encode(errorHandlingConfig, forKey: .errorHandlingConfig)
        }
        if let object = object {
            try encodeContainer.encode(object, forKey: .object)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .object)
        object = objectDecoded
        let errorHandlingConfigDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ErrorHandlingConfig.self, forKey: .errorHandlingConfig)
        errorHandlingConfig = errorHandlingConfigDecoded
    }
}

extension AppflowClientTypes {
    /// The properties that are applied when Amazon Honeycode is used as a destination.
    public struct HoneycodeDestinationProperties: Swift.Equatable {
        /// The settings that determine how Amazon AppFlow handles an error when placing data in the destination. For example, this setting would determine if the flow should fail after one insertion error, or continue and attempt to insert every record regardless of the initial failure. ErrorHandlingConfig is a part of the destination connector details.
        public var errorHandlingConfig: AppflowClientTypes.ErrorHandlingConfig?
        /// The object specified in the Amazon Honeycode flow destination.
        /// This member is required.
        public var object: Swift.String?

        public init (
            errorHandlingConfig: AppflowClientTypes.ErrorHandlingConfig? = nil,
            object: Swift.String? = nil
        )
        {
            self.errorHandlingConfig = errorHandlingConfig
            self.object = object
        }
    }

}

extension AppflowClientTypes.HoneycodeMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case oAuthScopes
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let oAuthScopes = oAuthScopes {
            var oAuthScopesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .oAuthScopes)
            for oauthscopelist0 in oAuthScopes {
                try oAuthScopesContainer.encode(oauthscopelist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let oAuthScopesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .oAuthScopes)
        var oAuthScopesDecoded0:[Swift.String]? = nil
        if let oAuthScopesContainer = oAuthScopesContainer {
            oAuthScopesDecoded0 = [Swift.String]()
            for string0 in oAuthScopesContainer {
                if let string0 = string0 {
                    oAuthScopesDecoded0?.append(string0)
                }
            }
        }
        oAuthScopes = oAuthScopesDecoded0
    }
}

extension AppflowClientTypes {
    /// The connector metadata specific to Amazon Honeycode.
    public struct HoneycodeMetadata: Swift.Equatable {
        /// The desired authorization scope for the Amazon Honeycode account.
        public var oAuthScopes: [Swift.String]?

        public init (
            oAuthScopes: [Swift.String]? = nil
        )
        {
            self.oAuthScopes = oAuthScopes
        }
    }

}

extension AppflowClientTypes.IncrementalPullConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datetimeTypeFieldName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datetimeTypeFieldName = datetimeTypeFieldName {
            try encodeContainer.encode(datetimeTypeFieldName, forKey: .datetimeTypeFieldName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datetimeTypeFieldNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datetimeTypeFieldName)
        datetimeTypeFieldName = datetimeTypeFieldNameDecoded
    }
}

extension AppflowClientTypes {
    /// Specifies the configuration used when importing incremental records from the source.
    public struct IncrementalPullConfig: Swift.Equatable {
        /// A field that specifies the date time or timestamp field as the criteria to use when importing incremental records from the source.
        public var datetimeTypeFieldName: Swift.String?

        public init (
            datetimeTypeFieldName: Swift.String? = nil
        )
        {
            self.datetimeTypeFieldName = datetimeTypeFieldName
        }
    }

}

extension AppflowClientTypes {
    public enum InforNexusConnectorOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case addition
        case between
        case division
        case equalTo
        case maskAll
        case maskFirstN
        case maskLastN
        case multiplication
        case noOp
        case projection
        case subtraction
        case validateNonNegative
        case validateNonNull
        case validateNonZero
        case validateNumeric
        case sdkUnknown(Swift.String)

        public static var allCases: [InforNexusConnectorOperator] {
            return [
                .addition,
                .between,
                .division,
                .equalTo,
                .maskAll,
                .maskFirstN,
                .maskLastN,
                .multiplication,
                .noOp,
                .projection,
                .subtraction,
                .validateNonNegative,
                .validateNonNull,
                .validateNonZero,
                .validateNumeric,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .addition: return "ADDITION"
            case .between: return "BETWEEN"
            case .division: return "DIVISION"
            case .equalTo: return "EQUAL_TO"
            case .maskAll: return "MASK_ALL"
            case .maskFirstN: return "MASK_FIRST_N"
            case .maskLastN: return "MASK_LAST_N"
            case .multiplication: return "MULTIPLICATION"
            case .noOp: return "NO_OP"
            case .projection: return "PROJECTION"
            case .subtraction: return "SUBTRACTION"
            case .validateNonNegative: return "VALIDATE_NON_NEGATIVE"
            case .validateNonNull: return "VALIDATE_NON_NULL"
            case .validateNonZero: return "VALIDATE_NON_ZERO"
            case .validateNumeric: return "VALIDATE_NUMERIC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = InforNexusConnectorOperator(rawValue: rawValue) ?? InforNexusConnectorOperator.sdkUnknown(rawValue)
        }
    }
}

extension AppflowClientTypes.InforNexusConnectorProfileCredentials: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessKeyId
        case datakey
        case secretAccessKey
        case userId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessKeyId = accessKeyId {
            try encodeContainer.encode(accessKeyId, forKey: .accessKeyId)
        }
        if let datakey = datakey {
            try encodeContainer.encode(datakey, forKey: .datakey)
        }
        if let secretAccessKey = secretAccessKey {
            try encodeContainer.encode(secretAccessKey, forKey: .secretAccessKey)
        }
        if let userId = userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessKeyId)
        accessKeyId = accessKeyIdDecoded
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
        let secretAccessKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretAccessKey)
        secretAccessKey = secretAccessKeyDecoded
        let datakeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datakey)
        datakey = datakeyDecoded
    }
}

extension AppflowClientTypes {
    /// The connector-specific profile credentials required by Infor Nexus.
    public struct InforNexusConnectorProfileCredentials: Swift.Equatable {
        /// The Access Key portion of the credentials.
        /// This member is required.
        public var accessKeyId: Swift.String?
        /// The encryption keys used to encrypt data.
        /// This member is required.
        public var datakey: Swift.String?
        /// The secret key used to sign requests.
        /// This member is required.
        public var secretAccessKey: Swift.String?
        /// The identifier for the user.
        /// This member is required.
        public var userId: Swift.String?

        public init (
            accessKeyId: Swift.String? = nil,
            datakey: Swift.String? = nil,
            secretAccessKey: Swift.String? = nil,
            userId: Swift.String? = nil
        )
        {
            self.accessKeyId = accessKeyId
            self.datakey = datakey
            self.secretAccessKey = secretAccessKey
            self.userId = userId
        }
    }

}

extension AppflowClientTypes.InforNexusConnectorProfileProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceUrl
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceUrl = instanceUrl {
            try encodeContainer.encode(instanceUrl, forKey: .instanceUrl)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceUrl)
        instanceUrl = instanceUrlDecoded
    }
}

extension AppflowClientTypes {
    /// The connector-specific profile properties required by Infor Nexus.
    public struct InforNexusConnectorProfileProperties: Swift.Equatable {
        /// The location of the Infor Nexus resource.
        /// This member is required.
        public var instanceUrl: Swift.String?

        public init (
            instanceUrl: Swift.String? = nil
        )
        {
            self.instanceUrl = instanceUrl
        }
    }

}

extension AppflowClientTypes.InforNexusMetadata: Swift.Codable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension AppflowClientTypes {
    /// The connector metadata specific to Infor Nexus.
    public struct InforNexusMetadata: Swift.Equatable {

    }

}

extension AppflowClientTypes.InforNexusSourceProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case object
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let object = object {
            try encodeContainer.encode(object, forKey: .object)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .object)
        object = objectDecoded
    }
}

extension AppflowClientTypes {
    /// The properties that are applied when Infor Nexus is being used as a source.
    public struct InforNexusSourceProperties: Swift.Equatable {
        /// The object specified in the Infor Nexus flow source.
        /// This member is required.
        public var object: Swift.String?

        public init (
            object: Swift.String? = nil
        )
        {
            self.object = object
        }
    }

}

extension InternalServerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An internal service error occurred during the processing of your request. Try again later.
public struct InternalServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListConnectorEntitiesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectorProfileName
        case connectorType
        case entitiesPath
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectorProfileName = connectorProfileName {
            try encodeContainer.encode(connectorProfileName, forKey: .connectorProfileName)
        }
        if let connectorType = connectorType {
            try encodeContainer.encode(connectorType.rawValue, forKey: .connectorType)
        }
        if let entitiesPath = entitiesPath {
            try encodeContainer.encode(entitiesPath, forKey: .entitiesPath)
        }
    }
}

extension ListConnectorEntitiesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/list-connector-entities"
    }
}

public struct ListConnectorEntitiesInput: Swift.Equatable {
    /// The name of the connector profile. The name is unique for each ConnectorProfile in the Amazon Web Services account, and is used to query the downstream connector.
    public var connectorProfileName: Swift.String?
    /// The type of connector, such as Salesforce, Amplitude, and so on.
    public var connectorType: AppflowClientTypes.ConnectorType?
    /// This optional parameter is specific to connector implementation. Some connectors support multiple levels or categories of entities. You can find out the list of roots for such providers by sending a request without the entitiesPath parameter. If the connector supports entities at different roots, this initial request returns the list of roots. Otherwise, this request returns all entities supported by the provider.
    public var entitiesPath: Swift.String?

    public init (
        connectorProfileName: Swift.String? = nil,
        connectorType: AppflowClientTypes.ConnectorType? = nil,
        entitiesPath: Swift.String? = nil
    )
    {
        self.connectorProfileName = connectorProfileName
        self.connectorType = connectorType
        self.entitiesPath = entitiesPath
    }
}

struct ListConnectorEntitiesInputBody: Swift.Equatable {
    let connectorProfileName: Swift.String?
    let connectorType: AppflowClientTypes.ConnectorType?
    let entitiesPath: Swift.String?
}

extension ListConnectorEntitiesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectorProfileName
        case connectorType
        case entitiesPath
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorProfileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectorProfileName)
        connectorProfileName = connectorProfileNameDecoded
        let connectorTypeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ConnectorType.self, forKey: .connectorType)
        connectorType = connectorTypeDecoded
        let entitiesPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entitiesPath)
        entitiesPath = entitiesPathDecoded
    }
}

extension ListConnectorEntitiesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListConnectorEntitiesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConnectorAuthenticationException" : self = .connectorAuthenticationException(try ConnectorAuthenticationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConnectorServerException" : self = .connectorServerException(try ConnectorServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListConnectorEntitiesOutputError: Swift.Error, Swift.Equatable {
    case connectorAuthenticationException(ConnectorAuthenticationException)
    case connectorServerException(ConnectorServerException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListConnectorEntitiesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListConnectorEntitiesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.connectorEntityMap = output.connectorEntityMap
        } else {
            self.connectorEntityMap = nil
        }
    }
}

public struct ListConnectorEntitiesOutputResponse: Swift.Equatable {
    /// The response of ListConnectorEntities lists entities grouped by category. This map's key represents the group name, and its value contains the list of entities belonging to that group.
    /// This member is required.
    public var connectorEntityMap: [Swift.String:[AppflowClientTypes.ConnectorEntity]]?

    public init (
        connectorEntityMap: [Swift.String:[AppflowClientTypes.ConnectorEntity]]? = nil
    )
    {
        self.connectorEntityMap = connectorEntityMap
    }
}

struct ListConnectorEntitiesOutputResponseBody: Swift.Equatable {
    let connectorEntityMap: [Swift.String:[AppflowClientTypes.ConnectorEntity]]?
}

extension ListConnectorEntitiesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectorEntityMap
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorEntityMapContainer = try containerValues.decodeIfPresent([Swift.String: [AppflowClientTypes.ConnectorEntity?]?].self, forKey: .connectorEntityMap)
        var connectorEntityMapDecoded0: [Swift.String:[AppflowClientTypes.ConnectorEntity]]? = nil
        if let connectorEntityMapContainer = connectorEntityMapContainer {
            connectorEntityMapDecoded0 = [Swift.String:[AppflowClientTypes.ConnectorEntity]]()
            for (key0, connectorentitylist0) in connectorEntityMapContainer {
                var connectorentitylist0Decoded0: [AppflowClientTypes.ConnectorEntity]? = nil
                if let connectorentitylist0 = connectorentitylist0 {
                    connectorentitylist0Decoded0 = [AppflowClientTypes.ConnectorEntity]()
                    for structure1 in connectorentitylist0 {
                        if let structure1 = structure1 {
                            connectorentitylist0Decoded0?.append(structure1)
                        }
                    }
                }
                connectorEntityMapDecoded0?[key0] = connectorentitylist0Decoded0
            }
        }
        connectorEntityMap = connectorEntityMapDecoded0
    }
}

extension ListFlowsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListFlowsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/list-flows"
    }
}

public struct ListFlowsInput: Swift.Equatable {
    /// Specifies the maximum number of items that should be returned in the result set.
    public var maxResults: Swift.Int?
    /// The pagination token for next page of data.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListFlowsInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListFlowsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListFlowsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListFlowsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListFlowsOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListFlowsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListFlowsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.flows = output.flows
            self.nextToken = output.nextToken
        } else {
            self.flows = nil
            self.nextToken = nil
        }
    }
}

public struct ListFlowsOutputResponse: Swift.Equatable {
    /// The list of flows associated with your account.
    public var flows: [AppflowClientTypes.FlowDefinition]?
    /// The pagination token for next page of data.
    public var nextToken: Swift.String?

    public init (
        flows: [AppflowClientTypes.FlowDefinition]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.flows = flows
        self.nextToken = nextToken
    }
}

struct ListFlowsOutputResponseBody: Swift.Equatable {
    let flows: [AppflowClientTypes.FlowDefinition]?
    let nextToken: Swift.String?
}

extension ListFlowsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case flows
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowsContainer = try containerValues.decodeIfPresent([AppflowClientTypes.FlowDefinition?].self, forKey: .flows)
        var flowsDecoded0:[AppflowClientTypes.FlowDefinition]? = nil
        if let flowsContainer = flowsContainer {
            flowsDecoded0 = [AppflowClientTypes.FlowDefinition]()
            for structure0 in flowsContainer {
                if let structure0 = structure0 {
                    flowsDecoded0?.append(structure0)
                }
            }
        }
        flows = flowsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the specified flow.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// The tags used to organize, track, or control access for your flow.
    public var tags: [Swift.String:Swift.String]?

    public init (
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension AppflowClientTypes.LookoutMetricsDestinationProperties: Swift.Codable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension AppflowClientTypes {
    /// The properties that are applied when Amazon Lookout for Metrics is used as a destination.
    public struct LookoutMetricsDestinationProperties: Swift.Equatable {

    }

}

extension AppflowClientTypes {
    public enum MarketoConnectorOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case addition
        case between
        case division
        case greaterThan
        case lessThan
        case maskAll
        case maskFirstN
        case maskLastN
        case multiplication
        case noOp
        case projection
        case subtraction
        case validateNonNegative
        case validateNonNull
        case validateNonZero
        case validateNumeric
        case sdkUnknown(Swift.String)

        public static var allCases: [MarketoConnectorOperator] {
            return [
                .addition,
                .between,
                .division,
                .greaterThan,
                .lessThan,
                .maskAll,
                .maskFirstN,
                .maskLastN,
                .multiplication,
                .noOp,
                .projection,
                .subtraction,
                .validateNonNegative,
                .validateNonNull,
                .validateNonZero,
                .validateNumeric,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .addition: return "ADDITION"
            case .between: return "BETWEEN"
            case .division: return "DIVISION"
            case .greaterThan: return "GREATER_THAN"
            case .lessThan: return "LESS_THAN"
            case .maskAll: return "MASK_ALL"
            case .maskFirstN: return "MASK_FIRST_N"
            case .maskLastN: return "MASK_LAST_N"
            case .multiplication: return "MULTIPLICATION"
            case .noOp: return "NO_OP"
            case .projection: return "PROJECTION"
            case .subtraction: return "SUBTRACTION"
            case .validateNonNegative: return "VALIDATE_NON_NEGATIVE"
            case .validateNonNull: return "VALIDATE_NON_NULL"
            case .validateNonZero: return "VALIDATE_NON_ZERO"
            case .validateNumeric: return "VALIDATE_NUMERIC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MarketoConnectorOperator(rawValue: rawValue) ?? MarketoConnectorOperator.sdkUnknown(rawValue)
        }
    }
}

extension AppflowClientTypes.MarketoConnectorProfileCredentials: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessToken
        case clientId
        case clientSecret
        case oAuthRequest
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessToken = accessToken {
            try encodeContainer.encode(accessToken, forKey: .accessToken)
        }
        if let clientId = clientId {
            try encodeContainer.encode(clientId, forKey: .clientId)
        }
        if let clientSecret = clientSecret {
            try encodeContainer.encode(clientSecret, forKey: .clientSecret)
        }
        if let oAuthRequest = oAuthRequest {
            try encodeContainer.encode(oAuthRequest, forKey: .oAuthRequest)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientId)
        clientId = clientIdDecoded
        let clientSecretDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientSecret)
        clientSecret = clientSecretDecoded
        let accessTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessToken)
        accessToken = accessTokenDecoded
        let oAuthRequestDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ConnectorOAuthRequest.self, forKey: .oAuthRequest)
        oAuthRequest = oAuthRequestDecoded
    }
}

extension AppflowClientTypes {
    /// The connector-specific profile credentials required by Marketo.
    public struct MarketoConnectorProfileCredentials: Swift.Equatable {
        /// The credentials used to access protected Marketo resources.
        public var accessToken: Swift.String?
        /// The identifier for the desired client.
        /// This member is required.
        public var clientId: Swift.String?
        /// The client secret used by the OAuth client to authenticate to the authorization server.
        /// This member is required.
        public var clientSecret: Swift.String?
        /// The OAuth requirement needed to request security tokens from the connector endpoint.
        public var oAuthRequest: AppflowClientTypes.ConnectorOAuthRequest?

        public init (
            accessToken: Swift.String? = nil,
            clientId: Swift.String? = nil,
            clientSecret: Swift.String? = nil,
            oAuthRequest: AppflowClientTypes.ConnectorOAuthRequest? = nil
        )
        {
            self.accessToken = accessToken
            self.clientId = clientId
            self.clientSecret = clientSecret
            self.oAuthRequest = oAuthRequest
        }
    }

}

extension AppflowClientTypes.MarketoConnectorProfileProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceUrl
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceUrl = instanceUrl {
            try encodeContainer.encode(instanceUrl, forKey: .instanceUrl)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceUrl)
        instanceUrl = instanceUrlDecoded
    }
}

extension AppflowClientTypes {
    /// The connector-specific profile properties required when using Marketo.
    public struct MarketoConnectorProfileProperties: Swift.Equatable {
        /// The location of the Marketo resource.
        /// This member is required.
        public var instanceUrl: Swift.String?

        public init (
            instanceUrl: Swift.String? = nil
        )
        {
            self.instanceUrl = instanceUrl
        }
    }

}

extension AppflowClientTypes.MarketoMetadata: Swift.Codable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension AppflowClientTypes {
    /// The connector metadata specific to Marketo.
    public struct MarketoMetadata: Swift.Equatable {

    }

}

extension AppflowClientTypes.MarketoSourceProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case object
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let object = object {
            try encodeContainer.encode(object, forKey: .object)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .object)
        object = objectDecoded
    }
}

extension AppflowClientTypes {
    /// The properties that are applied when Marketo is being used as a source.
    public struct MarketoSourceProperties: Swift.Equatable {
        /// The object specified in the Marketo flow source.
        /// This member is required.
        public var object: Swift.String?

        public init (
            object: Swift.String? = nil
        )
        {
            self.object = object
        }
    }

}

extension AppflowClientTypes.OAuthCredentials: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessToken
        case clientId
        case clientSecret
        case oAuthRequest
        case refreshToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessToken = accessToken {
            try encodeContainer.encode(accessToken, forKey: .accessToken)
        }
        if let clientId = clientId {
            try encodeContainer.encode(clientId, forKey: .clientId)
        }
        if let clientSecret = clientSecret {
            try encodeContainer.encode(clientSecret, forKey: .clientSecret)
        }
        if let oAuthRequest = oAuthRequest {
            try encodeContainer.encode(oAuthRequest, forKey: .oAuthRequest)
        }
        if let refreshToken = refreshToken {
            try encodeContainer.encode(refreshToken, forKey: .refreshToken)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientId)
        clientId = clientIdDecoded
        let clientSecretDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientSecret)
        clientSecret = clientSecretDecoded
        let accessTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessToken)
        accessToken = accessTokenDecoded
        let refreshTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .refreshToken)
        refreshToken = refreshTokenDecoded
        let oAuthRequestDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ConnectorOAuthRequest.self, forKey: .oAuthRequest)
        oAuthRequest = oAuthRequestDecoded
    }
}

extension AppflowClientTypes {
    /// The OAuth credentials required for OAuth type authentication.
    public struct OAuthCredentials: Swift.Equatable {
        /// The access token used to access protected SAPOData resources.
        public var accessToken: Swift.String?
        /// The identifier for the desired client.
        /// This member is required.
        public var clientId: Swift.String?
        /// The client secret used by the OAuth client to authenticate to the authorization server.
        /// This member is required.
        public var clientSecret: Swift.String?
        /// The OAuth requirement needed to request security tokens from the connector endpoint.
        public var oAuthRequest: AppflowClientTypes.ConnectorOAuthRequest?
        /// The refresh token used to refresh expired access token.
        public var refreshToken: Swift.String?

        public init (
            accessToken: Swift.String? = nil,
            clientId: Swift.String? = nil,
            clientSecret: Swift.String? = nil,
            oAuthRequest: AppflowClientTypes.ConnectorOAuthRequest? = nil,
            refreshToken: Swift.String? = nil
        )
        {
            self.accessToken = accessToken
            self.clientId = clientId
            self.clientSecret = clientSecret
            self.oAuthRequest = oAuthRequest
            self.refreshToken = refreshToken
        }
    }

}

extension AppflowClientTypes.OAuthProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authCodeUrl
        case oAuthScopes
        case tokenUrl
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authCodeUrl = authCodeUrl {
            try encodeContainer.encode(authCodeUrl, forKey: .authCodeUrl)
        }
        if let oAuthScopes = oAuthScopes {
            var oAuthScopesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .oAuthScopes)
            for oauthscopelist0 in oAuthScopes {
                try oAuthScopesContainer.encode(oauthscopelist0)
            }
        }
        if let tokenUrl = tokenUrl {
            try encodeContainer.encode(tokenUrl, forKey: .tokenUrl)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tokenUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tokenUrl)
        tokenUrl = tokenUrlDecoded
        let authCodeUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authCodeUrl)
        authCodeUrl = authCodeUrlDecoded
        let oAuthScopesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .oAuthScopes)
        var oAuthScopesDecoded0:[Swift.String]? = nil
        if let oAuthScopesContainer = oAuthScopesContainer {
            oAuthScopesDecoded0 = [Swift.String]()
            for string0 in oAuthScopesContainer {
                if let string0 = string0 {
                    oAuthScopesDecoded0?.append(string0)
                }
            }
        }
        oAuthScopes = oAuthScopesDecoded0
    }
}

extension AppflowClientTypes {
    /// The OAuth properties required for OAuth type authentication.
    public struct OAuthProperties: Swift.Equatable {
        /// The authorization code url required to redirect to SAP Login Page to fetch authorization code for OAuth type authentication.
        /// This member is required.
        public var authCodeUrl: Swift.String?
        /// The OAuth scopes required for OAuth type authentication.
        /// This member is required.
        public var oAuthScopes: [Swift.String]?
        /// The token url required to fetch access/refresh tokens using authorization code and also to refresh expired access token using refresh token.
        /// This member is required.
        public var tokenUrl: Swift.String?

        public init (
            authCodeUrl: Swift.String? = nil,
            oAuthScopes: [Swift.String]? = nil,
            tokenUrl: Swift.String? = nil
        )
        {
            self.authCodeUrl = authCodeUrl
            self.oAuthScopes = oAuthScopes
            self.tokenUrl = tokenUrl
        }
    }

}

extension AppflowClientTypes {
    public enum Operator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case addition
        case between
        case contains
        case division
        case equalTo
        case greaterThan
        case greaterThanOrEqualTo
        case lessThan
        case lessThanOrEqualTo
        case maskAll
        case maskFirstN
        case maskLastN
        case multiplication
        case notEqualTo
        case noOp
        case projection
        case subtraction
        case validateNonNegative
        case validateNonNull
        case validateNonZero
        case validateNumeric
        case sdkUnknown(Swift.String)

        public static var allCases: [Operator] {
            return [
                .addition,
                .between,
                .contains,
                .division,
                .equalTo,
                .greaterThan,
                .greaterThanOrEqualTo,
                .lessThan,
                .lessThanOrEqualTo,
                .maskAll,
                .maskFirstN,
                .maskLastN,
                .multiplication,
                .notEqualTo,
                .noOp,
                .projection,
                .subtraction,
                .validateNonNegative,
                .validateNonNull,
                .validateNonZero,
                .validateNumeric,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .addition: return "ADDITION"
            case .between: return "BETWEEN"
            case .contains: return "CONTAINS"
            case .division: return "DIVISION"
            case .equalTo: return "EQUAL_TO"
            case .greaterThan: return "GREATER_THAN"
            case .greaterThanOrEqualTo: return "GREATER_THAN_OR_EQUAL_TO"
            case .lessThan: return "LESS_THAN"
            case .lessThanOrEqualTo: return "LESS_THAN_OR_EQUAL_TO"
            case .maskAll: return "MASK_ALL"
            case .maskFirstN: return "MASK_FIRST_N"
            case .maskLastN: return "MASK_LAST_N"
            case .multiplication: return "MULTIPLICATION"
            case .notEqualTo: return "NOT_EQUAL_TO"
            case .noOp: return "NO_OP"
            case .projection: return "PROJECTION"
            case .subtraction: return "SUBTRACTION"
            case .validateNonNegative: return "VALIDATE_NON_NEGATIVE"
            case .validateNonNull: return "VALIDATE_NON_NULL"
            case .validateNonZero: return "VALIDATE_NON_ZERO"
            case .validateNumeric: return "VALIDATE_NUMERIC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Operator(rawValue: rawValue) ?? Operator.sdkUnknown(rawValue)
        }
    }
}

extension AppflowClientTypes {
    public enum OperatorPropertiesKeys: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case concatFormat
        case dataType
        case destinationDataType
        case excludeSourceFieldsList
        case lowerBound
        case maskLength
        case maskValue
        case mathOperationFieldsOrder
        case sourceDataType
        case subfieldCategoryMap
        case truncateLength
        case upperBound
        case validationAction
        case value
        case values
        case sdkUnknown(Swift.String)

        public static var allCases: [OperatorPropertiesKeys] {
            return [
                .concatFormat,
                .dataType,
                .destinationDataType,
                .excludeSourceFieldsList,
                .lowerBound,
                .maskLength,
                .maskValue,
                .mathOperationFieldsOrder,
                .sourceDataType,
                .subfieldCategoryMap,
                .truncateLength,
                .upperBound,
                .validationAction,
                .value,
                .values,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .concatFormat: return "CONCAT_FORMAT"
            case .dataType: return "DATA_TYPE"
            case .destinationDataType: return "DESTINATION_DATA_TYPE"
            case .excludeSourceFieldsList: return "EXCLUDE_SOURCE_FIELDS_LIST"
            case .lowerBound: return "LOWER_BOUND"
            case .maskLength: return "MASK_LENGTH"
            case .maskValue: return "MASK_VALUE"
            case .mathOperationFieldsOrder: return "MATH_OPERATION_FIELDS_ORDER"
            case .sourceDataType: return "SOURCE_DATA_TYPE"
            case .subfieldCategoryMap: return "SUBFIELD_CATEGORY_MAP"
            case .truncateLength: return "TRUNCATE_LENGTH"
            case .upperBound: return "UPPER_BOUND"
            case .validationAction: return "VALIDATION_ACTION"
            case .value: return "VALUE"
            case .values: return "VALUES"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OperatorPropertiesKeys(rawValue: rawValue) ?? OperatorPropertiesKeys.sdkUnknown(rawValue)
        }
    }
}

extension AppflowClientTypes.PrefixConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case prefixFormat
        case prefixType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let prefixFormat = prefixFormat {
            try encodeContainer.encode(prefixFormat.rawValue, forKey: .prefixFormat)
        }
        if let prefixType = prefixType {
            try encodeContainer.encode(prefixType.rawValue, forKey: .prefixType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let prefixTypeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.PrefixType.self, forKey: .prefixType)
        prefixType = prefixTypeDecoded
        let prefixFormatDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.PrefixFormat.self, forKey: .prefixFormat)
        prefixFormat = prefixFormatDecoded
    }
}

extension AppflowClientTypes {
    /// Determines the prefix that Amazon AppFlow applies to the destination folder name. You can name your destination folders according to the flow frequency and date.
    public struct PrefixConfig: Swift.Equatable {
        /// Determines the level of granularity that's included in the prefix.
        public var prefixFormat: AppflowClientTypes.PrefixFormat?
        /// Determines the format of the prefix, and whether it applies to the file name, file path, or both.
        public var prefixType: AppflowClientTypes.PrefixType?

        public init (
            prefixFormat: AppflowClientTypes.PrefixFormat? = nil,
            prefixType: AppflowClientTypes.PrefixType? = nil
        )
        {
            self.prefixFormat = prefixFormat
            self.prefixType = prefixType
        }
    }

}

extension AppflowClientTypes {
    public enum PrefixFormat: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case day
        case hour
        case minute
        case month
        case year
        case sdkUnknown(Swift.String)

        public static var allCases: [PrefixFormat] {
            return [
                .day,
                .hour,
                .minute,
                .month,
                .year,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .day: return "DAY"
            case .hour: return "HOUR"
            case .minute: return "MINUTE"
            case .month: return "MONTH"
            case .year: return "YEAR"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PrefixFormat(rawValue: rawValue) ?? PrefixFormat.sdkUnknown(rawValue)
        }
    }
}

extension AppflowClientTypes {
    public enum PrefixType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case filename
        case path
        case pathAndFilename
        case sdkUnknown(Swift.String)

        public static var allCases: [PrefixType] {
            return [
                .filename,
                .path,
                .pathAndFilename,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .filename: return "FILENAME"
            case .path: return "PATH"
            case .pathAndFilename: return "PATH_AND_FILENAME"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PrefixType(rawValue: rawValue) ?? PrefixType.sdkUnknown(rawValue)
        }
    }
}

extension AppflowClientTypes {
    public enum PrivateConnectionProvisioningFailureCause: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accessDenied
        case connectorAuthentication
        case connectorServer
        case internalServer
        case validation
        case sdkUnknown(Swift.String)

        public static var allCases: [PrivateConnectionProvisioningFailureCause] {
            return [
                .accessDenied,
                .connectorAuthentication,
                .connectorServer,
                .internalServer,
                .validation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accessDenied: return "ACCESS_DENIED"
            case .connectorAuthentication: return "CONNECTOR_AUTHENTICATION"
            case .connectorServer: return "CONNECTOR_SERVER"
            case .internalServer: return "INTERNAL_SERVER"
            case .validation: return "VALIDATION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PrivateConnectionProvisioningFailureCause(rawValue: rawValue) ?? PrivateConnectionProvisioningFailureCause.sdkUnknown(rawValue)
        }
    }
}

extension AppflowClientTypes.PrivateConnectionProvisioningState: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failureCause
        case failureMessage
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let failureCause = failureCause {
            try encodeContainer.encode(failureCause.rawValue, forKey: .failureCause)
        }
        if let failureMessage = failureMessage {
            try encodeContainer.encode(failureMessage, forKey: .failureMessage)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.PrivateConnectionProvisioningStatus.self, forKey: .status)
        status = statusDecoded
        let failureMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureMessage)
        failureMessage = failureMessageDecoded
        let failureCauseDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.PrivateConnectionProvisioningFailureCause.self, forKey: .failureCause)
        failureCause = failureCauseDecoded
    }
}

extension AppflowClientTypes {
    /// Specifies the private connection provisioning state.
    public struct PrivateConnectionProvisioningState: Swift.Equatable {
        /// Specifies the private connection provisioning failure cause.
        public var failureCause: AppflowClientTypes.PrivateConnectionProvisioningFailureCause?
        /// Specifies the private connection provisioning failure reason.
        public var failureMessage: Swift.String?
        /// Specifies the private connection provisioning status.
        public var status: AppflowClientTypes.PrivateConnectionProvisioningStatus?

        public init (
            failureCause: AppflowClientTypes.PrivateConnectionProvisioningFailureCause? = nil,
            failureMessage: Swift.String? = nil,
            status: AppflowClientTypes.PrivateConnectionProvisioningStatus? = nil
        )
        {
            self.failureCause = failureCause
            self.failureMessage = failureMessage
            self.status = status
        }
    }

}

extension AppflowClientTypes {
    public enum PrivateConnectionProvisioningStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case created
        case failed
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [PrivateConnectionProvisioningStatus] {
            return [
                .created,
                .failed,
                .pending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .created: return "CREATED"
            case .failed: return "FAILED"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PrivateConnectionProvisioningStatus(rawValue: rawValue) ?? PrivateConnectionProvisioningStatus.sdkUnknown(rawValue)
        }
    }
}

extension AppflowClientTypes.RedshiftConnectorProfileCredentials: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case password
        case username
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let password = password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let username = username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .username)
        username = usernameDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .password)
        password = passwordDecoded
    }
}

extension AppflowClientTypes {
    /// The connector-specific profile credentials required when using Amazon Redshift.
    public struct RedshiftConnectorProfileCredentials: Swift.Equatable {
        /// The password that corresponds to the user name.
        /// This member is required.
        public var password: Swift.String?
        /// The name of the user.
        /// This member is required.
        public var username: Swift.String?

        public init (
            password: Swift.String? = nil,
            username: Swift.String? = nil
        )
        {
            self.password = password
            self.username = username
        }
    }

}

extension AppflowClientTypes.RedshiftConnectorProfileProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketName
        case bucketPrefix
        case databaseUrl
        case roleArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketName = bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
        if let bucketPrefix = bucketPrefix {
            try encodeContainer.encode(bucketPrefix, forKey: .bucketPrefix)
        }
        if let databaseUrl = databaseUrl {
            try encodeContainer.encode(databaseUrl, forKey: .databaseUrl)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let databaseUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseUrl)
        databaseUrl = databaseUrlDecoded
        let bucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
        let bucketPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketPrefix)
        bucketPrefix = bucketPrefixDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension AppflowClientTypes {
    /// The connector-specific profile properties when using Amazon Redshift.
    public struct RedshiftConnectorProfileProperties: Swift.Equatable {
        /// A name for the associated Amazon S3 bucket.
        /// This member is required.
        public var bucketName: Swift.String?
        /// The object key for the destination bucket in which Amazon AppFlow places the files.
        public var bucketPrefix: Swift.String?
        /// The JDBC URL of the Amazon Redshift cluster.
        /// This member is required.
        public var databaseUrl: Swift.String?
        /// The Amazon Resource Name (ARN) of the IAM role.
        /// This member is required.
        public var roleArn: Swift.String?

        public init (
            bucketName: Swift.String? = nil,
            bucketPrefix: Swift.String? = nil,
            databaseUrl: Swift.String? = nil,
            roleArn: Swift.String? = nil
        )
        {
            self.bucketName = bucketName
            self.bucketPrefix = bucketPrefix
            self.databaseUrl = databaseUrl
            self.roleArn = roleArn
        }
    }

}

extension AppflowClientTypes.RedshiftDestinationProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketPrefix
        case errorHandlingConfig
        case intermediateBucketName
        case object
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketPrefix = bucketPrefix {
            try encodeContainer.encode(bucketPrefix, forKey: .bucketPrefix)
        }
        if let errorHandlingConfig = errorHandlingConfig {
            try encodeContainer.encode(errorHandlingConfig, forKey: .errorHandlingConfig)
        }
        if let intermediateBucketName = intermediateBucketName {
            try encodeContainer.encode(intermediateBucketName, forKey: .intermediateBucketName)
        }
        if let object = object {
            try encodeContainer.encode(object, forKey: .object)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .object)
        object = objectDecoded
        let intermediateBucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .intermediateBucketName)
        intermediateBucketName = intermediateBucketNameDecoded
        let bucketPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketPrefix)
        bucketPrefix = bucketPrefixDecoded
        let errorHandlingConfigDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ErrorHandlingConfig.self, forKey: .errorHandlingConfig)
        errorHandlingConfig = errorHandlingConfigDecoded
    }
}

extension AppflowClientTypes {
    /// The properties that are applied when Amazon Redshift is being used as a destination.
    public struct RedshiftDestinationProperties: Swift.Equatable {
        /// The object key for the bucket in which Amazon AppFlow places the destination files.
        public var bucketPrefix: Swift.String?
        /// The settings that determine how Amazon AppFlow handles an error when placing data in the Amazon Redshift destination. For example, this setting would determine if the flow should fail after one insertion error, or continue and attempt to insert every record regardless of the initial failure. ErrorHandlingConfig is a part of the destination connector details.
        public var errorHandlingConfig: AppflowClientTypes.ErrorHandlingConfig?
        /// The intermediate bucket that Amazon AppFlow uses when moving data into Amazon Redshift.
        /// This member is required.
        public var intermediateBucketName: Swift.String?
        /// The object specified in the Amazon Redshift flow destination.
        /// This member is required.
        public var object: Swift.String?

        public init (
            bucketPrefix: Swift.String? = nil,
            errorHandlingConfig: AppflowClientTypes.ErrorHandlingConfig? = nil,
            intermediateBucketName: Swift.String? = nil,
            object: Swift.String? = nil
        )
        {
            self.bucketPrefix = bucketPrefix
            self.errorHandlingConfig = errorHandlingConfig
            self.intermediateBucketName = intermediateBucketName
            self.object = object
        }
    }

}

extension AppflowClientTypes.RedshiftMetadata: Swift.Codable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension AppflowClientTypes {
    /// The connector metadata specific to Amazon Redshift.
    public struct RedshiftMetadata: Swift.Equatable {

    }

}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The resource specified in the request (such as the source or destination connector profile) is not found.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AppflowClientTypes {
    public enum S3ConnectorOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case addition
        case between
        case division
        case equalTo
        case greaterThan
        case greaterThanOrEqualTo
        case lessThan
        case lessThanOrEqualTo
        case maskAll
        case maskFirstN
        case maskLastN
        case multiplication
        case notEqualTo
        case noOp
        case projection
        case subtraction
        case validateNonNegative
        case validateNonNull
        case validateNonZero
        case validateNumeric
        case sdkUnknown(Swift.String)

        public static var allCases: [S3ConnectorOperator] {
            return [
                .addition,
                .between,
                .division,
                .equalTo,
                .greaterThan,
                .greaterThanOrEqualTo,
                .lessThan,
                .lessThanOrEqualTo,
                .maskAll,
                .maskFirstN,
                .maskLastN,
                .multiplication,
                .notEqualTo,
                .noOp,
                .projection,
                .subtraction,
                .validateNonNegative,
                .validateNonNull,
                .validateNonZero,
                .validateNumeric,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .addition: return "ADDITION"
            case .between: return "BETWEEN"
            case .division: return "DIVISION"
            case .equalTo: return "EQUAL_TO"
            case .greaterThan: return "GREATER_THAN"
            case .greaterThanOrEqualTo: return "GREATER_THAN_OR_EQUAL_TO"
            case .lessThan: return "LESS_THAN"
            case .lessThanOrEqualTo: return "LESS_THAN_OR_EQUAL_TO"
            case .maskAll: return "MASK_ALL"
            case .maskFirstN: return "MASK_FIRST_N"
            case .maskLastN: return "MASK_LAST_N"
            case .multiplication: return "MULTIPLICATION"
            case .notEqualTo: return "NOT_EQUAL_TO"
            case .noOp: return "NO_OP"
            case .projection: return "PROJECTION"
            case .subtraction: return "SUBTRACTION"
            case .validateNonNegative: return "VALIDATE_NON_NEGATIVE"
            case .validateNonNull: return "VALIDATE_NON_NULL"
            case .validateNonZero: return "VALIDATE_NON_ZERO"
            case .validateNumeric: return "VALIDATE_NUMERIC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = S3ConnectorOperator(rawValue: rawValue) ?? S3ConnectorOperator.sdkUnknown(rawValue)
        }
    }
}

extension AppflowClientTypes.S3DestinationProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketName
        case bucketPrefix
        case s3OutputFormatConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketName = bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
        if let bucketPrefix = bucketPrefix {
            try encodeContainer.encode(bucketPrefix, forKey: .bucketPrefix)
        }
        if let s3OutputFormatConfig = s3OutputFormatConfig {
            try encodeContainer.encode(s3OutputFormatConfig, forKey: .s3OutputFormatConfig)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
        let bucketPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketPrefix)
        bucketPrefix = bucketPrefixDecoded
        let s3OutputFormatConfigDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.S3OutputFormatConfig.self, forKey: .s3OutputFormatConfig)
        s3OutputFormatConfig = s3OutputFormatConfigDecoded
    }
}

extension AppflowClientTypes {
    /// The properties that are applied when Amazon S3 is used as a destination.
    public struct S3DestinationProperties: Swift.Equatable {
        /// The Amazon S3 bucket name in which Amazon AppFlow places the transferred data.
        /// This member is required.
        public var bucketName: Swift.String?
        /// The object key for the destination bucket in which Amazon AppFlow places the files.
        public var bucketPrefix: Swift.String?
        /// The configuration that determines how Amazon AppFlow should format the flow output data when Amazon S3 is used as the destination.
        public var s3OutputFormatConfig: AppflowClientTypes.S3OutputFormatConfig?

        public init (
            bucketName: Swift.String? = nil,
            bucketPrefix: Swift.String? = nil,
            s3OutputFormatConfig: AppflowClientTypes.S3OutputFormatConfig? = nil
        )
        {
            self.bucketName = bucketName
            self.bucketPrefix = bucketPrefix
            self.s3OutputFormatConfig = s3OutputFormatConfig
        }
    }

}

extension AppflowClientTypes {
    public enum S3InputFileType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case csv
        case json
        case sdkUnknown(Swift.String)

        public static var allCases: [S3InputFileType] {
            return [
                .csv,
                .json,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .csv: return "CSV"
            case .json: return "JSON"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = S3InputFileType(rawValue: rawValue) ?? S3InputFileType.sdkUnknown(rawValue)
        }
    }
}

extension AppflowClientTypes.S3InputFormatConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3InputFileType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3InputFileType = s3InputFileType {
            try encodeContainer.encode(s3InputFileType.rawValue, forKey: .s3InputFileType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3InputFileTypeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.S3InputFileType.self, forKey: .s3InputFileType)
        s3InputFileType = s3InputFileTypeDecoded
    }
}

extension AppflowClientTypes {
    /// When you use Amazon S3 as the source, the configuration format that you provide the flow input data.
    public struct S3InputFormatConfig: Swift.Equatable {
        /// The file type that Amazon AppFlow gets from your Amazon S3 bucket.
        public var s3InputFileType: AppflowClientTypes.S3InputFileType?

        public init (
            s3InputFileType: AppflowClientTypes.S3InputFileType? = nil
        )
        {
            self.s3InputFileType = s3InputFileType
        }
    }

}

extension AppflowClientTypes.S3Metadata: Swift.Codable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension AppflowClientTypes {
    /// The connector metadata specific to Amazon S3.
    public struct S3Metadata: Swift.Equatable {

    }

}

extension AppflowClientTypes.S3OutputFormatConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aggregationConfig
        case fileType
        case prefixConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aggregationConfig = aggregationConfig {
            try encodeContainer.encode(aggregationConfig, forKey: .aggregationConfig)
        }
        if let fileType = fileType {
            try encodeContainer.encode(fileType.rawValue, forKey: .fileType)
        }
        if let prefixConfig = prefixConfig {
            try encodeContainer.encode(prefixConfig, forKey: .prefixConfig)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileTypeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.FileType.self, forKey: .fileType)
        fileType = fileTypeDecoded
        let prefixConfigDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.PrefixConfig.self, forKey: .prefixConfig)
        prefixConfig = prefixConfigDecoded
        let aggregationConfigDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.AggregationConfig.self, forKey: .aggregationConfig)
        aggregationConfig = aggregationConfigDecoded
    }
}

extension AppflowClientTypes {
    /// The configuration that determines how Amazon AppFlow should format the flow output data when Amazon S3 is used as the destination.
    public struct S3OutputFormatConfig: Swift.Equatable {
        /// The aggregation settings that you can use to customize the output format of your flow data.
        public var aggregationConfig: AppflowClientTypes.AggregationConfig?
        /// Indicates the file type that Amazon AppFlow places in the Amazon S3 bucket.
        public var fileType: AppflowClientTypes.FileType?
        /// Determines the prefix that Amazon AppFlow applies to the folder name in the Amazon S3 bucket. You can name folders according to the flow frequency and date.
        public var prefixConfig: AppflowClientTypes.PrefixConfig?

        public init (
            aggregationConfig: AppflowClientTypes.AggregationConfig? = nil,
            fileType: AppflowClientTypes.FileType? = nil,
            prefixConfig: AppflowClientTypes.PrefixConfig? = nil
        )
        {
            self.aggregationConfig = aggregationConfig
            self.fileType = fileType
            self.prefixConfig = prefixConfig
        }
    }

}

extension AppflowClientTypes.S3SourceProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketName
        case bucketPrefix
        case s3InputFormatConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketName = bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
        if let bucketPrefix = bucketPrefix {
            try encodeContainer.encode(bucketPrefix, forKey: .bucketPrefix)
        }
        if let s3InputFormatConfig = s3InputFormatConfig {
            try encodeContainer.encode(s3InputFormatConfig, forKey: .s3InputFormatConfig)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
        let bucketPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketPrefix)
        bucketPrefix = bucketPrefixDecoded
        let s3InputFormatConfigDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.S3InputFormatConfig.self, forKey: .s3InputFormatConfig)
        s3InputFormatConfig = s3InputFormatConfigDecoded
    }
}

extension AppflowClientTypes {
    /// The properties that are applied when Amazon S3 is being used as the flow source.
    public struct S3SourceProperties: Swift.Equatable {
        /// The Amazon S3 bucket name where the source files are stored.
        /// This member is required.
        public var bucketName: Swift.String?
        /// The object key for the Amazon S3 bucket in which the source files are stored.
        public var bucketPrefix: Swift.String?
        /// When you use Amazon S3 as the source, the configuration format that you provide the flow input data.
        public var s3InputFormatConfig: AppflowClientTypes.S3InputFormatConfig?

        public init (
            bucketName: Swift.String? = nil,
            bucketPrefix: Swift.String? = nil,
            s3InputFormatConfig: AppflowClientTypes.S3InputFormatConfig? = nil
        )
        {
            self.bucketName = bucketName
            self.bucketPrefix = bucketPrefix
            self.s3InputFormatConfig = s3InputFormatConfig
        }
    }

}

extension AppflowClientTypes {
    public enum SAPODataConnectorOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case addition
        case between
        case contains
        case division
        case equalTo
        case greaterThan
        case greaterThanOrEqualTo
        case lessThan
        case lessThanOrEqualTo
        case maskAll
        case maskFirstN
        case maskLastN
        case multiplication
        case notEqualTo
        case noOp
        case projection
        case subtraction
        case validateNonNegative
        case validateNonNull
        case validateNonZero
        case validateNumeric
        case sdkUnknown(Swift.String)

        public static var allCases: [SAPODataConnectorOperator] {
            return [
                .addition,
                .between,
                .contains,
                .division,
                .equalTo,
                .greaterThan,
                .greaterThanOrEqualTo,
                .lessThan,
                .lessThanOrEqualTo,
                .maskAll,
                .maskFirstN,
                .maskLastN,
                .multiplication,
                .notEqualTo,
                .noOp,
                .projection,
                .subtraction,
                .validateNonNegative,
                .validateNonNull,
                .validateNonZero,
                .validateNumeric,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .addition: return "ADDITION"
            case .between: return "BETWEEN"
            case .contains: return "CONTAINS"
            case .division: return "DIVISION"
            case .equalTo: return "EQUAL_TO"
            case .greaterThan: return "GREATER_THAN"
            case .greaterThanOrEqualTo: return "GREATER_THAN_OR_EQUAL_TO"
            case .lessThan: return "LESS_THAN"
            case .lessThanOrEqualTo: return "LESS_THAN_OR_EQUAL_TO"
            case .maskAll: return "MASK_ALL"
            case .maskFirstN: return "MASK_FIRST_N"
            case .maskLastN: return "MASK_LAST_N"
            case .multiplication: return "MULTIPLICATION"
            case .notEqualTo: return "NOT_EQUAL_TO"
            case .noOp: return "NO_OP"
            case .projection: return "PROJECTION"
            case .subtraction: return "SUBTRACTION"
            case .validateNonNegative: return "VALIDATE_NON_NEGATIVE"
            case .validateNonNull: return "VALIDATE_NON_NULL"
            case .validateNonZero: return "VALIDATE_NON_ZERO"
            case .validateNumeric: return "VALIDATE_NUMERIC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SAPODataConnectorOperator(rawValue: rawValue) ?? SAPODataConnectorOperator.sdkUnknown(rawValue)
        }
    }
}

extension AppflowClientTypes.SAPODataConnectorProfileCredentials: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case basicAuthCredentials
        case oAuthCredentials
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let basicAuthCredentials = basicAuthCredentials {
            try encodeContainer.encode(basicAuthCredentials, forKey: .basicAuthCredentials)
        }
        if let oAuthCredentials = oAuthCredentials {
            try encodeContainer.encode(oAuthCredentials, forKey: .oAuthCredentials)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let basicAuthCredentialsDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.BasicAuthCredentials.self, forKey: .basicAuthCredentials)
        basicAuthCredentials = basicAuthCredentialsDecoded
        let oAuthCredentialsDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.OAuthCredentials.self, forKey: .oAuthCredentials)
        oAuthCredentials = oAuthCredentialsDecoded
    }
}

extension AppflowClientTypes {
    /// The connector-specific profile credentials required when using SAPOData.
    public struct SAPODataConnectorProfileCredentials: Swift.Equatable {
        /// The SAPOData basic authentication credentials.
        public var basicAuthCredentials: AppflowClientTypes.BasicAuthCredentials?
        /// The SAPOData OAuth type authentication credentials.
        public var oAuthCredentials: AppflowClientTypes.OAuthCredentials?

        public init (
            basicAuthCredentials: AppflowClientTypes.BasicAuthCredentials? = nil,
            oAuthCredentials: AppflowClientTypes.OAuthCredentials? = nil
        )
        {
            self.basicAuthCredentials = basicAuthCredentials
            self.oAuthCredentials = oAuthCredentials
        }
    }

}

extension AppflowClientTypes.SAPODataConnectorProfileProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationHostUrl
        case applicationServicePath
        case clientNumber
        case logonLanguage
        case oAuthProperties
        case portNumber
        case privateLinkServiceName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationHostUrl = applicationHostUrl {
            try encodeContainer.encode(applicationHostUrl, forKey: .applicationHostUrl)
        }
        if let applicationServicePath = applicationServicePath {
            try encodeContainer.encode(applicationServicePath, forKey: .applicationServicePath)
        }
        if let clientNumber = clientNumber {
            try encodeContainer.encode(clientNumber, forKey: .clientNumber)
        }
        if let logonLanguage = logonLanguage {
            try encodeContainer.encode(logonLanguage, forKey: .logonLanguage)
        }
        if let oAuthProperties = oAuthProperties {
            try encodeContainer.encode(oAuthProperties, forKey: .oAuthProperties)
        }
        if portNumber != 0 {
            try encodeContainer.encode(portNumber, forKey: .portNumber)
        }
        if let privateLinkServiceName = privateLinkServiceName {
            try encodeContainer.encode(privateLinkServiceName, forKey: .privateLinkServiceName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationHostUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationHostUrl)
        applicationHostUrl = applicationHostUrlDecoded
        let applicationServicePathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationServicePath)
        applicationServicePath = applicationServicePathDecoded
        let portNumberDecoded = try containerValues.decode(Swift.Int.self, forKey: .portNumber)
        portNumber = portNumberDecoded
        let clientNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientNumber)
        clientNumber = clientNumberDecoded
        let logonLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logonLanguage)
        logonLanguage = logonLanguageDecoded
        let privateLinkServiceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .privateLinkServiceName)
        privateLinkServiceName = privateLinkServiceNameDecoded
        let oAuthPropertiesDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.OAuthProperties.self, forKey: .oAuthProperties)
        oAuthProperties = oAuthPropertiesDecoded
    }
}

extension AppflowClientTypes {
    /// The connector-specific profile properties required when using SAPOData.
    public struct SAPODataConnectorProfileProperties: Swift.Equatable {
        /// The location of the SAPOData resource.
        /// This member is required.
        public var applicationHostUrl: Swift.String?
        /// The application path to catalog service.
        /// This member is required.
        public var applicationServicePath: Swift.String?
        /// The client number for the client creating the connection.
        /// This member is required.
        public var clientNumber: Swift.String?
        /// The logon language of SAPOData instance.
        public var logonLanguage: Swift.String?
        /// The SAPOData OAuth properties required for OAuth type authentication.
        public var oAuthProperties: AppflowClientTypes.OAuthProperties?
        /// The port number of the SAPOData instance.
        /// This member is required.
        public var portNumber: Swift.Int
        /// The SAPOData Private Link service name to be used for private data transfers.
        public var privateLinkServiceName: Swift.String?

        public init (
            applicationHostUrl: Swift.String? = nil,
            applicationServicePath: Swift.String? = nil,
            clientNumber: Swift.String? = nil,
            logonLanguage: Swift.String? = nil,
            oAuthProperties: AppflowClientTypes.OAuthProperties? = nil,
            portNumber: Swift.Int = 0,
            privateLinkServiceName: Swift.String? = nil
        )
        {
            self.applicationHostUrl = applicationHostUrl
            self.applicationServicePath = applicationServicePath
            self.clientNumber = clientNumber
            self.logonLanguage = logonLanguage
            self.oAuthProperties = oAuthProperties
            self.portNumber = portNumber
            self.privateLinkServiceName = privateLinkServiceName
        }
    }

}

extension AppflowClientTypes.SAPODataMetadata: Swift.Codable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension AppflowClientTypes {
    /// The connector metadata specific to SAPOData.
    public struct SAPODataMetadata: Swift.Equatable {

    }

}

extension AppflowClientTypes.SAPODataSourceProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case objectPath
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let objectPath = objectPath {
            try encodeContainer.encode(objectPath, forKey: .objectPath)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .objectPath)
        objectPath = objectPathDecoded
    }
}

extension AppflowClientTypes {
    /// The properties that are applied when using SAPOData as a flow source.
    public struct SAPODataSourceProperties: Swift.Equatable {
        /// The object path specified in the SAPOData flow source.
        public var objectPath: Swift.String?

        public init (
            objectPath: Swift.String? = nil
        )
        {
            self.objectPath = objectPath
        }
    }

}

extension AppflowClientTypes {
    public enum SalesforceConnectorOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case addition
        case between
        case contains
        case division
        case equalTo
        case greaterThan
        case greaterThanOrEqualTo
        case lessThan
        case lessThanOrEqualTo
        case maskAll
        case maskFirstN
        case maskLastN
        case multiplication
        case notEqualTo
        case noOp
        case projection
        case subtraction
        case validateNonNegative
        case validateNonNull
        case validateNonZero
        case validateNumeric
        case sdkUnknown(Swift.String)

        public static var allCases: [SalesforceConnectorOperator] {
            return [
                .addition,
                .between,
                .contains,
                .division,
                .equalTo,
                .greaterThan,
                .greaterThanOrEqualTo,
                .lessThan,
                .lessThanOrEqualTo,
                .maskAll,
                .maskFirstN,
                .maskLastN,
                .multiplication,
                .notEqualTo,
                .noOp,
                .projection,
                .subtraction,
                .validateNonNegative,
                .validateNonNull,
                .validateNonZero,
                .validateNumeric,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .addition: return "ADDITION"
            case .between: return "BETWEEN"
            case .contains: return "CONTAINS"
            case .division: return "DIVISION"
            case .equalTo: return "EQUAL_TO"
            case .greaterThan: return "GREATER_THAN"
            case .greaterThanOrEqualTo: return "GREATER_THAN_OR_EQUAL_TO"
            case .lessThan: return "LESS_THAN"
            case .lessThanOrEqualTo: return "LESS_THAN_OR_EQUAL_TO"
            case .maskAll: return "MASK_ALL"
            case .maskFirstN: return "MASK_FIRST_N"
            case .maskLastN: return "MASK_LAST_N"
            case .multiplication: return "MULTIPLICATION"
            case .notEqualTo: return "NOT_EQUAL_TO"
            case .noOp: return "NO_OP"
            case .projection: return "PROJECTION"
            case .subtraction: return "SUBTRACTION"
            case .validateNonNegative: return "VALIDATE_NON_NEGATIVE"
            case .validateNonNull: return "VALIDATE_NON_NULL"
            case .validateNonZero: return "VALIDATE_NON_ZERO"
            case .validateNumeric: return "VALIDATE_NUMERIC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SalesforceConnectorOperator(rawValue: rawValue) ?? SalesforceConnectorOperator.sdkUnknown(rawValue)
        }
    }
}

extension AppflowClientTypes.SalesforceConnectorProfileCredentials: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessToken
        case clientCredentialsArn
        case oAuthRequest
        case refreshToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessToken = accessToken {
            try encodeContainer.encode(accessToken, forKey: .accessToken)
        }
        if let clientCredentialsArn = clientCredentialsArn {
            try encodeContainer.encode(clientCredentialsArn, forKey: .clientCredentialsArn)
        }
        if let oAuthRequest = oAuthRequest {
            try encodeContainer.encode(oAuthRequest, forKey: .oAuthRequest)
        }
        if let refreshToken = refreshToken {
            try encodeContainer.encode(refreshToken, forKey: .refreshToken)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessToken)
        accessToken = accessTokenDecoded
        let refreshTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .refreshToken)
        refreshToken = refreshTokenDecoded
        let oAuthRequestDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ConnectorOAuthRequest.self, forKey: .oAuthRequest)
        oAuthRequest = oAuthRequestDecoded
        let clientCredentialsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientCredentialsArn)
        clientCredentialsArn = clientCredentialsArnDecoded
    }
}

extension AppflowClientTypes {
    /// The connector-specific profile credentials required when using Salesforce.
    public struct SalesforceConnectorProfileCredentials: Swift.Equatable {
        /// The credentials used to access protected Salesforce resources.
        public var accessToken: Swift.String?
        /// The secret manager ARN, which contains the client ID and client secret of the connected app.
        public var clientCredentialsArn: Swift.String?
        /// The OAuth requirement needed to request security tokens from the connector endpoint.
        public var oAuthRequest: AppflowClientTypes.ConnectorOAuthRequest?
        /// The credentials used to acquire new access tokens.
        public var refreshToken: Swift.String?

        public init (
            accessToken: Swift.String? = nil,
            clientCredentialsArn: Swift.String? = nil,
            oAuthRequest: AppflowClientTypes.ConnectorOAuthRequest? = nil,
            refreshToken: Swift.String? = nil
        )
        {
            self.accessToken = accessToken
            self.clientCredentialsArn = clientCredentialsArn
            self.oAuthRequest = oAuthRequest
            self.refreshToken = refreshToken
        }
    }

}

extension AppflowClientTypes.SalesforceConnectorProfileProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceUrl
        case isSandboxEnvironment
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceUrl = instanceUrl {
            try encodeContainer.encode(instanceUrl, forKey: .instanceUrl)
        }
        if isSandboxEnvironment != false {
            try encodeContainer.encode(isSandboxEnvironment, forKey: .isSandboxEnvironment)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceUrl)
        instanceUrl = instanceUrlDecoded
        let isSandboxEnvironmentDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isSandboxEnvironment)
        isSandboxEnvironment = isSandboxEnvironmentDecoded
    }
}

extension AppflowClientTypes {
    /// The connector-specific profile properties required when using Salesforce.
    public struct SalesforceConnectorProfileProperties: Swift.Equatable {
        /// The location of the Salesforce resource.
        public var instanceUrl: Swift.String?
        /// Indicates whether the connector profile applies to a sandbox or production environment.
        public var isSandboxEnvironment: Swift.Bool

        public init (
            instanceUrl: Swift.String? = nil,
            isSandboxEnvironment: Swift.Bool = false
        )
        {
            self.instanceUrl = instanceUrl
            self.isSandboxEnvironment = isSandboxEnvironment
        }
    }

}

extension AppflowClientTypes.SalesforceDestinationProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorHandlingConfig
        case idFieldNames
        case object
        case writeOperationType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorHandlingConfig = errorHandlingConfig {
            try encodeContainer.encode(errorHandlingConfig, forKey: .errorHandlingConfig)
        }
        if let idFieldNames = idFieldNames {
            var idFieldNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .idFieldNames)
            for idfieldnamelist0 in idFieldNames {
                try idFieldNamesContainer.encode(idfieldnamelist0)
            }
        }
        if let object = object {
            try encodeContainer.encode(object, forKey: .object)
        }
        if let writeOperationType = writeOperationType {
            try encodeContainer.encode(writeOperationType.rawValue, forKey: .writeOperationType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .object)
        object = objectDecoded
        let idFieldNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .idFieldNames)
        var idFieldNamesDecoded0:[Swift.String]? = nil
        if let idFieldNamesContainer = idFieldNamesContainer {
            idFieldNamesDecoded0 = [Swift.String]()
            for string0 in idFieldNamesContainer {
                if let string0 = string0 {
                    idFieldNamesDecoded0?.append(string0)
                }
            }
        }
        idFieldNames = idFieldNamesDecoded0
        let errorHandlingConfigDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ErrorHandlingConfig.self, forKey: .errorHandlingConfig)
        errorHandlingConfig = errorHandlingConfigDecoded
        let writeOperationTypeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.WriteOperationType.self, forKey: .writeOperationType)
        writeOperationType = writeOperationTypeDecoded
    }
}

extension AppflowClientTypes {
    /// The properties that are applied when Salesforce is being used as a destination.
    public struct SalesforceDestinationProperties: Swift.Equatable {
        /// The settings that determine how Amazon AppFlow handles an error when placing data in the Salesforce destination. For example, this setting would determine if the flow should fail after one insertion error, or continue and attempt to insert every record regardless of the initial failure. ErrorHandlingConfig is a part of the destination connector details.
        public var errorHandlingConfig: AppflowClientTypes.ErrorHandlingConfig?
        /// The name of the field that Amazon AppFlow uses as an ID when performing a write operation such as update or delete.
        public var idFieldNames: [Swift.String]?
        /// The object specified in the Salesforce flow destination.
        /// This member is required.
        public var object: Swift.String?
        /// This specifies the type of write operation to be performed in Salesforce. When the value is UPSERT, then idFieldNames is required.
        public var writeOperationType: AppflowClientTypes.WriteOperationType?

        public init (
            errorHandlingConfig: AppflowClientTypes.ErrorHandlingConfig? = nil,
            idFieldNames: [Swift.String]? = nil,
            object: Swift.String? = nil,
            writeOperationType: AppflowClientTypes.WriteOperationType? = nil
        )
        {
            self.errorHandlingConfig = errorHandlingConfig
            self.idFieldNames = idFieldNames
            self.object = object
            self.writeOperationType = writeOperationType
        }
    }

}

extension AppflowClientTypes.SalesforceMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case oAuthScopes
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let oAuthScopes = oAuthScopes {
            var oAuthScopesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .oAuthScopes)
            for oauthscopelist0 in oAuthScopes {
                try oAuthScopesContainer.encode(oauthscopelist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let oAuthScopesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .oAuthScopes)
        var oAuthScopesDecoded0:[Swift.String]? = nil
        if let oAuthScopesContainer = oAuthScopesContainer {
            oAuthScopesDecoded0 = [Swift.String]()
            for string0 in oAuthScopesContainer {
                if let string0 = string0 {
                    oAuthScopesDecoded0?.append(string0)
                }
            }
        }
        oAuthScopes = oAuthScopesDecoded0
    }
}

extension AppflowClientTypes {
    /// The connector metadata specific to Salesforce.
    public struct SalesforceMetadata: Swift.Equatable {
        /// The desired authorization scope for the Salesforce account.
        public var oAuthScopes: [Swift.String]?

        public init (
            oAuthScopes: [Swift.String]? = nil
        )
        {
            self.oAuthScopes = oAuthScopes
        }
    }

}

extension AppflowClientTypes.SalesforceSourceProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enableDynamicFieldUpdate
        case includeDeletedRecords
        case object
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if enableDynamicFieldUpdate != false {
            try encodeContainer.encode(enableDynamicFieldUpdate, forKey: .enableDynamicFieldUpdate)
        }
        if includeDeletedRecords != false {
            try encodeContainer.encode(includeDeletedRecords, forKey: .includeDeletedRecords)
        }
        if let object = object {
            try encodeContainer.encode(object, forKey: .object)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .object)
        object = objectDecoded
        let enableDynamicFieldUpdateDecoded = try containerValues.decode(Swift.Bool.self, forKey: .enableDynamicFieldUpdate)
        enableDynamicFieldUpdate = enableDynamicFieldUpdateDecoded
        let includeDeletedRecordsDecoded = try containerValues.decode(Swift.Bool.self, forKey: .includeDeletedRecords)
        includeDeletedRecords = includeDeletedRecordsDecoded
    }
}

extension AppflowClientTypes {
    /// The properties that are applied when Salesforce is being used as a source.
    public struct SalesforceSourceProperties: Swift.Equatable {
        /// The flag that enables dynamic fetching of new (recently added) fields in the Salesforce objects while running a flow.
        public var enableDynamicFieldUpdate: Swift.Bool
        /// Indicates whether Amazon AppFlow includes deleted files in the flow run.
        public var includeDeletedRecords: Swift.Bool
        /// The object specified in the Salesforce flow source.
        /// This member is required.
        public var object: Swift.String?

        public init (
            enableDynamicFieldUpdate: Swift.Bool = false,
            includeDeletedRecords: Swift.Bool = false,
            object: Swift.String? = nil
        )
        {
            self.enableDynamicFieldUpdate = enableDynamicFieldUpdate
            self.includeDeletedRecords = includeDeletedRecords
            self.object = object
        }
    }

}

extension AppflowClientTypes {
    public enum ScheduleFrequencyType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case byminute
        case daily
        case hourly
        case monthly
        case once
        case weekly
        case sdkUnknown(Swift.String)

        public static var allCases: [ScheduleFrequencyType] {
            return [
                .byminute,
                .daily,
                .hourly,
                .monthly,
                .once,
                .weekly,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .byminute: return "BYMINUTE"
            case .daily: return "DAILY"
            case .hourly: return "HOURLY"
            case .monthly: return "MONTHLY"
            case .once: return "ONCE"
            case .weekly: return "WEEKLY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ScheduleFrequencyType(rawValue: rawValue) ?? ScheduleFrequencyType.sdkUnknown(rawValue)
        }
    }
}

extension AppflowClientTypes.ScheduledTriggerProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataPullMode
        case firstExecutionFrom
        case scheduleEndTime
        case scheduleExpression
        case scheduleOffset
        case scheduleStartTime
        case timezone
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataPullMode = dataPullMode {
            try encodeContainer.encode(dataPullMode.rawValue, forKey: .dataPullMode)
        }
        if let firstExecutionFrom = firstExecutionFrom {
            try encodeContainer.encode(firstExecutionFrom.timeIntervalSince1970, forKey: .firstExecutionFrom)
        }
        if let scheduleEndTime = scheduleEndTime {
            try encodeContainer.encode(scheduleEndTime.timeIntervalSince1970, forKey: .scheduleEndTime)
        }
        if let scheduleExpression = scheduleExpression {
            try encodeContainer.encode(scheduleExpression, forKey: .scheduleExpression)
        }
        if scheduleOffset != 0 {
            try encodeContainer.encode(scheduleOffset, forKey: .scheduleOffset)
        }
        if let scheduleStartTime = scheduleStartTime {
            try encodeContainer.encode(scheduleStartTime.timeIntervalSince1970, forKey: .scheduleStartTime)
        }
        if let timezone = timezone {
            try encodeContainer.encode(timezone, forKey: .timezone)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scheduleExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scheduleExpression)
        scheduleExpression = scheduleExpressionDecoded
        let dataPullModeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.DataPullMode.self, forKey: .dataPullMode)
        dataPullMode = dataPullModeDecoded
        let scheduleStartTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .scheduleStartTime)
        scheduleStartTime = scheduleStartTimeDecoded
        let scheduleEndTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .scheduleEndTime)
        scheduleEndTime = scheduleEndTimeDecoded
        let timezoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timezone)
        timezone = timezoneDecoded
        let scheduleOffsetDecoded = try containerValues.decode(Swift.Int.self, forKey: .scheduleOffset)
        scheduleOffset = scheduleOffsetDecoded
        let firstExecutionFromDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .firstExecutionFrom)
        firstExecutionFrom = firstExecutionFromDecoded
    }
}

extension AppflowClientTypes {
    /// Specifies the configuration details of a schedule-triggered flow as defined by the user. Currently, these settings only apply to the Scheduled trigger type.
    public struct ScheduledTriggerProperties: Swift.Equatable {
        /// Specifies whether a scheduled flow has an incremental data transfer or a complete data transfer for each flow run.
        public var dataPullMode: AppflowClientTypes.DataPullMode?
        /// Specifies the date range for the records to import from the connector in the first flow run.
        public var firstExecutionFrom: ClientRuntime.Date?
        /// Specifies the scheduled end time for a schedule-triggered flow.
        public var scheduleEndTime: ClientRuntime.Date?
        /// The scheduling expression that determines the rate at which the schedule will run, for example rate(5minutes).
        /// This member is required.
        public var scheduleExpression: Swift.String?
        /// Specifies the optional offset that is added to the time interval for a schedule-triggered flow.
        public var scheduleOffset: Swift.Int
        /// Specifies the scheduled start time for a schedule-triggered flow.
        public var scheduleStartTime: ClientRuntime.Date?
        /// Specifies the time zone used when referring to the date and time of a scheduled-triggered flow, such as America/New_York.
        public var timezone: Swift.String?

        public init (
            dataPullMode: AppflowClientTypes.DataPullMode? = nil,
            firstExecutionFrom: ClientRuntime.Date? = nil,
            scheduleEndTime: ClientRuntime.Date? = nil,
            scheduleExpression: Swift.String? = nil,
            scheduleOffset: Swift.Int = 0,
            scheduleStartTime: ClientRuntime.Date? = nil,
            timezone: Swift.String? = nil
        )
        {
            self.dataPullMode = dataPullMode
            self.firstExecutionFrom = firstExecutionFrom
            self.scheduleEndTime = scheduleEndTime
            self.scheduleExpression = scheduleExpression
            self.scheduleOffset = scheduleOffset
            self.scheduleStartTime = scheduleStartTime
            self.timezone = timezone
        }
    }

}

extension AppflowClientTypes {
    public enum ServiceNowConnectorOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case addition
        case between
        case contains
        case division
        case equalTo
        case greaterThan
        case greaterThanOrEqualTo
        case lessThan
        case lessThanOrEqualTo
        case maskAll
        case maskFirstN
        case maskLastN
        case multiplication
        case notEqualTo
        case noOp
        case projection
        case subtraction
        case validateNonNegative
        case validateNonNull
        case validateNonZero
        case validateNumeric
        case sdkUnknown(Swift.String)

        public static var allCases: [ServiceNowConnectorOperator] {
            return [
                .addition,
                .between,
                .contains,
                .division,
                .equalTo,
                .greaterThan,
                .greaterThanOrEqualTo,
                .lessThan,
                .lessThanOrEqualTo,
                .maskAll,
                .maskFirstN,
                .maskLastN,
                .multiplication,
                .notEqualTo,
                .noOp,
                .projection,
                .subtraction,
                .validateNonNegative,
                .validateNonNull,
                .validateNonZero,
                .validateNumeric,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .addition: return "ADDITION"
            case .between: return "BETWEEN"
            case .contains: return "CONTAINS"
            case .division: return "DIVISION"
            case .equalTo: return "EQUAL_TO"
            case .greaterThan: return "GREATER_THAN"
            case .greaterThanOrEqualTo: return "GREATER_THAN_OR_EQUAL_TO"
            case .lessThan: return "LESS_THAN"
            case .lessThanOrEqualTo: return "LESS_THAN_OR_EQUAL_TO"
            case .maskAll: return "MASK_ALL"
            case .maskFirstN: return "MASK_FIRST_N"
            case .maskLastN: return "MASK_LAST_N"
            case .multiplication: return "MULTIPLICATION"
            case .notEqualTo: return "NOT_EQUAL_TO"
            case .noOp: return "NO_OP"
            case .projection: return "PROJECTION"
            case .subtraction: return "SUBTRACTION"
            case .validateNonNegative: return "VALIDATE_NON_NEGATIVE"
            case .validateNonNull: return "VALIDATE_NON_NULL"
            case .validateNonZero: return "VALIDATE_NON_ZERO"
            case .validateNumeric: return "VALIDATE_NUMERIC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ServiceNowConnectorOperator(rawValue: rawValue) ?? ServiceNowConnectorOperator.sdkUnknown(rawValue)
        }
    }
}

extension AppflowClientTypes.ServiceNowConnectorProfileCredentials: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case password
        case username
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let password = password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let username = username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .username)
        username = usernameDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .password)
        password = passwordDecoded
    }
}

extension AppflowClientTypes {
    /// The connector-specific profile credentials required when using ServiceNow.
    public struct ServiceNowConnectorProfileCredentials: Swift.Equatable {
        /// The password that corresponds to the user name.
        /// This member is required.
        public var password: Swift.String?
        /// The name of the user.
        /// This member is required.
        public var username: Swift.String?

        public init (
            password: Swift.String? = nil,
            username: Swift.String? = nil
        )
        {
            self.password = password
            self.username = username
        }
    }

}

extension AppflowClientTypes.ServiceNowConnectorProfileProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceUrl
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceUrl = instanceUrl {
            try encodeContainer.encode(instanceUrl, forKey: .instanceUrl)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceUrl)
        instanceUrl = instanceUrlDecoded
    }
}

extension AppflowClientTypes {
    /// The connector-specific profile properties required when using ServiceNow.
    public struct ServiceNowConnectorProfileProperties: Swift.Equatable {
        /// The location of the ServiceNow resource.
        /// This member is required.
        public var instanceUrl: Swift.String?

        public init (
            instanceUrl: Swift.String? = nil
        )
        {
            self.instanceUrl = instanceUrl
        }
    }

}

extension AppflowClientTypes.ServiceNowMetadata: Swift.Codable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension AppflowClientTypes {
    /// The connector metadata specific to ServiceNow.
    public struct ServiceNowMetadata: Swift.Equatable {

    }

}

extension AppflowClientTypes.ServiceNowSourceProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case object
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let object = object {
            try encodeContainer.encode(object, forKey: .object)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .object)
        object = objectDecoded
    }
}

extension AppflowClientTypes {
    /// The properties that are applied when ServiceNow is being used as a source.
    public struct ServiceNowSourceProperties: Swift.Equatable {
        /// The object specified in the ServiceNow flow source.
        /// This member is required.
        public var object: Swift.String?

        public init (
            object: Swift.String? = nil
        )
        {
            self.object = object
        }
    }

}

extension ServiceQuotaExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request would cause a service quota (such as the number of flows) to be exceeded.
public struct ServiceQuotaExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AppflowClientTypes {
    public enum SingularConnectorOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case addition
        case division
        case equalTo
        case maskAll
        case maskFirstN
        case maskLastN
        case multiplication
        case noOp
        case projection
        case subtraction
        case validateNonNegative
        case validateNonNull
        case validateNonZero
        case validateNumeric
        case sdkUnknown(Swift.String)

        public static var allCases: [SingularConnectorOperator] {
            return [
                .addition,
                .division,
                .equalTo,
                .maskAll,
                .maskFirstN,
                .maskLastN,
                .multiplication,
                .noOp,
                .projection,
                .subtraction,
                .validateNonNegative,
                .validateNonNull,
                .validateNonZero,
                .validateNumeric,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .addition: return "ADDITION"
            case .division: return "DIVISION"
            case .equalTo: return "EQUAL_TO"
            case .maskAll: return "MASK_ALL"
            case .maskFirstN: return "MASK_FIRST_N"
            case .maskLastN: return "MASK_LAST_N"
            case .multiplication: return "MULTIPLICATION"
            case .noOp: return "NO_OP"
            case .projection: return "PROJECTION"
            case .subtraction: return "SUBTRACTION"
            case .validateNonNegative: return "VALIDATE_NON_NEGATIVE"
            case .validateNonNull: return "VALIDATE_NON_NULL"
            case .validateNonZero: return "VALIDATE_NON_ZERO"
            case .validateNumeric: return "VALIDATE_NUMERIC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SingularConnectorOperator(rawValue: rawValue) ?? SingularConnectorOperator.sdkUnknown(rawValue)
        }
    }
}

extension AppflowClientTypes.SingularConnectorProfileCredentials: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiKey
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiKey = apiKey {
            try encodeContainer.encode(apiKey, forKey: .apiKey)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiKey)
        apiKey = apiKeyDecoded
    }
}

extension AppflowClientTypes {
    /// The connector-specific profile credentials required when using Singular.
    public struct SingularConnectorProfileCredentials: Swift.Equatable {
        /// A unique alphanumeric identifier used to authenticate a user, developer, or calling program to your API.
        /// This member is required.
        public var apiKey: Swift.String?

        public init (
            apiKey: Swift.String? = nil
        )
        {
            self.apiKey = apiKey
        }
    }

}

extension AppflowClientTypes.SingularConnectorProfileProperties: Swift.Codable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension AppflowClientTypes {
    /// The connector-specific profile properties required when using Singular.
    public struct SingularConnectorProfileProperties: Swift.Equatable {

    }

}

extension AppflowClientTypes.SingularMetadata: Swift.Codable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension AppflowClientTypes {
    /// The connector metadata specific to Singular.
    public struct SingularMetadata: Swift.Equatable {

    }

}

extension AppflowClientTypes.SingularSourceProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case object
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let object = object {
            try encodeContainer.encode(object, forKey: .object)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .object)
        object = objectDecoded
    }
}

extension AppflowClientTypes {
    /// The properties that are applied when Singular is being used as a source.
    public struct SingularSourceProperties: Swift.Equatable {
        /// The object specified in the Singular flow source.
        /// This member is required.
        public var object: Swift.String?

        public init (
            object: Swift.String? = nil
        )
        {
            self.object = object
        }
    }

}

extension AppflowClientTypes {
    public enum SlackConnectorOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case addition
        case between
        case division
        case equalTo
        case greaterThan
        case greaterThanOrEqualTo
        case lessThan
        case lessThanOrEqualTo
        case maskAll
        case maskFirstN
        case maskLastN
        case multiplication
        case noOp
        case projection
        case subtraction
        case validateNonNegative
        case validateNonNull
        case validateNonZero
        case validateNumeric
        case sdkUnknown(Swift.String)

        public static var allCases: [SlackConnectorOperator] {
            return [
                .addition,
                .between,
                .division,
                .equalTo,
                .greaterThan,
                .greaterThanOrEqualTo,
                .lessThan,
                .lessThanOrEqualTo,
                .maskAll,
                .maskFirstN,
                .maskLastN,
                .multiplication,
                .noOp,
                .projection,
                .subtraction,
                .validateNonNegative,
                .validateNonNull,
                .validateNonZero,
                .validateNumeric,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .addition: return "ADDITION"
            case .between: return "BETWEEN"
            case .division: return "DIVISION"
            case .equalTo: return "EQUAL_TO"
            case .greaterThan: return "GREATER_THAN"
            case .greaterThanOrEqualTo: return "GREATER_THAN_OR_EQUAL_TO"
            case .lessThan: return "LESS_THAN"
            case .lessThanOrEqualTo: return "LESS_THAN_OR_EQUAL_TO"
            case .maskAll: return "MASK_ALL"
            case .maskFirstN: return "MASK_FIRST_N"
            case .maskLastN: return "MASK_LAST_N"
            case .multiplication: return "MULTIPLICATION"
            case .noOp: return "NO_OP"
            case .projection: return "PROJECTION"
            case .subtraction: return "SUBTRACTION"
            case .validateNonNegative: return "VALIDATE_NON_NEGATIVE"
            case .validateNonNull: return "VALIDATE_NON_NULL"
            case .validateNonZero: return "VALIDATE_NON_ZERO"
            case .validateNumeric: return "VALIDATE_NUMERIC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SlackConnectorOperator(rawValue: rawValue) ?? SlackConnectorOperator.sdkUnknown(rawValue)
        }
    }
}

extension AppflowClientTypes.SlackConnectorProfileCredentials: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessToken
        case clientId
        case clientSecret
        case oAuthRequest
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessToken = accessToken {
            try encodeContainer.encode(accessToken, forKey: .accessToken)
        }
        if let clientId = clientId {
            try encodeContainer.encode(clientId, forKey: .clientId)
        }
        if let clientSecret = clientSecret {
            try encodeContainer.encode(clientSecret, forKey: .clientSecret)
        }
        if let oAuthRequest = oAuthRequest {
            try encodeContainer.encode(oAuthRequest, forKey: .oAuthRequest)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientId)
        clientId = clientIdDecoded
        let clientSecretDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientSecret)
        clientSecret = clientSecretDecoded
        let accessTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessToken)
        accessToken = accessTokenDecoded
        let oAuthRequestDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ConnectorOAuthRequest.self, forKey: .oAuthRequest)
        oAuthRequest = oAuthRequestDecoded
    }
}

extension AppflowClientTypes {
    /// The connector-specific profile credentials required when using Slack.
    public struct SlackConnectorProfileCredentials: Swift.Equatable {
        /// The credentials used to access protected Slack resources.
        public var accessToken: Swift.String?
        /// The identifier for the client.
        /// This member is required.
        public var clientId: Swift.String?
        /// The client secret used by the OAuth client to authenticate to the authorization server.
        /// This member is required.
        public var clientSecret: Swift.String?
        /// The OAuth requirement needed to request security tokens from the connector endpoint.
        public var oAuthRequest: AppflowClientTypes.ConnectorOAuthRequest?

        public init (
            accessToken: Swift.String? = nil,
            clientId: Swift.String? = nil,
            clientSecret: Swift.String? = nil,
            oAuthRequest: AppflowClientTypes.ConnectorOAuthRequest? = nil
        )
        {
            self.accessToken = accessToken
            self.clientId = clientId
            self.clientSecret = clientSecret
            self.oAuthRequest = oAuthRequest
        }
    }

}

extension AppflowClientTypes.SlackConnectorProfileProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceUrl
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceUrl = instanceUrl {
            try encodeContainer.encode(instanceUrl, forKey: .instanceUrl)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceUrl)
        instanceUrl = instanceUrlDecoded
    }
}

extension AppflowClientTypes {
    /// The connector-specific profile properties required when using Slack.
    public struct SlackConnectorProfileProperties: Swift.Equatable {
        /// The location of the Slack resource.
        /// This member is required.
        public var instanceUrl: Swift.String?

        public init (
            instanceUrl: Swift.String? = nil
        )
        {
            self.instanceUrl = instanceUrl
        }
    }

}

extension AppflowClientTypes.SlackMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case oAuthScopes
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let oAuthScopes = oAuthScopes {
            var oAuthScopesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .oAuthScopes)
            for oauthscopelist0 in oAuthScopes {
                try oAuthScopesContainer.encode(oauthscopelist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let oAuthScopesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .oAuthScopes)
        var oAuthScopesDecoded0:[Swift.String]? = nil
        if let oAuthScopesContainer = oAuthScopesContainer {
            oAuthScopesDecoded0 = [Swift.String]()
            for string0 in oAuthScopesContainer {
                if let string0 = string0 {
                    oAuthScopesDecoded0?.append(string0)
                }
            }
        }
        oAuthScopes = oAuthScopesDecoded0
    }
}

extension AppflowClientTypes {
    /// The connector metadata specific to Slack.
    public struct SlackMetadata: Swift.Equatable {
        /// The desired authorization scope for the Slack account.
        public var oAuthScopes: [Swift.String]?

        public init (
            oAuthScopes: [Swift.String]? = nil
        )
        {
            self.oAuthScopes = oAuthScopes
        }
    }

}

extension AppflowClientTypes.SlackSourceProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case object
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let object = object {
            try encodeContainer.encode(object, forKey: .object)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .object)
        object = objectDecoded
    }
}

extension AppflowClientTypes {
    /// The properties that are applied when Slack is being used as a source.
    public struct SlackSourceProperties: Swift.Equatable {
        /// The object specified in the Slack flow source.
        /// This member is required.
        public var object: Swift.String?

        public init (
            object: Swift.String? = nil
        )
        {
            self.object = object
        }
    }

}

extension AppflowClientTypes.SnowflakeConnectorProfileCredentials: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case password
        case username
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let password = password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let username = username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .username)
        username = usernameDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .password)
        password = passwordDecoded
    }
}

extension AppflowClientTypes {
    /// The connector-specific profile credentials required when using Snowflake.
    public struct SnowflakeConnectorProfileCredentials: Swift.Equatable {
        /// The password that corresponds to the user name.
        /// This member is required.
        public var password: Swift.String?
        /// The name of the user.
        /// This member is required.
        public var username: Swift.String?

        public init (
            password: Swift.String? = nil,
            username: Swift.String? = nil
        )
        {
            self.password = password
            self.username = username
        }
    }

}

extension AppflowClientTypes.SnowflakeConnectorProfileProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountName
        case bucketName
        case bucketPrefix
        case privateLinkServiceName
        case region
        case stage
        case warehouse
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountName = accountName {
            try encodeContainer.encode(accountName, forKey: .accountName)
        }
        if let bucketName = bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
        if let bucketPrefix = bucketPrefix {
            try encodeContainer.encode(bucketPrefix, forKey: .bucketPrefix)
        }
        if let privateLinkServiceName = privateLinkServiceName {
            try encodeContainer.encode(privateLinkServiceName, forKey: .privateLinkServiceName)
        }
        if let region = region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let stage = stage {
            try encodeContainer.encode(stage, forKey: .stage)
        }
        if let warehouse = warehouse {
            try encodeContainer.encode(warehouse, forKey: .warehouse)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let warehouseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .warehouse)
        warehouse = warehouseDecoded
        let stageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stage)
        stage = stageDecoded
        let bucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
        let bucketPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketPrefix)
        bucketPrefix = bucketPrefixDecoded
        let privateLinkServiceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .privateLinkServiceName)
        privateLinkServiceName = privateLinkServiceNameDecoded
        let accountNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountName)
        accountName = accountNameDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
    }
}

extension AppflowClientTypes {
    /// The connector-specific profile properties required when using Snowflake.
    public struct SnowflakeConnectorProfileProperties: Swift.Equatable {
        /// The name of the account.
        public var accountName: Swift.String?
        /// The name of the Amazon S3 bucket associated with Snowflake.
        /// This member is required.
        public var bucketName: Swift.String?
        /// The bucket path that refers to the Amazon S3 bucket associated with Snowflake.
        public var bucketPrefix: Swift.String?
        /// The Snowflake Private Link service name to be used for private data transfers.
        public var privateLinkServiceName: Swift.String?
        /// The Amazon Web Services Region of the Snowflake account.
        public var region: Swift.String?
        /// The name of the Amazon S3 stage that was created while setting up an Amazon S3 stage in the Snowflake account. This is written in the following format: < Database>< Schema>.
        /// This member is required.
        public var stage: Swift.String?
        /// The name of the Snowflake warehouse.
        /// This member is required.
        public var warehouse: Swift.String?

        public init (
            accountName: Swift.String? = nil,
            bucketName: Swift.String? = nil,
            bucketPrefix: Swift.String? = nil,
            privateLinkServiceName: Swift.String? = nil,
            region: Swift.String? = nil,
            stage: Swift.String? = nil,
            warehouse: Swift.String? = nil
        )
        {
            self.accountName = accountName
            self.bucketName = bucketName
            self.bucketPrefix = bucketPrefix
            self.privateLinkServiceName = privateLinkServiceName
            self.region = region
            self.stage = stage
            self.warehouse = warehouse
        }
    }

}

extension AppflowClientTypes.SnowflakeDestinationProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketPrefix
        case errorHandlingConfig
        case intermediateBucketName
        case object
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketPrefix = bucketPrefix {
            try encodeContainer.encode(bucketPrefix, forKey: .bucketPrefix)
        }
        if let errorHandlingConfig = errorHandlingConfig {
            try encodeContainer.encode(errorHandlingConfig, forKey: .errorHandlingConfig)
        }
        if let intermediateBucketName = intermediateBucketName {
            try encodeContainer.encode(intermediateBucketName, forKey: .intermediateBucketName)
        }
        if let object = object {
            try encodeContainer.encode(object, forKey: .object)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .object)
        object = objectDecoded
        let intermediateBucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .intermediateBucketName)
        intermediateBucketName = intermediateBucketNameDecoded
        let bucketPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketPrefix)
        bucketPrefix = bucketPrefixDecoded
        let errorHandlingConfigDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ErrorHandlingConfig.self, forKey: .errorHandlingConfig)
        errorHandlingConfig = errorHandlingConfigDecoded
    }
}

extension AppflowClientTypes {
    /// The properties that are applied when Snowflake is being used as a destination.
    public struct SnowflakeDestinationProperties: Swift.Equatable {
        /// The object key for the destination bucket in which Amazon AppFlow places the files.
        public var bucketPrefix: Swift.String?
        /// The settings that determine how Amazon AppFlow handles an error when placing data in the Snowflake destination. For example, this setting would determine if the flow should fail after one insertion error, or continue and attempt to insert every record regardless of the initial failure. ErrorHandlingConfig is a part of the destination connector details.
        public var errorHandlingConfig: AppflowClientTypes.ErrorHandlingConfig?
        /// The intermediate bucket that Amazon AppFlow uses when moving data into Snowflake.
        /// This member is required.
        public var intermediateBucketName: Swift.String?
        /// The object specified in the Snowflake flow destination.
        /// This member is required.
        public var object: Swift.String?

        public init (
            bucketPrefix: Swift.String? = nil,
            errorHandlingConfig: AppflowClientTypes.ErrorHandlingConfig? = nil,
            intermediateBucketName: Swift.String? = nil,
            object: Swift.String? = nil
        )
        {
            self.bucketPrefix = bucketPrefix
            self.errorHandlingConfig = errorHandlingConfig
            self.intermediateBucketName = intermediateBucketName
            self.object = object
        }
    }

}

extension AppflowClientTypes.SnowflakeMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case supportedRegions
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let supportedRegions = supportedRegions {
            var supportedRegionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .supportedRegions)
            for regionlist0 in supportedRegions {
                try supportedRegionsContainer.encode(regionlist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let supportedRegionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .supportedRegions)
        var supportedRegionsDecoded0:[Swift.String]? = nil
        if let supportedRegionsContainer = supportedRegionsContainer {
            supportedRegionsDecoded0 = [Swift.String]()
            for string0 in supportedRegionsContainer {
                if let string0 = string0 {
                    supportedRegionsDecoded0?.append(string0)
                }
            }
        }
        supportedRegions = supportedRegionsDecoded0
    }
}

extension AppflowClientTypes {
    /// The connector metadata specific to Snowflake.
    public struct SnowflakeMetadata: Swift.Equatable {
        /// Specifies the supported Amazon Web Services Regions when using Snowflake.
        public var supportedRegions: [Swift.String]?

        public init (
            supportedRegions: [Swift.String]? = nil
        )
        {
            self.supportedRegions = supportedRegions
        }
    }

}

extension AppflowClientTypes.SourceConnectorProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amplitude = "Amplitude"
        case datadog = "Datadog"
        case dynatrace = "Dynatrace"
        case googleAnalytics = "GoogleAnalytics"
        case inforNexus = "InforNexus"
        case marketo = "Marketo"
        case s3 = "S3"
        case sAPOData = "SAPOData"
        case salesforce = "Salesforce"
        case serviceNow = "ServiceNow"
        case singular = "Singular"
        case slack = "Slack"
        case trendmicro = "Trendmicro"
        case veeva = "Veeva"
        case zendesk = "Zendesk"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amplitude = amplitude {
            try encodeContainer.encode(amplitude, forKey: .amplitude)
        }
        if let datadog = datadog {
            try encodeContainer.encode(datadog, forKey: .datadog)
        }
        if let dynatrace = dynatrace {
            try encodeContainer.encode(dynatrace, forKey: .dynatrace)
        }
        if let googleAnalytics = googleAnalytics {
            try encodeContainer.encode(googleAnalytics, forKey: .googleAnalytics)
        }
        if let inforNexus = inforNexus {
            try encodeContainer.encode(inforNexus, forKey: .inforNexus)
        }
        if let marketo = marketo {
            try encodeContainer.encode(marketo, forKey: .marketo)
        }
        if let s3 = s3 {
            try encodeContainer.encode(s3, forKey: .s3)
        }
        if let sAPOData = sAPOData {
            try encodeContainer.encode(sAPOData, forKey: .sAPOData)
        }
        if let salesforce = salesforce {
            try encodeContainer.encode(salesforce, forKey: .salesforce)
        }
        if let serviceNow = serviceNow {
            try encodeContainer.encode(serviceNow, forKey: .serviceNow)
        }
        if let singular = singular {
            try encodeContainer.encode(singular, forKey: .singular)
        }
        if let slack = slack {
            try encodeContainer.encode(slack, forKey: .slack)
        }
        if let trendmicro = trendmicro {
            try encodeContainer.encode(trendmicro, forKey: .trendmicro)
        }
        if let veeva = veeva {
            try encodeContainer.encode(veeva, forKey: .veeva)
        }
        if let zendesk = zendesk {
            try encodeContainer.encode(zendesk, forKey: .zendesk)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let amplitudeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.AmplitudeSourceProperties.self, forKey: .amplitude)
        amplitude = amplitudeDecoded
        let datadogDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.DatadogSourceProperties.self, forKey: .datadog)
        datadog = datadogDecoded
        let dynatraceDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.DynatraceSourceProperties.self, forKey: .dynatrace)
        dynatrace = dynatraceDecoded
        let googleAnalyticsDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.GoogleAnalyticsSourceProperties.self, forKey: .googleAnalytics)
        googleAnalytics = googleAnalyticsDecoded
        let inforNexusDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.InforNexusSourceProperties.self, forKey: .inforNexus)
        inforNexus = inforNexusDecoded
        let marketoDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.MarketoSourceProperties.self, forKey: .marketo)
        marketo = marketoDecoded
        let s3Decoded = try containerValues.decodeIfPresent(AppflowClientTypes.S3SourceProperties.self, forKey: .s3)
        s3 = s3Decoded
        let salesforceDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.SalesforceSourceProperties.self, forKey: .salesforce)
        salesforce = salesforceDecoded
        let serviceNowDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ServiceNowSourceProperties.self, forKey: .serviceNow)
        serviceNow = serviceNowDecoded
        let singularDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.SingularSourceProperties.self, forKey: .singular)
        singular = singularDecoded
        let slackDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.SlackSourceProperties.self, forKey: .slack)
        slack = slackDecoded
        let trendmicroDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.TrendmicroSourceProperties.self, forKey: .trendmicro)
        trendmicro = trendmicroDecoded
        let veevaDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.VeevaSourceProperties.self, forKey: .veeva)
        veeva = veevaDecoded
        let zendeskDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ZendeskSourceProperties.self, forKey: .zendesk)
        zendesk = zendeskDecoded
        let sAPODataDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.SAPODataSourceProperties.self, forKey: .sAPOData)
        sAPOData = sAPODataDecoded
    }
}

extension AppflowClientTypes {
    /// Specifies the information that is required to query a particular connector.
    public struct SourceConnectorProperties: Swift.Equatable {
        /// Specifies the information that is required for querying Amplitude.
        public var amplitude: AppflowClientTypes.AmplitudeSourceProperties?
        /// Specifies the information that is required for querying Datadog.
        public var datadog: AppflowClientTypes.DatadogSourceProperties?
        /// Specifies the information that is required for querying Dynatrace.
        public var dynatrace: AppflowClientTypes.DynatraceSourceProperties?
        /// Specifies the information that is required for querying Google Analytics.
        public var googleAnalytics: AppflowClientTypes.GoogleAnalyticsSourceProperties?
        /// Specifies the information that is required for querying Infor Nexus.
        public var inforNexus: AppflowClientTypes.InforNexusSourceProperties?
        /// Specifies the information that is required for querying Marketo.
        public var marketo: AppflowClientTypes.MarketoSourceProperties?
        /// Specifies the information that is required for querying Amazon S3.
        public var s3: AppflowClientTypes.S3SourceProperties?
        /// The properties that are applied when using SAPOData as a flow source.
        public var sAPOData: AppflowClientTypes.SAPODataSourceProperties?
        /// Specifies the information that is required for querying Salesforce.
        public var salesforce: AppflowClientTypes.SalesforceSourceProperties?
        /// Specifies the information that is required for querying ServiceNow.
        public var serviceNow: AppflowClientTypes.ServiceNowSourceProperties?
        /// Specifies the information that is required for querying Singular.
        public var singular: AppflowClientTypes.SingularSourceProperties?
        /// Specifies the information that is required for querying Slack.
        public var slack: AppflowClientTypes.SlackSourceProperties?
        /// Specifies the information that is required for querying Trend Micro.
        public var trendmicro: AppflowClientTypes.TrendmicroSourceProperties?
        /// Specifies the information that is required for querying Veeva.
        public var veeva: AppflowClientTypes.VeevaSourceProperties?
        /// Specifies the information that is required for querying Zendesk.
        public var zendesk: AppflowClientTypes.ZendeskSourceProperties?

        public init (
            amplitude: AppflowClientTypes.AmplitudeSourceProperties? = nil,
            datadog: AppflowClientTypes.DatadogSourceProperties? = nil,
            dynatrace: AppflowClientTypes.DynatraceSourceProperties? = nil,
            googleAnalytics: AppflowClientTypes.GoogleAnalyticsSourceProperties? = nil,
            inforNexus: AppflowClientTypes.InforNexusSourceProperties? = nil,
            marketo: AppflowClientTypes.MarketoSourceProperties? = nil,
            s3: AppflowClientTypes.S3SourceProperties? = nil,
            sAPOData: AppflowClientTypes.SAPODataSourceProperties? = nil,
            salesforce: AppflowClientTypes.SalesforceSourceProperties? = nil,
            serviceNow: AppflowClientTypes.ServiceNowSourceProperties? = nil,
            singular: AppflowClientTypes.SingularSourceProperties? = nil,
            slack: AppflowClientTypes.SlackSourceProperties? = nil,
            trendmicro: AppflowClientTypes.TrendmicroSourceProperties? = nil,
            veeva: AppflowClientTypes.VeevaSourceProperties? = nil,
            zendesk: AppflowClientTypes.ZendeskSourceProperties? = nil
        )
        {
            self.amplitude = amplitude
            self.datadog = datadog
            self.dynatrace = dynatrace
            self.googleAnalytics = googleAnalytics
            self.inforNexus = inforNexus
            self.marketo = marketo
            self.s3 = s3
            self.sAPOData = sAPOData
            self.salesforce = salesforce
            self.serviceNow = serviceNow
            self.singular = singular
            self.slack = slack
            self.trendmicro = trendmicro
            self.veeva = veeva
            self.zendesk = zendesk
        }
    }

}

extension AppflowClientTypes.SourceFieldProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isQueryable
        case isRetrievable
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if isQueryable != false {
            try encodeContainer.encode(isQueryable, forKey: .isQueryable)
        }
        if isRetrievable != false {
            try encodeContainer.encode(isRetrievable, forKey: .isRetrievable)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let isRetrievableDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isRetrievable)
        isRetrievable = isRetrievableDecoded
        let isQueryableDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isQueryable)
        isQueryable = isQueryableDecoded
    }
}

extension AppflowClientTypes {
    /// The properties that can be applied to a field when the connector is being used as a source.
    public struct SourceFieldProperties: Swift.Equatable {
        /// Indicates if the field can be queried.
        public var isQueryable: Swift.Bool
        /// Indicates whether the field can be returned in a search result.
        public var isRetrievable: Swift.Bool

        public init (
            isQueryable: Swift.Bool = false,
            isRetrievable: Swift.Bool = false
        )
        {
            self.isQueryable = isQueryable
            self.isRetrievable = isRetrievable
        }
    }

}

extension AppflowClientTypes.SourceFlowConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectorProfileName
        case connectorType
        case incrementalPullConfig
        case sourceConnectorProperties
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectorProfileName = connectorProfileName {
            try encodeContainer.encode(connectorProfileName, forKey: .connectorProfileName)
        }
        if let connectorType = connectorType {
            try encodeContainer.encode(connectorType.rawValue, forKey: .connectorType)
        }
        if let incrementalPullConfig = incrementalPullConfig {
            try encodeContainer.encode(incrementalPullConfig, forKey: .incrementalPullConfig)
        }
        if let sourceConnectorProperties = sourceConnectorProperties {
            try encodeContainer.encode(sourceConnectorProperties, forKey: .sourceConnectorProperties)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorTypeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ConnectorType.self, forKey: .connectorType)
        connectorType = connectorTypeDecoded
        let connectorProfileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectorProfileName)
        connectorProfileName = connectorProfileNameDecoded
        let sourceConnectorPropertiesDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.SourceConnectorProperties.self, forKey: .sourceConnectorProperties)
        sourceConnectorProperties = sourceConnectorPropertiesDecoded
        let incrementalPullConfigDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.IncrementalPullConfig.self, forKey: .incrementalPullConfig)
        incrementalPullConfig = incrementalPullConfigDecoded
    }
}

extension AppflowClientTypes {
    /// Contains information about the configuration of the source connector used in the flow.
    public struct SourceFlowConfig: Swift.Equatable {
        /// The name of the connector profile. This name must be unique for each connector profile in the Amazon Web Services account.
        public var connectorProfileName: Swift.String?
        /// The type of connector, such as Salesforce, Amplitude, and so on.
        /// This member is required.
        public var connectorType: AppflowClientTypes.ConnectorType?
        /// Defines the configuration for a scheduled incremental data pull. If a valid configuration is provided, the fields specified in the configuration are used when querying for the incremental data pull.
        public var incrementalPullConfig: AppflowClientTypes.IncrementalPullConfig?
        /// Specifies the information that is required to query a particular source connector.
        /// This member is required.
        public var sourceConnectorProperties: AppflowClientTypes.SourceConnectorProperties?

        public init (
            connectorProfileName: Swift.String? = nil,
            connectorType: AppflowClientTypes.ConnectorType? = nil,
            incrementalPullConfig: AppflowClientTypes.IncrementalPullConfig? = nil,
            sourceConnectorProperties: AppflowClientTypes.SourceConnectorProperties? = nil
        )
        {
            self.connectorProfileName = connectorProfileName
            self.connectorType = connectorType
            self.incrementalPullConfig = incrementalPullConfig
            self.sourceConnectorProperties = sourceConnectorProperties
        }
    }

}

extension StartFlowInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case flowName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let flowName = flowName {
            try encodeContainer.encode(flowName, forKey: .flowName)
        }
    }
}

extension StartFlowInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/start-flow"
    }
}

public struct StartFlowInput: Swift.Equatable {
    /// The specified name of the flow. Spaces are not allowed. Use underscores (_) or hyphens (-) only.
    /// This member is required.
    public var flowName: Swift.String?

    public init (
        flowName: Swift.String? = nil
    )
    {
        self.flowName = flowName
    }
}

struct StartFlowInputBody: Swift.Equatable {
    let flowName: Swift.String?
}

extension StartFlowInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case flowName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowName)
        flowName = flowNameDecoded
    }
}

extension StartFlowOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartFlowOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartFlowOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartFlowOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StartFlowOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.executionId = output.executionId
            self.flowArn = output.flowArn
            self.flowStatus = output.flowStatus
        } else {
            self.executionId = nil
            self.flowArn = nil
            self.flowStatus = nil
        }
    }
}

public struct StartFlowOutputResponse: Swift.Equatable {
    /// Returns the internal execution ID of an on-demand flow when the flow is started. For scheduled or event-triggered flows, this value is null.
    public var executionId: Swift.String?
    /// The flow's Amazon Resource Name (ARN).
    public var flowArn: Swift.String?
    /// Indicates the current status of the flow.
    public var flowStatus: AppflowClientTypes.FlowStatus?

    public init (
        executionId: Swift.String? = nil,
        flowArn: Swift.String? = nil,
        flowStatus: AppflowClientTypes.FlowStatus? = nil
    )
    {
        self.executionId = executionId
        self.flowArn = flowArn
        self.flowStatus = flowStatus
    }
}

struct StartFlowOutputResponseBody: Swift.Equatable {
    let flowArn: Swift.String?
    let flowStatus: AppflowClientTypes.FlowStatus?
    let executionId: Swift.String?
}

extension StartFlowOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case executionId
        case flowArn
        case flowStatus
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowArn)
        flowArn = flowArnDecoded
        let flowStatusDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.FlowStatus.self, forKey: .flowStatus)
        flowStatus = flowStatusDecoded
        let executionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionId)
        executionId = executionIdDecoded
    }
}

extension StopFlowInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case flowName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let flowName = flowName {
            try encodeContainer.encode(flowName, forKey: .flowName)
        }
    }
}

extension StopFlowInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/stop-flow"
    }
}

public struct StopFlowInput: Swift.Equatable {
    /// The specified name of the flow. Spaces are not allowed. Use underscores (_) or hyphens (-) only.
    /// This member is required.
    public var flowName: Swift.String?

    public init (
        flowName: Swift.String? = nil
    )
    {
        self.flowName = flowName
    }
}

struct StopFlowInputBody: Swift.Equatable {
    let flowName: Swift.String?
}

extension StopFlowInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case flowName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowName)
        flowName = flowNameDecoded
    }
}

extension StopFlowOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopFlowOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopFlowOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopFlowOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StopFlowOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.flowArn = output.flowArn
            self.flowStatus = output.flowStatus
        } else {
            self.flowArn = nil
            self.flowStatus = nil
        }
    }
}

public struct StopFlowOutputResponse: Swift.Equatable {
    /// The flow's Amazon Resource Name (ARN).
    public var flowArn: Swift.String?
    /// Indicates the current status of the flow.
    public var flowStatus: AppflowClientTypes.FlowStatus?

    public init (
        flowArn: Swift.String? = nil,
        flowStatus: AppflowClientTypes.FlowStatus? = nil
    )
    {
        self.flowArn = flowArn
        self.flowStatus = flowStatus
    }
}

struct StopFlowOutputResponseBody: Swift.Equatable {
    let flowArn: Swift.String?
    let flowStatus: AppflowClientTypes.FlowStatus?
}

extension StopFlowOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case flowArn
        case flowStatus
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowArn)
        flowArn = flowArnDecoded
        let flowStatusDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.FlowStatus.self, forKey: .flowStatus)
        flowStatus = flowStatusDecoded
    }
}

extension AppflowClientTypes.SupportedFieldTypeDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case v1
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let v1 = v1 {
            try encodeContainer.encode(v1, forKey: .v1)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let v1Decoded = try containerValues.decodeIfPresent(AppflowClientTypes.FieldTypeDetails.self, forKey: .v1)
        v1 = v1Decoded
    }
}

extension AppflowClientTypes {
    /// Contains details regarding all the supported FieldTypes and their corresponding filterOperators and supportedValues.
    public struct SupportedFieldTypeDetails: Swift.Equatable {
        /// The initial supported version for fieldType. If this is later changed to a different version, v2 will be introduced.
        /// This member is required.
        public var v1: AppflowClientTypes.FieldTypeDetails?

        public init (
            v1: AppflowClientTypes.FieldTypeDetails? = nil
        )
        {
            self.v1 = v1
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the flow that you want to tag.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags used to organize, track, or control access for your flow.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

}

extension AppflowClientTypes.Task: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectorOperator
        case destinationField
        case sourceFields
        case taskProperties
        case taskType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectorOperator = connectorOperator {
            try encodeContainer.encode(connectorOperator, forKey: .connectorOperator)
        }
        if let destinationField = destinationField {
            try encodeContainer.encode(destinationField, forKey: .destinationField)
        }
        if let sourceFields = sourceFields {
            var sourceFieldsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sourceFields)
            for sourcefields0 in sourceFields {
                try sourceFieldsContainer.encode(sourcefields0)
            }
        }
        if let taskProperties = taskProperties {
            var taskPropertiesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .taskProperties)
            for (dictKey0, taskpropertiesmap0) in taskProperties {
                try taskPropertiesContainer.encode(taskpropertiesmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let taskType = taskType {
            try encodeContainer.encode(taskType.rawValue, forKey: .taskType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceFieldsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .sourceFields)
        var sourceFieldsDecoded0:[Swift.String]? = nil
        if let sourceFieldsContainer = sourceFieldsContainer {
            sourceFieldsDecoded0 = [Swift.String]()
            for string0 in sourceFieldsContainer {
                if let string0 = string0 {
                    sourceFieldsDecoded0?.append(string0)
                }
            }
        }
        sourceFields = sourceFieldsDecoded0
        let connectorOperatorDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ConnectorOperator.self, forKey: .connectorOperator)
        connectorOperator = connectorOperatorDecoded
        let destinationFieldDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationField)
        destinationField = destinationFieldDecoded
        let taskTypeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.TaskType.self, forKey: .taskType)
        taskType = taskTypeDecoded
        let taskPropertiesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .taskProperties)
        var taskPropertiesDecoded0: [Swift.String:Swift.String]? = nil
        if let taskPropertiesContainer = taskPropertiesContainer {
            taskPropertiesDecoded0 = [Swift.String:Swift.String]()
            for (key0, property0) in taskPropertiesContainer {
                if let property0 = property0 {
                    taskPropertiesDecoded0?[key0] = property0
                }
            }
        }
        taskProperties = taskPropertiesDecoded0
    }
}

extension AppflowClientTypes {
    /// A class for modeling different type of tasks. Task implementation varies based on the TaskType.
    public struct Task: Swift.Equatable {
        /// The operation to be performed on the provided source fields.
        public var connectorOperator: AppflowClientTypes.ConnectorOperator?
        /// A field in a destination connector, or a field value against which Amazon AppFlow validates a source field.
        public var destinationField: Swift.String?
        /// The source fields to which a particular task is applied.
        /// This member is required.
        public var sourceFields: [Swift.String]?
        /// A map used to store task-related information. The execution service looks for particular information based on the TaskType.
        public var taskProperties: [Swift.String:Swift.String]?
        /// Specifies the particular task implementation that Amazon AppFlow performs.
        /// This member is required.
        public var taskType: AppflowClientTypes.TaskType?

        public init (
            connectorOperator: AppflowClientTypes.ConnectorOperator? = nil,
            destinationField: Swift.String? = nil,
            sourceFields: [Swift.String]? = nil,
            taskProperties: [Swift.String:Swift.String]? = nil,
            taskType: AppflowClientTypes.TaskType? = nil
        )
        {
            self.connectorOperator = connectorOperator
            self.destinationField = destinationField
            self.sourceFields = sourceFields
            self.taskProperties = taskProperties
            self.taskType = taskType
        }
    }

}

extension AppflowClientTypes {
    public enum TaskType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case arithmetic
        case filter
        case map
        case mapAll
        case mask
        case merge
        case truncate
        case validate
        case sdkUnknown(Swift.String)

        public static var allCases: [TaskType] {
            return [
                .arithmetic,
                .filter,
                .map,
                .mapAll,
                .mask,
                .merge,
                .truncate,
                .validate,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .arithmetic: return "Arithmetic"
            case .filter: return "Filter"
            case .map: return "Map"
            case .mapAll: return "Map_all"
            case .mask: return "Mask"
            case .merge: return "Merge"
            case .truncate: return "Truncate"
            case .validate: return "Validate"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TaskType(rawValue: rawValue) ?? TaskType.sdkUnknown(rawValue)
        }
    }
}

extension AppflowClientTypes {
    public enum TrendmicroConnectorOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case addition
        case division
        case equalTo
        case maskAll
        case maskFirstN
        case maskLastN
        case multiplication
        case noOp
        case projection
        case subtraction
        case validateNonNegative
        case validateNonNull
        case validateNonZero
        case validateNumeric
        case sdkUnknown(Swift.String)

        public static var allCases: [TrendmicroConnectorOperator] {
            return [
                .addition,
                .division,
                .equalTo,
                .maskAll,
                .maskFirstN,
                .maskLastN,
                .multiplication,
                .noOp,
                .projection,
                .subtraction,
                .validateNonNegative,
                .validateNonNull,
                .validateNonZero,
                .validateNumeric,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .addition: return "ADDITION"
            case .division: return "DIVISION"
            case .equalTo: return "EQUAL_TO"
            case .maskAll: return "MASK_ALL"
            case .maskFirstN: return "MASK_FIRST_N"
            case .maskLastN: return "MASK_LAST_N"
            case .multiplication: return "MULTIPLICATION"
            case .noOp: return "NO_OP"
            case .projection: return "PROJECTION"
            case .subtraction: return "SUBTRACTION"
            case .validateNonNegative: return "VALIDATE_NON_NEGATIVE"
            case .validateNonNull: return "VALIDATE_NON_NULL"
            case .validateNonZero: return "VALIDATE_NON_ZERO"
            case .validateNumeric: return "VALIDATE_NUMERIC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TrendmicroConnectorOperator(rawValue: rawValue) ?? TrendmicroConnectorOperator.sdkUnknown(rawValue)
        }
    }
}

extension AppflowClientTypes.TrendmicroConnectorProfileCredentials: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiSecretKey
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiSecretKey = apiSecretKey {
            try encodeContainer.encode(apiSecretKey, forKey: .apiSecretKey)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiSecretKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiSecretKey)
        apiSecretKey = apiSecretKeyDecoded
    }
}

extension AppflowClientTypes {
    /// The connector-specific profile credentials required when using Trend Micro.
    public struct TrendmicroConnectorProfileCredentials: Swift.Equatable {
        /// The Secret Access Key portion of the credentials.
        /// This member is required.
        public var apiSecretKey: Swift.String?

        public init (
            apiSecretKey: Swift.String? = nil
        )
        {
            self.apiSecretKey = apiSecretKey
        }
    }

}

extension AppflowClientTypes.TrendmicroConnectorProfileProperties: Swift.Codable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension AppflowClientTypes {
    /// The connector-specific profile properties required when using Trend Micro.
    public struct TrendmicroConnectorProfileProperties: Swift.Equatable {

    }

}

extension AppflowClientTypes.TrendmicroMetadata: Swift.Codable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension AppflowClientTypes {
    /// The connector metadata specific to Trend Micro.
    public struct TrendmicroMetadata: Swift.Equatable {

    }

}

extension AppflowClientTypes.TrendmicroSourceProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case object
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let object = object {
            try encodeContainer.encode(object, forKey: .object)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .object)
        object = objectDecoded
    }
}

extension AppflowClientTypes {
    /// The properties that are applied when using Trend Micro as a flow source.
    public struct TrendmicroSourceProperties: Swift.Equatable {
        /// The object specified in the Trend Micro flow source.
        /// This member is required.
        public var object: Swift.String?

        public init (
            object: Swift.String? = nil
        )
        {
            self.object = object
        }
    }

}

extension AppflowClientTypes.TriggerConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case triggerProperties
        case triggerType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let triggerProperties = triggerProperties {
            try encodeContainer.encode(triggerProperties, forKey: .triggerProperties)
        }
        if let triggerType = triggerType {
            try encodeContainer.encode(triggerType.rawValue, forKey: .triggerType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let triggerTypeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.TriggerType.self, forKey: .triggerType)
        triggerType = triggerTypeDecoded
        let triggerPropertiesDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.TriggerProperties.self, forKey: .triggerProperties)
        triggerProperties = triggerPropertiesDecoded
    }
}

extension AppflowClientTypes {
    /// The trigger settings that determine how and when Amazon AppFlow runs the specified flow.
    public struct TriggerConfig: Swift.Equatable {
        /// Specifies the configuration details of a schedule-triggered flow as defined by the user. Currently, these settings only apply to the Scheduled trigger type.
        public var triggerProperties: AppflowClientTypes.TriggerProperties?
        /// Specifies the type of flow trigger. This can be OnDemand, Scheduled, or Event.
        /// This member is required.
        public var triggerType: AppflowClientTypes.TriggerType?

        public init (
            triggerProperties: AppflowClientTypes.TriggerProperties? = nil,
            triggerType: AppflowClientTypes.TriggerType? = nil
        )
        {
            self.triggerProperties = triggerProperties
            self.triggerType = triggerType
        }
    }

}

extension AppflowClientTypes.TriggerProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case scheduled = "Scheduled"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let scheduled = scheduled {
            try encodeContainer.encode(scheduled, forKey: .scheduled)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scheduledDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ScheduledTriggerProperties.self, forKey: .scheduled)
        scheduled = scheduledDecoded
    }
}

extension AppflowClientTypes {
    /// Specifies the configuration details that control the trigger for a flow. Currently, these settings only apply to the Scheduled trigger type.
    public struct TriggerProperties: Swift.Equatable {
        /// Specifies the configuration details of a schedule-triggered flow as defined by the user.
        public var scheduled: AppflowClientTypes.ScheduledTriggerProperties?

        public init (
            scheduled: AppflowClientTypes.ScheduledTriggerProperties? = nil
        )
        {
            self.scheduled = scheduled
        }
    }

}

extension AppflowClientTypes {
    public enum TriggerType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case event
        case ondemand
        case scheduled
        case sdkUnknown(Swift.String)

        public static var allCases: [TriggerType] {
            return [
                .event,
                .ondemand,
                .scheduled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .event: return "Event"
            case .ondemand: return "OnDemand"
            case .scheduled: return "Scheduled"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TriggerType(rawValue: rawValue) ?? TriggerType.sdkUnknown(rawValue)
        }
    }
}

extension UnsupportedOperationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UnsupportedOperationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The requested operation is not supported for the current flow.
public struct UnsupportedOperationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct UnsupportedOperationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension UnsupportedOperationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let tagKeys = tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        return items
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the flow that you want to untag.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tag keys associated with the tag that you want to remove from your flow.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

}

extension UpdateConnectorProfileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionMode
        case connectorProfileConfig
        case connectorProfileName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionMode = connectionMode {
            try encodeContainer.encode(connectionMode.rawValue, forKey: .connectionMode)
        }
        if let connectorProfileConfig = connectorProfileConfig {
            try encodeContainer.encode(connectorProfileConfig, forKey: .connectorProfileConfig)
        }
        if let connectorProfileName = connectorProfileName {
            try encodeContainer.encode(connectorProfileName, forKey: .connectorProfileName)
        }
    }
}

extension UpdateConnectorProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/update-connector-profile"
    }
}

public struct UpdateConnectorProfileInput: Swift.Equatable {
    /// Indicates the connection mode and if it is public or private.
    /// This member is required.
    public var connectionMode: AppflowClientTypes.ConnectionMode?
    /// Defines the connector-specific profile configuration and credentials.
    /// This member is required.
    public var connectorProfileConfig: AppflowClientTypes.ConnectorProfileConfig?
    /// The name of the connector profile and is unique for each ConnectorProfile in the Amazon Web Services account.
    /// This member is required.
    public var connectorProfileName: Swift.String?

    public init (
        connectionMode: AppflowClientTypes.ConnectionMode? = nil,
        connectorProfileConfig: AppflowClientTypes.ConnectorProfileConfig? = nil,
        connectorProfileName: Swift.String? = nil
    )
    {
        self.connectionMode = connectionMode
        self.connectorProfileConfig = connectorProfileConfig
        self.connectorProfileName = connectorProfileName
    }
}

struct UpdateConnectorProfileInputBody: Swift.Equatable {
    let connectorProfileName: Swift.String?
    let connectionMode: AppflowClientTypes.ConnectionMode?
    let connectorProfileConfig: AppflowClientTypes.ConnectorProfileConfig?
}

extension UpdateConnectorProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionMode
        case connectorProfileConfig
        case connectorProfileName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorProfileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectorProfileName)
        connectorProfileName = connectorProfileNameDecoded
        let connectionModeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ConnectionMode.self, forKey: .connectionMode)
        connectionMode = connectionModeDecoded
        let connectorProfileConfigDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ConnectorProfileConfig.self, forKey: .connectorProfileConfig)
        connectorProfileConfig = connectorProfileConfigDecoded
    }
}

extension UpdateConnectorProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateConnectorProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConnectorAuthenticationException" : self = .connectorAuthenticationException(try ConnectorAuthenticationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateConnectorProfileOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case connectorAuthenticationException(ConnectorAuthenticationException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateConnectorProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateConnectorProfileOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.connectorProfileArn = output.connectorProfileArn
        } else {
            self.connectorProfileArn = nil
        }
    }
}

public struct UpdateConnectorProfileOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the connector profile.
    public var connectorProfileArn: Swift.String?

    public init (
        connectorProfileArn: Swift.String? = nil
    )
    {
        self.connectorProfileArn = connectorProfileArn
    }
}

struct UpdateConnectorProfileOutputResponseBody: Swift.Equatable {
    let connectorProfileArn: Swift.String?
}

extension UpdateConnectorProfileOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectorProfileArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorProfileArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectorProfileArn)
        connectorProfileArn = connectorProfileArnDecoded
    }
}

extension UpdateFlowInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case destinationFlowConfigList
        case flowName
        case sourceFlowConfig
        case tasks
        case triggerConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let destinationFlowConfigList = destinationFlowConfigList {
            var destinationFlowConfigListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .destinationFlowConfigList)
            for destinationflowconfiglist0 in destinationFlowConfigList {
                try destinationFlowConfigListContainer.encode(destinationflowconfiglist0)
            }
        }
        if let flowName = flowName {
            try encodeContainer.encode(flowName, forKey: .flowName)
        }
        if let sourceFlowConfig = sourceFlowConfig {
            try encodeContainer.encode(sourceFlowConfig, forKey: .sourceFlowConfig)
        }
        if let tasks = tasks {
            var tasksContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tasks)
            for tasks0 in tasks {
                try tasksContainer.encode(tasks0)
            }
        }
        if let triggerConfig = triggerConfig {
            try encodeContainer.encode(triggerConfig, forKey: .triggerConfig)
        }
    }
}

extension UpdateFlowInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/update-flow"
    }
}

public struct UpdateFlowInput: Swift.Equatable {
    /// A description of the flow.
    public var description: Swift.String?
    /// The configuration that controls how Amazon AppFlow transfers data to the destination connector.
    /// This member is required.
    public var destinationFlowConfigList: [AppflowClientTypes.DestinationFlowConfig]?
    /// The specified name of the flow. Spaces are not allowed. Use underscores (_) or hyphens (-) only.
    /// This member is required.
    public var flowName: Swift.String?
    /// Contains information about the configuration of the source connector used in the flow.
    /// This member is required.
    public var sourceFlowConfig: AppflowClientTypes.SourceFlowConfig?
    /// A list of tasks that Amazon AppFlow performs while transferring the data in the flow run.
    /// This member is required.
    public var tasks: [AppflowClientTypes.Task]?
    /// The trigger settings that determine how and when the flow runs.
    /// This member is required.
    public var triggerConfig: AppflowClientTypes.TriggerConfig?

    public init (
        description: Swift.String? = nil,
        destinationFlowConfigList: [AppflowClientTypes.DestinationFlowConfig]? = nil,
        flowName: Swift.String? = nil,
        sourceFlowConfig: AppflowClientTypes.SourceFlowConfig? = nil,
        tasks: [AppflowClientTypes.Task]? = nil,
        triggerConfig: AppflowClientTypes.TriggerConfig? = nil
    )
    {
        self.description = description
        self.destinationFlowConfigList = destinationFlowConfigList
        self.flowName = flowName
        self.sourceFlowConfig = sourceFlowConfig
        self.tasks = tasks
        self.triggerConfig = triggerConfig
    }
}

struct UpdateFlowInputBody: Swift.Equatable {
    let flowName: Swift.String?
    let description: Swift.String?
    let triggerConfig: AppflowClientTypes.TriggerConfig?
    let sourceFlowConfig: AppflowClientTypes.SourceFlowConfig?
    let destinationFlowConfigList: [AppflowClientTypes.DestinationFlowConfig]?
    let tasks: [AppflowClientTypes.Task]?
}

extension UpdateFlowInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case destinationFlowConfigList
        case flowName
        case sourceFlowConfig
        case tasks
        case triggerConfig
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowName)
        flowName = flowNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let triggerConfigDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.TriggerConfig.self, forKey: .triggerConfig)
        triggerConfig = triggerConfigDecoded
        let sourceFlowConfigDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.SourceFlowConfig.self, forKey: .sourceFlowConfig)
        sourceFlowConfig = sourceFlowConfigDecoded
        let destinationFlowConfigListContainer = try containerValues.decodeIfPresent([AppflowClientTypes.DestinationFlowConfig?].self, forKey: .destinationFlowConfigList)
        var destinationFlowConfigListDecoded0:[AppflowClientTypes.DestinationFlowConfig]? = nil
        if let destinationFlowConfigListContainer = destinationFlowConfigListContainer {
            destinationFlowConfigListDecoded0 = [AppflowClientTypes.DestinationFlowConfig]()
            for structure0 in destinationFlowConfigListContainer {
                if let structure0 = structure0 {
                    destinationFlowConfigListDecoded0?.append(structure0)
                }
            }
        }
        destinationFlowConfigList = destinationFlowConfigListDecoded0
        let tasksContainer = try containerValues.decodeIfPresent([AppflowClientTypes.Task?].self, forKey: .tasks)
        var tasksDecoded0:[AppflowClientTypes.Task]? = nil
        if let tasksContainer = tasksContainer {
            tasksDecoded0 = [AppflowClientTypes.Task]()
            for structure0 in tasksContainer {
                if let structure0 = structure0 {
                    tasksDecoded0?.append(structure0)
                }
            }
        }
        tasks = tasksDecoded0
    }
}

extension UpdateFlowOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateFlowOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConnectorAuthenticationException" : self = .connectorAuthenticationException(try ConnectorAuthenticationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConnectorServerException" : self = .connectorServerException(try ConnectorServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateFlowOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case connectorAuthenticationException(ConnectorAuthenticationException)
    case connectorServerException(ConnectorServerException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateFlowOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateFlowOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.flowStatus = output.flowStatus
        } else {
            self.flowStatus = nil
        }
    }
}

public struct UpdateFlowOutputResponse: Swift.Equatable {
    /// Indicates the current status of the flow.
    public var flowStatus: AppflowClientTypes.FlowStatus?

    public init (
        flowStatus: AppflowClientTypes.FlowStatus? = nil
    )
    {
        self.flowStatus = flowStatus
    }
}

struct UpdateFlowOutputResponseBody: Swift.Equatable {
    let flowStatus: AppflowClientTypes.FlowStatus?
}

extension UpdateFlowOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case flowStatus
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowStatusDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.FlowStatus.self, forKey: .flowStatus)
        flowStatus = flowStatusDecoded
    }
}

extension AppflowClientTypes.UpsolverDestinationProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketName
        case bucketPrefix
        case s3OutputFormatConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketName = bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
        if let bucketPrefix = bucketPrefix {
            try encodeContainer.encode(bucketPrefix, forKey: .bucketPrefix)
        }
        if let s3OutputFormatConfig = s3OutputFormatConfig {
            try encodeContainer.encode(s3OutputFormatConfig, forKey: .s3OutputFormatConfig)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
        let bucketPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketPrefix)
        bucketPrefix = bucketPrefixDecoded
        let s3OutputFormatConfigDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.UpsolverS3OutputFormatConfig.self, forKey: .s3OutputFormatConfig)
        s3OutputFormatConfig = s3OutputFormatConfigDecoded
    }
}

extension AppflowClientTypes {
    /// The properties that are applied when Upsolver is used as a destination.
    public struct UpsolverDestinationProperties: Swift.Equatable {
        /// The Upsolver Amazon S3 bucket name in which Amazon AppFlow places the transferred data.
        /// This member is required.
        public var bucketName: Swift.String?
        /// The object key for the destination Upsolver Amazon S3 bucket in which Amazon AppFlow places the files.
        public var bucketPrefix: Swift.String?
        /// The configuration that determines how data is formatted when Upsolver is used as the flow destination.
        /// This member is required.
        public var s3OutputFormatConfig: AppflowClientTypes.UpsolverS3OutputFormatConfig?

        public init (
            bucketName: Swift.String? = nil,
            bucketPrefix: Swift.String? = nil,
            s3OutputFormatConfig: AppflowClientTypes.UpsolverS3OutputFormatConfig? = nil
        )
        {
            self.bucketName = bucketName
            self.bucketPrefix = bucketPrefix
            self.s3OutputFormatConfig = s3OutputFormatConfig
        }
    }

}

extension AppflowClientTypes.UpsolverMetadata: Swift.Codable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension AppflowClientTypes {
    /// The connector metadata specific to Upsolver.
    public struct UpsolverMetadata: Swift.Equatable {

    }

}

extension AppflowClientTypes.UpsolverS3OutputFormatConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aggregationConfig
        case fileType
        case prefixConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aggregationConfig = aggregationConfig {
            try encodeContainer.encode(aggregationConfig, forKey: .aggregationConfig)
        }
        if let fileType = fileType {
            try encodeContainer.encode(fileType.rawValue, forKey: .fileType)
        }
        if let prefixConfig = prefixConfig {
            try encodeContainer.encode(prefixConfig, forKey: .prefixConfig)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileTypeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.FileType.self, forKey: .fileType)
        fileType = fileTypeDecoded
        let prefixConfigDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.PrefixConfig.self, forKey: .prefixConfig)
        prefixConfig = prefixConfigDecoded
        let aggregationConfigDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.AggregationConfig.self, forKey: .aggregationConfig)
        aggregationConfig = aggregationConfigDecoded
    }
}

extension AppflowClientTypes {
    /// The configuration that determines how Amazon AppFlow formats the flow output data when Upsolver is used as the destination.
    public struct UpsolverS3OutputFormatConfig: Swift.Equatable {
        /// The aggregation settings that you can use to customize the output format of your flow data.
        public var aggregationConfig: AppflowClientTypes.AggregationConfig?
        /// Indicates the file type that Amazon AppFlow places in the Upsolver Amazon S3 bucket.
        public var fileType: AppflowClientTypes.FileType?
        /// Determines the prefix that Amazon AppFlow applies to the destination folder name. You can name your destination folders according to the flow frequency and date.
        /// This member is required.
        public var prefixConfig: AppflowClientTypes.PrefixConfig?

        public init (
            aggregationConfig: AppflowClientTypes.AggregationConfig? = nil,
            fileType: AppflowClientTypes.FileType? = nil,
            prefixConfig: AppflowClientTypes.PrefixConfig? = nil
        )
        {
            self.aggregationConfig = aggregationConfig
            self.fileType = fileType
            self.prefixConfig = prefixConfig
        }
    }

}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request has invalid or missing parameters.
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AppflowClientTypes {
    public enum VeevaConnectorOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case addition
        case between
        case contains
        case division
        case equalTo
        case greaterThan
        case greaterThanOrEqualTo
        case lessThan
        case lessThanOrEqualTo
        case maskAll
        case maskFirstN
        case maskLastN
        case multiplication
        case notEqualTo
        case noOp
        case projection
        case subtraction
        case validateNonNegative
        case validateNonNull
        case validateNonZero
        case validateNumeric
        case sdkUnknown(Swift.String)

        public static var allCases: [VeevaConnectorOperator] {
            return [
                .addition,
                .between,
                .contains,
                .division,
                .equalTo,
                .greaterThan,
                .greaterThanOrEqualTo,
                .lessThan,
                .lessThanOrEqualTo,
                .maskAll,
                .maskFirstN,
                .maskLastN,
                .multiplication,
                .notEqualTo,
                .noOp,
                .projection,
                .subtraction,
                .validateNonNegative,
                .validateNonNull,
                .validateNonZero,
                .validateNumeric,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .addition: return "ADDITION"
            case .between: return "BETWEEN"
            case .contains: return "CONTAINS"
            case .division: return "DIVISION"
            case .equalTo: return "EQUAL_TO"
            case .greaterThan: return "GREATER_THAN"
            case .greaterThanOrEqualTo: return "GREATER_THAN_OR_EQUAL_TO"
            case .lessThan: return "LESS_THAN"
            case .lessThanOrEqualTo: return "LESS_THAN_OR_EQUAL_TO"
            case .maskAll: return "MASK_ALL"
            case .maskFirstN: return "MASK_FIRST_N"
            case .maskLastN: return "MASK_LAST_N"
            case .multiplication: return "MULTIPLICATION"
            case .notEqualTo: return "NOT_EQUAL_TO"
            case .noOp: return "NO_OP"
            case .projection: return "PROJECTION"
            case .subtraction: return "SUBTRACTION"
            case .validateNonNegative: return "VALIDATE_NON_NEGATIVE"
            case .validateNonNull: return "VALIDATE_NON_NULL"
            case .validateNonZero: return "VALIDATE_NON_ZERO"
            case .validateNumeric: return "VALIDATE_NUMERIC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = VeevaConnectorOperator(rawValue: rawValue) ?? VeevaConnectorOperator.sdkUnknown(rawValue)
        }
    }
}

extension AppflowClientTypes.VeevaConnectorProfileCredentials: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case password
        case username
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let password = password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let username = username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .username)
        username = usernameDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .password)
        password = passwordDecoded
    }
}

extension AppflowClientTypes {
    /// The connector-specific profile credentials required when using Veeva.
    public struct VeevaConnectorProfileCredentials: Swift.Equatable {
        /// The password that corresponds to the user name.
        /// This member is required.
        public var password: Swift.String?
        /// The name of the user.
        /// This member is required.
        public var username: Swift.String?

        public init (
            password: Swift.String? = nil,
            username: Swift.String? = nil
        )
        {
            self.password = password
            self.username = username
        }
    }

}

extension AppflowClientTypes.VeevaConnectorProfileProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceUrl
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceUrl = instanceUrl {
            try encodeContainer.encode(instanceUrl, forKey: .instanceUrl)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceUrl)
        instanceUrl = instanceUrlDecoded
    }
}

extension AppflowClientTypes {
    /// The connector-specific profile properties required when using Veeva.
    public struct VeevaConnectorProfileProperties: Swift.Equatable {
        /// The location of the Veeva resource.
        /// This member is required.
        public var instanceUrl: Swift.String?

        public init (
            instanceUrl: Swift.String? = nil
        )
        {
            self.instanceUrl = instanceUrl
        }
    }

}

extension AppflowClientTypes.VeevaMetadata: Swift.Codable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension AppflowClientTypes {
    /// The connector metadata specific to Veeva.
    public struct VeevaMetadata: Swift.Equatable {

    }

}

extension AppflowClientTypes.VeevaSourceProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case documentType
        case includeAllVersions
        case includeRenditions
        case includeSourceFiles
        case object
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let documentType = documentType {
            try encodeContainer.encode(documentType, forKey: .documentType)
        }
        if includeAllVersions != false {
            try encodeContainer.encode(includeAllVersions, forKey: .includeAllVersions)
        }
        if includeRenditions != false {
            try encodeContainer.encode(includeRenditions, forKey: .includeRenditions)
        }
        if includeSourceFiles != false {
            try encodeContainer.encode(includeSourceFiles, forKey: .includeSourceFiles)
        }
        if let object = object {
            try encodeContainer.encode(object, forKey: .object)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .object)
        object = objectDecoded
        let documentTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentType)
        documentType = documentTypeDecoded
        let includeSourceFilesDecoded = try containerValues.decode(Swift.Bool.self, forKey: .includeSourceFiles)
        includeSourceFiles = includeSourceFilesDecoded
        let includeRenditionsDecoded = try containerValues.decode(Swift.Bool.self, forKey: .includeRenditions)
        includeRenditions = includeRenditionsDecoded
        let includeAllVersionsDecoded = try containerValues.decode(Swift.Bool.self, forKey: .includeAllVersions)
        includeAllVersions = includeAllVersionsDecoded
    }
}

extension AppflowClientTypes {
    /// The properties that are applied when using Veeva as a flow source.
    public struct VeevaSourceProperties: Swift.Equatable {
        /// The document type specified in the Veeva document extract flow.
        public var documentType: Swift.String?
        /// Boolean value to include All Versions of files in Veeva document extract flow.
        public var includeAllVersions: Swift.Bool
        /// Boolean value to include file renditions in Veeva document extract flow.
        public var includeRenditions: Swift.Bool
        /// Boolean value to include source files in Veeva document extract flow.
        public var includeSourceFiles: Swift.Bool
        /// The object specified in the Veeva flow source.
        /// This member is required.
        public var object: Swift.String?

        public init (
            documentType: Swift.String? = nil,
            includeAllVersions: Swift.Bool = false,
            includeRenditions: Swift.Bool = false,
            includeSourceFiles: Swift.Bool = false,
            object: Swift.String? = nil
        )
        {
            self.documentType = documentType
            self.includeAllVersions = includeAllVersions
            self.includeRenditions = includeRenditions
            self.includeSourceFiles = includeSourceFiles
            self.object = object
        }
    }

}

extension AppflowClientTypes {
    /// The possible write operations in the destination connector. When this value is not provided, this defaults to the INSERT operation.
    public enum WriteOperationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case insert
        case update
        case upsert
        case sdkUnknown(Swift.String)

        public static var allCases: [WriteOperationType] {
            return [
                .insert,
                .update,
                .upsert,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .insert: return "INSERT"
            case .update: return "UPDATE"
            case .upsert: return "UPSERT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WriteOperationType(rawValue: rawValue) ?? WriteOperationType.sdkUnknown(rawValue)
        }
    }
}

extension AppflowClientTypes {
    public enum ZendeskConnectorOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case addition
        case division
        case greaterThan
        case maskAll
        case maskFirstN
        case maskLastN
        case multiplication
        case noOp
        case projection
        case subtraction
        case validateNonNegative
        case validateNonNull
        case validateNonZero
        case validateNumeric
        case sdkUnknown(Swift.String)

        public static var allCases: [ZendeskConnectorOperator] {
            return [
                .addition,
                .division,
                .greaterThan,
                .maskAll,
                .maskFirstN,
                .maskLastN,
                .multiplication,
                .noOp,
                .projection,
                .subtraction,
                .validateNonNegative,
                .validateNonNull,
                .validateNonZero,
                .validateNumeric,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .addition: return "ADDITION"
            case .division: return "DIVISION"
            case .greaterThan: return "GREATER_THAN"
            case .maskAll: return "MASK_ALL"
            case .maskFirstN: return "MASK_FIRST_N"
            case .maskLastN: return "MASK_LAST_N"
            case .multiplication: return "MULTIPLICATION"
            case .noOp: return "NO_OP"
            case .projection: return "PROJECTION"
            case .subtraction: return "SUBTRACTION"
            case .validateNonNegative: return "VALIDATE_NON_NEGATIVE"
            case .validateNonNull: return "VALIDATE_NON_NULL"
            case .validateNonZero: return "VALIDATE_NON_ZERO"
            case .validateNumeric: return "VALIDATE_NUMERIC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ZendeskConnectorOperator(rawValue: rawValue) ?? ZendeskConnectorOperator.sdkUnknown(rawValue)
        }
    }
}

extension AppflowClientTypes.ZendeskConnectorProfileCredentials: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessToken
        case clientId
        case clientSecret
        case oAuthRequest
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessToken = accessToken {
            try encodeContainer.encode(accessToken, forKey: .accessToken)
        }
        if let clientId = clientId {
            try encodeContainer.encode(clientId, forKey: .clientId)
        }
        if let clientSecret = clientSecret {
            try encodeContainer.encode(clientSecret, forKey: .clientSecret)
        }
        if let oAuthRequest = oAuthRequest {
            try encodeContainer.encode(oAuthRequest, forKey: .oAuthRequest)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientId)
        clientId = clientIdDecoded
        let clientSecretDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientSecret)
        clientSecret = clientSecretDecoded
        let accessTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessToken)
        accessToken = accessTokenDecoded
        let oAuthRequestDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ConnectorOAuthRequest.self, forKey: .oAuthRequest)
        oAuthRequest = oAuthRequestDecoded
    }
}

extension AppflowClientTypes {
    /// The connector-specific profile credentials required when using Zendesk.
    public struct ZendeskConnectorProfileCredentials: Swift.Equatable {
        /// The credentials used to access protected Zendesk resources.
        public var accessToken: Swift.String?
        /// The identifier for the desired client.
        /// This member is required.
        public var clientId: Swift.String?
        /// The client secret used by the OAuth client to authenticate to the authorization server.
        /// This member is required.
        public var clientSecret: Swift.String?
        /// The OAuth requirement needed to request security tokens from the connector endpoint.
        public var oAuthRequest: AppflowClientTypes.ConnectorOAuthRequest?

        public init (
            accessToken: Swift.String? = nil,
            clientId: Swift.String? = nil,
            clientSecret: Swift.String? = nil,
            oAuthRequest: AppflowClientTypes.ConnectorOAuthRequest? = nil
        )
        {
            self.accessToken = accessToken
            self.clientId = clientId
            self.clientSecret = clientSecret
            self.oAuthRequest = oAuthRequest
        }
    }

}

extension AppflowClientTypes.ZendeskConnectorProfileProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceUrl
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceUrl = instanceUrl {
            try encodeContainer.encode(instanceUrl, forKey: .instanceUrl)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceUrl)
        instanceUrl = instanceUrlDecoded
    }
}

extension AppflowClientTypes {
    /// The connector-specific profile properties required when using Zendesk.
    public struct ZendeskConnectorProfileProperties: Swift.Equatable {
        /// The location of the Zendesk resource.
        /// This member is required.
        public var instanceUrl: Swift.String?

        public init (
            instanceUrl: Swift.String? = nil
        )
        {
            self.instanceUrl = instanceUrl
        }
    }

}

extension AppflowClientTypes.ZendeskDestinationProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorHandlingConfig
        case idFieldNames
        case object
        case writeOperationType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorHandlingConfig = errorHandlingConfig {
            try encodeContainer.encode(errorHandlingConfig, forKey: .errorHandlingConfig)
        }
        if let idFieldNames = idFieldNames {
            var idFieldNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .idFieldNames)
            for idfieldnamelist0 in idFieldNames {
                try idFieldNamesContainer.encode(idfieldnamelist0)
            }
        }
        if let object = object {
            try encodeContainer.encode(object, forKey: .object)
        }
        if let writeOperationType = writeOperationType {
            try encodeContainer.encode(writeOperationType.rawValue, forKey: .writeOperationType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .object)
        object = objectDecoded
        let idFieldNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .idFieldNames)
        var idFieldNamesDecoded0:[Swift.String]? = nil
        if let idFieldNamesContainer = idFieldNamesContainer {
            idFieldNamesDecoded0 = [Swift.String]()
            for string0 in idFieldNamesContainer {
                if let string0 = string0 {
                    idFieldNamesDecoded0?.append(string0)
                }
            }
        }
        idFieldNames = idFieldNamesDecoded0
        let errorHandlingConfigDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ErrorHandlingConfig.self, forKey: .errorHandlingConfig)
        errorHandlingConfig = errorHandlingConfigDecoded
        let writeOperationTypeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.WriteOperationType.self, forKey: .writeOperationType)
        writeOperationType = writeOperationTypeDecoded
    }
}

extension AppflowClientTypes {
    /// The properties that are applied when Zendesk is used as a destination.
    public struct ZendeskDestinationProperties: Swift.Equatable {
        /// The settings that determine how Amazon AppFlow handles an error when placing data in the destination. For example, this setting would determine if the flow should fail after one insertion error, or continue and attempt to insert every record regardless of the initial failure. ErrorHandlingConfig is a part of the destination connector details.
        public var errorHandlingConfig: AppflowClientTypes.ErrorHandlingConfig?
        /// A list of field names that can be used as an ID field when performing a write operation.
        public var idFieldNames: [Swift.String]?
        /// The object specified in the Zendesk flow destination.
        /// This member is required.
        public var object: Swift.String?
        /// The possible write operations in the destination connector. When this value is not provided, this defaults to the INSERT operation.
        public var writeOperationType: AppflowClientTypes.WriteOperationType?

        public init (
            errorHandlingConfig: AppflowClientTypes.ErrorHandlingConfig? = nil,
            idFieldNames: [Swift.String]? = nil,
            object: Swift.String? = nil,
            writeOperationType: AppflowClientTypes.WriteOperationType? = nil
        )
        {
            self.errorHandlingConfig = errorHandlingConfig
            self.idFieldNames = idFieldNames
            self.object = object
            self.writeOperationType = writeOperationType
        }
    }

}

extension AppflowClientTypes.ZendeskMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case oAuthScopes
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let oAuthScopes = oAuthScopes {
            var oAuthScopesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .oAuthScopes)
            for oauthscopelist0 in oAuthScopes {
                try oAuthScopesContainer.encode(oauthscopelist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let oAuthScopesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .oAuthScopes)
        var oAuthScopesDecoded0:[Swift.String]? = nil
        if let oAuthScopesContainer = oAuthScopesContainer {
            oAuthScopesDecoded0 = [Swift.String]()
            for string0 in oAuthScopesContainer {
                if let string0 = string0 {
                    oAuthScopesDecoded0?.append(string0)
                }
            }
        }
        oAuthScopes = oAuthScopesDecoded0
    }
}

extension AppflowClientTypes {
    /// The connector metadata specific to Zendesk.
    public struct ZendeskMetadata: Swift.Equatable {
        /// The desired authorization scope for the Zendesk account.
        public var oAuthScopes: [Swift.String]?

        public init (
            oAuthScopes: [Swift.String]? = nil
        )
        {
            self.oAuthScopes = oAuthScopes
        }
    }

}

extension AppflowClientTypes.ZendeskSourceProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case object
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let object = object {
            try encodeContainer.encode(object, forKey: .object)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .object)
        object = objectDecoded
    }
}

extension AppflowClientTypes {
    /// The properties that are applied when using Zendesk as a flow source.
    public struct ZendeskSourceProperties: Swift.Equatable {
        /// The object specified in the Zendesk flow source.
        /// This member is required.
        public var object: Swift.String?

        public init (
            object: Swift.String? = nil
        )
        {
            self.object = object
        }
    }

}
