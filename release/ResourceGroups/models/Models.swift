// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension BadRequestException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BadRequestException(message: \(String(describing: message)))"}
}

extension BadRequestException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BadRequestExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request includes one or more parameters that violate validation rules.</p>
public struct BadRequestException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct BadRequestExceptionBody: Equatable {
    public let message: String?
}

extension BadRequestExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct CreateGroupInputBodyMiddleware: Middleware {
    public let id: String = "CreateGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateGroupInput>
    public typealias MOutput = OperationOutput<CreateGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateGroupOutputError>
}

extension CreateGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateGroupInput(configuration: \(String(describing: configuration)), description: \(String(describing: description)), name: \(String(describing: name)), resourceQuery: \(String(describing: resourceQuery)), tags: \(String(describing: tags)))"}
}

extension CreateGroupInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case configuration = "Configuration"
        case description = "Description"
        case name = "Name"
        case resourceQuery = "ResourceQuery"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configuration = configuration {
            var configurationContainer = encodeContainer.nestedUnkeyedContainer(forKey: .configuration)
            for groupconfigurationlist0 in configuration {
                try configurationContainer.encode(groupconfigurationlist0)
            }
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let resourceQuery = resourceQuery {
            try encodeContainer.encode(resourceQuery, forKey: .resourceQuery)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateGroupInputHeadersMiddleware: Middleware {
    public let id: String = "CreateGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateGroupInput>
    public typealias MOutput = OperationOutput<CreateGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateGroupOutputError>
}

public struct CreateGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateGroupInput>
    public typealias MOutput = OperationOutput<CreateGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateGroupOutputError>
}

public struct CreateGroupInput: Equatable {
    /// <p>A configuration associates the resource group with an AWS service and specifies how
    ///             the service can interact with the resources in the group. A configuration is an array of
    ///                 <a>GroupConfigurationItem</a> elements. For details about the syntax of
    ///             service configurations, see <a href="https://docs.aws.amazon.com/ARG/latest/APIReference/about-slg.html">Service configurations for resource
    ///                 groups</a>.</p>
    ///         <note>
    ///             <p>A resource group can contain either a <code>Configuration</code> or a
    ///                     <code>ResourceQuery</code>, but not both.</p>
    ///         </note>
    public let configuration: [GroupConfigurationItem]?
    /// <p>The description of the resource group. Descriptions can consist of letters, numbers,
    ///             hyphens, underscores, periods, and spaces.</p>
    public let description: String?
    /// <p>The name of the group, which is the identifier of the group in other operations. You
    ///             can't change the name of a resource group after you create it. A resource group name can
    ///             consist of letters, numbers, hyphens, periods, and underscores. The name cannot start
    ///             with <code>AWS</code> or <code>aws</code>; these are reserved. A resource group name
    ///             must be unique within each AWS Region in your AWS account.</p>
    public let name: String?
    /// <p>The resource query that determines which AWS resources are members of this group.
    ///             For more information about resource queries, see <a href="https://docs.aws.amazon.com/ARG/latest/userguide/gettingstarted-query.html#gettingstarted-query-cli-tag">Create
    ///                 a tag-based group in Resource Groups</a>. </p>
    ///         <note>
    ///             <p>A resource group can contain either a <code>ResourceQuery</code> or a
    ///                     <code>Configuration</code>, but not both.</p>
    ///         </note>
    public let resourceQuery: ResourceQuery?
    /// <p>The tags to add to the group. A tag is key-value pair string.</p>
    public let tags: [String:String]?

    public init (
        configuration: [GroupConfigurationItem]? = nil,
        description: String? = nil,
        name: String? = nil,
        resourceQuery: ResourceQuery? = nil,
        tags: [String:String]? = nil
    )
    {
        self.configuration = configuration
        self.description = description
        self.name = name
        self.resourceQuery = resourceQuery
        self.tags = tags
    }
}

struct CreateGroupInputBody: Equatable {
    public let name: String?
    public let description: String?
    public let resourceQuery: ResourceQuery?
    public let tags: [String:String]?
    public let configuration: [GroupConfigurationItem]?
}

extension CreateGroupInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case configuration = "Configuration"
        case description = "Description"
        case name = "Name"
        case resourceQuery = "ResourceQuery"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let resourceQueryDecoded = try containerValues.decodeIfPresent(ResourceQuery.self, forKey: .resourceQuery)
        resourceQuery = resourceQueryDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let configurationContainer = try containerValues.decodeIfPresent([GroupConfigurationItem?].self, forKey: .configuration)
        var configurationDecoded0:[GroupConfigurationItem]? = nil
        if let configurationContainer = configurationContainer {
            configurationDecoded0 = [GroupConfigurationItem]()
            for structure0 in configurationContainer {
                if let structure0 = structure0 {
                    configurationDecoded0?.append(structure0)
                }
            }
        }
        configuration = configurationDecoded0
    }
}

extension CreateGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateGroupOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case methodNotAllowedException(MethodNotAllowedException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateGroupOutputResponse(group: \(String(describing: group)), groupConfiguration: \(String(describing: groupConfiguration)), resourceQuery: \(String(describing: resourceQuery)), tags: \(String(describing: tags)))"}
}

extension CreateGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateGroupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.group = output.group
            self.groupConfiguration = output.groupConfiguration
            self.resourceQuery = output.resourceQuery
            self.tags = output.tags
        } else {
            self.group = nil
            self.groupConfiguration = nil
            self.resourceQuery = nil
            self.tags = nil
        }
    }
}

public struct CreateGroupOutputResponse: Equatable {
    /// <p>The description of the resource group.</p>
    public let group: Group?
    /// <p>The service configuration associated with the resource group. For details about the
    ///             syntax of a service configuration, see <a href="https://docs.aws.amazon.com/ARG/latest/APIReference/about-slg.html">Service configurations for resource
    ///                 groups</a>.</p>
    public let groupConfiguration: GroupConfiguration?
    /// <p>The resource query associated with the group. For more information about resource
    ///             queries, see <a href="https://docs.aws.amazon.com/ARG/latest/userguide/gettingstarted-query.html#gettingstarted-query-cli-tag">Create
    ///                 a tag-based group in Resource Groups</a>. </p>
    public let resourceQuery: ResourceQuery?
    /// <p>The tags associated with the group.</p>
    public let tags: [String:String]?

    public init (
        group: Group? = nil,
        groupConfiguration: GroupConfiguration? = nil,
        resourceQuery: ResourceQuery? = nil,
        tags: [String:String]? = nil
    )
    {
        self.group = group
        self.groupConfiguration = groupConfiguration
        self.resourceQuery = resourceQuery
        self.tags = tags
    }
}

struct CreateGroupOutputResponseBody: Equatable {
    public let group: Group?
    public let resourceQuery: ResourceQuery?
    public let tags: [String:String]?
    public let groupConfiguration: GroupConfiguration?
}

extension CreateGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case group = "Group"
        case groupConfiguration = "GroupConfiguration"
        case resourceQuery = "ResourceQuery"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupDecoded = try containerValues.decodeIfPresent(Group.self, forKey: .group)
        group = groupDecoded
        let resourceQueryDecoded = try containerValues.decodeIfPresent(ResourceQuery.self, forKey: .resourceQuery)
        resourceQuery = resourceQueryDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let groupConfigurationDecoded = try containerValues.decodeIfPresent(GroupConfiguration.self, forKey: .groupConfiguration)
        groupConfiguration = groupConfigurationDecoded
    }
}

public struct DeleteGroupInputBodyMiddleware: Middleware {
    public let id: String = "DeleteGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteGroupInput>
    public typealias MOutput = OperationOutput<DeleteGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteGroupOutputError>
}

extension DeleteGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteGroupInput(group: \(String(describing: group)), groupName: \(String(describing: groupName)))"}
}

extension DeleteGroupInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case group = "Group"
        case groupName = "GroupName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let group = group {
            try encodeContainer.encode(group, forKey: .group)
        }
        if let groupName = groupName {
            try encodeContainer.encode(groupName, forKey: .groupName)
        }
    }
}

public struct DeleteGroupInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteGroupInput>
    public typealias MOutput = OperationOutput<DeleteGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteGroupOutputError>
}

public struct DeleteGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteGroupInput>
    public typealias MOutput = OperationOutput<DeleteGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteGroupOutputError>
}

public struct DeleteGroupInput: Equatable {
    /// <p>The name or the ARN of the resource group to delete.</p>
    public let group: String?
    /// <p>Deprecated - don't use this parameter. Use <code>Group</code> instead.</p>
    @available(*, deprecated, message: "This field is deprecated, use Group instead.")
    public let groupName: String?

    public init (
        group: String? = nil,
        groupName: String? = nil
    )
    {
        self.group = group
        self.groupName = groupName
    }
}

struct DeleteGroupInputBody: Equatable {
    public let groupName: String?
    public let group: String?
}

extension DeleteGroupInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case group = "Group"
        case groupName = "GroupName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .groupName)
        groupName = groupNameDecoded
        let groupDecoded = try containerValues.decodeIfPresent(String.self, forKey: .group)
        group = groupDecoded
    }
}

extension DeleteGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteGroupOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case methodNotAllowedException(MethodNotAllowedException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteGroupOutputResponse(group: \(String(describing: group)))"}
}

extension DeleteGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteGroupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.group = output.group
        } else {
            self.group = nil
        }
    }
}

public struct DeleteGroupOutputResponse: Equatable {
    /// <p>A full description of the deleted resource group.</p>
    public let group: Group?

    public init (
        group: Group? = nil
    )
    {
        self.group = group
    }
}

struct DeleteGroupOutputResponseBody: Equatable {
    public let group: Group?
}

extension DeleteGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case group = "Group"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupDecoded = try containerValues.decodeIfPresent(Group.self, forKey: .group)
        group = groupDecoded
    }
}

extension FailedResource: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
    }
}

extension FailedResource: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FailedResource(errorCode: \(String(describing: errorCode)), errorMessage: \(String(describing: errorMessage)), resourceArn: \(String(describing: resourceArn)))"}
}

/// <p>A resource that failed to be added to or removed from a group.</p>
public struct FailedResource: Equatable {
    /// <p>The error code associated with the failure.</p>
    public let errorCode: String?
    /// <p>The error message text associated with the failure.</p>
    public let errorMessage: String?
    /// <p>The ARN of the resource that failed to be added or removed.</p>
    public let resourceArn: String?

    public init (
        errorCode: String? = nil,
        errorMessage: String? = nil,
        resourceArn: String? = nil
    )
    {
        self.errorCode = errorCode
        self.errorMessage = errorMessage
        self.resourceArn = resourceArn
    }
}

extension ForbiddenException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ForbiddenException(message: \(String(describing: message)))"}
}

extension ForbiddenException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ForbiddenExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The caller isn't authorized to make the request. Check permissions.</p>
public struct ForbiddenException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ForbiddenExceptionBody: Equatable {
    public let message: String?
}

extension ForbiddenExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct GetGroupConfigurationInputBodyMiddleware: Middleware {
    public let id: String = "GetGroupConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetGroupConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetGroupConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetGroupConfigurationInput>
    public typealias MOutput = OperationOutput<GetGroupConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetGroupConfigurationOutputError>
}

extension GetGroupConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetGroupConfigurationInput(group: \(String(describing: group)))"}
}

extension GetGroupConfigurationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case group = "Group"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let group = group {
            try encodeContainer.encode(group, forKey: .group)
        }
    }
}

public struct GetGroupConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "GetGroupConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetGroupConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetGroupConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetGroupConfigurationInput>
    public typealias MOutput = OperationOutput<GetGroupConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetGroupConfigurationOutputError>
}

public struct GetGroupConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "GetGroupConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetGroupConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetGroupConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetGroupConfigurationInput>
    public typealias MOutput = OperationOutput<GetGroupConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetGroupConfigurationOutputError>
}

public struct GetGroupConfigurationInput: Equatable {
    /// <p>The name or the ARN of the resource group.</p>
    public let group: String?

    public init (
        group: String? = nil
    )
    {
        self.group = group
    }
}

struct GetGroupConfigurationInputBody: Equatable {
    public let group: String?
}

extension GetGroupConfigurationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case group = "Group"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupDecoded = try containerValues.decodeIfPresent(String.self, forKey: .group)
        group = groupDecoded
    }
}

extension GetGroupConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetGroupConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetGroupConfigurationOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case methodNotAllowedException(MethodNotAllowedException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetGroupConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetGroupConfigurationOutputResponse(groupConfiguration: \(String(describing: groupConfiguration)))"}
}

extension GetGroupConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetGroupConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.groupConfiguration = output.groupConfiguration
        } else {
            self.groupConfiguration = nil
        }
    }
}

public struct GetGroupConfigurationOutputResponse: Equatable {
    /// <p>The service configuration associated with the specified group. For details about the
    ///             service configuration syntax, see <a href="https://docs.aws.amazon.com/ARG/latest/APIReference/about-slg.html">Service configurations for resource
    ///                 groups</a>.</p>
    public let groupConfiguration: GroupConfiguration?

    public init (
        groupConfiguration: GroupConfiguration? = nil
    )
    {
        self.groupConfiguration = groupConfiguration
    }
}

struct GetGroupConfigurationOutputResponseBody: Equatable {
    public let groupConfiguration: GroupConfiguration?
}

extension GetGroupConfigurationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case groupConfiguration = "GroupConfiguration"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupConfigurationDecoded = try containerValues.decodeIfPresent(GroupConfiguration.self, forKey: .groupConfiguration)
        groupConfiguration = groupConfigurationDecoded
    }
}

public struct GetGroupInputBodyMiddleware: Middleware {
    public let id: String = "GetGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<GetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetGroupInput>
    public typealias MOutput = OperationOutput<GetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetGroupOutputError>
}

extension GetGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetGroupInput(group: \(String(describing: group)), groupName: \(String(describing: groupName)))"}
}

extension GetGroupInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case group = "Group"
        case groupName = "GroupName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let group = group {
            try encodeContainer.encode(group, forKey: .group)
        }
        if let groupName = groupName {
            try encodeContainer.encode(groupName, forKey: .groupName)
        }
    }
}

public struct GetGroupInputHeadersMiddleware: Middleware {
    public let id: String = "GetGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<GetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetGroupInput>
    public typealias MOutput = OperationOutput<GetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetGroupOutputError>
}

public struct GetGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "GetGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<GetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetGroupInput>
    public typealias MOutput = OperationOutput<GetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetGroupOutputError>
}

public struct GetGroupInput: Equatable {
    /// <p>The name or the ARN of the resource group to retrieve.</p>
    public let group: String?
    /// <p>Deprecated - don't use this parameter. Use <code>Group</code> instead.</p>
    @available(*, deprecated, message: "This field is deprecated, use Group instead.")
    public let groupName: String?

    public init (
        group: String? = nil,
        groupName: String? = nil
    )
    {
        self.group = group
        self.groupName = groupName
    }
}

struct GetGroupInputBody: Equatable {
    public let groupName: String?
    public let group: String?
}

extension GetGroupInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case group = "Group"
        case groupName = "GroupName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .groupName)
        groupName = groupNameDecoded
        let groupDecoded = try containerValues.decodeIfPresent(String.self, forKey: .group)
        group = groupDecoded
    }
}

extension GetGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetGroupOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case methodNotAllowedException(MethodNotAllowedException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetGroupOutputResponse(group: \(String(describing: group)))"}
}

extension GetGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetGroupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.group = output.group
        } else {
            self.group = nil
        }
    }
}

public struct GetGroupOutputResponse: Equatable {
    /// <p>A full description of the resource group.</p>
    public let group: Group?

    public init (
        group: Group? = nil
    )
    {
        self.group = group
    }
}

struct GetGroupOutputResponseBody: Equatable {
    public let group: Group?
}

extension GetGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case group = "Group"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupDecoded = try containerValues.decodeIfPresent(Group.self, forKey: .group)
        group = groupDecoded
    }
}

public struct GetGroupQueryInputBodyMiddleware: Middleware {
    public let id: String = "GetGroupQueryInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetGroupQueryInput>,
                  next: H) -> Swift.Result<OperationOutput<GetGroupQueryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetGroupQueryInput>
    public typealias MOutput = OperationOutput<GetGroupQueryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetGroupQueryOutputError>
}

extension GetGroupQueryInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetGroupQueryInput(group: \(String(describing: group)), groupName: \(String(describing: groupName)))"}
}

extension GetGroupQueryInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case group = "Group"
        case groupName = "GroupName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let group = group {
            try encodeContainer.encode(group, forKey: .group)
        }
        if let groupName = groupName {
            try encodeContainer.encode(groupName, forKey: .groupName)
        }
    }
}

public struct GetGroupQueryInputHeadersMiddleware: Middleware {
    public let id: String = "GetGroupQueryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetGroupQueryInput>,
                  next: H) -> Swift.Result<OperationOutput<GetGroupQueryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetGroupQueryInput>
    public typealias MOutput = OperationOutput<GetGroupQueryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetGroupQueryOutputError>
}

public struct GetGroupQueryInputQueryItemMiddleware: Middleware {
    public let id: String = "GetGroupQueryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetGroupQueryInput>,
                  next: H) -> Swift.Result<OperationOutput<GetGroupQueryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetGroupQueryInput>
    public typealias MOutput = OperationOutput<GetGroupQueryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetGroupQueryOutputError>
}

public struct GetGroupQueryInput: Equatable {
    /// <p>The name or the ARN of the resource group to query.</p>
    public let group: String?
    /// <p>Don't use this parameter. Use <code>Group</code> instead.</p>
    @available(*, deprecated, message: "This field is deprecated, use Group instead.")
    public let groupName: String?

    public init (
        group: String? = nil,
        groupName: String? = nil
    )
    {
        self.group = group
        self.groupName = groupName
    }
}

struct GetGroupQueryInputBody: Equatable {
    public let groupName: String?
    public let group: String?
}

extension GetGroupQueryInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case group = "Group"
        case groupName = "GroupName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .groupName)
        groupName = groupNameDecoded
        let groupDecoded = try containerValues.decodeIfPresent(String.self, forKey: .group)
        group = groupDecoded
    }
}

extension GetGroupQueryOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetGroupQueryOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetGroupQueryOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case methodNotAllowedException(MethodNotAllowedException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetGroupQueryOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetGroupQueryOutputResponse(groupQuery: \(String(describing: groupQuery)))"}
}

extension GetGroupQueryOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetGroupQueryOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.groupQuery = output.groupQuery
        } else {
            self.groupQuery = nil
        }
    }
}

public struct GetGroupQueryOutputResponse: Equatable {
    /// <p>The resource query associated with the specified group. For more information about
    ///             resource queries, see <a href="https://docs.aws.amazon.com/ARG/latest/userguide/gettingstarted-query.html#gettingstarted-query-cli-tag">Create
    ///                 a tag-based group in Resource Groups</a>.</p>
    public let groupQuery: GroupQuery?

    public init (
        groupQuery: GroupQuery? = nil
    )
    {
        self.groupQuery = groupQuery
    }
}

struct GetGroupQueryOutputResponseBody: Equatable {
    public let groupQuery: GroupQuery?
}

extension GetGroupQueryOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case groupQuery = "GroupQuery"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupQueryDecoded = try containerValues.decodeIfPresent(GroupQuery.self, forKey: .groupQuery)
        groupQuery = groupQueryDecoded
    }
}

extension GetTagsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetTagsInput(arn: \(String(describing: arn)))"}
}

extension GetTagsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetTagsInputHeadersMiddleware: Middleware {
    public let id: String = "GetTagsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetTagsInput>
    public typealias MOutput = OperationOutput<GetTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetTagsOutputError>
}

public struct GetTagsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetTagsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetTagsInput>
    public typealias MOutput = OperationOutput<GetTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetTagsOutputError>
}

public struct GetTagsInput: Equatable {
    /// <p>The ARN of the resource group whose tags you want to retrieve.</p>
    public let arn: String?

    public init (
        arn: String? = nil
    )
    {
        self.arn = arn
    }
}

struct GetTagsInputBody: Equatable {
}

extension GetTagsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetTagsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetTagsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetTagsOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case methodNotAllowedException(MethodNotAllowedException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetTagsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetTagsOutputResponse(arn: \(String(describing: arn)), tags: \(String(describing: tags)))"}
}

extension GetTagsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetTagsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.tags = output.tags
        } else {
            self.arn = nil
            self.tags = nil
        }
    }
}

public struct GetTagsOutputResponse: Equatable {
    /// <p>The ARN of the tagged resource group.</p>
    public let arn: String?
    /// <p>The tags associated with the specified resource group.</p>
    public let tags: [String:String]?

    public init (
        arn: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.arn = arn
        self.tags = tags
    }
}

struct GetTagsOutputResponseBody: Equatable {
    public let arn: String?
    public let tags: [String:String]?
}

extension GetTagsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension Group: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case groupArn = "GroupArn"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let groupArn = groupArn {
            try encodeContainer.encode(groupArn, forKey: .groupArn)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .groupArn)
        groupArn = groupArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension Group: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Group(description: \(String(describing: description)), groupArn: \(String(describing: groupArn)), name: \(String(describing: name)))"}
}

/// <p>A resource group that contains AWS resources. You can assign resources to the group
///             by associating either of the following elements with the group:</p>
///         <ul>
///             <li>
///                 <p>
///                   <a>ResourceQuery</a> - Use a resource query to specify a set of tag
///                     keys and values. All resources in the same AWS Region and AWS account that
///                     have those keys with the same values are included in the group. You can add a
///                     resource query when you create the group, or later by using the <a>PutGroupConfiguration</a> operation.</p>
///             </li>
///             <li>
///                 <p>
///                   <a>GroupConfiguration</a> - Use a service configuration to
///                     associate the group with an AWS service. The configuration specifies which
///                     resource types can be included in the group.</p>
///             </li>
///          </ul>
public struct Group: Equatable {
    /// <p>The description of the resource group.</p>
    public let description: String?
    /// <p>The ARN of the resource group.</p>
    public let groupArn: String?
    /// <p>The name of the resource group.</p>
    public let name: String?

    public init (
        description: String? = nil,
        groupArn: String? = nil,
        name: String? = nil
    )
    {
        self.description = description
        self.groupArn = groupArn
        self.name = name
    }
}

extension GroupConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case configuration = "Configuration"
        case failureReason = "FailureReason"
        case proposedConfiguration = "ProposedConfiguration"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configuration = configuration {
            var configurationContainer = encodeContainer.nestedUnkeyedContainer(forKey: .configuration)
            for groupconfigurationlist0 in configuration {
                try configurationContainer.encode(groupconfigurationlist0)
            }
        }
        if let failureReason = failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let proposedConfiguration = proposedConfiguration {
            var proposedConfigurationContainer = encodeContainer.nestedUnkeyedContainer(forKey: .proposedConfiguration)
            for groupconfigurationlist0 in proposedConfiguration {
                try proposedConfigurationContainer.encode(groupconfigurationlist0)
            }
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationContainer = try containerValues.decodeIfPresent([GroupConfigurationItem?].self, forKey: .configuration)
        var configurationDecoded0:[GroupConfigurationItem]? = nil
        if let configurationContainer = configurationContainer {
            configurationDecoded0 = [GroupConfigurationItem]()
            for structure0 in configurationContainer {
                if let structure0 = structure0 {
                    configurationDecoded0?.append(structure0)
                }
            }
        }
        configuration = configurationDecoded0
        let proposedConfigurationContainer = try containerValues.decodeIfPresent([GroupConfigurationItem?].self, forKey: .proposedConfiguration)
        var proposedConfigurationDecoded0:[GroupConfigurationItem]? = nil
        if let proposedConfigurationContainer = proposedConfigurationContainer {
            proposedConfigurationDecoded0 = [GroupConfigurationItem]()
            for structure0 in proposedConfigurationContainer {
                if let structure0 = structure0 {
                    proposedConfigurationDecoded0?.append(structure0)
                }
            }
        }
        proposedConfiguration = proposedConfigurationDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(GroupConfigurationStatus.self, forKey: .status)
        status = statusDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
    }
}

extension GroupConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GroupConfiguration(configuration: \(String(describing: configuration)), failureReason: \(String(describing: failureReason)), proposedConfiguration: \(String(describing: proposedConfiguration)), status: \(String(describing: status)))"}
}

/// <p>A service configuration associated with a resource group. The configuration options
///             are determined by the AWS service that defines the <code>Type</code>, and specifies
///             which resources can be included in the group. You can add a service configuration when
///             you create the group by using <a>CreateGroup</a>, or later by using the <a>PutGroupConfiguration</a> operation. For details about group service
///             configuration syntax, see <a href="https://docs.aws.amazon.com/ARG/latest/APIReference/about-slg.html">Service configurations for resource
///                 groups</a>.</p>
public struct GroupConfiguration: Equatable {
    /// <p>The configuration currently associated with the group and in effect.</p>
    public let configuration: [GroupConfigurationItem]?
    /// <p>If present, the reason why a request to update the group configuration failed.</p>
    public let failureReason: String?
    /// <p>If present, the new configuration that is in the process of being applied to the
    ///             group.</p>
    public let proposedConfiguration: [GroupConfigurationItem]?
    /// <p>The current status of an attempt to update the group configuration.</p>
    public let status: GroupConfigurationStatus?

    public init (
        configuration: [GroupConfigurationItem]? = nil,
        failureReason: String? = nil,
        proposedConfiguration: [GroupConfigurationItem]? = nil,
        status: GroupConfigurationStatus? = nil
    )
    {
        self.configuration = configuration
        self.failureReason = failureReason
        self.proposedConfiguration = proposedConfiguration
        self.status = status
    }
}

extension GroupConfigurationItem: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case parameters = "Parameters"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .parameters)
            for groupparameterlist0 in parameters {
                try parametersContainer.encode(groupparameterlist0)
            }
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
        let parametersContainer = try containerValues.decodeIfPresent([GroupConfigurationParameter?].self, forKey: .parameters)
        var parametersDecoded0:[GroupConfigurationParameter]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [GroupConfigurationParameter]()
            for structure0 in parametersContainer {
                if let structure0 = structure0 {
                    parametersDecoded0?.append(structure0)
                }
            }
        }
        parameters = parametersDecoded0
    }
}

extension GroupConfigurationItem: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GroupConfigurationItem(parameters: \(String(describing: parameters)), type: \(String(describing: type)))"}
}

/// <p>An item in a group configuration. A group service configuration can have one or more
///             items. For details about group service configuration syntax, see <a href="https://docs.aws.amazon.com/ARG/latest/APIReference/about-slg.html">Service configurations for
///                 resource groups</a>.</p>
public struct GroupConfigurationItem: Equatable {
    /// <p>A collection of parameters for this group configuration item. For the list of
    ///             parameters that you can use with each configuration item type, see <a href="https://docs.aws.amazon.com/ARG/latest/APIReference/about-slg.html#about-slg-types">Supported
    ///                 resource types and parameters</a>.</p>
    public let parameters: [GroupConfigurationParameter]?
    /// <p>Specifies the type of group configuration item. Each item must have a unique value for
    ///                 <code>type</code>. For the list of types that you can specify for a configuration
    ///             item, see <a href="https://docs.aws.amazon.com/ARG/latest/APIReference/about-slg.html#about-slg-types">Supported resource types and
    ///                 parameters</a>.</p>
    public let type: String?

    public init (
        parameters: [GroupConfigurationParameter]? = nil,
        type: String? = nil
    )
    {
        self.parameters = parameters
        self.type = type
    }
}

extension GroupConfigurationParameter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case values = "Values"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for groupconfigurationparametervaluelist0 in values {
                try valuesContainer.encode(groupconfigurationparametervaluelist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .values)
        var valuesDecoded0:[String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension GroupConfigurationParameter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GroupConfigurationParameter(name: \(String(describing: name)), values: \(String(describing: values)))"}
}

/// <p>A parameter for a group configuration item. For details about group service
///             configuration syntax, see <a href="https://docs.aws.amazon.com/ARG/latest/APIReference/about-slg.html">Service configurations for resource
///                 groups</a>.</p>
public struct GroupConfigurationParameter: Equatable {
    /// <p>The name of the group configuration parameter. For the list of parameters that you can
    ///             use with each configuration item type, see <a href="https://docs.aws.amazon.com/ARG/latest/APIReference/about-slg.html#about-slg-types">Supported resource types and
    ///                 parameters</a>.</p>
    public let name: String?
    /// <p>The value or values to be used for the specified parameter. For the list of values you
    ///             can use with each parameter, see <a href="https://docs.aws.amazon.com/ARG/latest/APIReference/about-slg.html#about-slg-types">Supported resource types and
    ///                 parameters</a>.</p>
    public let values: [String]?

    public init (
        name: String? = nil,
        values: [String]? = nil
    )
    {
        self.name = name
        self.values = values
    }
}

public enum GroupConfigurationStatus {
    case updateComplete
    case updateFailed
    case updating
    case sdkUnknown(String)
}

extension GroupConfigurationStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [GroupConfigurationStatus] {
        return [
            .updateComplete,
            .updateFailed,
            .updating,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .updateComplete: return "UPDATE_COMPLETE"
        case .updateFailed: return "UPDATE_FAILED"
        case .updating: return "UPDATING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = GroupConfigurationStatus(rawValue: rawValue) ?? GroupConfigurationStatus.sdkUnknown(rawValue)
    }
}

extension GroupFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case values = "Values"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for groupfiltervalues0 in values {
                try valuesContainer.encode(groupfiltervalues0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(GroupFilterName.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .values)
        var valuesDecoded0:[String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension GroupFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GroupFilter(name: \(String(describing: name)), values: \(String(describing: values)))"}
}

/// <p>A filter collection that you can use to restrict the results from a <code>List</code>
///             operation to only those you want to include.</p>
public struct GroupFilter: Equatable {
    /// <p>The name of the filter. Filter names are case-sensitive.</p>
    public let name: GroupFilterName?
    /// <p>One or more filter values. Allowed filter values vary by group filter name, and are
    ///             case-sensitive.</p>
    public let values: [String]?

    public init (
        name: GroupFilterName? = nil,
        values: [String]? = nil
    )
    {
        self.name = name
        self.values = values
    }
}

public enum GroupFilterName {
    case configurationtype
    case resourcetype
    case sdkUnknown(String)
}

extension GroupFilterName : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [GroupFilterName] {
        return [
            .configurationtype,
            .resourcetype,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .configurationtype: return "configuration-type"
        case .resourcetype: return "resource-type"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = GroupFilterName(rawValue: rawValue) ?? GroupFilterName.sdkUnknown(rawValue)
    }
}

extension GroupIdentifier: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case groupArn = "GroupArn"
        case groupName = "GroupName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupArn = groupArn {
            try encodeContainer.encode(groupArn, forKey: .groupArn)
        }
        if let groupName = groupName {
            try encodeContainer.encode(groupName, forKey: .groupName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .groupName)
        groupName = groupNameDecoded
        let groupArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .groupArn)
        groupArn = groupArnDecoded
    }
}

extension GroupIdentifier: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GroupIdentifier(groupArn: \(String(describing: groupArn)), groupName: \(String(describing: groupName)))"}
}

/// <p>The unique identifiers for a resource group.</p>
public struct GroupIdentifier: Equatable {
    /// <p>The ARN of the resource group.</p>
    public let groupArn: String?
    /// <p>The name of the resource group.</p>
    public let groupName: String?

    public init (
        groupArn: String? = nil,
        groupName: String? = nil
    )
    {
        self.groupArn = groupArn
        self.groupName = groupName
    }
}

extension GroupQuery: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case groupName = "GroupName"
        case resourceQuery = "ResourceQuery"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupName = groupName {
            try encodeContainer.encode(groupName, forKey: .groupName)
        }
        if let resourceQuery = resourceQuery {
            try encodeContainer.encode(resourceQuery, forKey: .resourceQuery)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .groupName)
        groupName = groupNameDecoded
        let resourceQueryDecoded = try containerValues.decodeIfPresent(ResourceQuery.self, forKey: .resourceQuery)
        resourceQuery = resourceQueryDecoded
    }
}

extension GroupQuery: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GroupQuery(groupName: \(String(describing: groupName)), resourceQuery: \(String(describing: resourceQuery)))"}
}

/// <p>A mapping of a query attached to a resource group that determines the AWS resources
///             that are members of the group.</p>
public struct GroupQuery: Equatable {
    /// <p>The name of the resource group that is associated with the specified resource
    ///             query.</p>
    public let groupName: String?
    /// <p>The resource query that determines which AWS resources are members of the associated
    ///             resource group.</p>
    public let resourceQuery: ResourceQuery?

    public init (
        groupName: String? = nil,
        resourceQuery: ResourceQuery? = nil
    )
    {
        self.groupName = groupName
        self.resourceQuery = resourceQuery
    }
}

public struct GroupResourcesInputBodyMiddleware: Middleware {
    public let id: String = "GroupResourcesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GroupResourcesInput>,
                  next: H) -> Swift.Result<OperationOutput<GroupResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GroupResourcesInput>
    public typealias MOutput = OperationOutput<GroupResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GroupResourcesOutputError>
}

extension GroupResourcesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GroupResourcesInput(group: \(String(describing: group)), resourceArns: \(String(describing: resourceArns)))"}
}

extension GroupResourcesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case group = "Group"
        case resourceArns = "ResourceArns"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let group = group {
            try encodeContainer.encode(group, forKey: .group)
        }
        if let resourceArns = resourceArns {
            var resourceArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceArns)
            for resourcearnlist0 in resourceArns {
                try resourceArnsContainer.encode(resourcearnlist0)
            }
        }
    }
}

public struct GroupResourcesInputHeadersMiddleware: Middleware {
    public let id: String = "GroupResourcesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GroupResourcesInput>,
                  next: H) -> Swift.Result<OperationOutput<GroupResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GroupResourcesInput>
    public typealias MOutput = OperationOutput<GroupResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GroupResourcesOutputError>
}

public struct GroupResourcesInputQueryItemMiddleware: Middleware {
    public let id: String = "GroupResourcesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GroupResourcesInput>,
                  next: H) -> Swift.Result<OperationOutput<GroupResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GroupResourcesInput>
    public typealias MOutput = OperationOutput<GroupResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GroupResourcesOutputError>
}

public struct GroupResourcesInput: Equatable {
    /// <p>The name or the ARN of the resource group to add resources to.</p>
    public let group: String?
    /// <p>The list of ARNs for resources to be added to the group. </p>
    public let resourceArns: [String]?

    public init (
        group: String? = nil,
        resourceArns: [String]? = nil
    )
    {
        self.group = group
        self.resourceArns = resourceArns
    }
}

struct GroupResourcesInputBody: Equatable {
    public let group: String?
    public let resourceArns: [String]?
}

extension GroupResourcesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case group = "Group"
        case resourceArns = "ResourceArns"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupDecoded = try containerValues.decodeIfPresent(String.self, forKey: .group)
        group = groupDecoded
        let resourceArnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .resourceArns)
        var resourceArnsDecoded0:[String]? = nil
        if let resourceArnsContainer = resourceArnsContainer {
            resourceArnsDecoded0 = [String]()
            for string0 in resourceArnsContainer {
                if let string0 = string0 {
                    resourceArnsDecoded0?.append(string0)
                }
            }
        }
        resourceArns = resourceArnsDecoded0
    }
}

extension GroupResourcesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GroupResourcesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GroupResourcesOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case methodNotAllowedException(MethodNotAllowedException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GroupResourcesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GroupResourcesOutputResponse(failed: \(String(describing: failed)), pending: \(String(describing: pending)), succeeded: \(String(describing: succeeded)))"}
}

extension GroupResourcesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GroupResourcesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.failed = output.failed
            self.pending = output.pending
            self.succeeded = output.succeeded
        } else {
            self.failed = nil
            self.pending = nil
            self.succeeded = nil
        }
    }
}

public struct GroupResourcesOutputResponse: Equatable {
    /// <p>A list of ARNs of any resources that failed to be added to the group by this
    ///             operation.</p>
    public let failed: [FailedResource]?
    /// <p>A list of ARNs of any resources that are still in the process of being added to the
    ///             group by this operation. These pending additions continue asynchronously. You can check
    ///             the status of pending additions by using the <code>
    ///                <a>ListGroupResources</a>
    ///             </code> operation, and checking the <code>Resources</code> array in the response
    ///             and the <code>Status</code> field of each object in that array. </p>
    public let pending: [PendingResource]?
    /// <p>A list of ARNs of resources that were successfully added to the group by this
    ///             operation.</p>
    public let succeeded: [String]?

    public init (
        failed: [FailedResource]? = nil,
        pending: [PendingResource]? = nil,
        succeeded: [String]? = nil
    )
    {
        self.failed = failed
        self.pending = pending
        self.succeeded = succeeded
    }
}

struct GroupResourcesOutputResponseBody: Equatable {
    public let succeeded: [String]?
    public let failed: [FailedResource]?
    public let pending: [PendingResource]?
}

extension GroupResourcesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case failed = "Failed"
        case pending = "Pending"
        case succeeded = "Succeeded"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let succeededContainer = try containerValues.decodeIfPresent([String?].self, forKey: .succeeded)
        var succeededDecoded0:[String]? = nil
        if let succeededContainer = succeededContainer {
            succeededDecoded0 = [String]()
            for string0 in succeededContainer {
                if let string0 = string0 {
                    succeededDecoded0?.append(string0)
                }
            }
        }
        succeeded = succeededDecoded0
        let failedContainer = try containerValues.decodeIfPresent([FailedResource?].self, forKey: .failed)
        var failedDecoded0:[FailedResource]? = nil
        if let failedContainer = failedContainer {
            failedDecoded0 = [FailedResource]()
            for structure0 in failedContainer {
                if let structure0 = structure0 {
                    failedDecoded0?.append(structure0)
                }
            }
        }
        failed = failedDecoded0
        let pendingContainer = try containerValues.decodeIfPresent([PendingResource?].self, forKey: .pending)
        var pendingDecoded0:[PendingResource]? = nil
        if let pendingContainer = pendingContainer {
            pendingDecoded0 = [PendingResource]()
            for structure0 in pendingContainer {
                if let structure0 = structure0 {
                    pendingDecoded0?.append(structure0)
                }
            }
        }
        pending = pendingDecoded0
    }
}

extension InternalServerErrorException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalServerErrorException(message: \(String(describing: message)))"}
}

extension InternalServerErrorException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InternalServerErrorExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An internal error occurred while processing the request. Try again later.</p>
public struct InternalServerErrorException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerErrorExceptionBody: Equatable {
    public let message: String?
}

extension InternalServerErrorExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ListGroupResourcesInputBodyMiddleware: Middleware {
    public let id: String = "ListGroupResourcesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListGroupResourcesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListGroupResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListGroupResourcesInput>
    public typealias MOutput = OperationOutput<ListGroupResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListGroupResourcesOutputError>
}

extension ListGroupResourcesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListGroupResourcesInput(filters: \(String(describing: filters)), group: \(String(describing: group)), groupName: \(String(describing: groupName)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListGroupResourcesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case group = "Group"
        case groupName = "GroupName"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for resourcefilterlist0 in filters {
                try filtersContainer.encode(resourcefilterlist0)
            }
        }
        if let group = group {
            try encodeContainer.encode(group, forKey: .group)
        }
        if let groupName = groupName {
            try encodeContainer.encode(groupName, forKey: .groupName)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListGroupResourcesInputHeadersMiddleware: Middleware {
    public let id: String = "ListGroupResourcesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListGroupResourcesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListGroupResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListGroupResourcesInput>
    public typealias MOutput = OperationOutput<ListGroupResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListGroupResourcesOutputError>
}

public struct ListGroupResourcesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListGroupResourcesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListGroupResourcesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListGroupResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListGroupResourcesInput>
    public typealias MOutput = OperationOutput<ListGroupResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListGroupResourcesOutputError>
}

public struct ListGroupResourcesInput: Equatable {
    /// <p>Filters, formatted as <a>ResourceFilter</a> objects, that you want to apply
    ///             to a <code>ListGroupResources</code> operation. Filters the results to include only
    ///             those of the specified resource types.</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <code>resource-type</code> - Filter resources by their type. Specify up to
    ///                     five resource types in the format <code>AWS::ServiceCode::ResourceType</code>.
    ///                     For example, <code>AWS::EC2::Instance</code>, or <code>AWS::S3::Bucket</code>.
    ///                 </p>
    ///             </li>
    ///          </ul>
    ///         <p>When you specify a <code>resource-type</code> filter for
    ///                 <code>ListGroupResources</code>, AWS Resource Groups validates your filter resource types
    ///             against the types that are defined in the query associated with the group. For example,
    ///             if a group contains only S3 buckets because its query specifies only that resource type,
    ///             but your <code>resource-type</code> filter includes EC2 instances, AWS Resource Groups
    ///             does not filter for EC2 instances. In this case, a <code>ListGroupResources</code>
    ///             request returns a <code>BadRequestException</code> error with a message similar to the
    ///             following:</p>
    ///         <p>
    ///             <code>The resource types specified as filters in the request are not
    ///             valid.</code>
    ///          </p>
    ///         <p>The error includes a list of resource types that failed the validation because they
    ///             are not part of the query associated with the group. This validation doesn't occur when
    ///             the group query specifies <code>AWS::AllSupported</code>, because a group based on such
    ///             a query can contain any of the allowed resource types for the query type (tag-based or
    ///             AWS CloudFormation stack-based queries).</p>
    public let filters: [ResourceFilter]?
    /// <p>The name or the ARN of the resource group</p>
    public let group: String?
    /// <important>
    ///             <p>
    ///                <i>
    ///                   <b>Deprecated - don't use this parameter. Use the
    ///                             <code>Group</code> request field instead.</b>
    ///                </i>
    ///             </p>
    ///         </important>
    @available(*, deprecated, message: "This field is deprecated, use Group instead.")
    public let groupName: String?
    /// <p>The total number of results that you want included on each page of the
    /// response. If you do not include this parameter, it defaults to a value that is specific to the
    /// operation. If additional items exist beyond the maximum you specify, the <code>NextToken</code>
    /// response element is present and has a value (is not null). Include that value as the
    /// <code>NextToken</code> request parameter in the next call to the operation to get the next part
    /// of the results. Note that the service might return fewer results than the maximum even when there
    /// are more results available. You should check <code>NextToken</code> after every operation to
    /// ensure that you receive all of the results.</p>
    public let maxResults: Int?
    /// <p>The parameter for receiving additional results if you receive a
    /// <code>NextToken</code> response in a previous request. A <code>NextToken</code> response
    /// indicates that more output is available. Set this parameter to the value provided by a previous
    /// call's <code>NextToken</code> response to indicate where the output should continue from.</p>
    public let nextToken: String?

    public init (
        filters: [ResourceFilter]? = nil,
        group: String? = nil,
        groupName: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.filters = filters
        self.group = group
        self.groupName = groupName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListGroupResourcesInputBody: Equatable {
    public let groupName: String?
    public let group: String?
    public let filters: [ResourceFilter]?
    public let maxResults: Int?
    public let nextToken: String?
}

extension ListGroupResourcesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case group = "Group"
        case groupName = "GroupName"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .groupName)
        groupName = groupNameDecoded
        let groupDecoded = try containerValues.decodeIfPresent(String.self, forKey: .group)
        group = groupDecoded
        let filtersContainer = try containerValues.decodeIfPresent([ResourceFilter?].self, forKey: .filters)
        var filtersDecoded0:[ResourceFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [ResourceFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListGroupResourcesItem: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case identifier = "Identifier"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identifier = identifier {
            try encodeContainer.encode(identifier, forKey: .identifier)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identifierDecoded = try containerValues.decodeIfPresent(ResourceIdentifier.self, forKey: .identifier)
        identifier = identifierDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ResourceStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension ListGroupResourcesItem: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListGroupResourcesItem(identifier: \(String(describing: identifier)), status: \(String(describing: status)))"}
}

/// <p>A structure returned by the <a>ListGroupResources</a> operation that
///             contains identity and group membership status information for one of the resources in
///             the group.</p>
public struct ListGroupResourcesItem: Equatable {
    /// <p>A structure that contains the ARN of a resource and its resource type.</p>
    public let identifier: ResourceIdentifier?
    /// <p>A structure that contains the status of this resource's membership in the
    ///             group.</p>
    ///         <note>
    ///             <p>This field is present in the response only if the group is of type
    ///                     <code>AWS::EC2::HostManagement</code>.</p>
    ///         </note>
    public let status: ResourceStatus?

    public init (
        identifier: ResourceIdentifier? = nil,
        status: ResourceStatus? = nil
    )
    {
        self.identifier = identifier
        self.status = status
    }
}

extension ListGroupResourcesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListGroupResourcesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListGroupResourcesOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case methodNotAllowedException(MethodNotAllowedException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListGroupResourcesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListGroupResourcesOutputResponse(nextToken: \(String(describing: nextToken)), queryErrors: \(String(describing: queryErrors)), resourceIdentifiers: \(String(describing: resourceIdentifiers)), resources: \(String(describing: resources)))"}
}

extension ListGroupResourcesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListGroupResourcesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.queryErrors = output.queryErrors
            self.resourceIdentifiers = output.resourceIdentifiers
            self.resources = output.resources
        } else {
            self.nextToken = nil
            self.queryErrors = nil
            self.resourceIdentifiers = nil
            self.resources = nil
        }
    }
}

public struct ListGroupResourcesOutputResponse: Equatable {
    /// <p>If present, indicates that more output is available than is
    /// included in the current response. Use this value in the <code>NextToken</code> request parameter
    /// in a subsequent call to the operation to get the next part of the output. You should repeat this
    /// until the <code>NextToken</code> response element comes back as <code>null</code>.</p>
    public let nextToken: String?
    /// <p>A list of <code>QueryError</code> objects. Each error is an object that contains
    ///                 <code>ErrorCode</code> and <code>Message</code> structures. Possible values for
    ///                 <code>ErrorCode</code> are <code>CLOUDFORMATION_STACK_INACTIVE</code> and
    ///                 <code>CLOUDFORMATION_STACK_NOT_EXISTING</code>.</p>
    public let queryErrors: [QueryError]?
    /// <important>
    ///             <p>
    ///                <b>
    ///                   <i>Deprecated - don't use this parameter. Use the
    ///                             <code>Resources</code> response field
    ///                 instead.</i>
    ///                </b>
    ///             </p>
    ///         </important>
    @available(*, deprecated, message: "This field is deprecated, use Resources instead.")
    public let resourceIdentifiers: [ResourceIdentifier]?
    /// <p>An array of resources from which you can determine each resource's identity, type, and
    ///             group membership status.</p>
    public let resources: [ListGroupResourcesItem]?

    public init (
        nextToken: String? = nil,
        queryErrors: [QueryError]? = nil,
        resourceIdentifiers: [ResourceIdentifier]? = nil,
        resources: [ListGroupResourcesItem]? = nil
    )
    {
        self.nextToken = nextToken
        self.queryErrors = queryErrors
        self.resourceIdentifiers = resourceIdentifiers
        self.resources = resources
    }
}

struct ListGroupResourcesOutputResponseBody: Equatable {
    public let resources: [ListGroupResourcesItem]?
    public let resourceIdentifiers: [ResourceIdentifier]?
    public let nextToken: String?
    public let queryErrors: [QueryError]?
}

extension ListGroupResourcesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case queryErrors = "QueryErrors"
        case resourceIdentifiers = "ResourceIdentifiers"
        case resources = "Resources"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourcesContainer = try containerValues.decodeIfPresent([ListGroupResourcesItem?].self, forKey: .resources)
        var resourcesDecoded0:[ListGroupResourcesItem]? = nil
        if let resourcesContainer = resourcesContainer {
            resourcesDecoded0 = [ListGroupResourcesItem]()
            for structure0 in resourcesContainer {
                if let structure0 = structure0 {
                    resourcesDecoded0?.append(structure0)
                }
            }
        }
        resources = resourcesDecoded0
        let resourceIdentifiersContainer = try containerValues.decodeIfPresent([ResourceIdentifier?].self, forKey: .resourceIdentifiers)
        var resourceIdentifiersDecoded0:[ResourceIdentifier]? = nil
        if let resourceIdentifiersContainer = resourceIdentifiersContainer {
            resourceIdentifiersDecoded0 = [ResourceIdentifier]()
            for structure0 in resourceIdentifiersContainer {
                if let structure0 = structure0 {
                    resourceIdentifiersDecoded0?.append(structure0)
                }
            }
        }
        resourceIdentifiers = resourceIdentifiersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let queryErrorsContainer = try containerValues.decodeIfPresent([QueryError?].self, forKey: .queryErrors)
        var queryErrorsDecoded0:[QueryError]? = nil
        if let queryErrorsContainer = queryErrorsContainer {
            queryErrorsDecoded0 = [QueryError]()
            for structure0 in queryErrorsContainer {
                if let structure0 = structure0 {
                    queryErrorsDecoded0?.append(structure0)
                }
            }
        }
        queryErrors = queryErrorsDecoded0
    }
}

public struct ListGroupsInputBodyMiddleware: Middleware {
    public let id: String = "ListGroupsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListGroupsInput>
    public typealias MOutput = OperationOutput<ListGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListGroupsOutputError>
}

extension ListGroupsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListGroupsInput(filters: \(String(describing: filters)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListGroupsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for groupfilterlist0 in filters {
                try filtersContainer.encode(groupfilterlist0)
            }
        }
    }
}

public struct ListGroupsInputHeadersMiddleware: Middleware {
    public let id: String = "ListGroupsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListGroupsInput>
    public typealias MOutput = OperationOutput<ListGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListGroupsOutputError>
}

public struct ListGroupsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListGroupsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListGroupsInput>
    public typealias MOutput = OperationOutput<ListGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListGroupsOutputError>
}

public struct ListGroupsInput: Equatable {
    /// <p>Filters, formatted as <a>GroupFilter</a> objects, that you want to apply to
    ///             a <code>ListGroups</code> operation.</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <code>resource-type</code> - Filter the results to include only those of the
    ///                     specified resource types. Specify up to five resource types in the format
    ///                             <code>AWS::<i>ServiceCode</i>::<i>ResourceType</i>
    ///                   </code>.
    ///                     For example, <code>AWS::EC2::Instance</code>, or
    ///                     <code>AWS::S3::Bucket</code>.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>configuration-type</code> - Filter the results to include only those
    ///                     groups that have the specified configuration types attached. The current
    ///                     supported values are:</p>
    ///                 <ul>
    ///                   <li>
    ///                         <p>
    ///                         <code>AWS:EC2::CapacityReservationPool</code>
    ///                      </p>
    ///                     </li>
    ///                   <li>
    ///                         <p>
    ///                         <code>AWS:EC2::HostManagement</code>
    ///                      </p>
    ///                     </li>
    ///                </ul>
    ///             </li>
    ///          </ul>
    public let filters: [GroupFilter]?
    /// <p>The total number of results that you want included on each page of the
    /// response. If you do not include this parameter, it defaults to a value that is specific to the
    /// operation. If additional items exist beyond the maximum you specify, the <code>NextToken</code>
    /// response element is present and has a value (is not null). Include that value as the
    /// <code>NextToken</code> request parameter in the next call to the operation to get the next part
    /// of the results. Note that the service might return fewer results than the maximum even when there
    /// are more results available. You should check <code>NextToken</code> after every operation to
    /// ensure that you receive all of the results.</p>
    public let maxResults: Int?
    /// <p>The parameter for receiving additional results if you receive a
    /// <code>NextToken</code> response in a previous request. A <code>NextToken</code> response
    /// indicates that more output is available. Set this parameter to the value provided by a previous
    /// call's <code>NextToken</code> response to indicate where the output should continue from.</p>
    public let nextToken: String?

    public init (
        filters: [GroupFilter]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListGroupsInputBody: Equatable {
    public let filters: [GroupFilter]?
}

extension ListGroupsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([GroupFilter?].self, forKey: .filters)
        var filtersDecoded0:[GroupFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [GroupFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListGroupsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListGroupsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListGroupsOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case methodNotAllowedException(MethodNotAllowedException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListGroupsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListGroupsOutputResponse(groupIdentifiers: \(String(describing: groupIdentifiers)), groups: \(String(describing: groups)), nextToken: \(String(describing: nextToken)))"}
}

extension ListGroupsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListGroupsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.groupIdentifiers = output.groupIdentifiers
            self.groups = output.groups
            self.nextToken = output.nextToken
        } else {
            self.groupIdentifiers = nil
            self.groups = nil
            self.nextToken = nil
        }
    }
}

public struct ListGroupsOutputResponse: Equatable {
    /// <p>A list of <a>GroupIdentifier</a> objects. Each identifier is an object that
    ///             contains both the <code>Name</code> and the <code>GroupArn</code>.</p>
    public let groupIdentifiers: [GroupIdentifier]?
    /// <important>
    ///             <p>
    ///                <i>
    ///                   <b>Deprecated - don't use this field. Use the
    ///                             <code>GroupIdentifiers</code> response field
    ///                     instead.</b>
    ///                </i>
    ///             </p>
    ///         </important>
    @available(*, deprecated, message: "This field is deprecated, use GroupIdentifiers instead.")
    public let groups: [Group]?
    /// <p>If present, indicates that more output is available than is
    /// included in the current response. Use this value in the <code>NextToken</code> request parameter
    /// in a subsequent call to the operation to get the next part of the output. You should repeat this
    /// until the <code>NextToken</code> response element comes back as <code>null</code>.</p>
    public let nextToken: String?

    public init (
        groupIdentifiers: [GroupIdentifier]? = nil,
        groups: [Group]? = nil,
        nextToken: String? = nil
    )
    {
        self.groupIdentifiers = groupIdentifiers
        self.groups = groups
        self.nextToken = nextToken
    }
}

struct ListGroupsOutputResponseBody: Equatable {
    public let groupIdentifiers: [GroupIdentifier]?
    public let groups: [Group]?
    public let nextToken: String?
}

extension ListGroupsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case groupIdentifiers = "GroupIdentifiers"
        case groups = "Groups"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupIdentifiersContainer = try containerValues.decodeIfPresent([GroupIdentifier?].self, forKey: .groupIdentifiers)
        var groupIdentifiersDecoded0:[GroupIdentifier]? = nil
        if let groupIdentifiersContainer = groupIdentifiersContainer {
            groupIdentifiersDecoded0 = [GroupIdentifier]()
            for structure0 in groupIdentifiersContainer {
                if let structure0 = structure0 {
                    groupIdentifiersDecoded0?.append(structure0)
                }
            }
        }
        groupIdentifiers = groupIdentifiersDecoded0
        let groupsContainer = try containerValues.decodeIfPresent([Group?].self, forKey: .groups)
        var groupsDecoded0:[Group]? = nil
        if let groupsContainer = groupsContainer {
            groupsDecoded0 = [Group]()
            for structure0 in groupsContainer {
                if let structure0 = structure0 {
                    groupsDecoded0?.append(structure0)
                }
            }
        }
        groups = groupsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension MethodNotAllowedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MethodNotAllowedException(message: \(String(describing: message)))"}
}

extension MethodNotAllowedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: MethodNotAllowedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request uses an HTTP method that isn't allowed for the specified resource.</p>
public struct MethodNotAllowedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct MethodNotAllowedExceptionBody: Equatable {
    public let message: String?
}

extension MethodNotAllowedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NotFoundException(message: \(String(describing: message)))"}
}

extension NotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: NotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>One or more of the specified resources don't exist.</p>
public struct NotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct NotFoundExceptionBody: Equatable {
    public let message: String?
}

extension NotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PendingResource: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension PendingResource: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PendingResource(resourceArn: \(String(describing: resourceArn)))"}
}

/// <p>A structure that identifies a resource that is currently pending addition to the group
///             as a member. Adding a resource to a resource group happens asynchronously as a
///             background task and this one isn't completed yet.</p>
public struct PendingResource: Equatable {
    /// <p>The Amazon resource name (ARN) of the resource that's in a pending state.</p>
    public let resourceArn: String?

    public init (
        resourceArn: String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

public struct PutGroupConfigurationInputBodyMiddleware: Middleware {
    public let id: String = "PutGroupConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutGroupConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<PutGroupConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutGroupConfigurationInput>
    public typealias MOutput = OperationOutput<PutGroupConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutGroupConfigurationOutputError>
}

extension PutGroupConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutGroupConfigurationInput(configuration: \(String(describing: configuration)), group: \(String(describing: group)))"}
}

extension PutGroupConfigurationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case configuration = "Configuration"
        case group = "Group"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configuration = configuration {
            var configurationContainer = encodeContainer.nestedUnkeyedContainer(forKey: .configuration)
            for groupconfigurationlist0 in configuration {
                try configurationContainer.encode(groupconfigurationlist0)
            }
        }
        if let group = group {
            try encodeContainer.encode(group, forKey: .group)
        }
    }
}

public struct PutGroupConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "PutGroupConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutGroupConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<PutGroupConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutGroupConfigurationInput>
    public typealias MOutput = OperationOutput<PutGroupConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutGroupConfigurationOutputError>
}

public struct PutGroupConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "PutGroupConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutGroupConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<PutGroupConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutGroupConfigurationInput>
    public typealias MOutput = OperationOutput<PutGroupConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutGroupConfigurationOutputError>
}

public struct PutGroupConfigurationInput: Equatable {
    /// <p>The new configuration to associate with the specified group. A configuration
    ///             associates the resource group with an AWS service and specifies how the service can
    ///             interact with the resources in the group. A configuration is an array of <a>GroupConfigurationItem</a> elements.</p>
    ///         <p>For information about the syntax of a service configuration, see <a href="https://docs.aws.amazon.com/ARG/latest/APIReference/about-slg.html">Service configurations for
    ///                 resource groups</a>.</p>
    ///         <note>
    ///             <p>A resource group can contain either a <code>Configuration</code> or a
    ///                     <code>ResourceQuery</code>, but not both.</p>
    ///         </note>
    public let configuration: [GroupConfigurationItem]?
    /// <p>The name or ARN of the resource group with the configuration that you want to
    ///             update.</p>
    public let group: String?

    public init (
        configuration: [GroupConfigurationItem]? = nil,
        group: String? = nil
    )
    {
        self.configuration = configuration
        self.group = group
    }
}

struct PutGroupConfigurationInputBody: Equatable {
    public let group: String?
    public let configuration: [GroupConfigurationItem]?
}

extension PutGroupConfigurationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case configuration = "Configuration"
        case group = "Group"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupDecoded = try containerValues.decodeIfPresent(String.self, forKey: .group)
        group = groupDecoded
        let configurationContainer = try containerValues.decodeIfPresent([GroupConfigurationItem?].self, forKey: .configuration)
        var configurationDecoded0:[GroupConfigurationItem]? = nil
        if let configurationContainer = configurationContainer {
            configurationDecoded0 = [GroupConfigurationItem]()
            for structure0 in configurationContainer {
                if let structure0 = structure0 {
                    configurationDecoded0?.append(structure0)
                }
            }
        }
        configuration = configurationDecoded0
    }
}

extension PutGroupConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutGroupConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutGroupConfigurationOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case methodNotAllowedException(MethodNotAllowedException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutGroupConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutGroupConfigurationOutputResponse()"}
}

extension PutGroupConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct PutGroupConfigurationOutputResponse: Equatable {

    public init() {}
}

struct PutGroupConfigurationOutputResponseBody: Equatable {
}

extension PutGroupConfigurationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension QueryError: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case errorCode = "ErrorCode"
        case message = "Message"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode.rawValue, forKey: .errorCode)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(QueryErrorCode.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension QueryError: CustomDebugStringConvertible {
    public var debugDescription: String {
        "QueryError(errorCode: \(String(describing: errorCode)), message: \(String(describing: message)))"}
}

/// <p>A two-part error structure that can occur in <code>ListGroupResources</code> or
///                 <code>SearchResources</code> operations on CloudFormation stack-based queries. The error
///             occurs if the CloudFormation stack on which the query is based either does not exist, or has a
///             status that renders the stack inactive. A <code>QueryError</code> occurrence does not
///             necessarily mean that AWS Resource Groups could not complete the operation, but the resulting
///             group might have no member resources.</p>
public struct QueryError: Equatable {
    /// <p>Possible values are <code>CLOUDFORMATION_STACK_INACTIVE</code> and
    ///                 <code>CLOUDFORMATION_STACK_NOT_EXISTING</code>.</p>
    public let errorCode: QueryErrorCode?
    /// <p>A message that explains the <code>ErrorCode</code> value. Messages might state that
    ///             the specified CloudFormation stack does not exist (or no longer exists). For
    ///                 <code>CLOUDFORMATION_STACK_INACTIVE</code>, the message typically states that the
    ///             CloudFormation stack has a status that is not (or no longer) active, such as
    ///                 <code>CREATE_FAILED</code>.</p>
    public let message: String?

    public init (
        errorCode: QueryErrorCode? = nil,
        message: String? = nil
    )
    {
        self.errorCode = errorCode
        self.message = message
    }
}

public enum QueryErrorCode {
    case cloudformationStackInactive
    case cloudformationStackNotExisting
    case sdkUnknown(String)
}

extension QueryErrorCode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [QueryErrorCode] {
        return [
            .cloudformationStackInactive,
            .cloudformationStackNotExisting,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .cloudformationStackInactive: return "CLOUDFORMATION_STACK_INACTIVE"
        case .cloudformationStackNotExisting: return "CLOUDFORMATION_STACK_NOT_EXISTING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = QueryErrorCode(rawValue: rawValue) ?? QueryErrorCode.sdkUnknown(rawValue)
    }
}

public enum QueryType {
    case cloudformationStack10
    case tagFilters10
    case sdkUnknown(String)
}

extension QueryType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [QueryType] {
        return [
            .cloudformationStack10,
            .tagFilters10,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .cloudformationStack10: return "CLOUDFORMATION_STACK_1_0"
        case .tagFilters10: return "TAG_FILTERS_1_0"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = QueryType(rawValue: rawValue) ?? QueryType.sdkUnknown(rawValue)
    }
}

extension ResourceFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case values = "Values"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for resourcefiltervalues0 in values {
                try valuesContainer.encode(resourcefiltervalues0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(ResourceFilterName.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .values)
        var valuesDecoded0:[String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension ResourceFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceFilter(name: \(String(describing: name)), values: \(String(describing: values)))"}
}

/// <p>A filter name and value pair that is used to obtain more specific results from a list
///             of resources.</p>
public struct ResourceFilter: Equatable {
    /// <p>The name of the filter. Filter names are case-sensitive.</p>
    public let name: ResourceFilterName?
    /// <p>One or more filter values. Allowed filter values vary by resource filter name, and are
    ///             case-sensitive.</p>
    public let values: [String]?

    public init (
        name: ResourceFilterName? = nil,
        values: [String]? = nil
    )
    {
        self.name = name
        self.values = values
    }
}

public enum ResourceFilterName {
    case resourcetype
    case sdkUnknown(String)
}

extension ResourceFilterName : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ResourceFilterName] {
        return [
            .resourcetype,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .resourcetype: return "resource-type"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ResourceFilterName(rawValue: rawValue) ?? ResourceFilterName.sdkUnknown(rawValue)
    }
}

extension ResourceIdentifier: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
        case resourceType = "ResourceType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension ResourceIdentifier: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceIdentifier(resourceArn: \(String(describing: resourceArn)), resourceType: \(String(describing: resourceType)))"}
}

/// <p>A structure that contains the ARN of a resource and its resource type.</p>
public struct ResourceIdentifier: Equatable {
    /// <p>The ARN of a resource.</p>
    public let resourceArn: String?
    /// <p>The resource type of a resource, such as <code>AWS::EC2::Instance</code>.</p>
    public let resourceType: String?

    public init (
        resourceArn: String? = nil,
        resourceType: String? = nil
    )
    {
        self.resourceArn = resourceArn
        self.resourceType = resourceType
    }
}

extension ResourceQuery: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case query = "Query"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let query = query {
            try encodeContainer.encode(query, forKey: .query)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(QueryType.self, forKey: .type)
        type = typeDecoded
        let queryDecoded = try containerValues.decodeIfPresent(String.self, forKey: .query)
        query = queryDecoded
    }
}

extension ResourceQuery: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceQuery(query: \(String(describing: query)), type: \(String(describing: type)))"}
}

/// <p>The query that is used to define a resource group or a search for resources. A query
///             specifies both a query type and a query string as a JSON object. See the examples
///             section for example JSON strings.</p>
///         <p>The examples that follow are shown as standard JSON strings. If you include such a
///             string as a parameter to the AWS CLI or an SDK API, you might need to 'escape' the
///             string into a single line. For example, see the <a href="https://docs.aws.amazon.com/cli/latest/userguide/cli-usage-parameters-quoting-strings.html">Quoting
///                 strings</a> in the <i>AWS CLI User Guide</i>.</p>
///         <p>
///             <b>Example 1</b>
///          </p>
///         <p>The following generic example shows a resource query JSON string that includes only
///             resources that meet the following criteria:</p>
///         <ul>
///             <li>
///                 <p>The resource type must be either <code>resource_type1</code> or
///                         <code>resource_type2</code>.</p>
///             </li>
///             <li>
///                 <p>The resource must have a tag <code>Key1</code> with a value of either
///                         <code>ValueA</code> or <code>ValueB</code>.</p>
///             </li>
///             <li>
///                 <p>The resource must have a tag <code>Key2</code> with a value of either
///                         <code>ValueC</code> or <code>ValueD</code>.</p>
///             </li>
///          </ul>
///         <p>
///             <code>{
///     "Type": "TAG_FILTERS_1_0",
///     "Query": {
///         "ResourceTypeFilters": [ "resource_type1", "resource_type2"],
///         "TagFilters": [
///             {
///                 "Key": "Key1",
///                 "Values": ["ValueA","ValueB"]
///             },
///             {
///                 "Key":"Key2",
///                 "Values":["ValueC","ValueD"]
///             }
///         ]
///     }
/// }</code>
///          </p>
///         <p>This has the equivalent "shortcut" syntax of the following:</p>
///         <p>
///             <code>{
///     "Type": "TAG_FILTERS_1_0",
///     "Query": {
///         "ResourceTypeFilters": [ "resource_type1", "resource_type2"],
///         "TagFilters": [
///             { "Key1": ["ValueA","ValueB"] },
///             { "Key2": ["ValueC","ValueD"]
///             }
///         ]
///     }
/// }</code>
///          </p>
///         <p>
///             <b>Example 2</b>
///          </p>
///         <p>The following example shows a resource query JSON string that includes only Amazon EC2
///             instances that are tagged <code>Stage</code> with a value of <code>Test</code>.</p>
///         <p>
///             <code>{
///     "Type": "TAG_FILTERS_1_0",
///     "Query": "{
///         "ResourceTypeFilters": "AWS::EC2::Instance",
///         "TagFilters": { "Stage": "Test" }
///     }
/// }</code>
///          </p>
///         <p>
///             <b>Example 3</b>
///          </p>
///         <p>The following example shows a resource query JSON string that includes resource of any
///             supported type as long as it is tagged <code>Stage</code> with a value of
///                 <code>Prod</code>.</p>
///         <p>
///             <code>{
///     "Type": "TAG_FILTERS_1_0",
///     "Query": {
///         "ResourceTypeFilters": "AWS::AllSupported",
///         "TagFilters": { "Stage": "Prod" }
///     }
/// }</code>
///          </p>
///         <p>
///             <b>Example 4</b>
///          </p>
///         <p>The following example shows a resource query JSON string that includes only Amazon EC2
///             instances and Amazon S3 buckets that are part of the specified AWS CloudFormation stack.</p>
///         <p>
///             <code>{
///     "Type": "CLOUDFORMATION_STACK_1_0",
///     "Query": {
///         "ResourceTypeFilters": [ "AWS::EC2::Instance", "AWS::S3::Bucket" ],
///         "StackIdentifier": "arn:aws:cloudformation:us-west-2:123456789012:stack/AWStestuseraccount/fb0d5000-aba8-00e8-aa9e-50d5cEXAMPLE"
///     }
/// }</code>
///          </p>
public struct ResourceQuery: Equatable {
    /// <p>The query that defines a group or a search.</p>
    public let query: String?
    /// <p>The type of the query. You can use the following values:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <i>
    ///                      <code>CLOUDFORMATION_STACK_1_0:</code>
    ///                   </i>Specifies that the
    ///                         <code>Query</code> contains an ARN for a CloudFormation stack.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <i>
    ///                      <code>TAG_FILTERS_1_0:</code>
    ///                   </i>Specifies that the
    ///                         <code>Query</code> parameter contains a JSON string that represents a
    ///                     collection of simple tag filters for resource types and tags. The JSON string
    ///                     uses a syntax similar to the <code>
    ///                      <a href="https://docs.aws.amazon.com/resourcegroupstagging/latest/APIReference/API_GetResources.html">GetResources</a>
    ///                   </code> operation, but uses only the <code>
    ///                      <a href="https://docs.aws.amazon.com/resourcegroupstagging/latest/APIReference/API_GetResources.html#resourcegrouptagging-GetResources-request-ResourceTypeFilters"> ResourceTypeFilters</a>
    ///                   </code> and <code>
    ///                      <a href="https://docs.aws.amazon.com/resourcegroupstagging/latest/APIReference/API_GetResources.html#resourcegrouptagging-GetResources-request-TagFiltersTagFilters">TagFilters</a>
    ///                   </code> fields. If you specify more than one tag key,
    ///                     only resources that match all tag keys, and at least one value of each specified
    ///                     tag key, are returned in your query. If you specify more than one value for a
    ///                     tag key, a resource matches the filter if it has a tag key value that matches
    ///                         <i>any</i> of the specified values.</p>
    ///                 <p>For example, consider the following sample query for resources that have two
    ///                     tags, <code>Stage</code> and <code>Version</code>, with two values each:</p>
    ///                 <p>
    ///                   <code>[{"Stage":["Test","Deploy"]},{"Version":["1","2"]}]</code>
    ///                </p>
    ///                 <p>The results of this query could include the following.</p>
    ///                 <ul>
    ///                   <li>
    ///                         <p>An EC2 instance that has the following two tags:
    ///                                 <code>{"Stage":"Deploy"}</code>, and
    ///                             <code>{"Version":"2"}</code>
    ///                      </p>
    ///                     </li>
    ///                   <li>
    ///                         <p>An S3 bucket that has the following two tags:
    ///                                 <code>{"Stage":"Test"}</code>, and
    ///                             <code>{"Version":"1"}</code>
    ///                      </p>
    ///                     </li>
    ///                </ul>
    ///                 <p>The query would not include the following items in the results, however. </p>
    ///                 <ul>
    ///                   <li>
    ///                         <p>An EC2 instance that has only the following tag:
    ///                                 <code>{"Stage":"Deploy"}</code>.</p>
    ///                         <p>The instance does not have <b>all</b> of the
    ///                             tag keys specified in the filter, so it is excluded from the
    ///                             results.</p>
    ///                     </li>
    ///                   <li>
    ///                         <p>An RDS database that has the following two tags:
    ///                                 <code>{"Stage":"Archived"}</code> and
    ///                             <code>{"Version":"4"}</code>
    ///                      </p>
    ///                         <p>The database has all of the tag keys, but none of those keys has an
    ///                             associated value that matches at least one of the specified values in
    ///                             the filter.</p>
    ///                     </li>
    ///                </ul>
    ///             </li>
    ///          </ul>
    public let type: QueryType?

    public init (
        query: String? = nil,
        type: QueryType? = nil
    )
    {
        self.query = query
        self.type = type
    }
}

extension ResourceStatus: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(ResourceStatusValue.self, forKey: .name)
        name = nameDecoded
    }
}

extension ResourceStatus: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceStatus(name: \(String(describing: name)))"}
}

/// <p>A structure that identifies the current group membership status for a resource. Adding
///             a resource to a resource group is performed asynchronously as a background task. A
///                 <code>PENDING</code> status indicates, for this resource, that the process isn't
///             completed yet.</p>
public struct ResourceStatus: Equatable {
    /// <p>The current status.</p>
    public let name: ResourceStatusValue?

    public init (
        name: ResourceStatusValue? = nil
    )
    {
        self.name = name
    }
}

public enum ResourceStatusValue {
    case pending
    case sdkUnknown(String)
}

extension ResourceStatusValue : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ResourceStatusValue] {
        return [
            .pending,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .pending: return "PENDING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ResourceStatusValue(rawValue: rawValue) ?? ResourceStatusValue.sdkUnknown(rawValue)
    }
}

public struct SearchResourcesInputBodyMiddleware: Middleware {
    public let id: String = "SearchResourcesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SearchResourcesInput>,
                  next: H) -> Swift.Result<OperationOutput<SearchResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SearchResourcesInput>
    public typealias MOutput = OperationOutput<SearchResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SearchResourcesOutputError>
}

extension SearchResourcesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SearchResourcesInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), resourceQuery: \(String(describing: resourceQuery)))"}
}

extension SearchResourcesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceQuery = "ResourceQuery"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceQuery = resourceQuery {
            try encodeContainer.encode(resourceQuery, forKey: .resourceQuery)
        }
    }
}

public struct SearchResourcesInputHeadersMiddleware: Middleware {
    public let id: String = "SearchResourcesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SearchResourcesInput>,
                  next: H) -> Swift.Result<OperationOutput<SearchResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SearchResourcesInput>
    public typealias MOutput = OperationOutput<SearchResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SearchResourcesOutputError>
}

public struct SearchResourcesInputQueryItemMiddleware: Middleware {
    public let id: String = "SearchResourcesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SearchResourcesInput>,
                  next: H) -> Swift.Result<OperationOutput<SearchResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SearchResourcesInput>
    public typealias MOutput = OperationOutput<SearchResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SearchResourcesOutputError>
}

public struct SearchResourcesInput: Equatable {
    /// <p>The total number of results that you want included on each page of the
    /// response. If you do not include this parameter, it defaults to a value that is specific to the
    /// operation. If additional items exist beyond the maximum you specify, the <code>NextToken</code>
    /// response element is present and has a value (is not null). Include that value as the
    /// <code>NextToken</code> request parameter in the next call to the operation to get the next part
    /// of the results. Note that the service might return fewer results than the maximum even when there
    /// are more results available. You should check <code>NextToken</code> after every operation to
    /// ensure that you receive all of the results.</p>
    public let maxResults: Int?
    /// <p>The parameter for receiving additional results if you receive a
    /// <code>NextToken</code> response in a previous request. A <code>NextToken</code> response
    /// indicates that more output is available. Set this parameter to the value provided by a previous
    /// call's <code>NextToken</code> response to indicate where the output should continue from.</p>
    public let nextToken: String?
    /// <p>The search query, using the same formats that are supported for resource group
    ///             definition. For more information, see <a>CreateGroup</a>.</p>
    public let resourceQuery: ResourceQuery?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        resourceQuery: ResourceQuery? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceQuery = resourceQuery
    }
}

struct SearchResourcesInputBody: Equatable {
    public let resourceQuery: ResourceQuery?
    public let maxResults: Int?
    public let nextToken: String?
}

extension SearchResourcesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceQuery = "ResourceQuery"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceQueryDecoded = try containerValues.decodeIfPresent(ResourceQuery.self, forKey: .resourceQuery)
        resourceQuery = resourceQueryDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension SearchResourcesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SearchResourcesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SearchResourcesOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case methodNotAllowedException(MethodNotAllowedException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SearchResourcesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SearchResourcesOutputResponse(nextToken: \(String(describing: nextToken)), queryErrors: \(String(describing: queryErrors)), resourceIdentifiers: \(String(describing: resourceIdentifiers)))"}
}

extension SearchResourcesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: SearchResourcesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.queryErrors = output.queryErrors
            self.resourceIdentifiers = output.resourceIdentifiers
        } else {
            self.nextToken = nil
            self.queryErrors = nil
            self.resourceIdentifiers = nil
        }
    }
}

public struct SearchResourcesOutputResponse: Equatable {
    /// <p>If present, indicates that more output is available than is
    /// included in the current response. Use this value in the <code>NextToken</code> request parameter
    /// in a subsequent call to the operation to get the next part of the output. You should repeat this
    /// until the <code>NextToken</code> response element comes back as <code>null</code>.</p>
    public let nextToken: String?
    /// <p>A list of <code>QueryError</code> objects. Each error is an object that contains
    ///                 <code>ErrorCode</code> and <code>Message</code> structures. Possible values for
    ///                 <code>ErrorCode</code> are <code>CLOUDFORMATION_STACK_INACTIVE</code> and
    ///                 <code>CLOUDFORMATION_STACK_NOT_EXISTING</code>.</p>
    public let queryErrors: [QueryError]?
    /// <p>The ARNs and resource types of resources that are members of the group that you
    ///             specified.</p>
    public let resourceIdentifiers: [ResourceIdentifier]?

    public init (
        nextToken: String? = nil,
        queryErrors: [QueryError]? = nil,
        resourceIdentifiers: [ResourceIdentifier]? = nil
    )
    {
        self.nextToken = nextToken
        self.queryErrors = queryErrors
        self.resourceIdentifiers = resourceIdentifiers
    }
}

struct SearchResourcesOutputResponseBody: Equatable {
    public let resourceIdentifiers: [ResourceIdentifier]?
    public let nextToken: String?
    public let queryErrors: [QueryError]?
}

extension SearchResourcesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case queryErrors = "QueryErrors"
        case resourceIdentifiers = "ResourceIdentifiers"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdentifiersContainer = try containerValues.decodeIfPresent([ResourceIdentifier?].self, forKey: .resourceIdentifiers)
        var resourceIdentifiersDecoded0:[ResourceIdentifier]? = nil
        if let resourceIdentifiersContainer = resourceIdentifiersContainer {
            resourceIdentifiersDecoded0 = [ResourceIdentifier]()
            for structure0 in resourceIdentifiersContainer {
                if let structure0 = structure0 {
                    resourceIdentifiersDecoded0?.append(structure0)
                }
            }
        }
        resourceIdentifiers = resourceIdentifiersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let queryErrorsContainer = try containerValues.decodeIfPresent([QueryError?].self, forKey: .queryErrors)
        var queryErrorsDecoded0:[QueryError]? = nil
        if let queryErrorsContainer = queryErrorsContainer {
            queryErrorsDecoded0 = [QueryError]()
            for structure0 in queryErrorsContainer {
                if let structure0 = structure0 {
                    queryErrorsDecoded0?.append(structure0)
                }
            }
        }
        queryErrors = queryErrorsDecoded0
    }
}

public struct TagInputBodyMiddleware: Middleware {
    public let id: String = "TagInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagInput>,
                  next: H) -> Swift.Result<OperationOutput<TagOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagInput>
    public typealias MOutput = OperationOutput<TagOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagOutputError>
}

extension TagInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagInput(arn: \(String(describing: arn)), tags: \(String(describing: tags)))"}
}

extension TagInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct TagInputHeadersMiddleware: Middleware {
    public let id: String = "TagInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagInput>,
                  next: H) -> Swift.Result<OperationOutput<TagOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagInput>
    public typealias MOutput = OperationOutput<TagOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagOutputError>
}

public struct TagInputQueryItemMiddleware: Middleware {
    public let id: String = "TagInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagInput>,
                  next: H) -> Swift.Result<OperationOutput<TagOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagInput>
    public typealias MOutput = OperationOutput<TagOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagOutputError>
}

public struct TagInput: Equatable {
    /// <p>The ARN of the resource group to which to add tags.</p>
    public let arn: String?
    /// <p>The tags to add to the specified resource group. A tag is a string-to-string map of
    ///             key-value pairs.</p>
    public let tags: [String:String]?

    public init (
        arn: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.arn = arn
        self.tags = tags
    }
}

struct TagInputBody: Equatable {
    public let tags: [String:String]?
}

extension TagInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case methodNotAllowedException(MethodNotAllowedException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagOutputResponse(arn: \(String(describing: arn)), tags: \(String(describing: tags)))"}
}

extension TagOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: TagOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.tags = output.tags
        } else {
            self.arn = nil
            self.tags = nil
        }
    }
}

public struct TagOutputResponse: Equatable {
    /// <p>The ARN of the tagged resource.</p>
    public let arn: String?
    /// <p>The tags that have been added to the specified resource group.</p>
    public let tags: [String:String]?

    public init (
        arn: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.arn = arn
        self.tags = tags
    }
}

struct TagOutputResponseBody: Equatable {
    public let arn: String?
    public let tags: [String:String]?
}

extension TagOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TooManyRequestsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TooManyRequestsException(message: \(String(describing: message)))"}
}

extension TooManyRequestsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: TooManyRequestsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You've exceeded throttling limits by making too many requests in a period of
///             time.</p>
public struct TooManyRequestsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyRequestsExceptionBody: Equatable {
    public let message: String?
}

extension TooManyRequestsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UnauthorizedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UnauthorizedException(message: \(String(describing: message)))"}
}

extension UnauthorizedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UnauthorizedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request was rejected because it doesn't have valid credentials for the target
///             resource.</p>
public struct UnauthorizedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct UnauthorizedExceptionBody: Equatable {
    public let message: String?
}

extension UnauthorizedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct UngroupResourcesInputBodyMiddleware: Middleware {
    public let id: String = "UngroupResourcesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UngroupResourcesInput>,
                  next: H) -> Swift.Result<OperationOutput<UngroupResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UngroupResourcesInput>
    public typealias MOutput = OperationOutput<UngroupResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UngroupResourcesOutputError>
}

extension UngroupResourcesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UngroupResourcesInput(group: \(String(describing: group)), resourceArns: \(String(describing: resourceArns)))"}
}

extension UngroupResourcesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case group = "Group"
        case resourceArns = "ResourceArns"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let group = group {
            try encodeContainer.encode(group, forKey: .group)
        }
        if let resourceArns = resourceArns {
            var resourceArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceArns)
            for resourcearnlist0 in resourceArns {
                try resourceArnsContainer.encode(resourcearnlist0)
            }
        }
    }
}

public struct UngroupResourcesInputHeadersMiddleware: Middleware {
    public let id: String = "UngroupResourcesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UngroupResourcesInput>,
                  next: H) -> Swift.Result<OperationOutput<UngroupResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UngroupResourcesInput>
    public typealias MOutput = OperationOutput<UngroupResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UngroupResourcesOutputError>
}

public struct UngroupResourcesInputQueryItemMiddleware: Middleware {
    public let id: String = "UngroupResourcesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UngroupResourcesInput>,
                  next: H) -> Swift.Result<OperationOutput<UngroupResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UngroupResourcesInput>
    public typealias MOutput = OperationOutput<UngroupResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UngroupResourcesOutputError>
}

public struct UngroupResourcesInput: Equatable {
    /// <p>The name or the ARN of the resource group from which to remove the resources.</p>
    public let group: String?
    /// <p>The ARNs of the resources to be removed from the group.</p>
    public let resourceArns: [String]?

    public init (
        group: String? = nil,
        resourceArns: [String]? = nil
    )
    {
        self.group = group
        self.resourceArns = resourceArns
    }
}

struct UngroupResourcesInputBody: Equatable {
    public let group: String?
    public let resourceArns: [String]?
}

extension UngroupResourcesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case group = "Group"
        case resourceArns = "ResourceArns"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupDecoded = try containerValues.decodeIfPresent(String.self, forKey: .group)
        group = groupDecoded
        let resourceArnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .resourceArns)
        var resourceArnsDecoded0:[String]? = nil
        if let resourceArnsContainer = resourceArnsContainer {
            resourceArnsDecoded0 = [String]()
            for string0 in resourceArnsContainer {
                if let string0 = string0 {
                    resourceArnsDecoded0?.append(string0)
                }
            }
        }
        resourceArns = resourceArnsDecoded0
    }
}

extension UngroupResourcesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UngroupResourcesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UngroupResourcesOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case methodNotAllowedException(MethodNotAllowedException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UngroupResourcesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UngroupResourcesOutputResponse(failed: \(String(describing: failed)), pending: \(String(describing: pending)), succeeded: \(String(describing: succeeded)))"}
}

extension UngroupResourcesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UngroupResourcesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.failed = output.failed
            self.pending = output.pending
            self.succeeded = output.succeeded
        } else {
            self.failed = nil
            self.pending = nil
            self.succeeded = nil
        }
    }
}

public struct UngroupResourcesOutputResponse: Equatable {
    /// <p>A list of any resources that failed to be removed from the group by this
    ///             operation.</p>
    public let failed: [FailedResource]?
    /// <p>A list of any resources that are still in the process of being removed from the group
    ///             by this operation. These pending removals continue asynchronously. You can check the
    ///             status of pending removals by using the <code>
    ///                <a>ListGroupResources</a>
    ///             </code> operation. After the resource is successfully removed, it no longer
    ///             appears in the response.</p>
    public let pending: [PendingResource]?
    /// <p>A list of resources that were successfully removed from the group by this
    ///             operation.</p>
    public let succeeded: [String]?

    public init (
        failed: [FailedResource]? = nil,
        pending: [PendingResource]? = nil,
        succeeded: [String]? = nil
    )
    {
        self.failed = failed
        self.pending = pending
        self.succeeded = succeeded
    }
}

struct UngroupResourcesOutputResponseBody: Equatable {
    public let succeeded: [String]?
    public let failed: [FailedResource]?
    public let pending: [PendingResource]?
}

extension UngroupResourcesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case failed = "Failed"
        case pending = "Pending"
        case succeeded = "Succeeded"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let succeededContainer = try containerValues.decodeIfPresent([String?].self, forKey: .succeeded)
        var succeededDecoded0:[String]? = nil
        if let succeededContainer = succeededContainer {
            succeededDecoded0 = [String]()
            for string0 in succeededContainer {
                if let string0 = string0 {
                    succeededDecoded0?.append(string0)
                }
            }
        }
        succeeded = succeededDecoded0
        let failedContainer = try containerValues.decodeIfPresent([FailedResource?].self, forKey: .failed)
        var failedDecoded0:[FailedResource]? = nil
        if let failedContainer = failedContainer {
            failedDecoded0 = [FailedResource]()
            for structure0 in failedContainer {
                if let structure0 = structure0 {
                    failedDecoded0?.append(structure0)
                }
            }
        }
        failed = failedDecoded0
        let pendingContainer = try containerValues.decodeIfPresent([PendingResource?].self, forKey: .pending)
        var pendingDecoded0:[PendingResource]? = nil
        if let pendingContainer = pendingContainer {
            pendingDecoded0 = [PendingResource]()
            for structure0 in pendingContainer {
                if let structure0 = structure0 {
                    pendingDecoded0?.append(structure0)
                }
            }
        }
        pending = pendingDecoded0
    }
}

public struct UntagInputBodyMiddleware: Middleware {
    public let id: String = "UntagInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagInput>
    public typealias MOutput = OperationOutput<UntagOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagOutputError>
}

extension UntagInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagInput(arn: \(String(describing: arn)), keys: \(String(describing: keys)))"}
}

extension UntagInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case keys = "Keys"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let keys = keys {
            var keysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .keys)
            for tagkeylist0 in keys {
                try keysContainer.encode(tagkeylist0)
            }
        }
    }
}

public struct UntagInputHeadersMiddleware: Middleware {
    public let id: String = "UntagInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagInput>
    public typealias MOutput = OperationOutput<UntagOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagOutputError>
}

public struct UntagInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagInput>
    public typealias MOutput = OperationOutput<UntagOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagOutputError>
}

public struct UntagInput: Equatable {
    /// <p>The ARN of the resource group from which to remove tags. The command removed both the
    ///             specified keys and any values associated with those keys.</p>
    public let arn: String?
    /// <p>The keys of the tags to be removed.</p>
    public let keys: [String]?

    public init (
        arn: String? = nil,
        keys: [String]? = nil
    )
    {
        self.arn = arn
        self.keys = keys
    }
}

struct UntagInputBody: Equatable {
    public let keys: [String]?
}

extension UntagInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case keys = "Keys"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keysContainer = try containerValues.decodeIfPresent([String?].self, forKey: .keys)
        var keysDecoded0:[String]? = nil
        if let keysContainer = keysContainer {
            keysDecoded0 = [String]()
            for string0 in keysContainer {
                if let string0 = string0 {
                    keysDecoded0?.append(string0)
                }
            }
        }
        keys = keysDecoded0
    }
}

extension UntagOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case methodNotAllowedException(MethodNotAllowedException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagOutputResponse(arn: \(String(describing: arn)), keys: \(String(describing: keys)))"}
}

extension UntagOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UntagOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.keys = output.keys
        } else {
            self.arn = nil
            self.keys = nil
        }
    }
}

public struct UntagOutputResponse: Equatable {
    /// <p>The ARN of the resource group from which tags have been removed.</p>
    public let arn: String?
    /// <p>The keys of the tags that were removed.</p>
    public let keys: [String]?

    public init (
        arn: String? = nil,
        keys: [String]? = nil
    )
    {
        self.arn = arn
        self.keys = keys
    }
}

struct UntagOutputResponseBody: Equatable {
    public let arn: String?
    public let keys: [String]?
}

extension UntagOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case keys = "Keys"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let keysContainer = try containerValues.decodeIfPresent([String?].self, forKey: .keys)
        var keysDecoded0:[String]? = nil
        if let keysContainer = keysContainer {
            keysDecoded0 = [String]()
            for string0 in keysContainer {
                if let string0 = string0 {
                    keysDecoded0?.append(string0)
                }
            }
        }
        keys = keysDecoded0
    }
}

public struct UpdateGroupInputBodyMiddleware: Middleware {
    public let id: String = "UpdateGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateGroupInput>
    public typealias MOutput = OperationOutput<UpdateGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateGroupOutputError>
}

extension UpdateGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateGroupInput(description: \(String(describing: description)), group: \(String(describing: group)), groupName: \(String(describing: groupName)))"}
}

extension UpdateGroupInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case group = "Group"
        case groupName = "GroupName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let group = group {
            try encodeContainer.encode(group, forKey: .group)
        }
        if let groupName = groupName {
            try encodeContainer.encode(groupName, forKey: .groupName)
        }
    }
}

public struct UpdateGroupInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateGroupInput>
    public typealias MOutput = OperationOutput<UpdateGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateGroupOutputError>
}

public struct UpdateGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateGroupInput>
    public typealias MOutput = OperationOutput<UpdateGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateGroupOutputError>
}

public struct UpdateGroupInput: Equatable {
    /// <p>The new description that you want to update the resource group with. Descriptions can
    ///             contain letters, numbers, hyphens, underscores, periods, and spaces.</p>
    public let description: String?
    /// <p>The name or the ARN of the resource group to modify.</p>
    public let group: String?
    /// <p>Don't use this parameter. Use <code>Group</code> instead.</p>
    @available(*, deprecated, message: "This field is deprecated, use Group instead.")
    public let groupName: String?

    public init (
        description: String? = nil,
        group: String? = nil,
        groupName: String? = nil
    )
    {
        self.description = description
        self.group = group
        self.groupName = groupName
    }
}

struct UpdateGroupInputBody: Equatable {
    public let groupName: String?
    public let group: String?
    public let description: String?
}

extension UpdateGroupInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case group = "Group"
        case groupName = "GroupName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .groupName)
        groupName = groupNameDecoded
        let groupDecoded = try containerValues.decodeIfPresent(String.self, forKey: .group)
        group = groupDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateGroupOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case methodNotAllowedException(MethodNotAllowedException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateGroupOutputResponse(group: \(String(describing: group)))"}
}

extension UpdateGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateGroupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.group = output.group
        } else {
            self.group = nil
        }
    }
}

public struct UpdateGroupOutputResponse: Equatable {
    /// <p>The update description of the resource group.</p>
    public let group: Group?

    public init (
        group: Group? = nil
    )
    {
        self.group = group
    }
}

struct UpdateGroupOutputResponseBody: Equatable {
    public let group: Group?
}

extension UpdateGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case group = "Group"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupDecoded = try containerValues.decodeIfPresent(Group.self, forKey: .group)
        group = groupDecoded
    }
}

public struct UpdateGroupQueryInputBodyMiddleware: Middleware {
    public let id: String = "UpdateGroupQueryInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateGroupQueryInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateGroupQueryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateGroupQueryInput>
    public typealias MOutput = OperationOutput<UpdateGroupQueryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateGroupQueryOutputError>
}

extension UpdateGroupQueryInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateGroupQueryInput(group: \(String(describing: group)), groupName: \(String(describing: groupName)), resourceQuery: \(String(describing: resourceQuery)))"}
}

extension UpdateGroupQueryInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case group = "Group"
        case groupName = "GroupName"
        case resourceQuery = "ResourceQuery"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let group = group {
            try encodeContainer.encode(group, forKey: .group)
        }
        if let groupName = groupName {
            try encodeContainer.encode(groupName, forKey: .groupName)
        }
        if let resourceQuery = resourceQuery {
            try encodeContainer.encode(resourceQuery, forKey: .resourceQuery)
        }
    }
}

public struct UpdateGroupQueryInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateGroupQueryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateGroupQueryInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateGroupQueryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateGroupQueryInput>
    public typealias MOutput = OperationOutput<UpdateGroupQueryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateGroupQueryOutputError>
}

public struct UpdateGroupQueryInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateGroupQueryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateGroupQueryInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateGroupQueryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateGroupQueryInput>
    public typealias MOutput = OperationOutput<UpdateGroupQueryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateGroupQueryOutputError>
}

public struct UpdateGroupQueryInput: Equatable {
    /// <p>The name or the ARN of the resource group to query.</p>
    public let group: String?
    /// <p>Don't use this parameter. Use <code>Group</code> instead.</p>
    @available(*, deprecated, message: "This field is deprecated, use Group instead.")
    public let groupName: String?
    /// <p>The resource query to determine which AWS resources are members of this resource
    ///             group.</p>
    ///         <note>
    ///             <p>A resource group can contain either a <code>Configuration</code> or a
    ///                     <code>ResourceQuery</code>, but not both.</p>
    ///         </note>
    public let resourceQuery: ResourceQuery?

    public init (
        group: String? = nil,
        groupName: String? = nil,
        resourceQuery: ResourceQuery? = nil
    )
    {
        self.group = group
        self.groupName = groupName
        self.resourceQuery = resourceQuery
    }
}

struct UpdateGroupQueryInputBody: Equatable {
    public let groupName: String?
    public let group: String?
    public let resourceQuery: ResourceQuery?
}

extension UpdateGroupQueryInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case group = "Group"
        case groupName = "GroupName"
        case resourceQuery = "ResourceQuery"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .groupName)
        groupName = groupNameDecoded
        let groupDecoded = try containerValues.decodeIfPresent(String.self, forKey: .group)
        group = groupDecoded
        let resourceQueryDecoded = try containerValues.decodeIfPresent(ResourceQuery.self, forKey: .resourceQuery)
        resourceQuery = resourceQueryDecoded
    }
}

extension UpdateGroupQueryOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateGroupQueryOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateGroupQueryOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case methodNotAllowedException(MethodNotAllowedException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateGroupQueryOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateGroupQueryOutputResponse(groupQuery: \(String(describing: groupQuery)))"}
}

extension UpdateGroupQueryOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateGroupQueryOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.groupQuery = output.groupQuery
        } else {
            self.groupQuery = nil
        }
    }
}

public struct UpdateGroupQueryOutputResponse: Equatable {
    /// <p>The updated resource query associated with the resource group after the update.</p>
    public let groupQuery: GroupQuery?

    public init (
        groupQuery: GroupQuery? = nil
    )
    {
        self.groupQuery = groupQuery
    }
}

struct UpdateGroupQueryOutputResponseBody: Equatable {
    public let groupQuery: GroupQuery?
}

extension UpdateGroupQueryOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case groupQuery = "GroupQuery"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupQueryDecoded = try containerValues.decodeIfPresent(GroupQuery.self, forKey: .groupQuery)
        groupQuery = groupQueryDecoded
    }
}
