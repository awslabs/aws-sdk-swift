// Code generated by smithy-swift-codegen. DO NOT EDIT!

import AWSClientRuntime
import ClientRuntime
import Foundation

public class EcsClient {
    let client: SdkHttpClient
    let config: EcsClientConfiguration
    let serviceName = "ECS"
    let encoder: RequestEncoder
    let decoder: ResponseDecoder

    public init(config: EcsClientConfiguration) {
        client = SdkHttpClient(engine: config.httpClientEngine, config: config.httpClientConfiguration)
        let encoder = JSONEncoder()
        encoder.dateEncodingStrategy = .secondsSince1970
        self.encoder = config.encoder ?? encoder
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .secondsSince1970
        self.decoder = config.decoder ?? decoder
        self.config = config
    }

    public class EcsClientConfiguration: ClientRuntime.Configuration, AWSClientConfiguration {

        public var region: String
        public var credentialsProvider: AWSCredentialsProvider
        public var signingRegion: String
        public var endpointResolver: EndpointResolver

        public init (
            credentialsProvider: AWSCredentialsProvider,
            endpointResolver: EndpointResolver,
            region: String,
            signingRegion: String
        ) throws
        {
            self.credentialsProvider = credentialsProvider
            self.endpointResolver = endpointResolver
            self.region = region
            self.signingRegion = signingRegion
        }

        public convenience init(credentialsProvider: AWSCredentialsProvider) throws {
            let region = "us-east-1"
            let signingRegion = "us-east-1"
            let endpointResolver = DefaultEndpointResolver()
            try self.init(
                credentialsProvider: credentialsProvider,
                endpointResolver: endpointResolver,
                region: region,
                signingRegion: signingRegion
            )
        }

        public static func `default`() throws -> EcsClientConfiguration {
            let awsCredsProvider = try AWSCredentialsProvider.fromEnv()
            return try EcsClientConfiguration(credentialsProvider: awsCredsProvider)
        }
    }
}

extension EcsClient: EcsClientProtocol {
    /// <p>Creates a new capacity provider. Capacity providers are associated with an Amazon ECS
    /// 			cluster and are used in capacity provider strategies to facilitate cluster auto
    /// 			scaling.</p>
    /// 		       <p>Only capacity providers using an Auto Scaling group can be created. Amazon ECS tasks on
    /// 			AWS Fargate use the <code>FARGATE</code> and <code>FARGATE_SPOT</code> capacity providers
    /// 			which are already created and available to all accounts in Regions supported by
    /// 			AWS Fargate.</p>
    public func createCapacityProvider(input: CreateCapacityProviderInput, completion: @escaping (SdkResult<CreateCapacityProviderOutput, CreateCapacityProviderOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createCapacityProvider")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "ecs.\(config.region).amazonaws.com")
                      .withSigningName(value: "ecs")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateCapacityProviderInput, CreateCapacityProviderOutput, CreateCapacityProviderOutputError>(id: "createCapacityProvider")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateCapacityProviderInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateCapacityProviderInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateCapacityProviderInput, CreateCapacityProviderOutput, CreateCapacityProviderOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: CreateCapacityProviderInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<CreateCapacityProviderInput, CreateCapacityProviderOutput, CreateCapacityProviderOutputError>(xAmzTarget: "AmazonEC2ContainerServiceV20141113.CreateCapacityProvider"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates a new Amazon ECS cluster. By default, your account receives a <code>default</code>
    /// 			cluster when you launch your first container instance. However, you can create your own
    /// 			cluster with a unique name with the <code>CreateCluster</code> action.</p>
    /// 		       <note>
    /// 			         <p>When you call the <a>CreateCluster</a> API operation, Amazon ECS attempts to
    /// 				create the Amazon ECS service-linked role for your account so that required resources in
    /// 				other AWS services can be managed on your behalf. However, if the IAM user that
    /// 				makes the call does not have permissions to create the service-linked role, it is
    /// 				not created. For more information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/using-service-linked-roles.html">Using
    /// 					Service-Linked Roles for Amazon ECS</a> in the
    /// 					<i>Amazon Elastic Container Service Developer Guide</i>.</p>
    /// 		       </note>
    public func createCluster(input: CreateClusterInput, completion: @escaping (SdkResult<CreateClusterOutput, CreateClusterOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createCluster")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "ecs.\(config.region).amazonaws.com")
                      .withSigningName(value: "ecs")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateClusterInput, CreateClusterOutput, CreateClusterOutputError>(id: "createCluster")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateClusterInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateClusterInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateClusterInput, CreateClusterOutput, CreateClusterOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: CreateClusterInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<CreateClusterInput, CreateClusterOutput, CreateClusterOutputError>(xAmzTarget: "AmazonEC2ContainerServiceV20141113.CreateCluster"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Runs and maintains a desired number of tasks from a specified task definition. If the
    /// 			number of tasks running in a service drops below the <code>desiredCount</code>, Amazon ECS
    /// 			runs another copy of the task in the specified cluster. To update an existing service,
    /// 			see the UpdateService action.</p>
    /// 		       <p>In addition to maintaining the desired count of tasks in your service, you can
    /// 			optionally run your service behind one or more load balancers. The load balancers
    /// 			distribute traffic across the tasks that are associated with the service. For more
    /// 			information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/service-load-balancing.html">Service Load Balancing</a> in the
    /// 				<i>Amazon Elastic Container Service Developer Guide</i>.</p>
    /// 		       <p>Tasks for services that <i>do not</i> use a load balancer are considered
    /// 			healthy if they're in the <code>RUNNING</code> state. Tasks for services that
    /// 				<i>do</i> use a load balancer are considered healthy if they're in the
    /// 				<code>RUNNING</code> state and the container instance that they're hosted on is
    /// 			reported as healthy by the load balancer.</p>
    /// 		       <p>There are two service scheduler strategies available:</p>
    /// 		       <ul>
    ///             <li>
    /// 				           <p>
    ///                   <code>REPLICA</code> - The replica scheduling strategy places and
    /// 					maintains the desired number of tasks across your cluster. By default, the
    /// 					service scheduler spreads tasks across Availability Zones. You can use task
    /// 					placement strategies and constraints to customize task placement decisions. For
    /// 					more information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs_services.html">Service Scheduler Concepts</a> in the
    /// 						<i>Amazon Elastic Container Service Developer Guide</i>.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>
    ///                   <code>DAEMON</code> - The daemon scheduling strategy deploys exactly one
    /// 					task on each active container instance that meets all of the task placement
    /// 					constraints that you specify in your cluster. The service scheduler also
    /// 					evaluates the task placement constraints for running tasks and will stop tasks
    /// 					that do not meet the placement constraints. When using this strategy, you don't
    /// 					need to specify a desired number of tasks, a task placement strategy, or use
    /// 					Service Auto Scaling policies. For more information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs_services.html">Service Scheduler Concepts</a> in the
    /// 						<i>Amazon Elastic Container Service Developer Guide</i>.</p>
    /// 			         </li>
    ///          </ul>
    /// 		       <p>You can optionally specify a deployment configuration for your service. The deployment
    /// 			is triggered by changing properties, such as the task definition or the desired count of
    /// 			a service, with an <a>UpdateService</a> operation. The default value for a
    /// 			replica service for <code>minimumHealthyPercent</code> is 100%. The default value for a
    /// 			daemon service for <code>minimumHealthyPercent</code> is 0%.</p>
    /// 		       <p>If a service is using the <code>ECS</code> deployment controller, the minimum healthy
    /// 			percent represents a lower limit on the number of tasks in a service that must remain in
    /// 			the <code>RUNNING</code> state during a deployment, as a percentage of the desired
    /// 			number of tasks (rounded up to the nearest integer), and while any container instances
    /// 			are in the <code>DRAINING</code> state if the service contains tasks using the
    /// 			EC2 launch type. This parameter enables you to deploy without using
    /// 			additional cluster capacity. For example, if your service has a desired number of four
    /// 			tasks and a minimum healthy percent of 50%, the scheduler might stop two existing tasks
    /// 			to free up cluster capacity before starting two new tasks. Tasks for services that
    /// 				<i>do not</i> use a load balancer are considered healthy if they're in
    /// 			the <code>RUNNING</code> state. Tasks for services that <i>do</i> use a
    /// 			load balancer are considered healthy if they're in the <code>RUNNING</code> state and
    /// 			they're reported as healthy by the load balancer. The default value for minimum healthy
    /// 			percent is 100%.</p>
    /// 		       <p>If a service is using the <code>ECS</code> deployment controller, the <b>maximum percent</b> parameter represents an upper limit on the
    /// 			number of tasks in a service that are allowed in the <code>RUNNING</code> or
    /// 				<code>PENDING</code> state during a deployment, as a percentage of the desired
    /// 			number of tasks (rounded down to the nearest integer), and while any container instances
    /// 			are in the <code>DRAINING</code> state if the service contains tasks using the
    /// 			EC2 launch type. This parameter enables you to define the deployment batch
    /// 			size. For example, if your service has a desired number of four tasks and a maximum
    /// 			percent value of 200%, the scheduler may start four new tasks before stopping the four
    /// 			older tasks (provided that the cluster resources required to do this are available). The
    /// 			default value for maximum percent is 200%.</p>
    /// 		       <p>If a service is using either the <code>CODE_DEPLOY</code> or <code>EXTERNAL</code>
    /// 			deployment controller types and tasks that use the EC2 launch type, the
    /// 				<b>minimum healthy percent</b> and <b>maximum percent</b> values are used only to define the lower and upper limit
    /// 			on the number of the tasks in the service that remain in the <code>RUNNING</code> state
    /// 			while the container instances are in the <code>DRAINING</code> state. If the tasks in
    /// 			the service use the Fargate launch type, the minimum healthy percent and
    /// 			maximum percent values aren't used, although they're currently visible when describing
    /// 			your service.</p>
    /// 		       <p>When creating a service that uses the <code>EXTERNAL</code> deployment controller, you
    /// 			can specify only parameters that aren't controlled at the task set level. The only
    /// 			required parameter is the service name. You control your services using the <a>CreateTaskSet</a> operation. For more information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/deployment-types.html">Amazon ECS Deployment Types</a> in the <i>Amazon Elastic Container Service Developer Guide</i>.</p>
    /// 		       <p>When the service scheduler launches new tasks, it determines task placement in your
    /// 			cluster using the following logic:</p>
    /// 		       <ul>
    ///             <li>
    /// 				           <p>Determine which of the container instances in your cluster can support your
    /// 					service's task definition (for example, they have the required CPU, memory,
    /// 					ports, and container instance attributes).</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>By default, the service scheduler attempts to balance tasks across
    /// 					Availability Zones in this manner (although you can choose a different placement
    /// 					strategy) with the <code>placementStrategy</code> parameter):</p>
    /// 				           <ul>
    ///                   <li>
    /// 						               <p>Sort the valid container instances, giving priority to instances that
    /// 							have the fewest number of running tasks for this service in their
    /// 							respective Availability Zone. For example, if zone A has one running
    /// 							service task and zones B and C each have zero, valid container instances
    /// 							in either zone B or C are considered optimal for placement.</p>
    /// 					             </li>
    ///                   <li>
    /// 						               <p>Place the new service task on a valid container instance in an optimal
    /// 							Availability Zone (based on the previous steps), favoring container
    /// 							instances with the fewest number of running tasks for this
    /// 							service.</p>
    /// 					             </li>
    ///                </ul>
    /// 			         </li>
    ///          </ul>
    public func createService(input: CreateServiceInput, completion: @escaping (SdkResult<CreateServiceOutput, CreateServiceOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createService")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "ecs.\(config.region).amazonaws.com")
                      .withSigningName(value: "ecs")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateServiceInput, CreateServiceOutput, CreateServiceOutputError>(id: "createService")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateServiceInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateServiceInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateServiceInput, CreateServiceOutput, CreateServiceOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: CreateServiceInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<CreateServiceInput, CreateServiceOutput, CreateServiceOutputError>(xAmzTarget: "AmazonEC2ContainerServiceV20141113.CreateService"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Create a task set in the specified cluster and service. This is used when a service
    /// 			uses the <code>EXTERNAL</code> deployment controller type. For more information, see
    /// 				<a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/deployment-types.html">Amazon ECS Deployment
    /// 				Types</a> in the <i>Amazon Elastic Container Service Developer Guide</i>.</p>
    public func createTaskSet(input: CreateTaskSetInput, completion: @escaping (SdkResult<CreateTaskSetOutput, CreateTaskSetOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createTaskSet")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "ecs.\(config.region).amazonaws.com")
                      .withSigningName(value: "ecs")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateTaskSetInput, CreateTaskSetOutput, CreateTaskSetOutputError>(id: "createTaskSet")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateTaskSetInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateTaskSetInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateTaskSetInput, CreateTaskSetOutput, CreateTaskSetOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: CreateTaskSetInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<CreateTaskSetInput, CreateTaskSetOutput, CreateTaskSetOutputError>(xAmzTarget: "AmazonEC2ContainerServiceV20141113.CreateTaskSet"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Disables an account setting for a specified IAM user, IAM role, or the root user for
    /// 			an account.</p>
    public func deleteAccountSetting(input: DeleteAccountSettingInput, completion: @escaping (SdkResult<DeleteAccountSettingOutput, DeleteAccountSettingOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteAccountSetting")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "ecs.\(config.region).amazonaws.com")
                      .withSigningName(value: "ecs")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteAccountSettingInput, DeleteAccountSettingOutput, DeleteAccountSettingOutputError>(id: "deleteAccountSetting")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteAccountSettingInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteAccountSettingInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteAccountSettingInput, DeleteAccountSettingOutput, DeleteAccountSettingOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: DeleteAccountSettingInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<DeleteAccountSettingInput, DeleteAccountSettingOutput, DeleteAccountSettingOutputError>(xAmzTarget: "AmazonEC2ContainerServiceV20141113.DeleteAccountSetting"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes one or more custom attributes from an Amazon ECS resource.</p>
    public func deleteAttributes(input: DeleteAttributesInput, completion: @escaping (SdkResult<DeleteAttributesOutput, DeleteAttributesOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteAttributes")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "ecs.\(config.region).amazonaws.com")
                      .withSigningName(value: "ecs")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteAttributesInput, DeleteAttributesOutput, DeleteAttributesOutputError>(id: "deleteAttributes")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteAttributesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteAttributesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteAttributesInput, DeleteAttributesOutput, DeleteAttributesOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: DeleteAttributesInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<DeleteAttributesInput, DeleteAttributesOutput, DeleteAttributesOutputError>(xAmzTarget: "AmazonEC2ContainerServiceV20141113.DeleteAttributes"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes the specified capacity provider.</p>
    /// 		       <note>
    /// 			         <p>The <code>FARGATE</code> and <code>FARGATE_SPOT</code> capacity providers are
    /// 				reserved and cannot be deleted. You can disassociate them from a cluster using
    /// 				either the <a>PutClusterCapacityProviders</a> API or by deleting the
    /// 				cluster.</p>
    /// 		       </note>
    /// 		       <p>Prior to a capacity provider being deleted, the capacity provider must be removed from
    /// 			the capacity provider strategy from all services. The <a>UpdateService</a>
    /// 			API can be used to remove a capacity provider from a service's capacity provider
    /// 			strategy. When updating a service, the <code>forceNewDeployment</code> option can be
    /// 			used to ensure that any tasks using the Amazon EC2 instance capacity provided by the capacity
    /// 			provider are transitioned to use the capacity from the remaining capacity providers.
    /// 			Only capacity providers that are not associated with a cluster can be deleted. To remove
    /// 			a capacity provider from a cluster, you can either use <a>PutClusterCapacityProviders</a> or delete the cluster.</p>
    public func deleteCapacityProvider(input: DeleteCapacityProviderInput, completion: @escaping (SdkResult<DeleteCapacityProviderOutput, DeleteCapacityProviderOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteCapacityProvider")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "ecs.\(config.region).amazonaws.com")
                      .withSigningName(value: "ecs")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteCapacityProviderInput, DeleteCapacityProviderOutput, DeleteCapacityProviderOutputError>(id: "deleteCapacityProvider")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteCapacityProviderInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteCapacityProviderInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteCapacityProviderInput, DeleteCapacityProviderOutput, DeleteCapacityProviderOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: DeleteCapacityProviderInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<DeleteCapacityProviderInput, DeleteCapacityProviderOutput, DeleteCapacityProviderOutputError>(xAmzTarget: "AmazonEC2ContainerServiceV20141113.DeleteCapacityProvider"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes the specified cluster. The cluster will transition to the
    /// 				<code>INACTIVE</code> state. Clusters with an <code>INACTIVE</code> status may
    /// 			remain discoverable in your account for a period of time. However, this behavior is
    /// 			subject to change in the future, so you should not rely on <code>INACTIVE</code>
    /// 			clusters persisting.</p>
    /// 		       <p>You must deregister all container instances from this cluster before you may delete
    /// 			it. You can list the container instances in a cluster with <a>ListContainerInstances</a> and deregister them with <a>DeregisterContainerInstance</a>.</p>
    public func deleteCluster(input: DeleteClusterInput, completion: @escaping (SdkResult<DeleteClusterOutput, DeleteClusterOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteCluster")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "ecs.\(config.region).amazonaws.com")
                      .withSigningName(value: "ecs")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteClusterInput, DeleteClusterOutput, DeleteClusterOutputError>(id: "deleteCluster")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteClusterInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteClusterInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteClusterInput, DeleteClusterOutput, DeleteClusterOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: DeleteClusterInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<DeleteClusterInput, DeleteClusterOutput, DeleteClusterOutputError>(xAmzTarget: "AmazonEC2ContainerServiceV20141113.DeleteCluster"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes a specified service within a cluster. You can delete a service if you have no
    /// 			running tasks in it and the desired task count is zero. If the service is actively
    /// 			maintaining tasks, you cannot delete it, and you must update the service to a desired
    /// 			task count of zero. For more information, see <a>UpdateService</a>.</p>
    /// 		       <note>
    /// 			         <p>When you delete a service, if there are still running tasks that require cleanup,
    /// 				the service status moves from <code>ACTIVE</code> to <code>DRAINING</code>, and the
    /// 				service is no longer visible in the console or in the <a>ListServices</a>
    /// 				API operation. After all tasks have transitioned to either <code>STOPPING</code> or
    /// 					<code>STOPPED</code> status, the service status moves from <code>DRAINING</code>
    /// 				to <code>INACTIVE</code>. Services in the <code>DRAINING</code> or
    /// 					<code>INACTIVE</code> status can still be viewed with the <a>DescribeServices</a> API operation. However, in the future,
    /// 					<code>INACTIVE</code> services may be cleaned up and purged from Amazon ECS record
    /// 				keeping, and <a>DescribeServices</a> calls on those services return a
    /// 					<code>ServiceNotFoundException</code> error.</p>
    /// 		       </note>
    /// 		       <important>
    /// 			         <p>If you attempt to create a new service with the same name as an existing service
    /// 				in either <code>ACTIVE</code> or <code>DRAINING</code> status, you receive an
    /// 				error.</p>
    /// 		       </important>
    public func deleteService(input: DeleteServiceInput, completion: @escaping (SdkResult<DeleteServiceOutput, DeleteServiceOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteService")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "ecs.\(config.region).amazonaws.com")
                      .withSigningName(value: "ecs")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteServiceInput, DeleteServiceOutput, DeleteServiceOutputError>(id: "deleteService")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteServiceInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteServiceInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteServiceInput, DeleteServiceOutput, DeleteServiceOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: DeleteServiceInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<DeleteServiceInput, DeleteServiceOutput, DeleteServiceOutputError>(xAmzTarget: "AmazonEC2ContainerServiceV20141113.DeleteService"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes a specified task set within a service. This is used when a service uses the
    /// 				<code>EXTERNAL</code> deployment controller type. For more information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/deployment-types.html">Amazon ECS Deployment Types</a> in the <i>Amazon Elastic Container Service Developer Guide</i>.</p>
    public func deleteTaskSet(input: DeleteTaskSetInput, completion: @escaping (SdkResult<DeleteTaskSetOutput, DeleteTaskSetOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteTaskSet")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "ecs.\(config.region).amazonaws.com")
                      .withSigningName(value: "ecs")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteTaskSetInput, DeleteTaskSetOutput, DeleteTaskSetOutputError>(id: "deleteTaskSet")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteTaskSetInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteTaskSetInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteTaskSetInput, DeleteTaskSetOutput, DeleteTaskSetOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: DeleteTaskSetInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<DeleteTaskSetInput, DeleteTaskSetOutput, DeleteTaskSetOutputError>(xAmzTarget: "AmazonEC2ContainerServiceV20141113.DeleteTaskSet"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deregisters an Amazon ECS container instance from the specified cluster. This instance is
    /// 			no longer available to run tasks.</p>
    /// 		       <p>If you intend to use the container instance for some other purpose after
    /// 			deregistration, you should stop all of the tasks running on the container instance
    /// 			before deregistration. That prevents any orphaned tasks from consuming resources.</p>
    /// 		       <p>Deregistering a container instance removes the instance from a cluster, but it does
    /// 			not terminate the EC2 instance. If you are finished using the instance, be sure to
    /// 			terminate it in the Amazon EC2 console to stop billing.</p>
    /// 		       <note>
    /// 			         <p>If you terminate a running container instance, Amazon ECS automatically deregisters the
    /// 				instance from your cluster (stopped container instances or instances with
    /// 				disconnected agents are not automatically deregistered when terminated).</p>
    /// 		       </note>
    public func deregisterContainerInstance(input: DeregisterContainerInstanceInput, completion: @escaping (SdkResult<DeregisterContainerInstanceOutput, DeregisterContainerInstanceOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deregisterContainerInstance")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "ecs.\(config.region).amazonaws.com")
                      .withSigningName(value: "ecs")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeregisterContainerInstanceInput, DeregisterContainerInstanceOutput, DeregisterContainerInstanceOutputError>(id: "deregisterContainerInstance")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeregisterContainerInstanceInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeregisterContainerInstanceInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeregisterContainerInstanceInput, DeregisterContainerInstanceOutput, DeregisterContainerInstanceOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: DeregisterContainerInstanceInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<DeregisterContainerInstanceInput, DeregisterContainerInstanceOutput, DeregisterContainerInstanceOutputError>(xAmzTarget: "AmazonEC2ContainerServiceV20141113.DeregisterContainerInstance"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deregisters the specified task definition by family and revision. Upon deregistration,
    /// 			the task definition is marked as <code>INACTIVE</code>. Existing tasks and services that
    /// 			reference an <code>INACTIVE</code> task definition continue to run without disruption.
    /// 			Existing services that reference an <code>INACTIVE</code> task definition can still
    /// 			scale up or down by modifying the service's desired count.</p>
    /// 		       <p>You cannot use an <code>INACTIVE</code> task definition to run new tasks or create new
    /// 			services, and you cannot update an existing service to reference an
    /// 				<code>INACTIVE</code> task definition. However, there may be up to a 10-minute
    /// 			window following deregistration where these restrictions have not yet taken
    /// 			effect.</p>
    /// 		       <note>
    /// 			         <p>At this time, <code>INACTIVE</code> task definitions remain discoverable in your
    /// 				account indefinitely. However, this behavior is subject to change in the future, so
    /// 				you should not rely on <code>INACTIVE</code> task definitions persisting beyond the
    /// 				lifecycle of any associated tasks and services.</p>
    /// 		       </note>
    public func deregisterTaskDefinition(input: DeregisterTaskDefinitionInput, completion: @escaping (SdkResult<DeregisterTaskDefinitionOutput, DeregisterTaskDefinitionOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deregisterTaskDefinition")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "ecs.\(config.region).amazonaws.com")
                      .withSigningName(value: "ecs")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeregisterTaskDefinitionInput, DeregisterTaskDefinitionOutput, DeregisterTaskDefinitionOutputError>(id: "deregisterTaskDefinition")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeregisterTaskDefinitionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeregisterTaskDefinitionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeregisterTaskDefinitionInput, DeregisterTaskDefinitionOutput, DeregisterTaskDefinitionOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: DeregisterTaskDefinitionInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<DeregisterTaskDefinitionInput, DeregisterTaskDefinitionOutput, DeregisterTaskDefinitionOutputError>(xAmzTarget: "AmazonEC2ContainerServiceV20141113.DeregisterTaskDefinition"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Describes one or more of your capacity providers.</p>
    public func describeCapacityProviders(input: DescribeCapacityProvidersInput, completion: @escaping (SdkResult<DescribeCapacityProvidersOutput, DescribeCapacityProvidersOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeCapacityProviders")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "ecs.\(config.region).amazonaws.com")
                      .withSigningName(value: "ecs")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeCapacityProvidersInput, DescribeCapacityProvidersOutput, DescribeCapacityProvidersOutputError>(id: "describeCapacityProviders")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeCapacityProvidersInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeCapacityProvidersInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeCapacityProvidersInput, DescribeCapacityProvidersOutput, DescribeCapacityProvidersOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: DescribeCapacityProvidersInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<DescribeCapacityProvidersInput, DescribeCapacityProvidersOutput, DescribeCapacityProvidersOutputError>(xAmzTarget: "AmazonEC2ContainerServiceV20141113.DescribeCapacityProviders"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Describes one or more of your clusters.</p>
    public func describeClusters(input: DescribeClustersInput, completion: @escaping (SdkResult<DescribeClustersOutput, DescribeClustersOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeClusters")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "ecs.\(config.region).amazonaws.com")
                      .withSigningName(value: "ecs")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeClustersInput, DescribeClustersOutput, DescribeClustersOutputError>(id: "describeClusters")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeClustersInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeClustersInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeClustersInput, DescribeClustersOutput, DescribeClustersOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: DescribeClustersInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<DescribeClustersInput, DescribeClustersOutput, DescribeClustersOutputError>(xAmzTarget: "AmazonEC2ContainerServiceV20141113.DescribeClusters"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Describes one or more container instances. Returns metadata about each container
    /// 			instance requested.</p>
    public func describeContainerInstances(input: DescribeContainerInstancesInput, completion: @escaping (SdkResult<DescribeContainerInstancesOutput, DescribeContainerInstancesOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeContainerInstances")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "ecs.\(config.region).amazonaws.com")
                      .withSigningName(value: "ecs")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeContainerInstancesInput, DescribeContainerInstancesOutput, DescribeContainerInstancesOutputError>(id: "describeContainerInstances")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeContainerInstancesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeContainerInstancesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeContainerInstancesInput, DescribeContainerInstancesOutput, DescribeContainerInstancesOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: DescribeContainerInstancesInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<DescribeContainerInstancesInput, DescribeContainerInstancesOutput, DescribeContainerInstancesOutputError>(xAmzTarget: "AmazonEC2ContainerServiceV20141113.DescribeContainerInstances"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Describes the specified services running in your cluster.</p>
    public func describeServices(input: DescribeServicesInput, completion: @escaping (SdkResult<DescribeServicesOutput, DescribeServicesOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeServices")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "ecs.\(config.region).amazonaws.com")
                      .withSigningName(value: "ecs")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeServicesInput, DescribeServicesOutput, DescribeServicesOutputError>(id: "describeServices")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeServicesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeServicesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeServicesInput, DescribeServicesOutput, DescribeServicesOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: DescribeServicesInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<DescribeServicesInput, DescribeServicesOutput, DescribeServicesOutputError>(xAmzTarget: "AmazonEC2ContainerServiceV20141113.DescribeServices"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Describes a task definition. You can specify a <code>family</code> and
    /// 				<code>revision</code> to find information about a specific task definition, or you
    /// 			can simply specify the family to find the latest <code>ACTIVE</code> revision in that
    /// 			family.</p>
    /// 		       <note>
    /// 			         <p>You can only describe <code>INACTIVE</code> task definitions while an active task
    /// 				or service references them.</p>
    /// 		       </note>
    public func describeTaskDefinition(input: DescribeTaskDefinitionInput, completion: @escaping (SdkResult<DescribeTaskDefinitionOutput, DescribeTaskDefinitionOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeTaskDefinition")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "ecs.\(config.region).amazonaws.com")
                      .withSigningName(value: "ecs")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeTaskDefinitionInput, DescribeTaskDefinitionOutput, DescribeTaskDefinitionOutputError>(id: "describeTaskDefinition")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeTaskDefinitionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeTaskDefinitionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeTaskDefinitionInput, DescribeTaskDefinitionOutput, DescribeTaskDefinitionOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: DescribeTaskDefinitionInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<DescribeTaskDefinitionInput, DescribeTaskDefinitionOutput, DescribeTaskDefinitionOutputError>(xAmzTarget: "AmazonEC2ContainerServiceV20141113.DescribeTaskDefinition"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Describes the task sets in the specified cluster and service. This is used when a
    /// 			service uses the <code>EXTERNAL</code> deployment controller type. For more information,
    /// 			see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/deployment-types.html">Amazon ECS Deployment
    /// 				Types</a> in the <i>Amazon Elastic Container Service Developer Guide</i>.</p>
    public func describeTaskSets(input: DescribeTaskSetsInput, completion: @escaping (SdkResult<DescribeTaskSetsOutput, DescribeTaskSetsOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeTaskSets")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "ecs.\(config.region).amazonaws.com")
                      .withSigningName(value: "ecs")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeTaskSetsInput, DescribeTaskSetsOutput, DescribeTaskSetsOutputError>(id: "describeTaskSets")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeTaskSetsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeTaskSetsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeTaskSetsInput, DescribeTaskSetsOutput, DescribeTaskSetsOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: DescribeTaskSetsInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<DescribeTaskSetsInput, DescribeTaskSetsOutput, DescribeTaskSetsOutputError>(xAmzTarget: "AmazonEC2ContainerServiceV20141113.DescribeTaskSets"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Describes a specified task or tasks.</p>
    public func describeTasks(input: DescribeTasksInput, completion: @escaping (SdkResult<DescribeTasksOutput, DescribeTasksOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeTasks")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "ecs.\(config.region).amazonaws.com")
                      .withSigningName(value: "ecs")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeTasksInput, DescribeTasksOutput, DescribeTasksOutputError>(id: "describeTasks")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeTasksInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeTasksInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeTasksInput, DescribeTasksOutput, DescribeTasksOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: DescribeTasksInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<DescribeTasksInput, DescribeTasksOutput, DescribeTasksOutputError>(xAmzTarget: "AmazonEC2ContainerServiceV20141113.DescribeTasks"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <note>
    ///             <p>This action is only used by the Amazon ECS agent, and it is not intended for use outside of the agent.</p>
    ///          </note>
    ///          <p>Returns an endpoint for
    /// 			the Amazon ECS agent to poll for updates.</p>
    public func discoverPollEndpoint(input: DiscoverPollEndpointInput, completion: @escaping (SdkResult<DiscoverPollEndpointOutput, DiscoverPollEndpointOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "discoverPollEndpoint")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "ecs.\(config.region).amazonaws.com")
                      .withSigningName(value: "ecs")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DiscoverPollEndpointInput, DiscoverPollEndpointOutput, DiscoverPollEndpointOutputError>(id: "discoverPollEndpoint")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DiscoverPollEndpointInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DiscoverPollEndpointInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DiscoverPollEndpointInput, DiscoverPollEndpointOutput, DiscoverPollEndpointOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: DiscoverPollEndpointInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<DiscoverPollEndpointInput, DiscoverPollEndpointOutput, DiscoverPollEndpointOutputError>(xAmzTarget: "AmazonEC2ContainerServiceV20141113.DiscoverPollEndpoint"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Runs a command remotely on a container within a task.</p>
    public func executeCommand(input: ExecuteCommandInput, completion: @escaping (SdkResult<ExecuteCommandOutput, ExecuteCommandOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "executeCommand")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "ecs.\(config.region).amazonaws.com")
                      .withSigningName(value: "ecs")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ExecuteCommandInput, ExecuteCommandOutput, ExecuteCommandOutputError>(id: "executeCommand")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ExecuteCommandInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ExecuteCommandInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ExecuteCommandInput, ExecuteCommandOutput, ExecuteCommandOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: ExecuteCommandInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<ExecuteCommandInput, ExecuteCommandOutput, ExecuteCommandOutputError>(xAmzTarget: "AmazonEC2ContainerServiceV20141113.ExecuteCommand"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Lists the account settings for a specified principal.</p>
    public func listAccountSettings(input: ListAccountSettingsInput, completion: @escaping (SdkResult<ListAccountSettingsOutput, ListAccountSettingsOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listAccountSettings")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "ecs.\(config.region).amazonaws.com")
                      .withSigningName(value: "ecs")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListAccountSettingsInput, ListAccountSettingsOutput, ListAccountSettingsOutputError>(id: "listAccountSettings")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListAccountSettingsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListAccountSettingsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListAccountSettingsInput, ListAccountSettingsOutput, ListAccountSettingsOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: ListAccountSettingsInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<ListAccountSettingsInput, ListAccountSettingsOutput, ListAccountSettingsOutputError>(xAmzTarget: "AmazonEC2ContainerServiceV20141113.ListAccountSettings"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Lists the attributes for Amazon ECS resources within a specified target type and cluster.
    /// 			When you specify a target type and cluster, <code>ListAttributes</code> returns a list
    /// 			of attribute objects, one for each attribute on each resource. You can filter the list
    /// 			of results to a single attribute name to only return results that have that name. You
    /// 			can also filter the results by attribute name and value, for example, to see which
    /// 			container instances in a cluster are running a Linux AMI
    /// 			(<code>ecs.os-type=linux</code>). </p>
    public func listAttributes(input: ListAttributesInput, completion: @escaping (SdkResult<ListAttributesOutput, ListAttributesOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listAttributes")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "ecs.\(config.region).amazonaws.com")
                      .withSigningName(value: "ecs")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListAttributesInput, ListAttributesOutput, ListAttributesOutputError>(id: "listAttributes")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListAttributesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListAttributesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListAttributesInput, ListAttributesOutput, ListAttributesOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: ListAttributesInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<ListAttributesInput, ListAttributesOutput, ListAttributesOutputError>(xAmzTarget: "AmazonEC2ContainerServiceV20141113.ListAttributes"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns a list of existing clusters.</p>
    public func listClusters(input: ListClustersInput, completion: @escaping (SdkResult<ListClustersOutput, ListClustersOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listClusters")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "ecs.\(config.region).amazonaws.com")
                      .withSigningName(value: "ecs")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListClustersInput, ListClustersOutput, ListClustersOutputError>(id: "listClusters")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListClustersInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListClustersInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListClustersInput, ListClustersOutput, ListClustersOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: ListClustersInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<ListClustersInput, ListClustersOutput, ListClustersOutputError>(xAmzTarget: "AmazonEC2ContainerServiceV20141113.ListClusters"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns a list of container instances in a specified cluster. You can filter the
    /// 			results of a <code>ListContainerInstances</code> operation with cluster query language
    /// 			statements inside the <code>filter</code> parameter. For more information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/cluster-query-language.html">Cluster Query Language</a> in the
    /// 				<i>Amazon Elastic Container Service Developer Guide</i>.</p>
    public func listContainerInstances(input: ListContainerInstancesInput, completion: @escaping (SdkResult<ListContainerInstancesOutput, ListContainerInstancesOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listContainerInstances")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "ecs.\(config.region).amazonaws.com")
                      .withSigningName(value: "ecs")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListContainerInstancesInput, ListContainerInstancesOutput, ListContainerInstancesOutputError>(id: "listContainerInstances")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListContainerInstancesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListContainerInstancesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListContainerInstancesInput, ListContainerInstancesOutput, ListContainerInstancesOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: ListContainerInstancesInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<ListContainerInstancesInput, ListContainerInstancesOutput, ListContainerInstancesOutputError>(xAmzTarget: "AmazonEC2ContainerServiceV20141113.ListContainerInstances"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns a list of services. You can filter the results by cluster, launch type, and
    /// 			scheduling strategy.</p>
    public func listServices(input: ListServicesInput, completion: @escaping (SdkResult<ListServicesOutput, ListServicesOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listServices")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "ecs.\(config.region).amazonaws.com")
                      .withSigningName(value: "ecs")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListServicesInput, ListServicesOutput, ListServicesOutputError>(id: "listServices")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListServicesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListServicesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListServicesInput, ListServicesOutput, ListServicesOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: ListServicesInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<ListServicesInput, ListServicesOutput, ListServicesOutputError>(xAmzTarget: "AmazonEC2ContainerServiceV20141113.ListServices"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>List the tags for an Amazon ECS resource.</p>
    public func listTagsForResource(input: ListTagsForResourceInput, completion: @escaping (SdkResult<ListTagsForResourceOutput, ListTagsForResourceOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listTagsForResource")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "ecs.\(config.region).amazonaws.com")
                      .withSigningName(value: "ecs")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListTagsForResourceInput, ListTagsForResourceOutput, ListTagsForResourceOutputError>(id: "listTagsForResource")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListTagsForResourceInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListTagsForResourceInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListTagsForResourceInput, ListTagsForResourceOutput, ListTagsForResourceOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: ListTagsForResourceInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<ListTagsForResourceInput, ListTagsForResourceOutput, ListTagsForResourceOutputError>(xAmzTarget: "AmazonEC2ContainerServiceV20141113.ListTagsForResource"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns a list of task definition families that are registered to your account (which
    /// 			may include task definition families that no longer have any <code>ACTIVE</code> task
    /// 			definition revisions).</p>
    /// 		       <p>You can filter out task definition families that do not contain any
    /// 				<code>ACTIVE</code> task definition revisions by setting the <code>status</code>
    /// 			parameter to <code>ACTIVE</code>. You can also filter the results with the
    /// 				<code>familyPrefix</code> parameter.</p>
    public func listTaskDefinitionFamilies(input: ListTaskDefinitionFamiliesInput, completion: @escaping (SdkResult<ListTaskDefinitionFamiliesOutput, ListTaskDefinitionFamiliesOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listTaskDefinitionFamilies")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "ecs.\(config.region).amazonaws.com")
                      .withSigningName(value: "ecs")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListTaskDefinitionFamiliesInput, ListTaskDefinitionFamiliesOutput, ListTaskDefinitionFamiliesOutputError>(id: "listTaskDefinitionFamilies")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListTaskDefinitionFamiliesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListTaskDefinitionFamiliesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListTaskDefinitionFamiliesInput, ListTaskDefinitionFamiliesOutput, ListTaskDefinitionFamiliesOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: ListTaskDefinitionFamiliesInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<ListTaskDefinitionFamiliesInput, ListTaskDefinitionFamiliesOutput, ListTaskDefinitionFamiliesOutputError>(xAmzTarget: "AmazonEC2ContainerServiceV20141113.ListTaskDefinitionFamilies"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns a list of task definitions that are registered to your account. You can filter
    /// 			the results by family name with the <code>familyPrefix</code> parameter or by status
    /// 			with the <code>status</code> parameter.</p>
    public func listTaskDefinitions(input: ListTaskDefinitionsInput, completion: @escaping (SdkResult<ListTaskDefinitionsOutput, ListTaskDefinitionsOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listTaskDefinitions")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "ecs.\(config.region).amazonaws.com")
                      .withSigningName(value: "ecs")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListTaskDefinitionsInput, ListTaskDefinitionsOutput, ListTaskDefinitionsOutputError>(id: "listTaskDefinitions")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListTaskDefinitionsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListTaskDefinitionsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListTaskDefinitionsInput, ListTaskDefinitionsOutput, ListTaskDefinitionsOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: ListTaskDefinitionsInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<ListTaskDefinitionsInput, ListTaskDefinitionsOutput, ListTaskDefinitionsOutputError>(xAmzTarget: "AmazonEC2ContainerServiceV20141113.ListTaskDefinitions"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns a list of tasks. You can filter the results by cluster, task definition
    /// 			family, container instance, launch type, what IAM principal started the task, or by the
    /// 			desired status of the task.</p>
    /// 		       <p>Recently stopped tasks might appear in the returned results. Currently, stopped tasks
    /// 			appear in the returned results for at least one hour.</p>
    public func listTasks(input: ListTasksInput, completion: @escaping (SdkResult<ListTasksOutput, ListTasksOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listTasks")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "ecs.\(config.region).amazonaws.com")
                      .withSigningName(value: "ecs")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListTasksInput, ListTasksOutput, ListTasksOutputError>(id: "listTasks")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListTasksInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListTasksInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListTasksInput, ListTasksOutput, ListTasksOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: ListTasksInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<ListTasksInput, ListTasksOutput, ListTasksOutputError>(xAmzTarget: "AmazonEC2ContainerServiceV20141113.ListTasks"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Modifies an account setting. Account settings are set on a per-Region basis.</p>
    /// 		       <p>If you change the account setting for the root user, the default settings for all of
    /// 			the IAM users and roles for which no individual account setting has been specified are
    /// 			reset. For more information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-account-settings.html">Account
    /// 				Settings</a> in the <i>Amazon Elastic Container Service Developer Guide</i>.</p>
    /// 		       <p>When <code>serviceLongArnFormat</code>, <code>taskLongArnFormat</code>, or
    /// 				<code>containerInstanceLongArnFormat</code> are specified, the Amazon Resource Name
    /// 			(ARN) and resource ID format of the resource type for a specified IAM user, IAM role, or
    /// 			the root user for an account is affected. The opt-in and opt-out account setting must be
    /// 			set for each Amazon ECS resource separately. The ARN and resource ID format of a resource
    /// 			will be defined by the opt-in status of the IAM user or role that created the resource.
    /// 			You must enable this setting to use Amazon ECS features such as resource tagging.</p>
    /// 		       <p>When <code>awsvpcTrunking</code> is specified, the elastic network interface (ENI)
    /// 			limit for any new container instances that support the feature is changed. If
    /// 				<code>awsvpcTrunking</code> is enabled, any new container instances that support the
    /// 			feature are launched have the increased ENI limits available to them. For more
    /// 			information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/container-instance-eni.html">Elastic Network
    /// 				Interface Trunking</a> in the <i>Amazon Elastic Container Service Developer Guide</i>.</p>
    /// 		       <p>When <code>containerInsights</code> is specified, the default setting indicating
    /// 			whether CloudWatch Container Insights is enabled for your clusters is changed. If
    /// 				<code>containerInsights</code> is enabled, any new clusters that are created will
    /// 			have Container Insights enabled unless you disable it during cluster creation. For more
    /// 			information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/cloudwatch-container-insights.html">CloudWatch
    /// 				Container Insights</a> in the <i>Amazon Elastic Container Service Developer Guide</i>.</p>
    public func putAccountSetting(input: PutAccountSettingInput, completion: @escaping (SdkResult<PutAccountSettingOutput, PutAccountSettingOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "putAccountSetting")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "ecs.\(config.region).amazonaws.com")
                      .withSigningName(value: "ecs")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<PutAccountSettingInput, PutAccountSettingOutput, PutAccountSettingOutputError>(id: "putAccountSetting")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: PutAccountSettingInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: PutAccountSettingInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<PutAccountSettingInput, PutAccountSettingOutput, PutAccountSettingOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: PutAccountSettingInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<PutAccountSettingInput, PutAccountSettingOutput, PutAccountSettingOutputError>(xAmzTarget: "AmazonEC2ContainerServiceV20141113.PutAccountSetting"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Modifies an account setting for all IAM users on an account for whom no individual
    /// 			account setting has been specified. Account settings are set on a per-Region
    /// 			basis.</p>
    public func putAccountSettingDefault(input: PutAccountSettingDefaultInput, completion: @escaping (SdkResult<PutAccountSettingDefaultOutput, PutAccountSettingDefaultOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "putAccountSettingDefault")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "ecs.\(config.region).amazonaws.com")
                      .withSigningName(value: "ecs")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<PutAccountSettingDefaultInput, PutAccountSettingDefaultOutput, PutAccountSettingDefaultOutputError>(id: "putAccountSettingDefault")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: PutAccountSettingDefaultInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: PutAccountSettingDefaultInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<PutAccountSettingDefaultInput, PutAccountSettingDefaultOutput, PutAccountSettingDefaultOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: PutAccountSettingDefaultInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<PutAccountSettingDefaultInput, PutAccountSettingDefaultOutput, PutAccountSettingDefaultOutputError>(xAmzTarget: "AmazonEC2ContainerServiceV20141113.PutAccountSettingDefault"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Create or update an attribute on an Amazon ECS resource. If the attribute does not exist,
    /// 			it is created. If the attribute exists, its value is replaced with the specified value.
    /// 			To delete an attribute, use <a>DeleteAttributes</a>. For more information,
    /// 			see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task-placement-constraints.html#attributes">Attributes</a> in the
    /// 			<i>Amazon Elastic Container Service Developer Guide</i>.</p>
    public func putAttributes(input: PutAttributesInput, completion: @escaping (SdkResult<PutAttributesOutput, PutAttributesOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "putAttributes")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "ecs.\(config.region).amazonaws.com")
                      .withSigningName(value: "ecs")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<PutAttributesInput, PutAttributesOutput, PutAttributesOutputError>(id: "putAttributes")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: PutAttributesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: PutAttributesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<PutAttributesInput, PutAttributesOutput, PutAttributesOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: PutAttributesInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<PutAttributesInput, PutAttributesOutput, PutAttributesOutputError>(xAmzTarget: "AmazonEC2ContainerServiceV20141113.PutAttributes"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Modifies the available capacity providers and the default capacity provider strategy
    /// 			for a cluster.</p>
    /// 		       <p>You must specify both the available capacity providers and a default capacity provider
    /// 			strategy for the cluster. If the specified cluster has existing capacity providers
    /// 			associated with it, you must specify all existing capacity providers in addition to any
    /// 			new ones you want to add. Any existing capacity providers associated with a cluster that
    /// 			are omitted from a <a>PutClusterCapacityProviders</a> API call will be
    /// 			disassociated with the cluster. You can only disassociate an existing capacity provider
    /// 			from a cluster if it's not being used by any existing tasks.</p>
    /// 		       <p>When creating a service or running a task on a cluster, if no capacity provider or
    /// 			launch type is specified, then the cluster's default capacity provider strategy is used.
    /// 			It is recommended to define a default capacity provider strategy for your cluster,
    /// 			however you may specify an empty array (<code>[]</code>) to bypass defining a default
    /// 			strategy.</p>
    public func putClusterCapacityProviders(input: PutClusterCapacityProvidersInput, completion: @escaping (SdkResult<PutClusterCapacityProvidersOutput, PutClusterCapacityProvidersOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "putClusterCapacityProviders")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "ecs.\(config.region).amazonaws.com")
                      .withSigningName(value: "ecs")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<PutClusterCapacityProvidersInput, PutClusterCapacityProvidersOutput, PutClusterCapacityProvidersOutputError>(id: "putClusterCapacityProviders")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: PutClusterCapacityProvidersInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: PutClusterCapacityProvidersInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<PutClusterCapacityProvidersInput, PutClusterCapacityProvidersOutput, PutClusterCapacityProvidersOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: PutClusterCapacityProvidersInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<PutClusterCapacityProvidersInput, PutClusterCapacityProvidersOutput, PutClusterCapacityProvidersOutputError>(xAmzTarget: "AmazonEC2ContainerServiceV20141113.PutClusterCapacityProviders"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <note>
    ///             <p>This action is only used by the Amazon ECS agent, and it is not intended for use outside of the agent.</p>
    ///          </note>
    ///          <p>Registers an EC2
    /// 			instance into the specified cluster. This instance becomes available to place containers
    /// 			on.</p>
    public func registerContainerInstance(input: RegisterContainerInstanceInput, completion: @escaping (SdkResult<RegisterContainerInstanceOutput, RegisterContainerInstanceOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "registerContainerInstance")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "ecs.\(config.region).amazonaws.com")
                      .withSigningName(value: "ecs")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<RegisterContainerInstanceInput, RegisterContainerInstanceOutput, RegisterContainerInstanceOutputError>(id: "registerContainerInstance")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: RegisterContainerInstanceInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: RegisterContainerInstanceInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<RegisterContainerInstanceInput, RegisterContainerInstanceOutput, RegisterContainerInstanceOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: RegisterContainerInstanceInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<RegisterContainerInstanceInput, RegisterContainerInstanceOutput, RegisterContainerInstanceOutputError>(xAmzTarget: "AmazonEC2ContainerServiceV20141113.RegisterContainerInstance"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Registers a new task definition from the supplied <code>family</code> and
    /// 				<code>containerDefinitions</code>. Optionally, you can add data volumes to your
    /// 			containers with the <code>volumes</code> parameter. For more information about task
    /// 			definition parameters and defaults, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task_defintions.html">Amazon ECS Task
    /// 				Definitions</a> in the <i>Amazon Elastic Container Service Developer Guide</i>.</p>
    /// 		       <p>You can specify an IAM role for your task with the <code>taskRoleArn</code> parameter.
    /// 			When you specify an IAM role for a task, its containers can then use the latest versions
    /// 			of the AWS CLI or SDKs to make API requests to the AWS services that are specified in
    /// 			the IAM policy associated with the role. For more information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task-iam-roles.html">IAM
    /// 				Roles for Tasks</a> in the <i>Amazon Elastic Container Service Developer Guide</i>.</p>
    /// 		       <p>You can specify a Docker networking mode for the containers in your task definition
    /// 			with the <code>networkMode</code> parameter. The available network modes correspond to
    /// 			those described in <a href="https://docs.docker.com/engine/reference/run/#/network-settings">Network
    /// 				settings</a> in the Docker run reference. If you specify the <code>awsvpc</code>
    /// 			network mode, the task is allocated an elastic network interface, and you must specify a
    /// 				<a>NetworkConfiguration</a> when you create a service or run a task with
    /// 			the task definition. For more information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task-networking.html">Task Networking</a>
    /// 			in the <i>Amazon Elastic Container Service Developer Guide</i>.</p>
    public func registerTaskDefinition(input: RegisterTaskDefinitionInput, completion: @escaping (SdkResult<RegisterTaskDefinitionOutput, RegisterTaskDefinitionOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "registerTaskDefinition")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "ecs.\(config.region).amazonaws.com")
                      .withSigningName(value: "ecs")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<RegisterTaskDefinitionInput, RegisterTaskDefinitionOutput, RegisterTaskDefinitionOutputError>(id: "registerTaskDefinition")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: RegisterTaskDefinitionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: RegisterTaskDefinitionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<RegisterTaskDefinitionInput, RegisterTaskDefinitionOutput, RegisterTaskDefinitionOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: RegisterTaskDefinitionInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<RegisterTaskDefinitionInput, RegisterTaskDefinitionOutput, RegisterTaskDefinitionOutputError>(xAmzTarget: "AmazonEC2ContainerServiceV20141113.RegisterTaskDefinition"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Starts a new task using the specified task definition.</p>
    /// 		       <p>You can allow Amazon ECS to place tasks for you, or you can customize how Amazon ECS places
    /// 			tasks using placement constraints and placement strategies. For more information, see
    /// 				<a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/scheduling_tasks.html">Scheduling Tasks</a> in the
    /// 				<i>Amazon Elastic Container Service Developer Guide</i>.</p>
    /// 		       <p>Alternatively, you can use <a>StartTask</a> to use your own scheduler or
    /// 			place tasks manually on specific container instances.</p>
    /// 		       <p>The Amazon ECS API follows an eventual consistency model, due to the distributed nature of
    /// 			the system supporting the API. This means that the result of an API command you run that
    /// 			affects your Amazon ECS resources might not be immediately visible to all subsequent commands
    /// 			you run. Keep this in mind when you carry out an API command that immediately follows a
    /// 			previous API command.</p>
    /// 		       <p>To manage eventual consistency, you can do the following:</p>
    /// 		       <ul>
    ///             <li>
    /// 				           <p>Confirm the state of the resource before you run a command to modify it. Run
    /// 					the DescribeTasks command using an exponential backoff algorithm to ensure that
    /// 					you allow enough time for the previous command to propagate through the system.
    /// 					To do this, run the DescribeTasks command repeatedly, starting with a couple of
    /// 					seconds of wait time and increasing gradually up to five minutes of wait
    /// 					time.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>Add wait time between subsequent commands, even if the DescribeTasks command
    /// 					returns an accurate response. Apply an exponential backoff algorithm starting
    /// 					with a couple of seconds of wait time, and increase gradually up to about five
    /// 					minutes of wait time.</p>
    /// 			         </li>
    ///          </ul>
    public func runTask(input: RunTaskInput, completion: @escaping (SdkResult<RunTaskOutput, RunTaskOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "runTask")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "ecs.\(config.region).amazonaws.com")
                      .withSigningName(value: "ecs")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<RunTaskInput, RunTaskOutput, RunTaskOutputError>(id: "runTask")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: RunTaskInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: RunTaskInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<RunTaskInput, RunTaskOutput, RunTaskOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: RunTaskInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<RunTaskInput, RunTaskOutput, RunTaskOutputError>(xAmzTarget: "AmazonEC2ContainerServiceV20141113.RunTask"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Starts a new task from the specified task definition on the specified container
    /// 			instance or instances.</p>
    /// 		       <p>Alternatively, you can use <a>RunTask</a> to place tasks for you. For more
    /// 			information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/scheduling_tasks.html">Scheduling Tasks</a> in the
    /// 				<i>Amazon Elastic Container Service Developer Guide</i>.</p>
    public func startTask(input: StartTaskInput, completion: @escaping (SdkResult<StartTaskOutput, StartTaskOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "startTask")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "ecs.\(config.region).amazonaws.com")
                      .withSigningName(value: "ecs")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<StartTaskInput, StartTaskOutput, StartTaskOutputError>(id: "startTask")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: StartTaskInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: StartTaskInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<StartTaskInput, StartTaskOutput, StartTaskOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: StartTaskInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<StartTaskInput, StartTaskOutput, StartTaskOutputError>(xAmzTarget: "AmazonEC2ContainerServiceV20141113.StartTask"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Stops a running task. Any tags associated with the task will be deleted.</p>
    /// 		       <p>When <a>StopTask</a> is called on a task, the equivalent of <code>docker
    /// 				stop</code> is issued to the containers running in the task. This results in a
    /// 				<code>SIGTERM</code> value and a default 30-second timeout, after which the
    /// 				<code>SIGKILL</code> value is sent and the containers are forcibly stopped. If the
    /// 			container handles the <code>SIGTERM</code> value gracefully and exits within 30 seconds
    /// 			from receiving it, no <code>SIGKILL</code> value is sent.</p>
    /// 		       <note>
    /// 			         <p>The default 30-second timeout can be configured on the Amazon ECS container agent with
    /// 				the <code>ECS_CONTAINER_STOP_TIMEOUT</code> variable. For more information, see
    /// 					<a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-agent-config.html">Amazon ECS Container Agent Configuration</a> in the
    /// 					<i>Amazon Elastic Container Service Developer Guide</i>.</p>
    /// 		       </note>
    public func stopTask(input: StopTaskInput, completion: @escaping (SdkResult<StopTaskOutput, StopTaskOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "stopTask")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "ecs.\(config.region).amazonaws.com")
                      .withSigningName(value: "ecs")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<StopTaskInput, StopTaskOutput, StopTaskOutputError>(id: "stopTask")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: StopTaskInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: StopTaskInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<StopTaskInput, StopTaskOutput, StopTaskOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: StopTaskInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<StopTaskInput, StopTaskOutput, StopTaskOutputError>(xAmzTarget: "AmazonEC2ContainerServiceV20141113.StopTask"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <note>
    ///             <p>This action is only used by the Amazon ECS agent, and it is not intended for use outside of the agent.</p>
    ///          </note>
    ///          <p>Sent to
    /// 			acknowledge that an attachment changed states.</p>
    public func submitAttachmentStateChanges(input: SubmitAttachmentStateChangesInput, completion: @escaping (SdkResult<SubmitAttachmentStateChangesOutput, SubmitAttachmentStateChangesOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "submitAttachmentStateChanges")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "ecs.\(config.region).amazonaws.com")
                      .withSigningName(value: "ecs")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<SubmitAttachmentStateChangesInput, SubmitAttachmentStateChangesOutput, SubmitAttachmentStateChangesOutputError>(id: "submitAttachmentStateChanges")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: SubmitAttachmentStateChangesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: SubmitAttachmentStateChangesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<SubmitAttachmentStateChangesInput, SubmitAttachmentStateChangesOutput, SubmitAttachmentStateChangesOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: SubmitAttachmentStateChangesInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<SubmitAttachmentStateChangesInput, SubmitAttachmentStateChangesOutput, SubmitAttachmentStateChangesOutputError>(xAmzTarget: "AmazonEC2ContainerServiceV20141113.SubmitAttachmentStateChanges"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <note>
    ///             <p>This action is only used by the Amazon ECS agent, and it is not intended for use outside of the agent.</p>
    ///          </note>
    ///          <p>Sent to
    /// 			acknowledge that a container changed states.</p>
    public func submitContainerStateChange(input: SubmitContainerStateChangeInput, completion: @escaping (SdkResult<SubmitContainerStateChangeOutput, SubmitContainerStateChangeOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "submitContainerStateChange")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "ecs.\(config.region).amazonaws.com")
                      .withSigningName(value: "ecs")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<SubmitContainerStateChangeInput, SubmitContainerStateChangeOutput, SubmitContainerStateChangeOutputError>(id: "submitContainerStateChange")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: SubmitContainerStateChangeInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: SubmitContainerStateChangeInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<SubmitContainerStateChangeInput, SubmitContainerStateChangeOutput, SubmitContainerStateChangeOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: SubmitContainerStateChangeInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<SubmitContainerStateChangeInput, SubmitContainerStateChangeOutput, SubmitContainerStateChangeOutputError>(xAmzTarget: "AmazonEC2ContainerServiceV20141113.SubmitContainerStateChange"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <note>
    ///             <p>This action is only used by the Amazon ECS agent, and it is not intended for use outside of the agent.</p>
    ///          </note>
    ///          <p>Sent to acknowledge
    /// 			that a task changed states.</p>
    public func submitTaskStateChange(input: SubmitTaskStateChangeInput, completion: @escaping (SdkResult<SubmitTaskStateChangeOutput, SubmitTaskStateChangeOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "submitTaskStateChange")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "ecs.\(config.region).amazonaws.com")
                      .withSigningName(value: "ecs")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<SubmitTaskStateChangeInput, SubmitTaskStateChangeOutput, SubmitTaskStateChangeOutputError>(id: "submitTaskStateChange")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: SubmitTaskStateChangeInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: SubmitTaskStateChangeInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<SubmitTaskStateChangeInput, SubmitTaskStateChangeOutput, SubmitTaskStateChangeOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: SubmitTaskStateChangeInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<SubmitTaskStateChangeInput, SubmitTaskStateChangeOutput, SubmitTaskStateChangeOutputError>(xAmzTarget: "AmazonEC2ContainerServiceV20141113.SubmitTaskStateChange"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Associates the specified tags to a resource with the specified
    /// 				<code>resourceArn</code>. If existing tags on a resource are not specified in the
    /// 			request parameters, they are not changed. When a resource is deleted, the tags
    /// 			associated with that resource are deleted as well.</p>
    public func tagResource(input: TagResourceInput, completion: @escaping (SdkResult<TagResourceOutput, TagResourceOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "tagResource")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "ecs.\(config.region).amazonaws.com")
                      .withSigningName(value: "ecs")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<TagResourceInput, TagResourceOutput, TagResourceOutputError>(id: "tagResource")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: TagResourceInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: TagResourceInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<TagResourceInput, TagResourceOutput, TagResourceOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: TagResourceInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<TagResourceInput, TagResourceOutput, TagResourceOutputError>(xAmzTarget: "AmazonEC2ContainerServiceV20141113.TagResource"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes specified tags from a resource.</p>
    public func untagResource(input: UntagResourceInput, completion: @escaping (SdkResult<UntagResourceOutput, UntagResourceOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "untagResource")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "ecs.\(config.region).amazonaws.com")
                      .withSigningName(value: "ecs")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UntagResourceInput, UntagResourceOutput, UntagResourceOutputError>(id: "untagResource")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UntagResourceInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UntagResourceInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UntagResourceInput, UntagResourceOutput, UntagResourceOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: UntagResourceInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<UntagResourceInput, UntagResourceOutput, UntagResourceOutputError>(xAmzTarget: "AmazonEC2ContainerServiceV20141113.UntagResource"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Modifies the parameters for a capacity provider.</p>
    public func updateCapacityProvider(input: UpdateCapacityProviderInput, completion: @escaping (SdkResult<UpdateCapacityProviderOutput, UpdateCapacityProviderOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateCapacityProvider")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "ecs.\(config.region).amazonaws.com")
                      .withSigningName(value: "ecs")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateCapacityProviderInput, UpdateCapacityProviderOutput, UpdateCapacityProviderOutputError>(id: "updateCapacityProvider")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateCapacityProviderInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateCapacityProviderInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateCapacityProviderInput, UpdateCapacityProviderOutput, UpdateCapacityProviderOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateCapacityProviderInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<UpdateCapacityProviderInput, UpdateCapacityProviderOutput, UpdateCapacityProviderOutputError>(xAmzTarget: "AmazonEC2ContainerServiceV20141113.UpdateCapacityProvider"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Updates the cluster.</p>
    public func updateCluster(input: UpdateClusterInput, completion: @escaping (SdkResult<UpdateClusterOutput, UpdateClusterOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateCluster")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "ecs.\(config.region).amazonaws.com")
                      .withSigningName(value: "ecs")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateClusterInput, UpdateClusterOutput, UpdateClusterOutputError>(id: "updateCluster")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateClusterInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateClusterInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateClusterInput, UpdateClusterOutput, UpdateClusterOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateClusterInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<UpdateClusterInput, UpdateClusterOutput, UpdateClusterOutputError>(xAmzTarget: "AmazonEC2ContainerServiceV20141113.UpdateCluster"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Modifies the settings to use for a cluster.</p>
    public func updateClusterSettings(input: UpdateClusterSettingsInput, completion: @escaping (SdkResult<UpdateClusterSettingsOutput, UpdateClusterSettingsOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateClusterSettings")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "ecs.\(config.region).amazonaws.com")
                      .withSigningName(value: "ecs")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateClusterSettingsInput, UpdateClusterSettingsOutput, UpdateClusterSettingsOutputError>(id: "updateClusterSettings")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateClusterSettingsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateClusterSettingsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateClusterSettingsInput, UpdateClusterSettingsOutput, UpdateClusterSettingsOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateClusterSettingsInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<UpdateClusterSettingsInput, UpdateClusterSettingsOutput, UpdateClusterSettingsOutputError>(xAmzTarget: "AmazonEC2ContainerServiceV20141113.UpdateClusterSettings"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Updates the Amazon ECS container agent on a specified container instance. Updating the
    /// 			Amazon ECS container agent does not interrupt running tasks or services on the container
    /// 			instance. The process for updating the agent differs depending on whether your container
    /// 			instance was launched with the Amazon ECS-optimized AMI or another operating system.</p>
    /// 		       <note>
    /// 			         <p>The <code>UpdateContainerAgent</code> API isn't supported for container instances
    /// 				using the Amazon ECS-optimized Amazon Linux 2 (arm64) AMI. To update the container agent,
    /// 				you can update the <code>ecs-init</code> package which will update the agent. For
    /// 				more information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/agent-update-ecs-ami.html">Updating the
    /// 					Amazon ECS container agent</a> in the
    /// 				<i>Amazon Elastic Container Service Developer Guide</i>.</p>
    /// 		       </note>
    /// 		       <p>The <code>UpdateContainerAgent</code> API requires an Amazon ECS-optimized AMI or Amazon
    /// 			Linux AMI with the <code>ecs-init</code> service installed and running. For help
    /// 			updating the Amazon ECS container agent on other operating systems, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-agent-update.html#manually_update_agent">Manually updating the Amazon ECS container agent</a> in the
    /// 				<i>Amazon Elastic Container Service Developer Guide</i>.</p>
    public func updateContainerAgent(input: UpdateContainerAgentInput, completion: @escaping (SdkResult<UpdateContainerAgentOutput, UpdateContainerAgentOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateContainerAgent")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "ecs.\(config.region).amazonaws.com")
                      .withSigningName(value: "ecs")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateContainerAgentInput, UpdateContainerAgentOutput, UpdateContainerAgentOutputError>(id: "updateContainerAgent")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateContainerAgentInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateContainerAgentInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateContainerAgentInput, UpdateContainerAgentOutput, UpdateContainerAgentOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateContainerAgentInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<UpdateContainerAgentInput, UpdateContainerAgentOutput, UpdateContainerAgentOutputError>(xAmzTarget: "AmazonEC2ContainerServiceV20141113.UpdateContainerAgent"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Modifies the status of an Amazon ECS container instance.</p>
    /// 		       <p>Once a container instance has reached an <code>ACTIVE</code> state, you can change the
    /// 			status of a container instance to <code>DRAINING</code> to manually remove an instance
    /// 			from a cluster, for example to perform system updates, update the Docker daemon, or
    /// 			scale down the cluster size.</p>
    /// 		       <important>
    /// 			         <p>A container instance cannot be changed to <code>DRAINING</code> until it has
    /// 				reached an <code>ACTIVE</code> status. If the instance is in any other status, an
    /// 				error will be received.</p>
    /// 		       </important>
    /// 		       <p>When you set a container instance to <code>DRAINING</code>, Amazon ECS prevents new tasks
    /// 			from being scheduled for placement on the container instance and replacement service
    /// 			tasks are started on other container instances in the cluster if the resources are
    /// 			available. Service tasks on the container instance that are in the <code>PENDING</code>
    /// 			state are stopped immediately.</p>
    /// 		       <p>Service tasks on the container instance that are in the <code>RUNNING</code> state are
    /// 			stopped and replaced according to the service's deployment configuration parameters,
    /// 				<code>minimumHealthyPercent</code> and <code>maximumPercent</code>. You can change
    /// 			the deployment configuration of your service using <a>UpdateService</a>.</p>
    /// 		       <ul>
    ///             <li>
    /// 				           <p>If <code>minimumHealthyPercent</code> is below 100%, the scheduler can ignore
    /// 						<code>desiredCount</code> temporarily during task replacement. For example,
    /// 						<code>desiredCount</code> is four tasks, a minimum of 50% allows the
    /// 					scheduler to stop two existing tasks before starting two new tasks. If the
    /// 					minimum is 100%, the service scheduler can't remove existing tasks until the
    /// 					replacement tasks are considered healthy. Tasks for services that do not use a
    /// 					load balancer are considered healthy if they are in the <code>RUNNING</code>
    /// 					state. Tasks for services that use a load balancer are considered healthy if
    /// 					they are in the <code>RUNNING</code> state and the container instance they are
    /// 					hosted on is reported as healthy by the load balancer.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>The <code>maximumPercent</code> parameter represents an upper limit on the
    /// 					number of running tasks during task replacement, which enables you to define the
    /// 					replacement batch size. For example, if <code>desiredCount</code> is four tasks,
    /// 					a maximum of 200% starts four new tasks before stopping the four tasks to be
    /// 					drained, provided that the cluster resources required to do this are available.
    /// 					If the maximum is 100%, then replacement tasks can't start until the draining
    /// 					tasks have stopped.</p>
    /// 			         </li>
    ///          </ul>
    /// 		       <p>Any <code>PENDING</code> or <code>RUNNING</code> tasks that do not belong to a service
    /// 			are not affected. You must wait for them to finish or stop them manually.</p>
    /// 		       <p>A container instance has completed draining when it has no more <code>RUNNING</code>
    /// 			tasks. You can verify this using <a>ListTasks</a>.</p>
    /// 		       <p>When a container instance has been drained, you can set a container instance to
    /// 				<code>ACTIVE</code> status and once it has reached that status the Amazon ECS scheduler
    /// 			can begin scheduling tasks on the instance again.</p>
    public func updateContainerInstancesState(input: UpdateContainerInstancesStateInput, completion: @escaping (SdkResult<UpdateContainerInstancesStateOutput, UpdateContainerInstancesStateOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateContainerInstancesState")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "ecs.\(config.region).amazonaws.com")
                      .withSigningName(value: "ecs")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateContainerInstancesStateInput, UpdateContainerInstancesStateOutput, UpdateContainerInstancesStateOutputError>(id: "updateContainerInstancesState")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateContainerInstancesStateInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateContainerInstancesStateInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateContainerInstancesStateInput, UpdateContainerInstancesStateOutput, UpdateContainerInstancesStateOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateContainerInstancesStateInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<UpdateContainerInstancesStateInput, UpdateContainerInstancesStateOutput, UpdateContainerInstancesStateOutputError>(xAmzTarget: "AmazonEC2ContainerServiceV20141113.UpdateContainerInstancesState"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <important>
    /// 			         <p>Updating the task placement strategies and constraints on an Amazon ECS service remains
    /// 				in preview and is a Beta Service as defined by and subject to the Beta Service
    /// 				Participation Service Terms located at <a href="https://aws.amazon.com/service-terms">https://aws.amazon.com/service-terms</a> ("Beta Terms"). These Beta Terms
    /// 				apply to your participation in this preview.</p>
    /// 		       </important>
    /// 		       <p>Modifies the parameters of a service.</p>
    /// 		       <p>For services using the rolling update (<code>ECS</code>) deployment controller, the
    /// 			desired count, deployment configuration, network configuration, task placement
    /// 			constraints and strategies, or task definition used can be updated.</p>
    /// 		       <p>For services using the blue/green (<code>CODE_DEPLOY</code>) deployment controller,
    /// 			only the desired count, deployment configuration, task placement constraints and
    /// 			strategies, and health check grace period can be updated using this API. If the network
    /// 			configuration, platform version, or task definition need to be updated, a new AWS CodeDeploy
    /// 			deployment should be created. For more information, see <a href="https://docs.aws.amazon.com/codedeploy/latest/APIReference/API_CreateDeployment.html">CreateDeployment</a> in the <i>AWS CodeDeploy API Reference</i>.</p>
    /// 		       <p>For services using an external deployment controller, you can update only the desired
    /// 			count, task placement constraints and strategies, and health check grace period using
    /// 			this API. If the launch type, load balancer, network configuration, platform version, or
    /// 			task definition need to be updated, you should create a new task set. For more
    /// 			information, see <a>CreateTaskSet</a>.</p>
    /// 		       <p>You can add to or subtract from the number of instantiations of a task definition in a
    /// 			service by specifying the cluster that the service is running in and a new
    /// 				<code>desiredCount</code> parameter.</p>
    /// 		       <p>If you have updated the Docker image of your application, you can create a new task
    /// 			definition with that image and deploy it to your service. The service scheduler uses the
    /// 			minimum healthy percent and maximum percent parameters (in the service's deployment
    /// 			configuration) to determine the deployment strategy.</p>
    /// 		       <note>
    /// 			         <p>If your updated Docker image uses the same tag as what is in the existing task
    /// 				definition for your service (for example, <code>my_image:latest</code>), you do not
    /// 				need to create a new revision of your task definition. You can update the service
    /// 				using the <code>forceNewDeployment</code> option. The new tasks launched by the
    /// 				deployment pull the current image/tag combination from your repository when they
    /// 				start.</p>
    /// 		       </note>
    /// 		       <p>You can also update the deployment configuration of a service. When a deployment is
    /// 			triggered by updating the task definition of a service, the service scheduler uses the
    /// 			deployment configuration parameters, <code>minimumHealthyPercent</code> and
    /// 				<code>maximumPercent</code>, to determine the deployment strategy.</p>
    /// 		       <ul>
    ///             <li>
    /// 				           <p>If <code>minimumHealthyPercent</code> is below 100%, the scheduler can ignore
    /// 						<code>desiredCount</code> temporarily during a deployment. For example, if
    /// 						<code>desiredCount</code> is four tasks, a minimum of 50% allows the
    /// 					scheduler to stop two existing tasks before starting two new tasks. Tasks for
    /// 					services that do not use a load balancer are considered healthy if they are in
    /// 					the <code>RUNNING</code> state. Tasks for services that use a load balancer are
    /// 					considered healthy if they are in the <code>RUNNING</code> state and the
    /// 					container instance they are hosted on is reported as healthy by the load
    /// 					balancer.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>The <code>maximumPercent</code> parameter represents an upper limit on the
    /// 					number of running tasks during a deployment, which enables you to define the
    /// 					deployment batch size. For example, if <code>desiredCount</code> is four tasks,
    /// 					a maximum of 200% starts four new tasks before stopping the four older tasks
    /// 					(provided that the cluster resources required to do this are available).</p>
    /// 			         </li>
    ///          </ul>
    /// 		       <p>When <a>UpdateService</a> stops a task during a deployment, the equivalent
    /// 			of <code>docker stop</code> is issued to the containers running in the task. This
    /// 			results in a <code>SIGTERM</code> and a 30-second timeout, after which
    /// 				<code>SIGKILL</code> is sent and the containers are forcibly stopped. If the
    /// 			container handles the <code>SIGTERM</code> gracefully and exits within 30 seconds from
    /// 			receiving it, no <code>SIGKILL</code> is sent.</p>
    /// 		       <p>When the service scheduler launches new tasks, it determines task placement in your
    /// 			cluster with the following logic:</p>
    /// 		       <ul>
    ///             <li>
    /// 				           <p>Determine which of the container instances in your cluster can support your
    /// 					service's task definition (for example, they have the required CPU, memory,
    /// 					ports, and container instance attributes).</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>By default, the service scheduler attempts to balance tasks across
    /// 					Availability Zones in this manner (although you can choose a different placement
    /// 					strategy):</p>
    /// 				           <ul>
    ///                   <li>
    /// 						               <p>Sort the valid container instances by the fewest number of running
    /// 							tasks for this service in the same Availability Zone as the instance.
    /// 							For example, if zone A has one running service task and zones B and C
    /// 							each have zero, valid container instances in either zone B or C are
    /// 							considered optimal for placement.</p>
    /// 					             </li>
    ///                   <li>
    /// 						               <p>Place the new service task on a valid container instance in an optimal
    /// 							Availability Zone (based on the previous steps), favoring container
    /// 							instances with the fewest number of running tasks for this
    /// 							service.</p>
    /// 					             </li>
    ///                </ul>
    /// 			         </li>
    ///          </ul>
    /// 		       <p>When the service scheduler stops running tasks, it attempts to maintain balance across
    /// 			the Availability Zones in your cluster using the following logic: </p>
    /// 		       <ul>
    ///             <li>
    /// 				           <p>Sort the container instances by the largest number of running tasks for this
    /// 					service in the same Availability Zone as the instance. For example, if zone A
    /// 					has one running service task and zones B and C each have two, container
    /// 					instances in either zone B or C are considered optimal for termination.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>Stop the task on a container instance in an optimal Availability Zone (based
    /// 					on the previous steps), favoring container instances with the largest number of
    /// 					running tasks for this service.</p>
    /// 			         </li>
    ///          </ul>
    public func updateService(input: UpdateServiceInput, completion: @escaping (SdkResult<UpdateServiceOutput, UpdateServiceOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateService")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "ecs.\(config.region).amazonaws.com")
                      .withSigningName(value: "ecs")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateServiceInput, UpdateServiceOutput, UpdateServiceOutputError>(id: "updateService")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateServiceInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateServiceInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateServiceInput, UpdateServiceOutput, UpdateServiceOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateServiceInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<UpdateServiceInput, UpdateServiceOutput, UpdateServiceOutputError>(xAmzTarget: "AmazonEC2ContainerServiceV20141113.UpdateService"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Modifies which task set in a service is the primary task set. Any parameters that are
    /// 			updated on the primary task set in a service will transition to the service. This is
    /// 			used when a service uses the <code>EXTERNAL</code> deployment controller type. For more
    /// 			information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/deployment-types.html">Amazon ECS Deployment
    /// 				Types</a> in the <i>Amazon Elastic Container Service Developer Guide</i>.</p>
    public func updateServicePrimaryTaskSet(input: UpdateServicePrimaryTaskSetInput, completion: @escaping (SdkResult<UpdateServicePrimaryTaskSetOutput, UpdateServicePrimaryTaskSetOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateServicePrimaryTaskSet")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "ecs.\(config.region).amazonaws.com")
                      .withSigningName(value: "ecs")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateServicePrimaryTaskSetInput, UpdateServicePrimaryTaskSetOutput, UpdateServicePrimaryTaskSetOutputError>(id: "updateServicePrimaryTaskSet")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateServicePrimaryTaskSetInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateServicePrimaryTaskSetInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateServicePrimaryTaskSetInput, UpdateServicePrimaryTaskSetOutput, UpdateServicePrimaryTaskSetOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateServicePrimaryTaskSetInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<UpdateServicePrimaryTaskSetInput, UpdateServicePrimaryTaskSetOutput, UpdateServicePrimaryTaskSetOutputError>(xAmzTarget: "AmazonEC2ContainerServiceV20141113.UpdateServicePrimaryTaskSet"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Modifies a task set. This is used when a service uses the <code>EXTERNAL</code>
    /// 			deployment controller type. For more information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/deployment-types.html">Amazon ECS Deployment
    /// 				Types</a> in the <i>Amazon Elastic Container Service Developer Guide</i>.</p>
    public func updateTaskSet(input: UpdateTaskSetInput, completion: @escaping (SdkResult<UpdateTaskSetOutput, UpdateTaskSetOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateTaskSet")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "ecs.\(config.region).amazonaws.com")
                      .withSigningName(value: "ecs")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateTaskSetInput, UpdateTaskSetOutput, UpdateTaskSetOutputError>(id: "updateTaskSet")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateTaskSetInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateTaskSetInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateTaskSetInput, UpdateTaskSetOutput, UpdateTaskSetOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateTaskSetInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<UpdateTaskSetInput, UpdateTaskSetOutput, UpdateTaskSetOutputError>(xAmzTarget: "AmazonEC2ContainerServiceV20141113.UpdateTaskSet"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

}
