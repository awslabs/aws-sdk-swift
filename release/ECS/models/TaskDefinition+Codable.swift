// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension TaskDefinition: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case compatibilities
        case containerDefinitions
        case cpu
        case deregisteredAt
        case ephemeralStorage
        case executionRoleArn
        case family
        case inferenceAccelerators
        case ipcMode
        case memory
        case networkMode
        case pidMode
        case placementConstraints
        case proxyConfiguration
        case registeredAt
        case registeredBy
        case requiresAttributes
        case requiresCompatibilities
        case revision
        case status
        case taskDefinitionArn
        case taskRoleArn
        case volumes
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let compatibilities = compatibilities {
            var compatibilitiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .compatibilities)
            for compatibilitylist0 in compatibilities {
                try compatibilitiesContainer.encode(compatibilitylist0.rawValue)
            }
        }
        if let containerDefinitions = containerDefinitions {
            var containerDefinitionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .containerDefinitions)
            for containerdefinitions0 in containerDefinitions {
                try containerDefinitionsContainer.encode(containerdefinitions0)
            }
        }
        if let cpu = cpu {
            try encodeContainer.encode(cpu, forKey: .cpu)
        }
        if let deregisteredAt = deregisteredAt {
            try encodeContainer.encode(deregisteredAt.timeIntervalSince1970, forKey: .deregisteredAt)
        }
        if let ephemeralStorage = ephemeralStorage {
            try encodeContainer.encode(ephemeralStorage, forKey: .ephemeralStorage)
        }
        if let executionRoleArn = executionRoleArn {
            try encodeContainer.encode(executionRoleArn, forKey: .executionRoleArn)
        }
        if let family = family {
            try encodeContainer.encode(family, forKey: .family)
        }
        if let inferenceAccelerators = inferenceAccelerators {
            var inferenceAcceleratorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .inferenceAccelerators)
            for inferenceaccelerators0 in inferenceAccelerators {
                try inferenceAcceleratorsContainer.encode(inferenceaccelerators0)
            }
        }
        if let ipcMode = ipcMode {
            try encodeContainer.encode(ipcMode.rawValue, forKey: .ipcMode)
        }
        if let memory = memory {
            try encodeContainer.encode(memory, forKey: .memory)
        }
        if let networkMode = networkMode {
            try encodeContainer.encode(networkMode.rawValue, forKey: .networkMode)
        }
        if let pidMode = pidMode {
            try encodeContainer.encode(pidMode.rawValue, forKey: .pidMode)
        }
        if let placementConstraints = placementConstraints {
            var placementConstraintsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .placementConstraints)
            for taskdefinitionplacementconstraints0 in placementConstraints {
                try placementConstraintsContainer.encode(taskdefinitionplacementconstraints0)
            }
        }
        if let proxyConfiguration = proxyConfiguration {
            try encodeContainer.encode(proxyConfiguration, forKey: .proxyConfiguration)
        }
        if let registeredAt = registeredAt {
            try encodeContainer.encode(registeredAt.timeIntervalSince1970, forKey: .registeredAt)
        }
        if let registeredBy = registeredBy {
            try encodeContainer.encode(registeredBy, forKey: .registeredBy)
        }
        if let requiresAttributes = requiresAttributes {
            var requiresAttributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .requiresAttributes)
            for requiresattributes0 in requiresAttributes {
                try requiresAttributesContainer.encode(requiresattributes0)
            }
        }
        if let requiresCompatibilities = requiresCompatibilities {
            var requiresCompatibilitiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .requiresCompatibilities)
            for compatibilitylist0 in requiresCompatibilities {
                try requiresCompatibilitiesContainer.encode(compatibilitylist0.rawValue)
            }
        }
        if revision != 0 {
            try encodeContainer.encode(revision, forKey: .revision)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let taskDefinitionArn = taskDefinitionArn {
            try encodeContainer.encode(taskDefinitionArn, forKey: .taskDefinitionArn)
        }
        if let taskRoleArn = taskRoleArn {
            try encodeContainer.encode(taskRoleArn, forKey: .taskRoleArn)
        }
        if let volumes = volumes {
            var volumesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .volumes)
            for volumelist0 in volumes {
                try volumesContainer.encode(volumelist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let taskDefinitionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .taskDefinitionArn)
        taskDefinitionArn = taskDefinitionArnDecoded
        let containerDefinitionsContainer = try containerValues.decodeIfPresent([ContainerDefinition?].self, forKey: .containerDefinitions)
        var containerDefinitionsDecoded0:[ContainerDefinition]? = nil
        if let containerDefinitionsContainer = containerDefinitionsContainer {
            containerDefinitionsDecoded0 = [ContainerDefinition]()
            for structure0 in containerDefinitionsContainer {
                if let structure0 = structure0 {
                    containerDefinitionsDecoded0?.append(structure0)
                }
            }
        }
        containerDefinitions = containerDefinitionsDecoded0
        let familyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .family)
        family = familyDecoded
        let taskRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .taskRoleArn)
        taskRoleArn = taskRoleArnDecoded
        let executionRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .executionRoleArn)
        executionRoleArn = executionRoleArnDecoded
        let networkModeDecoded = try containerValues.decodeIfPresent(NetworkMode.self, forKey: .networkMode)
        networkMode = networkModeDecoded
        let revisionDecoded = try containerValues.decode(Int.self, forKey: .revision)
        revision = revisionDecoded
        let volumesContainer = try containerValues.decodeIfPresent([Volume?].self, forKey: .volumes)
        var volumesDecoded0:[Volume]? = nil
        if let volumesContainer = volumesContainer {
            volumesDecoded0 = [Volume]()
            for structure0 in volumesContainer {
                if let structure0 = structure0 {
                    volumesDecoded0?.append(structure0)
                }
            }
        }
        volumes = volumesDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(TaskDefinitionStatus.self, forKey: .status)
        status = statusDecoded
        let requiresAttributesContainer = try containerValues.decodeIfPresent([Attribute?].self, forKey: .requiresAttributes)
        var requiresAttributesDecoded0:[Attribute]? = nil
        if let requiresAttributesContainer = requiresAttributesContainer {
            requiresAttributesDecoded0 = [Attribute]()
            for structure0 in requiresAttributesContainer {
                if let structure0 = structure0 {
                    requiresAttributesDecoded0?.append(structure0)
                }
            }
        }
        requiresAttributes = requiresAttributesDecoded0
        let placementConstraintsContainer = try containerValues.decodeIfPresent([TaskDefinitionPlacementConstraint?].self, forKey: .placementConstraints)
        var placementConstraintsDecoded0:[TaskDefinitionPlacementConstraint]? = nil
        if let placementConstraintsContainer = placementConstraintsContainer {
            placementConstraintsDecoded0 = [TaskDefinitionPlacementConstraint]()
            for structure0 in placementConstraintsContainer {
                if let structure0 = structure0 {
                    placementConstraintsDecoded0?.append(structure0)
                }
            }
        }
        placementConstraints = placementConstraintsDecoded0
        let compatibilitiesContainer = try containerValues.decodeIfPresent([Compatibility?].self, forKey: .compatibilities)
        var compatibilitiesDecoded0:[Compatibility]? = nil
        if let compatibilitiesContainer = compatibilitiesContainer {
            compatibilitiesDecoded0 = [Compatibility]()
            for string0 in compatibilitiesContainer {
                if let string0 = string0 {
                    compatibilitiesDecoded0?.append(string0)
                }
            }
        }
        compatibilities = compatibilitiesDecoded0
        let requiresCompatibilitiesContainer = try containerValues.decodeIfPresent([Compatibility?].self, forKey: .requiresCompatibilities)
        var requiresCompatibilitiesDecoded0:[Compatibility]? = nil
        if let requiresCompatibilitiesContainer = requiresCompatibilitiesContainer {
            requiresCompatibilitiesDecoded0 = [Compatibility]()
            for string0 in requiresCompatibilitiesContainer {
                if let string0 = string0 {
                    requiresCompatibilitiesDecoded0?.append(string0)
                }
            }
        }
        requiresCompatibilities = requiresCompatibilitiesDecoded0
        let cpuDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cpu)
        cpu = cpuDecoded
        let memoryDecoded = try containerValues.decodeIfPresent(String.self, forKey: .memory)
        memory = memoryDecoded
        let inferenceAcceleratorsContainer = try containerValues.decodeIfPresent([InferenceAccelerator?].self, forKey: .inferenceAccelerators)
        var inferenceAcceleratorsDecoded0:[InferenceAccelerator]? = nil
        if let inferenceAcceleratorsContainer = inferenceAcceleratorsContainer {
            inferenceAcceleratorsDecoded0 = [InferenceAccelerator]()
            for structure0 in inferenceAcceleratorsContainer {
                if let structure0 = structure0 {
                    inferenceAcceleratorsDecoded0?.append(structure0)
                }
            }
        }
        inferenceAccelerators = inferenceAcceleratorsDecoded0
        let pidModeDecoded = try containerValues.decodeIfPresent(PidMode.self, forKey: .pidMode)
        pidMode = pidModeDecoded
        let ipcModeDecoded = try containerValues.decodeIfPresent(IpcMode.self, forKey: .ipcMode)
        ipcMode = ipcModeDecoded
        let proxyConfigurationDecoded = try containerValues.decodeIfPresent(ProxyConfiguration.self, forKey: .proxyConfiguration)
        proxyConfiguration = proxyConfigurationDecoded
        let registeredAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .registeredAt)
        registeredAt = registeredAtDecoded
        let deregisteredAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .deregisteredAt)
        deregisteredAt = deregisteredAtDecoded
        let registeredByDecoded = try containerValues.decodeIfPresent(String.self, forKey: .registeredBy)
        registeredBy = registeredByDecoded
        let ephemeralStorageDecoded = try containerValues.decodeIfPresent(EphemeralStorage.self, forKey: .ephemeralStorage)
        ephemeralStorage = ephemeralStorageDecoded
    }
}
