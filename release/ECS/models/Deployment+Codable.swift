// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension Deployment: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case capacityProviderStrategy
        case createdAt
        case desiredCount
        case failedTasks
        case id
        case launchType
        case networkConfiguration
        case pendingCount
        case platformVersion
        case rolloutState
        case rolloutStateReason
        case runningCount
        case status
        case taskDefinition
        case updatedAt
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let capacityProviderStrategy = capacityProviderStrategy {
            var capacityProviderStrategyContainer = encodeContainer.nestedUnkeyedContainer(forKey: .capacityProviderStrategy)
            for capacityproviderstrategy0 in capacityProviderStrategy {
                try capacityProviderStrategyContainer.encode(capacityproviderstrategy0)
            }
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if desiredCount != 0 {
            try encodeContainer.encode(desiredCount, forKey: .desiredCount)
        }
        if failedTasks != 0 {
            try encodeContainer.encode(failedTasks, forKey: .failedTasks)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let launchType = launchType {
            try encodeContainer.encode(launchType.rawValue, forKey: .launchType)
        }
        if let networkConfiguration = networkConfiguration {
            try encodeContainer.encode(networkConfiguration, forKey: .networkConfiguration)
        }
        if pendingCount != 0 {
            try encodeContainer.encode(pendingCount, forKey: .pendingCount)
        }
        if let platformVersion = platformVersion {
            try encodeContainer.encode(platformVersion, forKey: .platformVersion)
        }
        if let rolloutState = rolloutState {
            try encodeContainer.encode(rolloutState.rawValue, forKey: .rolloutState)
        }
        if let rolloutStateReason = rolloutStateReason {
            try encodeContainer.encode(rolloutStateReason, forKey: .rolloutStateReason)
        }
        if runningCount != 0 {
            try encodeContainer.encode(runningCount, forKey: .runningCount)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let taskDefinition = taskDefinition {
            try encodeContainer.encode(taskDefinition, forKey: .taskDefinition)
        }
        if let updatedAt = updatedAt {
            try encodeContainer.encode(updatedAt.timeIntervalSince1970, forKey: .updatedAt)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let taskDefinitionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .taskDefinition)
        taskDefinition = taskDefinitionDecoded
        let desiredCountDecoded = try containerValues.decode(Int.self, forKey: .desiredCount)
        desiredCount = desiredCountDecoded
        let pendingCountDecoded = try containerValues.decode(Int.self, forKey: .pendingCount)
        pendingCount = pendingCountDecoded
        let runningCountDecoded = try containerValues.decode(Int.self, forKey: .runningCount)
        runningCount = runningCountDecoded
        let failedTasksDecoded = try containerValues.decode(Int.self, forKey: .failedTasks)
        failedTasks = failedTasksDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let capacityProviderStrategyContainer = try containerValues.decodeIfPresent([CapacityProviderStrategyItem].self, forKey: .capacityProviderStrategy)
        var capacityProviderStrategyDecoded0:[CapacityProviderStrategyItem]? = nil
        if let capacityProviderStrategyContainer = capacityProviderStrategyContainer {
            capacityProviderStrategyDecoded0 = [CapacityProviderStrategyItem]()
            for structure0 in capacityProviderStrategyContainer {
                capacityProviderStrategyDecoded0?.append(structure0)
            }
        }
        capacityProviderStrategy = capacityProviderStrategyDecoded0
        let launchTypeDecoded = try containerValues.decodeIfPresent(LaunchType.self, forKey: .launchType)
        launchType = launchTypeDecoded
        let platformVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .platformVersion)
        platformVersion = platformVersionDecoded
        let networkConfigurationDecoded = try containerValues.decodeIfPresent(NetworkConfiguration.self, forKey: .networkConfiguration)
        networkConfiguration = networkConfigurationDecoded
        let rolloutStateDecoded = try containerValues.decodeIfPresent(DeploymentRolloutState.self, forKey: .rolloutState)
        rolloutState = rolloutStateDecoded
        let rolloutStateReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .rolloutStateReason)
        rolloutStateReason = rolloutStateReasonDecoded
    }
}
