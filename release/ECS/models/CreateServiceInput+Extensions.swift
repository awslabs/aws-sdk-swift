// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

public struct CreateServiceInputHeadersMiddleware: Middleware {
    public let id: String = "CreateServiceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateServiceInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateServiceInput>
    public typealias MOutput = OperationOutput<CreateServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateServiceOutputError>
}

public struct CreateServiceInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateServiceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateServiceInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateServiceInput>
    public typealias MOutput = OperationOutput<CreateServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateServiceOutputError>
}

public struct CreateServiceInputBodyMiddleware: Middleware {
    public let id: String = "CreateServiceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateServiceInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateServiceInput>
    public typealias MOutput = OperationOutput<CreateServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateServiceOutputError>
}

extension CreateServiceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case capacityProviderStrategy
        case clientToken
        case cluster
        case deploymentConfiguration
        case deploymentController
        case desiredCount
        case enableECSManagedTags
        case enableExecuteCommand
        case healthCheckGracePeriodSeconds
        case launchType
        case loadBalancers
        case networkConfiguration
        case placementConstraints
        case placementStrategy
        case platformVersion
        case propagateTags
        case role
        case schedulingStrategy
        case serviceName
        case serviceRegistries
        case tags
        case taskDefinition
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let capacityProviderStrategy = capacityProviderStrategy {
            var capacityProviderStrategyContainer = encodeContainer.nestedUnkeyedContainer(forKey: .capacityProviderStrategy)
            for capacityproviderstrategy0 in capacityProviderStrategy {
                try capacityProviderStrategyContainer.encode(capacityproviderstrategy0)
            }
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let cluster = cluster {
            try encodeContainer.encode(cluster, forKey: .cluster)
        }
        if let deploymentConfiguration = deploymentConfiguration {
            try encodeContainer.encode(deploymentConfiguration, forKey: .deploymentConfiguration)
        }
        if let deploymentController = deploymentController {
            try encodeContainer.encode(deploymentController, forKey: .deploymentController)
        }
        if let desiredCount = desiredCount {
            try encodeContainer.encode(desiredCount, forKey: .desiredCount)
        }
        if enableECSManagedTags != false {
            try encodeContainer.encode(enableECSManagedTags, forKey: .enableECSManagedTags)
        }
        if enableExecuteCommand != false {
            try encodeContainer.encode(enableExecuteCommand, forKey: .enableExecuteCommand)
        }
        if let healthCheckGracePeriodSeconds = healthCheckGracePeriodSeconds {
            try encodeContainer.encode(healthCheckGracePeriodSeconds, forKey: .healthCheckGracePeriodSeconds)
        }
        if let launchType = launchType {
            try encodeContainer.encode(launchType.rawValue, forKey: .launchType)
        }
        if let loadBalancers = loadBalancers {
            var loadBalancersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .loadBalancers)
            for loadbalancers0 in loadBalancers {
                try loadBalancersContainer.encode(loadbalancers0)
            }
        }
        if let networkConfiguration = networkConfiguration {
            try encodeContainer.encode(networkConfiguration, forKey: .networkConfiguration)
        }
        if let placementConstraints = placementConstraints {
            var placementConstraintsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .placementConstraints)
            for placementconstraints0 in placementConstraints {
                try placementConstraintsContainer.encode(placementconstraints0)
            }
        }
        if let placementStrategy = placementStrategy {
            var placementStrategyContainer = encodeContainer.nestedUnkeyedContainer(forKey: .placementStrategy)
            for placementstrategies0 in placementStrategy {
                try placementStrategyContainer.encode(placementstrategies0)
            }
        }
        if let platformVersion = platformVersion {
            try encodeContainer.encode(platformVersion, forKey: .platformVersion)
        }
        if let propagateTags = propagateTags {
            try encodeContainer.encode(propagateTags.rawValue, forKey: .propagateTags)
        }
        if let role = role {
            try encodeContainer.encode(role, forKey: .role)
        }
        if let schedulingStrategy = schedulingStrategy {
            try encodeContainer.encode(schedulingStrategy.rawValue, forKey: .schedulingStrategy)
        }
        if let serviceName = serviceName {
            try encodeContainer.encode(serviceName, forKey: .serviceName)
        }
        if let serviceRegistries = serviceRegistries {
            var serviceRegistriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .serviceRegistries)
            for serviceregistries0 in serviceRegistries {
                try serviceRegistriesContainer.encode(serviceregistries0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
        if let taskDefinition = taskDefinition {
            try encodeContainer.encode(taskDefinition, forKey: .taskDefinition)
        }
    }
}
