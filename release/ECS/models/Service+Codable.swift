// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension Service: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case capacityProviderStrategy
        case clusterArn
        case createdAt
        case createdBy
        case deploymentConfiguration
        case deploymentController
        case deployments
        case desiredCount
        case enableECSManagedTags
        case enableExecuteCommand
        case events
        case healthCheckGracePeriodSeconds
        case launchType
        case loadBalancers
        case networkConfiguration
        case pendingCount
        case placementConstraints
        case placementStrategy
        case platformVersion
        case propagateTags
        case roleArn
        case runningCount
        case schedulingStrategy
        case serviceArn
        case serviceName
        case serviceRegistries
        case status
        case tags
        case taskDefinition
        case taskSets
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let capacityProviderStrategy = capacityProviderStrategy {
            var capacityProviderStrategyContainer = encodeContainer.nestedUnkeyedContainer(forKey: .capacityProviderStrategy)
            for capacityproviderstrategy0 in capacityProviderStrategy {
                try capacityProviderStrategyContainer.encode(capacityproviderstrategy0)
            }
        }
        if let clusterArn = clusterArn {
            try encodeContainer.encode(clusterArn, forKey: .clusterArn)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let createdBy = createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let deploymentConfiguration = deploymentConfiguration {
            try encodeContainer.encode(deploymentConfiguration, forKey: .deploymentConfiguration)
        }
        if let deploymentController = deploymentController {
            try encodeContainer.encode(deploymentController, forKey: .deploymentController)
        }
        if let deployments = deployments {
            var deploymentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .deployments)
            for deployments0 in deployments {
                try deploymentsContainer.encode(deployments0)
            }
        }
        if desiredCount != 0 {
            try encodeContainer.encode(desiredCount, forKey: .desiredCount)
        }
        if enableECSManagedTags != false {
            try encodeContainer.encode(enableECSManagedTags, forKey: .enableECSManagedTags)
        }
        if enableExecuteCommand != false {
            try encodeContainer.encode(enableExecuteCommand, forKey: .enableExecuteCommand)
        }
        if let events = events {
            var eventsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .events)
            for serviceevents0 in events {
                try eventsContainer.encode(serviceevents0)
            }
        }
        if let healthCheckGracePeriodSeconds = healthCheckGracePeriodSeconds {
            try encodeContainer.encode(healthCheckGracePeriodSeconds, forKey: .healthCheckGracePeriodSeconds)
        }
        if let launchType = launchType {
            try encodeContainer.encode(launchType.rawValue, forKey: .launchType)
        }
        if let loadBalancers = loadBalancers {
            var loadBalancersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .loadBalancers)
            for loadbalancers0 in loadBalancers {
                try loadBalancersContainer.encode(loadbalancers0)
            }
        }
        if let networkConfiguration = networkConfiguration {
            try encodeContainer.encode(networkConfiguration, forKey: .networkConfiguration)
        }
        if pendingCount != 0 {
            try encodeContainer.encode(pendingCount, forKey: .pendingCount)
        }
        if let placementConstraints = placementConstraints {
            var placementConstraintsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .placementConstraints)
            for placementconstraints0 in placementConstraints {
                try placementConstraintsContainer.encode(placementconstraints0)
            }
        }
        if let placementStrategy = placementStrategy {
            var placementStrategyContainer = encodeContainer.nestedUnkeyedContainer(forKey: .placementStrategy)
            for placementstrategies0 in placementStrategy {
                try placementStrategyContainer.encode(placementstrategies0)
            }
        }
        if let platformVersion = platformVersion {
            try encodeContainer.encode(platformVersion, forKey: .platformVersion)
        }
        if let propagateTags = propagateTags {
            try encodeContainer.encode(propagateTags.rawValue, forKey: .propagateTags)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if runningCount != 0 {
            try encodeContainer.encode(runningCount, forKey: .runningCount)
        }
        if let schedulingStrategy = schedulingStrategy {
            try encodeContainer.encode(schedulingStrategy.rawValue, forKey: .schedulingStrategy)
        }
        if let serviceArn = serviceArn {
            try encodeContainer.encode(serviceArn, forKey: .serviceArn)
        }
        if let serviceName = serviceName {
            try encodeContainer.encode(serviceName, forKey: .serviceName)
        }
        if let serviceRegistries = serviceRegistries {
            var serviceRegistriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .serviceRegistries)
            for serviceregistries0 in serviceRegistries {
                try serviceRegistriesContainer.encode(serviceregistries0)
            }
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
        if let taskDefinition = taskDefinition {
            try encodeContainer.encode(taskDefinition, forKey: .taskDefinition)
        }
        if let taskSets = taskSets {
            var taskSetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .taskSets)
            for tasksets0 in taskSets {
                try taskSetsContainer.encode(tasksets0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceArn)
        serviceArn = serviceArnDecoded
        let serviceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
        let clusterArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clusterArn)
        clusterArn = clusterArnDecoded
        let loadBalancersContainer = try containerValues.decodeIfPresent([LoadBalancer].self, forKey: .loadBalancers)
        var loadBalancersDecoded0:[LoadBalancer]? = nil
        if let loadBalancersContainer = loadBalancersContainer {
            loadBalancersDecoded0 = [LoadBalancer]()
            for structure0 in loadBalancersContainer {
                loadBalancersDecoded0?.append(structure0)
            }
        }
        loadBalancers = loadBalancersDecoded0
        let serviceRegistriesContainer = try containerValues.decodeIfPresent([ServiceRegistry].self, forKey: .serviceRegistries)
        var serviceRegistriesDecoded0:[ServiceRegistry]? = nil
        if let serviceRegistriesContainer = serviceRegistriesContainer {
            serviceRegistriesDecoded0 = [ServiceRegistry]()
            for structure0 in serviceRegistriesContainer {
                serviceRegistriesDecoded0?.append(structure0)
            }
        }
        serviceRegistries = serviceRegistriesDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let desiredCountDecoded = try containerValues.decode(Int.self, forKey: .desiredCount)
        desiredCount = desiredCountDecoded
        let runningCountDecoded = try containerValues.decode(Int.self, forKey: .runningCount)
        runningCount = runningCountDecoded
        let pendingCountDecoded = try containerValues.decode(Int.self, forKey: .pendingCount)
        pendingCount = pendingCountDecoded
        let launchTypeDecoded = try containerValues.decodeIfPresent(LaunchType.self, forKey: .launchType)
        launchType = launchTypeDecoded
        let capacityProviderStrategyContainer = try containerValues.decodeIfPresent([CapacityProviderStrategyItem].self, forKey: .capacityProviderStrategy)
        var capacityProviderStrategyDecoded0:[CapacityProviderStrategyItem]? = nil
        if let capacityProviderStrategyContainer = capacityProviderStrategyContainer {
            capacityProviderStrategyDecoded0 = [CapacityProviderStrategyItem]()
            for structure0 in capacityProviderStrategyContainer {
                capacityProviderStrategyDecoded0?.append(structure0)
            }
        }
        capacityProviderStrategy = capacityProviderStrategyDecoded0
        let platformVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .platformVersion)
        platformVersion = platformVersionDecoded
        let taskDefinitionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .taskDefinition)
        taskDefinition = taskDefinitionDecoded
        let deploymentConfigurationDecoded = try containerValues.decodeIfPresent(DeploymentConfiguration.self, forKey: .deploymentConfiguration)
        deploymentConfiguration = deploymentConfigurationDecoded
        let taskSetsContainer = try containerValues.decodeIfPresent([TaskSet].self, forKey: .taskSets)
        var taskSetsDecoded0:[TaskSet]? = nil
        if let taskSetsContainer = taskSetsContainer {
            taskSetsDecoded0 = [TaskSet]()
            for structure0 in taskSetsContainer {
                taskSetsDecoded0?.append(structure0)
            }
        }
        taskSets = taskSetsDecoded0
        let deploymentsContainer = try containerValues.decodeIfPresent([Deployment].self, forKey: .deployments)
        var deploymentsDecoded0:[Deployment]? = nil
        if let deploymentsContainer = deploymentsContainer {
            deploymentsDecoded0 = [Deployment]()
            for structure0 in deploymentsContainer {
                deploymentsDecoded0?.append(structure0)
            }
        }
        deployments = deploymentsDecoded0
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let eventsContainer = try containerValues.decodeIfPresent([ServiceEvent].self, forKey: .events)
        var eventsDecoded0:[ServiceEvent]? = nil
        if let eventsContainer = eventsContainer {
            eventsDecoded0 = [ServiceEvent]()
            for structure0 in eventsContainer {
                eventsDecoded0?.append(structure0)
            }
        }
        events = eventsDecoded0
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let placementConstraintsContainer = try containerValues.decodeIfPresent([PlacementConstraint].self, forKey: .placementConstraints)
        var placementConstraintsDecoded0:[PlacementConstraint]? = nil
        if let placementConstraintsContainer = placementConstraintsContainer {
            placementConstraintsDecoded0 = [PlacementConstraint]()
            for structure0 in placementConstraintsContainer {
                placementConstraintsDecoded0?.append(structure0)
            }
        }
        placementConstraints = placementConstraintsDecoded0
        let placementStrategyContainer = try containerValues.decodeIfPresent([PlacementStrategy].self, forKey: .placementStrategy)
        var placementStrategyDecoded0:[PlacementStrategy]? = nil
        if let placementStrategyContainer = placementStrategyContainer {
            placementStrategyDecoded0 = [PlacementStrategy]()
            for structure0 in placementStrategyContainer {
                placementStrategyDecoded0?.append(structure0)
            }
        }
        placementStrategy = placementStrategyDecoded0
        let networkConfigurationDecoded = try containerValues.decodeIfPresent(NetworkConfiguration.self, forKey: .networkConfiguration)
        networkConfiguration = networkConfigurationDecoded
        let healthCheckGracePeriodSecondsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .healthCheckGracePeriodSeconds)
        healthCheckGracePeriodSeconds = healthCheckGracePeriodSecondsDecoded
        let schedulingStrategyDecoded = try containerValues.decodeIfPresent(SchedulingStrategy.self, forKey: .schedulingStrategy)
        schedulingStrategy = schedulingStrategyDecoded
        let deploymentControllerDecoded = try containerValues.decodeIfPresent(DeploymentController.self, forKey: .deploymentController)
        deploymentController = deploymentControllerDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                tagsDecoded0?.append(structure0)
            }
        }
        tags = tagsDecoded0
        let createdByDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let enableECSManagedTagsDecoded = try containerValues.decode(Bool.self, forKey: .enableECSManagedTags)
        enableECSManagedTags = enableECSManagedTagsDecoded
        let propagateTagsDecoded = try containerValues.decodeIfPresent(PropagateTags.self, forKey: .propagateTags)
        propagateTags = propagateTagsDecoded
        let enableExecuteCommandDecoded = try containerValues.decode(Bool.self, forKey: .enableExecuteCommand)
        enableExecuteCommand = enableExecuteCommandDecoded
    }
}
