// Code generated by smithy-swift-codegen. DO NOT EDIT!



public struct CreateServiceInput: Equatable {
    /// <p>The capacity provider strategy to use for the service.</p>
    /// 		       <p>If a <code>capacityProviderStrategy</code> is specified, the <code>launchType</code>
    /// 			parameter must be omitted. If no <code>capacityProviderStrategy</code> or
    /// 				<code>launchType</code> is specified, the
    /// 				<code>defaultCapacityProviderStrategy</code> for the cluster is used.</p>
    public let capacityProviderStrategy: [CapacityProviderStrategyItem]?
    /// <p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the
    /// 			request. Up to 32 ASCII characters are allowed.</p>
    public let clientToken: String?
    /// <p>The short name or full Amazon Resource Name (ARN) of the cluster on which to run your service.
    /// 			If you do not specify a cluster, the default cluster is assumed.</p>
    public let cluster: String?
    /// <p>Optional deployment parameters that control how many tasks run during the deployment
    /// 			and the ordering of stopping and starting tasks.</p>
    public let deploymentConfiguration: DeploymentConfiguration?
    /// <p>The deployment controller to use for the service. If no deployment controller is
    /// 			specified, the default value of <code>ECS</code> is used.</p>
    public let deploymentController: DeploymentController?
    /// <p>The number of instantiations of the specified task definition to place and keep
    /// 			running on your cluster.</p>
    /// 		       <p>This is required if <code>schedulingStrategy</code> is <code>REPLICA</code> or is not
    /// 			specified. If <code>schedulingStrategy</code> is <code>DAEMON</code> then this is not
    /// 			required.</p>
    public let desiredCount: Int?
    /// <p>Specifies whether to enable Amazon ECS managed tags for the tasks within the service. For
    /// 			more information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-using-tags.html">Tagging Your Amazon ECS
    /// 				Resources</a> in the <i>Amazon Elastic Container Service Developer Guide</i>.</p>
    public let enableECSManagedTags: Bool
    /// <p>Whether or not the execute command functionality is enabled for the service. If
    /// 				<code>true</code>, this enables execute command functionality on all containers in
    /// 			the service tasks.</p>
    public let enableExecuteCommand: Bool
    /// <p>The period of time, in seconds, that the Amazon ECS service scheduler should ignore
    /// 			unhealthy Elastic Load Balancing target health checks after a task has first started. This is only used
    /// 			when your service is configured to use a load balancer. If your service has a load
    /// 			balancer defined and you don't specify a health check grace period value, the default
    /// 			value of <code>0</code> is used.</p>
    /// 		       <p>If your service's tasks take a while to start and respond to Elastic Load Balancing health checks, you
    /// 			can specify a health check grace period of up to 2,147,483,647 seconds. During that
    /// 			time, the Amazon ECS service scheduler ignores health check status. This grace period can
    /// 			prevent the service scheduler from marking tasks as unhealthy and stopping them before
    /// 			they have time to come up.</p>
    public let healthCheckGracePeriodSeconds: Int?
    /// <p>The infrastructure on which to run your service. For more information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/launch_types.html">Amazon ECS
    /// 				launch types</a> in the <i>Amazon Elastic Container Service Developer Guide</i>.</p>
    /// 		       <p>The <code>FARGATE</code> launch type runs your tasks on AWS Fargate On-Demand
    /// 			infrastructure.</p>
    /// 		       <note>
    /// 			         <p>Fargate Spot infrastructure is available for use but a capacity provider
    /// 				strategy must be used. For more information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/userguide/fargate-capacity-providers.html">AWS Fargate capacity providers</a> in the
    /// 					<i>Amazon ECS User Guide for AWS Fargate</i>.</p>
    /// 		       </note>
    /// 		       <p>The <code>EC2</code> launch type runs your tasks on Amazon EC2 instances registered to your
    /// 			cluster.</p>
    /// 		       <p>The <code>EXTERNAL</code> launch type runs your tasks on your on-premise server or
    /// 			virtual machine (VM) capacity registered to your cluster.</p>
    /// 		       <p>A service can use either a launch type or a capacity provider strategy. If a
    /// 				<code>launchType</code> is specified, the <code>capacityProviderStrategy</code>
    /// 			parameter must be omitted.</p>
    public let launchType: LaunchType?
    /// <p>A load balancer object representing the load balancers to use with your service. For
    /// 			more information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/service-load-balancing.html">Service Load Balancing</a> in the
    /// 				<i>Amazon Elastic Container Service Developer Guide</i>.</p>
    /// 		       <p>If the service is using the rolling update (<code>ECS</code>) deployment controller
    /// 			and using either an Application Load Balancer or Network Load Balancer, you must specify one or more target group ARNs to
    /// 			attach to the service. The service-linked role is required for services that make use of
    /// 			multiple target groups. For more information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/using-service-linked-roles.html">Using service-linked roles for Amazon ECS</a> in the
    /// 				<i>Amazon Elastic Container Service Developer Guide</i>.</p>
    /// 		       <p>If the service is using the <code>CODE_DEPLOY</code> deployment controller, the
    /// 			service is required to use either an Application Load Balancer or Network Load Balancer. When creating an AWS CodeDeploy deployment
    /// 			group, you specify two target groups (referred to as a <code>targetGroupPair</code>).
    /// 			During a deployment, AWS CodeDeploy determines which task set in your service has the status
    /// 				<code>PRIMARY</code> and associates one target group with it, and then associates
    /// 			the other target group with the replacement task set. The load balancer can also have up
    /// 			to two listeners: a required listener for production traffic and an optional listener
    /// 			that allows you perform validation tests with Lambda functions before routing production
    /// 			traffic to it.</p>
    /// 		       <p>After you create a service using the <code>ECS</code> deployment controller, the load
    /// 			balancer name or target group ARN, container name, and container port specified in the
    /// 			service definition are immutable. If you are using the <code>CODE_DEPLOY</code>
    /// 			deployment controller, these values can be changed when updating the service.</p>
    /// 		       <p>For Application Load Balancers and Network Load Balancers, this object must contain the load balancer target group ARN,
    /// 			the container name (as it appears in a container definition), and the container port to
    /// 			access from the load balancer. The load balancer name parameter must be omitted. When a
    /// 			task from this service is placed on a container instance, the container instance and
    /// 			port combination is registered as a target in the target group specified here.</p>
    /// 		       <p>For Classic Load Balancers, this object must contain the load balancer name, the container name (as it
    /// 			appears in a container definition), and the container port to access from the load
    /// 			balancer. The target group ARN parameter must be omitted. When a task from this service
    /// 			is placed on a container instance, the container instance is registered with the load
    /// 			balancer specified here.</p>
    /// 		       <p>Services with tasks that use the <code>awsvpc</code> network mode (for example, those
    /// 			with the Fargate launch type) only support Application Load Balancers and Network Load Balancers. Classic Load Balancers are
    /// 			not supported. Also, when you create any target groups for these services, you must
    /// 			choose <code>ip</code> as the target type, not <code>instance</code>, because tasks that
    /// 			use the <code>awsvpc</code> network mode are associated with an elastic network
    /// 			interface, not an Amazon EC2 instance.</p>
    public let loadBalancers: [LoadBalancer]?
    /// <p>The network configuration for the service. This parameter is required for task
    /// 			definitions that use the <code>awsvpc</code> network mode to receive their own elastic
    /// 			network interface, and it is not supported for other network modes. For more
    /// 			information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task-networking.html">Task networking</a>
    /// 			in the <i>Amazon Elastic Container Service Developer Guide</i>.</p>
    public let networkConfiguration: NetworkConfiguration?
    /// <p>An array of placement constraint objects to use for tasks in your service. You can
    /// 			specify a maximum of 10 constraints per task (this limit includes constraints in the
    /// 			task definition and those specified at runtime). </p>
    public let placementConstraints: [PlacementConstraint]?
    /// <p>The placement strategy objects to use for tasks in your service. You can specify a
    /// 			maximum of five strategy rules per service.</p>
    public let placementStrategy: [PlacementStrategy]?
    /// <p>The platform version that your tasks in the service are running on. A platform version
    /// 			is specified only for tasks using the Fargate launch type. If one isn't
    /// 			specified, the <code>LATEST</code> platform version is used by default. For more
    /// 			information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/platform_versions.html">AWS Fargate platform
    /// 				versions</a> in the <i>Amazon Elastic Container Service Developer Guide</i>.</p>
    public let platformVersion: String?
    /// <p>Specifies whether to propagate the tags from the task definition or the service to the
    /// 			tasks in the service. If no value is specified, the tags are not propagated. Tags can
    /// 			only be propagated to the tasks within the service during service creation. To add tags
    /// 			to a task after service creation, use the <a>TagResource</a> API
    /// 			action.</p>
    public let propagateTags: PropagateTags?
    /// <p>The name or full Amazon Resource Name (ARN) of the IAM role that allows Amazon ECS to make calls to your
    /// 			load balancer on your behalf. This parameter is only permitted if you are using a load
    /// 			balancer with your service and your task definition does not use the <code>awsvpc</code>
    /// 			network mode. If you specify the <code>role</code> parameter, you must also specify a
    /// 			load balancer object with the <code>loadBalancers</code> parameter.</p>
    /// 		       <important>
    /// 			         <p>If your account has already created the Amazon ECS service-linked role, that role is
    /// 				used by default for your service unless you specify a role here. The service-linked
    /// 				role is required if your task definition uses the <code>awsvpc</code> network mode
    /// 				or if the service is configured to use service discovery, an external deployment
    /// 				controller, multiple target groups, or Elastic Inference accelerators in which case
    /// 				you should not specify a role here. For more information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/using-service-linked-roles.html">Using
    /// 					service-linked roles for Amazon ECS</a> in the
    /// 					<i>Amazon Elastic Container Service Developer Guide</i>.</p>
    /// 		       </important>
    /// 		       <p>If your specified role has a path other than <code>/</code>, then you must either
    /// 			specify the full role ARN (this is recommended) or prefix the role name with the path.
    /// 			For example, if a role with the name <code>bar</code> has a path of <code>/foo/</code>
    /// 			then you would specify <code>/foo/bar</code> as the role name. For more information, see
    /// 				<a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html#identifiers-friendly-names">Friendly names and paths</a> in the <i>IAM User Guide</i>.</p>
    public let role: String?
    /// <p>The scheduling strategy to use for the service. For more information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs_services.html">Services</a>.</p>
    /// 		       <p>There are two service scheduler strategies available:</p>
    /// 		       <ul>
    ///             <li>
    /// 				           <p>
    ///                   <code>REPLICA</code>-The replica scheduling strategy places and
    /// 					maintains the desired number of tasks across your cluster. By default, the
    /// 					service scheduler spreads tasks across Availability Zones. You can use task
    /// 					placement strategies and constraints to customize task placement decisions. This
    /// 					scheduler strategy is required if the service is using the
    /// 						<code>CODE_DEPLOY</code> or <code>EXTERNAL</code> deployment controller
    /// 					types.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>
    ///                   <code>DAEMON</code>-The daemon scheduling strategy deploys exactly one
    /// 					task on each active container instance that meets all of the task placement
    /// 					constraints that you specify in your cluster. The service scheduler also
    /// 					evaluates the task placement constraints for running tasks and will stop tasks
    /// 					that do not meet the placement constraints. When you're using this strategy, you
    /// 					don't need to specify a desired number of tasks, a task placement strategy, or
    /// 					use Service Auto Scaling policies.</p>
    /// 				           <note>
    /// 					             <p>Tasks using the Fargate launch type or the
    /// 							<code>CODE_DEPLOY</code> or <code>EXTERNAL</code> deployment controller
    /// 						types don't support the <code>DAEMON</code> scheduling strategy.</p>
    /// 				           </note>
    /// 			         </li>
    ///          </ul>
    public let schedulingStrategy: SchedulingStrategy?
    /// <p>The name of your service. Up to 255 letters (uppercase and lowercase), numbers, underscores, and hyphens are allowed. Service names must be unique within
    /// 			a cluster, but you can have similarly named services in multiple clusters within a
    /// 			Region or across multiple Regions.</p>
    public let serviceName: String?
    /// <p>The details of the service discovery registry to associate with this service. For more
    /// 			information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/service-discovery.html">Service
    /// 				discovery</a>.</p>
    /// 		       <note>
    /// 			         <p>Each service may be associated with one service registry. Multiple service
    /// 				registries per service isn't supported.</p>
    /// 		       </note>
    public let serviceRegistries: [ServiceRegistry]?
    /// <p>The metadata that you apply to the service to help you categorize and organize them.
    /// 			Each tag consists of a key and an optional value, both of which you define. When a
    /// 			service is deleted, the tags are deleted as well.</p>
    ///          <p>The following basic restrictions apply to tags:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>Maximum number of tags per resource - 50</p>
    ///             </li>
    ///             <li>
    ///                 <p>For each resource, each tag key must be unique, and each tag key can have only
    ///                     one value.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Maximum key length - 128 Unicode characters in UTF-8</p>
    ///             </li>
    ///             <li>
    ///                 <p>Maximum value length - 256 Unicode characters in UTF-8</p>
    ///             </li>
    ///             <li>
    ///                 <p>If your tagging schema is used across multiple services and resources,
    ///                     remember that other services may have restrictions on allowed characters.
    ///                     Generally allowed characters are: letters, numbers, and spaces representable in
    ///                     UTF-8, and the following characters: + - = . _ : / @.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Tag keys and values are case-sensitive.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Do not use <code>aws:</code>, <code>AWS:</code>, or any upper or lowercase
    ///                     combination of such as a prefix for either keys or values as it is reserved for
    ///                     AWS use. You cannot edit or delete tag keys or values with this prefix. Tags with
    ///                     this prefix do not count against your tags per resource limit.</p>
    ///             </li>
    ///          </ul>
    public let tags: [Tag]?
    /// <p>The <code>family</code> and <code>revision</code> (<code>family:revision</code>) or
    /// 			full ARN of the task definition to run in your service. If a <code>revision</code> is
    /// 			not specified, the latest <code>ACTIVE</code> revision is used.</p>
    /// 		       <p>A task definition must be specified if the service is using either the
    /// 				<code>ECS</code> or <code>CODE_DEPLOY</code> deployment controllers.</p>
    public let taskDefinition: String?

    public init (
        capacityProviderStrategy: [CapacityProviderStrategyItem]? = nil,
        clientToken: String? = nil,
        cluster: String? = nil,
        deploymentConfiguration: DeploymentConfiguration? = nil,
        deploymentController: DeploymentController? = nil,
        desiredCount: Int? = nil,
        enableECSManagedTags: Bool = false,
        enableExecuteCommand: Bool = false,
        healthCheckGracePeriodSeconds: Int? = nil,
        launchType: LaunchType? = nil,
        loadBalancers: [LoadBalancer]? = nil,
        networkConfiguration: NetworkConfiguration? = nil,
        placementConstraints: [PlacementConstraint]? = nil,
        placementStrategy: [PlacementStrategy]? = nil,
        platformVersion: String? = nil,
        propagateTags: PropagateTags? = nil,
        role: String? = nil,
        schedulingStrategy: SchedulingStrategy? = nil,
        serviceName: String? = nil,
        serviceRegistries: [ServiceRegistry]? = nil,
        tags: [Tag]? = nil,
        taskDefinition: String? = nil
    )
    {
        self.capacityProviderStrategy = capacityProviderStrategy
        self.clientToken = clientToken
        self.cluster = cluster
        self.deploymentConfiguration = deploymentConfiguration
        self.deploymentController = deploymentController
        self.desiredCount = desiredCount
        self.enableECSManagedTags = enableECSManagedTags
        self.enableExecuteCommand = enableExecuteCommand
        self.healthCheckGracePeriodSeconds = healthCheckGracePeriodSeconds
        self.launchType = launchType
        self.loadBalancers = loadBalancers
        self.networkConfiguration = networkConfiguration
        self.placementConstraints = placementConstraints
        self.placementStrategy = placementStrategy
        self.platformVersion = platformVersion
        self.propagateTags = propagateTags
        self.role = role
        self.schedulingStrategy = schedulingStrategy
        self.serviceName = serviceName
        self.serviceRegistries = serviceRegistries
        self.tags = tags
        self.taskDefinition = taskDefinition
    }
}

extension CreateServiceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateServiceInput(capacityProviderStrategy: \(String(describing: capacityProviderStrategy)), clientToken: \(String(describing: clientToken)), cluster: \(String(describing: cluster)), deploymentConfiguration: \(String(describing: deploymentConfiguration)), deploymentController: \(String(describing: deploymentController)), desiredCount: \(String(describing: desiredCount)), enableECSManagedTags: \(String(describing: enableECSManagedTags)), enableExecuteCommand: \(String(describing: enableExecuteCommand)), healthCheckGracePeriodSeconds: \(String(describing: healthCheckGracePeriodSeconds)), launchType: \(String(describing: launchType)), loadBalancers: \(String(describing: loadBalancers)), networkConfiguration: \(String(describing: networkConfiguration)), placementConstraints: \(String(describing: placementConstraints)), placementStrategy: \(String(describing: placementStrategy)), platformVersion: \(String(describing: platformVersion)), propagateTags: \(String(describing: propagateTags)), role: \(String(describing: role)), schedulingStrategy: \(String(describing: schedulingStrategy)), serviceName: \(String(describing: serviceName)), serviceRegistries: \(String(describing: serviceRegistries)), tags: \(String(describing: tags)), taskDefinition: \(String(describing: taskDefinition)))"}
}
