// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

struct RegisterTaskDefinitionInputBody: Equatable {
    public let family: String?
    public let taskRoleArn: String?
    public let executionRoleArn: String?
    public let networkMode: NetworkMode?
    public let containerDefinitions: [ContainerDefinition]?
    public let volumes: [Volume]?
    public let placementConstraints: [TaskDefinitionPlacementConstraint]?
    public let requiresCompatibilities: [Compatibility]?
    public let cpu: String?
    public let memory: String?
    public let tags: [Tag]?
    public let pidMode: PidMode?
    public let ipcMode: IpcMode?
    public let proxyConfiguration: ProxyConfiguration?
    public let inferenceAccelerators: [InferenceAccelerator]?
    public let ephemeralStorage: EphemeralStorage?
}

extension RegisterTaskDefinitionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case containerDefinitions
        case cpu
        case ephemeralStorage
        case executionRoleArn
        case family
        case inferenceAccelerators
        case ipcMode
        case memory
        case networkMode
        case pidMode
        case placementConstraints
        case proxyConfiguration
        case requiresCompatibilities
        case tags
        case taskRoleArn
        case volumes
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let familyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .family)
        family = familyDecoded
        let taskRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .taskRoleArn)
        taskRoleArn = taskRoleArnDecoded
        let executionRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .executionRoleArn)
        executionRoleArn = executionRoleArnDecoded
        let networkModeDecoded = try containerValues.decodeIfPresent(NetworkMode.self, forKey: .networkMode)
        networkMode = networkModeDecoded
        let containerDefinitionsContainer = try containerValues.decodeIfPresent([ContainerDefinition].self, forKey: .containerDefinitions)
        var containerDefinitionsDecoded0:[ContainerDefinition]? = nil
        if let containerDefinitionsContainer = containerDefinitionsContainer {
            containerDefinitionsDecoded0 = [ContainerDefinition]()
            for structure0 in containerDefinitionsContainer {
                containerDefinitionsDecoded0?.append(structure0)
            }
        }
        containerDefinitions = containerDefinitionsDecoded0
        let volumesContainer = try containerValues.decodeIfPresent([Volume].self, forKey: .volumes)
        var volumesDecoded0:[Volume]? = nil
        if let volumesContainer = volumesContainer {
            volumesDecoded0 = [Volume]()
            for structure0 in volumesContainer {
                volumesDecoded0?.append(structure0)
            }
        }
        volumes = volumesDecoded0
        let placementConstraintsContainer = try containerValues.decodeIfPresent([TaskDefinitionPlacementConstraint].self, forKey: .placementConstraints)
        var placementConstraintsDecoded0:[TaskDefinitionPlacementConstraint]? = nil
        if let placementConstraintsContainer = placementConstraintsContainer {
            placementConstraintsDecoded0 = [TaskDefinitionPlacementConstraint]()
            for structure0 in placementConstraintsContainer {
                placementConstraintsDecoded0?.append(structure0)
            }
        }
        placementConstraints = placementConstraintsDecoded0
        let requiresCompatibilitiesContainer = try containerValues.decodeIfPresent([Compatibility].self, forKey: .requiresCompatibilities)
        var requiresCompatibilitiesDecoded0:[Compatibility]? = nil
        if let requiresCompatibilitiesContainer = requiresCompatibilitiesContainer {
            requiresCompatibilitiesDecoded0 = [Compatibility]()
            for string0 in requiresCompatibilitiesContainer {
                requiresCompatibilitiesDecoded0?.append(string0)
            }
        }
        requiresCompatibilities = requiresCompatibilitiesDecoded0
        let cpuDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cpu)
        cpu = cpuDecoded
        let memoryDecoded = try containerValues.decodeIfPresent(String.self, forKey: .memory)
        memory = memoryDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                tagsDecoded0?.append(structure0)
            }
        }
        tags = tagsDecoded0
        let pidModeDecoded = try containerValues.decodeIfPresent(PidMode.self, forKey: .pidMode)
        pidMode = pidModeDecoded
        let ipcModeDecoded = try containerValues.decodeIfPresent(IpcMode.self, forKey: .ipcMode)
        ipcMode = ipcModeDecoded
        let proxyConfigurationDecoded = try containerValues.decodeIfPresent(ProxyConfiguration.self, forKey: .proxyConfiguration)
        proxyConfiguration = proxyConfigurationDecoded
        let inferenceAcceleratorsContainer = try containerValues.decodeIfPresent([InferenceAccelerator].self, forKey: .inferenceAccelerators)
        var inferenceAcceleratorsDecoded0:[InferenceAccelerator]? = nil
        if let inferenceAcceleratorsContainer = inferenceAcceleratorsContainer {
            inferenceAcceleratorsDecoded0 = [InferenceAccelerator]()
            for structure0 in inferenceAcceleratorsContainer {
                inferenceAcceleratorsDecoded0?.append(structure0)
            }
        }
        inferenceAccelerators = inferenceAcceleratorsDecoded0
        let ephemeralStorageDecoded = try containerValues.decodeIfPresent(EphemeralStorage.self, forKey: .ephemeralStorage)
        ephemeralStorage = ephemeralStorageDecoded
    }
}
