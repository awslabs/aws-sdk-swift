// Code generated by smithy-swift-codegen. DO NOT EDIT!



public struct UpdateServiceInput: Equatable {
    /// <p>The capacity provider strategy to update the service to use.</p>
    /// 		       <p>If the service is using the default capacity provider strategy for the cluster, the
    /// 			service can be updated to use one or more capacity providers as opposed to the default
    /// 			capacity provider strategy. However, when a service is using a capacity provider
    /// 			strategy that is not the default capacity provider strategy, the service cannot be
    /// 			updated to use the cluster's default capacity provider strategy.</p>
    /// 		       <p>A capacity provider strategy consists of one or more capacity providers along with the
    /// 				<code>base</code> and <code>weight</code> to assign to them. A capacity provider
    /// 			must be associated with the cluster to be used in a capacity provider strategy. The
    /// 				<a>PutClusterCapacityProviders</a> API is used to associate a capacity
    /// 			provider with a cluster. Only capacity providers with an <code>ACTIVE</code> or
    /// 				<code>UPDATING</code> status can be used.</p>
    /// 		       <p>If specifying a capacity provider that uses an Auto Scaling group, the capacity
    /// 			provider must already be created. New capacity providers can be created with the <a>CreateCapacityProvider</a> API operation.</p>
    /// 		       <p>To use a AWS Fargate capacity provider, specify either the <code>FARGATE</code> or
    /// 				<code>FARGATE_SPOT</code> capacity providers. The AWS Fargate capacity providers are
    /// 			available to all accounts and only need to be associated with a cluster to be
    /// 			used.</p>
    /// 		       <p>The <a>PutClusterCapacityProviders</a> API operation is used to update the
    /// 			list of available capacity providers for a cluster after the cluster is created.</p>
    /// 		       <p></p>
    public let capacityProviderStrategy: [CapacityProviderStrategyItem]?
    /// <p>The short name or full Amazon Resource Name (ARN) of the cluster that your service is running on.
    /// 			If you do not specify a cluster, the default cluster is assumed.</p>
    public let cluster: String?
    /// <p>Optional deployment parameters that control how many tasks run during the deployment
    /// 			and the ordering of stopping and starting tasks.</p>
    public let deploymentConfiguration: DeploymentConfiguration?
    /// <p>The number of instantiations of the task to place and keep running in your
    /// 			service.</p>
    public let desiredCount: Int?
    /// <p>If <code>true</code>, this enables execute command functionality on all task
    /// 			containers.</p>
    /// 		       <p>If you do not want to override the value that was set when the service was created,
    /// 			you can set this to <code>null</code> when performing this action.</p>
    public let enableExecuteCommand: Bool?
    /// <p>Whether to force a new deployment of the service. Deployments are not forced by
    /// 			default. You can use this option to trigger a new deployment with no service definition
    /// 			changes. For example, you can update a service's tasks to use a newer Docker image with
    /// 			the same image/tag combination (<code>my_image:latest</code>) or to roll Fargate tasks
    /// 			onto a newer platform version.</p>
    public let forceNewDeployment: Bool
    /// <p>The period of time, in seconds, that the Amazon ECS service scheduler should ignore
    /// 			unhealthy Elastic Load Balancing target health checks after a task has first started. This is only valid
    /// 			if your service is configured to use a load balancer. If your service's tasks take a
    /// 			while to start and respond to Elastic Load Balancing health checks, you can specify a health check grace
    /// 			period of up to 2,147,483,647 seconds. During that time, the Amazon ECS service
    /// 			scheduler ignores the Elastic Load Balancing health check status. This grace period can prevent the ECS
    /// 			service scheduler from marking tasks as unhealthy and stopping them before they have
    /// 			time to come up.</p>
    public let healthCheckGracePeriodSeconds: Int?
    /// <p>An object representing the network configuration for the service.</p>
    public let networkConfiguration: NetworkConfiguration?
    /// <p>An array of task placement constraint objects to update the service to use. If no
    /// 			value is specified, the existing placement constraints for the service will remain
    /// 			unchanged. If this value is specified, it will override any existing placement
    /// 			constraints defined for the service. To remove all existing placement constraints,
    /// 			specify an empty array.</p>
    /// 		       <p>You can specify a maximum of 10 constraints per task (this limit includes constraints
    /// 			in the task definition and those specified at runtime).</p>
    public let placementConstraints: [PlacementConstraint]?
    /// <p>The task placement strategy objects to update the service to use. If no value is
    /// 			specified, the existing placement strategy for the service will remain unchanged. If
    /// 			this value is specified, it will override the existing placement strategy defined for
    /// 			the service. To remove an existing placement strategy, specify an empty object.</p>
    /// 		       <p>You can specify a maximum of five strategy rules per service.</p>
    public let placementStrategy: [PlacementStrategy]?
    /// <p>The platform version on which your tasks in the service are running. A platform
    /// 			version is only specified for tasks using the Fargate launch type. If a
    /// 			platform version is not specified, the <code>LATEST</code> platform version is used by
    /// 			default. For more information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/platform_versions.html">AWS Fargate Platform
    /// 				Versions</a> in the <i>Amazon Elastic Container Service Developer Guide</i>.</p>
    public let platformVersion: String?
    /// <p>The name of the service to update.</p>
    public let service: String?
    /// <p>The <code>family</code> and <code>revision</code> (<code>family:revision</code>) or
    /// 			full ARN of the task definition to run in your service. If a <code>revision</code> is
    /// 			not specified, the latest <code>ACTIVE</code> revision is used. If you modify the task
    /// 			definition with <code>UpdateService</code>, Amazon ECS spawns a task with the new version of
    /// 			the task definition and then stops an old task after the new version is running.</p>
    public let taskDefinition: String?

    public init (
        capacityProviderStrategy: [CapacityProviderStrategyItem]? = nil,
        cluster: String? = nil,
        deploymentConfiguration: DeploymentConfiguration? = nil,
        desiredCount: Int? = nil,
        enableExecuteCommand: Bool? = nil,
        forceNewDeployment: Bool = false,
        healthCheckGracePeriodSeconds: Int? = nil,
        networkConfiguration: NetworkConfiguration? = nil,
        placementConstraints: [PlacementConstraint]? = nil,
        placementStrategy: [PlacementStrategy]? = nil,
        platformVersion: String? = nil,
        service: String? = nil,
        taskDefinition: String? = nil
    )
    {
        self.capacityProviderStrategy = capacityProviderStrategy
        self.cluster = cluster
        self.deploymentConfiguration = deploymentConfiguration
        self.desiredCount = desiredCount
        self.enableExecuteCommand = enableExecuteCommand
        self.forceNewDeployment = forceNewDeployment
        self.healthCheckGracePeriodSeconds = healthCheckGracePeriodSeconds
        self.networkConfiguration = networkConfiguration
        self.placementConstraints = placementConstraints
        self.placementStrategy = placementStrategy
        self.platformVersion = platformVersion
        self.service = service
        self.taskDefinition = taskDefinition
    }
}

extension UpdateServiceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateServiceInput(capacityProviderStrategy: \(String(describing: capacityProviderStrategy)), cluster: \(String(describing: cluster)), deploymentConfiguration: \(String(describing: deploymentConfiguration)), desiredCount: \(String(describing: desiredCount)), enableExecuteCommand: \(String(describing: enableExecuteCommand)), forceNewDeployment: \(String(describing: forceNewDeployment)), healthCheckGracePeriodSeconds: \(String(describing: healthCheckGracePeriodSeconds)), networkConfiguration: \(String(describing: networkConfiguration)), placementConstraints: \(String(describing: placementConstraints)), placementStrategy: \(String(describing: placementStrategy)), platformVersion: \(String(describing: platformVersion)), service: \(String(describing: service)), taskDefinition: \(String(describing: taskDefinition)))"}
}
