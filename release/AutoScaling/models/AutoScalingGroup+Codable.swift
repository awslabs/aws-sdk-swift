// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension AutoScalingGroup: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case autoScalingGroupARN = "AutoScalingGroupARN"
        case autoScalingGroupName = "AutoScalingGroupName"
        case availabilityZones = "AvailabilityZones"
        case capacityRebalance = "CapacityRebalance"
        case createdTime = "CreatedTime"
        case defaultCooldown = "DefaultCooldown"
        case desiredCapacity = "DesiredCapacity"
        case enabledMetrics = "EnabledMetrics"
        case healthCheckGracePeriod = "HealthCheckGracePeriod"
        case healthCheckType = "HealthCheckType"
        case instances = "Instances"
        case launchConfigurationName = "LaunchConfigurationName"
        case launchTemplate = "LaunchTemplate"
        case loadBalancerNames = "LoadBalancerNames"
        case maxInstanceLifetime = "MaxInstanceLifetime"
        case maxSize = "MaxSize"
        case minSize = "MinSize"
        case mixedInstancesPolicy = "MixedInstancesPolicy"
        case newInstancesProtectedFromScaleIn = "NewInstancesProtectedFromScaleIn"
        case placementGroup = "PlacementGroup"
        case predictedCapacity = "PredictedCapacity"
        case serviceLinkedRoleARN = "ServiceLinkedRoleARN"
        case status = "Status"
        case suspendedProcesses = "SuspendedProcesses"
        case tags = "Tags"
        case targetGroupARNs = "TargetGroupARNs"
        case terminationPolicies = "TerminationPolicies"
        case vPCZoneIdentifier = "VPCZoneIdentifier"
        case warmPoolConfiguration = "WarmPoolConfiguration"
        case warmPoolSize = "WarmPoolSize"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let autoScalingGroupARN = autoScalingGroupARN {
            try container.encode(autoScalingGroupARN, forKey: Key("AutoScalingGroupARN"))
        }
        if let autoScalingGroupName = autoScalingGroupName {
            try container.encode(autoScalingGroupName, forKey: Key("AutoScalingGroupName"))
        }
        if let availabilityZones = availabilityZones {
            var availabilityZonesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("AvailabilityZones"))
            for (index0, xmlstringmaxlen2550) in availabilityZones.enumerated() {
                try availabilityZonesContainer.encode(xmlstringmaxlen2550, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let capacityRebalance = capacityRebalance {
            try container.encode(capacityRebalance, forKey: Key("CapacityRebalance"))
        }
        if let createdTime = createdTime {
            try container.encode(TimestampWrapper(createdTime, format: .dateTime), forKey: Key("createdTime"))
        }
        if let defaultCooldown = defaultCooldown {
            try container.encode(defaultCooldown, forKey: Key("DefaultCooldown"))
        }
        if let desiredCapacity = desiredCapacity {
            try container.encode(desiredCapacity, forKey: Key("DesiredCapacity"))
        }
        if let enabledMetrics = enabledMetrics {
            var enabledMetricsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("EnabledMetrics"))
            for (index0, enabledmetric0) in enabledMetrics.enumerated() {
                try enabledMetricsContainer.encode(enabledmetric0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let healthCheckGracePeriod = healthCheckGracePeriod {
            try container.encode(healthCheckGracePeriod, forKey: Key("HealthCheckGracePeriod"))
        }
        if let healthCheckType = healthCheckType {
            try container.encode(healthCheckType, forKey: Key("HealthCheckType"))
        }
        if let instances = instances {
            var instancesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Instances"))
            for (index0, instance0) in instances.enumerated() {
                try instancesContainer.encode(instance0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let launchConfigurationName = launchConfigurationName {
            try container.encode(launchConfigurationName, forKey: Key("LaunchConfigurationName"))
        }
        if let launchTemplate = launchTemplate {
            try container.encode(launchTemplate, forKey: Key("LaunchTemplate"))
        }
        if let loadBalancerNames = loadBalancerNames {
            var loadBalancerNamesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("LoadBalancerNames"))
            for (index0, xmlstringmaxlen2550) in loadBalancerNames.enumerated() {
                try loadBalancerNamesContainer.encode(xmlstringmaxlen2550, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let maxInstanceLifetime = maxInstanceLifetime {
            try container.encode(maxInstanceLifetime, forKey: Key("MaxInstanceLifetime"))
        }
        if let maxSize = maxSize {
            try container.encode(maxSize, forKey: Key("MaxSize"))
        }
        if let minSize = minSize {
            try container.encode(minSize, forKey: Key("MinSize"))
        }
        if let mixedInstancesPolicy = mixedInstancesPolicy {
            try container.encode(mixedInstancesPolicy, forKey: Key("MixedInstancesPolicy"))
        }
        if let newInstancesProtectedFromScaleIn = newInstancesProtectedFromScaleIn {
            try container.encode(newInstancesProtectedFromScaleIn, forKey: Key("NewInstancesProtectedFromScaleIn"))
        }
        if let placementGroup = placementGroup {
            try container.encode(placementGroup, forKey: Key("PlacementGroup"))
        }
        if let predictedCapacity = predictedCapacity {
            try container.encode(predictedCapacity, forKey: Key("PredictedCapacity"))
        }
        if let serviceLinkedRoleARN = serviceLinkedRoleARN {
            try container.encode(serviceLinkedRoleARN, forKey: Key("ServiceLinkedRoleARN"))
        }
        if let status = status {
            try container.encode(status, forKey: Key("Status"))
        }
        if let suspendedProcesses = suspendedProcesses {
            var suspendedProcessesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("SuspendedProcesses"))
            for (index0, suspendedprocess0) in suspendedProcesses.enumerated() {
                try suspendedProcessesContainer.encode(suspendedprocess0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Tags"))
            for (index0, tagdescription0) in tags.enumerated() {
                try tagsContainer.encode(tagdescription0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let targetGroupARNs = targetGroupARNs {
            var targetGroupARNsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("TargetGroupARNs"))
            for (index0, xmlstringmaxlen5110) in targetGroupARNs.enumerated() {
                try targetGroupARNsContainer.encode(xmlstringmaxlen5110, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let terminationPolicies = terminationPolicies {
            var terminationPoliciesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("TerminationPolicies"))
            for (index0, xmlstringmaxlen16000) in terminationPolicies.enumerated() {
                try terminationPoliciesContainer.encode(xmlstringmaxlen16000, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let vPCZoneIdentifier = vPCZoneIdentifier {
            try container.encode(vPCZoneIdentifier, forKey: Key("VPCZoneIdentifier"))
        }
        if let warmPoolConfiguration = warmPoolConfiguration {
            try container.encode(warmPoolConfiguration, forKey: Key("WarmPoolConfiguration"))
        }
        if let warmPoolSize = warmPoolSize {
            try container.encode(warmPoolSize, forKey: Key("WarmPoolSize"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoScalingGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .autoScalingGroupName)
        autoScalingGroupName = autoScalingGroupNameDecoded
        let autoScalingGroupARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .autoScalingGroupARN)
        autoScalingGroupARN = autoScalingGroupARNDecoded
        let launchConfigurationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .launchConfigurationName)
        launchConfigurationName = launchConfigurationNameDecoded
        let launchTemplateDecoded = try containerValues.decodeIfPresent(LaunchTemplateSpecification.self, forKey: .launchTemplate)
        launchTemplate = launchTemplateDecoded
        let mixedInstancesPolicyDecoded = try containerValues.decodeIfPresent(MixedInstancesPolicy.self, forKey: .mixedInstancesPolicy)
        mixedInstancesPolicy = mixedInstancesPolicyDecoded
        let minSizeDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .minSize)
        minSize = minSizeDecoded
        let maxSizeDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxSize)
        maxSize = maxSizeDecoded
        let desiredCapacityDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .desiredCapacity)
        desiredCapacity = desiredCapacityDecoded
        let predictedCapacityDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .predictedCapacity)
        predictedCapacity = predictedCapacityDecoded
        let defaultCooldownDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .defaultCooldown)
        defaultCooldown = defaultCooldownDecoded
        if containerValues.contains(.availabilityZones) {
            struct KeyVal0{struct member{}}
            let availabilityZonesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .availabilityZones)
            if let availabilityZonesWrappedContainer = availabilityZonesWrappedContainer {
                let availabilityZonesContainer = try availabilityZonesWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var availabilityZonesBuffer:[String]? = nil
                if let availabilityZonesContainer = availabilityZonesContainer {
                    availabilityZonesBuffer = [String]()
                    for stringContainer0 in availabilityZonesContainer {
                        availabilityZonesBuffer?.append(stringContainer0)
                    }
                }
                availabilityZones = availabilityZonesBuffer
            } else {
                availabilityZones = []
            }
        } else {
            availabilityZones = nil
        }
        if containerValues.contains(.loadBalancerNames) {
            struct KeyVal0{struct member{}}
            let loadBalancerNamesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .loadBalancerNames)
            if let loadBalancerNamesWrappedContainer = loadBalancerNamesWrappedContainer {
                let loadBalancerNamesContainer = try loadBalancerNamesWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var loadBalancerNamesBuffer:[String]? = nil
                if let loadBalancerNamesContainer = loadBalancerNamesContainer {
                    loadBalancerNamesBuffer = [String]()
                    for stringContainer0 in loadBalancerNamesContainer {
                        loadBalancerNamesBuffer?.append(stringContainer0)
                    }
                }
                loadBalancerNames = loadBalancerNamesBuffer
            } else {
                loadBalancerNames = []
            }
        } else {
            loadBalancerNames = nil
        }
        if containerValues.contains(.targetGroupARNs) {
            struct KeyVal0{struct member{}}
            let targetGroupARNsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .targetGroupARNs)
            if let targetGroupARNsWrappedContainer = targetGroupARNsWrappedContainer {
                let targetGroupARNsContainer = try targetGroupARNsWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var targetGroupARNsBuffer:[String]? = nil
                if let targetGroupARNsContainer = targetGroupARNsContainer {
                    targetGroupARNsBuffer = [String]()
                    for stringContainer0 in targetGroupARNsContainer {
                        targetGroupARNsBuffer?.append(stringContainer0)
                    }
                }
                targetGroupARNs = targetGroupARNsBuffer
            } else {
                targetGroupARNs = []
            }
        } else {
            targetGroupARNs = nil
        }
        let healthCheckTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .healthCheckType)
        healthCheckType = healthCheckTypeDecoded
        let healthCheckGracePeriodDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .healthCheckGracePeriod)
        healthCheckGracePeriod = healthCheckGracePeriodDecoded
        if containerValues.contains(.instances) {
            struct KeyVal0{struct member{}}
            let instancesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .instances)
            if let instancesWrappedContainer = instancesWrappedContainer {
                let instancesContainer = try instancesWrappedContainer.decodeIfPresent([Instance].self, forKey: .member)
                var instancesBuffer:[Instance]? = nil
                if let instancesContainer = instancesContainer {
                    instancesBuffer = [Instance]()
                    for structureContainer0 in instancesContainer {
                        instancesBuffer?.append(structureContainer0)
                    }
                }
                instances = instancesBuffer
            } else {
                instances = []
            }
        } else {
            instances = nil
        }
        let createdTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createdTime)
        var createdTimeBuffer:Date? = nil
        if let createdTimeDecoded = createdTimeDecoded {
            createdTimeBuffer = try TimestampWrapperDecoder.parseDateStringValue(createdTimeDecoded, format: .dateTime)
        }
        createdTime = createdTimeBuffer
        if containerValues.contains(.suspendedProcesses) {
            struct KeyVal0{struct member{}}
            let suspendedProcessesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .suspendedProcesses)
            if let suspendedProcessesWrappedContainer = suspendedProcessesWrappedContainer {
                let suspendedProcessesContainer = try suspendedProcessesWrappedContainer.decodeIfPresent([SuspendedProcess].self, forKey: .member)
                var suspendedProcessesBuffer:[SuspendedProcess]? = nil
                if let suspendedProcessesContainer = suspendedProcessesContainer {
                    suspendedProcessesBuffer = [SuspendedProcess]()
                    for structureContainer0 in suspendedProcessesContainer {
                        suspendedProcessesBuffer?.append(structureContainer0)
                    }
                }
                suspendedProcesses = suspendedProcessesBuffer
            } else {
                suspendedProcesses = []
            }
        } else {
            suspendedProcesses = nil
        }
        let placementGroupDecoded = try containerValues.decodeIfPresent(String.self, forKey: .placementGroup)
        placementGroup = placementGroupDecoded
        let vPCZoneIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vPCZoneIdentifier)
        vPCZoneIdentifier = vPCZoneIdentifierDecoded
        if containerValues.contains(.enabledMetrics) {
            struct KeyVal0{struct member{}}
            let enabledMetricsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .enabledMetrics)
            if let enabledMetricsWrappedContainer = enabledMetricsWrappedContainer {
                let enabledMetricsContainer = try enabledMetricsWrappedContainer.decodeIfPresent([EnabledMetric].self, forKey: .member)
                var enabledMetricsBuffer:[EnabledMetric]? = nil
                if let enabledMetricsContainer = enabledMetricsContainer {
                    enabledMetricsBuffer = [EnabledMetric]()
                    for structureContainer0 in enabledMetricsContainer {
                        enabledMetricsBuffer?.append(structureContainer0)
                    }
                }
                enabledMetrics = enabledMetricsBuffer
            } else {
                enabledMetrics = []
            }
        } else {
            enabledMetrics = nil
        }
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct member{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([TagDescription].self, forKey: .member)
                var tagsBuffer:[TagDescription]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [TagDescription]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
        if containerValues.contains(.terminationPolicies) {
            struct KeyVal0{struct member{}}
            let terminationPoliciesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .terminationPolicies)
            if let terminationPoliciesWrappedContainer = terminationPoliciesWrappedContainer {
                let terminationPoliciesContainer = try terminationPoliciesWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var terminationPoliciesBuffer:[String]? = nil
                if let terminationPoliciesContainer = terminationPoliciesContainer {
                    terminationPoliciesBuffer = [String]()
                    for stringContainer0 in terminationPoliciesContainer {
                        terminationPoliciesBuffer?.append(stringContainer0)
                    }
                }
                terminationPolicies = terminationPoliciesBuffer
            } else {
                terminationPolicies = []
            }
        } else {
            terminationPolicies = nil
        }
        let newInstancesProtectedFromScaleInDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .newInstancesProtectedFromScaleIn)
        newInstancesProtectedFromScaleIn = newInstancesProtectedFromScaleInDecoded
        let serviceLinkedRoleARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceLinkedRoleARN)
        serviceLinkedRoleARN = serviceLinkedRoleARNDecoded
        let maxInstanceLifetimeDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxInstanceLifetime)
        maxInstanceLifetime = maxInstanceLifetimeDecoded
        let capacityRebalanceDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .capacityRebalance)
        capacityRebalance = capacityRebalanceDecoded
        let warmPoolConfigurationDecoded = try containerValues.decodeIfPresent(WarmPoolConfiguration.self, forKey: .warmPoolConfiguration)
        warmPoolConfiguration = warmPoolConfigurationDecoded
        let warmPoolSizeDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .warmPoolSize)
        warmPoolSize = warmPoolSizeDecoded
    }
}
