// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension ScalingPolicy: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case adjustmentType = "AdjustmentType"
        case alarms = "Alarms"
        case autoScalingGroupName = "AutoScalingGroupName"
        case cooldown = "Cooldown"
        case enabled = "Enabled"
        case estimatedInstanceWarmup = "EstimatedInstanceWarmup"
        case metricAggregationType = "MetricAggregationType"
        case minAdjustmentMagnitude = "MinAdjustmentMagnitude"
        case minAdjustmentStep = "MinAdjustmentStep"
        case policyARN = "PolicyARN"
        case policyName = "PolicyName"
        case policyType = "PolicyType"
        case predictiveScalingConfiguration = "PredictiveScalingConfiguration"
        case scalingAdjustment = "ScalingAdjustment"
        case stepAdjustments = "StepAdjustments"
        case targetTrackingConfiguration = "TargetTrackingConfiguration"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let adjustmentType = adjustmentType {
            try container.encode(adjustmentType, forKey: Key("AdjustmentType"))
        }
        if let alarms = alarms {
            var alarmsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Alarms"))
            for (index0, alarm0) in alarms.enumerated() {
                try alarmsContainer.encode(alarm0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let autoScalingGroupName = autoScalingGroupName {
            try container.encode(autoScalingGroupName, forKey: Key("AutoScalingGroupName"))
        }
        if let cooldown = cooldown {
            try container.encode(cooldown, forKey: Key("Cooldown"))
        }
        if let enabled = enabled {
            try container.encode(enabled, forKey: Key("Enabled"))
        }
        if let estimatedInstanceWarmup = estimatedInstanceWarmup {
            try container.encode(estimatedInstanceWarmup, forKey: Key("EstimatedInstanceWarmup"))
        }
        if let metricAggregationType = metricAggregationType {
            try container.encode(metricAggregationType, forKey: Key("MetricAggregationType"))
        }
        if let minAdjustmentMagnitude = minAdjustmentMagnitude {
            try container.encode(minAdjustmentMagnitude, forKey: Key("MinAdjustmentMagnitude"))
        }
        if let minAdjustmentStep = minAdjustmentStep {
            try container.encode(minAdjustmentStep, forKey: Key("MinAdjustmentStep"))
        }
        if let policyARN = policyARN {
            try container.encode(policyARN, forKey: Key("PolicyARN"))
        }
        if let policyName = policyName {
            try container.encode(policyName, forKey: Key("PolicyName"))
        }
        if let policyType = policyType {
            try container.encode(policyType, forKey: Key("PolicyType"))
        }
        if let predictiveScalingConfiguration = predictiveScalingConfiguration {
            try container.encode(predictiveScalingConfiguration, forKey: Key("PredictiveScalingConfiguration"))
        }
        if let scalingAdjustment = scalingAdjustment {
            try container.encode(scalingAdjustment, forKey: Key("ScalingAdjustment"))
        }
        if let stepAdjustments = stepAdjustments {
            var stepAdjustmentsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("StepAdjustments"))
            for (index0, stepadjustment0) in stepAdjustments.enumerated() {
                try stepAdjustmentsContainer.encode(stepadjustment0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let targetTrackingConfiguration = targetTrackingConfiguration {
            try container.encode(targetTrackingConfiguration, forKey: Key("TargetTrackingConfiguration"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoScalingGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .autoScalingGroupName)
        autoScalingGroupName = autoScalingGroupNameDecoded
        let policyNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policyName)
        policyName = policyNameDecoded
        let policyARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policyARN)
        policyARN = policyARNDecoded
        let policyTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policyType)
        policyType = policyTypeDecoded
        let adjustmentTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .adjustmentType)
        adjustmentType = adjustmentTypeDecoded
        let minAdjustmentStepDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .minAdjustmentStep)
        minAdjustmentStep = minAdjustmentStepDecoded
        let minAdjustmentMagnitudeDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .minAdjustmentMagnitude)
        minAdjustmentMagnitude = minAdjustmentMagnitudeDecoded
        let scalingAdjustmentDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .scalingAdjustment)
        scalingAdjustment = scalingAdjustmentDecoded
        let cooldownDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .cooldown)
        cooldown = cooldownDecoded
        if containerValues.contains(.stepAdjustments) {
            struct KeyVal0{struct member{}}
            let stepAdjustmentsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .stepAdjustments)
            if let stepAdjustmentsWrappedContainer = stepAdjustmentsWrappedContainer {
                let stepAdjustmentsContainer = try stepAdjustmentsWrappedContainer.decodeIfPresent([StepAdjustment].self, forKey: .member)
                var stepAdjustmentsBuffer:[StepAdjustment]? = nil
                if let stepAdjustmentsContainer = stepAdjustmentsContainer {
                    stepAdjustmentsBuffer = [StepAdjustment]()
                    for structureContainer0 in stepAdjustmentsContainer {
                        stepAdjustmentsBuffer?.append(structureContainer0)
                    }
                }
                stepAdjustments = stepAdjustmentsBuffer
            } else {
                stepAdjustments = []
            }
        } else {
            stepAdjustments = nil
        }
        let metricAggregationTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .metricAggregationType)
        metricAggregationType = metricAggregationTypeDecoded
        let estimatedInstanceWarmupDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .estimatedInstanceWarmup)
        estimatedInstanceWarmup = estimatedInstanceWarmupDecoded
        if containerValues.contains(.alarms) {
            struct KeyVal0{struct member{}}
            let alarmsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .alarms)
            if let alarmsWrappedContainer = alarmsWrappedContainer {
                let alarmsContainer = try alarmsWrappedContainer.decodeIfPresent([Alarm].self, forKey: .member)
                var alarmsBuffer:[Alarm]? = nil
                if let alarmsContainer = alarmsContainer {
                    alarmsBuffer = [Alarm]()
                    for structureContainer0 in alarmsContainer {
                        alarmsBuffer?.append(structureContainer0)
                    }
                }
                alarms = alarmsBuffer
            } else {
                alarms = []
            }
        } else {
            alarms = nil
        }
        let targetTrackingConfigurationDecoded = try containerValues.decodeIfPresent(TargetTrackingConfiguration.self, forKey: .targetTrackingConfiguration)
        targetTrackingConfiguration = targetTrackingConfigurationDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let predictiveScalingConfigurationDecoded = try containerValues.decodeIfPresent(PredictiveScalingConfiguration.self, forKey: .predictiveScalingConfiguration)
        predictiveScalingConfiguration = predictiveScalingConfigurationDecoded
    }
}
