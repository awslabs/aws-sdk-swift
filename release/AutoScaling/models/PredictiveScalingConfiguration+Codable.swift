// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension PredictiveScalingConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxCapacityBreachBehavior = "MaxCapacityBreachBehavior"
        case maxCapacityBuffer = "MaxCapacityBuffer"
        case metricSpecifications = "MetricSpecifications"
        case mode = "Mode"
        case schedulingBufferTime = "SchedulingBufferTime"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let maxCapacityBreachBehavior = maxCapacityBreachBehavior {
            try container.encode(maxCapacityBreachBehavior, forKey: Key("MaxCapacityBreachBehavior"))
        }
        if let maxCapacityBuffer = maxCapacityBuffer {
            try container.encode(maxCapacityBuffer, forKey: Key("MaxCapacityBuffer"))
        }
        if let metricSpecifications = metricSpecifications {
            var metricSpecificationsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("MetricSpecifications"))
            for (index0, predictivescalingmetricspecification0) in metricSpecifications.enumerated() {
                try metricSpecificationsContainer.encode(predictivescalingmetricspecification0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let mode = mode {
            try container.encode(mode, forKey: Key("Mode"))
        }
        if let schedulingBufferTime = schedulingBufferTime {
            try container.encode(schedulingBufferTime, forKey: Key("SchedulingBufferTime"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.metricSpecifications) {
            struct KeyVal0{struct member{}}
            let metricSpecificationsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .metricSpecifications)
            if let metricSpecificationsWrappedContainer = metricSpecificationsWrappedContainer {
                let metricSpecificationsContainer = try metricSpecificationsWrappedContainer.decodeIfPresent([PredictiveScalingMetricSpecification].self, forKey: .member)
                var metricSpecificationsBuffer:[PredictiveScalingMetricSpecification]? = nil
                if let metricSpecificationsContainer = metricSpecificationsContainer {
                    metricSpecificationsBuffer = [PredictiveScalingMetricSpecification]()
                    for structureContainer0 in metricSpecificationsContainer {
                        metricSpecificationsBuffer?.append(structureContainer0)
                    }
                }
                metricSpecifications = metricSpecificationsBuffer
            } else {
                metricSpecifications = []
            }
        } else {
            metricSpecifications = nil
        }
        let modeDecoded = try containerValues.decodeIfPresent(PredictiveScalingMode.self, forKey: .mode)
        mode = modeDecoded
        let schedulingBufferTimeDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .schedulingBufferTime)
        schedulingBufferTime = schedulingBufferTimeDecoded
        let maxCapacityBreachBehaviorDecoded = try containerValues.decodeIfPresent(PredictiveScalingMaxCapacityBreachBehavior.self, forKey: .maxCapacityBreachBehavior)
        maxCapacityBreachBehavior = maxCapacityBreachBehaviorDecoded
        let maxCapacityBufferDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxCapacityBuffer)
        maxCapacityBuffer = maxCapacityBufferDecoded
    }
}
