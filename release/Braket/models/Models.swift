// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccessDeniedException(message: \(String(describing: message)))"}
}

extension AccessDeniedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You do not have sufficient access to perform this action.</p>
public struct AccessDeniedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Equatable {
    public let message: String?
}

extension AccessDeniedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct CancelQuantumTaskInputBodyMiddleware: Middleware {
    public let id: String = "CancelQuantumTaskInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CancelQuantumTaskInput>,
                  next: H) -> Swift.Result<OperationOutput<CancelQuantumTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CancelQuantumTaskInput>
    public typealias MOutput = OperationOutput<CancelQuantumTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CancelQuantumTaskOutputError>
}

extension CancelQuantumTaskInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CancelQuantumTaskInput(clientToken: \(String(describing: clientToken)), quantumTaskArn: \(String(describing: quantumTaskArn)))"}
}

extension CancelQuantumTaskInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
    }
}

public struct CancelQuantumTaskInputHeadersMiddleware: Middleware {
    public let id: String = "CancelQuantumTaskInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CancelQuantumTaskInput>,
                  next: H) -> Swift.Result<OperationOutput<CancelQuantumTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CancelQuantumTaskInput>
    public typealias MOutput = OperationOutput<CancelQuantumTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CancelQuantumTaskOutputError>
}

public struct CancelQuantumTaskInputQueryItemMiddleware: Middleware {
    public let id: String = "CancelQuantumTaskInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CancelQuantumTaskInput>,
                  next: H) -> Swift.Result<OperationOutput<CancelQuantumTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CancelQuantumTaskInput>
    public typealias MOutput = OperationOutput<CancelQuantumTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CancelQuantumTaskOutputError>
}

public struct CancelQuantumTaskInput: Equatable {
    /// <p>The client token associated with the request.</p>
    public var clientToken: String?
    /// <p>The ARN of the task to cancel.</p>
    public let quantumTaskArn: String?

    public init (
        clientToken: String? = nil,
        quantumTaskArn: String? = nil
    )
    {
        self.clientToken = clientToken
        self.quantumTaskArn = quantumTaskArn
    }
}

struct CancelQuantumTaskInputBody: Equatable {
    public let clientToken: String?
}

extension CancelQuantumTaskInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CancelQuantumTaskOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CancelQuantumTaskOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CancelQuantumTaskOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServiceException(InternalServiceException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CancelQuantumTaskOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CancelQuantumTaskOutputResponse(cancellationStatus: \(String(describing: cancellationStatus)), quantumTaskArn: \(String(describing: quantumTaskArn)))"}
}

extension CancelQuantumTaskOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CancelQuantumTaskOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.cancellationStatus = output.cancellationStatus
            self.quantumTaskArn = output.quantumTaskArn
        } else {
            self.cancellationStatus = nil
            self.quantumTaskArn = nil
        }
    }
}

public struct CancelQuantumTaskOutputResponse: Equatable {
    /// <p>The status of the cancellation request.</p>
    public let cancellationStatus: CancellationStatus?
    /// <p>The ARN of the task.</p>
    public let quantumTaskArn: String?

    public init (
        cancellationStatus: CancellationStatus? = nil,
        quantumTaskArn: String? = nil
    )
    {
        self.cancellationStatus = cancellationStatus
        self.quantumTaskArn = quantumTaskArn
    }
}

struct CancelQuantumTaskOutputResponseBody: Equatable {
    public let quantumTaskArn: String?
    public let cancellationStatus: CancellationStatus?
}

extension CancelQuantumTaskOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case cancellationStatus
        case quantumTaskArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantumTaskArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .quantumTaskArn)
        quantumTaskArn = quantumTaskArnDecoded
        let cancellationStatusDecoded = try containerValues.decodeIfPresent(CancellationStatus.self, forKey: .cancellationStatus)
        cancellationStatus = cancellationStatusDecoded
    }
}

public enum CancellationStatus {
    case cancelled
    case cancelling
    case sdkUnknown(String)
}

extension CancellationStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [CancellationStatus] {
        return [
            .cancelled,
            .cancelling,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .cancelled: return "CANCELLED"
        case .cancelling: return "CANCELLING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = CancellationStatus(rawValue: rawValue) ?? CancellationStatus.sdkUnknown(rawValue)
    }
}

extension ConflictException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConflictException(message: \(String(describing: message)))"}
}

extension ConflictException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An error occurred due to a conflict.</p>
public struct ConflictException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ConflictExceptionBody: Equatable {
    public let message: String?
}

extension ConflictExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct CreateQuantumTaskInputBodyMiddleware: Middleware {
    public let id: String = "CreateQuantumTaskInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateQuantumTaskInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateQuantumTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateQuantumTaskInput>
    public typealias MOutput = OperationOutput<CreateQuantumTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateQuantumTaskOutputError>
}

extension CreateQuantumTaskInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateQuantumTaskInput(action: \(String(describing: action)), clientToken: \(String(describing: clientToken)), deviceArn: \(String(describing: deviceArn)), deviceParameters: \(String(describing: deviceParameters)), outputS3Bucket: \(String(describing: outputS3Bucket)), outputS3KeyPrefix: \(String(describing: outputS3KeyPrefix)), shots: \(String(describing: shots)), tags: \(String(describing: tags)))"}
}

extension CreateQuantumTaskInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case action
        case clientToken
        case deviceArn
        case deviceParameters
        case outputS3Bucket
        case outputS3KeyPrefix
        case shots
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            try encodeContainer.encode(action, forKey: .action)
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let deviceArn = deviceArn {
            try encodeContainer.encode(deviceArn, forKey: .deviceArn)
        }
        if let deviceParameters = deviceParameters {
            try encodeContainer.encode(deviceParameters, forKey: .deviceParameters)
        }
        if let outputS3Bucket = outputS3Bucket {
            try encodeContainer.encode(outputS3Bucket, forKey: .outputS3Bucket)
        }
        if let outputS3KeyPrefix = outputS3KeyPrefix {
            try encodeContainer.encode(outputS3KeyPrefix, forKey: .outputS3KeyPrefix)
        }
        if let shots = shots {
            try encodeContainer.encode(shots, forKey: .shots)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagsmap0) in tags {
                try tagsContainer.encode(tagsmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateQuantumTaskInputHeadersMiddleware: Middleware {
    public let id: String = "CreateQuantumTaskInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateQuantumTaskInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateQuantumTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateQuantumTaskInput>
    public typealias MOutput = OperationOutput<CreateQuantumTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateQuantumTaskOutputError>
}

public struct CreateQuantumTaskInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateQuantumTaskInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateQuantumTaskInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateQuantumTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateQuantumTaskInput>
    public typealias MOutput = OperationOutput<CreateQuantumTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateQuantumTaskOutputError>
}

public struct CreateQuantumTaskInput: Equatable {
    /// <p>The action associated with the task.</p>
    public let action: String?
    /// <p>The client token associated with the request.</p>
    public var clientToken: String?
    /// <p>The ARN of the device to run the task on.</p>
    public let deviceArn: String?
    /// <p>The parameters for the device to run the task on.</p>
    public let deviceParameters: String?
    /// <p>The S3 bucket to store task result files in.</p>
    public let outputS3Bucket: String?
    /// <p>The key prefix for the location in the S3 bucket to store task results in.</p>
    public let outputS3KeyPrefix: String?
    /// <p>The number of shots to use for the task.</p>
    public let shots: Int?
    /// <p>Tags to be added to the quantum task you're creating.</p>
    public let tags: [String:String]?

    public init (
        action: String? = nil,
        clientToken: String? = nil,
        deviceArn: String? = nil,
        deviceParameters: String? = nil,
        outputS3Bucket: String? = nil,
        outputS3KeyPrefix: String? = nil,
        shots: Int? = nil,
        tags: [String:String]? = nil
    )
    {
        self.action = action
        self.clientToken = clientToken
        self.deviceArn = deviceArn
        self.deviceParameters = deviceParameters
        self.outputS3Bucket = outputS3Bucket
        self.outputS3KeyPrefix = outputS3KeyPrefix
        self.shots = shots
        self.tags = tags
    }
}

struct CreateQuantumTaskInputBody: Equatable {
    public let clientToken: String?
    public let deviceArn: String?
    public let deviceParameters: String?
    public let shots: Int?
    public let outputS3Bucket: String?
    public let outputS3KeyPrefix: String?
    public let action: String?
    public let tags: [String:String]?
}

extension CreateQuantumTaskInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case action
        case clientToken
        case deviceArn
        case deviceParameters
        case outputS3Bucket
        case outputS3KeyPrefix
        case shots
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let deviceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deviceArn)
        deviceArn = deviceArnDecoded
        let deviceParametersDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deviceParameters)
        deviceParameters = deviceParametersDecoded
        let shotsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .shots)
        shots = shotsDecoded
        let outputS3BucketDecoded = try containerValues.decodeIfPresent(String.self, forKey: .outputS3Bucket)
        outputS3Bucket = outputS3BucketDecoded
        let outputS3KeyPrefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .outputS3KeyPrefix)
        outputS3KeyPrefix = outputS3KeyPrefixDecoded
        let actionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .action)
        action = actionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateQuantumTaskOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateQuantumTaskOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DeviceOfflineException" : self = .deviceOfflineException(try DeviceOfflineException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateQuantumTaskOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case deviceOfflineException(DeviceOfflineException)
    case internalServiceException(InternalServiceException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateQuantumTaskOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateQuantumTaskOutputResponse(quantumTaskArn: \(String(describing: quantumTaskArn)))"}
}

extension CreateQuantumTaskOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateQuantumTaskOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.quantumTaskArn = output.quantumTaskArn
        } else {
            self.quantumTaskArn = nil
        }
    }
}

public struct CreateQuantumTaskOutputResponse: Equatable {
    /// <p>The ARN of the task created by the request.</p>
    public let quantumTaskArn: String?

    public init (
        quantumTaskArn: String? = nil
    )
    {
        self.quantumTaskArn = quantumTaskArn
    }
}

struct CreateQuantumTaskOutputResponseBody: Equatable {
    public let quantumTaskArn: String?
}

extension CreateQuantumTaskOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case quantumTaskArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantumTaskArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .quantumTaskArn)
        quantumTaskArn = quantumTaskArnDecoded
    }
}

extension DeviceOfflineException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeviceOfflineException(message: \(String(describing: message)))"}
}

extension DeviceOfflineException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeviceOfflineExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified device is currently offline.</p>
public struct DeviceOfflineException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DeviceOfflineExceptionBody: Equatable {
    public let message: String?
}

extension DeviceOfflineExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DeviceRetiredException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeviceRetiredException(message: \(String(describing: message)))"}
}

extension DeviceRetiredException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeviceRetiredExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified device has been retired.</p>
public struct DeviceRetiredException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DeviceRetiredExceptionBody: Equatable {
    public let message: String?
}

extension DeviceRetiredExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum DeviceStatus {
    case offline
    case online
    case retired
    case sdkUnknown(String)
}

extension DeviceStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DeviceStatus] {
        return [
            .offline,
            .online,
            .retired,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .offline: return "OFFLINE"
        case .online: return "ONLINE"
        case .retired: return "RETIRED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DeviceStatus(rawValue: rawValue) ?? DeviceStatus.sdkUnknown(rawValue)
    }
}

extension DeviceSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case deviceArn
        case deviceName
        case deviceStatus
        case deviceType
        case providerName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceArn = deviceArn {
            try encodeContainer.encode(deviceArn, forKey: .deviceArn)
        }
        if let deviceName = deviceName {
            try encodeContainer.encode(deviceName, forKey: .deviceName)
        }
        if let deviceStatus = deviceStatus {
            try encodeContainer.encode(deviceStatus.rawValue, forKey: .deviceStatus)
        }
        if let deviceType = deviceType {
            try encodeContainer.encode(deviceType.rawValue, forKey: .deviceType)
        }
        if let providerName = providerName {
            try encodeContainer.encode(providerName, forKey: .providerName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deviceArn)
        deviceArn = deviceArnDecoded
        let deviceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deviceName)
        deviceName = deviceNameDecoded
        let providerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .providerName)
        providerName = providerNameDecoded
        let deviceTypeDecoded = try containerValues.decodeIfPresent(DeviceType.self, forKey: .deviceType)
        deviceType = deviceTypeDecoded
        let deviceStatusDecoded = try containerValues.decodeIfPresent(DeviceStatus.self, forKey: .deviceStatus)
        deviceStatus = deviceStatusDecoded
    }
}

extension DeviceSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeviceSummary(deviceArn: \(String(describing: deviceArn)), deviceName: \(String(describing: deviceName)), deviceStatus: \(String(describing: deviceStatus)), deviceType: \(String(describing: deviceType)), providerName: \(String(describing: providerName)))"}
}

/// <p>Includes information about the device.</p>
public struct DeviceSummary: Equatable {
    /// <p>The ARN of the device.</p>
    public let deviceArn: String?
    /// <p>The name of the device.</p>
    public let deviceName: String?
    /// <p>The status of the device.</p>
    public let deviceStatus: DeviceStatus?
    /// <p>The type of the device.</p>
    public let deviceType: DeviceType?
    /// <p>The provider of the device.</p>
    public let providerName: String?

    public init (
        deviceArn: String? = nil,
        deviceName: String? = nil,
        deviceStatus: DeviceStatus? = nil,
        deviceType: DeviceType? = nil,
        providerName: String? = nil
    )
    {
        self.deviceArn = deviceArn
        self.deviceName = deviceName
        self.deviceStatus = deviceStatus
        self.deviceType = deviceType
        self.providerName = providerName
    }
}

public enum DeviceType {
    case qpu
    case simulator
    case sdkUnknown(String)
}

extension DeviceType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DeviceType] {
        return [
            .qpu,
            .simulator,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .qpu: return "QPU"
        case .simulator: return "SIMULATOR"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DeviceType(rawValue: rawValue) ?? DeviceType.sdkUnknown(rawValue)
    }
}

extension GetDeviceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDeviceInput(deviceArn: \(String(describing: deviceArn)))"}
}

extension GetDeviceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetDeviceInputHeadersMiddleware: Middleware {
    public let id: String = "GetDeviceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDeviceInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDeviceInput>
    public typealias MOutput = OperationOutput<GetDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDeviceOutputError>
}

public struct GetDeviceInputQueryItemMiddleware: Middleware {
    public let id: String = "GetDeviceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDeviceInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDeviceInput>
    public typealias MOutput = OperationOutput<GetDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDeviceOutputError>
}

public struct GetDeviceInput: Equatable {
    /// <p>The ARN of the device to retrieve.</p>
    public let deviceArn: String?

    public init (
        deviceArn: String? = nil
    )
    {
        self.deviceArn = deviceArn
    }
}

struct GetDeviceInputBody: Equatable {
}

extension GetDeviceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetDeviceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDeviceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DeviceOfflineException" : self = .deviceOfflineException(try DeviceOfflineException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DeviceRetiredException" : self = .deviceRetiredException(try DeviceRetiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDeviceOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case deviceOfflineException(DeviceOfflineException)
    case deviceRetiredException(DeviceRetiredException)
    case internalServiceException(InternalServiceException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDeviceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDeviceOutputResponse(deviceArn: \(String(describing: deviceArn)), deviceCapabilities: \(String(describing: deviceCapabilities)), deviceName: \(String(describing: deviceName)), deviceStatus: \(String(describing: deviceStatus)), deviceType: \(String(describing: deviceType)), providerName: \(String(describing: providerName)))"}
}

extension GetDeviceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetDeviceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.deviceArn = output.deviceArn
            self.deviceCapabilities = output.deviceCapabilities
            self.deviceName = output.deviceName
            self.deviceStatus = output.deviceStatus
            self.deviceType = output.deviceType
            self.providerName = output.providerName
        } else {
            self.deviceArn = nil
            self.deviceCapabilities = nil
            self.deviceName = nil
            self.deviceStatus = nil
            self.deviceType = nil
            self.providerName = nil
        }
    }
}

public struct GetDeviceOutputResponse: Equatable {
    /// <p>The ARN of the device.</p>
    public let deviceArn: String?
    /// <p>Details about the capabilities of the device.</p>
    public let deviceCapabilities: String?
    /// <p>The name of the device.</p>
    public let deviceName: String?
    /// <p>The status of the device.</p>
    public let deviceStatus: DeviceStatus?
    /// <p>The type of the device.</p>
    public let deviceType: DeviceType?
    /// <p>The name of the partner company for the device.</p>
    public let providerName: String?

    public init (
        deviceArn: String? = nil,
        deviceCapabilities: String? = nil,
        deviceName: String? = nil,
        deviceStatus: DeviceStatus? = nil,
        deviceType: DeviceType? = nil,
        providerName: String? = nil
    )
    {
        self.deviceArn = deviceArn
        self.deviceCapabilities = deviceCapabilities
        self.deviceName = deviceName
        self.deviceStatus = deviceStatus
        self.deviceType = deviceType
        self.providerName = providerName
    }
}

struct GetDeviceOutputResponseBody: Equatable {
    public let deviceArn: String?
    public let deviceName: String?
    public let providerName: String?
    public let deviceType: DeviceType?
    public let deviceStatus: DeviceStatus?
    public let deviceCapabilities: String?
}

extension GetDeviceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case deviceArn
        case deviceCapabilities
        case deviceName
        case deviceStatus
        case deviceType
        case providerName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deviceArn)
        deviceArn = deviceArnDecoded
        let deviceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deviceName)
        deviceName = deviceNameDecoded
        let providerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .providerName)
        providerName = providerNameDecoded
        let deviceTypeDecoded = try containerValues.decodeIfPresent(DeviceType.self, forKey: .deviceType)
        deviceType = deviceTypeDecoded
        let deviceStatusDecoded = try containerValues.decodeIfPresent(DeviceStatus.self, forKey: .deviceStatus)
        deviceStatus = deviceStatusDecoded
        let deviceCapabilitiesDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deviceCapabilities)
        deviceCapabilities = deviceCapabilitiesDecoded
    }
}

extension GetQuantumTaskInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetQuantumTaskInput(quantumTaskArn: \(String(describing: quantumTaskArn)))"}
}

extension GetQuantumTaskInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetQuantumTaskInputHeadersMiddleware: Middleware {
    public let id: String = "GetQuantumTaskInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetQuantumTaskInput>,
                  next: H) -> Swift.Result<OperationOutput<GetQuantumTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetQuantumTaskInput>
    public typealias MOutput = OperationOutput<GetQuantumTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetQuantumTaskOutputError>
}

public struct GetQuantumTaskInputQueryItemMiddleware: Middleware {
    public let id: String = "GetQuantumTaskInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetQuantumTaskInput>,
                  next: H) -> Swift.Result<OperationOutput<GetQuantumTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetQuantumTaskInput>
    public typealias MOutput = OperationOutput<GetQuantumTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetQuantumTaskOutputError>
}

public struct GetQuantumTaskInput: Equatable {
    /// <p>the ARN of the task to retrieve.</p>
    public let quantumTaskArn: String?

    public init (
        quantumTaskArn: String? = nil
    )
    {
        self.quantumTaskArn = quantumTaskArn
    }
}

struct GetQuantumTaskInputBody: Equatable {
}

extension GetQuantumTaskInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetQuantumTaskOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetQuantumTaskOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetQuantumTaskOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceException(InternalServiceException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetQuantumTaskOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetQuantumTaskOutputResponse(createdAt: \(String(describing: createdAt)), deviceArn: \(String(describing: deviceArn)), deviceParameters: \(String(describing: deviceParameters)), endedAt: \(String(describing: endedAt)), failureReason: \(String(describing: failureReason)), outputS3Bucket: \(String(describing: outputS3Bucket)), outputS3Directory: \(String(describing: outputS3Directory)), quantumTaskArn: \(String(describing: quantumTaskArn)), shots: \(String(describing: shots)), status: \(String(describing: status)), tags: \(String(describing: tags)))"}
}

extension GetQuantumTaskOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetQuantumTaskOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.createdAt = output.createdAt
            self.deviceArn = output.deviceArn
            self.deviceParameters = output.deviceParameters
            self.endedAt = output.endedAt
            self.failureReason = output.failureReason
            self.outputS3Bucket = output.outputS3Bucket
            self.outputS3Directory = output.outputS3Directory
            self.quantumTaskArn = output.quantumTaskArn
            self.shots = output.shots
            self.status = output.status
            self.tags = output.tags
        } else {
            self.createdAt = nil
            self.deviceArn = nil
            self.deviceParameters = nil
            self.endedAt = nil
            self.failureReason = nil
            self.outputS3Bucket = nil
            self.outputS3Directory = nil
            self.quantumTaskArn = nil
            self.shots = nil
            self.status = nil
            self.tags = nil
        }
    }
}

public struct GetQuantumTaskOutputResponse: Equatable {
    /// <p>The time at which the task was created.</p>
    public let createdAt: Date?
    /// <p>The ARN of the device the task was run on.</p>
    public let deviceArn: String?
    /// <p>The parameters for the device on which the task ran.</p>
    public let deviceParameters: String?
    /// <p>The time at which the task ended.</p>
    public let endedAt: Date?
    /// <p>The reason that a task failed.</p>
    public let failureReason: String?
    /// <p>The S3 bucket where task results are stored.</p>
    public let outputS3Bucket: String?
    /// <p>The folder in the S3 bucket where task results are stored.</p>
    public let outputS3Directory: String?
    /// <p>The ARN of the task.</p>
    public let quantumTaskArn: String?
    /// <p>The number of shots used in the task.</p>
    public let shots: Int?
    /// <p>The status of the task.</p>
    public let status: QuantumTaskStatus?
    /// <p>The tags that belong to this task.</p>
    public let tags: [String:String]?

    public init (
        createdAt: Date? = nil,
        deviceArn: String? = nil,
        deviceParameters: String? = nil,
        endedAt: Date? = nil,
        failureReason: String? = nil,
        outputS3Bucket: String? = nil,
        outputS3Directory: String? = nil,
        quantumTaskArn: String? = nil,
        shots: Int? = nil,
        status: QuantumTaskStatus? = nil,
        tags: [String:String]? = nil
    )
    {
        self.createdAt = createdAt
        self.deviceArn = deviceArn
        self.deviceParameters = deviceParameters
        self.endedAt = endedAt
        self.failureReason = failureReason
        self.outputS3Bucket = outputS3Bucket
        self.outputS3Directory = outputS3Directory
        self.quantumTaskArn = quantumTaskArn
        self.shots = shots
        self.status = status
        self.tags = tags
    }
}

struct GetQuantumTaskOutputResponseBody: Equatable {
    public let quantumTaskArn: String?
    public let status: QuantumTaskStatus?
    public let failureReason: String?
    public let deviceArn: String?
    public let deviceParameters: String?
    public let shots: Int?
    public let outputS3Bucket: String?
    public let outputS3Directory: String?
    public let createdAt: Date?
    public let endedAt: Date?
    public let tags: [String:String]?
}

extension GetQuantumTaskOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case createdAt
        case deviceArn
        case deviceParameters
        case endedAt
        case failureReason
        case outputS3Bucket
        case outputS3Directory
        case quantumTaskArn
        case shots
        case status
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantumTaskArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .quantumTaskArn)
        quantumTaskArn = quantumTaskArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(QuantumTaskStatus.self, forKey: .status)
        status = statusDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let deviceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deviceArn)
        deviceArn = deviceArnDecoded
        let deviceParametersDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deviceParameters)
        deviceParameters = deviceParametersDecoded
        let shotsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .shots)
        shots = shotsDecoded
        let outputS3BucketDecoded = try containerValues.decodeIfPresent(String.self, forKey: .outputS3Bucket)
        outputS3Bucket = outputS3BucketDecoded
        let outputS3DirectoryDecoded = try containerValues.decodeIfPresent(String.self, forKey: .outputS3Directory)
        outputS3Directory = outputS3DirectoryDecoded
        let createdAtDateString = try containerValues.decodeIfPresent(String.self, forKey: .createdAt)
        var createdAtDecoded: Date? = nil
        if let createdAtDateString = createdAtDateString {
            let createdAtFormatter = DateFormatter.iso8601DateFormatterWithoutFractionalSeconds
            createdAtDecoded = createdAtFormatter.date(from: createdAtDateString)
        }
        createdAt = createdAtDecoded
        let endedAtDateString = try containerValues.decodeIfPresent(String.self, forKey: .endedAt)
        var endedAtDecoded: Date? = nil
        if let endedAtDateString = endedAtDateString {
            let endedAtFormatter = DateFormatter.iso8601DateFormatterWithoutFractionalSeconds
            endedAtDecoded = endedAtFormatter.date(from: endedAtDateString)
        }
        endedAt = endedAtDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension InternalServiceException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalServiceException(message: \(String(describing: message)))"}
}

extension InternalServiceException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InternalServiceExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request processing has failed because of an unknown error, exception, or failure.</p>
public struct InternalServiceException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServiceExceptionBody: Equatable {
    public let message: String?
}

extension InternalServiceExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListTagsForResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceInput(resourceArn: \(String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Equatable {
    /// <p>Specify the <code>resourceArn</code> for the resource whose tags to display.</p>
    public let resourceArn: String?

    public init (
        resourceArn: String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Equatable {
}

extension ListTagsForResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Equatable {
    case internalServiceException(InternalServiceException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceOutputResponse(tags: \(String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Equatable {
    /// <p>Displays the key, value pairs of tags associated with this resource.</p>
    public let tags: [String:String]?

    public init (
        tags: [String:String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Equatable {
    public let tags: [String:String]?
}

extension ListTagsForResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

public enum QuantumTaskStatus {
    case cancelled
    case cancelling
    case completed
    case created
    case failed
    case queued
    case running
    case sdkUnknown(String)
}

extension QuantumTaskStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [QuantumTaskStatus] {
        return [
            .cancelled,
            .cancelling,
            .completed,
            .created,
            .failed,
            .queued,
            .running,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .cancelled: return "CANCELLED"
        case .cancelling: return "CANCELLING"
        case .completed: return "COMPLETED"
        case .created: return "CREATED"
        case .failed: return "FAILED"
        case .queued: return "QUEUED"
        case .running: return "RUNNING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = QuantumTaskStatus(rawValue: rawValue) ?? QuantumTaskStatus.sdkUnknown(rawValue)
    }
}

extension QuantumTaskSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case createdAt
        case deviceArn
        case endedAt
        case outputS3Bucket
        case outputS3Directory
        case quantumTaskArn
        case shots
        case status
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.iso8601WithoutFractionalSeconds(), forKey: .createdAt)
        }
        if let deviceArn = deviceArn {
            try encodeContainer.encode(deviceArn, forKey: .deviceArn)
        }
        if let endedAt = endedAt {
            try encodeContainer.encode(endedAt.iso8601WithoutFractionalSeconds(), forKey: .endedAt)
        }
        if let outputS3Bucket = outputS3Bucket {
            try encodeContainer.encode(outputS3Bucket, forKey: .outputS3Bucket)
        }
        if let outputS3Directory = outputS3Directory {
            try encodeContainer.encode(outputS3Directory, forKey: .outputS3Directory)
        }
        if let quantumTaskArn = quantumTaskArn {
            try encodeContainer.encode(quantumTaskArn, forKey: .quantumTaskArn)
        }
        if let shots = shots {
            try encodeContainer.encode(shots, forKey: .shots)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagsmap0) in tags {
                try tagsContainer.encode(tagsmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantumTaskArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .quantumTaskArn)
        quantumTaskArn = quantumTaskArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(QuantumTaskStatus.self, forKey: .status)
        status = statusDecoded
        let deviceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deviceArn)
        deviceArn = deviceArnDecoded
        let shotsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .shots)
        shots = shotsDecoded
        let outputS3BucketDecoded = try containerValues.decodeIfPresent(String.self, forKey: .outputS3Bucket)
        outputS3Bucket = outputS3BucketDecoded
        let outputS3DirectoryDecoded = try containerValues.decodeIfPresent(String.self, forKey: .outputS3Directory)
        outputS3Directory = outputS3DirectoryDecoded
        let createdAtDateString = try containerValues.decodeIfPresent(String.self, forKey: .createdAt)
        var createdAtDecoded: Date? = nil
        if let createdAtDateString = createdAtDateString {
            let createdAtFormatter = DateFormatter.iso8601DateFormatterWithoutFractionalSeconds
            createdAtDecoded = createdAtFormatter.date(from: createdAtDateString)
        }
        createdAt = createdAtDecoded
        let endedAtDateString = try containerValues.decodeIfPresent(String.self, forKey: .endedAt)
        var endedAtDecoded: Date? = nil
        if let endedAtDateString = endedAtDateString {
            let endedAtFormatter = DateFormatter.iso8601DateFormatterWithoutFractionalSeconds
            endedAtDecoded = endedAtFormatter.date(from: endedAtDateString)
        }
        endedAt = endedAtDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension QuantumTaskSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "QuantumTaskSummary(createdAt: \(String(describing: createdAt)), deviceArn: \(String(describing: deviceArn)), endedAt: \(String(describing: endedAt)), outputS3Bucket: \(String(describing: outputS3Bucket)), outputS3Directory: \(String(describing: outputS3Directory)), quantumTaskArn: \(String(describing: quantumTaskArn)), shots: \(String(describing: shots)), status: \(String(describing: status)), tags: \(String(describing: tags)))"}
}

/// <p>Includes information about a quantum task.</p>
public struct QuantumTaskSummary: Equatable {
    /// <p>The time at which the task was created.</p>
    public let createdAt: Date?
    /// <p>The ARN of the device the task ran on.</p>
    public let deviceArn: String?
    /// <p>The time at which the task finished.</p>
    public let endedAt: Date?
    /// <p>The S3 bucket where the task result file is stored..</p>
    public let outputS3Bucket: String?
    /// <p>The folder in the S3 bucket where the task result file is stored.</p>
    public let outputS3Directory: String?
    /// <p>The ARN of the task.</p>
    public let quantumTaskArn: String?
    /// <p>The shots used for the task.</p>
    public let shots: Int?
    /// <p>The status of the task.</p>
    public let status: QuantumTaskStatus?
    /// <p>Displays the key, value pairs of tags associated with this quantum task.</p>
    public let tags: [String:String]?

    public init (
        createdAt: Date? = nil,
        deviceArn: String? = nil,
        endedAt: Date? = nil,
        outputS3Bucket: String? = nil,
        outputS3Directory: String? = nil,
        quantumTaskArn: String? = nil,
        shots: Int? = nil,
        status: QuantumTaskStatus? = nil,
        tags: [String:String]? = nil
    )
    {
        self.createdAt = createdAt
        self.deviceArn = deviceArn
        self.endedAt = endedAt
        self.outputS3Bucket = outputS3Bucket
        self.outputS3Directory = outputS3Directory
        self.quantumTaskArn = quantumTaskArn
        self.shots = shots
        self.status = status
        self.tags = tags
    }
}

extension ResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundException(message: \(String(describing: message)))"}
}

extension ResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified resource was not found.</p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension ResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SearchDevicesFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name
        case values
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for string256list0 in values {
                try valuesContainer.encode(string256list0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .values)
        var valuesDecoded0:[String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension SearchDevicesFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SearchDevicesFilter(name: \(String(describing: name)), values: \(String(describing: values)))"}
}

/// <p>The filter to use for searching devices.</p>
public struct SearchDevicesFilter: Equatable {
    /// <p>The name to use to filter results.</p>
    public let name: String?
    /// <p>The values to use to filter results.</p>
    public let values: [String]?

    public init (
        name: String? = nil,
        values: [String]? = nil
    )
    {
        self.name = name
        self.values = values
    }
}

public struct SearchDevicesInputBodyMiddleware: Middleware {
    public let id: String = "SearchDevicesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SearchDevicesInput>,
                  next: H) -> Swift.Result<OperationOutput<SearchDevicesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SearchDevicesInput>
    public typealias MOutput = OperationOutput<SearchDevicesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SearchDevicesOutputError>
}

extension SearchDevicesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SearchDevicesInput(filters: \(String(describing: filters)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension SearchDevicesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for searchdevicesfilterlist0 in filters {
                try filtersContainer.encode(searchdevicesfilterlist0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct SearchDevicesInputHeadersMiddleware: Middleware {
    public let id: String = "SearchDevicesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SearchDevicesInput>,
                  next: H) -> Swift.Result<OperationOutput<SearchDevicesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SearchDevicesInput>
    public typealias MOutput = OperationOutput<SearchDevicesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SearchDevicesOutputError>
}

public struct SearchDevicesInputQueryItemMiddleware: Middleware {
    public let id: String = "SearchDevicesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SearchDevicesInput>,
                  next: H) -> Swift.Result<OperationOutput<SearchDevicesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SearchDevicesInput>
    public typealias MOutput = OperationOutput<SearchDevicesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SearchDevicesOutputError>
}

public struct SearchDevicesInput: Equatable {
    /// <p>The filter values to use to search for a device.</p>
    public let filters: [SearchDevicesFilter]?
    /// <p>The maximum number of results to return in the response.</p>
    public let maxResults: Int?
    /// <p>A token used for pagination of results returned in the response. Use the token returned from the previous request continue results where the previous request ended.</p>
    public let nextToken: String?

    public init (
        filters: [SearchDevicesFilter]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct SearchDevicesInputBody: Equatable {
    public let nextToken: String?
    public let maxResults: Int?
    public let filters: [SearchDevicesFilter]?
}

extension SearchDevicesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([SearchDevicesFilter?].self, forKey: .filters)
        var filtersDecoded0:[SearchDevicesFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [SearchDevicesFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension SearchDevicesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SearchDevicesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SearchDevicesOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceException(InternalServiceException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SearchDevicesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SearchDevicesOutputResponse(devices: \(String(describing: devices)), nextToken: \(String(describing: nextToken)))"}
}

extension SearchDevicesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: SearchDevicesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.devices = output.devices
            self.nextToken = output.nextToken
        } else {
            self.devices = nil
            self.nextToken = nil
        }
    }
}

public struct SearchDevicesOutputResponse: Equatable {
    /// <p>An array of <code>DeviceSummary</code> objects for devices that match the specified filter values.</p>
    public let devices: [DeviceSummary]?
    /// <p>A token used for pagination of results, or null if there are no additional results. Use the token value in a subsequent request to continue results where the previous request ended.</p>
    public let nextToken: String?

    public init (
        devices: [DeviceSummary]? = nil,
        nextToken: String? = nil
    )
    {
        self.devices = devices
        self.nextToken = nextToken
    }
}

struct SearchDevicesOutputResponseBody: Equatable {
    public let devices: [DeviceSummary]?
    public let nextToken: String?
}

extension SearchDevicesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case devices
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let devicesContainer = try containerValues.decodeIfPresent([DeviceSummary?].self, forKey: .devices)
        var devicesDecoded0:[DeviceSummary]? = nil
        if let devicesContainer = devicesContainer {
            devicesDecoded0 = [DeviceSummary]()
            for structure0 in devicesContainer {
                if let structure0 = structure0 {
                    devicesDecoded0?.append(structure0)
                }
            }
        }
        devices = devicesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension SearchQuantumTasksFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name
        case `operator` = "operator"
        case values
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let `operator` = `operator` {
            try encodeContainer.encode(`operator`.rawValue, forKey: .`operator`)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for string256list0 in values {
                try valuesContainer.encode(string256list0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .values)
        var valuesDecoded0:[String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
        let operatorDecoded = try containerValues.decodeIfPresent(SearchQuantumTasksFilterOperator.self, forKey: .operator)
        `operator` = operatorDecoded
    }
}

extension SearchQuantumTasksFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SearchQuantumTasksFilter(name: \(String(describing: name)), operator: \(String(describing: `operator`)), values: \(String(describing: values)))"}
}

/// <p>A filter to use to search for tasks.</p>
public struct SearchQuantumTasksFilter: Equatable {
    /// <p>An operator to use in the filter.</p>
    public let `operator`: SearchQuantumTasksFilterOperator?
    /// <p>The name of the device used for the task.</p>
    public let name: String?
    /// <p>The values to use for the filter.</p>
    public let values: [String]?

    public init (
        `operator`: SearchQuantumTasksFilterOperator? = nil,
        name: String? = nil,
        values: [String]? = nil
    )
    {
        self.`operator` = `operator`
        self.name = name
        self.values = values
    }
}

public enum SearchQuantumTasksFilterOperator {
    case between
    case equal
    case gt
    case gte
    case lt
    case lte
    case sdkUnknown(String)
}

extension SearchQuantumTasksFilterOperator : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SearchQuantumTasksFilterOperator] {
        return [
            .between,
            .equal,
            .gt,
            .gte,
            .lt,
            .lte,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .between: return "BETWEEN"
        case .equal: return "EQUAL"
        case .gt: return "GT"
        case .gte: return "GTE"
        case .lt: return "LT"
        case .lte: return "LTE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SearchQuantumTasksFilterOperator(rawValue: rawValue) ?? SearchQuantumTasksFilterOperator.sdkUnknown(rawValue)
    }
}

public struct SearchQuantumTasksInputBodyMiddleware: Middleware {
    public let id: String = "SearchQuantumTasksInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SearchQuantumTasksInput>,
                  next: H) -> Swift.Result<OperationOutput<SearchQuantumTasksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SearchQuantumTasksInput>
    public typealias MOutput = OperationOutput<SearchQuantumTasksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SearchQuantumTasksOutputError>
}

extension SearchQuantumTasksInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SearchQuantumTasksInput(filters: \(String(describing: filters)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension SearchQuantumTasksInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for searchquantumtasksfilterlist0 in filters {
                try filtersContainer.encode(searchquantumtasksfilterlist0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct SearchQuantumTasksInputHeadersMiddleware: Middleware {
    public let id: String = "SearchQuantumTasksInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SearchQuantumTasksInput>,
                  next: H) -> Swift.Result<OperationOutput<SearchQuantumTasksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SearchQuantumTasksInput>
    public typealias MOutput = OperationOutput<SearchQuantumTasksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SearchQuantumTasksOutputError>
}

public struct SearchQuantumTasksInputQueryItemMiddleware: Middleware {
    public let id: String = "SearchQuantumTasksInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SearchQuantumTasksInput>,
                  next: H) -> Swift.Result<OperationOutput<SearchQuantumTasksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SearchQuantumTasksInput>
    public typealias MOutput = OperationOutput<SearchQuantumTasksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SearchQuantumTasksOutputError>
}

public struct SearchQuantumTasksInput: Equatable {
    /// <p>Array of <code>SearchQuantumTasksFilter</code> objects.</p>
    public let filters: [SearchQuantumTasksFilter]?
    /// <p>Maximum number of results to return in the response.</p>
    public let maxResults: Int?
    /// <p>A token used for pagination of results returned in the response. Use the token returned from the previous request continue results where the previous request ended.</p>
    public let nextToken: String?

    public init (
        filters: [SearchQuantumTasksFilter]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct SearchQuantumTasksInputBody: Equatable {
    public let nextToken: String?
    public let maxResults: Int?
    public let filters: [SearchQuantumTasksFilter]?
}

extension SearchQuantumTasksInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([SearchQuantumTasksFilter?].self, forKey: .filters)
        var filtersDecoded0:[SearchQuantumTasksFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [SearchQuantumTasksFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension SearchQuantumTasksOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SearchQuantumTasksOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SearchQuantumTasksOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceException(InternalServiceException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SearchQuantumTasksOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SearchQuantumTasksOutputResponse(nextToken: \(String(describing: nextToken)), quantumTasks: \(String(describing: quantumTasks)))"}
}

extension SearchQuantumTasksOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: SearchQuantumTasksOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.quantumTasks = output.quantumTasks
        } else {
            self.nextToken = nil
            self.quantumTasks = nil
        }
    }
}

public struct SearchQuantumTasksOutputResponse: Equatable {
    /// <p>A token used for pagination of results, or null if there are no additional results. Use the token value in a subsequent request to continue results where the previous request ended.</p>
    public let nextToken: String?
    /// <p>An array of <code>QuantumTaskSummary</code> objects for tasks that match the specified filters.</p>
    public let quantumTasks: [QuantumTaskSummary]?

    public init (
        nextToken: String? = nil,
        quantumTasks: [QuantumTaskSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.quantumTasks = quantumTasks
    }
}

struct SearchQuantumTasksOutputResponseBody: Equatable {
    public let quantumTasks: [QuantumTaskSummary]?
    public let nextToken: String?
}

extension SearchQuantumTasksOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case quantumTasks
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantumTasksContainer = try containerValues.decodeIfPresent([QuantumTaskSummary?].self, forKey: .quantumTasks)
        var quantumTasksDecoded0:[QuantumTaskSummary]? = nil
        if let quantumTasksContainer = quantumTasksContainer {
            quantumTasksDecoded0 = [QuantumTaskSummary]()
            for structure0 in quantumTasksContainer {
                if let structure0 = structure0 {
                    quantumTasksDecoded0?.append(structure0)
                }
            }
        }
        quantumTasks = quantumTasksDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ServiceQuotaExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceQuotaExceededException(message: \(String(describing: message)))"}
}

extension ServiceQuotaExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request failed because a service quota is exceeded.</p>
public struct ServiceQuotaExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Equatable {
    public let message: String?
}

extension ServiceQuotaExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct TagResourceInputBodyMiddleware: Middleware {
    public let id: String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

extension TagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceInput(resourceArn: \(String(describing: resourceArn)), tags: \(String(describing: tags)))"}
}

extension TagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagsmap0) in tags {
                try tagsContainer.encode(tagsmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Equatable {
    /// <p>Specify the <code>resourceArn</code> of the resource to which a tag will be added.</p>
    public let resourceArn: String?
    /// <p>Specify the tags to add to the resource.</p>
    public let tags: [String:String]?

    public init (
        resourceArn: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Equatable {
    public let tags: [String:String]?
}

extension TagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Equatable {
    case internalServiceException(InternalServiceException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Equatable {
}

extension TagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ThrottlingException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ThrottlingException(message: \(String(describing: message)))"}
}

extension ThrottlingException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The throttling rate limit is met.</p>
public struct ThrottlingException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ThrottlingExceptionBody: Equatable {
    public let message: String?
}

extension ThrottlingExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceInput(resourceArn: \(String(describing: resourceArn)), tagKeys: \(String(describing: tagKeys)))"}
}

extension UntagResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct UntagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let tagKeys = input.operationInput.tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Equatable {
    /// <p>Specify the <code>resourceArn</code> for the resource from which to remove the tags.</p>
    public let resourceArn: String?
    /// <p>Specify the keys for the tags to remove from the resource.</p>
    public let tagKeys: [String]?

    public init (
        resourceArn: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Equatable {
}

extension UntagResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension UntagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Equatable {
    case internalServiceException(InternalServiceException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Equatable {
}

extension UntagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ValidationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ValidationException(message: \(String(describing: message)))"}
}

extension ValidationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The input fails to satisfy the constraints specified by an AWS service.</p>
public struct ValidationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Equatable {
    public let message: String?
}

extension ValidationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}
