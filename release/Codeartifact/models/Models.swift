// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccessDeniedException(message: \(String(describing: message)))"}
}

extension AccessDeniedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>
///         The operation did not succeed because of an unauthorized access attempt.
///       </p>
public struct AccessDeniedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Equatable {
    public let message: String?
}

extension AccessDeniedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AssetSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case hashes
        case name
        case size
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hashes = hashes {
            var hashesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .hashes)
            for (dictKey0, assethashes0) in hashes {
                try hashesContainer.encode(assethashes0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let size = size {
            try encodeContainer.encode(size, forKey: .size)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let sizeDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .size)
        size = sizeDecoded
        let hashesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .hashes)
        var hashesDecoded0: [String:String]? = nil
        if let hashesContainer = hashesContainer {
            hashesDecoded0 = [String:String]()
            for (key0, hashvalue0) in hashesContainer {
                if let hashvalue0 = hashvalue0 {
                    hashesDecoded0?[key0] = hashvalue0
                }
            }
        }
        hashes = hashesDecoded0
    }
}

extension AssetSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssetSummary(hashes: \(String(describing: hashes)), name: \(String(describing: name)), size: \(String(describing: size)))"}
}

/// <p>
///         Contains details about a package version asset.
///        </p>
public struct AssetSummary: Equatable {
    /// <p>
    ///       The hashes of the asset.
    ///     </p>
    public let hashes: [String:String]?
    /// <p>
    ///          The name of the asset.
    ///        </p>
    public let name: String?
    /// <p>
    ///       The size of the asset.
    ///     </p>
    public let size: Int?

    public init (
        hashes: [String:String]? = nil,
        name: String? = nil,
        size: Int? = nil
    )
    {
        self.hashes = hashes
        self.name = name
        self.size = size
    }
}

extension AssociateExternalConnectionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateExternalConnectionInput(domain: \(String(describing: domain)), domainOwner: \(String(describing: domainOwner)), externalConnection: \(String(describing: externalConnection)), repository: \(String(describing: repository)))"}
}

extension AssociateExternalConnectionInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct AssociateExternalConnectionInputHeadersMiddleware: Middleware {
    public let id: String = "AssociateExternalConnectionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateExternalConnectionInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateExternalConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateExternalConnectionInput>
    public typealias MOutput = OperationOutput<AssociateExternalConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateExternalConnectionOutputError>
}

public struct AssociateExternalConnectionInputQueryItemMiddleware: Middleware {
    public let id: String = "AssociateExternalConnectionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateExternalConnectionInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateExternalConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let externalConnection = input.operationInput.externalConnection {
            let externalConnectionQueryItem = URLQueryItem(name: "external-connection".urlPercentEncoding(), value: String(externalConnection).urlPercentEncoding())
            input.builder.withQueryItem(externalConnectionQueryItem)
        }
        if let domain = input.operationInput.domain {
            let domainQueryItem = URLQueryItem(name: "domain".urlPercentEncoding(), value: String(domain).urlPercentEncoding())
            input.builder.withQueryItem(domainQueryItem)
        }
        if let domainOwner = input.operationInput.domainOwner {
            let domainOwnerQueryItem = URLQueryItem(name: "domain-owner".urlPercentEncoding(), value: String(domainOwner).urlPercentEncoding())
            input.builder.withQueryItem(domainOwnerQueryItem)
        }
        if let repository = input.operationInput.repository {
            let repositoryQueryItem = URLQueryItem(name: "repository".urlPercentEncoding(), value: String(repository).urlPercentEncoding())
            input.builder.withQueryItem(repositoryQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateExternalConnectionInput>
    public typealias MOutput = OperationOutput<AssociateExternalConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateExternalConnectionOutputError>
}

public struct AssociateExternalConnectionInput: Equatable {
    /// <p>The name of the domain that contains the repository.</p>
    public let domain: String?
    /// <p>
    ///         The 12-digit account number of the AWS account that owns the domain. It does not include
    ///         dashes or spaces.
    ///       </p>
    public let domainOwner: String?
    /// <p>
    ///       The name of the external connection to add to the repository. The following values are supported:
    ///     </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>public:npmjs</code> - for the npm public repository.
    ///         </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>public:pypi</code> - for the Python Package Index.
    ///         </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>public:maven-central</code> - for Maven Central.
    ///         </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>public:maven-googleandroid</code> - for the Google Android repository.
    ///         </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>public:maven-gradleplugins</code> - for the Gradle plugins repository.
    ///         </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>public:maven-commonsware</code> - for the CommonsWare Android repository.
    ///         </p>
    ///             </li>
    ///          </ul>
    public let externalConnection: String?
    /// <p>
    ///       The name of the repository to which the external connection is added.
    ///     </p>
    public let repository: String?

    public init (
        domain: String? = nil,
        domainOwner: String? = nil,
        externalConnection: String? = nil,
        repository: String? = nil
    )
    {
        self.domain = domain
        self.domainOwner = domainOwner
        self.externalConnection = externalConnection
        self.repository = repository
    }
}

struct AssociateExternalConnectionInputBody: Equatable {
}

extension AssociateExternalConnectionInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension AssociateExternalConnectionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateExternalConnectionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateExternalConnectionOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateExternalConnectionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateExternalConnectionOutputResponse(repository: \(String(describing: repository)))"}
}

extension AssociateExternalConnectionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AssociateExternalConnectionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.repository = output.repository
        } else {
            self.repository = nil
        }
    }
}

public struct AssociateExternalConnectionOutputResponse: Equatable {
    /// <p>
    ///         Information about the connected repository after processing the request.
    ///        </p>
    public let repository: RepositoryDescription?

    public init (
        repository: RepositoryDescription? = nil
    )
    {
        self.repository = repository
    }
}

struct AssociateExternalConnectionOutputResponseBody: Equatable {
    public let repository: RepositoryDescription?
}

extension AssociateExternalConnectionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case repository
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryDecoded = try containerValues.decodeIfPresent(RepositoryDescription.self, forKey: .repository)
        repository = repositoryDecoded
    }
}

extension ConflictException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConflictException(message: \(String(describing: message)), resourceId: \(String(describing: resourceId)), resourceType: \(String(describing: resourceType)))"}
}

extension ConflictException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>
///         The operation did not succeed because prerequisites are not met.
///       </p>
public struct ConflictException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    /// <p>
    ///       The ID of the resource.
    ///     </p>
    public var resourceId: String?
    /// <p>
    ///       The type of AWS resource.
    ///     </p>
    public var resourceType: ResourceType?

    public init (
        message: String? = nil,
        resourceId: String? = nil,
        resourceType: ResourceType? = nil
    )
    {
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ConflictExceptionBody: Equatable {
    public let message: String?
    public let resourceId: String?
    public let resourceType: ResourceType?
}

extension ConflictExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
        case resourceId
        case resourceType
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

public struct CopyPackageVersionsInputBodyMiddleware: Middleware {
    public let id: String = "CopyPackageVersionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CopyPackageVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<CopyPackageVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CopyPackageVersionsInput>
    public typealias MOutput = OperationOutput<CopyPackageVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CopyPackageVersionsOutputError>
}

extension CopyPackageVersionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CopyPackageVersionsInput(allowOverwrite: \(String(describing: allowOverwrite)), destinationRepository: \(String(describing: destinationRepository)), domain: \(String(describing: domain)), domainOwner: \(String(describing: domainOwner)), format: \(String(describing: format)), includeFromUpstream: \(String(describing: includeFromUpstream)), namespace: \(String(describing: namespace)), package: \(String(describing: package)), sourceRepository: \(String(describing: sourceRepository)), versionRevisions: \(String(describing: versionRevisions)), versions: \(String(describing: versions)))"}
}

extension CopyPackageVersionsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case allowOverwrite
        case includeFromUpstream
        case versionRevisions
        case versions
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowOverwrite = allowOverwrite {
            try encodeContainer.encode(allowOverwrite, forKey: .allowOverwrite)
        }
        if let includeFromUpstream = includeFromUpstream {
            try encodeContainer.encode(includeFromUpstream, forKey: .includeFromUpstream)
        }
        if let versionRevisions = versionRevisions {
            var versionRevisionsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .versionRevisions)
            for (dictKey0, packageversionrevisionmap0) in versionRevisions {
                try versionRevisionsContainer.encode(packageversionrevisionmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let versions = versions {
            var versionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .versions)
            for packageversionlist0 in versions {
                try versionsContainer.encode(packageversionlist0)
            }
        }
    }
}

public struct CopyPackageVersionsInputHeadersMiddleware: Middleware {
    public let id: String = "CopyPackageVersionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CopyPackageVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<CopyPackageVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CopyPackageVersionsInput>
    public typealias MOutput = OperationOutput<CopyPackageVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CopyPackageVersionsOutputError>
}

public struct CopyPackageVersionsInputQueryItemMiddleware: Middleware {
    public let id: String = "CopyPackageVersionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CopyPackageVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<CopyPackageVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let sourceRepository = input.operationInput.sourceRepository {
            let sourceRepositoryQueryItem = URLQueryItem(name: "source-repository".urlPercentEncoding(), value: String(sourceRepository).urlPercentEncoding())
            input.builder.withQueryItem(sourceRepositoryQueryItem)
        }
        if let destinationRepository = input.operationInput.destinationRepository {
            let destinationRepositoryQueryItem = URLQueryItem(name: "destination-repository".urlPercentEncoding(), value: String(destinationRepository).urlPercentEncoding())
            input.builder.withQueryItem(destinationRepositoryQueryItem)
        }
        if let package = input.operationInput.package {
            let packageQueryItem = URLQueryItem(name: "package".urlPercentEncoding(), value: String(package).urlPercentEncoding())
            input.builder.withQueryItem(packageQueryItem)
        }
        if let domain = input.operationInput.domain {
            let domainQueryItem = URLQueryItem(name: "domain".urlPercentEncoding(), value: String(domain).urlPercentEncoding())
            input.builder.withQueryItem(domainQueryItem)
        }
        if let domainOwner = input.operationInput.domainOwner {
            let domainOwnerQueryItem = URLQueryItem(name: "domain-owner".urlPercentEncoding(), value: String(domainOwner).urlPercentEncoding())
            input.builder.withQueryItem(domainOwnerQueryItem)
        }
        if let format = input.operationInput.format {
            let formatQueryItem = URLQueryItem(name: "format".urlPercentEncoding(), value: String(format.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(formatQueryItem)
        }
        if let namespace = input.operationInput.namespace {
            let namespaceQueryItem = URLQueryItem(name: "namespace".urlPercentEncoding(), value: String(namespace).urlPercentEncoding())
            input.builder.withQueryItem(namespaceQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CopyPackageVersionsInput>
    public typealias MOutput = OperationOutput<CopyPackageVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CopyPackageVersionsOutputError>
}

public struct CopyPackageVersionsInput: Equatable {
    /// <p>
    ///        Set to true to overwrite a package version that already exists in the destination repository.
    ///        If set to false and the package version already exists in the destination repository,
    ///        the package version is returned in the <code>failedVersions</code> field of the response with
    ///        an <code>ALREADY_EXISTS</code> error code.
    ///      </p>
    public let allowOverwrite: Bool?
    /// <p>
    ///       The name of the repository into which package versions are copied.
    ///     </p>
    public let destinationRepository: String?
    /// <p>
    ///         The name of the domain that contains the source and destination repositories.
    ///       </p>
    public let domain: String?
    /// <p>
    ///         The 12-digit account number of the AWS account that owns the domain. It does not include
    ///         dashes or spaces.
    ///       </p>
    public let domainOwner: String?
    /// <p>
    ///       The format of the package that is copied. The valid package types are:
    ///     </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>npm</code>: A Node Package Manager (npm) package.
    ///         </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>pypi</code>: A Python Package Index (PyPI) package.
    ///         </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>maven</code>: A Maven package that contains compiled code in a distributable format, such as a JAR file.
    ///         </p>
    ///             </li>
    ///          </ul>
    public let format: PackageFormat?
    /// <p> Set to true to copy packages from repositories that are upstream from the source
    ///       repository to the destination repository. The default setting is false. For more information,
    ///       see <a href="https://docs.aws.amazon.com/codeartifact/latest/ug/repos-upstream.html">Working with
    ///         upstream repositories</a>. </p>
    public let includeFromUpstream: Bool?
    /// <p>
    ///       The namespace of the package. The package component that specifies its
    ///       namespace depends on its type. For example:
    ///     </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///           The namespace of a Maven package is its <code>groupId</code>.
    ///         </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///           The namespace of an npm package is its <code>scope</code>.
    ///         </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///           A Python package does not contain a corresponding component, so
    ///           Python packages do not have a namespace.
    ///         </p>
    ///             </li>
    ///          </ul>
    public let namespace: String?
    /// <p>
    ///       The name of the package that is copied.
    ///     </p>
    public let package: String?
    /// <p>
    ///          The name of the repository that contains the package versions to copy.
    ///        </p>
    public let sourceRepository: String?
    /// <p>
    ///        A list of key-value pairs. The keys are package versions and the values are package version revisions. A <code>CopyPackageVersion</code> operation
    ///       succeeds if the specified versions in the source repository match the specified package version revision.
    ///     </p>
    ///          <note>
    ///             <p>
    ///         You must specify <code>versions</code> or <code>versionRevisions</code>. You cannot specify both.
    ///       </p>
    ///          </note>
    public let versionRevisions: [String:String]?
    /// <p>
    ///         The versions of the package to copy.
    ///       </p>
    ///          <note>
    ///             <p>
    ///         You must specify <code>versions</code> or <code>versionRevisions</code>. You cannot specify both.
    ///       </p>
    ///          </note>
    public let versions: [String]?

    public init (
        allowOverwrite: Bool? = nil,
        destinationRepository: String? = nil,
        domain: String? = nil,
        domainOwner: String? = nil,
        format: PackageFormat? = nil,
        includeFromUpstream: Bool? = nil,
        namespace: String? = nil,
        package: String? = nil,
        sourceRepository: String? = nil,
        versionRevisions: [String:String]? = nil,
        versions: [String]? = nil
    )
    {
        self.allowOverwrite = allowOverwrite
        self.destinationRepository = destinationRepository
        self.domain = domain
        self.domainOwner = domainOwner
        self.format = format
        self.includeFromUpstream = includeFromUpstream
        self.namespace = namespace
        self.package = package
        self.sourceRepository = sourceRepository
        self.versionRevisions = versionRevisions
        self.versions = versions
    }
}

struct CopyPackageVersionsInputBody: Equatable {
    public let versions: [String]?
    public let versionRevisions: [String:String]?
    public let allowOverwrite: Bool?
    public let includeFromUpstream: Bool?
}

extension CopyPackageVersionsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case allowOverwrite
        case includeFromUpstream
        case versionRevisions
        case versions
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .versions)
        var versionsDecoded0:[String]? = nil
        if let versionsContainer = versionsContainer {
            versionsDecoded0 = [String]()
            for string0 in versionsContainer {
                if let string0 = string0 {
                    versionsDecoded0?.append(string0)
                }
            }
        }
        versions = versionsDecoded0
        let versionRevisionsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .versionRevisions)
        var versionRevisionsDecoded0: [String:String]? = nil
        if let versionRevisionsContainer = versionRevisionsContainer {
            versionRevisionsDecoded0 = [String:String]()
            for (key0, packageversionrevision0) in versionRevisionsContainer {
                if let packageversionrevision0 = packageversionrevision0 {
                    versionRevisionsDecoded0?[key0] = packageversionrevision0
                }
            }
        }
        versionRevisions = versionRevisionsDecoded0
        let allowOverwriteDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .allowOverwrite)
        allowOverwrite = allowOverwriteDecoded
        let includeFromUpstreamDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .includeFromUpstream)
        includeFromUpstream = includeFromUpstreamDecoded
    }
}

extension CopyPackageVersionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CopyPackageVersionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CopyPackageVersionsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CopyPackageVersionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CopyPackageVersionsOutputResponse(failedVersions: \(String(describing: failedVersions)), successfulVersions: \(String(describing: successfulVersions)))"}
}

extension CopyPackageVersionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CopyPackageVersionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.failedVersions = output.failedVersions
            self.successfulVersions = output.successfulVersions
        } else {
            self.failedVersions = nil
            self.successfulVersions = nil
        }
    }
}

public struct CopyPackageVersionsOutputResponse: Equatable {
    /// <p>
    ///       A map of package versions that failed to copy and their error codes. The possible error codes are in
    ///       the <code>PackageVersionError</code> data type. They are:
    ///     </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>ALREADY_EXISTS</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>MISMATCHED_REVISION</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>MISMATCHED_STATUS</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>NOT_ALLOWED</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>NOT_FOUND</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>SKIPPED</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let failedVersions: [String:PackageVersionError]?
    /// <p>
    ///       A list of the package versions that were successfully copied to your repository.
    ///     </p>
    public let successfulVersions: [String:SuccessfulPackageVersionInfo]?

    public init (
        failedVersions: [String:PackageVersionError]? = nil,
        successfulVersions: [String:SuccessfulPackageVersionInfo]? = nil
    )
    {
        self.failedVersions = failedVersions
        self.successfulVersions = successfulVersions
    }
}

struct CopyPackageVersionsOutputResponseBody: Equatable {
    public let successfulVersions: [String:SuccessfulPackageVersionInfo]?
    public let failedVersions: [String:PackageVersionError]?
}

extension CopyPackageVersionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case failedVersions
        case successfulVersions
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let successfulVersionsContainer = try containerValues.decodeIfPresent([String: SuccessfulPackageVersionInfo?].self, forKey: .successfulVersions)
        var successfulVersionsDecoded0: [String:SuccessfulPackageVersionInfo]? = nil
        if let successfulVersionsContainer = successfulVersionsContainer {
            successfulVersionsDecoded0 = [String:SuccessfulPackageVersionInfo]()
            for (key0, successfulpackageversioninfo0) in successfulVersionsContainer {
                if let successfulpackageversioninfo0 = successfulpackageversioninfo0 {
                    successfulVersionsDecoded0?[key0] = successfulpackageversioninfo0
                }
            }
        }
        successfulVersions = successfulVersionsDecoded0
        let failedVersionsContainer = try containerValues.decodeIfPresent([String: PackageVersionError?].self, forKey: .failedVersions)
        var failedVersionsDecoded0: [String:PackageVersionError]? = nil
        if let failedVersionsContainer = failedVersionsContainer {
            failedVersionsDecoded0 = [String:PackageVersionError]()
            for (key0, packageversionerror0) in failedVersionsContainer {
                if let packageversionerror0 = packageversionerror0 {
                    failedVersionsDecoded0?[key0] = packageversionerror0
                }
            }
        }
        failedVersions = failedVersionsDecoded0
    }
}

public struct CreateDomainInputBodyMiddleware: Middleware {
    public let id: String = "CreateDomainInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDomainInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDomainInput>
    public typealias MOutput = OperationOutput<CreateDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDomainOutputError>
}

extension CreateDomainInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDomainInput(domain: \(String(describing: domain)), encryptionKey: \(String(describing: encryptionKey)), tags: \(String(describing: tags)))"}
}

extension CreateDomainInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case encryptionKey
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encryptionKey = encryptionKey {
            try encodeContainer.encode(encryptionKey, forKey: .encryptionKey)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateDomainInputHeadersMiddleware: Middleware {
    public let id: String = "CreateDomainInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDomainInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDomainInput>
    public typealias MOutput = OperationOutput<CreateDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDomainOutputError>
}

public struct CreateDomainInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateDomainInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDomainInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let domain = input.operationInput.domain {
            let domainQueryItem = URLQueryItem(name: "domain".urlPercentEncoding(), value: String(domain).urlPercentEncoding())
            input.builder.withQueryItem(domainQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDomainInput>
    public typealias MOutput = OperationOutput<CreateDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDomainOutputError>
}

public struct CreateDomainInput: Equatable {
    /// <p> The name of the domain to create. All domain names in an AWS Region that are in the
    ///       same AWS account must be unique. The domain name is used as the prefix in DNS hostnames. Do
    ///       not use sensitive information in a domain name because it is publicly discoverable. </p>
    public let domain: String?
    /// <p> The encryption key for the domain. This is used to encrypt content stored in a domain.
    ///       An encryption key can be a key ID, a key Amazon Resource Name (ARN), a key alias, or a key
    ///       alias ARN. To specify an <code>encryptionKey</code>, your IAM role must have
    ///         <code>kms:DescribeKey</code> and <code>kms:CreateGrant</code> permissions on the encryption
    ///       key that is used. For more information, see <a href="https://docs.aws.amazon.com/kms/latest/APIReference/API_DescribeKey.html#API_DescribeKey_RequestSyntax">DescribeKey</a> in the <i>AWS Key Management Service API Reference</i>
    ///       and <a href="https://docs.aws.amazon.com/kms/latest/developerguide/kms-api-permissions-reference.html">AWS KMS API Permissions
    ///         Reference</a> in the <i>AWS Key Management Service Developer Guide</i>. </p>
    ///          <important>
    ///             <p> CodeArtifact supports only symmetric CMKs. Do not associate an asymmetric CMK with your
    ///         domain. For more information, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/symmetric-asymmetric.html">Using symmetric and asymmetric
    ///           keys</a> in the <i>AWS Key Management Service Developer Guide</i>. </p>
    ///          </important>
    public let encryptionKey: String?
    /// <p>One or more tag key-value pairs for the domain.</p>
    public let tags: [Tag]?

    public init (
        domain: String? = nil,
        encryptionKey: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.domain = domain
        self.encryptionKey = encryptionKey
        self.tags = tags
    }
}

struct CreateDomainInputBody: Equatable {
    public let encryptionKey: String?
    public let tags: [Tag]?
}

extension CreateDomainInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case encryptionKey
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let encryptionKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .encryptionKey)
        encryptionKey = encryptionKeyDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateDomainOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDomainOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDomainOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDomainOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDomainOutputResponse(domain: \(String(describing: domain)))"}
}

extension CreateDomainOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateDomainOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.domain = output.domain
        } else {
            self.domain = nil
        }
    }
}

public struct CreateDomainOutputResponse: Equatable {
    /// <p>
    ///         Contains information about the created domain after processing the request.
    ///       </p>
    public let domain: DomainDescription?

    public init (
        domain: DomainDescription? = nil
    )
    {
        self.domain = domain
    }
}

struct CreateDomainOutputResponseBody: Equatable {
    public let domain: DomainDescription?
}

extension CreateDomainOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case domain
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainDecoded = try containerValues.decodeIfPresent(DomainDescription.self, forKey: .domain)
        domain = domainDecoded
    }
}

public struct CreateRepositoryInputBodyMiddleware: Middleware {
    public let id: String = "CreateRepositoryInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateRepositoryInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateRepositoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateRepositoryInput>
    public typealias MOutput = OperationOutput<CreateRepositoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateRepositoryOutputError>
}

extension CreateRepositoryInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateRepositoryInput(description: \(String(describing: description)), domain: \(String(describing: domain)), domainOwner: \(String(describing: domainOwner)), repository: \(String(describing: repository)), tags: \(String(describing: tags)), upstreams: \(String(describing: upstreams)))"}
}

extension CreateRepositoryInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description
        case tags
        case upstreams
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let upstreams = upstreams {
            var upstreamsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .upstreams)
            for upstreamrepositorylist0 in upstreams {
                try upstreamsContainer.encode(upstreamrepositorylist0)
            }
        }
    }
}

public struct CreateRepositoryInputHeadersMiddleware: Middleware {
    public let id: String = "CreateRepositoryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateRepositoryInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateRepositoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateRepositoryInput>
    public typealias MOutput = OperationOutput<CreateRepositoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateRepositoryOutputError>
}

public struct CreateRepositoryInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateRepositoryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateRepositoryInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateRepositoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let domain = input.operationInput.domain {
            let domainQueryItem = URLQueryItem(name: "domain".urlPercentEncoding(), value: String(domain).urlPercentEncoding())
            input.builder.withQueryItem(domainQueryItem)
        }
        if let domainOwner = input.operationInput.domainOwner {
            let domainOwnerQueryItem = URLQueryItem(name: "domain-owner".urlPercentEncoding(), value: String(domainOwner).urlPercentEncoding())
            input.builder.withQueryItem(domainOwnerQueryItem)
        }
        if let repository = input.operationInput.repository {
            let repositoryQueryItem = URLQueryItem(name: "repository".urlPercentEncoding(), value: String(repository).urlPercentEncoding())
            input.builder.withQueryItem(repositoryQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateRepositoryInput>
    public typealias MOutput = OperationOutput<CreateRepositoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateRepositoryOutputError>
}

public struct CreateRepositoryInput: Equatable {
    /// <p>
    ///       A description of the created repository.
    ///     </p>
    public let description: String?
    /// <p>
    ///         The name of the domain that contains the created repository.
    ///       </p>
    public let domain: String?
    /// <p>
    ///         The 12-digit account number of the AWS account that owns the domain. It does not include
    ///         dashes or spaces.
    ///       </p>
    public let domainOwner: String?
    /// <p> The name of the repository to create. </p>
    public let repository: String?
    /// <p>One or more tag key-value pairs for the repository.</p>
    public let tags: [Tag]?
    /// <p> A list of upstream repositories to associate with the repository. The order of the upstream repositories
    ///         in the list determines their priority order when AWS CodeArtifact looks for a requested package version. For more
    ///         information, see <a href="https://docs.aws.amazon.com/codeartifact/latest/ug/repos-upstream.html">Working with upstream repositories</a>. </p>
    public let upstreams: [UpstreamRepository]?

    public init (
        description: String? = nil,
        domain: String? = nil,
        domainOwner: String? = nil,
        repository: String? = nil,
        tags: [Tag]? = nil,
        upstreams: [UpstreamRepository]? = nil
    )
    {
        self.description = description
        self.domain = domain
        self.domainOwner = domainOwner
        self.repository = repository
        self.tags = tags
        self.upstreams = upstreams
    }
}

struct CreateRepositoryInputBody: Equatable {
    public let description: String?
    public let upstreams: [UpstreamRepository]?
    public let tags: [Tag]?
}

extension CreateRepositoryInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description
        case tags
        case upstreams
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let upstreamsContainer = try containerValues.decodeIfPresent([UpstreamRepository?].self, forKey: .upstreams)
        var upstreamsDecoded0:[UpstreamRepository]? = nil
        if let upstreamsContainer = upstreamsContainer {
            upstreamsDecoded0 = [UpstreamRepository]()
            for structure0 in upstreamsContainer {
                if let structure0 = structure0 {
                    upstreamsDecoded0?.append(structure0)
                }
            }
        }
        upstreams = upstreamsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateRepositoryOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateRepositoryOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateRepositoryOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateRepositoryOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateRepositoryOutputResponse(repository: \(String(describing: repository)))"}
}

extension CreateRepositoryOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateRepositoryOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.repository = output.repository
        } else {
            self.repository = nil
        }
    }
}

public struct CreateRepositoryOutputResponse: Equatable {
    /// <p>
    ///         Information about the created repository after processing the request.
    ///       </p>
    public let repository: RepositoryDescription?

    public init (
        repository: RepositoryDescription? = nil
    )
    {
        self.repository = repository
    }
}

struct CreateRepositoryOutputResponseBody: Equatable {
    public let repository: RepositoryDescription?
}

extension CreateRepositoryOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case repository
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryDecoded = try containerValues.decodeIfPresent(RepositoryDescription.self, forKey: .repository)
        repository = repositoryDecoded
    }
}

extension DeleteDomainInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDomainInput(domain: \(String(describing: domain)), domainOwner: \(String(describing: domainOwner)))"}
}

extension DeleteDomainInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteDomainInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteDomainInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDomainInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDomainInput>
    public typealias MOutput = OperationOutput<DeleteDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDomainOutputError>
}

public struct DeleteDomainInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteDomainInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDomainInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let domain = input.operationInput.domain {
            let domainQueryItem = URLQueryItem(name: "domain".urlPercentEncoding(), value: String(domain).urlPercentEncoding())
            input.builder.withQueryItem(domainQueryItem)
        }
        if let domainOwner = input.operationInput.domainOwner {
            let domainOwnerQueryItem = URLQueryItem(name: "domain-owner".urlPercentEncoding(), value: String(domainOwner).urlPercentEncoding())
            input.builder.withQueryItem(domainOwnerQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDomainInput>
    public typealias MOutput = OperationOutput<DeleteDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDomainOutputError>
}

public struct DeleteDomainInput: Equatable {
    /// <p>
    ///          The name of the domain to delete.
    ///        </p>
    public let domain: String?
    /// <p>
    ///         The 12-digit account number of the AWS account that owns the domain. It does not include
    ///         dashes or spaces.
    ///       </p>
    public let domainOwner: String?

    public init (
        domain: String? = nil,
        domainOwner: String? = nil
    )
    {
        self.domain = domain
        self.domainOwner = domainOwner
    }
}

struct DeleteDomainInputBody: Equatable {
}

extension DeleteDomainInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteDomainOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDomainOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDomainOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDomainOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDomainOutputResponse(domain: \(String(describing: domain)))"}
}

extension DeleteDomainOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteDomainOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.domain = output.domain
        } else {
            self.domain = nil
        }
    }
}

public struct DeleteDomainOutputResponse: Equatable {
    /// <p>
    ///         Contains information about the deleted domain after processing the request.
    ///        </p>
    public let domain: DomainDescription?

    public init (
        domain: DomainDescription? = nil
    )
    {
        self.domain = domain
    }
}

struct DeleteDomainOutputResponseBody: Equatable {
    public let domain: DomainDescription?
}

extension DeleteDomainOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case domain
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainDecoded = try containerValues.decodeIfPresent(DomainDescription.self, forKey: .domain)
        domain = domainDecoded
    }
}

extension DeleteDomainPermissionsPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDomainPermissionsPolicyInput(domain: \(String(describing: domain)), domainOwner: \(String(describing: domainOwner)), policyRevision: \(String(describing: policyRevision)))"}
}

extension DeleteDomainPermissionsPolicyInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteDomainPermissionsPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteDomainPermissionsPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDomainPermissionsPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDomainPermissionsPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDomainPermissionsPolicyInput>
    public typealias MOutput = OperationOutput<DeleteDomainPermissionsPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDomainPermissionsPolicyOutputError>
}

public struct DeleteDomainPermissionsPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteDomainPermissionsPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDomainPermissionsPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDomainPermissionsPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let domain = input.operationInput.domain {
            let domainQueryItem = URLQueryItem(name: "domain".urlPercentEncoding(), value: String(domain).urlPercentEncoding())
            input.builder.withQueryItem(domainQueryItem)
        }
        if let domainOwner = input.operationInput.domainOwner {
            let domainOwnerQueryItem = URLQueryItem(name: "domain-owner".urlPercentEncoding(), value: String(domainOwner).urlPercentEncoding())
            input.builder.withQueryItem(domainOwnerQueryItem)
        }
        if let policyRevision = input.operationInput.policyRevision {
            let policyRevisionQueryItem = URLQueryItem(name: "policy-revision".urlPercentEncoding(), value: String(policyRevision).urlPercentEncoding())
            input.builder.withQueryItem(policyRevisionQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDomainPermissionsPolicyInput>
    public typealias MOutput = OperationOutput<DeleteDomainPermissionsPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDomainPermissionsPolicyOutputError>
}

public struct DeleteDomainPermissionsPolicyInput: Equatable {
    /// <p>
    ///         The name of the domain associated with the resource policy to be deleted.
    ///       </p>
    public let domain: String?
    /// <p>
    ///         The 12-digit account number of the AWS account that owns the domain. It does not include
    ///         dashes or spaces.
    ///       </p>
    public let domainOwner: String?
    /// <p>
    ///         The current revision of the resource policy to be deleted. This revision is used for optimistic locking, which
    ///         prevents others from overwriting your changes to the domain's resource policy.
    ///       </p>
    public let policyRevision: String?

    public init (
        domain: String? = nil,
        domainOwner: String? = nil,
        policyRevision: String? = nil
    )
    {
        self.domain = domain
        self.domainOwner = domainOwner
        self.policyRevision = policyRevision
    }
}

struct DeleteDomainPermissionsPolicyInputBody: Equatable {
}

extension DeleteDomainPermissionsPolicyInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteDomainPermissionsPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDomainPermissionsPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDomainPermissionsPolicyOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDomainPermissionsPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDomainPermissionsPolicyOutputResponse(policy: \(String(describing: policy)))"}
}

extension DeleteDomainPermissionsPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteDomainPermissionsPolicyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.policy = output.policy
        } else {
            self.policy = nil
        }
    }
}

public struct DeleteDomainPermissionsPolicyOutputResponse: Equatable {
    /// <p>
    ///         Information about the deleted resource policy after processing the request.
    ///       </p>
    public let policy: ResourcePolicy?

    public init (
        policy: ResourcePolicy? = nil
    )
    {
        self.policy = policy
    }
}

struct DeleteDomainPermissionsPolicyOutputResponseBody: Equatable {
    public let policy: ResourcePolicy?
}

extension DeleteDomainPermissionsPolicyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case policy
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(ResourcePolicy.self, forKey: .policy)
        policy = policyDecoded
    }
}

public struct DeletePackageVersionsInputBodyMiddleware: Middleware {
    public let id: String = "DeletePackageVersionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeletePackageVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DeletePackageVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeletePackageVersionsInput>
    public typealias MOutput = OperationOutput<DeletePackageVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeletePackageVersionsOutputError>
}

extension DeletePackageVersionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeletePackageVersionsInput(domain: \(String(describing: domain)), domainOwner: \(String(describing: domainOwner)), expectedStatus: \(String(describing: expectedStatus)), format: \(String(describing: format)), namespace: \(String(describing: namespace)), package: \(String(describing: package)), repository: \(String(describing: repository)), versions: \(String(describing: versions)))"}
}

extension DeletePackageVersionsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case expectedStatus
        case versions
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let expectedStatus = expectedStatus {
            try encodeContainer.encode(expectedStatus.rawValue, forKey: .expectedStatus)
        }
        if let versions = versions {
            var versionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .versions)
            for packageversionlist0 in versions {
                try versionsContainer.encode(packageversionlist0)
            }
        }
    }
}

public struct DeletePackageVersionsInputHeadersMiddleware: Middleware {
    public let id: String = "DeletePackageVersionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeletePackageVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DeletePackageVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeletePackageVersionsInput>
    public typealias MOutput = OperationOutput<DeletePackageVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeletePackageVersionsOutputError>
}

public struct DeletePackageVersionsInputQueryItemMiddleware: Middleware {
    public let id: String = "DeletePackageVersionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeletePackageVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DeletePackageVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let package = input.operationInput.package {
            let packageQueryItem = URLQueryItem(name: "package".urlPercentEncoding(), value: String(package).urlPercentEncoding())
            input.builder.withQueryItem(packageQueryItem)
        }
        if let domain = input.operationInput.domain {
            let domainQueryItem = URLQueryItem(name: "domain".urlPercentEncoding(), value: String(domain).urlPercentEncoding())
            input.builder.withQueryItem(domainQueryItem)
        }
        if let domainOwner = input.operationInput.domainOwner {
            let domainOwnerQueryItem = URLQueryItem(name: "domain-owner".urlPercentEncoding(), value: String(domainOwner).urlPercentEncoding())
            input.builder.withQueryItem(domainOwnerQueryItem)
        }
        if let format = input.operationInput.format {
            let formatQueryItem = URLQueryItem(name: "format".urlPercentEncoding(), value: String(format.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(formatQueryItem)
        }
        if let namespace = input.operationInput.namespace {
            let namespaceQueryItem = URLQueryItem(name: "namespace".urlPercentEncoding(), value: String(namespace).urlPercentEncoding())
            input.builder.withQueryItem(namespaceQueryItem)
        }
        if let repository = input.operationInput.repository {
            let repositoryQueryItem = URLQueryItem(name: "repository".urlPercentEncoding(), value: String(repository).urlPercentEncoding())
            input.builder.withQueryItem(repositoryQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeletePackageVersionsInput>
    public typealias MOutput = OperationOutput<DeletePackageVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeletePackageVersionsOutputError>
}

public struct DeletePackageVersionsInput: Equatable {
    /// <p>
    ///         The name of the domain that contains the package to delete.
    ///       </p>
    public let domain: String?
    /// <p>
    ///         The 12-digit account number of the AWS account that owns the domain. It does not include
    ///         dashes or spaces.
    ///       </p>
    public let domainOwner: String?
    /// <p>
    ///         The expected status of the package version to delete. Valid values are:
    ///       </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>Published</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Unfinished</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Unlisted</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Archived</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Disposed</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let expectedStatus: PackageVersionStatus?
    /// <p>
    ///         The format of the package versions to delete. The valid values are:
    ///       </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>npm</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>pypi</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>maven</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let format: PackageFormat?
    /// <p>
    ///       The namespace of the package. The package component that specifies its
    ///       namespace depends on its type. For example:
    ///     </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///           The namespace of a Maven package is its <code>groupId</code>.
    ///         </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///           The namespace of an npm package is its <code>scope</code>.
    ///         </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///           A Python package does not contain a corresponding component, so
    ///           Python packages do not have a namespace.
    ///         </p>
    ///             </li>
    ///          </ul>
    public let namespace: String?
    /// <p>
    ///         The name of the package with the versions to delete.
    ///       </p>
    public let package: String?
    /// <p>
    ///         The name of the repository that contains the package versions to delete.
    ///       </p>
    public let repository: String?
    /// <p>
    ///         An array of strings that specify the versions of the package to delete.
    ///       </p>
    public let versions: [String]?

    public init (
        domain: String? = nil,
        domainOwner: String? = nil,
        expectedStatus: PackageVersionStatus? = nil,
        format: PackageFormat? = nil,
        namespace: String? = nil,
        package: String? = nil,
        repository: String? = nil,
        versions: [String]? = nil
    )
    {
        self.domain = domain
        self.domainOwner = domainOwner
        self.expectedStatus = expectedStatus
        self.format = format
        self.namespace = namespace
        self.package = package
        self.repository = repository
        self.versions = versions
    }
}

struct DeletePackageVersionsInputBody: Equatable {
    public let versions: [String]?
    public let expectedStatus: PackageVersionStatus?
}

extension DeletePackageVersionsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case expectedStatus
        case versions
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .versions)
        var versionsDecoded0:[String]? = nil
        if let versionsContainer = versionsContainer {
            versionsDecoded0 = [String]()
            for string0 in versionsContainer {
                if let string0 = string0 {
                    versionsDecoded0?.append(string0)
                }
            }
        }
        versions = versionsDecoded0
        let expectedStatusDecoded = try containerValues.decodeIfPresent(PackageVersionStatus.self, forKey: .expectedStatus)
        expectedStatus = expectedStatusDecoded
    }
}

extension DeletePackageVersionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeletePackageVersionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeletePackageVersionsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeletePackageVersionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeletePackageVersionsOutputResponse(failedVersions: \(String(describing: failedVersions)), successfulVersions: \(String(describing: successfulVersions)))"}
}

extension DeletePackageVersionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeletePackageVersionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.failedVersions = output.failedVersions
            self.successfulVersions = output.successfulVersions
        } else {
            self.failedVersions = nil
            self.successfulVersions = nil
        }
    }
}

public struct DeletePackageVersionsOutputResponse: Equatable {
    /// <p>
    ///        A <code>PackageVersionError</code> object that contains a map of errors codes for the
    ///        deleted package that failed. The possible error codes are:
    ///      </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>ALREADY_EXISTS</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>MISMATCHED_REVISION</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>MISMATCHED_STATUS</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>NOT_ALLOWED</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>NOT_FOUND</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>SKIPPED</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let failedVersions: [String:PackageVersionError]?
    /// <p>
    ///        A list of the package versions that were successfully deleted.
    ///      </p>
    public let successfulVersions: [String:SuccessfulPackageVersionInfo]?

    public init (
        failedVersions: [String:PackageVersionError]? = nil,
        successfulVersions: [String:SuccessfulPackageVersionInfo]? = nil
    )
    {
        self.failedVersions = failedVersions
        self.successfulVersions = successfulVersions
    }
}

struct DeletePackageVersionsOutputResponseBody: Equatable {
    public let successfulVersions: [String:SuccessfulPackageVersionInfo]?
    public let failedVersions: [String:PackageVersionError]?
}

extension DeletePackageVersionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case failedVersions
        case successfulVersions
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let successfulVersionsContainer = try containerValues.decodeIfPresent([String: SuccessfulPackageVersionInfo?].self, forKey: .successfulVersions)
        var successfulVersionsDecoded0: [String:SuccessfulPackageVersionInfo]? = nil
        if let successfulVersionsContainer = successfulVersionsContainer {
            successfulVersionsDecoded0 = [String:SuccessfulPackageVersionInfo]()
            for (key0, successfulpackageversioninfo0) in successfulVersionsContainer {
                if let successfulpackageversioninfo0 = successfulpackageversioninfo0 {
                    successfulVersionsDecoded0?[key0] = successfulpackageversioninfo0
                }
            }
        }
        successfulVersions = successfulVersionsDecoded0
        let failedVersionsContainer = try containerValues.decodeIfPresent([String: PackageVersionError?].self, forKey: .failedVersions)
        var failedVersionsDecoded0: [String:PackageVersionError]? = nil
        if let failedVersionsContainer = failedVersionsContainer {
            failedVersionsDecoded0 = [String:PackageVersionError]()
            for (key0, packageversionerror0) in failedVersionsContainer {
                if let packageversionerror0 = packageversionerror0 {
                    failedVersionsDecoded0?[key0] = packageversionerror0
                }
            }
        }
        failedVersions = failedVersionsDecoded0
    }
}

extension DeleteRepositoryInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteRepositoryInput(domain: \(String(describing: domain)), domainOwner: \(String(describing: domainOwner)), repository: \(String(describing: repository)))"}
}

extension DeleteRepositoryInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteRepositoryInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteRepositoryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRepositoryInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRepositoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRepositoryInput>
    public typealias MOutput = OperationOutput<DeleteRepositoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRepositoryOutputError>
}

public struct DeleteRepositoryInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteRepositoryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRepositoryInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRepositoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let domain = input.operationInput.domain {
            let domainQueryItem = URLQueryItem(name: "domain".urlPercentEncoding(), value: String(domain).urlPercentEncoding())
            input.builder.withQueryItem(domainQueryItem)
        }
        if let domainOwner = input.operationInput.domainOwner {
            let domainOwnerQueryItem = URLQueryItem(name: "domain-owner".urlPercentEncoding(), value: String(domainOwner).urlPercentEncoding())
            input.builder.withQueryItem(domainOwnerQueryItem)
        }
        if let repository = input.operationInput.repository {
            let repositoryQueryItem = URLQueryItem(name: "repository".urlPercentEncoding(), value: String(repository).urlPercentEncoding())
            input.builder.withQueryItem(repositoryQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRepositoryInput>
    public typealias MOutput = OperationOutput<DeleteRepositoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRepositoryOutputError>
}

public struct DeleteRepositoryInput: Equatable {
    /// <p>
    ///          The name of the domain that contains the repository to delete.
    ///        </p>
    public let domain: String?
    /// <p>
    ///         The 12-digit account number of the AWS account that owns the domain. It does not include
    ///         dashes or spaces.
    ///       </p>
    public let domainOwner: String?
    /// <p> The name of the repository to delete. </p>
    public let repository: String?

    public init (
        domain: String? = nil,
        domainOwner: String? = nil,
        repository: String? = nil
    )
    {
        self.domain = domain
        self.domainOwner = domainOwner
        self.repository = repository
    }
}

struct DeleteRepositoryInputBody: Equatable {
}

extension DeleteRepositoryInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteRepositoryOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteRepositoryOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteRepositoryOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteRepositoryOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteRepositoryOutputResponse(repository: \(String(describing: repository)))"}
}

extension DeleteRepositoryOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteRepositoryOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.repository = output.repository
        } else {
            self.repository = nil
        }
    }
}

public struct DeleteRepositoryOutputResponse: Equatable {
    /// <p>
    ///         Information about the deleted repository after processing the request.
    ///        </p>
    public let repository: RepositoryDescription?

    public init (
        repository: RepositoryDescription? = nil
    )
    {
        self.repository = repository
    }
}

struct DeleteRepositoryOutputResponseBody: Equatable {
    public let repository: RepositoryDescription?
}

extension DeleteRepositoryOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case repository
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryDecoded = try containerValues.decodeIfPresent(RepositoryDescription.self, forKey: .repository)
        repository = repositoryDecoded
    }
}

extension DeleteRepositoryPermissionsPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteRepositoryPermissionsPolicyInput(domain: \(String(describing: domain)), domainOwner: \(String(describing: domainOwner)), policyRevision: \(String(describing: policyRevision)), repository: \(String(describing: repository)))"}
}

extension DeleteRepositoryPermissionsPolicyInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteRepositoryPermissionsPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteRepositoryPermissionsPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRepositoryPermissionsPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRepositoryPermissionsPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRepositoryPermissionsPolicyInput>
    public typealias MOutput = OperationOutput<DeleteRepositoryPermissionsPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRepositoryPermissionsPolicyOutputError>
}

public struct DeleteRepositoryPermissionsPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteRepositoryPermissionsPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRepositoryPermissionsPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRepositoryPermissionsPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let domain = input.operationInput.domain {
            let domainQueryItem = URLQueryItem(name: "domain".urlPercentEncoding(), value: String(domain).urlPercentEncoding())
            input.builder.withQueryItem(domainQueryItem)
        }
        if let domainOwner = input.operationInput.domainOwner {
            let domainOwnerQueryItem = URLQueryItem(name: "domain-owner".urlPercentEncoding(), value: String(domainOwner).urlPercentEncoding())
            input.builder.withQueryItem(domainOwnerQueryItem)
        }
        if let policyRevision = input.operationInput.policyRevision {
            let policyRevisionQueryItem = URLQueryItem(name: "policy-revision".urlPercentEncoding(), value: String(policyRevision).urlPercentEncoding())
            input.builder.withQueryItem(policyRevisionQueryItem)
        }
        if let repository = input.operationInput.repository {
            let repositoryQueryItem = URLQueryItem(name: "repository".urlPercentEncoding(), value: String(repository).urlPercentEncoding())
            input.builder.withQueryItem(repositoryQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRepositoryPermissionsPolicyInput>
    public typealias MOutput = OperationOutput<DeleteRepositoryPermissionsPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRepositoryPermissionsPolicyOutputError>
}

public struct DeleteRepositoryPermissionsPolicyInput: Equatable {
    /// <p>
    ///         The name of the domain that contains the repository associated with the resource policy to be deleted.
    ///       </p>
    public let domain: String?
    /// <p>
    ///         The 12-digit account number of the AWS account that owns the domain. It does not include
    ///         dashes or spaces.
    ///       </p>
    public let domainOwner: String?
    /// <p>
    ///       The revision of the repository's resource policy to be deleted. This revision is used for optimistic locking, which
    ///       prevents others from accidentally overwriting your changes to the repository's resource policy.
    ///     </p>
    public let policyRevision: String?
    /// <p>
    ///       The name of the repository that is associated with the resource policy to be deleted
    ///     </p>
    public let repository: String?

    public init (
        domain: String? = nil,
        domainOwner: String? = nil,
        policyRevision: String? = nil,
        repository: String? = nil
    )
    {
        self.domain = domain
        self.domainOwner = domainOwner
        self.policyRevision = policyRevision
        self.repository = repository
    }
}

struct DeleteRepositoryPermissionsPolicyInputBody: Equatable {
}

extension DeleteRepositoryPermissionsPolicyInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteRepositoryPermissionsPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteRepositoryPermissionsPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteRepositoryPermissionsPolicyOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteRepositoryPermissionsPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteRepositoryPermissionsPolicyOutputResponse(policy: \(String(describing: policy)))"}
}

extension DeleteRepositoryPermissionsPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteRepositoryPermissionsPolicyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.policy = output.policy
        } else {
            self.policy = nil
        }
    }
}

public struct DeleteRepositoryPermissionsPolicyOutputResponse: Equatable {
    /// <p>
    ///       Information about the deleted policy after processing the request.
    ///     </p>
    public let policy: ResourcePolicy?

    public init (
        policy: ResourcePolicy? = nil
    )
    {
        self.policy = policy
    }
}

struct DeleteRepositoryPermissionsPolicyOutputResponseBody: Equatable {
    public let policy: ResourcePolicy?
}

extension DeleteRepositoryPermissionsPolicyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case policy
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(ResourcePolicy.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension DescribeDomainInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDomainInput(domain: \(String(describing: domain)), domainOwner: \(String(describing: domainOwner)))"}
}

extension DescribeDomainInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeDomainInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeDomainInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDomainInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDomainInput>
    public typealias MOutput = OperationOutput<DescribeDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDomainOutputError>
}

public struct DescribeDomainInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeDomainInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDomainInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let domain = input.operationInput.domain {
            let domainQueryItem = URLQueryItem(name: "domain".urlPercentEncoding(), value: String(domain).urlPercentEncoding())
            input.builder.withQueryItem(domainQueryItem)
        }
        if let domainOwner = input.operationInput.domainOwner {
            let domainOwnerQueryItem = URLQueryItem(name: "domain-owner".urlPercentEncoding(), value: String(domainOwner).urlPercentEncoding())
            input.builder.withQueryItem(domainOwnerQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDomainInput>
    public typealias MOutput = OperationOutput<DescribeDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDomainOutputError>
}

public struct DescribeDomainInput: Equatable {
    /// <p>
    ///          A string that specifies the name of the requested domain.
    ///      </p>
    public let domain: String?
    /// <p>
    ///         The 12-digit account number of the AWS account that owns the domain. It does not include
    ///         dashes or spaces.
    ///       </p>
    public let domainOwner: String?

    public init (
        domain: String? = nil,
        domainOwner: String? = nil
    )
    {
        self.domain = domain
        self.domainOwner = domainOwner
    }
}

struct DescribeDomainInputBody: Equatable {
}

extension DescribeDomainInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeDomainOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDomainOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDomainOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDomainOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDomainOutputResponse(domain: \(String(describing: domain)))"}
}

extension DescribeDomainOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeDomainOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.domain = output.domain
        } else {
            self.domain = nil
        }
    }
}

public struct DescribeDomainOutputResponse: Equatable {
    /// <p>
    ///        Information about a domain. A domain is a container for repositories. When you create a domain, it is empty until you
    ///        add one or more repositories.
    ///       </p>
    public let domain: DomainDescription?

    public init (
        domain: DomainDescription? = nil
    )
    {
        self.domain = domain
    }
}

struct DescribeDomainOutputResponseBody: Equatable {
    public let domain: DomainDescription?
}

extension DescribeDomainOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case domain
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainDecoded = try containerValues.decodeIfPresent(DomainDescription.self, forKey: .domain)
        domain = domainDecoded
    }
}

extension DescribePackageVersionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribePackageVersionInput(domain: \(String(describing: domain)), domainOwner: \(String(describing: domainOwner)), format: \(String(describing: format)), namespace: \(String(describing: namespace)), package: \(String(describing: package)), packageVersion: \(String(describing: packageVersion)), repository: \(String(describing: repository)))"}
}

extension DescribePackageVersionInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribePackageVersionInputHeadersMiddleware: Middleware {
    public let id: String = "DescribePackageVersionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribePackageVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribePackageVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribePackageVersionInput>
    public typealias MOutput = OperationOutput<DescribePackageVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribePackageVersionOutputError>
}

public struct DescribePackageVersionInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribePackageVersionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribePackageVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribePackageVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let package = input.operationInput.package {
            let packageQueryItem = URLQueryItem(name: "package".urlPercentEncoding(), value: String(package).urlPercentEncoding())
            input.builder.withQueryItem(packageQueryItem)
        }
        if let domain = input.operationInput.domain {
            let domainQueryItem = URLQueryItem(name: "domain".urlPercentEncoding(), value: String(domain).urlPercentEncoding())
            input.builder.withQueryItem(domainQueryItem)
        }
        if let domainOwner = input.operationInput.domainOwner {
            let domainOwnerQueryItem = URLQueryItem(name: "domain-owner".urlPercentEncoding(), value: String(domainOwner).urlPercentEncoding())
            input.builder.withQueryItem(domainOwnerQueryItem)
        }
        if let format = input.operationInput.format {
            let formatQueryItem = URLQueryItem(name: "format".urlPercentEncoding(), value: String(format.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(formatQueryItem)
        }
        if let namespace = input.operationInput.namespace {
            let namespaceQueryItem = URLQueryItem(name: "namespace".urlPercentEncoding(), value: String(namespace).urlPercentEncoding())
            input.builder.withQueryItem(namespaceQueryItem)
        }
        if let packageVersion = input.operationInput.packageVersion {
            let packageVersionQueryItem = URLQueryItem(name: "version".urlPercentEncoding(), value: String(packageVersion).urlPercentEncoding())
            input.builder.withQueryItem(packageVersionQueryItem)
        }
        if let repository = input.operationInput.repository {
            let repositoryQueryItem = URLQueryItem(name: "repository".urlPercentEncoding(), value: String(repository).urlPercentEncoding())
            input.builder.withQueryItem(repositoryQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribePackageVersionInput>
    public typealias MOutput = OperationOutput<DescribePackageVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribePackageVersionOutputError>
}

public struct DescribePackageVersionInput: Equatable {
    /// <p>
    ///       The name of the domain that contains the repository that contains the package version.
    ///     </p>
    public let domain: String?
    /// <p>
    ///         The 12-digit account number of the AWS account that owns the domain. It does not include
    ///         dashes or spaces.
    ///       </p>
    public let domainOwner: String?
    /// <p>
    ///       A format that specifies the type of the requested package version. The valid values are:
    ///     </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>npm</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>pypi</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>maven</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let format: PackageFormat?
    /// <p>
    ///       The namespace of the package. The package component that specifies its
    ///       namespace depends on its type. For example:
    ///     </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///           The namespace of a Maven package is its <code>groupId</code>.
    ///         </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///           The namespace of an npm package is its <code>scope</code>.
    ///         </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///           A Python package does not contain a corresponding component, so
    ///           Python packages do not have a namespace.
    ///         </p>
    ///             </li>
    ///          </ul>
    public let namespace: String?
    /// <p> The name of the requested package version. </p>
    public let package: String?
    /// <p>
    ///       A string that contains the package version (for example, <code>3.5.2</code>).
    ///     </p>
    public let packageVersion: String?
    /// <p> The name of the repository that contains the package version. </p>
    public let repository: String?

    public init (
        domain: String? = nil,
        domainOwner: String? = nil,
        format: PackageFormat? = nil,
        namespace: String? = nil,
        package: String? = nil,
        packageVersion: String? = nil,
        repository: String? = nil
    )
    {
        self.domain = domain
        self.domainOwner = domainOwner
        self.format = format
        self.namespace = namespace
        self.package = package
        self.packageVersion = packageVersion
        self.repository = repository
    }
}

struct DescribePackageVersionInputBody: Equatable {
}

extension DescribePackageVersionInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribePackageVersionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribePackageVersionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribePackageVersionOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribePackageVersionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribePackageVersionOutputResponse(packageVersion: \(String(describing: packageVersion)))"}
}

extension DescribePackageVersionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribePackageVersionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.packageVersion = output.packageVersion
        } else {
            self.packageVersion = nil
        }
    }
}

public struct DescribePackageVersionOutputResponse: Equatable {
    /// <p>
    ///       A <a href="https://docs.aws.amazon.com/codeartifact/latest/APIReference/API_PackageVersionDescription.html">PackageVersionDescription</a>
    ///       object that contains information about the requested package version.
    ///     </p>
    public let packageVersion: PackageVersionDescription?

    public init (
        packageVersion: PackageVersionDescription? = nil
    )
    {
        self.packageVersion = packageVersion
    }
}

struct DescribePackageVersionOutputResponseBody: Equatable {
    public let packageVersion: PackageVersionDescription?
}

extension DescribePackageVersionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case packageVersion
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let packageVersionDecoded = try containerValues.decodeIfPresent(PackageVersionDescription.self, forKey: .packageVersion)
        packageVersion = packageVersionDecoded
    }
}

extension DescribeRepositoryInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeRepositoryInput(domain: \(String(describing: domain)), domainOwner: \(String(describing: domainOwner)), repository: \(String(describing: repository)))"}
}

extension DescribeRepositoryInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeRepositoryInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeRepositoryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeRepositoryInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeRepositoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeRepositoryInput>
    public typealias MOutput = OperationOutput<DescribeRepositoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeRepositoryOutputError>
}

public struct DescribeRepositoryInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeRepositoryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeRepositoryInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeRepositoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let domain = input.operationInput.domain {
            let domainQueryItem = URLQueryItem(name: "domain".urlPercentEncoding(), value: String(domain).urlPercentEncoding())
            input.builder.withQueryItem(domainQueryItem)
        }
        if let domainOwner = input.operationInput.domainOwner {
            let domainOwnerQueryItem = URLQueryItem(name: "domain-owner".urlPercentEncoding(), value: String(domainOwner).urlPercentEncoding())
            input.builder.withQueryItem(domainOwnerQueryItem)
        }
        if let repository = input.operationInput.repository {
            let repositoryQueryItem = URLQueryItem(name: "repository".urlPercentEncoding(), value: String(repository).urlPercentEncoding())
            input.builder.withQueryItem(repositoryQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeRepositoryInput>
    public typealias MOutput = OperationOutput<DescribeRepositoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeRepositoryOutputError>
}

public struct DescribeRepositoryInput: Equatable {
    /// <p>
    ///          The name of the domain that contains the repository to describe.
    ///        </p>
    public let domain: String?
    /// <p>
    ///         The 12-digit account number of the AWS account that owns the domain. It does not include
    ///         dashes or spaces.
    ///       </p>
    public let domainOwner: String?
    /// <p>
    ///         A string that specifies the name of the requested repository.
    ///        </p>
    public let repository: String?

    public init (
        domain: String? = nil,
        domainOwner: String? = nil,
        repository: String? = nil
    )
    {
        self.domain = domain
        self.domainOwner = domainOwner
        self.repository = repository
    }
}

struct DescribeRepositoryInputBody: Equatable {
}

extension DescribeRepositoryInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeRepositoryOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeRepositoryOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeRepositoryOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeRepositoryOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeRepositoryOutputResponse(repository: \(String(describing: repository)))"}
}

extension DescribeRepositoryOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeRepositoryOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.repository = output.repository
        } else {
            self.repository = nil
        }
    }
}

public struct DescribeRepositoryOutputResponse: Equatable {
    /// <p>
    ///          A <code>RepositoryDescription</code> object that contains the requested repository information.
    ///        </p>
    public let repository: RepositoryDescription?

    public init (
        repository: RepositoryDescription? = nil
    )
    {
        self.repository = repository
    }
}

struct DescribeRepositoryOutputResponseBody: Equatable {
    public let repository: RepositoryDescription?
}

extension DescribeRepositoryOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case repository
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryDecoded = try containerValues.decodeIfPresent(RepositoryDescription.self, forKey: .repository)
        repository = repositoryDecoded
    }
}

extension DisassociateExternalConnectionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateExternalConnectionInput(domain: \(String(describing: domain)), domainOwner: \(String(describing: domainOwner)), externalConnection: \(String(describing: externalConnection)), repository: \(String(describing: repository)))"}
}

extension DisassociateExternalConnectionInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DisassociateExternalConnectionInputHeadersMiddleware: Middleware {
    public let id: String = "DisassociateExternalConnectionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateExternalConnectionInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateExternalConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateExternalConnectionInput>
    public typealias MOutput = OperationOutput<DisassociateExternalConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateExternalConnectionOutputError>
}

public struct DisassociateExternalConnectionInputQueryItemMiddleware: Middleware {
    public let id: String = "DisassociateExternalConnectionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateExternalConnectionInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateExternalConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let externalConnection = input.operationInput.externalConnection {
            let externalConnectionQueryItem = URLQueryItem(name: "external-connection".urlPercentEncoding(), value: String(externalConnection).urlPercentEncoding())
            input.builder.withQueryItem(externalConnectionQueryItem)
        }
        if let domain = input.operationInput.domain {
            let domainQueryItem = URLQueryItem(name: "domain".urlPercentEncoding(), value: String(domain).urlPercentEncoding())
            input.builder.withQueryItem(domainQueryItem)
        }
        if let domainOwner = input.operationInput.domainOwner {
            let domainOwnerQueryItem = URLQueryItem(name: "domain-owner".urlPercentEncoding(), value: String(domainOwner).urlPercentEncoding())
            input.builder.withQueryItem(domainOwnerQueryItem)
        }
        if let repository = input.operationInput.repository {
            let repositoryQueryItem = URLQueryItem(name: "repository".urlPercentEncoding(), value: String(repository).urlPercentEncoding())
            input.builder.withQueryItem(repositoryQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateExternalConnectionInput>
    public typealias MOutput = OperationOutput<DisassociateExternalConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateExternalConnectionOutputError>
}

public struct DisassociateExternalConnectionInput: Equatable {
    /// <p>The name of the domain that contains the repository from which to remove the external
    ///       repository. </p>
    public let domain: String?
    /// <p>
    ///         The 12-digit account number of the AWS account that owns the domain. It does not include
    ///         dashes or spaces.
    ///       </p>
    public let domainOwner: String?
    /// <p>The name of the external connection to be removed from the repository. </p>
    public let externalConnection: String?
    /// <p>The name of the repository from which the external connection will be removed. </p>
    public let repository: String?

    public init (
        domain: String? = nil,
        domainOwner: String? = nil,
        externalConnection: String? = nil,
        repository: String? = nil
    )
    {
        self.domain = domain
        self.domainOwner = domainOwner
        self.externalConnection = externalConnection
        self.repository = repository
    }
}

struct DisassociateExternalConnectionInputBody: Equatable {
}

extension DisassociateExternalConnectionInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DisassociateExternalConnectionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateExternalConnectionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateExternalConnectionOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateExternalConnectionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateExternalConnectionOutputResponse(repository: \(String(describing: repository)))"}
}

extension DisassociateExternalConnectionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DisassociateExternalConnectionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.repository = output.repository
        } else {
            self.repository = nil
        }
    }
}

public struct DisassociateExternalConnectionOutputResponse: Equatable {
    /// <p>
    ///       The repository associated with the removed external connection.
    ///     </p>
    public let repository: RepositoryDescription?

    public init (
        repository: RepositoryDescription? = nil
    )
    {
        self.repository = repository
    }
}

struct DisassociateExternalConnectionOutputResponseBody: Equatable {
    public let repository: RepositoryDescription?
}

extension DisassociateExternalConnectionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case repository
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryDecoded = try containerValues.decodeIfPresent(RepositoryDescription.self, forKey: .repository)
        repository = repositoryDecoded
    }
}

public struct DisposePackageVersionsInputBodyMiddleware: Middleware {
    public let id: String = "DisposePackageVersionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisposePackageVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DisposePackageVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisposePackageVersionsInput>
    public typealias MOutput = OperationOutput<DisposePackageVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisposePackageVersionsOutputError>
}

extension DisposePackageVersionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisposePackageVersionsInput(domain: \(String(describing: domain)), domainOwner: \(String(describing: domainOwner)), expectedStatus: \(String(describing: expectedStatus)), format: \(String(describing: format)), namespace: \(String(describing: namespace)), package: \(String(describing: package)), repository: \(String(describing: repository)), versionRevisions: \(String(describing: versionRevisions)), versions: \(String(describing: versions)))"}
}

extension DisposePackageVersionsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case expectedStatus
        case versionRevisions
        case versions
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let expectedStatus = expectedStatus {
            try encodeContainer.encode(expectedStatus.rawValue, forKey: .expectedStatus)
        }
        if let versionRevisions = versionRevisions {
            var versionRevisionsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .versionRevisions)
            for (dictKey0, packageversionrevisionmap0) in versionRevisions {
                try versionRevisionsContainer.encode(packageversionrevisionmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let versions = versions {
            var versionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .versions)
            for packageversionlist0 in versions {
                try versionsContainer.encode(packageversionlist0)
            }
        }
    }
}

public struct DisposePackageVersionsInputHeadersMiddleware: Middleware {
    public let id: String = "DisposePackageVersionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisposePackageVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DisposePackageVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisposePackageVersionsInput>
    public typealias MOutput = OperationOutput<DisposePackageVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisposePackageVersionsOutputError>
}

public struct DisposePackageVersionsInputQueryItemMiddleware: Middleware {
    public let id: String = "DisposePackageVersionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisposePackageVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DisposePackageVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let package = input.operationInput.package {
            let packageQueryItem = URLQueryItem(name: "package".urlPercentEncoding(), value: String(package).urlPercentEncoding())
            input.builder.withQueryItem(packageQueryItem)
        }
        if let domain = input.operationInput.domain {
            let domainQueryItem = URLQueryItem(name: "domain".urlPercentEncoding(), value: String(domain).urlPercentEncoding())
            input.builder.withQueryItem(domainQueryItem)
        }
        if let domainOwner = input.operationInput.domainOwner {
            let domainOwnerQueryItem = URLQueryItem(name: "domain-owner".urlPercentEncoding(), value: String(domainOwner).urlPercentEncoding())
            input.builder.withQueryItem(domainOwnerQueryItem)
        }
        if let format = input.operationInput.format {
            let formatQueryItem = URLQueryItem(name: "format".urlPercentEncoding(), value: String(format.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(formatQueryItem)
        }
        if let namespace = input.operationInput.namespace {
            let namespaceQueryItem = URLQueryItem(name: "namespace".urlPercentEncoding(), value: String(namespace).urlPercentEncoding())
            input.builder.withQueryItem(namespaceQueryItem)
        }
        if let repository = input.operationInput.repository {
            let repositoryQueryItem = URLQueryItem(name: "repository".urlPercentEncoding(), value: String(repository).urlPercentEncoding())
            input.builder.withQueryItem(repositoryQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisposePackageVersionsInput>
    public typealias MOutput = OperationOutput<DisposePackageVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisposePackageVersionsOutputError>
}

public struct DisposePackageVersionsInput: Equatable {
    /// <p>
    ///       The name of the domain that contains the repository you want to dispose.
    ///     </p>
    public let domain: String?
    /// <p>
    ///         The 12-digit account number of the AWS account that owns the domain. It does not include
    ///         dashes or spaces.
    ///       </p>
    public let domainOwner: String?
    /// <p>
    ///       The expected status of the package version to dispose. Valid values are:
    ///     </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>Published</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Unfinished</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Unlisted</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Archived</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Disposed</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let expectedStatus: PackageVersionStatus?
    /// <p>
    ///       A format that specifies the type of package versions you want to dispose. The valid values are:
    ///     </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>npm</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>pypi</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>maven</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let format: PackageFormat?
    /// <p>
    ///       The namespace of the package. The package component that specifies its
    ///       namespace depends on its type. For example:
    ///     </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///           The namespace of a Maven package is its <code>groupId</code>.
    ///         </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///           The namespace of an npm package is its <code>scope</code>.
    ///         </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///           A Python package does not contain a corresponding component, so
    ///           Python packages do not have a namespace.
    ///         </p>
    ///             </li>
    ///          </ul>
    public let namespace: String?
    /// <p>
    ///       The name of the package with the versions you want to dispose.
    ///     </p>
    public let package: String?
    /// <p>
    ///       The name of the repository that contains the package versions you want to dispose.
    ///     </p>
    public let repository: String?
    /// <p>
    ///       The revisions of the package versions you want to dispose.
    ///     </p>
    public let versionRevisions: [String:String]?
    /// <p>
    ///       The versions of the package you want to dispose.
    ///     </p>
    public let versions: [String]?

    public init (
        domain: String? = nil,
        domainOwner: String? = nil,
        expectedStatus: PackageVersionStatus? = nil,
        format: PackageFormat? = nil,
        namespace: String? = nil,
        package: String? = nil,
        repository: String? = nil,
        versionRevisions: [String:String]? = nil,
        versions: [String]? = nil
    )
    {
        self.domain = domain
        self.domainOwner = domainOwner
        self.expectedStatus = expectedStatus
        self.format = format
        self.namespace = namespace
        self.package = package
        self.repository = repository
        self.versionRevisions = versionRevisions
        self.versions = versions
    }
}

struct DisposePackageVersionsInputBody: Equatable {
    public let versions: [String]?
    public let versionRevisions: [String:String]?
    public let expectedStatus: PackageVersionStatus?
}

extension DisposePackageVersionsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case expectedStatus
        case versionRevisions
        case versions
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .versions)
        var versionsDecoded0:[String]? = nil
        if let versionsContainer = versionsContainer {
            versionsDecoded0 = [String]()
            for string0 in versionsContainer {
                if let string0 = string0 {
                    versionsDecoded0?.append(string0)
                }
            }
        }
        versions = versionsDecoded0
        let versionRevisionsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .versionRevisions)
        var versionRevisionsDecoded0: [String:String]? = nil
        if let versionRevisionsContainer = versionRevisionsContainer {
            versionRevisionsDecoded0 = [String:String]()
            for (key0, packageversionrevision0) in versionRevisionsContainer {
                if let packageversionrevision0 = packageversionrevision0 {
                    versionRevisionsDecoded0?[key0] = packageversionrevision0
                }
            }
        }
        versionRevisions = versionRevisionsDecoded0
        let expectedStatusDecoded = try containerValues.decodeIfPresent(PackageVersionStatus.self, forKey: .expectedStatus)
        expectedStatus = expectedStatusDecoded
    }
}

extension DisposePackageVersionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisposePackageVersionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisposePackageVersionsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisposePackageVersionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisposePackageVersionsOutputResponse(failedVersions: \(String(describing: failedVersions)), successfulVersions: \(String(describing: successfulVersions)))"}
}

extension DisposePackageVersionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DisposePackageVersionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.failedVersions = output.failedVersions
            self.successfulVersions = output.successfulVersions
        } else {
            self.failedVersions = nil
            self.successfulVersions = nil
        }
    }
}

public struct DisposePackageVersionsOutputResponse: Equatable {
    /// <p>
    ///       A <code>PackageVersionError</code> object that contains a map of errors codes for the
    ///       disposed package versions that failed. The possible error codes are:
    ///     </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>ALREADY_EXISTS</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>MISMATCHED_REVISION</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>MISMATCHED_STATUS</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>NOT_ALLOWED</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>NOT_FOUND</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>SKIPPED</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let failedVersions: [String:PackageVersionError]?
    /// <p>
    ///       A list of the package versions that were successfully disposed.
    ///     </p>
    public let successfulVersions: [String:SuccessfulPackageVersionInfo]?

    public init (
        failedVersions: [String:PackageVersionError]? = nil,
        successfulVersions: [String:SuccessfulPackageVersionInfo]? = nil
    )
    {
        self.failedVersions = failedVersions
        self.successfulVersions = successfulVersions
    }
}

struct DisposePackageVersionsOutputResponseBody: Equatable {
    public let successfulVersions: [String:SuccessfulPackageVersionInfo]?
    public let failedVersions: [String:PackageVersionError]?
}

extension DisposePackageVersionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case failedVersions
        case successfulVersions
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let successfulVersionsContainer = try containerValues.decodeIfPresent([String: SuccessfulPackageVersionInfo?].self, forKey: .successfulVersions)
        var successfulVersionsDecoded0: [String:SuccessfulPackageVersionInfo]? = nil
        if let successfulVersionsContainer = successfulVersionsContainer {
            successfulVersionsDecoded0 = [String:SuccessfulPackageVersionInfo]()
            for (key0, successfulpackageversioninfo0) in successfulVersionsContainer {
                if let successfulpackageversioninfo0 = successfulpackageversioninfo0 {
                    successfulVersionsDecoded0?[key0] = successfulpackageversioninfo0
                }
            }
        }
        successfulVersions = successfulVersionsDecoded0
        let failedVersionsContainer = try containerValues.decodeIfPresent([String: PackageVersionError?].self, forKey: .failedVersions)
        var failedVersionsDecoded0: [String:PackageVersionError]? = nil
        if let failedVersionsContainer = failedVersionsContainer {
            failedVersionsDecoded0 = [String:PackageVersionError]()
            for (key0, packageversionerror0) in failedVersionsContainer {
                if let packageversionerror0 = packageversionerror0 {
                    failedVersionsDecoded0?[key0] = packageversionerror0
                }
            }
        }
        failedVersions = failedVersionsDecoded0
    }
}

extension DomainDescription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case assetSizeBytes
        case createdTime
        case encryptionKey
        case name
        case owner
        case repositoryCount
        case s3BucketArn
        case status
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if assetSizeBytes != 0 {
            try encodeContainer.encode(assetSizeBytes, forKey: .assetSizeBytes)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
        if let encryptionKey = encryptionKey {
            try encodeContainer.encode(encryptionKey, forKey: .encryptionKey)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let owner = owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
        if repositoryCount != 0 {
            try encodeContainer.encode(repositoryCount, forKey: .repositoryCount)
        }
        if let s3BucketArn = s3BucketArn {
            try encodeContainer.encode(s3BucketArn, forKey: .s3BucketArn)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .owner)
        owner = ownerDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DomainStatus.self, forKey: .status)
        status = statusDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let encryptionKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .encryptionKey)
        encryptionKey = encryptionKeyDecoded
        let repositoryCountDecoded = try containerValues.decode(Int.self, forKey: .repositoryCount)
        repositoryCount = repositoryCountDecoded
        let assetSizeBytesDecoded = try containerValues.decode(Int.self, forKey: .assetSizeBytes)
        assetSizeBytes = assetSizeBytesDecoded
        let s3BucketArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3BucketArn)
        s3BucketArn = s3BucketArnDecoded
    }
}

extension DomainDescription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DomainDescription(arn: \(String(describing: arn)), assetSizeBytes: \(String(describing: assetSizeBytes)), createdTime: \(String(describing: createdTime)), encryptionKey: \(String(describing: encryptionKey)), name: \(String(describing: name)), owner: \(String(describing: owner)), repositoryCount: \(String(describing: repositoryCount)), s3BucketArn: \(String(describing: s3BucketArn)), status: \(String(describing: status)))"}
}

/// <p>
///        Information about a domain. A domain is a container for repositories. When you create a domain, it is empty until you
///        add one or more repositories.
///       </p>
public struct DomainDescription: Equatable {
    /// <p> The Amazon Resource Name (ARN) of the domain. </p>
    public let arn: String?
    /// <p>
    ///       The total size of all assets in the domain.
    ///     </p>
    public let assetSizeBytes: Int
    /// <p>
    ///       A timestamp that represents the date and time the domain was created.
    ///     </p>
    public let createdTime: Date?
    /// <p> The ARN of an AWS Key Management Service (AWS KMS) key associated with a domain. </p>
    public let encryptionKey: String?
    /// <p>
    ///          The name of the domain.
    ///        </p>
    public let name: String?
    /// <p> The AWS account ID that owns the domain. </p>
    public let owner: String?
    /// <p>
    ///       The number of repositories in the domain.
    ///     </p>
    public let repositoryCount: Int
    /// <p>The Amazon Resource Name (ARN) of the Amazon S3 bucket that is used to store package assets in the domain.</p>
    public let s3BucketArn: String?
    /// <p> The current status of a domain. The valid values are </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>Active</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Deleted</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let status: DomainStatus?

    public init (
        arn: String? = nil,
        assetSizeBytes: Int = 0,
        createdTime: Date? = nil,
        encryptionKey: String? = nil,
        name: String? = nil,
        owner: String? = nil,
        repositoryCount: Int = 0,
        s3BucketArn: String? = nil,
        status: DomainStatus? = nil
    )
    {
        self.arn = arn
        self.assetSizeBytes = assetSizeBytes
        self.createdTime = createdTime
        self.encryptionKey = encryptionKey
        self.name = name
        self.owner = owner
        self.repositoryCount = repositoryCount
        self.s3BucketArn = s3BucketArn
        self.status = status
    }
}

public enum DomainStatus {
    case active
    case deleted
    case sdkUnknown(String)
}

extension DomainStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DomainStatus] {
        return [
            .active,
            .deleted,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .active: return "Active"
        case .deleted: return "Deleted"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DomainStatus(rawValue: rawValue) ?? DomainStatus.sdkUnknown(rawValue)
    }
}

extension DomainSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case createdTime
        case encryptionKey
        case name
        case owner
        case status
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
        if let encryptionKey = encryptionKey {
            try encodeContainer.encode(encryptionKey, forKey: .encryptionKey)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let owner = owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .owner)
        owner = ownerDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DomainStatus.self, forKey: .status)
        status = statusDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let encryptionKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .encryptionKey)
        encryptionKey = encryptionKeyDecoded
    }
}

extension DomainSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DomainSummary(arn: \(String(describing: arn)), createdTime: \(String(describing: createdTime)), encryptionKey: \(String(describing: encryptionKey)), name: \(String(describing: name)), owner: \(String(describing: owner)), status: \(String(describing: status)))"}
}

/// <p> Information about a domain, including its name, Amazon Resource Name (ARN), and status.
///       The <a href="https://docs.aws.amazon.com/codeartifact/latest/APIReference/API_ListDomains.html">ListDomains</a> operation returns a list of <code>DomainSummary</code>
///       objects. </p>
public struct DomainSummary: Equatable {
    /// <p>
    ///       The ARN of the domain.
    ///     </p>
    public let arn: String?
    /// <p>
    ///       A timestamp that contains the date and time the domain was created.
    ///     </p>
    public let createdTime: Date?
    /// <p>
    ///       The key used to encrypt the domain.
    ///     </p>
    public let encryptionKey: String?
    /// <p>
    ///       The name of the domain.
    ///     </p>
    public let name: String?
    /// <p>
    ///         The 12-digit account number of the AWS account that owns the domain. It does not include
    ///         dashes or spaces.
    ///       </p>
    public let owner: String?
    /// <p>
    ///       A string that contains the status of the domain. The valid values are:
    ///     </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>Active</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Deleted</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let status: DomainStatus?

    public init (
        arn: String? = nil,
        createdTime: Date? = nil,
        encryptionKey: String? = nil,
        name: String? = nil,
        owner: String? = nil,
        status: DomainStatus? = nil
    )
    {
        self.arn = arn
        self.createdTime = createdTime
        self.encryptionKey = encryptionKey
        self.name = name
        self.owner = owner
        self.status = status
    }
}

public enum ExternalConnectionStatus {
    case available
    case sdkUnknown(String)
}

extension ExternalConnectionStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ExternalConnectionStatus] {
        return [
            .available,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .available: return "Available"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ExternalConnectionStatus(rawValue: rawValue) ?? ExternalConnectionStatus.sdkUnknown(rawValue)
    }
}

extension GetAuthorizationTokenInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAuthorizationTokenInput(domain: \(String(describing: domain)), domainOwner: \(String(describing: domainOwner)), durationSeconds: \(String(describing: durationSeconds)))"}
}

extension GetAuthorizationTokenInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetAuthorizationTokenInputHeadersMiddleware: Middleware {
    public let id: String = "GetAuthorizationTokenInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAuthorizationTokenInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAuthorizationTokenOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAuthorizationTokenInput>
    public typealias MOutput = OperationOutput<GetAuthorizationTokenOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAuthorizationTokenOutputError>
}

public struct GetAuthorizationTokenInputQueryItemMiddleware: Middleware {
    public let id: String = "GetAuthorizationTokenInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAuthorizationTokenInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAuthorizationTokenOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let durationSeconds = input.operationInput.durationSeconds {
            let durationSecondsQueryItem = URLQueryItem(name: "duration".urlPercentEncoding(), value: String(durationSeconds).urlPercentEncoding())
            input.builder.withQueryItem(durationSecondsQueryItem)
        }
        if let domain = input.operationInput.domain {
            let domainQueryItem = URLQueryItem(name: "domain".urlPercentEncoding(), value: String(domain).urlPercentEncoding())
            input.builder.withQueryItem(domainQueryItem)
        }
        if let domainOwner = input.operationInput.domainOwner {
            let domainOwnerQueryItem = URLQueryItem(name: "domain-owner".urlPercentEncoding(), value: String(domainOwner).urlPercentEncoding())
            input.builder.withQueryItem(domainOwnerQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAuthorizationTokenInput>
    public typealias MOutput = OperationOutput<GetAuthorizationTokenOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAuthorizationTokenOutputError>
}

public struct GetAuthorizationTokenInput: Equatable {
    /// <p>
    ///         The name of the domain that is in scope for the generated authorization token.
    ///        </p>
    public let domain: String?
    /// <p>
    ///         The 12-digit account number of the AWS account that owns the domain. It does not include
    ///         dashes or spaces.
    ///       </p>
    public let domainOwner: String?
    /// <p>The time, in seconds, that the generated authorization token is valid. Valid values are
    ///     <code>0</code> and any number between <code>900</code> (15 minutes) and <code>43200</code> (12 hours).
    ///     A value of <code>0</code> will set the expiration of the authorization token to the same expiration of
    ///     the user's role's temporary credentials.</p>
    public let durationSeconds: Int?

    public init (
        domain: String? = nil,
        domainOwner: String? = nil,
        durationSeconds: Int? = nil
    )
    {
        self.domain = domain
        self.domainOwner = domainOwner
        self.durationSeconds = durationSeconds
    }
}

struct GetAuthorizationTokenInputBody: Equatable {
}

extension GetAuthorizationTokenInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetAuthorizationTokenOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAuthorizationTokenOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAuthorizationTokenOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAuthorizationTokenOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAuthorizationTokenOutputResponse(authorizationToken: \(String(describing: authorizationToken)), expiration: \(String(describing: expiration)))"}
}

extension GetAuthorizationTokenOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetAuthorizationTokenOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.authorizationToken = output.authorizationToken
            self.expiration = output.expiration
        } else {
            self.authorizationToken = nil
            self.expiration = nil
        }
    }
}

public struct GetAuthorizationTokenOutputResponse: Equatable {
    /// <p>
    ///         The returned authentication token.
    ///        </p>
    public let authorizationToken: String?
    /// <p>
    ///       A timestamp that specifies the date and time the authorization token expires.
    ///     </p>
    public let expiration: Date?

    public init (
        authorizationToken: String? = nil,
        expiration: Date? = nil
    )
    {
        self.authorizationToken = authorizationToken
        self.expiration = expiration
    }
}

struct GetAuthorizationTokenOutputResponseBody: Equatable {
    public let authorizationToken: String?
    public let expiration: Date?
}

extension GetAuthorizationTokenOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case authorizationToken
        case expiration
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authorizationTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .authorizationToken)
        authorizationToken = authorizationTokenDecoded
        let expirationDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .expiration)
        expiration = expirationDecoded
    }
}

extension GetDomainPermissionsPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDomainPermissionsPolicyInput(domain: \(String(describing: domain)), domainOwner: \(String(describing: domainOwner)))"}
}

extension GetDomainPermissionsPolicyInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetDomainPermissionsPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "GetDomainPermissionsPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDomainPermissionsPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDomainPermissionsPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDomainPermissionsPolicyInput>
    public typealias MOutput = OperationOutput<GetDomainPermissionsPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDomainPermissionsPolicyOutputError>
}

public struct GetDomainPermissionsPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "GetDomainPermissionsPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDomainPermissionsPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDomainPermissionsPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let domain = input.operationInput.domain {
            let domainQueryItem = URLQueryItem(name: "domain".urlPercentEncoding(), value: String(domain).urlPercentEncoding())
            input.builder.withQueryItem(domainQueryItem)
        }
        if let domainOwner = input.operationInput.domainOwner {
            let domainOwnerQueryItem = URLQueryItem(name: "domain-owner".urlPercentEncoding(), value: String(domainOwner).urlPercentEncoding())
            input.builder.withQueryItem(domainOwnerQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDomainPermissionsPolicyInput>
    public typealias MOutput = OperationOutput<GetDomainPermissionsPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDomainPermissionsPolicyOutputError>
}

public struct GetDomainPermissionsPolicyInput: Equatable {
    /// <p>
    ///         The name of the domain to which the resource policy is attached.
    ///       </p>
    public let domain: String?
    /// <p>
    ///         The 12-digit account number of the AWS account that owns the domain. It does not include
    ///         dashes or spaces.
    ///       </p>
    public let domainOwner: String?

    public init (
        domain: String? = nil,
        domainOwner: String? = nil
    )
    {
        self.domain = domain
        self.domainOwner = domainOwner
    }
}

struct GetDomainPermissionsPolicyInputBody: Equatable {
}

extension GetDomainPermissionsPolicyInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetDomainPermissionsPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDomainPermissionsPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDomainPermissionsPolicyOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDomainPermissionsPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDomainPermissionsPolicyOutputResponse(policy: \(String(describing: policy)))"}
}

extension GetDomainPermissionsPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetDomainPermissionsPolicyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.policy = output.policy
        } else {
            self.policy = nil
        }
    }
}

public struct GetDomainPermissionsPolicyOutputResponse: Equatable {
    /// <p>
    ///         The returned resource policy.
    ///       </p>
    public let policy: ResourcePolicy?

    public init (
        policy: ResourcePolicy? = nil
    )
    {
        self.policy = policy
    }
}

struct GetDomainPermissionsPolicyOutputResponseBody: Equatable {
    public let policy: ResourcePolicy?
}

extension GetDomainPermissionsPolicyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case policy
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(ResourcePolicy.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension GetPackageVersionAssetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetPackageVersionAssetInput(asset: \(String(describing: asset)), domain: \(String(describing: domain)), domainOwner: \(String(describing: domainOwner)), format: \(String(describing: format)), namespace: \(String(describing: namespace)), package: \(String(describing: package)), packageVersion: \(String(describing: packageVersion)), packageVersionRevision: \(String(describing: packageVersionRevision)), repository: \(String(describing: repository)))"}
}

extension GetPackageVersionAssetInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetPackageVersionAssetInputHeadersMiddleware: Middleware {
    public let id: String = "GetPackageVersionAssetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetPackageVersionAssetInput>,
                  next: H) -> Swift.Result<OperationOutput<GetPackageVersionAssetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetPackageVersionAssetInput>
    public typealias MOutput = OperationOutput<GetPackageVersionAssetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetPackageVersionAssetOutputError>
}

public struct GetPackageVersionAssetInputQueryItemMiddleware: Middleware {
    public let id: String = "GetPackageVersionAssetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetPackageVersionAssetInput>,
                  next: H) -> Swift.Result<OperationOutput<GetPackageVersionAssetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let package = input.operationInput.package {
            let packageQueryItem = URLQueryItem(name: "package".urlPercentEncoding(), value: String(package).urlPercentEncoding())
            input.builder.withQueryItem(packageQueryItem)
        }
        if let domain = input.operationInput.domain {
            let domainQueryItem = URLQueryItem(name: "domain".urlPercentEncoding(), value: String(domain).urlPercentEncoding())
            input.builder.withQueryItem(domainQueryItem)
        }
        if let domainOwner = input.operationInput.domainOwner {
            let domainOwnerQueryItem = URLQueryItem(name: "domain-owner".urlPercentEncoding(), value: String(domainOwner).urlPercentEncoding())
            input.builder.withQueryItem(domainOwnerQueryItem)
        }
        if let format = input.operationInput.format {
            let formatQueryItem = URLQueryItem(name: "format".urlPercentEncoding(), value: String(format.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(formatQueryItem)
        }
        if let namespace = input.operationInput.namespace {
            let namespaceQueryItem = URLQueryItem(name: "namespace".urlPercentEncoding(), value: String(namespace).urlPercentEncoding())
            input.builder.withQueryItem(namespaceQueryItem)
        }
        if let packageVersion = input.operationInput.packageVersion {
            let packageVersionQueryItem = URLQueryItem(name: "version".urlPercentEncoding(), value: String(packageVersion).urlPercentEncoding())
            input.builder.withQueryItem(packageVersionQueryItem)
        }
        if let packageVersionRevision = input.operationInput.packageVersionRevision {
            let packageVersionRevisionQueryItem = URLQueryItem(name: "revision".urlPercentEncoding(), value: String(packageVersionRevision).urlPercentEncoding())
            input.builder.withQueryItem(packageVersionRevisionQueryItem)
        }
        if let repository = input.operationInput.repository {
            let repositoryQueryItem = URLQueryItem(name: "repository".urlPercentEncoding(), value: String(repository).urlPercentEncoding())
            input.builder.withQueryItem(repositoryQueryItem)
        }
        if let asset = input.operationInput.asset {
            let assetQueryItem = URLQueryItem(name: "asset".urlPercentEncoding(), value: String(asset).urlPercentEncoding())
            input.builder.withQueryItem(assetQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetPackageVersionAssetInput>
    public typealias MOutput = OperationOutput<GetPackageVersionAssetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetPackageVersionAssetOutputError>
}

public struct GetPackageVersionAssetInput: Equatable {
    /// <p>
    ///       The name of the requested asset.
    ///     </p>
    public let asset: String?
    /// <p>
    ///       The name of the domain that contains the repository that contains the package version with the requested asset.
    ///     </p>
    public let domain: String?
    /// <p>
    ///         The 12-digit account number of the AWS account that owns the domain. It does not include
    ///         dashes or spaces.
    ///       </p>
    public let domainOwner: String?
    /// <p>
    ///       A format that specifies the type of the package version with the requested asset file. The valid values are:
    ///     </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>npm</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>pypi</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>maven</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let format: PackageFormat?
    /// <p>
    ///       The namespace of the package. The package component that specifies its
    ///       namespace depends on its type. For example:
    ///     </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///           The namespace of a Maven package is its <code>groupId</code>.
    ///         </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///           The namespace of an npm package is its <code>scope</code>.
    ///         </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///           A Python package does not contain a corresponding component, so
    ///           Python packages do not have a namespace.
    ///         </p>
    ///             </li>
    ///          </ul>
    public let namespace: String?
    /// <p>
    ///       The name of the package that contains the requested asset.
    ///     </p>
    public let package: String?
    /// <p>
    ///       A string that contains the package version (for example, <code>3.5.2</code>).
    ///     </p>
    public let packageVersion: String?
    /// <p>
    ///         The name of the package version revision that contains the requested asset.
    ///     </p>
    public let packageVersionRevision: String?
    /// <p>
    ///       The repository that contains the package version with the requested asset.
    ///     </p>
    public let repository: String?

    public init (
        asset: String? = nil,
        domain: String? = nil,
        domainOwner: String? = nil,
        format: PackageFormat? = nil,
        namespace: String? = nil,
        package: String? = nil,
        packageVersion: String? = nil,
        packageVersionRevision: String? = nil,
        repository: String? = nil
    )
    {
        self.asset = asset
        self.domain = domain
        self.domainOwner = domainOwner
        self.format = format
        self.namespace = namespace
        self.package = package
        self.packageVersion = packageVersion
        self.packageVersionRevision = packageVersionRevision
        self.repository = repository
    }
}

struct GetPackageVersionAssetInputBody: Equatable {
}

extension GetPackageVersionAssetInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetPackageVersionAssetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetPackageVersionAssetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetPackageVersionAssetOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetPackageVersionAssetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetPackageVersionAssetOutputResponse(asset: \(String(describing: asset)), assetName: \(String(describing: assetName)), packageVersion: \(String(describing: packageVersion)), packageVersionRevision: \(String(describing: packageVersionRevision)))"}
}

extension GetPackageVersionAssetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if let assetNameHeaderValue = httpResponse.headers.value(for: "X-AssetName") {
            self.assetName = assetNameHeaderValue
        } else {
            self.assetName = nil
        }
        if let packageVersionHeaderValue = httpResponse.headers.value(for: "X-PackageVersion") {
            self.packageVersion = packageVersionHeaderValue
        } else {
            self.packageVersion = nil
        }
        if let packageVersionRevisionHeaderValue = httpResponse.headers.value(for: "X-PackageVersionRevision") {
            self.packageVersionRevision = packageVersionRevisionHeaderValue
        } else {
            self.packageVersionRevision = nil
        }
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            self.asset = unwrappedData
        } else {
            self.asset = nil
        }
    }
}

public struct GetPackageVersionAssetOutputResponse: Equatable {
    /// <p> The binary file, or asset, that is downloaded.</p>
    public let asset: Data?
    /// <p>
    ///       The name of the asset that is downloaded.
    ///     </p>
    public let assetName: String?
    /// <p>
    ///       A string that contains the package version (for example, <code>3.5.2</code>).
    ///     </p>
    public let packageVersion: String?
    /// <p>
    ///       The name of the package version revision that contains the downloaded asset.
    ///     </p>
    public let packageVersionRevision: String?

    public init (
        asset: Data? = nil,
        assetName: String? = nil,
        packageVersion: String? = nil,
        packageVersionRevision: String? = nil
    )
    {
        self.asset = asset
        self.assetName = assetName
        self.packageVersion = packageVersion
        self.packageVersionRevision = packageVersionRevision
    }
}

struct GetPackageVersionAssetOutputResponseBody: Equatable {
    public let asset: Data?
}

extension GetPackageVersionAssetOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case asset
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .asset)
        asset = assetDecoded
    }
}

extension GetPackageVersionReadmeInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetPackageVersionReadmeInput(domain: \(String(describing: domain)), domainOwner: \(String(describing: domainOwner)), format: \(String(describing: format)), namespace: \(String(describing: namespace)), package: \(String(describing: package)), packageVersion: \(String(describing: packageVersion)), repository: \(String(describing: repository)))"}
}

extension GetPackageVersionReadmeInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetPackageVersionReadmeInputHeadersMiddleware: Middleware {
    public let id: String = "GetPackageVersionReadmeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetPackageVersionReadmeInput>,
                  next: H) -> Swift.Result<OperationOutput<GetPackageVersionReadmeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetPackageVersionReadmeInput>
    public typealias MOutput = OperationOutput<GetPackageVersionReadmeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetPackageVersionReadmeOutputError>
}

public struct GetPackageVersionReadmeInputQueryItemMiddleware: Middleware {
    public let id: String = "GetPackageVersionReadmeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetPackageVersionReadmeInput>,
                  next: H) -> Swift.Result<OperationOutput<GetPackageVersionReadmeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let package = input.operationInput.package {
            let packageQueryItem = URLQueryItem(name: "package".urlPercentEncoding(), value: String(package).urlPercentEncoding())
            input.builder.withQueryItem(packageQueryItem)
        }
        if let domain = input.operationInput.domain {
            let domainQueryItem = URLQueryItem(name: "domain".urlPercentEncoding(), value: String(domain).urlPercentEncoding())
            input.builder.withQueryItem(domainQueryItem)
        }
        if let domainOwner = input.operationInput.domainOwner {
            let domainOwnerQueryItem = URLQueryItem(name: "domain-owner".urlPercentEncoding(), value: String(domainOwner).urlPercentEncoding())
            input.builder.withQueryItem(domainOwnerQueryItem)
        }
        if let format = input.operationInput.format {
            let formatQueryItem = URLQueryItem(name: "format".urlPercentEncoding(), value: String(format.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(formatQueryItem)
        }
        if let namespace = input.operationInput.namespace {
            let namespaceQueryItem = URLQueryItem(name: "namespace".urlPercentEncoding(), value: String(namespace).urlPercentEncoding())
            input.builder.withQueryItem(namespaceQueryItem)
        }
        if let packageVersion = input.operationInput.packageVersion {
            let packageVersionQueryItem = URLQueryItem(name: "version".urlPercentEncoding(), value: String(packageVersion).urlPercentEncoding())
            input.builder.withQueryItem(packageVersionQueryItem)
        }
        if let repository = input.operationInput.repository {
            let repositoryQueryItem = URLQueryItem(name: "repository".urlPercentEncoding(), value: String(repository).urlPercentEncoding())
            input.builder.withQueryItem(repositoryQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetPackageVersionReadmeInput>
    public typealias MOutput = OperationOutput<GetPackageVersionReadmeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetPackageVersionReadmeOutputError>
}

public struct GetPackageVersionReadmeInput: Equatable {
    /// <p>
    ///       The name of the domain that contains the repository that contains the package version with the requested readme file.
    ///     </p>
    public let domain: String?
    /// <p>
    ///         The 12-digit account number of the AWS account that owns the domain. It does not include
    ///         dashes or spaces.
    ///       </p>
    public let domainOwner: String?
    /// <p>
    ///       A format that specifies the type of the package version with the requested readme file. The valid values are:
    ///     </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>npm</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>pypi</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>maven</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let format: PackageFormat?
    /// <p>
    ///       The namespace of the package. The package component that specifies its
    ///       namespace depends on its type. For example:
    ///     </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///           The namespace of a Maven package is its <code>groupId</code>.
    ///         </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///           The namespace of an npm package is its <code>scope</code>.
    ///         </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///           A Python package does not contain a corresponding component, so
    ///           Python packages do not have a namespace.
    ///         </p>
    ///             </li>
    ///          </ul>
    public let namespace: String?
    /// <p>
    ///       The name of the package version that contains the requested readme file.
    ///     </p>
    public let package: String?
    /// <p>
    ///       A string that contains the package version (for example, <code>3.5.2</code>).
    ///     </p>
    public let packageVersion: String?
    /// <p>
    ///       The repository that contains the package with the requested readme file.
    ///     </p>
    public let repository: String?

    public init (
        domain: String? = nil,
        domainOwner: String? = nil,
        format: PackageFormat? = nil,
        namespace: String? = nil,
        package: String? = nil,
        packageVersion: String? = nil,
        repository: String? = nil
    )
    {
        self.domain = domain
        self.domainOwner = domainOwner
        self.format = format
        self.namespace = namespace
        self.package = package
        self.packageVersion = packageVersion
        self.repository = repository
    }
}

struct GetPackageVersionReadmeInputBody: Equatable {
}

extension GetPackageVersionReadmeInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetPackageVersionReadmeOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetPackageVersionReadmeOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetPackageVersionReadmeOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetPackageVersionReadmeOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetPackageVersionReadmeOutputResponse(format: \(String(describing: format)), namespace: \(String(describing: namespace)), package: \(String(describing: package)), readme: \(String(describing: readme)), version: \(String(describing: version)), versionRevision: \(String(describing: versionRevision)))"}
}

extension GetPackageVersionReadmeOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetPackageVersionReadmeOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.format = output.format
            self.namespace = output.namespace
            self.package = output.package
            self.readme = output.readme
            self.version = output.version
            self.versionRevision = output.versionRevision
        } else {
            self.format = nil
            self.namespace = nil
            self.package = nil
            self.readme = nil
            self.version = nil
            self.versionRevision = nil
        }
    }
}

public struct GetPackageVersionReadmeOutputResponse: Equatable {
    /// <p>
    ///       The format of the package with the requested readme file. Valid format types are:
    ///     </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>npm</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>pypi</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>maven</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let format: PackageFormat?
    /// <p>
    ///       The namespace of the package. The package component that specifies its
    ///       namespace depends on its type. For example:
    ///     </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///           The namespace of a Maven package is its <code>groupId</code>.
    ///         </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///           The namespace of an npm package is its <code>scope</code>.
    ///         </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///           A Python package does not contain a corresponding component, so
    ///           Python packages do not have a namespace.
    ///         </p>
    ///             </li>
    ///          </ul>
    public let namespace: String?
    /// <p>
    ///       The name of the package that contains the returned readme file.
    ///     </p>
    public let package: String?
    /// <p>
    ///       The text of the returned readme file.
    ///     </p>
    public let readme: String?
    /// <p>
    ///       The version of the package with the requested readme file.
    ///     </p>
    public let version: String?
    /// <p>
    ///       The current revision associated with the package version.
    ///     </p>
    public let versionRevision: String?

    public init (
        format: PackageFormat? = nil,
        namespace: String? = nil,
        package: String? = nil,
        readme: String? = nil,
        version: String? = nil,
        versionRevision: String? = nil
    )
    {
        self.format = format
        self.namespace = namespace
        self.package = package
        self.readme = readme
        self.version = version
        self.versionRevision = versionRevision
    }
}

struct GetPackageVersionReadmeOutputResponseBody: Equatable {
    public let format: PackageFormat?
    public let namespace: String?
    public let package: String?
    public let version: String?
    public let versionRevision: String?
    public let readme: String?
}

extension GetPackageVersionReadmeOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case format
        case namespace
        case package
        case readme
        case version
        case versionRevision
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let formatDecoded = try containerValues.decodeIfPresent(PackageFormat.self, forKey: .format)
        format = formatDecoded
        let namespaceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .namespace)
        namespace = namespaceDecoded
        let packageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .package)
        package = packageDecoded
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
        let versionRevisionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .versionRevision)
        versionRevision = versionRevisionDecoded
        let readmeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .readme)
        readme = readmeDecoded
    }
}

extension GetRepositoryEndpointInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetRepositoryEndpointInput(domain: \(String(describing: domain)), domainOwner: \(String(describing: domainOwner)), format: \(String(describing: format)), repository: \(String(describing: repository)))"}
}

extension GetRepositoryEndpointInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetRepositoryEndpointInputHeadersMiddleware: Middleware {
    public let id: String = "GetRepositoryEndpointInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRepositoryEndpointInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRepositoryEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRepositoryEndpointInput>
    public typealias MOutput = OperationOutput<GetRepositoryEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRepositoryEndpointOutputError>
}

public struct GetRepositoryEndpointInputQueryItemMiddleware: Middleware {
    public let id: String = "GetRepositoryEndpointInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRepositoryEndpointInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRepositoryEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let domain = input.operationInput.domain {
            let domainQueryItem = URLQueryItem(name: "domain".urlPercentEncoding(), value: String(domain).urlPercentEncoding())
            input.builder.withQueryItem(domainQueryItem)
        }
        if let domainOwner = input.operationInput.domainOwner {
            let domainOwnerQueryItem = URLQueryItem(name: "domain-owner".urlPercentEncoding(), value: String(domainOwner).urlPercentEncoding())
            input.builder.withQueryItem(domainOwnerQueryItem)
        }
        if let format = input.operationInput.format {
            let formatQueryItem = URLQueryItem(name: "format".urlPercentEncoding(), value: String(format.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(formatQueryItem)
        }
        if let repository = input.operationInput.repository {
            let repositoryQueryItem = URLQueryItem(name: "repository".urlPercentEncoding(), value: String(repository).urlPercentEncoding())
            input.builder.withQueryItem(repositoryQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRepositoryEndpointInput>
    public typealias MOutput = OperationOutput<GetRepositoryEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRepositoryEndpointOutputError>
}

public struct GetRepositoryEndpointInput: Equatable {
    /// <p>
    ///          The name of the domain that contains the repository.
    ///      </p>
    public let domain: String?
    /// <p>
    ///         The 12-digit account number of the AWS account that owns the domain that contains the repository. It does not include
    ///         dashes or spaces.
    ///       </p>
    public let domainOwner: String?
    /// <p>
    ///       Returns which endpoint of a repository to return. A repository has one endpoint for each
    ///       package format:
    ///     </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>npm</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>pypi</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>maven</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let format: PackageFormat?
    /// <p>
    ///          The name of the repository.
    ///      </p>
    public let repository: String?

    public init (
        domain: String? = nil,
        domainOwner: String? = nil,
        format: PackageFormat? = nil,
        repository: String? = nil
    )
    {
        self.domain = domain
        self.domainOwner = domainOwner
        self.format = format
        self.repository = repository
    }
}

struct GetRepositoryEndpointInputBody: Equatable {
}

extension GetRepositoryEndpointInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetRepositoryEndpointOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetRepositoryEndpointOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetRepositoryEndpointOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRepositoryEndpointOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetRepositoryEndpointOutputResponse(repositoryEndpoint: \(String(describing: repositoryEndpoint)))"}
}

extension GetRepositoryEndpointOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetRepositoryEndpointOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.repositoryEndpoint = output.repositoryEndpoint
        } else {
            self.repositoryEndpoint = nil
        }
    }
}

public struct GetRepositoryEndpointOutputResponse: Equatable {
    /// <p>
    ///          A string that specifies the URL of the returned endpoint.
    ///      </p>
    public let repositoryEndpoint: String?

    public init (
        repositoryEndpoint: String? = nil
    )
    {
        self.repositoryEndpoint = repositoryEndpoint
    }
}

struct GetRepositoryEndpointOutputResponseBody: Equatable {
    public let repositoryEndpoint: String?
}

extension GetRepositoryEndpointOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case repositoryEndpoint
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryEndpointDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryEndpoint)
        repositoryEndpoint = repositoryEndpointDecoded
    }
}

extension GetRepositoryPermissionsPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetRepositoryPermissionsPolicyInput(domain: \(String(describing: domain)), domainOwner: \(String(describing: domainOwner)), repository: \(String(describing: repository)))"}
}

extension GetRepositoryPermissionsPolicyInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetRepositoryPermissionsPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "GetRepositoryPermissionsPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRepositoryPermissionsPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRepositoryPermissionsPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRepositoryPermissionsPolicyInput>
    public typealias MOutput = OperationOutput<GetRepositoryPermissionsPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRepositoryPermissionsPolicyOutputError>
}

public struct GetRepositoryPermissionsPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "GetRepositoryPermissionsPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRepositoryPermissionsPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRepositoryPermissionsPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let domain = input.operationInput.domain {
            let domainQueryItem = URLQueryItem(name: "domain".urlPercentEncoding(), value: String(domain).urlPercentEncoding())
            input.builder.withQueryItem(domainQueryItem)
        }
        if let domainOwner = input.operationInput.domainOwner {
            let domainOwnerQueryItem = URLQueryItem(name: "domain-owner".urlPercentEncoding(), value: String(domainOwner).urlPercentEncoding())
            input.builder.withQueryItem(domainOwnerQueryItem)
        }
        if let repository = input.operationInput.repository {
            let repositoryQueryItem = URLQueryItem(name: "repository".urlPercentEncoding(), value: String(repository).urlPercentEncoding())
            input.builder.withQueryItem(repositoryQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRepositoryPermissionsPolicyInput>
    public typealias MOutput = OperationOutput<GetRepositoryPermissionsPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRepositoryPermissionsPolicyOutputError>
}

public struct GetRepositoryPermissionsPolicyInput: Equatable {
    /// <p>
    ///         The name of the domain containing the repository whose associated resource policy is to be retrieved.
    ///       </p>
    public let domain: String?
    /// <p>
    ///         The 12-digit account number of the AWS account that owns the domain. It does not include
    ///         dashes or spaces.
    ///       </p>
    public let domainOwner: String?
    /// <p>
    ///         The name of the repository whose associated resource policy is to be retrieved.
    ///       </p>
    public let repository: String?

    public init (
        domain: String? = nil,
        domainOwner: String? = nil,
        repository: String? = nil
    )
    {
        self.domain = domain
        self.domainOwner = domainOwner
        self.repository = repository
    }
}

struct GetRepositoryPermissionsPolicyInputBody: Equatable {
}

extension GetRepositoryPermissionsPolicyInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetRepositoryPermissionsPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetRepositoryPermissionsPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetRepositoryPermissionsPolicyOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRepositoryPermissionsPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetRepositoryPermissionsPolicyOutputResponse(policy: \(String(describing: policy)))"}
}

extension GetRepositoryPermissionsPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetRepositoryPermissionsPolicyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.policy = output.policy
        } else {
            self.policy = nil
        }
    }
}

public struct GetRepositoryPermissionsPolicyOutputResponse: Equatable {
    /// <p>
    ///         The returned resource policy.
    ///       </p>
    public let policy: ResourcePolicy?

    public init (
        policy: ResourcePolicy? = nil
    )
    {
        self.policy = policy
    }
}

struct GetRepositoryPermissionsPolicyOutputResponseBody: Equatable {
    public let policy: ResourcePolicy?
}

extension GetRepositoryPermissionsPolicyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case policy
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(ResourcePolicy.self, forKey: .policy)
        policy = policyDecoded
    }
}

public enum HashAlgorithm {
    case md5
    case sha1
    case sha256
    case sha512
    case sdkUnknown(String)
}

extension HashAlgorithm : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [HashAlgorithm] {
        return [
            .md5,
            .sha1,
            .sha256,
            .sha512,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .md5: return "MD5"
        case .sha1: return "SHA-1"
        case .sha256: return "SHA-256"
        case .sha512: return "SHA-512"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = HashAlgorithm(rawValue: rawValue) ?? HashAlgorithm.sdkUnknown(rawValue)
    }
}

extension InternalServerException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalServerException(message: \(String(describing: message)))"}
}

extension InternalServerException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p> The operation did not succeed because of an error that occurred inside AWS CodeArtifact. </p>
public struct InternalServerException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Equatable {
    public let message: String?
}

extension InternalServerExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LicenseInfo: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name
        case url
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let url = url {
            try encodeContainer.encode(url, forKey: .url)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let urlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .url)
        url = urlDecoded
    }
}

extension LicenseInfo: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LicenseInfo(name: \(String(describing: name)), url: \(String(describing: url)))"}
}

/// <p>
///         Details of the license data.
///       </p>
public struct LicenseInfo: Equatable {
    /// <p>
    ///         Name of the license.
    ///       </p>
    public let name: String?
    /// <p>
    ///         The URL for license data.
    ///       </p>
    public let url: String?

    public init (
        name: String? = nil,
        url: String? = nil
    )
    {
        self.name = name
        self.url = url
    }
}

public struct ListDomainsInputBodyMiddleware: Middleware {
    public let id: String = "ListDomainsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDomainsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDomainsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDomainsInput>
    public typealias MOutput = OperationOutput<ListDomainsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDomainsOutputError>
}

extension ListDomainsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDomainsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListDomainsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListDomainsInputHeadersMiddleware: Middleware {
    public let id: String = "ListDomainsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDomainsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDomainsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDomainsInput>
    public typealias MOutput = OperationOutput<ListDomainsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDomainsOutputError>
}

public struct ListDomainsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListDomainsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDomainsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDomainsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDomainsInput>
    public typealias MOutput = OperationOutput<ListDomainsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDomainsOutputError>
}

public struct ListDomainsInput: Equatable {
    /// <p>
    ///         The maximum number of results to return per page.
    ///        </p>
    public let maxResults: Int?
    /// <p>
    ///         The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    ///        </p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDomainsInputBody: Equatable {
    public let maxResults: Int?
    public let nextToken: String?
}

extension ListDomainsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListDomainsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDomainsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDomainsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDomainsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDomainsOutputResponse(domains: \(String(describing: domains)), nextToken: \(String(describing: nextToken)))"}
}

extension ListDomainsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListDomainsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.domains = output.domains
            self.nextToken = output.nextToken
        } else {
            self.domains = nil
            self.nextToken = nil
        }
    }
}

public struct ListDomainsOutputResponse: Equatable {
    /// <p>
    ///       The returned list of <a href="https://docs.aws.amazon.com/codeartifact/latest/APIReference/API_DomainSummary.html">DomainSummary</a> objects.
    ///      </p>
    public let domains: [DomainSummary]?
    /// <p>
    ///         The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    ///        </p>
    public let nextToken: String?

    public init (
        domains: [DomainSummary]? = nil,
        nextToken: String? = nil
    )
    {
        self.domains = domains
        self.nextToken = nextToken
    }
}

struct ListDomainsOutputResponseBody: Equatable {
    public let domains: [DomainSummary]?
    public let nextToken: String?
}

extension ListDomainsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case domains
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainsContainer = try containerValues.decodeIfPresent([DomainSummary?].self, forKey: .domains)
        var domainsDecoded0:[DomainSummary]? = nil
        if let domainsContainer = domainsContainer {
            domainsDecoded0 = [DomainSummary]()
            for structure0 in domainsContainer {
                if let structure0 = structure0 {
                    domainsDecoded0?.append(structure0)
                }
            }
        }
        domains = domainsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListPackageVersionAssetsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListPackageVersionAssetsInput(domain: \(String(describing: domain)), domainOwner: \(String(describing: domainOwner)), format: \(String(describing: format)), maxResults: \(String(describing: maxResults)), namespace: \(String(describing: namespace)), nextToken: \(String(describing: nextToken)), package: \(String(describing: package)), packageVersion: \(String(describing: packageVersion)), repository: \(String(describing: repository)))"}
}

extension ListPackageVersionAssetsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListPackageVersionAssetsInputHeadersMiddleware: Middleware {
    public let id: String = "ListPackageVersionAssetsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPackageVersionAssetsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPackageVersionAssetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPackageVersionAssetsInput>
    public typealias MOutput = OperationOutput<ListPackageVersionAssetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPackageVersionAssetsOutputError>
}

public struct ListPackageVersionAssetsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListPackageVersionAssetsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPackageVersionAssetsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPackageVersionAssetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let package = input.operationInput.package {
            let packageQueryItem = URLQueryItem(name: "package".urlPercentEncoding(), value: String(package).urlPercentEncoding())
            input.builder.withQueryItem(packageQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "max-results".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "next-token".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let domain = input.operationInput.domain {
            let domainQueryItem = URLQueryItem(name: "domain".urlPercentEncoding(), value: String(domain).urlPercentEncoding())
            input.builder.withQueryItem(domainQueryItem)
        }
        if let domainOwner = input.operationInput.domainOwner {
            let domainOwnerQueryItem = URLQueryItem(name: "domain-owner".urlPercentEncoding(), value: String(domainOwner).urlPercentEncoding())
            input.builder.withQueryItem(domainOwnerQueryItem)
        }
        if let format = input.operationInput.format {
            let formatQueryItem = URLQueryItem(name: "format".urlPercentEncoding(), value: String(format.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(formatQueryItem)
        }
        if let namespace = input.operationInput.namespace {
            let namespaceQueryItem = URLQueryItem(name: "namespace".urlPercentEncoding(), value: String(namespace).urlPercentEncoding())
            input.builder.withQueryItem(namespaceQueryItem)
        }
        if let packageVersion = input.operationInput.packageVersion {
            let packageVersionQueryItem = URLQueryItem(name: "version".urlPercentEncoding(), value: String(packageVersion).urlPercentEncoding())
            input.builder.withQueryItem(packageVersionQueryItem)
        }
        if let repository = input.operationInput.repository {
            let repositoryQueryItem = URLQueryItem(name: "repository".urlPercentEncoding(), value: String(repository).urlPercentEncoding())
            input.builder.withQueryItem(repositoryQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPackageVersionAssetsInput>
    public typealias MOutput = OperationOutput<ListPackageVersionAssetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPackageVersionAssetsOutputError>
}

public struct ListPackageVersionAssetsInput: Equatable {
    /// <p>
    ///          The name of the domain that contains the repository associated with the package version assets.
    ///        </p>
    public let domain: String?
    /// <p>
    ///         The 12-digit account number of the AWS account that owns the domain. It does not include
    ///         dashes or spaces.
    ///       </p>
    public let domainOwner: String?
    /// <p>
    ///       The format of the package that contains the returned package version assets. The valid package types are:
    ///     </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>npm</code>: A Node Package Manager (npm) package.
    ///         </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>pypi</code>: A Python Package Index (PyPI) package.
    ///         </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>maven</code>: A Maven package that contains compiled code in a distributable format, such as a JAR file.
    ///         </p>
    ///             </li>
    ///          </ul>
    public let format: PackageFormat?
    /// <p>
    ///         The maximum number of results to return per page.
    ///        </p>
    public let maxResults: Int?
    /// <p>
    ///       The namespace of the package. The package component that specifies its
    ///       namespace depends on its type. For example:
    ///     </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///           The namespace of a Maven package is its <code>groupId</code>.
    ///         </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///           The namespace of an npm package is its <code>scope</code>.
    ///         </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///           A Python package does not contain a corresponding component, so
    ///           Python packages do not have a namespace.
    ///         </p>
    ///             </li>
    ///          </ul>
    public let namespace: String?
    /// <p>
    ///         The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    ///        </p>
    public let nextToken: String?
    /// <p>
    ///          The name of the package that contains the returned package version assets.
    ///        </p>
    public let package: String?
    /// <p>
    ///       A string that contains the package version (for example, <code>3.5.2</code>).
    ///     </p>
    public let packageVersion: String?
    /// <p>
    ///       The name of the repository that contains the package that contains the returned package version assets.
    ///     </p>
    public let repository: String?

    public init (
        domain: String? = nil,
        domainOwner: String? = nil,
        format: PackageFormat? = nil,
        maxResults: Int? = nil,
        namespace: String? = nil,
        nextToken: String? = nil,
        package: String? = nil,
        packageVersion: String? = nil,
        repository: String? = nil
    )
    {
        self.domain = domain
        self.domainOwner = domainOwner
        self.format = format
        self.maxResults = maxResults
        self.namespace = namespace
        self.nextToken = nextToken
        self.package = package
        self.packageVersion = packageVersion
        self.repository = repository
    }
}

struct ListPackageVersionAssetsInputBody: Equatable {
}

extension ListPackageVersionAssetsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListPackageVersionAssetsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPackageVersionAssetsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPackageVersionAssetsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPackageVersionAssetsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListPackageVersionAssetsOutputResponse(assets: \(String(describing: assets)), format: \(String(describing: format)), namespace: \(String(describing: namespace)), nextToken: \(String(describing: nextToken)), package: \(String(describing: package)), version: \(String(describing: version)), versionRevision: \(String(describing: versionRevision)))"}
}

extension ListPackageVersionAssetsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListPackageVersionAssetsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.assets = output.assets
            self.format = output.format
            self.namespace = output.namespace
            self.nextToken = output.nextToken
            self.package = output.package
            self.version = output.version
            self.versionRevision = output.versionRevision
        } else {
            self.assets = nil
            self.format = nil
            self.namespace = nil
            self.nextToken = nil
            self.package = nil
            self.version = nil
            self.versionRevision = nil
        }
    }
}

public struct ListPackageVersionAssetsOutputResponse: Equatable {
    /// <p>
    ///       The returned list of <a href="https://docs.aws.amazon.com/codeartifact/latest/APIReference/API_AssetSummary.html">AssetSummary</a> objects.
    ///     </p>
    public let assets: [AssetSummary]?
    /// <p>
    ///       The format of the package that contains the returned package version assets.
    ///     </p>
    public let format: PackageFormat?
    /// <p>
    ///       The namespace of the package. The package component that specifies its
    ///       namespace depends on its type. For example:
    ///     </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///           The namespace of a Maven package is its <code>groupId</code>.
    ///         </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///           The namespace of an npm package is its <code>scope</code>.
    ///         </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///           A Python package does not contain a corresponding component, so
    ///           Python packages do not have a namespace.
    ///         </p>
    ///             </li>
    ///          </ul>
    public let namespace: String?
    /// <p>
    ///         If there are additional results, this is the token for the next set of results.
    ///        </p>
    public let nextToken: String?
    /// <p>
    ///       The name of the package that contains the returned package version assets.
    ///     </p>
    public let package: String?
    /// <p>
    ///       The version of the package associated with the returned assets.
    ///     </p>
    public let version: String?
    /// <p>
    ///       The current revision associated with the package version.
    ///     </p>
    public let versionRevision: String?

    public init (
        assets: [AssetSummary]? = nil,
        format: PackageFormat? = nil,
        namespace: String? = nil,
        nextToken: String? = nil,
        package: String? = nil,
        version: String? = nil,
        versionRevision: String? = nil
    )
    {
        self.assets = assets
        self.format = format
        self.namespace = namespace
        self.nextToken = nextToken
        self.package = package
        self.version = version
        self.versionRevision = versionRevision
    }
}

struct ListPackageVersionAssetsOutputResponseBody: Equatable {
    public let format: PackageFormat?
    public let namespace: String?
    public let package: String?
    public let version: String?
    public let versionRevision: String?
    public let nextToken: String?
    public let assets: [AssetSummary]?
}

extension ListPackageVersionAssetsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case assets
        case format
        case namespace
        case nextToken
        case package
        case version
        case versionRevision
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let formatDecoded = try containerValues.decodeIfPresent(PackageFormat.self, forKey: .format)
        format = formatDecoded
        let namespaceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .namespace)
        namespace = namespaceDecoded
        let packageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .package)
        package = packageDecoded
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
        let versionRevisionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .versionRevision)
        versionRevision = versionRevisionDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let assetsContainer = try containerValues.decodeIfPresent([AssetSummary?].self, forKey: .assets)
        var assetsDecoded0:[AssetSummary]? = nil
        if let assetsContainer = assetsContainer {
            assetsDecoded0 = [AssetSummary]()
            for structure0 in assetsContainer {
                if let structure0 = structure0 {
                    assetsDecoded0?.append(structure0)
                }
            }
        }
        assets = assetsDecoded0
    }
}

extension ListPackageVersionDependenciesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListPackageVersionDependenciesInput(domain: \(String(describing: domain)), domainOwner: \(String(describing: domainOwner)), format: \(String(describing: format)), namespace: \(String(describing: namespace)), nextToken: \(String(describing: nextToken)), package: \(String(describing: package)), packageVersion: \(String(describing: packageVersion)), repository: \(String(describing: repository)))"}
}

extension ListPackageVersionDependenciesInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListPackageVersionDependenciesInputHeadersMiddleware: Middleware {
    public let id: String = "ListPackageVersionDependenciesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPackageVersionDependenciesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPackageVersionDependenciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPackageVersionDependenciesInput>
    public typealias MOutput = OperationOutput<ListPackageVersionDependenciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPackageVersionDependenciesOutputError>
}

public struct ListPackageVersionDependenciesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListPackageVersionDependenciesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPackageVersionDependenciesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPackageVersionDependenciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let package = input.operationInput.package {
            let packageQueryItem = URLQueryItem(name: "package".urlPercentEncoding(), value: String(package).urlPercentEncoding())
            input.builder.withQueryItem(packageQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "next-token".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let domain = input.operationInput.domain {
            let domainQueryItem = URLQueryItem(name: "domain".urlPercentEncoding(), value: String(domain).urlPercentEncoding())
            input.builder.withQueryItem(domainQueryItem)
        }
        if let domainOwner = input.operationInput.domainOwner {
            let domainOwnerQueryItem = URLQueryItem(name: "domain-owner".urlPercentEncoding(), value: String(domainOwner).urlPercentEncoding())
            input.builder.withQueryItem(domainOwnerQueryItem)
        }
        if let format = input.operationInput.format {
            let formatQueryItem = URLQueryItem(name: "format".urlPercentEncoding(), value: String(format.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(formatQueryItem)
        }
        if let namespace = input.operationInput.namespace {
            let namespaceQueryItem = URLQueryItem(name: "namespace".urlPercentEncoding(), value: String(namespace).urlPercentEncoding())
            input.builder.withQueryItem(namespaceQueryItem)
        }
        if let packageVersion = input.operationInput.packageVersion {
            let packageVersionQueryItem = URLQueryItem(name: "version".urlPercentEncoding(), value: String(packageVersion).urlPercentEncoding())
            input.builder.withQueryItem(packageVersionQueryItem)
        }
        if let repository = input.operationInput.repository {
            let repositoryQueryItem = URLQueryItem(name: "repository".urlPercentEncoding(), value: String(repository).urlPercentEncoding())
            input.builder.withQueryItem(repositoryQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPackageVersionDependenciesInput>
    public typealias MOutput = OperationOutput<ListPackageVersionDependenciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPackageVersionDependenciesOutputError>
}

public struct ListPackageVersionDependenciesInput: Equatable {
    /// <p>
    ///       The name of the domain that contains the repository that contains the requested package version dependencies.
    ///     </p>
    public let domain: String?
    /// <p>
    ///         The 12-digit account number of the AWS account that owns the domain. It does not include
    ///         dashes or spaces.
    ///       </p>
    public let domainOwner: String?
    /// <p>
    ///       The format of the package with the requested dependencies. The valid package types are:
    ///     </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>npm</code>: A Node Package Manager (npm) package.
    ///         </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>pypi</code>: A Python Package Index (PyPI) package.
    ///         </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>maven</code>: A Maven package that contains compiled code in a distributable format, such as a JAR file.
    ///         </p>
    ///             </li>
    ///          </ul>
    public let format: PackageFormat?
    /// <p>
    ///       The namespace of the package. The package component that specifies its
    ///       namespace depends on its type. For example:
    ///     </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///           The namespace of a Maven package is its <code>groupId</code>.
    ///         </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///           The namespace of an npm package is its <code>scope</code>.
    ///         </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///           A Python package does not contain a corresponding component, so
    ///           Python packages do not have a namespace.
    ///         </p>
    ///             </li>
    ///          </ul>
    public let namespace: String?
    /// <p>
    ///         The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    ///        </p>
    public let nextToken: String?
    /// <p>
    ///       The name of the package versions' package.
    ///     </p>
    public let package: String?
    /// <p>
    ///       A string that contains the package version (for example, <code>3.5.2</code>).
    ///     </p>
    public let packageVersion: String?
    /// <p>
    ///       The name of the repository that contains the requested package version.
    ///     </p>
    public let repository: String?

    public init (
        domain: String? = nil,
        domainOwner: String? = nil,
        format: PackageFormat? = nil,
        namespace: String? = nil,
        nextToken: String? = nil,
        package: String? = nil,
        packageVersion: String? = nil,
        repository: String? = nil
    )
    {
        self.domain = domain
        self.domainOwner = domainOwner
        self.format = format
        self.namespace = namespace
        self.nextToken = nextToken
        self.package = package
        self.packageVersion = packageVersion
        self.repository = repository
    }
}

struct ListPackageVersionDependenciesInputBody: Equatable {
}

extension ListPackageVersionDependenciesInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListPackageVersionDependenciesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPackageVersionDependenciesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPackageVersionDependenciesOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPackageVersionDependenciesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListPackageVersionDependenciesOutputResponse(dependencies: \(String(describing: dependencies)), format: \(String(describing: format)), namespace: \(String(describing: namespace)), nextToken: \(String(describing: nextToken)), package: \(String(describing: package)), version: \(String(describing: version)), versionRevision: \(String(describing: versionRevision)))"}
}

extension ListPackageVersionDependenciesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListPackageVersionDependenciesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dependencies = output.dependencies
            self.format = output.format
            self.namespace = output.namespace
            self.nextToken = output.nextToken
            self.package = output.package
            self.version = output.version
            self.versionRevision = output.versionRevision
        } else {
            self.dependencies = nil
            self.format = nil
            self.namespace = nil
            self.nextToken = nil
            self.package = nil
            self.version = nil
            self.versionRevision = nil
        }
    }
}

public struct ListPackageVersionDependenciesOutputResponse: Equatable {
    /// <p>
    ///       The returned list of <a href="https://docs.aws.amazon.com/codeartifact/latest/APIReference/API_PackageDependency.html">PackageDependency</a> objects.
    ///     </p>
    public let dependencies: [PackageDependency]?
    /// <p>
    ///       A format that specifies the type of the package that contains the returned dependencies. The valid values are:
    ///     </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>npm</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>pypi</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>maven</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let format: PackageFormat?
    /// <p>
    ///       The namespace of the package. The package component that specifies its
    ///       namespace depends on its type. For example:
    ///     </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///           The namespace of a Maven package is its <code>groupId</code>.
    ///         </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///           The namespace of an npm package is its <code>scope</code>.
    ///         </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///           A Python package does not contain a corresponding component, so
    ///           Python packages do not have a namespace.
    ///         </p>
    ///             </li>
    ///          </ul>
    public let namespace: String?
    /// <p>
    ///         The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    ///        </p>
    public let nextToken: String?
    /// <p>
    ///       The name of the package that contains the returned package versions dependencies.
    ///     </p>
    public let package: String?
    /// <p>
    ///       The version of the package that is specified in the request.
    ///     </p>
    public let version: String?
    /// <p>
    ///       The current revision associated with the package version.
    ///     </p>
    public let versionRevision: String?

    public init (
        dependencies: [PackageDependency]? = nil,
        format: PackageFormat? = nil,
        namespace: String? = nil,
        nextToken: String? = nil,
        package: String? = nil,
        version: String? = nil,
        versionRevision: String? = nil
    )
    {
        self.dependencies = dependencies
        self.format = format
        self.namespace = namespace
        self.nextToken = nextToken
        self.package = package
        self.version = version
        self.versionRevision = versionRevision
    }
}

struct ListPackageVersionDependenciesOutputResponseBody: Equatable {
    public let format: PackageFormat?
    public let namespace: String?
    public let package: String?
    public let version: String?
    public let versionRevision: String?
    public let nextToken: String?
    public let dependencies: [PackageDependency]?
}

extension ListPackageVersionDependenciesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dependencies
        case format
        case namespace
        case nextToken
        case package
        case version
        case versionRevision
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let formatDecoded = try containerValues.decodeIfPresent(PackageFormat.self, forKey: .format)
        format = formatDecoded
        let namespaceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .namespace)
        namespace = namespaceDecoded
        let packageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .package)
        package = packageDecoded
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
        let versionRevisionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .versionRevision)
        versionRevision = versionRevisionDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let dependenciesContainer = try containerValues.decodeIfPresent([PackageDependency?].self, forKey: .dependencies)
        var dependenciesDecoded0:[PackageDependency]? = nil
        if let dependenciesContainer = dependenciesContainer {
            dependenciesDecoded0 = [PackageDependency]()
            for structure0 in dependenciesContainer {
                if let structure0 = structure0 {
                    dependenciesDecoded0?.append(structure0)
                }
            }
        }
        dependencies = dependenciesDecoded0
    }
}

extension ListPackageVersionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListPackageVersionsInput(domain: \(String(describing: domain)), domainOwner: \(String(describing: domainOwner)), format: \(String(describing: format)), maxResults: \(String(describing: maxResults)), namespace: \(String(describing: namespace)), nextToken: \(String(describing: nextToken)), package: \(String(describing: package)), repository: \(String(describing: repository)), sortBy: \(String(describing: sortBy)), status: \(String(describing: status)))"}
}

extension ListPackageVersionsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListPackageVersionsInputHeadersMiddleware: Middleware {
    public let id: String = "ListPackageVersionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPackageVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPackageVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPackageVersionsInput>
    public typealias MOutput = OperationOutput<ListPackageVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPackageVersionsOutputError>
}

public struct ListPackageVersionsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListPackageVersionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPackageVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPackageVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let package = input.operationInput.package {
            let packageQueryItem = URLQueryItem(name: "package".urlPercentEncoding(), value: String(package).urlPercentEncoding())
            input.builder.withQueryItem(packageQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "max-results".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "next-token".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let domain = input.operationInput.domain {
            let domainQueryItem = URLQueryItem(name: "domain".urlPercentEncoding(), value: String(domain).urlPercentEncoding())
            input.builder.withQueryItem(domainQueryItem)
        }
        if let domainOwner = input.operationInput.domainOwner {
            let domainOwnerQueryItem = URLQueryItem(name: "domain-owner".urlPercentEncoding(), value: String(domainOwner).urlPercentEncoding())
            input.builder.withQueryItem(domainOwnerQueryItem)
        }
        if let format = input.operationInput.format {
            let formatQueryItem = URLQueryItem(name: "format".urlPercentEncoding(), value: String(format.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(formatQueryItem)
        }
        if let namespace = input.operationInput.namespace {
            let namespaceQueryItem = URLQueryItem(name: "namespace".urlPercentEncoding(), value: String(namespace).urlPercentEncoding())
            input.builder.withQueryItem(namespaceQueryItem)
        }
        if let sortBy = input.operationInput.sortBy {
            let sortByQueryItem = URLQueryItem(name: "sortBy".urlPercentEncoding(), value: String(sortBy.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(sortByQueryItem)
        }
        if let repository = input.operationInput.repository {
            let repositoryQueryItem = URLQueryItem(name: "repository".urlPercentEncoding(), value: String(repository).urlPercentEncoding())
            input.builder.withQueryItem(repositoryQueryItem)
        }
        if let status = input.operationInput.status {
            let statusQueryItem = URLQueryItem(name: "status".urlPercentEncoding(), value: String(status.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(statusQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPackageVersionsInput>
    public typealias MOutput = OperationOutput<ListPackageVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPackageVersionsOutputError>
}

public struct ListPackageVersionsInput: Equatable {
    /// <p>
    ///          The name of the domain that contains the repository that contains the returned package versions.
    ///        </p>
    public let domain: String?
    /// <p>
    ///         The 12-digit account number of the AWS account that owns the domain. It does not include
    ///         dashes or spaces.
    ///       </p>
    public let domainOwner: String?
    /// <p>
    ///       The format of the returned packages. The valid package types are:
    ///     </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>npm</code>: A Node Package Manager (npm) package.
    ///         </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>pypi</code>: A Python Package Index (PyPI) package.
    ///         </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>maven</code>: A Maven package that contains compiled code in a distributable format, such as a JAR file.
    ///         </p>
    ///             </li>
    ///          </ul>
    public let format: PackageFormat?
    /// <p>
    ///         The maximum number of results to return per page.
    ///        </p>
    public let maxResults: Int?
    /// <p>
    ///       The namespace of the package. The package component that specifies its
    ///       namespace depends on its type. For example:
    ///     </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///           The namespace of a Maven package is its <code>groupId</code>.
    ///         </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///           The namespace of an npm package is its <code>scope</code>.
    ///         </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///           A Python package does not contain a corresponding component, so
    ///           Python packages do not have a namespace.
    ///         </p>
    ///             </li>
    ///          </ul>
    public let namespace: String?
    /// <p>
    ///         The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    ///        </p>
    public let nextToken: String?
    /// <p>
    ///       The name of the package for which you want to return a list of package versions.
    ///     </p>
    public let package: String?
    /// <p>
    ///          The name of the repository that contains the package.
    ///        </p>
    public let repository: String?
    /// <p>
    ///       How to sort the returned list of package versions.
    ///     </p>
    public let sortBy: PackageVersionSortType?
    /// <p>
    ///       A string that specifies the status of the package versions to include in the returned list. It can be one of the following:
    ///     </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>Published</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Unfinished</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Unlisted</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Archived</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Disposed</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let status: PackageVersionStatus?

    public init (
        domain: String? = nil,
        domainOwner: String? = nil,
        format: PackageFormat? = nil,
        maxResults: Int? = nil,
        namespace: String? = nil,
        nextToken: String? = nil,
        package: String? = nil,
        repository: String? = nil,
        sortBy: PackageVersionSortType? = nil,
        status: PackageVersionStatus? = nil
    )
    {
        self.domain = domain
        self.domainOwner = domainOwner
        self.format = format
        self.maxResults = maxResults
        self.namespace = namespace
        self.nextToken = nextToken
        self.package = package
        self.repository = repository
        self.sortBy = sortBy
        self.status = status
    }
}

struct ListPackageVersionsInputBody: Equatable {
}

extension ListPackageVersionsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListPackageVersionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPackageVersionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPackageVersionsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPackageVersionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListPackageVersionsOutputResponse(defaultDisplayVersion: \(String(describing: defaultDisplayVersion)), format: \(String(describing: format)), namespace: \(String(describing: namespace)), nextToken: \(String(describing: nextToken)), package: \(String(describing: package)), versions: \(String(describing: versions)))"}
}

extension ListPackageVersionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListPackageVersionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.defaultDisplayVersion = output.defaultDisplayVersion
            self.format = output.format
            self.namespace = output.namespace
            self.nextToken = output.nextToken
            self.package = output.package
            self.versions = output.versions
        } else {
            self.defaultDisplayVersion = nil
            self.format = nil
            self.namespace = nil
            self.nextToken = nil
            self.package = nil
            self.versions = nil
        }
    }
}

public struct ListPackageVersionsOutputResponse: Equatable {
    /// <p>
    ///       The default package version to display. This depends on the package format:
    ///     </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///           For Maven and PyPI packages, it's the most recently published package version.
    ///         </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///           For npm packages, it's the version referenced by the
    ///           <code>latest</code> tag. If the  <code>latest</code> tag is not set, it's the most recently published package version.
    ///         </p>
    ///             </li>
    ///          </ul>
    public let defaultDisplayVersion: String?
    /// <p>
    ///       A format of the package. Valid package format values are:
    ///     </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>npm</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>pypi</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>maven</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let format: PackageFormat?
    /// <p>
    ///       The namespace of the package. The package component that specifies its
    ///       namespace depends on its type. For example:
    ///     </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///           The namespace of a Maven package is its <code>groupId</code>.
    ///         </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///           The namespace of an npm package is its <code>scope</code>.
    ///         </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///           A Python package does not contain a corresponding component, so
    ///           Python packages do not have a namespace.
    ///         </p>
    ///             </li>
    ///          </ul>
    public let namespace: String?
    /// <p>
    ///         If there are additional results, this is the token for the next set of results.
    ///        </p>
    public let nextToken: String?
    /// <p>
    ///          The name of the package.
    ///        </p>
    public let package: String?
    /// <p>
    ///         The returned list of
    ///         <a href="https://docs.aws.amazon.com/codeartifact/latest/APIReference/API_PackageVersionSummary.html">PackageVersionSummary</a>
    ///         objects.
    ///        </p>
    public let versions: [PackageVersionSummary]?

    public init (
        defaultDisplayVersion: String? = nil,
        format: PackageFormat? = nil,
        namespace: String? = nil,
        nextToken: String? = nil,
        package: String? = nil,
        versions: [PackageVersionSummary]? = nil
    )
    {
        self.defaultDisplayVersion = defaultDisplayVersion
        self.format = format
        self.namespace = namespace
        self.nextToken = nextToken
        self.package = package
        self.versions = versions
    }
}

struct ListPackageVersionsOutputResponseBody: Equatable {
    public let defaultDisplayVersion: String?
    public let format: PackageFormat?
    public let namespace: String?
    public let package: String?
    public let versions: [PackageVersionSummary]?
    public let nextToken: String?
}

extension ListPackageVersionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case defaultDisplayVersion
        case format
        case namespace
        case nextToken
        case package
        case versions
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let defaultDisplayVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .defaultDisplayVersion)
        defaultDisplayVersion = defaultDisplayVersionDecoded
        let formatDecoded = try containerValues.decodeIfPresent(PackageFormat.self, forKey: .format)
        format = formatDecoded
        let namespaceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .namespace)
        namespace = namespaceDecoded
        let packageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .package)
        package = packageDecoded
        let versionsContainer = try containerValues.decodeIfPresent([PackageVersionSummary?].self, forKey: .versions)
        var versionsDecoded0:[PackageVersionSummary]? = nil
        if let versionsContainer = versionsContainer {
            versionsDecoded0 = [PackageVersionSummary]()
            for structure0 in versionsContainer {
                if let structure0 = structure0 {
                    versionsDecoded0?.append(structure0)
                }
            }
        }
        versions = versionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListPackagesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListPackagesInput(domain: \(String(describing: domain)), domainOwner: \(String(describing: domainOwner)), format: \(String(describing: format)), maxResults: \(String(describing: maxResults)), namespace: \(String(describing: namespace)), nextToken: \(String(describing: nextToken)), packagePrefix: \(String(describing: packagePrefix)), repository: \(String(describing: repository)))"}
}

extension ListPackagesInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListPackagesInputHeadersMiddleware: Middleware {
    public let id: String = "ListPackagesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPackagesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPackagesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPackagesInput>
    public typealias MOutput = OperationOutput<ListPackagesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPackagesOutputError>
}

public struct ListPackagesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListPackagesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPackagesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPackagesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let packagePrefix = input.operationInput.packagePrefix {
            let packagePrefixQueryItem = URLQueryItem(name: "package-prefix".urlPercentEncoding(), value: String(packagePrefix).urlPercentEncoding())
            input.builder.withQueryItem(packagePrefixQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "max-results".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "next-token".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let domain = input.operationInput.domain {
            let domainQueryItem = URLQueryItem(name: "domain".urlPercentEncoding(), value: String(domain).urlPercentEncoding())
            input.builder.withQueryItem(domainQueryItem)
        }
        if let domainOwner = input.operationInput.domainOwner {
            let domainOwnerQueryItem = URLQueryItem(name: "domain-owner".urlPercentEncoding(), value: String(domainOwner).urlPercentEncoding())
            input.builder.withQueryItem(domainOwnerQueryItem)
        }
        if let format = input.operationInput.format {
            let formatQueryItem = URLQueryItem(name: "format".urlPercentEncoding(), value: String(format.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(formatQueryItem)
        }
        if let namespace = input.operationInput.namespace {
            let namespaceQueryItem = URLQueryItem(name: "namespace".urlPercentEncoding(), value: String(namespace).urlPercentEncoding())
            input.builder.withQueryItem(namespaceQueryItem)
        }
        if let repository = input.operationInput.repository {
            let repositoryQueryItem = URLQueryItem(name: "repository".urlPercentEncoding(), value: String(repository).urlPercentEncoding())
            input.builder.withQueryItem(repositoryQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPackagesInput>
    public typealias MOutput = OperationOutput<ListPackagesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPackagesOutputError>
}

public struct ListPackagesInput: Equatable {
    /// <p>
    ///         The name of the domain that contains the repository that contains the requested list of packages.
    ///       </p>
    public let domain: String?
    /// <p>
    ///         The 12-digit account number of the AWS account that owns the domain. It does not include
    ///         dashes or spaces.
    ///       </p>
    public let domainOwner: String?
    /// <p>
    ///       The format of the packages. The valid package types are:
    ///     </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>npm</code>: A Node Package Manager (npm) package.
    ///         </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>pypi</code>: A Python Package Index (PyPI) package.
    ///         </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>maven</code>: A Maven package that contains compiled code in a distributable format, such as a JAR file.
    ///         </p>
    ///             </li>
    ///          </ul>
    public let format: PackageFormat?
    /// <p>
    ///         The maximum number of results to return per page.
    ///        </p>
    public let maxResults: Int?
    /// <p>
    ///       The namespace of the package. The package component that specifies its
    ///       namespace depends on its type. For example:
    ///     </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///           The namespace of a Maven package is its <code>groupId</code>.
    ///         </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///           The namespace of an npm package is its <code>scope</code>.
    ///         </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///           A Python package does not contain a corresponding component, so
    ///           Python packages do not have a namespace.
    ///         </p>
    ///             </li>
    ///          </ul>
    public let namespace: String?
    /// <p>
    ///         The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    ///        </p>
    public let nextToken: String?
    /// <p>
    ///       A prefix used to filter returned packages. Only packages with names that start with
    ///       <code>packagePrefix</code> are returned.
    ///     </p>
    public let packagePrefix: String?
    /// <p>
    ///          The name of the repository from which packages are to be listed.
    ///        </p>
    public let repository: String?

    public init (
        domain: String? = nil,
        domainOwner: String? = nil,
        format: PackageFormat? = nil,
        maxResults: Int? = nil,
        namespace: String? = nil,
        nextToken: String? = nil,
        packagePrefix: String? = nil,
        repository: String? = nil
    )
    {
        self.domain = domain
        self.domainOwner = domainOwner
        self.format = format
        self.maxResults = maxResults
        self.namespace = namespace
        self.nextToken = nextToken
        self.packagePrefix = packagePrefix
        self.repository = repository
    }
}

struct ListPackagesInputBody: Equatable {
}

extension ListPackagesInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListPackagesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPackagesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPackagesOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPackagesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListPackagesOutputResponse(nextToken: \(String(describing: nextToken)), packages: \(String(describing: packages)))"}
}

extension ListPackagesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListPackagesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.packages = output.packages
        } else {
            self.nextToken = nil
            self.packages = nil
        }
    }
}

public struct ListPackagesOutputResponse: Equatable {
    /// <p>
    ///         If there are additional results, this is the token for the next set of results.
    ///        </p>
    public let nextToken: String?
    /// <p>
    ///         The list of returned <a href="https://docs.aws.amazon.com/codeartifact/latest/APIReference/API_PackageSummary.html">PackageSummary</a>
    ///         objects.
    ///        </p>
    public let packages: [PackageSummary]?

    public init (
        nextToken: String? = nil,
        packages: [PackageSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.packages = packages
    }
}

struct ListPackagesOutputResponseBody: Equatable {
    public let packages: [PackageSummary]?
    public let nextToken: String?
}

extension ListPackagesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case packages
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let packagesContainer = try containerValues.decodeIfPresent([PackageSummary?].self, forKey: .packages)
        var packagesDecoded0:[PackageSummary]? = nil
        if let packagesContainer = packagesContainer {
            packagesDecoded0 = [PackageSummary]()
            for structure0 in packagesContainer {
                if let structure0 = structure0 {
                    packagesDecoded0?.append(structure0)
                }
            }
        }
        packages = packagesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListRepositoriesInDomainInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListRepositoriesInDomainInput(administratorAccount: \(String(describing: administratorAccount)), domain: \(String(describing: domain)), domainOwner: \(String(describing: domainOwner)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), repositoryPrefix: \(String(describing: repositoryPrefix)))"}
}

extension ListRepositoriesInDomainInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListRepositoriesInDomainInputHeadersMiddleware: Middleware {
    public let id: String = "ListRepositoriesInDomainInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListRepositoriesInDomainInput>,
                  next: H) -> Swift.Result<OperationOutput<ListRepositoriesInDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListRepositoriesInDomainInput>
    public typealias MOutput = OperationOutput<ListRepositoriesInDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListRepositoriesInDomainOutputError>
}

public struct ListRepositoriesInDomainInputQueryItemMiddleware: Middleware {
    public let id: String = "ListRepositoriesInDomainInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListRepositoriesInDomainInput>,
                  next: H) -> Swift.Result<OperationOutput<ListRepositoriesInDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let repositoryPrefix = input.operationInput.repositoryPrefix {
            let repositoryPrefixQueryItem = URLQueryItem(name: "repository-prefix".urlPercentEncoding(), value: String(repositoryPrefix).urlPercentEncoding())
            input.builder.withQueryItem(repositoryPrefixQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "max-results".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "next-token".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let domain = input.operationInput.domain {
            let domainQueryItem = URLQueryItem(name: "domain".urlPercentEncoding(), value: String(domain).urlPercentEncoding())
            input.builder.withQueryItem(domainQueryItem)
        }
        if let domainOwner = input.operationInput.domainOwner {
            let domainOwnerQueryItem = URLQueryItem(name: "domain-owner".urlPercentEncoding(), value: String(domainOwner).urlPercentEncoding())
            input.builder.withQueryItem(domainOwnerQueryItem)
        }
        if let administratorAccount = input.operationInput.administratorAccount {
            let administratorAccountQueryItem = URLQueryItem(name: "administrator-account".urlPercentEncoding(), value: String(administratorAccount).urlPercentEncoding())
            input.builder.withQueryItem(administratorAccountQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListRepositoriesInDomainInput>
    public typealias MOutput = OperationOutput<ListRepositoriesInDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListRepositoriesInDomainOutputError>
}

public struct ListRepositoriesInDomainInput: Equatable {
    /// <p>
    ///          Filter the list of repositories to only include those that are managed by the AWS account ID.
    ///        </p>
    public let administratorAccount: String?
    /// <p>
    ///          The name of the domain that contains the returned list of repositories.
    ///        </p>
    public let domain: String?
    /// <p>
    ///         The 12-digit account number of the AWS account that owns the domain. It does not include
    ///         dashes or spaces.
    ///       </p>
    public let domainOwner: String?
    /// <p>
    ///         The maximum number of results to return per page.
    ///        </p>
    public let maxResults: Int?
    /// <p>
    ///         The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    ///        </p>
    public let nextToken: String?
    /// <p>
    ///       A prefix used to filter returned repositories. Only repositories with names that start with
    ///       <code>repositoryPrefix</code> are returned.
    ///     </p>
    public let repositoryPrefix: String?

    public init (
        administratorAccount: String? = nil,
        domain: String? = nil,
        domainOwner: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        repositoryPrefix: String? = nil
    )
    {
        self.administratorAccount = administratorAccount
        self.domain = domain
        self.domainOwner = domainOwner
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.repositoryPrefix = repositoryPrefix
    }
}

struct ListRepositoriesInDomainInputBody: Equatable {
}

extension ListRepositoriesInDomainInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListRepositoriesInDomainOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListRepositoriesInDomainOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListRepositoriesInDomainOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListRepositoriesInDomainOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListRepositoriesInDomainOutputResponse(nextToken: \(String(describing: nextToken)), repositories: \(String(describing: repositories)))"}
}

extension ListRepositoriesInDomainOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListRepositoriesInDomainOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.repositories = output.repositories
        } else {
            self.nextToken = nil
            self.repositories = nil
        }
    }
}

public struct ListRepositoriesInDomainOutputResponse: Equatable {
    /// <p>
    ///         If there are additional results, this is the token for the next set of results.
    ///        </p>
    public let nextToken: String?
    /// <p>
    ///        The returned list of repositories.
    ///      </p>
    public let repositories: [RepositorySummary]?

    public init (
        nextToken: String? = nil,
        repositories: [RepositorySummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.repositories = repositories
    }
}

struct ListRepositoriesInDomainOutputResponseBody: Equatable {
    public let repositories: [RepositorySummary]?
    public let nextToken: String?
}

extension ListRepositoriesInDomainOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case repositories
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoriesContainer = try containerValues.decodeIfPresent([RepositorySummary?].self, forKey: .repositories)
        var repositoriesDecoded0:[RepositorySummary]? = nil
        if let repositoriesContainer = repositoriesContainer {
            repositoriesDecoded0 = [RepositorySummary]()
            for structure0 in repositoriesContainer {
                if let structure0 = structure0 {
                    repositoriesDecoded0?.append(structure0)
                }
            }
        }
        repositories = repositoriesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListRepositoriesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListRepositoriesInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), repositoryPrefix: \(String(describing: repositoryPrefix)))"}
}

extension ListRepositoriesInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListRepositoriesInputHeadersMiddleware: Middleware {
    public let id: String = "ListRepositoriesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListRepositoriesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListRepositoriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListRepositoriesInput>
    public typealias MOutput = OperationOutput<ListRepositoriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListRepositoriesOutputError>
}

public struct ListRepositoriesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListRepositoriesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListRepositoriesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListRepositoriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let repositoryPrefix = input.operationInput.repositoryPrefix {
            let repositoryPrefixQueryItem = URLQueryItem(name: "repository-prefix".urlPercentEncoding(), value: String(repositoryPrefix).urlPercentEncoding())
            input.builder.withQueryItem(repositoryPrefixQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "max-results".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "next-token".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListRepositoriesInput>
    public typealias MOutput = OperationOutput<ListRepositoriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListRepositoriesOutputError>
}

public struct ListRepositoriesInput: Equatable {
    /// <p>
    ///         The maximum number of results to return per page.
    ///        </p>
    public let maxResults: Int?
    /// <p>
    ///         The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    ///        </p>
    public let nextToken: String?
    /// <p> A prefix used to filter returned repositories. Only repositories with names that start
    ///       with <code>repositoryPrefix</code> are returned.</p>
    public let repositoryPrefix: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        repositoryPrefix: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.repositoryPrefix = repositoryPrefix
    }
}

struct ListRepositoriesInputBody: Equatable {
}

extension ListRepositoriesInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListRepositoriesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListRepositoriesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListRepositoriesOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListRepositoriesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListRepositoriesOutputResponse(nextToken: \(String(describing: nextToken)), repositories: \(String(describing: repositories)))"}
}

extension ListRepositoriesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListRepositoriesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.repositories = output.repositories
        } else {
            self.nextToken = nil
            self.repositories = nil
        }
    }
}

public struct ListRepositoriesOutputResponse: Equatable {
    /// <p>
    ///         If there are additional results, this is the token for the next set of results.
    ///        </p>
    public let nextToken: String?
    /// <p>
    ///         The returned list of <a href="https://docs.aws.amazon.com/codeartifact/latest/APIReference/API_RepositorySummary.html">RepositorySummary</a>
    ///         objects.
    ///        </p>
    public let repositories: [RepositorySummary]?

    public init (
        nextToken: String? = nil,
        repositories: [RepositorySummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.repositories = repositories
    }
}

struct ListRepositoriesOutputResponseBody: Equatable {
    public let repositories: [RepositorySummary]?
    public let nextToken: String?
}

extension ListRepositoriesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case repositories
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoriesContainer = try containerValues.decodeIfPresent([RepositorySummary?].self, forKey: .repositories)
        var repositoriesDecoded0:[RepositorySummary]? = nil
        if let repositoriesContainer = repositoriesContainer {
            repositoriesDecoded0 = [RepositorySummary]()
            for structure0 in repositoriesContainer {
                if let structure0 = structure0 {
                    repositoriesDecoded0?.append(structure0)
                }
            }
        }
        repositories = repositoriesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceInput(resourceArn: \(String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let resourceArn = input.operationInput.resourceArn {
            let resourceArnQueryItem = URLQueryItem(name: "resourceArn".urlPercentEncoding(), value: String(resourceArn).urlPercentEncoding())
            input.builder.withQueryItem(resourceArnQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the resource to get tags for.</p>
    public let resourceArn: String?

    public init (
        resourceArn: String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Equatable {
}

extension ListTagsForResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceOutputResponse(tags: \(String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Equatable {
    /// <p>A list of tag key and value pairs associated with the specified resource.</p>
    public let tags: [Tag]?

    public init (
        tags: [Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Equatable {
    public let tags: [Tag]?
}

extension ListTagsForResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension PackageDependency: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dependencyType
        case namespace
        case package
        case versionRequirement
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dependencyType = dependencyType {
            try encodeContainer.encode(dependencyType, forKey: .dependencyType)
        }
        if let namespace = namespace {
            try encodeContainer.encode(namespace, forKey: .namespace)
        }
        if let package = package {
            try encodeContainer.encode(package, forKey: .package)
        }
        if let versionRequirement = versionRequirement {
            try encodeContainer.encode(versionRequirement, forKey: .versionRequirement)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namespaceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .namespace)
        namespace = namespaceDecoded
        let packageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .package)
        package = packageDecoded
        let dependencyTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dependencyType)
        dependencyType = dependencyTypeDecoded
        let versionRequirementDecoded = try containerValues.decodeIfPresent(String.self, forKey: .versionRequirement)
        versionRequirement = versionRequirementDecoded
    }
}

extension PackageDependency: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PackageDependency(dependencyType: \(String(describing: dependencyType)), namespace: \(String(describing: namespace)), package: \(String(describing: package)), versionRequirement: \(String(describing: versionRequirement)))"}
}

/// <p>
///         Details about a package dependency.
///       </p>
public struct PackageDependency: Equatable {
    /// <p> The type of a package dependency. The possible values depend on the package type.
    ///       Example types are <code>compile</code>, <code>runtime</code>, and <code>test</code> for Maven
    ///       packages, and <code>dev</code>, <code>prod</code>, and <code>optional</code> for npm packages. </p>
    public let dependencyType: String?
    /// <p>
    ///       The namespace of the package. The package component that specifies its
    ///       namespace depends on its type. For example:
    ///     </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///           The namespace of a Maven package is its <code>groupId</code>.
    ///         </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///           The namespace of an npm package is its <code>scope</code>.
    ///         </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///           A Python package does not contain a corresponding component, so
    ///           Python packages do not have a namespace.
    ///         </p>
    ///             </li>
    ///          </ul>
    public let namespace: String?
    /// <p>
    ///         The name of the package that this package depends on.
    ///        </p>
    public let package: String?
    /// <p>
    ///         The required version, or version range, of the package that this package depends on. The version format
    ///         is specific to the package type. For example, the following are possible valid required versions: <code>1.2.3</code>,
    ///         <code>^2.3.4</code>, or <code>4.x</code>.
    ///       </p>
    public let versionRequirement: String?

    public init (
        dependencyType: String? = nil,
        namespace: String? = nil,
        package: String? = nil,
        versionRequirement: String? = nil
    )
    {
        self.dependencyType = dependencyType
        self.namespace = namespace
        self.package = package
        self.versionRequirement = versionRequirement
    }
}

public enum PackageFormat {
    case maven
    case npm
    case nuget
    case pypi
    case sdkUnknown(String)
}

extension PackageFormat : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [PackageFormat] {
        return [
            .maven,
            .npm,
            .nuget,
            .pypi,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .maven: return "maven"
        case .npm: return "npm"
        case .nuget: return "nuget"
        case .pypi: return "pypi"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = PackageFormat(rawValue: rawValue) ?? PackageFormat.sdkUnknown(rawValue)
    }
}

extension PackageSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case format
        case namespace
        case package
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let format = format {
            try encodeContainer.encode(format.rawValue, forKey: .format)
        }
        if let namespace = namespace {
            try encodeContainer.encode(namespace, forKey: .namespace)
        }
        if let package = package {
            try encodeContainer.encode(package, forKey: .package)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let formatDecoded = try containerValues.decodeIfPresent(PackageFormat.self, forKey: .format)
        format = formatDecoded
        let namespaceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .namespace)
        namespace = namespaceDecoded
        let packageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .package)
        package = packageDecoded
    }
}

extension PackageSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PackageSummary(format: \(String(describing: format)), namespace: \(String(describing: namespace)), package: \(String(describing: package)))"}
}

/// <p>
///       Details about a package, including its format, namespace, and name. The
///       <a href="https://docs.aws.amazon.com/codeartifact/latest/APIReference/API_ListPackages.html">ListPackages</a>
///       operation returns a list of <code>PackageSummary</code> objects.
///     </p>
public struct PackageSummary: Equatable {
    /// <p>
    ///       The format of the package. Valid values are:
    ///     </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>npm</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>pypi</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>maven</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let format: PackageFormat?
    /// <p>
    ///       The namespace of the package. The package component that specifies its
    ///       namespace depends on its type. For example:
    ///     </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///           The namespace of a Maven package is its <code>groupId</code>.
    ///         </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///           The namespace of an npm package is its <code>scope</code>.
    ///         </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///           A Python package does not contain a corresponding component, so
    ///           Python packages do not have a namespace.
    ///         </p>
    ///             </li>
    ///          </ul>
    public let namespace: String?
    /// <p>
    ///       The name of the package.
    ///     </p>
    public let package: String?

    public init (
        format: PackageFormat? = nil,
        namespace: String? = nil,
        package: String? = nil
    )
    {
        self.format = format
        self.namespace = namespace
        self.package = package
    }
}

extension PackageVersionDescription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case displayName
        case format
        case homePage
        case licenses
        case namespace
        case packageName
        case publishedTime
        case revision
        case sourceCodeRepository
        case status
        case summary
        case version
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let format = format {
            try encodeContainer.encode(format.rawValue, forKey: .format)
        }
        if let homePage = homePage {
            try encodeContainer.encode(homePage, forKey: .homePage)
        }
        if let licenses = licenses {
            var licensesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .licenses)
            for licenseinfolist0 in licenses {
                try licensesContainer.encode(licenseinfolist0)
            }
        }
        if let namespace = namespace {
            try encodeContainer.encode(namespace, forKey: .namespace)
        }
        if let packageName = packageName {
            try encodeContainer.encode(packageName, forKey: .packageName)
        }
        if let publishedTime = publishedTime {
            try encodeContainer.encode(publishedTime.timeIntervalSince1970, forKey: .publishedTime)
        }
        if let revision = revision {
            try encodeContainer.encode(revision, forKey: .revision)
        }
        if let sourceCodeRepository = sourceCodeRepository {
            try encodeContainer.encode(sourceCodeRepository, forKey: .sourceCodeRepository)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let summary = summary {
            try encodeContainer.encode(summary, forKey: .summary)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let formatDecoded = try containerValues.decodeIfPresent(PackageFormat.self, forKey: .format)
        format = formatDecoded
        let namespaceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .namespace)
        namespace = namespaceDecoded
        let packageNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .packageName)
        packageName = packageNameDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
        let summaryDecoded = try containerValues.decodeIfPresent(String.self, forKey: .summary)
        summary = summaryDecoded
        let homePageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .homePage)
        homePage = homePageDecoded
        let sourceCodeRepositoryDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceCodeRepository)
        sourceCodeRepository = sourceCodeRepositoryDecoded
        let publishedTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .publishedTime)
        publishedTime = publishedTimeDecoded
        let licensesContainer = try containerValues.decodeIfPresent([LicenseInfo?].self, forKey: .licenses)
        var licensesDecoded0:[LicenseInfo]? = nil
        if let licensesContainer = licensesContainer {
            licensesDecoded0 = [LicenseInfo]()
            for structure0 in licensesContainer {
                if let structure0 = structure0 {
                    licensesDecoded0?.append(structure0)
                }
            }
        }
        licenses = licensesDecoded0
        let revisionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .revision)
        revision = revisionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(PackageVersionStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension PackageVersionDescription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PackageVersionDescription(displayName: \(String(describing: displayName)), format: \(String(describing: format)), homePage: \(String(describing: homePage)), licenses: \(String(describing: licenses)), namespace: \(String(describing: namespace)), packageName: \(String(describing: packageName)), publishedTime: \(String(describing: publishedTime)), revision: \(String(describing: revision)), sourceCodeRepository: \(String(describing: sourceCodeRepository)), status: \(String(describing: status)), summary: \(String(describing: summary)), version: \(String(describing: version)))"}
}

/// <p>
///       Details about a package version.
///     </p>
public struct PackageVersionDescription: Equatable {
    /// <p>
    ///       The name of the package that is displayed. The <code>displayName</code> varies depending
    ///       on the package version's format. For example, if an npm package is named <code>ui</code>,
    ///       is in the namespace <code>vue</code>, and has the format <code>npm</code>, then
    ///       the <code>displayName</code> is <code>@vue/ui</code>.
    ///     </p>
    public let displayName: String?
    /// <p>
    ///       The format of the package version. The valid package formats are:
    ///     </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>npm</code>: A Node Package Manager (npm) package.
    ///         </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>pypi</code>: A Python Package Index (PyPI) package.
    ///         </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>maven</code>: A Maven package that contains compiled code in a distributable format, such as a JAR file.
    ///         </p>
    ///             </li>
    ///          </ul>
    public let format: PackageFormat?
    /// <p>
    ///       The homepage associated with the package.
    ///     </p>
    public let homePage: String?
    /// <p>
    ///       Information about licenses associated with the package version.
    ///     </p>
    public let licenses: [LicenseInfo]?
    /// <p>
    ///       The namespace of the package. The package component that specifies its
    ///       namespace depends on its type. For example:
    ///     </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///           The namespace of a Maven package is its <code>groupId</code>.
    ///         </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///           The namespace of an npm package is its <code>scope</code>.
    ///         </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///           A Python package does not contain a corresponding component, so
    ///           Python packages do not have a namespace.
    ///         </p>
    ///             </li>
    ///          </ul>
    public let namespace: String?
    /// <p>
    ///       The name of the requested package.
    ///     </p>
    public let packageName: String?
    /// <p>
    ///       A timestamp that contains the date and time the package version was published.
    ///     </p>
    public let publishedTime: Date?
    /// <p>
    ///       The revision of the package version.
    ///     </p>
    public let revision: String?
    /// <p>
    ///       The repository for the source code in the package version, or the source code used to build it.
    ///     </p>
    public let sourceCodeRepository: String?
    /// <p>
    ///       A string that contains the status of the package version. It can be one of the following:
    ///     </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>Published</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Unfinished</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Unlisted</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Archived</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Disposed</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let status: PackageVersionStatus?
    /// <p>
    ///       A summary of the package version. The summary is extracted from the package. The information in and
    ///       detail level of the summary depends on the package version's format.
    ///     </p>
    public let summary: String?
    /// <p>
    ///       The version of the package.
    ///     </p>
    public let version: String?

    public init (
        displayName: String? = nil,
        format: PackageFormat? = nil,
        homePage: String? = nil,
        licenses: [LicenseInfo]? = nil,
        namespace: String? = nil,
        packageName: String? = nil,
        publishedTime: Date? = nil,
        revision: String? = nil,
        sourceCodeRepository: String? = nil,
        status: PackageVersionStatus? = nil,
        summary: String? = nil,
        version: String? = nil
    )
    {
        self.displayName = displayName
        self.format = format
        self.homePage = homePage
        self.licenses = licenses
        self.namespace = namespace
        self.packageName = packageName
        self.publishedTime = publishedTime
        self.revision = revision
        self.sourceCodeRepository = sourceCodeRepository
        self.status = status
        self.summary = summary
        self.version = version
    }
}

extension PackageVersionError: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case errorCode
        case errorMessage
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode.rawValue, forKey: .errorCode)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(PackageVersionErrorCode.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension PackageVersionError: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PackageVersionError(errorCode: \(String(describing: errorCode)), errorMessage: \(String(describing: errorMessage)))"}
}

/// <p>
///        An error associated with package.
///    </p>
public struct PackageVersionError: Equatable {
    /// <p> The error code associated with the error. Valid error codes are: </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>ALREADY_EXISTS</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>MISMATCHED_REVISION</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>MISMATCHED_STATUS</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>NOT_ALLOWED</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>NOT_FOUND</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>SKIPPED</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let errorCode: PackageVersionErrorCode?
    /// <p>
    ///          The error message associated with the error.
    ///      </p>
    public let errorMessage: String?

    public init (
        errorCode: PackageVersionErrorCode? = nil,
        errorMessage: String? = nil
    )
    {
        self.errorCode = errorCode
        self.errorMessage = errorMessage
    }
}

public enum PackageVersionErrorCode {
    case alreadyExists
    case mismatchedRevision
    case mismatchedStatus
    case notAllowed
    case notFound
    case skipped
    case sdkUnknown(String)
}

extension PackageVersionErrorCode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [PackageVersionErrorCode] {
        return [
            .alreadyExists,
            .mismatchedRevision,
            .mismatchedStatus,
            .notAllowed,
            .notFound,
            .skipped,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .alreadyExists: return "ALREADY_EXISTS"
        case .mismatchedRevision: return "MISMATCHED_REVISION"
        case .mismatchedStatus: return "MISMATCHED_STATUS"
        case .notAllowed: return "NOT_ALLOWED"
        case .notFound: return "NOT_FOUND"
        case .skipped: return "SKIPPED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = PackageVersionErrorCode(rawValue: rawValue) ?? PackageVersionErrorCode.sdkUnknown(rawValue)
    }
}

public enum PackageVersionSortType {
    case publishedTime
    case sdkUnknown(String)
}

extension PackageVersionSortType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [PackageVersionSortType] {
        return [
            .publishedTime,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .publishedTime: return "PUBLISHED_TIME"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = PackageVersionSortType(rawValue: rawValue) ?? PackageVersionSortType.sdkUnknown(rawValue)
    }
}

public enum PackageVersionStatus {
    case archived
    case deleted
    case disposed
    case published
    case unfinished
    case unlisted
    case sdkUnknown(String)
}

extension PackageVersionStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [PackageVersionStatus] {
        return [
            .archived,
            .deleted,
            .disposed,
            .published,
            .unfinished,
            .unlisted,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .archived: return "Archived"
        case .deleted: return "Deleted"
        case .disposed: return "Disposed"
        case .published: return "Published"
        case .unfinished: return "Unfinished"
        case .unlisted: return "Unlisted"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = PackageVersionStatus(rawValue: rawValue) ?? PackageVersionStatus.sdkUnknown(rawValue)
    }
}

extension PackageVersionSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case revision
        case status
        case version
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let revision = revision {
            try encodeContainer.encode(revision, forKey: .revision)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
        let revisionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .revision)
        revision = revisionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(PackageVersionStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension PackageVersionSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PackageVersionSummary(revision: \(String(describing: revision)), status: \(String(describing: status)), version: \(String(describing: version)))"}
}

/// <p>
///        Details about a package version, including its status, version, and revision. The
///        <a href="https://docs.aws.amazon.com/codeartifact/latest/APIReference/API_ListPackageVersions.html">ListPackageVersions</a>
///        operation returns a list of <code>PackageVersionSummary</code> objects.
///      </p>
public struct PackageVersionSummary: Equatable {
    /// <p>
    ///       The revision associated with a package version.
    ///     </p>
    public let revision: String?
    /// <p>
    ///       A string that contains the status of the package version. It can be one of the following:
    ///     </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>Published</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Unfinished</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Unlisted</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Archived</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Disposed</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let status: PackageVersionStatus?
    /// <p>
    ///         Information about a package version.
    ///        </p>
    public let version: String?

    public init (
        revision: String? = nil,
        status: PackageVersionStatus? = nil,
        version: String? = nil
    )
    {
        self.revision = revision
        self.status = status
        self.version = version
    }
}

public struct PutDomainPermissionsPolicyInputBodyMiddleware: Middleware {
    public let id: String = "PutDomainPermissionsPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutDomainPermissionsPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<PutDomainPermissionsPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutDomainPermissionsPolicyInput>
    public typealias MOutput = OperationOutput<PutDomainPermissionsPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutDomainPermissionsPolicyOutputError>
}

extension PutDomainPermissionsPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutDomainPermissionsPolicyInput(domain: \(String(describing: domain)), domainOwner: \(String(describing: domainOwner)), policyDocument: \(String(describing: policyDocument)), policyRevision: \(String(describing: policyRevision)))"}
}

extension PutDomainPermissionsPolicyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case domain
        case domainOwner
        case policyDocument
        case policyRevision
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domain = domain {
            try encodeContainer.encode(domain, forKey: .domain)
        }
        if let domainOwner = domainOwner {
            try encodeContainer.encode(domainOwner, forKey: .domainOwner)
        }
        if let policyDocument = policyDocument {
            try encodeContainer.encode(policyDocument, forKey: .policyDocument)
        }
        if let policyRevision = policyRevision {
            try encodeContainer.encode(policyRevision, forKey: .policyRevision)
        }
    }
}

public struct PutDomainPermissionsPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "PutDomainPermissionsPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutDomainPermissionsPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<PutDomainPermissionsPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutDomainPermissionsPolicyInput>
    public typealias MOutput = OperationOutput<PutDomainPermissionsPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutDomainPermissionsPolicyOutputError>
}

public struct PutDomainPermissionsPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "PutDomainPermissionsPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutDomainPermissionsPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<PutDomainPermissionsPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutDomainPermissionsPolicyInput>
    public typealias MOutput = OperationOutput<PutDomainPermissionsPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutDomainPermissionsPolicyOutputError>
}

public struct PutDomainPermissionsPolicyInput: Equatable {
    /// <p>
    ///         The name of the domain on which to set the resource policy.
    ///       </p>
    public let domain: String?
    /// <p>
    ///         The 12-digit account number of the AWS account that owns the domain. It does not include
    ///         dashes or spaces.
    ///       </p>
    public let domainOwner: String?
    /// <p> A valid displayable JSON Aspen policy string to be set as the access control resource
    ///       policy on the provided domain. </p>
    public let policyDocument: String?
    /// <p>
    ///         The current revision of the resource policy to be set. This revision is used for optimistic locking, which
    ///         prevents others from overwriting your changes to the domain's resource policy.
    ///       </p>
    public let policyRevision: String?

    public init (
        domain: String? = nil,
        domainOwner: String? = nil,
        policyDocument: String? = nil,
        policyRevision: String? = nil
    )
    {
        self.domain = domain
        self.domainOwner = domainOwner
        self.policyDocument = policyDocument
        self.policyRevision = policyRevision
    }
}

struct PutDomainPermissionsPolicyInputBody: Equatable {
    public let domain: String?
    public let domainOwner: String?
    public let policyRevision: String?
    public let policyDocument: String?
}

extension PutDomainPermissionsPolicyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case domain
        case domainOwner
        case policyDocument
        case policyRevision
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domain)
        domain = domainDecoded
        let domainOwnerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domainOwner)
        domainOwner = domainOwnerDecoded
        let policyRevisionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policyRevision)
        policyRevision = policyRevisionDecoded
        let policyDocumentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policyDocument)
        policyDocument = policyDocumentDecoded
    }
}

extension PutDomainPermissionsPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutDomainPermissionsPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutDomainPermissionsPolicyOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutDomainPermissionsPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutDomainPermissionsPolicyOutputResponse(policy: \(String(describing: policy)))"}
}

extension PutDomainPermissionsPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PutDomainPermissionsPolicyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.policy = output.policy
        } else {
            self.policy = nil
        }
    }
}

public struct PutDomainPermissionsPolicyOutputResponse: Equatable {
    /// <p> The resource policy that was set after processing the request. </p>
    public let policy: ResourcePolicy?

    public init (
        policy: ResourcePolicy? = nil
    )
    {
        self.policy = policy
    }
}

struct PutDomainPermissionsPolicyOutputResponseBody: Equatable {
    public let policy: ResourcePolicy?
}

extension PutDomainPermissionsPolicyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case policy
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(ResourcePolicy.self, forKey: .policy)
        policy = policyDecoded
    }
}

public struct PutRepositoryPermissionsPolicyInputBodyMiddleware: Middleware {
    public let id: String = "PutRepositoryPermissionsPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutRepositoryPermissionsPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<PutRepositoryPermissionsPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutRepositoryPermissionsPolicyInput>
    public typealias MOutput = OperationOutput<PutRepositoryPermissionsPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutRepositoryPermissionsPolicyOutputError>
}

extension PutRepositoryPermissionsPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutRepositoryPermissionsPolicyInput(domain: \(String(describing: domain)), domainOwner: \(String(describing: domainOwner)), policyDocument: \(String(describing: policyDocument)), policyRevision: \(String(describing: policyRevision)), repository: \(String(describing: repository)))"}
}

extension PutRepositoryPermissionsPolicyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case policyDocument
        case policyRevision
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policyDocument = policyDocument {
            try encodeContainer.encode(policyDocument, forKey: .policyDocument)
        }
        if let policyRevision = policyRevision {
            try encodeContainer.encode(policyRevision, forKey: .policyRevision)
        }
    }
}

public struct PutRepositoryPermissionsPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "PutRepositoryPermissionsPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutRepositoryPermissionsPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<PutRepositoryPermissionsPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutRepositoryPermissionsPolicyInput>
    public typealias MOutput = OperationOutput<PutRepositoryPermissionsPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutRepositoryPermissionsPolicyOutputError>
}

public struct PutRepositoryPermissionsPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "PutRepositoryPermissionsPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutRepositoryPermissionsPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<PutRepositoryPermissionsPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let domain = input.operationInput.domain {
            let domainQueryItem = URLQueryItem(name: "domain".urlPercentEncoding(), value: String(domain).urlPercentEncoding())
            input.builder.withQueryItem(domainQueryItem)
        }
        if let domainOwner = input.operationInput.domainOwner {
            let domainOwnerQueryItem = URLQueryItem(name: "domain-owner".urlPercentEncoding(), value: String(domainOwner).urlPercentEncoding())
            input.builder.withQueryItem(domainOwnerQueryItem)
        }
        if let repository = input.operationInput.repository {
            let repositoryQueryItem = URLQueryItem(name: "repository".urlPercentEncoding(), value: String(repository).urlPercentEncoding())
            input.builder.withQueryItem(repositoryQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutRepositoryPermissionsPolicyInput>
    public typealias MOutput = OperationOutput<PutRepositoryPermissionsPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutRepositoryPermissionsPolicyOutputError>
}

public struct PutRepositoryPermissionsPolicyInput: Equatable {
    /// <p>
    ///         The name of the domain containing the repository to set the resource policy on.
    ///       </p>
    public let domain: String?
    /// <p>
    ///         The 12-digit account number of the AWS account that owns the domain. It does not include
    ///         dashes or spaces.
    ///       </p>
    public let domainOwner: String?
    /// <p> A valid displayable JSON Aspen policy string to be set as the access control resource
    ///       policy on the provided repository. </p>
    public let policyDocument: String?
    /// <p>
    ///         Sets the revision of the resource policy that specifies permissions to access the repository.
    ///         This revision is used for optimistic locking, which prevents others from overwriting your
    ///         changes to the repository's resource policy.
    ///       </p>
    public let policyRevision: String?
    /// <p> The name of the repository to set the resource policy on. </p>
    public let repository: String?

    public init (
        domain: String? = nil,
        domainOwner: String? = nil,
        policyDocument: String? = nil,
        policyRevision: String? = nil,
        repository: String? = nil
    )
    {
        self.domain = domain
        self.domainOwner = domainOwner
        self.policyDocument = policyDocument
        self.policyRevision = policyRevision
        self.repository = repository
    }
}

struct PutRepositoryPermissionsPolicyInputBody: Equatable {
    public let policyRevision: String?
    public let policyDocument: String?
}

extension PutRepositoryPermissionsPolicyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case policyDocument
        case policyRevision
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyRevisionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policyRevision)
        policyRevision = policyRevisionDecoded
        let policyDocumentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policyDocument)
        policyDocument = policyDocumentDecoded
    }
}

extension PutRepositoryPermissionsPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutRepositoryPermissionsPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutRepositoryPermissionsPolicyOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutRepositoryPermissionsPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutRepositoryPermissionsPolicyOutputResponse(policy: \(String(describing: policy)))"}
}

extension PutRepositoryPermissionsPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PutRepositoryPermissionsPolicyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.policy = output.policy
        } else {
            self.policy = nil
        }
    }
}

public struct PutRepositoryPermissionsPolicyOutputResponse: Equatable {
    /// <p> The resource policy that was set after processing the request. </p>
    public let policy: ResourcePolicy?

    public init (
        policy: ResourcePolicy? = nil
    )
    {
        self.policy = policy
    }
}

struct PutRepositoryPermissionsPolicyOutputResponseBody: Equatable {
    public let policy: ResourcePolicy?
}

extension PutRepositoryPermissionsPolicyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case policy
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(ResourcePolicy.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension RepositoryDescription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case administratorAccount
        case arn
        case description
        case domainName
        case domainOwner
        case externalConnections
        case name
        case upstreams
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let administratorAccount = administratorAccount {
            try encodeContainer.encode(administratorAccount, forKey: .administratorAccount)
        }
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let domainName = domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let domainOwner = domainOwner {
            try encodeContainer.encode(domainOwner, forKey: .domainOwner)
        }
        if let externalConnections = externalConnections {
            var externalConnectionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .externalConnections)
            for repositoryexternalconnectioninfolist0 in externalConnections {
                try externalConnectionsContainer.encode(repositoryexternalconnectioninfolist0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let upstreams = upstreams {
            var upstreamsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .upstreams)
            for upstreamrepositoryinfolist0 in upstreams {
                try upstreamsContainer.encode(upstreamrepositoryinfolist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let administratorAccountDecoded = try containerValues.decodeIfPresent(String.self, forKey: .administratorAccount)
        administratorAccount = administratorAccountDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let domainOwnerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domainOwner)
        domainOwner = domainOwnerDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let upstreamsContainer = try containerValues.decodeIfPresent([UpstreamRepositoryInfo?].self, forKey: .upstreams)
        var upstreamsDecoded0:[UpstreamRepositoryInfo]? = nil
        if let upstreamsContainer = upstreamsContainer {
            upstreamsDecoded0 = [UpstreamRepositoryInfo]()
            for structure0 in upstreamsContainer {
                if let structure0 = structure0 {
                    upstreamsDecoded0?.append(structure0)
                }
            }
        }
        upstreams = upstreamsDecoded0
        let externalConnectionsContainer = try containerValues.decodeIfPresent([RepositoryExternalConnectionInfo?].self, forKey: .externalConnections)
        var externalConnectionsDecoded0:[RepositoryExternalConnectionInfo]? = nil
        if let externalConnectionsContainer = externalConnectionsContainer {
            externalConnectionsDecoded0 = [RepositoryExternalConnectionInfo]()
            for structure0 in externalConnectionsContainer {
                if let structure0 = structure0 {
                    externalConnectionsDecoded0?.append(structure0)
                }
            }
        }
        externalConnections = externalConnectionsDecoded0
    }
}

extension RepositoryDescription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RepositoryDescription(administratorAccount: \(String(describing: administratorAccount)), arn: \(String(describing: arn)), description: \(String(describing: description)), domainName: \(String(describing: domainName)), domainOwner: \(String(describing: domainOwner)), externalConnections: \(String(describing: externalConnections)), name: \(String(describing: name)), upstreams: \(String(describing: upstreams)))"}
}

/// <p> The details of a repository stored in AWS CodeArtifact. A CodeArtifact repository contains a set of
///       package versions, each of which maps to a set of assets. Repositories are polyglot—a single
///       repository can contain packages of any supported type. Each repository exposes endpoints for
///       fetching and publishing packages using tools like the <code>npm</code> CLI, the Maven CLI
///         (<code>mvn</code>), and <code>pip</code>. You can create up to 100 repositories per AWS
///       account. </p>
public struct RepositoryDescription: Equatable {
    /// <p> The 12-digit account number of the AWS account that manages the repository. </p>
    public let administratorAccount: String?
    /// <p> The Amazon Resource Name (ARN) of the repository. </p>
    public let arn: String?
    /// <p>
    ///       A text description of the repository.
    ///     </p>
    public let description: String?
    /// <p>
    ///         The name of the domain that contains the repository.
    ///        </p>
    public let domainName: String?
    /// <p>
    ///         The 12-digit account number of the AWS account that owns the domain that contains the repository. It does not include
    ///         dashes or spaces.
    ///       </p>
    public let domainOwner: String?
    /// <p>
    ///       An array of external connections associated with the repository.
    ///     </p>
    public let externalConnections: [RepositoryExternalConnectionInfo]?
    /// <p>
    ///         The name of the repository.
    ///        </p>
    public let name: String?
    /// <p> A list of upstream repositories to associate with the repository. The order of the upstream repositories
    ///         in the list determines their priority order when AWS CodeArtifact looks for a requested package version. For more
    ///         information, see <a href="https://docs.aws.amazon.com/codeartifact/latest/ug/repos-upstream.html">Working with upstream repositories</a>. </p>
    public let upstreams: [UpstreamRepositoryInfo]?

    public init (
        administratorAccount: String? = nil,
        arn: String? = nil,
        description: String? = nil,
        domainName: String? = nil,
        domainOwner: String? = nil,
        externalConnections: [RepositoryExternalConnectionInfo]? = nil,
        name: String? = nil,
        upstreams: [UpstreamRepositoryInfo]? = nil
    )
    {
        self.administratorAccount = administratorAccount
        self.arn = arn
        self.description = description
        self.domainName = domainName
        self.domainOwner = domainOwner
        self.externalConnections = externalConnections
        self.name = name
        self.upstreams = upstreams
    }
}

extension RepositoryExternalConnectionInfo: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case externalConnectionName
        case packageFormat
        case status
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let externalConnectionName = externalConnectionName {
            try encodeContainer.encode(externalConnectionName, forKey: .externalConnectionName)
        }
        if let packageFormat = packageFormat {
            try encodeContainer.encode(packageFormat.rawValue, forKey: .packageFormat)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let externalConnectionNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .externalConnectionName)
        externalConnectionName = externalConnectionNameDecoded
        let packageFormatDecoded = try containerValues.decodeIfPresent(PackageFormat.self, forKey: .packageFormat)
        packageFormat = packageFormatDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ExternalConnectionStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension RepositoryExternalConnectionInfo: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RepositoryExternalConnectionInfo(externalConnectionName: \(String(describing: externalConnectionName)), packageFormat: \(String(describing: packageFormat)), status: \(String(describing: status)))"}
}

/// <p>
///         Contains information about the external connection of a repository.
///       </p>
public struct RepositoryExternalConnectionInfo: Equatable {
    /// <p> The name of the external connection associated with a repository. </p>
    public let externalConnectionName: String?
    /// <p>
    ///         The package format associated with a repository's external connection. The valid package formats are:
    ///       </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>npm</code>: A Node Package Manager (npm) package.
    ///         </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>pypi</code>: A Python Package Index (PyPI) package.
    ///         </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>maven</code>: A Maven package that contains compiled code in a distributable format, such as a JAR file.
    ///         </p>
    ///             </li>
    ///          </ul>
    public let packageFormat: PackageFormat?
    /// <p>
    ///         The status of the external connection of a repository. There is one valid value, <code>Available</code>.
    ///       </p>
    public let status: ExternalConnectionStatus?

    public init (
        externalConnectionName: String? = nil,
        packageFormat: PackageFormat? = nil,
        status: ExternalConnectionStatus? = nil
    )
    {
        self.externalConnectionName = externalConnectionName
        self.packageFormat = packageFormat
        self.status = status
    }
}

extension RepositorySummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case administratorAccount
        case arn
        case description
        case domainName
        case domainOwner
        case name
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let administratorAccount = administratorAccount {
            try encodeContainer.encode(administratorAccount, forKey: .administratorAccount)
        }
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let domainName = domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let domainOwner = domainOwner {
            try encodeContainer.encode(domainOwner, forKey: .domainOwner)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let administratorAccountDecoded = try containerValues.decodeIfPresent(String.self, forKey: .administratorAccount)
        administratorAccount = administratorAccountDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let domainOwnerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domainOwner)
        domainOwner = domainOwnerDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension RepositorySummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RepositorySummary(administratorAccount: \(String(describing: administratorAccount)), arn: \(String(describing: arn)), description: \(String(describing: description)), domainName: \(String(describing: domainName)), domainOwner: \(String(describing: domainOwner)), name: \(String(describing: name)))"}
}

/// <p> Details about a repository, including its Amazon Resource Name (ARN), description, and
///       domain information. The <a href="https://docs.aws.amazon.com/codeartifact/latest/APIReference/API_ListRepositories.html">ListRepositories</a> operation returns a list of
///         <code>RepositorySummary</code> objects. </p>
public struct RepositorySummary: Equatable {
    /// <p>
    ///          The AWS account ID that manages the repository.
    ///       </p>
    public let administratorAccount: String?
    /// <p> The ARN of the repository. </p>
    public let arn: String?
    /// <p>
    ///       The description of the repository.
    ///     </p>
    public let description: String?
    /// <p>
    ///          The name of the domain that contains the repository.
    ///       </p>
    public let domainName: String?
    /// <p>
    ///         The 12-digit account number of the AWS account that owns the domain. It does not include
    ///         dashes or spaces.
    ///       </p>
    public let domainOwner: String?
    /// <p>
    ///          The name of the repository.
    ///       </p>
    public let name: String?

    public init (
        administratorAccount: String? = nil,
        arn: String? = nil,
        description: String? = nil,
        domainName: String? = nil,
        domainOwner: String? = nil,
        name: String? = nil
    )
    {
        self.administratorAccount = administratorAccount
        self.arn = arn
        self.description = description
        self.domainName = domainName
        self.domainOwner = domainOwner
        self.name = name
    }
}

extension ResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundException(message: \(String(describing: message)), resourceId: \(String(describing: resourceId)), resourceType: \(String(describing: resourceType)))"}
}

extension ResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>
///       The operation did not succeed because the resource requested is not found in the service.
///     </p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    /// <p>
    ///       The ID of the resource.
    ///     </p>
    public var resourceId: String?
    /// <p>
    ///       The type of AWS resource.
    ///     </p>
    public var resourceType: ResourceType?

    public init (
        message: String? = nil,
        resourceId: String? = nil,
        resourceType: ResourceType? = nil
    )
    {
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody: Equatable {
    public let message: String?
    public let resourceId: String?
    public let resourceType: ResourceType?
}

extension ResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
        case resourceId
        case resourceType
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension ResourcePolicy: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case document
        case resourceArn
        case revision
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let document = document {
            try encodeContainer.encode(document, forKey: .document)
        }
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let revision = revision {
            try encodeContainer.encode(revision, forKey: .revision)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let revisionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .revision)
        revision = revisionDecoded
        let documentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .document)
        document = documentDecoded
    }
}

extension ResourcePolicy: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourcePolicy(document: \(String(describing: document)), resourceArn: \(String(describing: resourceArn)), revision: \(String(describing: revision)))"}
}

/// <p>
///         An AWS CodeArtifact resource policy that contains a resource ARN, document details, and a revision.
///       </p>
public struct ResourcePolicy: Equatable {
    /// <p>
    ///       The resource policy formatted in JSON.
    ///     </p>
    public let document: String?
    /// <p>
    ///         The ARN of the resource associated with the resource policy
    ///       </p>
    public let resourceArn: String?
    /// <p>
    ///         The current revision of the resource policy.
    ///       </p>
    public let revision: String?

    public init (
        document: String? = nil,
        resourceArn: String? = nil,
        revision: String? = nil
    )
    {
        self.document = document
        self.resourceArn = resourceArn
        self.revision = revision
    }
}

public enum ResourceType {
    case asset
    case domain
    case package
    case packageVersion
    case repository
    case sdkUnknown(String)
}

extension ResourceType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ResourceType] {
        return [
            .asset,
            .domain,
            .package,
            .packageVersion,
            .repository,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .asset: return "asset"
        case .domain: return "domain"
        case .package: return "package"
        case .packageVersion: return "package-version"
        case .repository: return "repository"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ResourceType(rawValue: rawValue) ?? ResourceType.sdkUnknown(rawValue)
    }
}

extension ServiceQuotaExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceQuotaExceededException(message: \(String(describing: message)), resourceId: \(String(describing: resourceId)), resourceType: \(String(describing: resourceType)))"}
}

extension ServiceQuotaExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>
///         The operation did not succeed because it would have exceeded a service limit for your account.
///       </p>
public struct ServiceQuotaExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    /// <p>
    ///       The ID of the resource.
    ///     </p>
    public var resourceId: String?
    /// <p>
    ///       The type of AWS resource.
    ///     </p>
    public var resourceType: ResourceType?

    public init (
        message: String? = nil,
        resourceId: String? = nil,
        resourceType: ResourceType? = nil
    )
    {
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ServiceQuotaExceededExceptionBody: Equatable {
    public let message: String?
    public let resourceId: String?
    public let resourceType: ResourceType?
}

extension ServiceQuotaExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
        case resourceId
        case resourceType
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension SuccessfulPackageVersionInfo: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case revision
        case status
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let revision = revision {
            try encodeContainer.encode(revision, forKey: .revision)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let revisionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .revision)
        revision = revisionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(PackageVersionStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension SuccessfulPackageVersionInfo: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SuccessfulPackageVersionInfo(revision: \(String(describing: revision)), status: \(String(describing: status)))"}
}

/// <p>
///       Contains the revision and status of a package version.
///     </p>
public struct SuccessfulPackageVersionInfo: Equatable {
    /// <p>
    ///       The revision of a package version.
    ///     </p>
    public let revision: String?
    /// <p>
    ///       The status of a package version. Valid statuses are:
    ///     </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>Published</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Unfinished</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Unlisted</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Archived</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Disposed</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let status: PackageVersionStatus?

    public init (
        revision: String? = nil,
        status: PackageVersionStatus? = nil
    )
    {
        self.revision = revision
        self.status = status
    }
}

extension Tag: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key
        case value
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Tag: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Tag(key: \(String(describing: key)), value: \(String(describing: value)))"}
}

/// <p>A tag is a key-value pair that can be used to manage, search for, or filter resources in AWS CodeArtifact.</p>
public struct Tag: Equatable {
    /// <p>The tag key.</p>
    public let key: String?
    /// <p>The tag value.</p>
    public let value: String?

    public init (
        key: String? = nil,
        value: String? = nil
    )
    {
        self.key = key
        self.value = value
    }
}

public struct TagResourceInputBodyMiddleware: Middleware {
    public let id: String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

extension TagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceInput(resourceArn: \(String(describing: resourceArn)), tags: \(String(describing: tags)))"}
}

extension TagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let resourceArn = input.operationInput.resourceArn {
            let resourceArnQueryItem = URLQueryItem(name: "resourceArn".urlPercentEncoding(), value: String(resourceArn).urlPercentEncoding())
            input.builder.withQueryItem(resourceArnQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the resource that you want to add or update tags for.</p>
    public let resourceArn: String?
    /// <p>The tags you want to modify or add to the resource.</p>
    public let tags: [Tag]?

    public init (
        resourceArn: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Equatable {
    public let tags: [Tag]?
}

extension TagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Equatable {
}

extension TagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ThrottlingException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ThrottlingException(message: \(String(describing: message)), retryAfterSeconds: \(String(describing: retryAfterSeconds)))"}
}

extension ThrottlingException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.retryAfterSeconds = Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.retryAfterSeconds = nil
        }
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>
///       The operation did not succeed because too many requests are sent to the service.
///     </p>
public struct ThrottlingException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    /// <p>
    ///       The time period, in seconds, to wait before retrying the request.
    ///     </p>
    public var retryAfterSeconds: Int?

    public init (
        message: String? = nil,
        retryAfterSeconds: Int? = nil
    )
    {
        self.message = message
        self.retryAfterSeconds = retryAfterSeconds
    }
}

struct ThrottlingExceptionBody: Equatable {
    public let message: String?
}

extension ThrottlingExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct UntagResourceInputBodyMiddleware: Middleware {
    public let id: String = "UntagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

extension UntagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceInput(resourceArn: \(String(describing: resourceArn)), tagKeys: \(String(describing: tagKeys)))"}
}

extension UntagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case tagKeys
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkeylist0 in tagKeys {
                try tagKeysContainer.encode(tagkeylist0)
            }
        }
    }
}

public struct UntagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let resourceArn = input.operationInput.resourceArn {
            let resourceArnQueryItem = URLQueryItem(name: "resourceArn".urlPercentEncoding(), value: String(resourceArn).urlPercentEncoding())
            input.builder.withQueryItem(resourceArnQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the resource that you want to remove tags from.</p>
    public let resourceArn: String?
    /// <p>The tag key for each tag that you want to remove from the resource.</p>
    public let tagKeys: [String]?

    public init (
        resourceArn: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Equatable {
    public let tagKeys: [String]?
}

extension UntagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tagKeys
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagKeysContainer = try containerValues.decodeIfPresent([String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Equatable {
}

extension UntagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdatePackageVersionsStatusInputBodyMiddleware: Middleware {
    public let id: String = "UpdatePackageVersionsStatusInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdatePackageVersionsStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdatePackageVersionsStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdatePackageVersionsStatusInput>
    public typealias MOutput = OperationOutput<UpdatePackageVersionsStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdatePackageVersionsStatusOutputError>
}

extension UpdatePackageVersionsStatusInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdatePackageVersionsStatusInput(domain: \(String(describing: domain)), domainOwner: \(String(describing: domainOwner)), expectedStatus: \(String(describing: expectedStatus)), format: \(String(describing: format)), namespace: \(String(describing: namespace)), package: \(String(describing: package)), repository: \(String(describing: repository)), targetStatus: \(String(describing: targetStatus)), versionRevisions: \(String(describing: versionRevisions)), versions: \(String(describing: versions)))"}
}

extension UpdatePackageVersionsStatusInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case expectedStatus
        case targetStatus
        case versionRevisions
        case versions
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let expectedStatus = expectedStatus {
            try encodeContainer.encode(expectedStatus.rawValue, forKey: .expectedStatus)
        }
        if let targetStatus = targetStatus {
            try encodeContainer.encode(targetStatus.rawValue, forKey: .targetStatus)
        }
        if let versionRevisions = versionRevisions {
            var versionRevisionsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .versionRevisions)
            for (dictKey0, packageversionrevisionmap0) in versionRevisions {
                try versionRevisionsContainer.encode(packageversionrevisionmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let versions = versions {
            var versionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .versions)
            for packageversionlist0 in versions {
                try versionsContainer.encode(packageversionlist0)
            }
        }
    }
}

public struct UpdatePackageVersionsStatusInputHeadersMiddleware: Middleware {
    public let id: String = "UpdatePackageVersionsStatusInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdatePackageVersionsStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdatePackageVersionsStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdatePackageVersionsStatusInput>
    public typealias MOutput = OperationOutput<UpdatePackageVersionsStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdatePackageVersionsStatusOutputError>
}

public struct UpdatePackageVersionsStatusInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdatePackageVersionsStatusInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdatePackageVersionsStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdatePackageVersionsStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let package = input.operationInput.package {
            let packageQueryItem = URLQueryItem(name: "package".urlPercentEncoding(), value: String(package).urlPercentEncoding())
            input.builder.withQueryItem(packageQueryItem)
        }
        if let domain = input.operationInput.domain {
            let domainQueryItem = URLQueryItem(name: "domain".urlPercentEncoding(), value: String(domain).urlPercentEncoding())
            input.builder.withQueryItem(domainQueryItem)
        }
        if let domainOwner = input.operationInput.domainOwner {
            let domainOwnerQueryItem = URLQueryItem(name: "domain-owner".urlPercentEncoding(), value: String(domainOwner).urlPercentEncoding())
            input.builder.withQueryItem(domainOwnerQueryItem)
        }
        if let format = input.operationInput.format {
            let formatQueryItem = URLQueryItem(name: "format".urlPercentEncoding(), value: String(format.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(formatQueryItem)
        }
        if let namespace = input.operationInput.namespace {
            let namespaceQueryItem = URLQueryItem(name: "namespace".urlPercentEncoding(), value: String(namespace).urlPercentEncoding())
            input.builder.withQueryItem(namespaceQueryItem)
        }
        if let repository = input.operationInput.repository {
            let repositoryQueryItem = URLQueryItem(name: "repository".urlPercentEncoding(), value: String(repository).urlPercentEncoding())
            input.builder.withQueryItem(repositoryQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdatePackageVersionsStatusInput>
    public typealias MOutput = OperationOutput<UpdatePackageVersionsStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdatePackageVersionsStatusOutputError>
}

public struct UpdatePackageVersionsStatusInput: Equatable {
    /// <p>
    ///       The name of the domain that contains the repository that contains the package versions with a status to be updated.
    ///     </p>
    public let domain: String?
    /// <p>
    ///         The 12-digit account number of the AWS account that owns the domain. It does not include
    ///         dashes or spaces.
    ///       </p>
    public let domainOwner: String?
    /// <p> The package version’s expected status before it is updated. If
    ///         <code>expectedStatus</code> is provided, the package version's status is updated only if its
    ///       status at the time <code>UpdatePackageVersionsStatus</code> is called matches
    ///         <code>expectedStatus</code>. </p>
    public let expectedStatus: PackageVersionStatus?
    /// <p>
    ///       A format that specifies the type of the package with the statuses to update. The valid values are:
    ///     </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>npm</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>pypi</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>maven</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let format: PackageFormat?
    /// <p>
    ///       The namespace of the package. The package component that specifies its
    ///       namespace depends on its type. For example:
    ///     </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///           The namespace of a Maven package is its <code>groupId</code>.
    ///         </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///           The namespace of an npm package is its <code>scope</code>.
    ///         </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///           A Python package does not contain a corresponding component, so
    ///           Python packages do not have a namespace.
    ///         </p>
    ///             </li>
    ///          </ul>
    public let namespace: String?
    /// <p>
    ///       The name of the package with the version statuses to update.
    ///     </p>
    public let package: String?
    /// <p>
    ///       The repository that contains the package versions with the status you want to update.
    ///     </p>
    public let repository: String?
    /// <p>
    ///       The status you want to change the package version status to.
    ///     </p>
    public let targetStatus: PackageVersionStatus?
    /// <p> A map of package versions and package version revisions. The map <code>key</code> is the
    ///       package version (for example, <code>3.5.2</code>), and the map <code>value</code> is the
    ///       package version revision. </p>
    public let versionRevisions: [String:String]?
    /// <p>
    ///       An array of strings that specify the versions of the package with the statuses to update.
    ///     </p>
    public let versions: [String]?

    public init (
        domain: String? = nil,
        domainOwner: String? = nil,
        expectedStatus: PackageVersionStatus? = nil,
        format: PackageFormat? = nil,
        namespace: String? = nil,
        package: String? = nil,
        repository: String? = nil,
        targetStatus: PackageVersionStatus? = nil,
        versionRevisions: [String:String]? = nil,
        versions: [String]? = nil
    )
    {
        self.domain = domain
        self.domainOwner = domainOwner
        self.expectedStatus = expectedStatus
        self.format = format
        self.namespace = namespace
        self.package = package
        self.repository = repository
        self.targetStatus = targetStatus
        self.versionRevisions = versionRevisions
        self.versions = versions
    }
}

struct UpdatePackageVersionsStatusInputBody: Equatable {
    public let versions: [String]?
    public let versionRevisions: [String:String]?
    public let expectedStatus: PackageVersionStatus?
    public let targetStatus: PackageVersionStatus?
}

extension UpdatePackageVersionsStatusInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case expectedStatus
        case targetStatus
        case versionRevisions
        case versions
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .versions)
        var versionsDecoded0:[String]? = nil
        if let versionsContainer = versionsContainer {
            versionsDecoded0 = [String]()
            for string0 in versionsContainer {
                if let string0 = string0 {
                    versionsDecoded0?.append(string0)
                }
            }
        }
        versions = versionsDecoded0
        let versionRevisionsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .versionRevisions)
        var versionRevisionsDecoded0: [String:String]? = nil
        if let versionRevisionsContainer = versionRevisionsContainer {
            versionRevisionsDecoded0 = [String:String]()
            for (key0, packageversionrevision0) in versionRevisionsContainer {
                if let packageversionrevision0 = packageversionrevision0 {
                    versionRevisionsDecoded0?[key0] = packageversionrevision0
                }
            }
        }
        versionRevisions = versionRevisionsDecoded0
        let expectedStatusDecoded = try containerValues.decodeIfPresent(PackageVersionStatus.self, forKey: .expectedStatus)
        expectedStatus = expectedStatusDecoded
        let targetStatusDecoded = try containerValues.decodeIfPresent(PackageVersionStatus.self, forKey: .targetStatus)
        targetStatus = targetStatusDecoded
    }
}

extension UpdatePackageVersionsStatusOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdatePackageVersionsStatusOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdatePackageVersionsStatusOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdatePackageVersionsStatusOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdatePackageVersionsStatusOutputResponse(failedVersions: \(String(describing: failedVersions)), successfulVersions: \(String(describing: successfulVersions)))"}
}

extension UpdatePackageVersionsStatusOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdatePackageVersionsStatusOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.failedVersions = output.failedVersions
            self.successfulVersions = output.successfulVersions
        } else {
            self.failedVersions = nil
            self.successfulVersions = nil
        }
    }
}

public struct UpdatePackageVersionsStatusOutputResponse: Equatable {
    /// <p> A list of <code>SuccessfulPackageVersionInfo</code> objects, one for each package version
    ///       with a status that successfully updated. </p>
    public let failedVersions: [String:PackageVersionError]?
    /// <p>
    ///       A list of <code>PackageVersionError</code> objects, one for each package version with
    ///       a status that failed to update.
    ///     </p>
    public let successfulVersions: [String:SuccessfulPackageVersionInfo]?

    public init (
        failedVersions: [String:PackageVersionError]? = nil,
        successfulVersions: [String:SuccessfulPackageVersionInfo]? = nil
    )
    {
        self.failedVersions = failedVersions
        self.successfulVersions = successfulVersions
    }
}

struct UpdatePackageVersionsStatusOutputResponseBody: Equatable {
    public let successfulVersions: [String:SuccessfulPackageVersionInfo]?
    public let failedVersions: [String:PackageVersionError]?
}

extension UpdatePackageVersionsStatusOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case failedVersions
        case successfulVersions
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let successfulVersionsContainer = try containerValues.decodeIfPresent([String: SuccessfulPackageVersionInfo?].self, forKey: .successfulVersions)
        var successfulVersionsDecoded0: [String:SuccessfulPackageVersionInfo]? = nil
        if let successfulVersionsContainer = successfulVersionsContainer {
            successfulVersionsDecoded0 = [String:SuccessfulPackageVersionInfo]()
            for (key0, successfulpackageversioninfo0) in successfulVersionsContainer {
                if let successfulpackageversioninfo0 = successfulpackageversioninfo0 {
                    successfulVersionsDecoded0?[key0] = successfulpackageversioninfo0
                }
            }
        }
        successfulVersions = successfulVersionsDecoded0
        let failedVersionsContainer = try containerValues.decodeIfPresent([String: PackageVersionError?].self, forKey: .failedVersions)
        var failedVersionsDecoded0: [String:PackageVersionError]? = nil
        if let failedVersionsContainer = failedVersionsContainer {
            failedVersionsDecoded0 = [String:PackageVersionError]()
            for (key0, packageversionerror0) in failedVersionsContainer {
                if let packageversionerror0 = packageversionerror0 {
                    failedVersionsDecoded0?[key0] = packageversionerror0
                }
            }
        }
        failedVersions = failedVersionsDecoded0
    }
}

public struct UpdateRepositoryInputBodyMiddleware: Middleware {
    public let id: String = "UpdateRepositoryInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateRepositoryInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateRepositoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateRepositoryInput>
    public typealias MOutput = OperationOutput<UpdateRepositoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateRepositoryOutputError>
}

extension UpdateRepositoryInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateRepositoryInput(description: \(String(describing: description)), domain: \(String(describing: domain)), domainOwner: \(String(describing: domainOwner)), repository: \(String(describing: repository)), upstreams: \(String(describing: upstreams)))"}
}

extension UpdateRepositoryInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description
        case upstreams
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let upstreams = upstreams {
            var upstreamsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .upstreams)
            for upstreamrepositorylist0 in upstreams {
                try upstreamsContainer.encode(upstreamrepositorylist0)
            }
        }
    }
}

public struct UpdateRepositoryInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateRepositoryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateRepositoryInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateRepositoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateRepositoryInput>
    public typealias MOutput = OperationOutput<UpdateRepositoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateRepositoryOutputError>
}

public struct UpdateRepositoryInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateRepositoryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateRepositoryInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateRepositoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let domain = input.operationInput.domain {
            let domainQueryItem = URLQueryItem(name: "domain".urlPercentEncoding(), value: String(domain).urlPercentEncoding())
            input.builder.withQueryItem(domainQueryItem)
        }
        if let domainOwner = input.operationInput.domainOwner {
            let domainOwnerQueryItem = URLQueryItem(name: "domain-owner".urlPercentEncoding(), value: String(domainOwner).urlPercentEncoding())
            input.builder.withQueryItem(domainOwnerQueryItem)
        }
        if let repository = input.operationInput.repository {
            let repositoryQueryItem = URLQueryItem(name: "repository".urlPercentEncoding(), value: String(repository).urlPercentEncoding())
            input.builder.withQueryItem(repositoryQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateRepositoryInput>
    public typealias MOutput = OperationOutput<UpdateRepositoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateRepositoryOutputError>
}

public struct UpdateRepositoryInput: Equatable {
    /// <p>
    ///          An updated repository description.
    ///        </p>
    public let description: String?
    /// <p>
    ///          The name of the domain associated with the repository to update.
    ///        </p>
    public let domain: String?
    /// <p>
    ///         The 12-digit account number of the AWS account that owns the domain. It does not include
    ///         dashes or spaces.
    ///       </p>
    public let domainOwner: String?
    /// <p>
    ///          The name of the repository to update.
    ///        </p>
    public let repository: String?
    /// <p> A list of upstream repositories to associate with the repository. The order of the upstream repositories
    ///         in the list determines their priority order when AWS CodeArtifact looks for a requested package version. For more
    ///         information, see <a href="https://docs.aws.amazon.com/codeartifact/latest/ug/repos-upstream.html">Working with upstream repositories</a>. </p>
    public let upstreams: [UpstreamRepository]?

    public init (
        description: String? = nil,
        domain: String? = nil,
        domainOwner: String? = nil,
        repository: String? = nil,
        upstreams: [UpstreamRepository]? = nil
    )
    {
        self.description = description
        self.domain = domain
        self.domainOwner = domainOwner
        self.repository = repository
        self.upstreams = upstreams
    }
}

struct UpdateRepositoryInputBody: Equatable {
    public let description: String?
    public let upstreams: [UpstreamRepository]?
}

extension UpdateRepositoryInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description
        case upstreams
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let upstreamsContainer = try containerValues.decodeIfPresent([UpstreamRepository?].self, forKey: .upstreams)
        var upstreamsDecoded0:[UpstreamRepository]? = nil
        if let upstreamsContainer = upstreamsContainer {
            upstreamsDecoded0 = [UpstreamRepository]()
            for structure0 in upstreamsContainer {
                if let structure0 = structure0 {
                    upstreamsDecoded0?.append(structure0)
                }
            }
        }
        upstreams = upstreamsDecoded0
    }
}

extension UpdateRepositoryOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateRepositoryOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateRepositoryOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateRepositoryOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateRepositoryOutputResponse(repository: \(String(describing: repository)))"}
}

extension UpdateRepositoryOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateRepositoryOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.repository = output.repository
        } else {
            self.repository = nil
        }
    }
}

public struct UpdateRepositoryOutputResponse: Equatable {
    /// <p>
    ///          The updated repository.
    ///        </p>
    public let repository: RepositoryDescription?

    public init (
        repository: RepositoryDescription? = nil
    )
    {
        self.repository = repository
    }
}

struct UpdateRepositoryOutputResponseBody: Equatable {
    public let repository: RepositoryDescription?
}

extension UpdateRepositoryOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case repository
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryDecoded = try containerValues.decodeIfPresent(RepositoryDescription.self, forKey: .repository)
        repository = repositoryDecoded
    }
}

extension UpstreamRepository: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case repositoryName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
    }
}

extension UpstreamRepository: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpstreamRepository(repositoryName: \(String(describing: repositoryName)))"}
}

/// <p>
///        Information about an upstream repository. A list of <code>UpstreamRepository</code> objects is an input parameter to
///        <a href="https://docs.aws.amazon.com/codeartifact/latest/APIReference/API_CreateRepository.html">CreateRepository</a>
///        and <a href="https://docs.aws.amazon.com/codeartifact/latest/APIReference/API_UpdateRepository.html">UpdateRepository</a>.
///      </p>
public struct UpstreamRepository: Equatable {
    /// <p> The name of an upstream repository. </p>
    public let repositoryName: String?

    public init (
        repositoryName: String? = nil
    )
    {
        self.repositoryName = repositoryName
    }
}

extension UpstreamRepositoryInfo: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case repositoryName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
    }
}

extension UpstreamRepositoryInfo: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpstreamRepositoryInfo(repositoryName: \(String(describing: repositoryName)))"}
}

/// <p>
///         Information about an upstream repository.
///       </p>
public struct UpstreamRepositoryInfo: Equatable {
    /// <p> The name of an upstream repository. </p>
    public let repositoryName: String?

    public init (
        repositoryName: String? = nil
    )
    {
        self.repositoryName = repositoryName
    }
}

extension ValidationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ValidationException(message: \(String(describing: message)), reason: \(String(describing: reason)))"}
}

extension ValidationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.reason = output.reason
        } else {
            self.message = nil
            self.reason = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>
///       The operation did not succeed because a parameter in the request was sent with an invalid value.
///     </p>
public struct ValidationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    /// <p>
    ///
    ///     </p>
    public var reason: ValidationExceptionReason?

    public init (
        message: String? = nil,
        reason: ValidationExceptionReason? = nil
    )
    {
        self.message = message
        self.reason = reason
    }
}

struct ValidationExceptionBody: Equatable {
    public let message: String?
    public let reason: ValidationExceptionReason?
}

extension ValidationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
        case reason
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(ValidationExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
    }
}

public enum ValidationExceptionReason {
    case cannotParse
    case encryptionKeyError
    case fieldValidationFailed
    case other
    case unknownOperation
    case sdkUnknown(String)
}

extension ValidationExceptionReason : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ValidationExceptionReason] {
        return [
            .cannotParse,
            .encryptionKeyError,
            .fieldValidationFailed,
            .other,
            .unknownOperation,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .cannotParse: return "CANNOT_PARSE"
        case .encryptionKeyError: return "ENCRYPTION_KEY_ERROR"
        case .fieldValidationFailed: return "FIELD_VALIDATION_FAILED"
        case .other: return "OTHER"
        case .unknownOperation: return "UNKNOWN_OPERATION"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ValidationExceptionReason(rawValue: rawValue) ?? ValidationExceptionReason.sdkUnknown(rawValue)
    }
}
