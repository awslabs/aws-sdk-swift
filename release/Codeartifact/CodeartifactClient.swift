// Code generated by smithy-swift-codegen. DO NOT EDIT!

import AWSClientRuntime
import ClientRuntime
import Foundation

public class CodeartifactClient {
    let client: SdkHttpClient
    let config: CodeartifactClientConfiguration
    let serviceName = "codeartifact"
    let encoder: RequestEncoder
    let decoder: ResponseDecoder

    public init(config: CodeartifactClientConfiguration) {
        client = SdkHttpClient(engine: config.httpClientEngine, config: config.httpClientConfiguration)
        let encoder = JSONEncoder()
        encoder.dateEncodingStrategy = .secondsSince1970
        self.encoder = config.encoder ?? encoder
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .secondsSince1970
        self.decoder = config.decoder ?? decoder
        self.config = config
    }

    public class CodeartifactClientConfiguration: ClientRuntime.Configuration, AWSClientConfiguration {

        public var region: String
        public var credentialsProvider: AWSCredentialsProvider
        public var signingRegion: String
        public var endpointResolver: EndpointResolver

        public init (
            credentialsProvider: AWSCredentialsProvider,
            endpointResolver: EndpointResolver,
            region: String,
            signingRegion: String
        ) throws
        {
            self.credentialsProvider = credentialsProvider
            self.endpointResolver = endpointResolver
            self.region = region
            self.signingRegion = signingRegion
        }

        public convenience init(credentialsProvider: AWSCredentialsProvider) throws {
            let region = "us-east-1"
            let signingRegion = "us-east-1"
            let endpointResolver = DefaultEndpointResolver()
            try self.init(
                credentialsProvider: credentialsProvider,
                endpointResolver: endpointResolver,
                region: region,
                signingRegion: signingRegion
            )
        }

        public static func `default`() throws -> CodeartifactClientConfiguration {
            let awsCredsProvider = try AWSCredentialsProvider.fromEnv()
            return try CodeartifactClientConfiguration(credentialsProvider: awsCredsProvider)
        }
    }
}

extension CodeartifactClient: CodeartifactClientProtocol {
    /// <p>Adds an existing external connection to a repository. One external connection is allowed
    ///       per repository.</p>
    ///          <note>
    ///             <p>A repository can have one or more upstream repositories, or an external connection.</p>
    ///          </note>
    public func associateExternalConnection(input: AssociateExternalConnectionInput, completion: @escaping (SdkResult<AssociateExternalConnectionOutput, AssociateExternalConnectionOutputError>) -> Void)
    {
        let urlPath = "/v1/repository/external-connection"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "associateExternalConnection")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "codeartifact.\(config.region).amazonaws.com")
                      .withSigningName(value: "codeartifact")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<AssociateExternalConnectionInput, AssociateExternalConnectionOutput, AssociateExternalConnectionOutputError>(id: "associateExternalConnection")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: AssociateExternalConnectionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: AssociateExternalConnectionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<AssociateExternalConnectionInput, AssociateExternalConnectionOutput, AssociateExternalConnectionOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>
    ///         Copies package versions from one repository to another repository in the same domain.
    ///       </p>
    ///          <note>
    ///             <p>
    ///         You must specify <code>versions</code> or <code>versionRevisions</code>. You cannot specify both.
    ///       </p>
    ///          </note>
    public func copyPackageVersions(input: CopyPackageVersionsInput, completion: @escaping (SdkResult<CopyPackageVersionsOutput, CopyPackageVersionsOutputError>) -> Void)
    {
        let urlPath = "/v1/package/versions/copy"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "copyPackageVersions")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "codeartifact.\(config.region).amazonaws.com")
                      .withSigningName(value: "codeartifact")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CopyPackageVersionsInput, CopyPackageVersionsOutput, CopyPackageVersionsOutputError>(id: "copyPackageVersions")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CopyPackageVersionsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CopyPackageVersionsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CopyPackageVersionsInput, CopyPackageVersionsOutput, CopyPackageVersionsOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CopyPackageVersionsInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>
    ///       Creates a domain. CodeArtifact <i>domains</i> make it easier to manage multiple repositories across an
    ///         organization. You can use a domain to apply permissions across many
    ///         repositories owned by different AWS accounts. An asset is stored only once
    ///         in a domain, even if it's in multiple repositories.
    ///     </p>
    ///
    ///          <p>Although you can have multiple domains, we recommend a single production domain that contains all
    ///         published artifacts so that your development teams can find and share packages. You can use a second
    ///         pre-production domain to test changes to the production domain configuration.
    ///       </p>
    public func createDomain(input: CreateDomainInput, completion: @escaping (SdkResult<CreateDomainOutput, CreateDomainOutputError>) -> Void)
    {
        let urlPath = "/v1/domain"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createDomain")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "codeartifact.\(config.region).amazonaws.com")
                      .withSigningName(value: "codeartifact")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateDomainInput, CreateDomainOutput, CreateDomainOutputError>(id: "createDomain")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateDomainInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateDomainInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateDomainInput, CreateDomainOutput, CreateDomainOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateDomainInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>
    ///         Creates a repository.
    ///       </p>
    public func createRepository(input: CreateRepositoryInput, completion: @escaping (SdkResult<CreateRepositoryOutput, CreateRepositoryOutputError>) -> Void)
    {
        let urlPath = "/v1/repository"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createRepository")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "codeartifact.\(config.region).amazonaws.com")
                      .withSigningName(value: "codeartifact")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateRepositoryInput, CreateRepositoryOutput, CreateRepositoryOutputError>(id: "createRepository")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateRepositoryInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateRepositoryInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateRepositoryInput, CreateRepositoryOutput, CreateRepositoryOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateRepositoryInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>
    ///          Deletes a domain. You cannot delete a domain that contains repositories. If you want to delete a domain
    ///          with repositories, first delete its repositories.
    ///       </p>
    public func deleteDomain(input: DeleteDomainInput, completion: @escaping (SdkResult<DeleteDomainOutput, DeleteDomainOutputError>) -> Void)
    {
        let urlPath = "/v1/domain"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteDomain")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "codeartifact.\(config.region).amazonaws.com")
                      .withSigningName(value: "codeartifact")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteDomainInput, DeleteDomainOutput, DeleteDomainOutputError>(id: "deleteDomain")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteDomainInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteDomainInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteDomainInput, DeleteDomainOutput, DeleteDomainOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>
    ///         Deletes the resource policy set on a domain.
    ///       </p>
    public func deleteDomainPermissionsPolicy(input: DeleteDomainPermissionsPolicyInput, completion: @escaping (SdkResult<DeleteDomainPermissionsPolicyOutput, DeleteDomainPermissionsPolicyOutputError>) -> Void)
    {
        let urlPath = "/v1/domain/permissions/policy"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteDomainPermissionsPolicy")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "codeartifact.\(config.region).amazonaws.com")
                      .withSigningName(value: "codeartifact")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteDomainPermissionsPolicyInput, DeleteDomainPermissionsPolicyOutput, DeleteDomainPermissionsPolicyOutputError>(id: "deleteDomainPermissionsPolicy")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteDomainPermissionsPolicyInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteDomainPermissionsPolicyInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteDomainPermissionsPolicyInput, DeleteDomainPermissionsPolicyOutput, DeleteDomainPermissionsPolicyOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p> Deletes one or more versions of a package. A deleted package version cannot be restored
    ///       in your repository. If you want to remove a package version from your repository and be able
    ///       to restore it later, set its status to <code>Archived</code>. Archived packages cannot be
    ///       downloaded from a repository and don't show up with list package APIs (for example,
    ///           <a href="https://docs.aws.amazon.com/codeartifact/latest/APIReference/API_ListPackageVersions.html">ListackageVersions</a>), but you can restore them using <a href="https://docs.aws.amazon.com/codeartifact/latest/APIReference/API_UpdatePackageVersionsStatus.html">UpdatePackageVersionsStatus</a>. </p>
    public func deletePackageVersions(input: DeletePackageVersionsInput, completion: @escaping (SdkResult<DeletePackageVersionsOutput, DeletePackageVersionsOutputError>) -> Void)
    {
        let urlPath = "/v1/package/versions/delete"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deletePackageVersions")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "codeartifact.\(config.region).amazonaws.com")
                      .withSigningName(value: "codeartifact")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeletePackageVersionsInput, DeletePackageVersionsOutput, DeletePackageVersionsOutputError>(id: "deletePackageVersions")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeletePackageVersionsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeletePackageVersionsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeletePackageVersionsInput, DeletePackageVersionsOutput, DeletePackageVersionsOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: DeletePackageVersionsInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>
    ///          Deletes a repository.
    ///        </p>
    public func deleteRepository(input: DeleteRepositoryInput, completion: @escaping (SdkResult<DeleteRepositoryOutput, DeleteRepositoryOutputError>) -> Void)
    {
        let urlPath = "/v1/repository"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteRepository")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "codeartifact.\(config.region).amazonaws.com")
                      .withSigningName(value: "codeartifact")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteRepositoryInput, DeleteRepositoryOutput, DeleteRepositoryOutputError>(id: "deleteRepository")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteRepositoryInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteRepositoryInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteRepositoryInput, DeleteRepositoryOutput, DeleteRepositoryOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>
    ///         Deletes the resource policy that is set on a repository. After a resource policy is deleted, the
    ///         permissions allowed and denied by the deleted policy are removed. The effect of deleting a resource policy might not be immediate.
    ///       </p>
    ///          <important>
    ///             <p>
    ///          Use <code>DeleteRepositoryPermissionsPolicy</code> with caution. After a policy is deleted, AWS users, roles, and accounts lose permissions to perform
    ///          the repository actions granted by the deleted policy.
    ///        </p>
    ///          </important>
    public func deleteRepositoryPermissionsPolicy(input: DeleteRepositoryPermissionsPolicyInput, completion: @escaping (SdkResult<DeleteRepositoryPermissionsPolicyOutput, DeleteRepositoryPermissionsPolicyOutputError>) -> Void)
    {
        let urlPath = "/v1/repository/permissions/policies"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteRepositoryPermissionsPolicy")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "codeartifact.\(config.region).amazonaws.com")
                      .withSigningName(value: "codeartifact")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteRepositoryPermissionsPolicyInput, DeleteRepositoryPermissionsPolicyOutput, DeleteRepositoryPermissionsPolicyOutputError>(id: "deleteRepositoryPermissionsPolicy")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteRepositoryPermissionsPolicyInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteRepositoryPermissionsPolicyInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteRepositoryPermissionsPolicyInput, DeleteRepositoryPermissionsPolicyOutput, DeleteRepositoryPermissionsPolicyOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>
    ///          Returns a
    ///       <a href="https://docs.aws.amazon.com/codeartifact/latest/APIReference/API_DomainDescription.html">DomainDescription</a>
    ///       object that contains information about the requested domain.
    ///      </p>
    public func describeDomain(input: DescribeDomainInput, completion: @escaping (SdkResult<DescribeDomainOutput, DescribeDomainOutputError>) -> Void)
    {
        let urlPath = "/v1/domain"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeDomain")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "codeartifact.\(config.region).amazonaws.com")
                      .withSigningName(value: "codeartifact")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeDomainInput, DescribeDomainOutput, DescribeDomainOutputError>(id: "describeDomain")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeDomainInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeDomainInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeDomainInput, DescribeDomainOutput, DescribeDomainOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>
    ///        Returns a
    ///        <a href="https://docs.aws.amazon.com/codeartifact/latest/APIReference/API_PackageVersionDescription.html">PackageVersionDescription</a>
    ///        object that contains information about the requested package version.
    ///      </p>
    public func describePackageVersion(input: DescribePackageVersionInput, completion: @escaping (SdkResult<DescribePackageVersionOutput, DescribePackageVersionOutputError>) -> Void)
    {
        let urlPath = "/v1/package/version"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describePackageVersion")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "codeartifact.\(config.region).amazonaws.com")
                      .withSigningName(value: "codeartifact")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribePackageVersionInput, DescribePackageVersionOutput, DescribePackageVersionOutputError>(id: "describePackageVersion")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribePackageVersionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribePackageVersionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribePackageVersionInput, DescribePackageVersionOutput, DescribePackageVersionOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>
    ///          Returns a <code>RepositoryDescription</code> object that contains detailed information
    ///         about the requested repository.
    ///        </p>
    public func describeRepository(input: DescribeRepositoryInput, completion: @escaping (SdkResult<DescribeRepositoryOutput, DescribeRepositoryOutputError>) -> Void)
    {
        let urlPath = "/v1/repository"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeRepository")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "codeartifact.\(config.region).amazonaws.com")
                      .withSigningName(value: "codeartifact")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeRepositoryInput, DescribeRepositoryOutput, DescribeRepositoryOutputError>(id: "describeRepository")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeRepositoryInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeRepositoryInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeRepositoryInput, DescribeRepositoryOutput, DescribeRepositoryOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>
    ///       Removes an existing external connection from a repository.
    ///     </p>
    public func disassociateExternalConnection(input: DisassociateExternalConnectionInput, completion: @escaping (SdkResult<DisassociateExternalConnectionOutput, DisassociateExternalConnectionOutputError>) -> Void)
    {
        let urlPath = "/v1/repository/external-connection"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "disassociateExternalConnection")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "codeartifact.\(config.region).amazonaws.com")
                      .withSigningName(value: "codeartifact")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DisassociateExternalConnectionInput, DisassociateExternalConnectionOutput, DisassociateExternalConnectionOutputError>(id: "disassociateExternalConnection")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DisassociateExternalConnectionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DisassociateExternalConnectionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DisassociateExternalConnectionInput, DisassociateExternalConnectionOutput, DisassociateExternalConnectionOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>
    ///       Deletes the assets in package versions and sets the package versions' status to <code>Disposed</code>.
    ///       A disposed package version cannot be restored in your repository because its assets are deleted.
    ///     </p>
    ///
    ///          <p>
    ///       To view all disposed package versions in a repository, use <a href="https://docs.aws.amazon.com/codeartifact/latest/APIReference/API_ListPackageVersions.html">ListPackageVersions</a> and set the
    ///       <a href="https://docs.aws.amazon.com/codeartifact/latest/APIReference/API_ListPackageVersions.html#API_ListPackageVersions_RequestSyntax">status</a> parameter
    ///       to <code>Disposed</code>.
    ///     </p>
    ///
    ///          <p>
    ///       To view information about a disposed package version, use <a href="https://docs.aws.amazon.com/codeartifact/latest/APIReference/API_DescribePackageVersion.html">DescribePackageVersion</a>.
    ///     </p>
    public func disposePackageVersions(input: DisposePackageVersionsInput, completion: @escaping (SdkResult<DisposePackageVersionsOutput, DisposePackageVersionsOutputError>) -> Void)
    {
        let urlPath = "/v1/package/versions/dispose"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "disposePackageVersions")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "codeartifact.\(config.region).amazonaws.com")
                      .withSigningName(value: "codeartifact")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DisposePackageVersionsInput, DisposePackageVersionsOutput, DisposePackageVersionsOutputError>(id: "disposePackageVersions")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DisposePackageVersionsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DisposePackageVersionsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DisposePackageVersionsInput, DisposePackageVersionsOutput, DisposePackageVersionsOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: DisposePackageVersionsInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>
    ///         Generates a temporary authorization token for accessing repositories in the domain.
    ///         This API requires the <code>codeartifact:GetAuthorizationToken</code> and <code>sts:GetServiceBearerToken</code> permissions.
    ///         For more information about authorization tokens, see
    ///         <a href="https://docs.aws.amazon.com/codeartifact/latest/ug/tokens-authentication.html">AWS CodeArtifact authentication and tokens</a>.
    ///       </p>
    ///          <note>
    ///             <p>CodeArtifact authorization tokens are valid for a period of 12 hours when created with the <code>login</code> command.
    ///          You can call <code>login</code> periodically to refresh the token. When
    ///          you create an authorization token with the <code>GetAuthorizationToken</code> API, you can set a custom authorization period,
    ///          up to a maximum of 12 hours, with the <code>durationSeconds</code> parameter.</p>
    ///             <p>The authorization period begins after <code>login</code>
    ///          or <code>GetAuthorizationToken</code> is called. If <code>login</code> or <code>GetAuthorizationToken</code> is called while
    ///          assuming a role, the token lifetime is independent of the maximum session duration
    ///          of the role. For example, if you call <code>sts assume-role</code> and specify a session duration of 15 minutes, then
    ///          generate a CodeArtifact authorization token, the token will be valid for the full authorization period
    ///          even though this is longer than the 15-minute session duration.</p>
    ///             <p>See
    ///          <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_use.html">Using IAM Roles</a>
    ///          for more information on controlling session duration. </p>
    ///          </note>
    public func getAuthorizationToken(input: GetAuthorizationTokenInput, completion: @escaping (SdkResult<GetAuthorizationTokenOutput, GetAuthorizationTokenOutputError>) -> Void)
    {
        let urlPath = "/v1/authorization-token"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getAuthorizationToken")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "codeartifact.\(config.region).amazonaws.com")
                      .withSigningName(value: "codeartifact")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetAuthorizationTokenInput, GetAuthorizationTokenOutput, GetAuthorizationTokenOutputError>(id: "getAuthorizationToken")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetAuthorizationTokenInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetAuthorizationTokenInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetAuthorizationTokenInput, GetAuthorizationTokenOutput, GetAuthorizationTokenOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>
    ///         Returns the resource policy attached to the specified domain.
    ///       </p>
    ///          <note>
    ///             <p>
    ///          The policy is a resource-based policy, not an identity-based policy. For more information, see
    ///          <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_identity-vs-resource.html">Identity-based policies
    ///            and resource-based policies </a> in the <i>AWS Identity and Access Management User Guide</i>.
    ///        </p>
    ///          </note>
    public func getDomainPermissionsPolicy(input: GetDomainPermissionsPolicyInput, completion: @escaping (SdkResult<GetDomainPermissionsPolicyOutput, GetDomainPermissionsPolicyOutputError>) -> Void)
    {
        let urlPath = "/v1/domain/permissions/policy"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getDomainPermissionsPolicy")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "codeartifact.\(config.region).amazonaws.com")
                      .withSigningName(value: "codeartifact")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetDomainPermissionsPolicyInput, GetDomainPermissionsPolicyOutput, GetDomainPermissionsPolicyOutputError>(id: "getDomainPermissionsPolicy")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetDomainPermissionsPolicyInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetDomainPermissionsPolicyInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetDomainPermissionsPolicyInput, GetDomainPermissionsPolicyOutput, GetDomainPermissionsPolicyOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>
    ///       Returns an asset (or file) that is in a package. For example, for a Maven package version, use
    ///       <code>GetPackageVersionAsset</code> to download a <code>JAR</code> file, a <code>POM</code> file,
    ///       or any other assets in the package version.
    ///     </p>
    public func getPackageVersionAsset(input: GetPackageVersionAssetInput, streamSink: StreamSink, completion: @escaping (SdkResult<GetPackageVersionAssetOutput, GetPackageVersionAssetOutputError>) -> Void)
    {
        let urlPath = "/v1/package/version/asset"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getPackageVersionAsset")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "codeartifact.\(config.region).amazonaws.com")
                      .withSigningName(value: "codeartifact")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetPackageVersionAssetInput, GetPackageVersionAssetOutput, GetPackageVersionAssetOutputError>(id: "getPackageVersionAsset")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetPackageVersionAssetInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetPackageVersionAssetInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetPackageVersionAssetInput, GetPackageVersionAssetOutput, GetPackageVersionAssetOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>
    ///          Gets the readme file or descriptive text for a package version. For packages that do not contain a readme file, CodeArtifact
    ///          extracts a description from a metadata file. For example, from the <code><description></code> element in the
    ///         <code>pom.xml</code> file of a Maven package.
    ///       </p>
    ///          <p>
    ///        The returned text might contain formatting. For example, it might contain formatting for Markdown or reStructuredText.
    ///      </p>
    public func getPackageVersionReadme(input: GetPackageVersionReadmeInput, completion: @escaping (SdkResult<GetPackageVersionReadmeOutput, GetPackageVersionReadmeOutputError>) -> Void)
    {
        let urlPath = "/v1/package/version/readme"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getPackageVersionReadme")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "codeartifact.\(config.region).amazonaws.com")
                      .withSigningName(value: "codeartifact")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetPackageVersionReadmeInput, GetPackageVersionReadmeOutput, GetPackageVersionReadmeOutputError>(id: "getPackageVersionReadme")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetPackageVersionReadmeInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetPackageVersionReadmeInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetPackageVersionReadmeInput, GetPackageVersionReadmeOutput, GetPackageVersionReadmeOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>
    ///       Returns the endpoint of a repository for a specific package format. A repository has one endpoint for each
    ///       package format:
    ///     </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>npm</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>pypi</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>maven</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public func getRepositoryEndpoint(input: GetRepositoryEndpointInput, completion: @escaping (SdkResult<GetRepositoryEndpointOutput, GetRepositoryEndpointOutputError>) -> Void)
    {
        let urlPath = "/v1/repository/endpoint"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getRepositoryEndpoint")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "codeartifact.\(config.region).amazonaws.com")
                      .withSigningName(value: "codeartifact")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetRepositoryEndpointInput, GetRepositoryEndpointOutput, GetRepositoryEndpointOutputError>(id: "getRepositoryEndpoint")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetRepositoryEndpointInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetRepositoryEndpointInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetRepositoryEndpointInput, GetRepositoryEndpointOutput, GetRepositoryEndpointOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>
    ///         Returns the resource policy that is set on a repository.
    ///       </p>
    public func getRepositoryPermissionsPolicy(input: GetRepositoryPermissionsPolicyInput, completion: @escaping (SdkResult<GetRepositoryPermissionsPolicyOutput, GetRepositoryPermissionsPolicyOutputError>) -> Void)
    {
        let urlPath = "/v1/repository/permissions/policy"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getRepositoryPermissionsPolicy")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "codeartifact.\(config.region).amazonaws.com")
                      .withSigningName(value: "codeartifact")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetRepositoryPermissionsPolicyInput, GetRepositoryPermissionsPolicyOutput, GetRepositoryPermissionsPolicyOutputError>(id: "getRepositoryPermissionsPolicy")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetRepositoryPermissionsPolicyInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetRepositoryPermissionsPolicyInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetRepositoryPermissionsPolicyInput, GetRepositoryPermissionsPolicyOutput, GetRepositoryPermissionsPolicyOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p> Returns a list of <a href="https://docs.aws.amazon.com/codeartifact/latest/APIReference/API_PackageVersionDescription.html">DomainSummary</a> objects for all domains owned by the AWS account that makes
    ///       this call. Each returned <code>DomainSummary</code> object contains information about a
    ///       domain. </p>
    public func listDomains(input: ListDomainsInput, completion: @escaping (SdkResult<ListDomainsOutput, ListDomainsOutputError>) -> Void)
    {
        let urlPath = "/v1/domains"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listDomains")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "codeartifact.\(config.region).amazonaws.com")
                      .withSigningName(value: "codeartifact")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListDomainsInput, ListDomainsOutput, ListDomainsOutputError>(id: "listDomains")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListDomainsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListDomainsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListDomainsInput, ListDomainsOutput, ListDomainsOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: ListDomainsInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>
    ///        Returns a list of
    ///        <a href="https://docs.aws.amazon.com/codeartifact/latest/APIReference/API_AssetSummary.html">AssetSummary</a>
    ///        objects for assets in a package version.
    ///      </p>
    public func listPackageVersionAssets(input: ListPackageVersionAssetsInput, completion: @escaping (SdkResult<ListPackageVersionAssetsOutput, ListPackageVersionAssetsOutputError>) -> Void)
    {
        let urlPath = "/v1/package/version/assets"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listPackageVersionAssets")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "codeartifact.\(config.region).amazonaws.com")
                      .withSigningName(value: "codeartifact")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListPackageVersionAssetsInput, ListPackageVersionAssetsOutput, ListPackageVersionAssetsOutputError>(id: "listPackageVersionAssets")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListPackageVersionAssetsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListPackageVersionAssetsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListPackageVersionAssetsInput, ListPackageVersionAssetsOutput, ListPackageVersionAssetsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>
    ///          Returns the direct dependencies for a package version. The dependencies are returned as
    ///         <a href="https://docs.aws.amazon.com/codeartifact/latest/APIReference/API_PackageDependency.html">PackageDependency</a>
    ///           objects. CodeArtifact extracts the dependencies for a package version from the metadata file for the package
    ///           format (for example, the <code>package.json</code> file for npm packages and the <code>pom.xml</code> file
    ///         for Maven). Any package version dependencies that are not listed in the configuration file are not returned.
    ///       </p>
    public func listPackageVersionDependencies(input: ListPackageVersionDependenciesInput, completion: @escaping (SdkResult<ListPackageVersionDependenciesOutput, ListPackageVersionDependenciesOutputError>) -> Void)
    {
        let urlPath = "/v1/package/version/dependencies"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listPackageVersionDependencies")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "codeartifact.\(config.region).amazonaws.com")
                      .withSigningName(value: "codeartifact")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListPackageVersionDependenciesInput, ListPackageVersionDependenciesOutput, ListPackageVersionDependenciesOutputError>(id: "listPackageVersionDependencies")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListPackageVersionDependenciesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListPackageVersionDependenciesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListPackageVersionDependenciesInput, ListPackageVersionDependenciesOutput, ListPackageVersionDependenciesOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>
    ///         Returns a list of
    ///         <a href="https://docs.aws.amazon.com/codeartifact/latest/APIReference/API_PackageVersionSummary.html">PackageVersionSummary</a>
    ///         objects for package versions in a repository that match the request parameters.
    ///       </p>
    public func listPackageVersions(input: ListPackageVersionsInput, completion: @escaping (SdkResult<ListPackageVersionsOutput, ListPackageVersionsOutputError>) -> Void)
    {
        let urlPath = "/v1/package/versions"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listPackageVersions")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "codeartifact.\(config.region).amazonaws.com")
                      .withSigningName(value: "codeartifact")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListPackageVersionsInput, ListPackageVersionsOutput, ListPackageVersionsOutputError>(id: "listPackageVersions")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListPackageVersionsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListPackageVersionsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListPackageVersionsInput, ListPackageVersionsOutput, ListPackageVersionsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>
    ///         Returns a list of
    ///         <a href="https://docs.aws.amazon.com/codeartifact/latest/APIReference/API_PackageSummary.html">PackageSummary</a>
    ///         objects for packages in a repository that match the request parameters.
    ///       </p>
    public func listPackages(input: ListPackagesInput, completion: @escaping (SdkResult<ListPackagesOutput, ListPackagesOutputError>) -> Void)
    {
        let urlPath = "/v1/packages"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listPackages")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "codeartifact.\(config.region).amazonaws.com")
                      .withSigningName(value: "codeartifact")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListPackagesInput, ListPackagesOutput, ListPackagesOutputError>(id: "listPackages")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListPackagesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListPackagesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListPackagesInput, ListPackagesOutput, ListPackagesOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>
    ///        Returns a list of
    ///        <a href="https://docs.aws.amazon.com/codeartifact/latest/APIReference/API_RepositorySummary.html">RepositorySummary</a>
    ///        objects. Each <code>RepositorySummary</code> contains information about a repository in the specified AWS account and that matches the input
    ///        parameters.
    ///      </p>
    public func listRepositories(input: ListRepositoriesInput, completion: @escaping (SdkResult<ListRepositoriesOutput, ListRepositoriesOutputError>) -> Void)
    {
        let urlPath = "/v1/repositories"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listRepositories")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "codeartifact.\(config.region).amazonaws.com")
                      .withSigningName(value: "codeartifact")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListRepositoriesInput, ListRepositoriesOutput, ListRepositoriesOutputError>(id: "listRepositories")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListRepositoriesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListRepositoriesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListRepositoriesInput, ListRepositoriesOutput, ListRepositoriesOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>
    ///        Returns a list of
    ///        <a href="https://docs.aws.amazon.com/codeartifact/latest/APIReference/API_RepositorySummary.html">RepositorySummary</a>
    ///        objects. Each <code>RepositorySummary</code> contains information about a repository in the specified domain and that matches the input
    ///        parameters.
    ///      </p>
    public func listRepositoriesInDomain(input: ListRepositoriesInDomainInput, completion: @escaping (SdkResult<ListRepositoriesInDomainOutput, ListRepositoriesInDomainOutputError>) -> Void)
    {
        let urlPath = "/v1/domain/repositories"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listRepositoriesInDomain")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "codeartifact.\(config.region).amazonaws.com")
                      .withSigningName(value: "codeartifact")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListRepositoriesInDomainInput, ListRepositoriesInDomainOutput, ListRepositoriesInDomainOutputError>(id: "listRepositoriesInDomain")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListRepositoriesInDomainInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListRepositoriesInDomainInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListRepositoriesInDomainInput, ListRepositoriesInDomainOutput, ListRepositoriesInDomainOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Gets information about AWS tags for a specified Amazon Resource Name (ARN) in AWS CodeArtifact.</p>
    public func listTagsForResource(input: ListTagsForResourceInput, completion: @escaping (SdkResult<ListTagsForResourceOutput, ListTagsForResourceOutputError>) -> Void)
    {
        let urlPath = "/v1/tags"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listTagsForResource")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "codeartifact.\(config.region).amazonaws.com")
                      .withSigningName(value: "codeartifact")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListTagsForResourceInput, ListTagsForResourceOutput, ListTagsForResourceOutputError>(id: "listTagsForResource")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListTagsForResourceInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListTagsForResourceInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListTagsForResourceInput, ListTagsForResourceOutput, ListTagsForResourceOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>
    ///         Sets a resource policy on a domain that specifies permissions to access it.
    ///       </p>
    ///          <p>
    ///        When you call <code>PutDomainPermissionsPolicy</code>, the resource policy on the domain is ignored when evaluting permissions.
    ///        This ensures that the owner of a domain cannot lock themselves out of the domain, which would prevent them from being
    ///        able to update the resource policy.
    ///      </p>
    public func putDomainPermissionsPolicy(input: PutDomainPermissionsPolicyInput, completion: @escaping (SdkResult<PutDomainPermissionsPolicyOutput, PutDomainPermissionsPolicyOutputError>) -> Void)
    {
        let urlPath = "/v1/domain/permissions/policy"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "putDomainPermissionsPolicy")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "codeartifact.\(config.region).amazonaws.com")
                      .withSigningName(value: "codeartifact")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<PutDomainPermissionsPolicyInput, PutDomainPermissionsPolicyOutput, PutDomainPermissionsPolicyOutputError>(id: "putDomainPermissionsPolicy")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: PutDomainPermissionsPolicyInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: PutDomainPermissionsPolicyInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<PutDomainPermissionsPolicyInput, PutDomainPermissionsPolicyOutput, PutDomainPermissionsPolicyOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: PutDomainPermissionsPolicyInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>
    ///         Sets the resource policy on a repository that specifies permissions to access it.
    ///       </p>
    ///          <p>
    ///        When you call <code>PutRepositoryPermissionsPolicy</code>, the resource policy on the repository is ignored when evaluting permissions.
    ///        This ensures that the owner of a repository cannot lock themselves out of the repository, which would prevent them from being
    ///        able to update the resource policy.
    ///      </p>
    public func putRepositoryPermissionsPolicy(input: PutRepositoryPermissionsPolicyInput, completion: @escaping (SdkResult<PutRepositoryPermissionsPolicyOutput, PutRepositoryPermissionsPolicyOutputError>) -> Void)
    {
        let urlPath = "/v1/repository/permissions/policy"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "putRepositoryPermissionsPolicy")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "codeartifact.\(config.region).amazonaws.com")
                      .withSigningName(value: "codeartifact")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<PutRepositoryPermissionsPolicyInput, PutRepositoryPermissionsPolicyOutput, PutRepositoryPermissionsPolicyOutputError>(id: "putRepositoryPermissionsPolicy")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: PutRepositoryPermissionsPolicyInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: PutRepositoryPermissionsPolicyInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<PutRepositoryPermissionsPolicyInput, PutRepositoryPermissionsPolicyOutput, PutRepositoryPermissionsPolicyOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: PutRepositoryPermissionsPolicyInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Adds or updates tags for a resource in AWS CodeArtifact.</p>
    public func tagResource(input: TagResourceInput, completion: @escaping (SdkResult<TagResourceOutput, TagResourceOutputError>) -> Void)
    {
        let urlPath = "/v1/tag"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "tagResource")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "codeartifact.\(config.region).amazonaws.com")
                      .withSigningName(value: "codeartifact")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<TagResourceInput, TagResourceOutput, TagResourceOutputError>(id: "tagResource")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: TagResourceInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: TagResourceInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<TagResourceInput, TagResourceOutput, TagResourceOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: TagResourceInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Removes tags from a resource in AWS CodeArtifact.</p>
    public func untagResource(input: UntagResourceInput, completion: @escaping (SdkResult<UntagResourceOutput, UntagResourceOutputError>) -> Void)
    {
        let urlPath = "/v1/untag"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "untagResource")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "codeartifact.\(config.region).amazonaws.com")
                      .withSigningName(value: "codeartifact")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UntagResourceInput, UntagResourceOutput, UntagResourceOutputError>(id: "untagResource")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UntagResourceInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UntagResourceInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UntagResourceInput, UntagResourceOutput, UntagResourceOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UntagResourceInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>
    ///       Updates the status of one or more versions of a package.
    ///     </p>
    public func updatePackageVersionsStatus(input: UpdatePackageVersionsStatusInput, completion: @escaping (SdkResult<UpdatePackageVersionsStatusOutput, UpdatePackageVersionsStatusOutputError>) -> Void)
    {
        let urlPath = "/v1/package/versions/update_status"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updatePackageVersionsStatus")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "codeartifact.\(config.region).amazonaws.com")
                      .withSigningName(value: "codeartifact")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdatePackageVersionsStatusInput, UpdatePackageVersionsStatusOutput, UpdatePackageVersionsStatusOutputError>(id: "updatePackageVersionsStatus")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdatePackageVersionsStatusInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdatePackageVersionsStatusInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdatePackageVersionsStatusInput, UpdatePackageVersionsStatusOutput, UpdatePackageVersionsStatusOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdatePackageVersionsStatusInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>
    ///          Update the properties of a repository.
    ///        </p>
    public func updateRepository(input: UpdateRepositoryInput, completion: @escaping (SdkResult<UpdateRepositoryOutput, UpdateRepositoryOutputError>) -> Void)
    {
        let urlPath = "/v1/repository"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateRepository")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "codeartifact.\(config.region).amazonaws.com")
                      .withSigningName(value: "codeartifact")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateRepositoryInput, UpdateRepositoryOutput, UpdateRepositoryOutputError>(id: "updateRepository")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateRepositoryInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateRepositoryInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateRepositoryInput, UpdateRepositoryOutput, UpdateRepositoryOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateRepositoryInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

}
