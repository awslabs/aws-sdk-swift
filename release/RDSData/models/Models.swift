// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension ArrayValue: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arrayValues
        case booleanValues
        case doubleValues
        case longValues
        case sdkUnknown
        case stringValues
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .arrayValues(arrayValues):
                if let arrayValues = arrayValues {
                    var arrayValuesContainer = container.nestedUnkeyedContainer(forKey: .arrayValues)
                    for arrayofarray0 in arrayValues {
                        try arrayValuesContainer.encode(arrayofarray0)
                    }
                }
            case let .booleanValues(booleanValues):
                if let booleanValues = booleanValues {
                    var booleanValuesContainer = container.nestedUnkeyedContainer(forKey: .booleanValues)
                    for booleanarray0 in booleanValues {
                        try booleanValuesContainer.encode(booleanarray0)
                    }
                }
            case let .doubleValues(doubleValues):
                if let doubleValues = doubleValues {
                    var doubleValuesContainer = container.nestedUnkeyedContainer(forKey: .doubleValues)
                    for doublearray0 in doubleValues {
                        try doubleValuesContainer.encode(doublearray0)
                    }
                }
            case let .longValues(longValues):
                if let longValues = longValues {
                    var longValuesContainer = container.nestedUnkeyedContainer(forKey: .longValues)
                    for longarray0 in longValues {
                        try longValuesContainer.encode(longarray0)
                    }
                }
            case let .stringValues(stringValues):
                if let stringValues = stringValues {
                    var stringValuesContainer = container.nestedUnkeyedContainer(forKey: .stringValues)
                    for stringarray0 in stringValues {
                        try stringValuesContainer.encode(stringarray0)
                    }
                }
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let booleanValuesContainer = try values.decodeIfPresent([Bool?].self, forKey: .booleanValues)
        var booleanValuesDecoded0:[Bool]? = nil
        if let booleanValuesContainer = booleanValuesContainer {
            booleanValuesDecoded0 = [Bool]()
            for boolean0 in booleanValuesContainer {
                if let boolean0 = boolean0 {
                    booleanValuesDecoded0?.append(boolean0)
                }
            }
        }
        if let booleanValues = booleanValuesDecoded0 {
            self = .booleanValues(booleanValues)
            return
        }
        let longValuesContainer = try values.decodeIfPresent([Int?].self, forKey: .longValues)
        var longValuesDecoded0:[Int]? = nil
        if let longValuesContainer = longValuesContainer {
            longValuesDecoded0 = [Int]()
            for long0 in longValuesContainer {
                if let long0 = long0 {
                    longValuesDecoded0?.append(long0)
                }
            }
        }
        if let longValues = longValuesDecoded0 {
            self = .longValues(longValues)
            return
        }
        let doubleValuesContainer = try values.decodeIfPresent([Double?].self, forKey: .doubleValues)
        var doubleValuesDecoded0:[Double]? = nil
        if let doubleValuesContainer = doubleValuesContainer {
            doubleValuesDecoded0 = [Double]()
            for double0 in doubleValuesContainer {
                if let double0 = double0 {
                    doubleValuesDecoded0?.append(double0)
                }
            }
        }
        if let doubleValues = doubleValuesDecoded0 {
            self = .doubleValues(doubleValues)
            return
        }
        let stringValuesContainer = try values.decodeIfPresent([String?].self, forKey: .stringValues)
        var stringValuesDecoded0:[String]? = nil
        if let stringValuesContainer = stringValuesContainer {
            stringValuesDecoded0 = [String]()
            for string0 in stringValuesContainer {
                if let string0 = string0 {
                    stringValuesDecoded0?.append(string0)
                }
            }
        }
        if let stringValues = stringValuesDecoded0 {
            self = .stringValues(stringValues)
            return
        }
        let arrayValuesContainer = try values.decodeIfPresent([ArrayValue?].self, forKey: .arrayValues)
        var arrayValuesDecoded0:[ArrayValue]? = nil
        if let arrayValuesContainer = arrayValuesContainer {
            arrayValuesDecoded0 = [ArrayValue]()
            for union0 in arrayValuesContainer {
                if let union0 = union0 {
                    arrayValuesDecoded0?.append(union0)
                }
            }
        }
        if let arrayValues = arrayValuesDecoded0 {
            self = .arrayValues(arrayValues)
            return
        }
        self = .sdkUnknown("")
    }
}

/// <p>Contains an array.</p>
public enum ArrayValue: Equatable {
    /// <p>An array of Boolean values.</p>
    case booleanValues([Bool]?)
    /// <p>An array of floating point numbers.</p>
    case longValues([Int]?)
    /// <p>An array of integers.</p>
    case doubleValues([Double]?)
    /// <p>An array of strings.</p>
    case stringValues([String]?)
    /// <p>An array of arrays.</p>
    case arrayValues([ArrayValue]?)
    case sdkUnknown(String?)
}

extension BadRequestException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BadRequestException(message: \(String(describing: message)))"}
}

extension BadRequestException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BadRequestExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>There is an error in the call or in a SQL statement.</p>
public struct BadRequestException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The error message returned by this <code>BadRequestException</code> error.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct BadRequestExceptionBody: Equatable {
    public let message: String?
}

extension BadRequestExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct BatchExecuteStatementInputBodyMiddleware: Middleware {
    public let id: String = "BatchExecuteStatementInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchExecuteStatementInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchExecuteStatementOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchExecuteStatementInput>
    public typealias MOutput = OperationOutput<BatchExecuteStatementOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchExecuteStatementOutputError>
}

extension BatchExecuteStatementInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchExecuteStatementInput(database: \(String(describing: database)), parameterSets: \(String(describing: parameterSets)), resourceArn: \(String(describing: resourceArn)), schema: \(String(describing: schema)), secretArn: \(String(describing: secretArn)), sql: \(String(describing: sql)), transactionId: \(String(describing: transactionId)))"}
}

extension BatchExecuteStatementInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case database
        case parameterSets
        case resourceArn
        case schema
        case secretArn
        case sql
        case transactionId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let database = database {
            try encodeContainer.encode(database, forKey: .database)
        }
        if let parameterSets = parameterSets {
            var parameterSetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .parameterSets)
            for sqlparametersets0 in parameterSets {
                var sqlparametersets0Container = parameterSetsContainer.nestedUnkeyedContainer()
                for sqlparameterslist1 in sqlparametersets0 {
                    try sqlparametersets0Container.encode(sqlparameterslist1)
                }
            }
        }
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let schema = schema {
            try encodeContainer.encode(schema, forKey: .schema)
        }
        if let secretArn = secretArn {
            try encodeContainer.encode(secretArn, forKey: .secretArn)
        }
        if let sql = sql {
            try encodeContainer.encode(sql, forKey: .sql)
        }
        if let transactionId = transactionId {
            try encodeContainer.encode(transactionId, forKey: .transactionId)
        }
    }
}

public struct BatchExecuteStatementInputHeadersMiddleware: Middleware {
    public let id: String = "BatchExecuteStatementInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchExecuteStatementInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchExecuteStatementOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchExecuteStatementInput>
    public typealias MOutput = OperationOutput<BatchExecuteStatementOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchExecuteStatementOutputError>
}

public struct BatchExecuteStatementInputQueryItemMiddleware: Middleware {
    public let id: String = "BatchExecuteStatementInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchExecuteStatementInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchExecuteStatementOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchExecuteStatementInput>
    public typealias MOutput = OperationOutput<BatchExecuteStatementOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchExecuteStatementOutputError>
}

/// <p>The request parameters represent the input of a SQL statement over an array of
///             data.</p>
public struct BatchExecuteStatementInput: Equatable {
    /// <p>The name of the database.</p>
    public let database: String?
    /// <p>The parameter set for the batch operation.</p>
    ///         <p>The SQL statement is executed as many times as the number of parameter sets provided.
    ///           To execute a SQL statement with no parameters, use one of the following options:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>Specify one or more empty parameter sets.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Use the <code>ExecuteStatement</code> operation instead of the <code>BatchExecuteStatement</code> operation.</p>
    ///             </li>
    ///          </ul>
    ///         <note>
    ///             <p>Array parameters are not supported.</p>
    ///         </note>
    public let parameterSets: [[SqlParameter]]?
    /// <p>The Amazon Resource Name (ARN) of the Aurora Serverless DB cluster.</p>
    public let resourceArn: String?
    /// <p>The name of the database schema.</p>
    public let schema: String?
    /// <p>The name or ARN of the secret that enables access to the DB cluster.</p>
    public let secretArn: String?
    /// <p>The SQL statement to run.</p>
    public let sql: String?
    /// <p>The identifier of a transaction that was started by using the
    ///                 <code>BeginTransaction</code> operation. Specify the transaction ID of the
    ///             transaction that you want to include the SQL statement in.</p>
    ///         <p>If the SQL statement is not part of a transaction, don't set this
    ///             parameter.</p>
    public let transactionId: String?

    public init (
        database: String? = nil,
        parameterSets: [[SqlParameter]]? = nil,
        resourceArn: String? = nil,
        schema: String? = nil,
        secretArn: String? = nil,
        sql: String? = nil,
        transactionId: String? = nil
    )
    {
        self.database = database
        self.parameterSets = parameterSets
        self.resourceArn = resourceArn
        self.schema = schema
        self.secretArn = secretArn
        self.sql = sql
        self.transactionId = transactionId
    }
}

struct BatchExecuteStatementInputBody: Equatable {
    public let resourceArn: String?
    public let secretArn: String?
    public let sql: String?
    public let database: String?
    public let schema: String?
    public let parameterSets: [[SqlParameter]]?
    public let transactionId: String?
}

extension BatchExecuteStatementInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case database
        case parameterSets
        case resourceArn
        case schema
        case secretArn
        case sql
        case transactionId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let secretArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .secretArn)
        secretArn = secretArnDecoded
        let sqlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sql)
        sql = sqlDecoded
        let databaseDecoded = try containerValues.decodeIfPresent(String.self, forKey: .database)
        database = databaseDecoded
        let schemaDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schema)
        schema = schemaDecoded
        let parameterSetsContainer = try containerValues.decodeIfPresent([[SqlParameter?]?].self, forKey: .parameterSets)
        var parameterSetsDecoded0:[[SqlParameter]]? = nil
        if let parameterSetsContainer = parameterSetsContainer {
            parameterSetsDecoded0 = [[SqlParameter]]()
            for list0 in parameterSetsContainer {
                var list0Decoded0: [SqlParameter]? = nil
                if let list0 = list0 {
                    list0Decoded0 = [SqlParameter]()
                    for structure1 in list0 {
                        if let structure1 = structure1 {
                            list0Decoded0?.append(structure1)
                        }
                    }
                }
                if let list0Decoded0 = list0Decoded0 {
                    parameterSetsDecoded0?.append(list0Decoded0)
                }
            }
        }
        parameterSets = parameterSetsDecoded0
        let transactionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .transactionId)
        transactionId = transactionIdDecoded
    }
}

extension BatchExecuteStatementOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchExecuteStatementOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableError" : self = .serviceUnavailableError(try ServiceUnavailableError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StatementTimeoutException" : self = .statementTimeoutException(try StatementTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchExecuteStatementOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case serviceUnavailableError(ServiceUnavailableError)
    case statementTimeoutException(StatementTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchExecuteStatementOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchExecuteStatementOutputResponse(updateResults: \(String(describing: updateResults)))"}
}

extension BatchExecuteStatementOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BatchExecuteStatementOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.updateResults = output.updateResults
        } else {
            self.updateResults = nil
        }
    }
}

/// <p>The response elements represent the output of a SQL statement over an array of
///             data.</p>
public struct BatchExecuteStatementOutputResponse: Equatable {
    /// <p>The execution results of each batch entry.</p>
    public let updateResults: [UpdateResult]?

    public init (
        updateResults: [UpdateResult]? = nil
    )
    {
        self.updateResults = updateResults
    }
}

struct BatchExecuteStatementOutputResponseBody: Equatable {
    public let updateResults: [UpdateResult]?
}

extension BatchExecuteStatementOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case updateResults
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let updateResultsContainer = try containerValues.decodeIfPresent([UpdateResult?].self, forKey: .updateResults)
        var updateResultsDecoded0:[UpdateResult]? = nil
        if let updateResultsContainer = updateResultsContainer {
            updateResultsDecoded0 = [UpdateResult]()
            for structure0 in updateResultsContainer {
                if let structure0 = structure0 {
                    updateResultsDecoded0?.append(structure0)
                }
            }
        }
        updateResults = updateResultsDecoded0
    }
}

public struct BeginTransactionInputBodyMiddleware: Middleware {
    public let id: String = "BeginTransactionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BeginTransactionInput>,
                  next: H) -> Swift.Result<OperationOutput<BeginTransactionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BeginTransactionInput>
    public typealias MOutput = OperationOutput<BeginTransactionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BeginTransactionOutputError>
}

extension BeginTransactionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BeginTransactionInput(database: \(String(describing: database)), resourceArn: \(String(describing: resourceArn)), schema: \(String(describing: schema)), secretArn: \(String(describing: secretArn)))"}
}

extension BeginTransactionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case database
        case resourceArn
        case schema
        case secretArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let database = database {
            try encodeContainer.encode(database, forKey: .database)
        }
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let schema = schema {
            try encodeContainer.encode(schema, forKey: .schema)
        }
        if let secretArn = secretArn {
            try encodeContainer.encode(secretArn, forKey: .secretArn)
        }
    }
}

public struct BeginTransactionInputHeadersMiddleware: Middleware {
    public let id: String = "BeginTransactionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BeginTransactionInput>,
                  next: H) -> Swift.Result<OperationOutput<BeginTransactionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BeginTransactionInput>
    public typealias MOutput = OperationOutput<BeginTransactionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BeginTransactionOutputError>
}

public struct BeginTransactionInputQueryItemMiddleware: Middleware {
    public let id: String = "BeginTransactionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BeginTransactionInput>,
                  next: H) -> Swift.Result<OperationOutput<BeginTransactionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BeginTransactionInput>
    public typealias MOutput = OperationOutput<BeginTransactionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BeginTransactionOutputError>
}

/// <p>The request parameters represent the input of a request to start a SQL
///             transaction.</p>
public struct BeginTransactionInput: Equatable {
    /// <p>The name of the database.</p>
    public let database: String?
    /// <p>The Amazon Resource Name (ARN) of the Aurora Serverless DB cluster.</p>
    public let resourceArn: String?
    /// <p>The name of the database schema.</p>
    public let schema: String?
    /// <p>The name or ARN of the secret that enables access to the DB cluster.</p>
    public let secretArn: String?

    public init (
        database: String? = nil,
        resourceArn: String? = nil,
        schema: String? = nil,
        secretArn: String? = nil
    )
    {
        self.database = database
        self.resourceArn = resourceArn
        self.schema = schema
        self.secretArn = secretArn
    }
}

struct BeginTransactionInputBody: Equatable {
    public let resourceArn: String?
    public let secretArn: String?
    public let database: String?
    public let schema: String?
}

extension BeginTransactionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case database
        case resourceArn
        case schema
        case secretArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let secretArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .secretArn)
        secretArn = secretArnDecoded
        let databaseDecoded = try containerValues.decodeIfPresent(String.self, forKey: .database)
        database = databaseDecoded
        let schemaDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schema)
        schema = schemaDecoded
    }
}

extension BeginTransactionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BeginTransactionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableError" : self = .serviceUnavailableError(try ServiceUnavailableError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StatementTimeoutException" : self = .statementTimeoutException(try StatementTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BeginTransactionOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case serviceUnavailableError(ServiceUnavailableError)
    case statementTimeoutException(StatementTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BeginTransactionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BeginTransactionOutputResponse(transactionId: \(String(describing: transactionId)))"}
}

extension BeginTransactionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BeginTransactionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.transactionId = output.transactionId
        } else {
            self.transactionId = nil
        }
    }
}

/// <p>The response elements represent the output of a request to start a SQL
///             transaction.</p>
public struct BeginTransactionOutputResponse: Equatable {
    /// <p>The transaction ID of the transaction started by the call.</p>
    public let transactionId: String?

    public init (
        transactionId: String? = nil
    )
    {
        self.transactionId = transactionId
    }
}

struct BeginTransactionOutputResponseBody: Equatable {
    public let transactionId: String?
}

extension BeginTransactionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case transactionId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transactionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .transactionId)
        transactionId = transactionIdDecoded
    }
}

extension ColumnMetadata: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arrayBaseColumnType
        case isAutoIncrement
        case isCaseSensitive
        case isCurrency
        case isSigned
        case label
        case name
        case nullable
        case precision
        case scale
        case schemaName
        case tableName
        case type
        case typeName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if arrayBaseColumnType != 0 {
            try encodeContainer.encode(arrayBaseColumnType, forKey: .arrayBaseColumnType)
        }
        if isAutoIncrement != false {
            try encodeContainer.encode(isAutoIncrement, forKey: .isAutoIncrement)
        }
        if isCaseSensitive != false {
            try encodeContainer.encode(isCaseSensitive, forKey: .isCaseSensitive)
        }
        if isCurrency != false {
            try encodeContainer.encode(isCurrency, forKey: .isCurrency)
        }
        if isSigned != false {
            try encodeContainer.encode(isSigned, forKey: .isSigned)
        }
        if let label = label {
            try encodeContainer.encode(label, forKey: .label)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if nullable != 0 {
            try encodeContainer.encode(nullable, forKey: .nullable)
        }
        if precision != 0 {
            try encodeContainer.encode(precision, forKey: .precision)
        }
        if scale != 0 {
            try encodeContainer.encode(scale, forKey: .scale)
        }
        if let schemaName = schemaName {
            try encodeContainer.encode(schemaName, forKey: .schemaName)
        }
        if let tableName = tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
        if type != 0 {
            try encodeContainer.encode(type, forKey: .type)
        }
        if let typeName = typeName {
            try encodeContainer.encode(typeName, forKey: .typeName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decode(Int.self, forKey: .type)
        type = typeDecoded
        let typeNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .typeName)
        typeName = typeNameDecoded
        let labelDecoded = try containerValues.decodeIfPresent(String.self, forKey: .label)
        label = labelDecoded
        let schemaNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schemaName)
        schemaName = schemaNameDecoded
        let tableNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tableName)
        tableName = tableNameDecoded
        let isAutoIncrementDecoded = try containerValues.decode(Bool.self, forKey: .isAutoIncrement)
        isAutoIncrement = isAutoIncrementDecoded
        let isSignedDecoded = try containerValues.decode(Bool.self, forKey: .isSigned)
        isSigned = isSignedDecoded
        let isCurrencyDecoded = try containerValues.decode(Bool.self, forKey: .isCurrency)
        isCurrency = isCurrencyDecoded
        let isCaseSensitiveDecoded = try containerValues.decode(Bool.self, forKey: .isCaseSensitive)
        isCaseSensitive = isCaseSensitiveDecoded
        let nullableDecoded = try containerValues.decode(Int.self, forKey: .nullable)
        nullable = nullableDecoded
        let precisionDecoded = try containerValues.decode(Int.self, forKey: .precision)
        precision = precisionDecoded
        let scaleDecoded = try containerValues.decode(Int.self, forKey: .scale)
        scale = scaleDecoded
        let arrayBaseColumnTypeDecoded = try containerValues.decode(Int.self, forKey: .arrayBaseColumnType)
        arrayBaseColumnType = arrayBaseColumnTypeDecoded
    }
}

extension ColumnMetadata: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ColumnMetadata(arrayBaseColumnType: \(String(describing: arrayBaseColumnType)), isAutoIncrement: \(String(describing: isAutoIncrement)), isCaseSensitive: \(String(describing: isCaseSensitive)), isCurrency: \(String(describing: isCurrency)), isSigned: \(String(describing: isSigned)), label: \(String(describing: label)), name: \(String(describing: name)), nullable: \(String(describing: nullable)), precision: \(String(describing: precision)), scale: \(String(describing: scale)), schemaName: \(String(describing: schemaName)), tableName: \(String(describing: tableName)), type: \(String(describing: type)), typeName: \(String(describing: typeName)))"}
}

/// <p>Contains the metadata for a column.</p>
public struct ColumnMetadata: Equatable {
    /// <p>The type of the column.</p>
    public let arrayBaseColumnType: Int
    /// <p>A value that indicates whether the column increments automatically.</p>
    public let isAutoIncrement: Bool
    /// <p>A value that indicates whether the column is case-sensitive.</p>
    public let isCaseSensitive: Bool
    /// <p>A value that indicates whether the column contains currency values.</p>
    public let isCurrency: Bool
    /// <p>A value that indicates whether an integer column is signed.</p>
    public let isSigned: Bool
    /// <p>The label for the column.</p>
    public let label: String?
    /// <p>The name of the column.</p>
    public let name: String?
    /// <p>A value that indicates whether the column is nullable.</p>
    public let nullable: Int
    /// <p>The precision value of a decimal number column.</p>
    public let precision: Int
    /// <p>The scale value of a decimal number column.</p>
    public let scale: Int
    /// <p>The name of the schema that owns the table that includes the column.</p>
    public let schemaName: String?
    /// <p>The name of the table that includes the column.</p>
    public let tableName: String?
    /// <p>The type of the column.</p>
    public let type: Int
    /// <p>The database-specific data type of the column.</p>
    public let typeName: String?

    public init (
        arrayBaseColumnType: Int = 0,
        isAutoIncrement: Bool = false,
        isCaseSensitive: Bool = false,
        isCurrency: Bool = false,
        isSigned: Bool = false,
        label: String? = nil,
        name: String? = nil,
        nullable: Int = 0,
        precision: Int = 0,
        scale: Int = 0,
        schemaName: String? = nil,
        tableName: String? = nil,
        type: Int = 0,
        typeName: String? = nil
    )
    {
        self.arrayBaseColumnType = arrayBaseColumnType
        self.isAutoIncrement = isAutoIncrement
        self.isCaseSensitive = isCaseSensitive
        self.isCurrency = isCurrency
        self.isSigned = isSigned
        self.label = label
        self.name = name
        self.nullable = nullable
        self.precision = precision
        self.scale = scale
        self.schemaName = schemaName
        self.tableName = tableName
        self.type = type
        self.typeName = typeName
    }
}

public struct CommitTransactionInputBodyMiddleware: Middleware {
    public let id: String = "CommitTransactionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CommitTransactionInput>,
                  next: H) -> Swift.Result<OperationOutput<CommitTransactionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CommitTransactionInput>
    public typealias MOutput = OperationOutput<CommitTransactionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CommitTransactionOutputError>
}

extension CommitTransactionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CommitTransactionInput(resourceArn: \(String(describing: resourceArn)), secretArn: \(String(describing: secretArn)), transactionId: \(String(describing: transactionId)))"}
}

extension CommitTransactionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceArn
        case secretArn
        case transactionId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let secretArn = secretArn {
            try encodeContainer.encode(secretArn, forKey: .secretArn)
        }
        if let transactionId = transactionId {
            try encodeContainer.encode(transactionId, forKey: .transactionId)
        }
    }
}

public struct CommitTransactionInputHeadersMiddleware: Middleware {
    public let id: String = "CommitTransactionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CommitTransactionInput>,
                  next: H) -> Swift.Result<OperationOutput<CommitTransactionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CommitTransactionInput>
    public typealias MOutput = OperationOutput<CommitTransactionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CommitTransactionOutputError>
}

public struct CommitTransactionInputQueryItemMiddleware: Middleware {
    public let id: String = "CommitTransactionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CommitTransactionInput>,
                  next: H) -> Swift.Result<OperationOutput<CommitTransactionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CommitTransactionInput>
    public typealias MOutput = OperationOutput<CommitTransactionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CommitTransactionOutputError>
}

/// <p>The request parameters represent the input of a commit transaction request.</p>
public struct CommitTransactionInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the Aurora Serverless DB cluster.</p>
    public let resourceArn: String?
    /// <p>The name or ARN of the secret that enables access to the DB cluster.</p>
    public let secretArn: String?
    /// <p>The identifier of the transaction to end and commit.</p>
    public let transactionId: String?

    public init (
        resourceArn: String? = nil,
        secretArn: String? = nil,
        transactionId: String? = nil
    )
    {
        self.resourceArn = resourceArn
        self.secretArn = secretArn
        self.transactionId = transactionId
    }
}

struct CommitTransactionInputBody: Equatable {
    public let resourceArn: String?
    public let secretArn: String?
    public let transactionId: String?
}

extension CommitTransactionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceArn
        case secretArn
        case transactionId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let secretArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .secretArn)
        secretArn = secretArnDecoded
        let transactionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .transactionId)
        transactionId = transactionIdDecoded
    }
}

extension CommitTransactionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CommitTransactionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableError" : self = .serviceUnavailableError(try ServiceUnavailableError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StatementTimeoutException" : self = .statementTimeoutException(try StatementTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CommitTransactionOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableError(ServiceUnavailableError)
    case statementTimeoutException(StatementTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CommitTransactionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CommitTransactionOutputResponse(transactionStatus: \(String(describing: transactionStatus)))"}
}

extension CommitTransactionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CommitTransactionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.transactionStatus = output.transactionStatus
        } else {
            self.transactionStatus = nil
        }
    }
}

/// <p>The response elements represent the output of a commit transaction request.</p>
public struct CommitTransactionOutputResponse: Equatable {
    /// <p>The status of the commit operation.</p>
    public let transactionStatus: String?

    public init (
        transactionStatus: String? = nil
    )
    {
        self.transactionStatus = transactionStatus
    }
}

struct CommitTransactionOutputResponseBody: Equatable {
    public let transactionStatus: String?
}

extension CommitTransactionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case transactionStatus
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transactionStatusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .transactionStatus)
        transactionStatus = transactionStatusDecoded
    }
}

public enum DecimalReturnType {
    case doubleOrLong
    case string
    case sdkUnknown(String)
}

extension DecimalReturnType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DecimalReturnType] {
        return [
            .doubleOrLong,
            .string,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .doubleOrLong: return "DOUBLE_OR_LONG"
        case .string: return "STRING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DecimalReturnType(rawValue: rawValue) ?? DecimalReturnType.sdkUnknown(rawValue)
    }
}

public struct ExecuteSqlInputBodyMiddleware: Middleware {
    public let id: String = "ExecuteSqlInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ExecuteSqlInput>,
                  next: H) -> Swift.Result<OperationOutput<ExecuteSqlOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ExecuteSqlInput>
    public typealias MOutput = OperationOutput<ExecuteSqlOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ExecuteSqlOutputError>
}

extension ExecuteSqlInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ExecuteSqlInput(awsSecretStoreArn: \(String(describing: awsSecretStoreArn)), database: \(String(describing: database)), dbClusterOrInstanceArn: \(String(describing: dbClusterOrInstanceArn)), schema: \(String(describing: schema)), sqlStatements: \(String(describing: sqlStatements)))"}
}

extension ExecuteSqlInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case awsSecretStoreArn
        case database
        case dbClusterOrInstanceArn
        case schema
        case sqlStatements
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsSecretStoreArn = awsSecretStoreArn {
            try encodeContainer.encode(awsSecretStoreArn, forKey: .awsSecretStoreArn)
        }
        if let database = database {
            try encodeContainer.encode(database, forKey: .database)
        }
        if let dbClusterOrInstanceArn = dbClusterOrInstanceArn {
            try encodeContainer.encode(dbClusterOrInstanceArn, forKey: .dbClusterOrInstanceArn)
        }
        if let schema = schema {
            try encodeContainer.encode(schema, forKey: .schema)
        }
        if let sqlStatements = sqlStatements {
            try encodeContainer.encode(sqlStatements, forKey: .sqlStatements)
        }
    }
}

public struct ExecuteSqlInputHeadersMiddleware: Middleware {
    public let id: String = "ExecuteSqlInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ExecuteSqlInput>,
                  next: H) -> Swift.Result<OperationOutput<ExecuteSqlOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ExecuteSqlInput>
    public typealias MOutput = OperationOutput<ExecuteSqlOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ExecuteSqlOutputError>
}

public struct ExecuteSqlInputQueryItemMiddleware: Middleware {
    public let id: String = "ExecuteSqlInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ExecuteSqlInput>,
                  next: H) -> Swift.Result<OperationOutput<ExecuteSqlOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ExecuteSqlInput>
    public typealias MOutput = OperationOutput<ExecuteSqlOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ExecuteSqlOutputError>
}

/// <p>The request parameters represent the input of a request to run one or more SQL
///             statements.</p>
public struct ExecuteSqlInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the secret that enables access to the DB cluster.</p>
    public let awsSecretStoreArn: String?
    /// <p>The name of the database.</p>
    public let database: String?
    /// <p>The ARN of the Aurora Serverless DB cluster.</p>
    public let dbClusterOrInstanceArn: String?
    /// <p>The name of the database schema.</p>
    public let schema: String?
    /// <p>One or more SQL statements to run on the DB cluster.</p>
    ///         <p>You can separate SQL statements from each other with a semicolon (;). Any valid SQL
    ///             statement is permitted, including data definition, data manipulation, and commit
    ///             statements. </p>
    public let sqlStatements: String?

    public init (
        awsSecretStoreArn: String? = nil,
        database: String? = nil,
        dbClusterOrInstanceArn: String? = nil,
        schema: String? = nil,
        sqlStatements: String? = nil
    )
    {
        self.awsSecretStoreArn = awsSecretStoreArn
        self.database = database
        self.dbClusterOrInstanceArn = dbClusterOrInstanceArn
        self.schema = schema
        self.sqlStatements = sqlStatements
    }
}

struct ExecuteSqlInputBody: Equatable {
    public let dbClusterOrInstanceArn: String?
    public let awsSecretStoreArn: String?
    public let sqlStatements: String?
    public let database: String?
    public let schema: String?
}

extension ExecuteSqlInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case awsSecretStoreArn
        case database
        case dbClusterOrInstanceArn
        case schema
        case sqlStatements
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dbClusterOrInstanceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dbClusterOrInstanceArn)
        dbClusterOrInstanceArn = dbClusterOrInstanceArnDecoded
        let awsSecretStoreArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .awsSecretStoreArn)
        awsSecretStoreArn = awsSecretStoreArnDecoded
        let sqlStatementsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sqlStatements)
        sqlStatements = sqlStatementsDecoded
        let databaseDecoded = try containerValues.decodeIfPresent(String.self, forKey: .database)
        database = databaseDecoded
        let schemaDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schema)
        schema = schemaDecoded
    }
}

extension ExecuteSqlOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ExecuteSqlOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableError" : self = .serviceUnavailableError(try ServiceUnavailableError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ExecuteSqlOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case serviceUnavailableError(ServiceUnavailableError)
    case unknown(UnknownAWSHttpServiceError)
}

extension ExecuteSqlOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ExecuteSqlOutputResponse(sqlStatementResults: \(String(describing: sqlStatementResults)))"}
}

extension ExecuteSqlOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ExecuteSqlOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.sqlStatementResults = output.sqlStatementResults
        } else {
            self.sqlStatementResults = nil
        }
    }
}

/// <p>The response elements represent the output of a request to run one or more SQL
///             statements.</p>
public struct ExecuteSqlOutputResponse: Equatable {
    /// <p>The results of the SQL statement or statements.</p>
    public let sqlStatementResults: [SqlStatementResult]?

    public init (
        sqlStatementResults: [SqlStatementResult]? = nil
    )
    {
        self.sqlStatementResults = sqlStatementResults
    }
}

struct ExecuteSqlOutputResponseBody: Equatable {
    public let sqlStatementResults: [SqlStatementResult]?
}

extension ExecuteSqlOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case sqlStatementResults
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sqlStatementResultsContainer = try containerValues.decodeIfPresent([SqlStatementResult?].self, forKey: .sqlStatementResults)
        var sqlStatementResultsDecoded0:[SqlStatementResult]? = nil
        if let sqlStatementResultsContainer = sqlStatementResultsContainer {
            sqlStatementResultsDecoded0 = [SqlStatementResult]()
            for structure0 in sqlStatementResultsContainer {
                if let structure0 = structure0 {
                    sqlStatementResultsDecoded0?.append(structure0)
                }
            }
        }
        sqlStatementResults = sqlStatementResultsDecoded0
    }
}

public struct ExecuteStatementInputBodyMiddleware: Middleware {
    public let id: String = "ExecuteStatementInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ExecuteStatementInput>,
                  next: H) -> Swift.Result<OperationOutput<ExecuteStatementOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ExecuteStatementInput>
    public typealias MOutput = OperationOutput<ExecuteStatementOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ExecuteStatementOutputError>
}

extension ExecuteStatementInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ExecuteStatementInput(continueAfterTimeout: \(String(describing: continueAfterTimeout)), database: \(String(describing: database)), includeResultMetadata: \(String(describing: includeResultMetadata)), parameters: \(String(describing: parameters)), resourceArn: \(String(describing: resourceArn)), resultSetOptions: \(String(describing: resultSetOptions)), schema: \(String(describing: schema)), secretArn: \(String(describing: secretArn)), sql: \(String(describing: sql)), transactionId: \(String(describing: transactionId)))"}
}

extension ExecuteStatementInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case continueAfterTimeout
        case database
        case includeResultMetadata
        case parameters
        case resourceArn
        case resultSetOptions
        case schema
        case secretArn
        case sql
        case transactionId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if continueAfterTimeout != false {
            try encodeContainer.encode(continueAfterTimeout, forKey: .continueAfterTimeout)
        }
        if let database = database {
            try encodeContainer.encode(database, forKey: .database)
        }
        if includeResultMetadata != false {
            try encodeContainer.encode(includeResultMetadata, forKey: .includeResultMetadata)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .parameters)
            for sqlparameterslist0 in parameters {
                try parametersContainer.encode(sqlparameterslist0)
            }
        }
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let resultSetOptions = resultSetOptions {
            try encodeContainer.encode(resultSetOptions, forKey: .resultSetOptions)
        }
        if let schema = schema {
            try encodeContainer.encode(schema, forKey: .schema)
        }
        if let secretArn = secretArn {
            try encodeContainer.encode(secretArn, forKey: .secretArn)
        }
        if let sql = sql {
            try encodeContainer.encode(sql, forKey: .sql)
        }
        if let transactionId = transactionId {
            try encodeContainer.encode(transactionId, forKey: .transactionId)
        }
    }
}

public struct ExecuteStatementInputHeadersMiddleware: Middleware {
    public let id: String = "ExecuteStatementInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ExecuteStatementInput>,
                  next: H) -> Swift.Result<OperationOutput<ExecuteStatementOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ExecuteStatementInput>
    public typealias MOutput = OperationOutput<ExecuteStatementOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ExecuteStatementOutputError>
}

public struct ExecuteStatementInputQueryItemMiddleware: Middleware {
    public let id: String = "ExecuteStatementInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ExecuteStatementInput>,
                  next: H) -> Swift.Result<OperationOutput<ExecuteStatementOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ExecuteStatementInput>
    public typealias MOutput = OperationOutput<ExecuteStatementOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ExecuteStatementOutputError>
}

/// <p>The request parameters represent the input of a request to run a SQL statement against
///             a database.</p>
public struct ExecuteStatementInput: Equatable {
    /// <p>A value that indicates whether to continue running the statement after
    ///             the call times out. By default, the statement stops running when the call
    ///             times out.</p>
    ///         <important>
    ///             <p>For DDL statements, we recommend continuing to run the statement after
    ///                the call times out. When a DDL statement terminates before it is finished
    ///                running, it can result in errors and possibly corrupted data structures.</p>
    ///         </important>
    public let continueAfterTimeout: Bool
    /// <p>The name of the database.</p>
    public let database: String?
    /// <p>A value that indicates whether to include metadata in the results.</p>
    public let includeResultMetadata: Bool
    /// <p>The parameters for the SQL statement.</p>
    ///         <note>
    ///             <p>Array parameters are not supported.</p>
    ///         </note>
    public let parameters: [SqlParameter]?
    /// <p>The Amazon Resource Name (ARN) of the Aurora Serverless DB cluster.</p>
    public let resourceArn: String?
    /// <p>Options that control how the result set is returned.</p>
    public let resultSetOptions: ResultSetOptions?
    /// <p>The name of the database schema.</p>
    ///         <note>
    ///             <p>Currently, the <code>schema</code> parameter isn't supported.</p>
    ///         </note>
    public let schema: String?
    /// <p>The name or ARN of the secret that enables access to the DB cluster.</p>
    public let secretArn: String?
    /// <p>The SQL statement to run.</p>
    public let sql: String?
    /// <p>The identifier of a transaction that was started by using the
    ///                 <code>BeginTransaction</code> operation. Specify the transaction ID of the
    ///             transaction that you want to include the SQL statement in.</p>
    ///         <p>If the SQL statement is not part of a transaction, don't set this parameter.</p>
    public let transactionId: String?

    public init (
        continueAfterTimeout: Bool = false,
        database: String? = nil,
        includeResultMetadata: Bool = false,
        parameters: [SqlParameter]? = nil,
        resourceArn: String? = nil,
        resultSetOptions: ResultSetOptions? = nil,
        schema: String? = nil,
        secretArn: String? = nil,
        sql: String? = nil,
        transactionId: String? = nil
    )
    {
        self.continueAfterTimeout = continueAfterTimeout
        self.database = database
        self.includeResultMetadata = includeResultMetadata
        self.parameters = parameters
        self.resourceArn = resourceArn
        self.resultSetOptions = resultSetOptions
        self.schema = schema
        self.secretArn = secretArn
        self.sql = sql
        self.transactionId = transactionId
    }
}

struct ExecuteStatementInputBody: Equatable {
    public let resourceArn: String?
    public let secretArn: String?
    public let sql: String?
    public let database: String?
    public let schema: String?
    public let parameters: [SqlParameter]?
    public let transactionId: String?
    public let includeResultMetadata: Bool
    public let continueAfterTimeout: Bool
    public let resultSetOptions: ResultSetOptions?
}

extension ExecuteStatementInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case continueAfterTimeout
        case database
        case includeResultMetadata
        case parameters
        case resourceArn
        case resultSetOptions
        case schema
        case secretArn
        case sql
        case transactionId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let secretArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .secretArn)
        secretArn = secretArnDecoded
        let sqlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sql)
        sql = sqlDecoded
        let databaseDecoded = try containerValues.decodeIfPresent(String.self, forKey: .database)
        database = databaseDecoded
        let schemaDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schema)
        schema = schemaDecoded
        let parametersContainer = try containerValues.decodeIfPresent([SqlParameter?].self, forKey: .parameters)
        var parametersDecoded0:[SqlParameter]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [SqlParameter]()
            for structure0 in parametersContainer {
                if let structure0 = structure0 {
                    parametersDecoded0?.append(structure0)
                }
            }
        }
        parameters = parametersDecoded0
        let transactionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .transactionId)
        transactionId = transactionIdDecoded
        let includeResultMetadataDecoded = try containerValues.decode(Bool.self, forKey: .includeResultMetadata)
        includeResultMetadata = includeResultMetadataDecoded
        let continueAfterTimeoutDecoded = try containerValues.decode(Bool.self, forKey: .continueAfterTimeout)
        continueAfterTimeout = continueAfterTimeoutDecoded
        let resultSetOptionsDecoded = try containerValues.decodeIfPresent(ResultSetOptions.self, forKey: .resultSetOptions)
        resultSetOptions = resultSetOptionsDecoded
    }
}

extension ExecuteStatementOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ExecuteStatementOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableError" : self = .serviceUnavailableError(try ServiceUnavailableError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StatementTimeoutException" : self = .statementTimeoutException(try StatementTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ExecuteStatementOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case serviceUnavailableError(ServiceUnavailableError)
    case statementTimeoutException(StatementTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ExecuteStatementOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ExecuteStatementOutputResponse(columnMetadata: \(String(describing: columnMetadata)), generatedFields: \(String(describing: generatedFields)), numberOfRecordsUpdated: \(String(describing: numberOfRecordsUpdated)), records: \(String(describing: records)))"}
}

extension ExecuteStatementOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ExecuteStatementOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.columnMetadata = output.columnMetadata
            self.generatedFields = output.generatedFields
            self.numberOfRecordsUpdated = output.numberOfRecordsUpdated
            self.records = output.records
        } else {
            self.columnMetadata = nil
            self.generatedFields = nil
            self.numberOfRecordsUpdated = 0
            self.records = nil
        }
    }
}

/// <p>The response elements represent the output of a request to run a SQL statement against
///             a database.</p>
public struct ExecuteStatementOutputResponse: Equatable {
    /// <p>Metadata for the columns included in the results.</p>
    public let columnMetadata: [ColumnMetadata]?
    /// <p>Values for fields generated during the request.</p>
    ///
    ///         <note>
    ///             <p>The <code>generatedFields</code> data isn't supported by Aurora PostgreSQL.
    ///                 To get the values of generated fields, use the <code>RETURNING</code> clause. For
    ///                 more information, see <a href="https://www.postgresql.org/docs/10/dml-returning.html">Returning Data From
    ///                     Modified Rows</a> in the PostgreSQL documentation.</p>
    ///         </note>
    public let generatedFields: [Field]?
    /// <p>The number of records updated by the request.</p>
    public let numberOfRecordsUpdated: Int
    /// <p>The records returned by the SQL statement.</p>
    public let records: [[Field]]?

    public init (
        columnMetadata: [ColumnMetadata]? = nil,
        generatedFields: [Field]? = nil,
        numberOfRecordsUpdated: Int = 0,
        records: [[Field]]? = nil
    )
    {
        self.columnMetadata = columnMetadata
        self.generatedFields = generatedFields
        self.numberOfRecordsUpdated = numberOfRecordsUpdated
        self.records = records
    }
}

struct ExecuteStatementOutputResponseBody: Equatable {
    public let records: [[Field]]?
    public let columnMetadata: [ColumnMetadata]?
    public let numberOfRecordsUpdated: Int
    public let generatedFields: [Field]?
}

extension ExecuteStatementOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case columnMetadata
        case generatedFields
        case numberOfRecordsUpdated
        case records
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recordsContainer = try containerValues.decodeIfPresent([[Field?]?].self, forKey: .records)
        var recordsDecoded0:[[Field]]? = nil
        if let recordsContainer = recordsContainer {
            recordsDecoded0 = [[Field]]()
            for list0 in recordsContainer {
                var list0Decoded0: [Field]? = nil
                if let list0 = list0 {
                    list0Decoded0 = [Field]()
                    for union1 in list0 {
                        if let union1 = union1 {
                            list0Decoded0?.append(union1)
                        }
                    }
                }
                if let list0Decoded0 = list0Decoded0 {
                    recordsDecoded0?.append(list0Decoded0)
                }
            }
        }
        records = recordsDecoded0
        let columnMetadataContainer = try containerValues.decodeIfPresent([ColumnMetadata?].self, forKey: .columnMetadata)
        var columnMetadataDecoded0:[ColumnMetadata]? = nil
        if let columnMetadataContainer = columnMetadataContainer {
            columnMetadataDecoded0 = [ColumnMetadata]()
            for structure0 in columnMetadataContainer {
                if let structure0 = structure0 {
                    columnMetadataDecoded0?.append(structure0)
                }
            }
        }
        columnMetadata = columnMetadataDecoded0
        let numberOfRecordsUpdatedDecoded = try containerValues.decode(Int.self, forKey: .numberOfRecordsUpdated)
        numberOfRecordsUpdated = numberOfRecordsUpdatedDecoded
        let generatedFieldsContainer = try containerValues.decodeIfPresent([Field?].self, forKey: .generatedFields)
        var generatedFieldsDecoded0:[Field]? = nil
        if let generatedFieldsContainer = generatedFieldsContainer {
            generatedFieldsDecoded0 = [Field]()
            for union0 in generatedFieldsContainer {
                if let union0 = union0 {
                    generatedFieldsDecoded0?.append(union0)
                }
            }
        }
        generatedFields = generatedFieldsDecoded0
    }
}

extension Field: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arrayValue
        case blobValue
        case booleanValue
        case doubleValue
        case isNull
        case longValue
        case sdkUnknown
        case stringValue
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .arrayValue(arrayValue):
                if let arrayValue = arrayValue {
                    try container.encode(arrayValue, forKey: .arrayValue)
                }
            case let .blobValue(blobValue):
                if let blobValue = blobValue {
                    try container.encode(blobValue.base64EncodedString(), forKey: .blobValue)
                }
            case let .booleanValue(booleanValue):
                if let booleanValue = booleanValue {
                    try container.encode(booleanValue, forKey: .booleanValue)
                }
            case let .doubleValue(doubleValue):
                if let doubleValue = doubleValue {
                    try container.encode(doubleValue, forKey: .doubleValue)
                }
            case let .isNull(isNull):
                if let isNull = isNull {
                    try container.encode(isNull, forKey: .isNull)
                }
            case let .longValue(longValue):
                if let longValue = longValue {
                    try container.encode(longValue, forKey: .longValue)
                }
            case let .stringValue(stringValue):
                if let stringValue = stringValue {
                    try container.encode(stringValue, forKey: .stringValue)
                }
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let isNullDecoded = try values.decodeIfPresent(Bool.self, forKey: .isNull)
        if let isNull = isNullDecoded {
            self = .isNull(isNull)
            return
        }
        let booleanValueDecoded = try values.decodeIfPresent(Bool.self, forKey: .booleanValue)
        if let booleanValue = booleanValueDecoded {
            self = .booleanValue(booleanValue)
            return
        }
        let longValueDecoded = try values.decodeIfPresent(Int.self, forKey: .longValue)
        if let longValue = longValueDecoded {
            self = .longValue(longValue)
            return
        }
        let doubleValueDecoded = try values.decodeIfPresent(Double.self, forKey: .doubleValue)
        if let doubleValue = doubleValueDecoded {
            self = .doubleValue(doubleValue)
            return
        }
        let stringValueDecoded = try values.decodeIfPresent(String.self, forKey: .stringValue)
        if let stringValue = stringValueDecoded {
            self = .stringValue(stringValue)
            return
        }
        let blobValueDecoded = try values.decodeIfPresent(Data.self, forKey: .blobValue)
        if let blobValue = blobValueDecoded {
            self = .blobValue(blobValue)
            return
        }
        let arrayValueDecoded = try values.decodeIfPresent(ArrayValue.self, forKey: .arrayValue)
        if let arrayValue = arrayValueDecoded {
            self = .arrayValue(arrayValue)
            return
        }
        self = .sdkUnknown("")
    }
}

/// <p>Contains a value.</p>
public enum Field: Equatable {
    /// <p>A NULL value.</p>
    case isNull(Bool?)
    /// <p>A value of Boolean data type.</p>
    case booleanValue(Bool?)
    /// <p>A value of long data type.</p>
    case longValue(Int?)
    /// <p>A value of double data type.</p>
    case doubleValue(Double?)
    /// <p>A value of string data type.</p>
    case stringValue(String?)
    /// <p>A value of BLOB data type.</p>
    case blobValue(Data?)
    /// <p>An array of values.</p>
    case arrayValue(ArrayValue?)
    case sdkUnknown(String?)
}

extension ForbiddenException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ForbiddenException(message: \(String(describing: message)))"}
}

extension ForbiddenException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ForbiddenExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>There are insufficient privileges to make the call.</p>
public struct ForbiddenException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The error message returned by this <code>ForbiddenException</code> error.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ForbiddenExceptionBody: Equatable {
    public let message: String?
}

extension ForbiddenExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InternalServerErrorException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalServerErrorException()"}
}

extension InternalServerErrorException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An internal error occurred.</p>
public struct InternalServerErrorException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server

    public init() {}
}

extension NotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NotFoundException(message: \(String(describing: message)))"}
}

extension NotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: NotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The <code>resourceArn</code>, <code>secretArn</code>, or <code>transactionId</code> value can't be found.</p>
public struct NotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The error message returned by this <code>NotFoundException</code> error.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct NotFoundExceptionBody: Equatable {
    public let message: String?
}

extension NotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Record: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case values
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for row0 in values {
                try valuesContainer.encode(row0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valuesContainer = try containerValues.decodeIfPresent([Value?].self, forKey: .values)
        var valuesDecoded0:[Value]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Value]()
            for union0 in valuesContainer {
                if let union0 = union0 {
                    valuesDecoded0?.append(union0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension Record: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Record(values: \(String(describing: values)))"}
}

/// <p>A record returned by a call.</p>
public struct Record: Equatable {
    /// <p>The values returned in the record.</p>
    public let values: [Value]?

    public init (
        values: [Value]? = nil
    )
    {
        self.values = values
    }
}

extension ResultFrame: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case records
        case resultSetMetadata
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let records = records {
            var recordsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .records)
            for records0 in records {
                try recordsContainer.encode(records0)
            }
        }
        if let resultSetMetadata = resultSetMetadata {
            try encodeContainer.encode(resultSetMetadata, forKey: .resultSetMetadata)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resultSetMetadataDecoded = try containerValues.decodeIfPresent(ResultSetMetadata.self, forKey: .resultSetMetadata)
        resultSetMetadata = resultSetMetadataDecoded
        let recordsContainer = try containerValues.decodeIfPresent([Record?].self, forKey: .records)
        var recordsDecoded0:[Record]? = nil
        if let recordsContainer = recordsContainer {
            recordsDecoded0 = [Record]()
            for structure0 in recordsContainer {
                if let structure0 = structure0 {
                    recordsDecoded0?.append(structure0)
                }
            }
        }
        records = recordsDecoded0
    }
}

extension ResultFrame: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResultFrame(records: \(String(describing: records)), resultSetMetadata: \(String(describing: resultSetMetadata)))"}
}

/// <p>The result set returned by a SQL statement.</p>
public struct ResultFrame: Equatable {
    /// <p>The records in the result set.</p>
    public let records: [Record]?
    /// <p>The result-set metadata in the result set.</p>
    public let resultSetMetadata: ResultSetMetadata?

    public init (
        records: [Record]? = nil,
        resultSetMetadata: ResultSetMetadata? = nil
    )
    {
        self.records = records
        self.resultSetMetadata = resultSetMetadata
    }
}

extension ResultSetMetadata: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case columnCount
        case columnMetadata
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if columnCount != 0 {
            try encodeContainer.encode(columnCount, forKey: .columnCount)
        }
        if let columnMetadata = columnMetadata {
            var columnMetadataContainer = encodeContainer.nestedUnkeyedContainer(forKey: .columnMetadata)
            for metadata0 in columnMetadata {
                try columnMetadataContainer.encode(metadata0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let columnCountDecoded = try containerValues.decode(Int.self, forKey: .columnCount)
        columnCount = columnCountDecoded
        let columnMetadataContainer = try containerValues.decodeIfPresent([ColumnMetadata?].self, forKey: .columnMetadata)
        var columnMetadataDecoded0:[ColumnMetadata]? = nil
        if let columnMetadataContainer = columnMetadataContainer {
            columnMetadataDecoded0 = [ColumnMetadata]()
            for structure0 in columnMetadataContainer {
                if let structure0 = structure0 {
                    columnMetadataDecoded0?.append(structure0)
                }
            }
        }
        columnMetadata = columnMetadataDecoded0
    }
}

extension ResultSetMetadata: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResultSetMetadata(columnCount: \(String(describing: columnCount)), columnMetadata: \(String(describing: columnMetadata)))"}
}

/// <p>The metadata of the result set returned by a SQL statement.</p>
public struct ResultSetMetadata: Equatable {
    /// <p>The number of columns in the result set.</p>
    public let columnCount: Int
    /// <p>The metadata of the columns in the result set.</p>
    public let columnMetadata: [ColumnMetadata]?

    public init (
        columnCount: Int = 0,
        columnMetadata: [ColumnMetadata]? = nil
    )
    {
        self.columnCount = columnCount
        self.columnMetadata = columnMetadata
    }
}

extension ResultSetOptions: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case decimalReturnType
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let decimalReturnType = decimalReturnType {
            try encodeContainer.encode(decimalReturnType.rawValue, forKey: .decimalReturnType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let decimalReturnTypeDecoded = try containerValues.decodeIfPresent(DecimalReturnType.self, forKey: .decimalReturnType)
        decimalReturnType = decimalReturnTypeDecoded
    }
}

extension ResultSetOptions: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResultSetOptions(decimalReturnType: \(String(describing: decimalReturnType)))"}
}

/// <p>Options that control how the result set is returned.</p>
public struct ResultSetOptions: Equatable {
    /// <p>A value that indicates how a field of <code>DECIMAL</code> type is represented
    ///             in the response. The value of <code>STRING</code>, the default, specifies that
    ///             it is converted to a String value. The value of <code>DOUBLE_OR_LONG</code>
    ///             specifies that it is converted to a Long value if its scale is 0, or to a Double
    ///             value otherwise.</p>
    ///         <important>
    ///             <p>Conversion to Double or Long can result in roundoff errors due to precision loss.
    ///                 We recommend converting to String, especially when working with currency values.</p>
    ///         </important>
    public let decimalReturnType: DecimalReturnType?

    public init (
        decimalReturnType: DecimalReturnType? = nil
    )
    {
        self.decimalReturnType = decimalReturnType
    }
}

public struct RollbackTransactionInputBodyMiddleware: Middleware {
    public let id: String = "RollbackTransactionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RollbackTransactionInput>,
                  next: H) -> Swift.Result<OperationOutput<RollbackTransactionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RollbackTransactionInput>
    public typealias MOutput = OperationOutput<RollbackTransactionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RollbackTransactionOutputError>
}

extension RollbackTransactionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RollbackTransactionInput(resourceArn: \(String(describing: resourceArn)), secretArn: \(String(describing: secretArn)), transactionId: \(String(describing: transactionId)))"}
}

extension RollbackTransactionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceArn
        case secretArn
        case transactionId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let secretArn = secretArn {
            try encodeContainer.encode(secretArn, forKey: .secretArn)
        }
        if let transactionId = transactionId {
            try encodeContainer.encode(transactionId, forKey: .transactionId)
        }
    }
}

public struct RollbackTransactionInputHeadersMiddleware: Middleware {
    public let id: String = "RollbackTransactionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RollbackTransactionInput>,
                  next: H) -> Swift.Result<OperationOutput<RollbackTransactionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RollbackTransactionInput>
    public typealias MOutput = OperationOutput<RollbackTransactionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RollbackTransactionOutputError>
}

public struct RollbackTransactionInputQueryItemMiddleware: Middleware {
    public let id: String = "RollbackTransactionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RollbackTransactionInput>,
                  next: H) -> Swift.Result<OperationOutput<RollbackTransactionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RollbackTransactionInput>
    public typealias MOutput = OperationOutput<RollbackTransactionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RollbackTransactionOutputError>
}

/// <p>The request parameters represent the input of a request to perform a rollback of a
///             transaction.</p>
public struct RollbackTransactionInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the Aurora Serverless DB cluster.</p>
    public let resourceArn: String?
    /// <p>The name or ARN of the secret that enables access to the DB cluster.</p>
    public let secretArn: String?
    /// <p>The identifier of the transaction to roll back.</p>
    public let transactionId: String?

    public init (
        resourceArn: String? = nil,
        secretArn: String? = nil,
        transactionId: String? = nil
    )
    {
        self.resourceArn = resourceArn
        self.secretArn = secretArn
        self.transactionId = transactionId
    }
}

struct RollbackTransactionInputBody: Equatable {
    public let resourceArn: String?
    public let secretArn: String?
    public let transactionId: String?
}

extension RollbackTransactionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceArn
        case secretArn
        case transactionId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let secretArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .secretArn)
        secretArn = secretArnDecoded
        let transactionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .transactionId)
        transactionId = transactionIdDecoded
    }
}

extension RollbackTransactionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RollbackTransactionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableError" : self = .serviceUnavailableError(try ServiceUnavailableError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StatementTimeoutException" : self = .statementTimeoutException(try StatementTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RollbackTransactionOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableError(ServiceUnavailableError)
    case statementTimeoutException(StatementTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RollbackTransactionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RollbackTransactionOutputResponse(transactionStatus: \(String(describing: transactionStatus)))"}
}

extension RollbackTransactionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RollbackTransactionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.transactionStatus = output.transactionStatus
        } else {
            self.transactionStatus = nil
        }
    }
}

/// <p>The response elements represent the output of a request to perform a rollback of a
///             transaction.</p>
public struct RollbackTransactionOutputResponse: Equatable {
    /// <p>The status of the rollback operation.</p>
    public let transactionStatus: String?

    public init (
        transactionStatus: String? = nil
    )
    {
        self.transactionStatus = transactionStatus
    }
}

struct RollbackTransactionOutputResponseBody: Equatable {
    public let transactionStatus: String?
}

extension RollbackTransactionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case transactionStatus
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transactionStatusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .transactionStatus)
        transactionStatus = transactionStatusDecoded
    }
}

extension ServiceUnavailableError: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceUnavailableError()"}
}

extension ServiceUnavailableError: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The service specified by the <code>resourceArn</code> parameter is not
///             available.</p>
public struct ServiceUnavailableError: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server

    public init() {}
}

extension SqlParameter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name
        case typeHint
        case value
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let typeHint = typeHint {
            try encodeContainer.encode(typeHint.rawValue, forKey: .typeHint)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Field.self, forKey: .value)
        value = valueDecoded
        let typeHintDecoded = try containerValues.decodeIfPresent(TypeHint.self, forKey: .typeHint)
        typeHint = typeHintDecoded
    }
}

extension SqlParameter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SqlParameter(name: \(String(describing: name)), typeHint: \(String(describing: typeHint)), value: \(String(describing: value)))"}
}

/// <p>A parameter used in a SQL statement.</p>
public struct SqlParameter: Equatable {
    /// <p>The name of the parameter.</p>
    public let name: String?
    /// <p>A hint that specifies the correct object type for data type mapping. Possible values
    ///             are as follows:</p>
    ///         <ul>
    ///             <li>
    ///                <p>
    ///                   <code>DATE</code> - The corresponding <code>String</code> parameter value is sent as an object
    ///               of <code>DATE</code> type to the database. The accepted format is <code>YYYY-MM-DD</code>.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>DECIMAL</code> - The corresponding <code>String</code> parameter value is sent as an object
    ///                     of <code>DECIMAL</code> type to the database.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>JSON</code> - The corresponding <code>String</code> parameter value is sent as an
    ///            object of <code>JSON</code> type to the database.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>TIME</code> - The corresponding <code>String</code> parameter value is sent as an object
    ///                     of <code>TIME</code> type to the database. The accepted format is <code>HH:MM:SS[.FFF]</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>TIMESTAMP</code> - The corresponding <code>String</code> parameter value is sent as an object
    ///               of <code>TIMESTAMP</code> type to the database. The accepted format is <code>YYYY-MM-DD HH:MM:SS[.FFF]</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>UUID</code> - The corresponding <code>String</code> parameter value is sent as an object of
    ///              <code>UUID</code> type to the database.
    ///           </p>
    ///             </li>
    ///          </ul>
    public let typeHint: TypeHint?
    /// <p>The value of the parameter.</p>
    public let value: Field?

    public init (
        name: String? = nil,
        typeHint: TypeHint? = nil,
        value: Field? = nil
    )
    {
        self.name = name
        self.typeHint = typeHint
        self.value = value
    }
}

extension SqlStatementResult: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case numberOfRecordsUpdated
        case resultFrame
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if numberOfRecordsUpdated != 0 {
            try encodeContainer.encode(numberOfRecordsUpdated, forKey: .numberOfRecordsUpdated)
        }
        if let resultFrame = resultFrame {
            try encodeContainer.encode(resultFrame, forKey: .resultFrame)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resultFrameDecoded = try containerValues.decodeIfPresent(ResultFrame.self, forKey: .resultFrame)
        resultFrame = resultFrameDecoded
        let numberOfRecordsUpdatedDecoded = try containerValues.decode(Int.self, forKey: .numberOfRecordsUpdated)
        numberOfRecordsUpdated = numberOfRecordsUpdatedDecoded
    }
}

extension SqlStatementResult: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SqlStatementResult(numberOfRecordsUpdated: \(String(describing: numberOfRecordsUpdated)), resultFrame: \(String(describing: resultFrame)))"}
}

/// <p>The result of a SQL statement.</p>
///
///         <important>
///             <p>This data type is deprecated.</p>
///         </important>
public struct SqlStatementResult: Equatable {
    /// <p>The number of records updated by a SQL statement.</p>
    public let numberOfRecordsUpdated: Int
    /// <p>The result set of the SQL statement.</p>
    public let resultFrame: ResultFrame?

    public init (
        numberOfRecordsUpdated: Int = 0,
        resultFrame: ResultFrame? = nil
    )
    {
        self.numberOfRecordsUpdated = numberOfRecordsUpdated
        self.resultFrame = resultFrame
    }
}

extension StatementTimeoutException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StatementTimeoutException(dbConnectionId: \(String(describing: dbConnectionId)), message: \(String(describing: message)))"}
}

extension StatementTimeoutException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StatementTimeoutExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dbConnectionId = output.dbConnectionId
            self.message = output.message
        } else {
            self.dbConnectionId = 0
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The execution of the SQL statement timed out.</p>
public struct StatementTimeoutException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The database connection ID that executed the SQL statement.</p>
    public var dbConnectionId: Int
    /// <p>The error message returned by this <code>StatementTimeoutException</code> error.</p>
    public var message: String?

    public init (
        dbConnectionId: Int = 0,
        message: String? = nil
    )
    {
        self.dbConnectionId = dbConnectionId
        self.message = message
    }
}

struct StatementTimeoutExceptionBody: Equatable {
    public let message: String?
    public let dbConnectionId: Int
}

extension StatementTimeoutExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dbConnectionId
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let dbConnectionIdDecoded = try containerValues.decode(Int.self, forKey: .dbConnectionId)
        dbConnectionId = dbConnectionIdDecoded
    }
}

extension StructValue: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attributes
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributes)
            for arrayvaluelist0 in attributes {
                try attributesContainer.encode(arrayvaluelist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributesContainer = try containerValues.decodeIfPresent([Value?].self, forKey: .attributes)
        var attributesDecoded0:[Value]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [Value]()
            for union0 in attributesContainer {
                if let union0 = union0 {
                    attributesDecoded0?.append(union0)
                }
            }
        }
        attributes = attributesDecoded0
    }
}

extension StructValue: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StructValue(attributes: \(String(describing: attributes)))"}
}

/// <p>A structure value returned by a call.</p>
public struct StructValue: Equatable {
    /// <p>The attributes returned in the record.</p>
    public let attributes: [Value]?

    public init (
        attributes: [Value]? = nil
    )
    {
        self.attributes = attributes
    }
}

public enum TypeHint {
    case date
    case decimal
    case json
    case time
    case timestamp
    case uuid
    case sdkUnknown(String)
}

extension TypeHint : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [TypeHint] {
        return [
            .date,
            .decimal,
            .json,
            .time,
            .timestamp,
            .uuid,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .date: return "DATE"
        case .decimal: return "DECIMAL"
        case .json: return "JSON"
        case .time: return "TIME"
        case .timestamp: return "TIMESTAMP"
        case .uuid: return "UUID"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = TypeHint(rawValue: rawValue) ?? TypeHint.sdkUnknown(rawValue)
    }
}

extension UpdateResult: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case generatedFields
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let generatedFields = generatedFields {
            var generatedFieldsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .generatedFields)
            for fieldlist0 in generatedFields {
                try generatedFieldsContainer.encode(fieldlist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let generatedFieldsContainer = try containerValues.decodeIfPresent([Field?].self, forKey: .generatedFields)
        var generatedFieldsDecoded0:[Field]? = nil
        if let generatedFieldsContainer = generatedFieldsContainer {
            generatedFieldsDecoded0 = [Field]()
            for union0 in generatedFieldsContainer {
                if let union0 = union0 {
                    generatedFieldsDecoded0?.append(union0)
                }
            }
        }
        generatedFields = generatedFieldsDecoded0
    }
}

extension UpdateResult: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateResult(generatedFields: \(String(describing: generatedFields)))"}
}

/// <p>The response elements represent the results of an update.</p>
public struct UpdateResult: Equatable {
    /// <p>Values for fields generated during the request.</p>
    public let generatedFields: [Field]?

    public init (
        generatedFields: [Field]? = nil
    )
    {
        self.generatedFields = generatedFields
    }
}

extension Value: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arrayValues
        case bigIntValue
        case bitValue
        case blobValue
        case doubleValue
        case intValue
        case isNull
        case realValue
        case sdkUnknown
        case stringValue
        case structValue
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .arrayValues(arrayValues):
                if let arrayValues = arrayValues {
                    var arrayValuesContainer = container.nestedUnkeyedContainer(forKey: .arrayValues)
                    for arrayvaluelist0 in arrayValues {
                        try arrayValuesContainer.encode(arrayvaluelist0)
                    }
                }
            case let .bigIntValue(bigIntValue):
                if let bigIntValue = bigIntValue {
                    try container.encode(bigIntValue, forKey: .bigIntValue)
                }
            case let .bitValue(bitValue):
                if let bitValue = bitValue {
                    try container.encode(bitValue, forKey: .bitValue)
                }
            case let .blobValue(blobValue):
                if let blobValue = blobValue {
                    try container.encode(blobValue.base64EncodedString(), forKey: .blobValue)
                }
            case let .doubleValue(doubleValue):
                if let doubleValue = doubleValue {
                    try container.encode(doubleValue, forKey: .doubleValue)
                }
            case let .intValue(intValue):
                if let intValue = intValue {
                    try container.encode(intValue, forKey: .intValue)
                }
            case let .isNull(isNull):
                if let isNull = isNull {
                    try container.encode(isNull, forKey: .isNull)
                }
            case let .realValue(realValue):
                if let realValue = realValue {
                    try container.encode(realValue, forKey: .realValue)
                }
            case let .stringValue(stringValue):
                if let stringValue = stringValue {
                    try container.encode(stringValue, forKey: .stringValue)
                }
            case let .structValue(structValue):
                if let structValue = structValue {
                    try container.encode(structValue, forKey: .structValue)
                }
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let isNullDecoded = try values.decodeIfPresent(Bool.self, forKey: .isNull)
        if let isNull = isNullDecoded {
            self = .isNull(isNull)
            return
        }
        let bitValueDecoded = try values.decodeIfPresent(Bool.self, forKey: .bitValue)
        if let bitValue = bitValueDecoded {
            self = .bitValue(bitValue)
            return
        }
        let bigIntValueDecoded = try values.decodeIfPresent(Int.self, forKey: .bigIntValue)
        if let bigIntValue = bigIntValueDecoded {
            self = .bigIntValue(bigIntValue)
            return
        }
        let intValueDecoded = try values.decodeIfPresent(Int.self, forKey: .intValue)
        if let intValue = intValueDecoded {
            self = .intValue(intValue)
            return
        }
        let doubleValueDecoded = try values.decodeIfPresent(Double.self, forKey: .doubleValue)
        if let doubleValue = doubleValueDecoded {
            self = .doubleValue(doubleValue)
            return
        }
        let realValueDecoded = try values.decodeIfPresent(Float.self, forKey: .realValue)
        if let realValue = realValueDecoded {
            self = .realValue(realValue)
            return
        }
        let stringValueDecoded = try values.decodeIfPresent(String.self, forKey: .stringValue)
        if let stringValue = stringValueDecoded {
            self = .stringValue(stringValue)
            return
        }
        let blobValueDecoded = try values.decodeIfPresent(Data.self, forKey: .blobValue)
        if let blobValue = blobValueDecoded {
            self = .blobValue(blobValue)
            return
        }
        let arrayValuesContainer = try values.decodeIfPresent([Value?].self, forKey: .arrayValues)
        var arrayValuesDecoded0:[Value]? = nil
        if let arrayValuesContainer = arrayValuesContainer {
            arrayValuesDecoded0 = [Value]()
            for union0 in arrayValuesContainer {
                if let union0 = union0 {
                    arrayValuesDecoded0?.append(union0)
                }
            }
        }
        if let arrayValues = arrayValuesDecoded0 {
            self = .arrayValues(arrayValues)
            return
        }
        let structValueDecoded = try values.decodeIfPresent(StructValue.self, forKey: .structValue)
        if let structValue = structValueDecoded {
            self = .structValue(structValue)
            return
        }
        self = .sdkUnknown("")
    }
}

/// <p>Contains the value of a column.</p>
///
///         <important>
///             <p>This data type is deprecated.</p>
///         </important>
public enum Value: Equatable {
    /// <p>A NULL value.</p>
    case isNull(Bool?)
    /// <p>A value for a column of BIT data type.</p>
    case bitValue(Bool?)
    /// <p>A value for a column of big integer data type.</p>
    case bigIntValue(Int?)
    /// <p>A value for a column of integer data type.</p>
    case intValue(Int?)
    /// <p>A value for a column of double data type.</p>
    case doubleValue(Double?)
    /// <p>A value for a column of real data type.</p>
    case realValue(Float?)
    /// <p>A value for a column of string data type.</p>
    case stringValue(String?)
    /// <p>A value for a column of BLOB data type.</p>
    case blobValue(Data?)
    /// <p>An array of column values.</p>
    case arrayValues([Value]?)
    /// <p>A value for a column of STRUCT data type.</p>
    case structValue(StructValue?)
    case sdkUnknown(String?)
}
