// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AddressBook: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case addressBookArn = "AddressBookArn"
        case description = "Description"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addressBookArn = addressBookArn {
            try encodeContainer.encode(addressBookArn, forKey: .addressBookArn)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addressBookArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .addressBookArn)
        addressBookArn = addressBookArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension AddressBook: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AddressBook(addressBookArn: \(String(describing: addressBookArn)), description: \(String(describing: description)), name: \(String(describing: name)))"}
}

/// <p>An address book with attributes.</p>
public struct AddressBook: Equatable {
    /// <p>The ARN of the address book.</p>
    public let addressBookArn: String?
    /// <p>The description of the address book.</p>
    public let description: String?
    /// <p>The name of the address book.</p>
    public let name: String?

    public init (
        addressBookArn: String? = nil,
        description: String? = nil,
        name: String? = nil
    )
    {
        self.addressBookArn = addressBookArn
        self.description = description
        self.name = name
    }
}

extension AddressBookData: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case addressBookArn = "AddressBookArn"
        case description = "Description"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addressBookArn = addressBookArn {
            try encodeContainer.encode(addressBookArn, forKey: .addressBookArn)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addressBookArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .addressBookArn)
        addressBookArn = addressBookArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension AddressBookData: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AddressBookData(addressBookArn: \(String(describing: addressBookArn)), description: \(String(describing: description)), name: \(String(describing: name)))"}
}

/// <p>Information related to an address book.</p>
public struct AddressBookData: Equatable {
    /// <p>The ARN of the address book.</p>
    public let addressBookArn: String?
    /// <p>The description of the address book.</p>
    public let description: String?
    /// <p>The name of the address book.</p>
    public let name: String?

    public init (
        addressBookArn: String? = nil,
        description: String? = nil,
        name: String? = nil
    )
    {
        self.addressBookArn = addressBookArn
        self.description = description
        self.name = name
    }
}

extension AlreadyExistsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AlreadyExistsException(message: \(String(describing: message)))"}
}

extension AlreadyExistsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The resource being created already exists.</p>
public struct AlreadyExistsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct AlreadyExistsExceptionBody: Equatable {
    public let message: String?
}

extension AlreadyExistsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ApproveSkillInputBodyMiddleware: Middleware {
    public let id: String = "ApproveSkillInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ApproveSkillInput>,
                  next: H) -> Swift.Result<OperationOutput<ApproveSkillOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ApproveSkillInput>
    public typealias MOutput = OperationOutput<ApproveSkillOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ApproveSkillOutputError>
}

extension ApproveSkillInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ApproveSkillInput(skillId: \(String(describing: skillId)))"}
}

extension ApproveSkillInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case skillId = "SkillId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let skillId = skillId {
            try encodeContainer.encode(skillId, forKey: .skillId)
        }
    }
}

public struct ApproveSkillInputHeadersMiddleware: Middleware {
    public let id: String = "ApproveSkillInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ApproveSkillInput>,
                  next: H) -> Swift.Result<OperationOutput<ApproveSkillOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ApproveSkillInput>
    public typealias MOutput = OperationOutput<ApproveSkillOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ApproveSkillOutputError>
}

public struct ApproveSkillInputQueryItemMiddleware: Middleware {
    public let id: String = "ApproveSkillInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ApproveSkillInput>,
                  next: H) -> Swift.Result<OperationOutput<ApproveSkillOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ApproveSkillInput>
    public typealias MOutput = OperationOutput<ApproveSkillOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ApproveSkillOutputError>
}

public struct ApproveSkillInput: Equatable {
    /// <p>The unique identifier of the skill.</p>
    public let skillId: String?

    public init (
        skillId: String? = nil
    )
    {
        self.skillId = skillId
    }
}

struct ApproveSkillInputBody: Equatable {
    public let skillId: String?
}

extension ApproveSkillInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case skillId = "SkillId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let skillIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .skillId)
        skillId = skillIdDecoded
    }
}

extension ApproveSkillOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ApproveSkillOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ApproveSkillOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ApproveSkillOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ApproveSkillOutputResponse()"}
}

extension ApproveSkillOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct ApproveSkillOutputResponse: Equatable {

    public init() {}
}

struct ApproveSkillOutputResponseBody: Equatable {
}

extension ApproveSkillOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct AssociateContactWithAddressBookInputBodyMiddleware: Middleware {
    public let id: String = "AssociateContactWithAddressBookInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateContactWithAddressBookInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateContactWithAddressBookOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateContactWithAddressBookInput>
    public typealias MOutput = OperationOutput<AssociateContactWithAddressBookOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateContactWithAddressBookOutputError>
}

extension AssociateContactWithAddressBookInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateContactWithAddressBookInput(addressBookArn: \(String(describing: addressBookArn)), contactArn: \(String(describing: contactArn)))"}
}

extension AssociateContactWithAddressBookInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case addressBookArn = "AddressBookArn"
        case contactArn = "ContactArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addressBookArn = addressBookArn {
            try encodeContainer.encode(addressBookArn, forKey: .addressBookArn)
        }
        if let contactArn = contactArn {
            try encodeContainer.encode(contactArn, forKey: .contactArn)
        }
    }
}

public struct AssociateContactWithAddressBookInputHeadersMiddleware: Middleware {
    public let id: String = "AssociateContactWithAddressBookInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateContactWithAddressBookInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateContactWithAddressBookOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateContactWithAddressBookInput>
    public typealias MOutput = OperationOutput<AssociateContactWithAddressBookOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateContactWithAddressBookOutputError>
}

public struct AssociateContactWithAddressBookInputQueryItemMiddleware: Middleware {
    public let id: String = "AssociateContactWithAddressBookInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateContactWithAddressBookInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateContactWithAddressBookOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateContactWithAddressBookInput>
    public typealias MOutput = OperationOutput<AssociateContactWithAddressBookOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateContactWithAddressBookOutputError>
}

public struct AssociateContactWithAddressBookInput: Equatable {
    /// <p>The ARN of the address book with which to associate the contact.</p>
    public let addressBookArn: String?
    /// <p>The ARN of the contact to associate with an address book.</p>
    public let contactArn: String?

    public init (
        addressBookArn: String? = nil,
        contactArn: String? = nil
    )
    {
        self.addressBookArn = addressBookArn
        self.contactArn = contactArn
    }
}

struct AssociateContactWithAddressBookInputBody: Equatable {
    public let contactArn: String?
    public let addressBookArn: String?
}

extension AssociateContactWithAddressBookInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case addressBookArn = "AddressBookArn"
        case contactArn = "ContactArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .contactArn)
        contactArn = contactArnDecoded
        let addressBookArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .addressBookArn)
        addressBookArn = addressBookArnDecoded
    }
}

extension AssociateContactWithAddressBookOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateContactWithAddressBookOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateContactWithAddressBookOutputError: Equatable {
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateContactWithAddressBookOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateContactWithAddressBookOutputResponse()"}
}

extension AssociateContactWithAddressBookOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct AssociateContactWithAddressBookOutputResponse: Equatable {

    public init() {}
}

struct AssociateContactWithAddressBookOutputResponseBody: Equatable {
}

extension AssociateContactWithAddressBookOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct AssociateDeviceWithNetworkProfileInputBodyMiddleware: Middleware {
    public let id: String = "AssociateDeviceWithNetworkProfileInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateDeviceWithNetworkProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateDeviceWithNetworkProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateDeviceWithNetworkProfileInput>
    public typealias MOutput = OperationOutput<AssociateDeviceWithNetworkProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateDeviceWithNetworkProfileOutputError>
}

extension AssociateDeviceWithNetworkProfileInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateDeviceWithNetworkProfileInput(deviceArn: \(String(describing: deviceArn)), networkProfileArn: \(String(describing: networkProfileArn)))"}
}

extension AssociateDeviceWithNetworkProfileInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case deviceArn = "DeviceArn"
        case networkProfileArn = "NetworkProfileArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceArn = deviceArn {
            try encodeContainer.encode(deviceArn, forKey: .deviceArn)
        }
        if let networkProfileArn = networkProfileArn {
            try encodeContainer.encode(networkProfileArn, forKey: .networkProfileArn)
        }
    }
}

public struct AssociateDeviceWithNetworkProfileInputHeadersMiddleware: Middleware {
    public let id: String = "AssociateDeviceWithNetworkProfileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateDeviceWithNetworkProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateDeviceWithNetworkProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateDeviceWithNetworkProfileInput>
    public typealias MOutput = OperationOutput<AssociateDeviceWithNetworkProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateDeviceWithNetworkProfileOutputError>
}

public struct AssociateDeviceWithNetworkProfileInputQueryItemMiddleware: Middleware {
    public let id: String = "AssociateDeviceWithNetworkProfileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateDeviceWithNetworkProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateDeviceWithNetworkProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateDeviceWithNetworkProfileInput>
    public typealias MOutput = OperationOutput<AssociateDeviceWithNetworkProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateDeviceWithNetworkProfileOutputError>
}

public struct AssociateDeviceWithNetworkProfileInput: Equatable {
    /// <p>The device ARN.</p>
    public let deviceArn: String?
    /// <p>The ARN of the network profile to associate with a device.</p>
    public let networkProfileArn: String?

    public init (
        deviceArn: String? = nil,
        networkProfileArn: String? = nil
    )
    {
        self.deviceArn = deviceArn
        self.networkProfileArn = networkProfileArn
    }
}

struct AssociateDeviceWithNetworkProfileInputBody: Equatable {
    public let deviceArn: String?
    public let networkProfileArn: String?
}

extension AssociateDeviceWithNetworkProfileInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case deviceArn = "DeviceArn"
        case networkProfileArn = "NetworkProfileArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deviceArn)
        deviceArn = deviceArnDecoded
        let networkProfileArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .networkProfileArn)
        networkProfileArn = networkProfileArnDecoded
    }
}

extension AssociateDeviceWithNetworkProfileOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateDeviceWithNetworkProfileOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DeviceNotRegisteredException" : self = .deviceNotRegisteredException(try DeviceNotRegisteredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateDeviceWithNetworkProfileOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case deviceNotRegisteredException(DeviceNotRegisteredException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateDeviceWithNetworkProfileOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateDeviceWithNetworkProfileOutputResponse()"}
}

extension AssociateDeviceWithNetworkProfileOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct AssociateDeviceWithNetworkProfileOutputResponse: Equatable {

    public init() {}
}

struct AssociateDeviceWithNetworkProfileOutputResponseBody: Equatable {
}

extension AssociateDeviceWithNetworkProfileOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct AssociateDeviceWithRoomInputBodyMiddleware: Middleware {
    public let id: String = "AssociateDeviceWithRoomInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateDeviceWithRoomInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateDeviceWithRoomOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateDeviceWithRoomInput>
    public typealias MOutput = OperationOutput<AssociateDeviceWithRoomOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateDeviceWithRoomOutputError>
}

extension AssociateDeviceWithRoomInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateDeviceWithRoomInput(deviceArn: \(String(describing: deviceArn)), roomArn: \(String(describing: roomArn)))"}
}

extension AssociateDeviceWithRoomInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case deviceArn = "DeviceArn"
        case roomArn = "RoomArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceArn = deviceArn {
            try encodeContainer.encode(deviceArn, forKey: .deviceArn)
        }
        if let roomArn = roomArn {
            try encodeContainer.encode(roomArn, forKey: .roomArn)
        }
    }
}

public struct AssociateDeviceWithRoomInputHeadersMiddleware: Middleware {
    public let id: String = "AssociateDeviceWithRoomInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateDeviceWithRoomInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateDeviceWithRoomOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateDeviceWithRoomInput>
    public typealias MOutput = OperationOutput<AssociateDeviceWithRoomOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateDeviceWithRoomOutputError>
}

public struct AssociateDeviceWithRoomInputQueryItemMiddleware: Middleware {
    public let id: String = "AssociateDeviceWithRoomInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateDeviceWithRoomInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateDeviceWithRoomOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateDeviceWithRoomInput>
    public typealias MOutput = OperationOutput<AssociateDeviceWithRoomOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateDeviceWithRoomOutputError>
}

public struct AssociateDeviceWithRoomInput: Equatable {
    /// <p>The ARN of the device to associate to a room. Required.</p>
    public let deviceArn: String?
    /// <p>The ARN of the room with which to associate the device. Required.</p>
    public let roomArn: String?

    public init (
        deviceArn: String? = nil,
        roomArn: String? = nil
    )
    {
        self.deviceArn = deviceArn
        self.roomArn = roomArn
    }
}

struct AssociateDeviceWithRoomInputBody: Equatable {
    public let deviceArn: String?
    public let roomArn: String?
}

extension AssociateDeviceWithRoomInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case deviceArn = "DeviceArn"
        case roomArn = "RoomArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deviceArn)
        deviceArn = deviceArnDecoded
        let roomArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roomArn)
        roomArn = roomArnDecoded
    }
}

extension AssociateDeviceWithRoomOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateDeviceWithRoomOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DeviceNotRegisteredException" : self = .deviceNotRegisteredException(try DeviceNotRegisteredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateDeviceWithRoomOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case deviceNotRegisteredException(DeviceNotRegisteredException)
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateDeviceWithRoomOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateDeviceWithRoomOutputResponse()"}
}

extension AssociateDeviceWithRoomOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct AssociateDeviceWithRoomOutputResponse: Equatable {

    public init() {}
}

struct AssociateDeviceWithRoomOutputResponseBody: Equatable {
}

extension AssociateDeviceWithRoomOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct AssociateSkillGroupWithRoomInputBodyMiddleware: Middleware {
    public let id: String = "AssociateSkillGroupWithRoomInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateSkillGroupWithRoomInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateSkillGroupWithRoomOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateSkillGroupWithRoomInput>
    public typealias MOutput = OperationOutput<AssociateSkillGroupWithRoomOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateSkillGroupWithRoomOutputError>
}

extension AssociateSkillGroupWithRoomInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateSkillGroupWithRoomInput(roomArn: \(String(describing: roomArn)), skillGroupArn: \(String(describing: skillGroupArn)))"}
}

extension AssociateSkillGroupWithRoomInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case roomArn = "RoomArn"
        case skillGroupArn = "SkillGroupArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let roomArn = roomArn {
            try encodeContainer.encode(roomArn, forKey: .roomArn)
        }
        if let skillGroupArn = skillGroupArn {
            try encodeContainer.encode(skillGroupArn, forKey: .skillGroupArn)
        }
    }
}

public struct AssociateSkillGroupWithRoomInputHeadersMiddleware: Middleware {
    public let id: String = "AssociateSkillGroupWithRoomInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateSkillGroupWithRoomInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateSkillGroupWithRoomOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateSkillGroupWithRoomInput>
    public typealias MOutput = OperationOutput<AssociateSkillGroupWithRoomOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateSkillGroupWithRoomOutputError>
}

public struct AssociateSkillGroupWithRoomInputQueryItemMiddleware: Middleware {
    public let id: String = "AssociateSkillGroupWithRoomInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateSkillGroupWithRoomInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateSkillGroupWithRoomOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateSkillGroupWithRoomInput>
    public typealias MOutput = OperationOutput<AssociateSkillGroupWithRoomOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateSkillGroupWithRoomOutputError>
}

public struct AssociateSkillGroupWithRoomInput: Equatable {
    /// <p>The ARN of the room with which to associate the skill group. Required.</p>
    public let roomArn: String?
    /// <p>The ARN of the skill group to associate with a room. Required.</p>
    public let skillGroupArn: String?

    public init (
        roomArn: String? = nil,
        skillGroupArn: String? = nil
    )
    {
        self.roomArn = roomArn
        self.skillGroupArn = skillGroupArn
    }
}

struct AssociateSkillGroupWithRoomInputBody: Equatable {
    public let skillGroupArn: String?
    public let roomArn: String?
}

extension AssociateSkillGroupWithRoomInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case roomArn = "RoomArn"
        case skillGroupArn = "SkillGroupArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let skillGroupArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .skillGroupArn)
        skillGroupArn = skillGroupArnDecoded
        let roomArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roomArn)
        roomArn = roomArnDecoded
    }
}

extension AssociateSkillGroupWithRoomOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateSkillGroupWithRoomOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateSkillGroupWithRoomOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateSkillGroupWithRoomOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateSkillGroupWithRoomOutputResponse()"}
}

extension AssociateSkillGroupWithRoomOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct AssociateSkillGroupWithRoomOutputResponse: Equatable {

    public init() {}
}

struct AssociateSkillGroupWithRoomOutputResponseBody: Equatable {
}

extension AssociateSkillGroupWithRoomOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct AssociateSkillWithSkillGroupInputBodyMiddleware: Middleware {
    public let id: String = "AssociateSkillWithSkillGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateSkillWithSkillGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateSkillWithSkillGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateSkillWithSkillGroupInput>
    public typealias MOutput = OperationOutput<AssociateSkillWithSkillGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateSkillWithSkillGroupOutputError>
}

extension AssociateSkillWithSkillGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateSkillWithSkillGroupInput(skillGroupArn: \(String(describing: skillGroupArn)), skillId: \(String(describing: skillId)))"}
}

extension AssociateSkillWithSkillGroupInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case skillGroupArn = "SkillGroupArn"
        case skillId = "SkillId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let skillGroupArn = skillGroupArn {
            try encodeContainer.encode(skillGroupArn, forKey: .skillGroupArn)
        }
        if let skillId = skillId {
            try encodeContainer.encode(skillId, forKey: .skillId)
        }
    }
}

public struct AssociateSkillWithSkillGroupInputHeadersMiddleware: Middleware {
    public let id: String = "AssociateSkillWithSkillGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateSkillWithSkillGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateSkillWithSkillGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateSkillWithSkillGroupInput>
    public typealias MOutput = OperationOutput<AssociateSkillWithSkillGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateSkillWithSkillGroupOutputError>
}

public struct AssociateSkillWithSkillGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "AssociateSkillWithSkillGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateSkillWithSkillGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateSkillWithSkillGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateSkillWithSkillGroupInput>
    public typealias MOutput = OperationOutput<AssociateSkillWithSkillGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateSkillWithSkillGroupOutputError>
}

public struct AssociateSkillWithSkillGroupInput: Equatable {
    /// <p>The ARN of the skill group to associate the skill to. Required.</p>
    public let skillGroupArn: String?
    /// <p>The unique identifier of the skill.</p>
    public let skillId: String?

    public init (
        skillGroupArn: String? = nil,
        skillId: String? = nil
    )
    {
        self.skillGroupArn = skillGroupArn
        self.skillId = skillId
    }
}

struct AssociateSkillWithSkillGroupInputBody: Equatable {
    public let skillGroupArn: String?
    public let skillId: String?
}

extension AssociateSkillWithSkillGroupInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case skillGroupArn = "SkillGroupArn"
        case skillId = "SkillId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let skillGroupArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .skillGroupArn)
        skillGroupArn = skillGroupArnDecoded
        let skillIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .skillId)
        skillId = skillIdDecoded
    }
}

extension AssociateSkillWithSkillGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateSkillWithSkillGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SkillNotLinkedException" : self = .skillNotLinkedException(try SkillNotLinkedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateSkillWithSkillGroupOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case notFoundException(NotFoundException)
    case skillNotLinkedException(SkillNotLinkedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateSkillWithSkillGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateSkillWithSkillGroupOutputResponse()"}
}

extension AssociateSkillWithSkillGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct AssociateSkillWithSkillGroupOutputResponse: Equatable {

    public init() {}
}

struct AssociateSkillWithSkillGroupOutputResponseBody: Equatable {
}

extension AssociateSkillWithSkillGroupOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct AssociateSkillWithUsersInputBodyMiddleware: Middleware {
    public let id: String = "AssociateSkillWithUsersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateSkillWithUsersInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateSkillWithUsersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateSkillWithUsersInput>
    public typealias MOutput = OperationOutput<AssociateSkillWithUsersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateSkillWithUsersOutputError>
}

extension AssociateSkillWithUsersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateSkillWithUsersInput(skillId: \(String(describing: skillId)))"}
}

extension AssociateSkillWithUsersInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case skillId = "SkillId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let skillId = skillId {
            try encodeContainer.encode(skillId, forKey: .skillId)
        }
    }
}

public struct AssociateSkillWithUsersInputHeadersMiddleware: Middleware {
    public let id: String = "AssociateSkillWithUsersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateSkillWithUsersInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateSkillWithUsersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateSkillWithUsersInput>
    public typealias MOutput = OperationOutput<AssociateSkillWithUsersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateSkillWithUsersOutputError>
}

public struct AssociateSkillWithUsersInputQueryItemMiddleware: Middleware {
    public let id: String = "AssociateSkillWithUsersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateSkillWithUsersInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateSkillWithUsersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateSkillWithUsersInput>
    public typealias MOutput = OperationOutput<AssociateSkillWithUsersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateSkillWithUsersOutputError>
}

public struct AssociateSkillWithUsersInput: Equatable {
    /// <p>The private skill ID you want to make available to enrolled users.</p>
    public let skillId: String?

    public init (
        skillId: String? = nil
    )
    {
        self.skillId = skillId
    }
}

struct AssociateSkillWithUsersInputBody: Equatable {
    public let skillId: String?
}

extension AssociateSkillWithUsersInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case skillId = "SkillId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let skillIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .skillId)
        skillId = skillIdDecoded
    }
}

extension AssociateSkillWithUsersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateSkillWithUsersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateSkillWithUsersOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateSkillWithUsersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateSkillWithUsersOutputResponse()"}
}

extension AssociateSkillWithUsersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct AssociateSkillWithUsersOutputResponse: Equatable {

    public init() {}
}

struct AssociateSkillWithUsersOutputResponseBody: Equatable {
}

extension AssociateSkillWithUsersOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension Audio: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case locale = "Locale"
        case location = "Location"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let locale = locale {
            try encodeContainer.encode(locale.rawValue, forKey: .locale)
        }
        if let location = location {
            try encodeContainer.encode(location, forKey: .location)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let localeDecoded = try containerValues.decodeIfPresent(Locale.self, forKey: .locale)
        locale = localeDecoded
        let locationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .location)
        location = locationDecoded
    }
}

extension Audio: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Audio(locale: \(String(describing: locale)), location: \(String(describing: location)))"}
}

/// <p>The audio message. There is a 1 MB limit on the audio file input and the only supported
///          format is MP3. To convert your MP3 audio files to an Alexa-friendly,  </p>
///          <p>required codec version (MPEG version 2) and bit rate (48 kbps), you might use converter
///          software. One option for this is a command-line tool, FFmpeg. For more information, see
///             <a href="https://www.ffmpeg.org/">FFmpeg</a>. The following command converts the
///          provided <input-file> to an MP3 file that is played in the announcement:</p>
///          <p>
///             <code>ffmpeg -i <input-file> -ac 2 -codec:a libmp3lame -b:a 48k -ar 16000
///             <output-file.mp3></code>
///          </p>
public struct Audio: Equatable {
    /// <p>The locale of the audio message. Currently, en-US is supported.</p>
    public let locale: Locale?
    /// <p>The location of the audio file. Currently, S3 URLs are supported. Only S3 locations
    ///          comprised of safe characters are valid. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingMetadata.html#Safe%20Characters">Safe Characters</a>.</p>
    public let location: String?

    public init (
        locale: Locale? = nil,
        location: String? = nil
    )
    {
        self.locale = locale
        self.location = location
    }
}

extension BusinessReport: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case deliveryTime = "DeliveryTime"
        case downloadUrl = "DownloadUrl"
        case failureCode = "FailureCode"
        case s3Location = "S3Location"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deliveryTime = deliveryTime {
            try encodeContainer.encode(deliveryTime.timeIntervalSince1970, forKey: .deliveryTime)
        }
        if let downloadUrl = downloadUrl {
            try encodeContainer.encode(downloadUrl, forKey: .downloadUrl)
        }
        if let failureCode = failureCode {
            try encodeContainer.encode(failureCode.rawValue, forKey: .failureCode)
        }
        if let s3Location = s3Location {
            try encodeContainer.encode(s3Location, forKey: .s3Location)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(BusinessReportStatus.self, forKey: .status)
        status = statusDecoded
        let failureCodeDecoded = try containerValues.decodeIfPresent(BusinessReportFailureCode.self, forKey: .failureCode)
        failureCode = failureCodeDecoded
        let s3LocationDecoded = try containerValues.decodeIfPresent(BusinessReportS3Location.self, forKey: .s3Location)
        s3Location = s3LocationDecoded
        let deliveryTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .deliveryTime)
        deliveryTime = deliveryTimeDecoded
        let downloadUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .downloadUrl)
        downloadUrl = downloadUrlDecoded
    }
}

extension BusinessReport: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BusinessReport(deliveryTime: \(String(describing: deliveryTime)), downloadUrl: \(String(describing: downloadUrl)), failureCode: \(String(describing: failureCode)), s3Location: \(String(describing: s3Location)), status: \(String(describing: status)))"}
}

/// <p>Usage report with specified parameters.</p>
public struct BusinessReport: Equatable {
    /// <p>The time of report delivery.</p>
    public let deliveryTime: Date?
    /// <p>The download link where a user can download the report.</p>
    public let downloadUrl: String?
    /// <p>The failure code.</p>
    public let failureCode: BusinessReportFailureCode?
    /// <p>The S3 location of the output reports.</p>
    public let s3Location: BusinessReportS3Location?
    /// <p>The status of the report generation execution (RUNNING, SUCCEEDED, or
    ///          FAILED).</p>
    public let status: BusinessReportStatus?

    public init (
        deliveryTime: Date? = nil,
        downloadUrl: String? = nil,
        failureCode: BusinessReportFailureCode? = nil,
        s3Location: BusinessReportS3Location? = nil,
        status: BusinessReportStatus? = nil
    )
    {
        self.deliveryTime = deliveryTime
        self.downloadUrl = downloadUrl
        self.failureCode = failureCode
        self.s3Location = s3Location
        self.status = status
    }
}

extension BusinessReportContentRange: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case interval = "Interval"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let interval = interval {
            try encodeContainer.encode(interval.rawValue, forKey: .interval)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let intervalDecoded = try containerValues.decodeIfPresent(BusinessReportInterval.self, forKey: .interval)
        interval = intervalDecoded
    }
}

extension BusinessReportContentRange: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BusinessReportContentRange(interval: \(String(describing: interval)))"}
}

/// <p>The content range of the report.</p>
public struct BusinessReportContentRange: Equatable {
    /// <p>The interval of the content range.</p>
    public let interval: BusinessReportInterval?

    public init (
        interval: BusinessReportInterval? = nil
    )
    {
        self.interval = interval
    }
}

public enum BusinessReportFailureCode {
    case accessDenied
    case internalFailure
    case noSuchBucket
    case sdkUnknown(String)
}

extension BusinessReportFailureCode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [BusinessReportFailureCode] {
        return [
            .accessDenied,
            .internalFailure,
            .noSuchBucket,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .accessDenied: return "ACCESS_DENIED"
        case .internalFailure: return "INTERNAL_FAILURE"
        case .noSuchBucket: return "NO_SUCH_BUCKET"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = BusinessReportFailureCode(rawValue: rawValue) ?? BusinessReportFailureCode.sdkUnknown(rawValue)
    }
}

public enum BusinessReportFormat {
    case csv
    case csvZip
    case sdkUnknown(String)
}

extension BusinessReportFormat : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [BusinessReportFormat] {
        return [
            .csv,
            .csvZip,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .csv: return "CSV"
        case .csvZip: return "CSV_ZIP"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = BusinessReportFormat(rawValue: rawValue) ?? BusinessReportFormat.sdkUnknown(rawValue)
    }
}

public enum BusinessReportInterval {
    case oneDay
    case oneWeek
    case thirtyDays
    case sdkUnknown(String)
}

extension BusinessReportInterval : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [BusinessReportInterval] {
        return [
            .oneDay,
            .oneWeek,
            .thirtyDays,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .oneDay: return "ONE_DAY"
        case .oneWeek: return "ONE_WEEK"
        case .thirtyDays: return "THIRTY_DAYS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = BusinessReportInterval(rawValue: rawValue) ?? BusinessReportInterval.sdkUnknown(rawValue)
    }
}

extension BusinessReportRecurrence: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case startDate = "StartDate"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let startDate = startDate {
            try encodeContainer.encode(startDate, forKey: .startDate)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .startDate)
        startDate = startDateDecoded
    }
}

extension BusinessReportRecurrence: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BusinessReportRecurrence(startDate: \(String(describing: startDate)))"}
}

/// <p>The recurrence of the reports.</p>
public struct BusinessReportRecurrence: Equatable {
    /// <p>The start date.</p>
    public let startDate: String?

    public init (
        startDate: String? = nil
    )
    {
        self.startDate = startDate
    }
}

extension BusinessReportS3Location: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bucketName = "BucketName"
        case path = "Path"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketName = bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
        if let path = path {
            try encodeContainer.encode(path, forKey: .path)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .path)
        path = pathDecoded
        let bucketNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
    }
}

extension BusinessReportS3Location: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BusinessReportS3Location(bucketName: \(String(describing: bucketName)), path: \(String(describing: path)))"}
}

/// <p>The S3 location of the output reports.</p>
public struct BusinessReportS3Location: Equatable {
    /// <p>The S3 bucket name of the output reports.</p>
    public let bucketName: String?
    /// <p>The path of the business report.</p>
    public let path: String?

    public init (
        bucketName: String? = nil,
        path: String? = nil
    )
    {
        self.bucketName = bucketName
        self.path = path
    }
}

extension BusinessReportSchedule: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case contentRange = "ContentRange"
        case format = "Format"
        case lastBusinessReport = "LastBusinessReport"
        case recurrence = "Recurrence"
        case s3BucketName = "S3BucketName"
        case s3KeyPrefix = "S3KeyPrefix"
        case scheduleArn = "ScheduleArn"
        case scheduleName = "ScheduleName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contentRange = contentRange {
            try encodeContainer.encode(contentRange, forKey: .contentRange)
        }
        if let format = format {
            try encodeContainer.encode(format.rawValue, forKey: .format)
        }
        if let lastBusinessReport = lastBusinessReport {
            try encodeContainer.encode(lastBusinessReport, forKey: .lastBusinessReport)
        }
        if let recurrence = recurrence {
            try encodeContainer.encode(recurrence, forKey: .recurrence)
        }
        if let s3BucketName = s3BucketName {
            try encodeContainer.encode(s3BucketName, forKey: .s3BucketName)
        }
        if let s3KeyPrefix = s3KeyPrefix {
            try encodeContainer.encode(s3KeyPrefix, forKey: .s3KeyPrefix)
        }
        if let scheduleArn = scheduleArn {
            try encodeContainer.encode(scheduleArn, forKey: .scheduleArn)
        }
        if let scheduleName = scheduleName {
            try encodeContainer.encode(scheduleName, forKey: .scheduleName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scheduleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .scheduleArn)
        scheduleArn = scheduleArnDecoded
        let scheduleNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .scheduleName)
        scheduleName = scheduleNameDecoded
        let s3BucketNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3BucketName)
        s3BucketName = s3BucketNameDecoded
        let s3KeyPrefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3KeyPrefix)
        s3KeyPrefix = s3KeyPrefixDecoded
        let formatDecoded = try containerValues.decodeIfPresent(BusinessReportFormat.self, forKey: .format)
        format = formatDecoded
        let contentRangeDecoded = try containerValues.decodeIfPresent(BusinessReportContentRange.self, forKey: .contentRange)
        contentRange = contentRangeDecoded
        let recurrenceDecoded = try containerValues.decodeIfPresent(BusinessReportRecurrence.self, forKey: .recurrence)
        recurrence = recurrenceDecoded
        let lastBusinessReportDecoded = try containerValues.decodeIfPresent(BusinessReport.self, forKey: .lastBusinessReport)
        lastBusinessReport = lastBusinessReportDecoded
    }
}

extension BusinessReportSchedule: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BusinessReportSchedule(contentRange: \(String(describing: contentRange)), format: \(String(describing: format)), lastBusinessReport: \(String(describing: lastBusinessReport)), recurrence: \(String(describing: recurrence)), s3BucketName: \(String(describing: s3BucketName)), s3KeyPrefix: \(String(describing: s3KeyPrefix)), scheduleArn: \(String(describing: scheduleArn)), scheduleName: \(String(describing: scheduleName)))"}
}

/// <p>The schedule of the usage report.</p>
public struct BusinessReportSchedule: Equatable {
    /// <p>The content range of the reports.</p>
    public let contentRange: BusinessReportContentRange?
    /// <p>The format of the generated report (individual CSV files or zipped files of
    ///          individual files).</p>
    public let format: BusinessReportFormat?
    /// <p>The details of the last business report delivery for a specified time
    ///          interval.</p>
    public let lastBusinessReport: BusinessReport?
    /// <p>The recurrence of the reports.</p>
    public let recurrence: BusinessReportRecurrence?
    /// <p>The S3 bucket name of the output reports.</p>
    public let s3BucketName: String?
    /// <p>The S3 key where the report is delivered.</p>
    public let s3KeyPrefix: String?
    /// <p>The ARN of the business report schedule.</p>
    public let scheduleArn: String?
    /// <p>The name identifier of the schedule.</p>
    public let scheduleName: String?

    public init (
        contentRange: BusinessReportContentRange? = nil,
        format: BusinessReportFormat? = nil,
        lastBusinessReport: BusinessReport? = nil,
        recurrence: BusinessReportRecurrence? = nil,
        s3BucketName: String? = nil,
        s3KeyPrefix: String? = nil,
        scheduleArn: String? = nil,
        scheduleName: String? = nil
    )
    {
        self.contentRange = contentRange
        self.format = format
        self.lastBusinessReport = lastBusinessReport
        self.recurrence = recurrence
        self.s3BucketName = s3BucketName
        self.s3KeyPrefix = s3KeyPrefix
        self.scheduleArn = scheduleArn
        self.scheduleName = scheduleName
    }
}

public enum BusinessReportStatus {
    case failed
    case running
    case succeeded
    case sdkUnknown(String)
}

extension BusinessReportStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [BusinessReportStatus] {
        return [
            .failed,
            .running,
            .succeeded,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .failed: return "FAILED"
        case .running: return "RUNNING"
        case .succeeded: return "SUCCEEDED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = BusinessReportStatus(rawValue: rawValue) ?? BusinessReportStatus.sdkUnknown(rawValue)
    }
}

extension Category: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case categoryId = "CategoryId"
        case categoryName = "CategoryName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let categoryId = categoryId {
            try encodeContainer.encode(categoryId, forKey: .categoryId)
        }
        if let categoryName = categoryName {
            try encodeContainer.encode(categoryName, forKey: .categoryName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let categoryIdDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .categoryId)
        categoryId = categoryIdDecoded
        let categoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .categoryName)
        categoryName = categoryNameDecoded
    }
}

extension Category: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Category(categoryId: \(String(describing: categoryId)), categoryName: \(String(describing: categoryName)))"}
}

/// <p>The skill store category that is shown. Alexa skills are assigned a specific skill
///          category during creation, such as News, Social, and Sports.</p>
public struct Category: Equatable {
    /// <p>The ID of the skill store category.</p>
    public let categoryId: Int?
    /// <p>The name of the skill store category.</p>
    public let categoryName: String?

    public init (
        categoryId: Int? = nil,
        categoryName: String? = nil
    )
    {
        self.categoryId = categoryId
        self.categoryName = categoryName
    }
}

public enum CommsProtocol {
    case h323
    case sip
    case sips
    case sdkUnknown(String)
}

extension CommsProtocol : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [CommsProtocol] {
        return [
            .h323,
            .sip,
            .sips,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .h323: return "H323"
        case .sip: return "SIP"
        case .sips: return "SIPS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = CommsProtocol(rawValue: rawValue) ?? CommsProtocol.sdkUnknown(rawValue)
    }
}

extension ConcurrentModificationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConcurrentModificationException(message: \(String(describing: message)))"}
}

extension ConcurrentModificationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ConcurrentModificationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>There is a concurrent modification of resources.</p>
public struct ConcurrentModificationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ConcurrentModificationExceptionBody: Equatable {
    public let message: String?
}

extension ConcurrentModificationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConferencePreference: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case defaultConferenceProviderArn = "DefaultConferenceProviderArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultConferenceProviderArn = defaultConferenceProviderArn {
            try encodeContainer.encode(defaultConferenceProviderArn, forKey: .defaultConferenceProviderArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let defaultConferenceProviderArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .defaultConferenceProviderArn)
        defaultConferenceProviderArn = defaultConferenceProviderArnDecoded
    }
}

extension ConferencePreference: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConferencePreference(defaultConferenceProviderArn: \(String(describing: defaultConferenceProviderArn)))"}
}

/// <p>The default conference provider that is used if no other scheduled meetings are
///          detected.</p>
public struct ConferencePreference: Equatable {
    /// <p>The ARN of the default conference provider.</p>
    public let defaultConferenceProviderArn: String?

    public init (
        defaultConferenceProviderArn: String? = nil
    )
    {
        self.defaultConferenceProviderArn = defaultConferenceProviderArn
    }
}

extension ConferenceProvider: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case iPDialIn = "IPDialIn"
        case meetingSetting = "MeetingSetting"
        case name = "Name"
        case pSTNDialIn = "PSTNDialIn"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let iPDialIn = iPDialIn {
            try encodeContainer.encode(iPDialIn, forKey: .iPDialIn)
        }
        if let meetingSetting = meetingSetting {
            try encodeContainer.encode(meetingSetting, forKey: .meetingSetting)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let pSTNDialIn = pSTNDialIn {
            try encodeContainer.encode(pSTNDialIn, forKey: .pSTNDialIn)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ConferenceProviderType.self, forKey: .type)
        type = typeDecoded
        let iPDialInDecoded = try containerValues.decodeIfPresent(IPDialIn.self, forKey: .iPDialIn)
        iPDialIn = iPDialInDecoded
        let pSTNDialInDecoded = try containerValues.decodeIfPresent(PSTNDialIn.self, forKey: .pSTNDialIn)
        pSTNDialIn = pSTNDialInDecoded
        let meetingSettingDecoded = try containerValues.decodeIfPresent(MeetingSetting.self, forKey: .meetingSetting)
        meetingSetting = meetingSettingDecoded
    }
}

extension ConferenceProvider: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConferenceProvider(arn: \(String(describing: arn)), iPDialIn: \(String(describing: iPDialIn)), meetingSetting: \(String(describing: meetingSetting)), name: \(String(describing: name)), pSTNDialIn: \(String(describing: pSTNDialIn)), type: \(String(describing: type)))"}
}

/// <p>An entity that provides a conferencing solution. Alexa for Business acts as the voice interface and mediator that connects users to their preferred conference provider. Examples of conference providers include Amazon Chime, Zoom, Cisco, and Polycom. </p>
public struct ConferenceProvider: Equatable {
    /// <p>The ARN of the newly created conference provider.</p>
    public let arn: String?
    /// <p>The IP endpoint and protocol for calling.</p>
    public let iPDialIn: IPDialIn?
    /// <p>The meeting settings for the conference provider.</p>
    public let meetingSetting: MeetingSetting?
    /// <p>The name of the conference provider.</p>
    public let name: String?
    /// <p>The information for PSTN conferencing.</p>
    public let pSTNDialIn: PSTNDialIn?
    /// <p>The type of conference providers.</p>
    public let type: ConferenceProviderType?

    public init (
        arn: String? = nil,
        iPDialIn: IPDialIn? = nil,
        meetingSetting: MeetingSetting? = nil,
        name: String? = nil,
        pSTNDialIn: PSTNDialIn? = nil,
        type: ConferenceProviderType? = nil
    )
    {
        self.arn = arn
        self.iPDialIn = iPDialIn
        self.meetingSetting = meetingSetting
        self.name = name
        self.pSTNDialIn = pSTNDialIn
        self.type = type
    }
}

public enum ConferenceProviderType {
    case bluejeans
    case chime
    case custom
    case fuze
    case googleHangouts
    case polycom
    case ringcentral
    case skypeForBusiness
    case webex
    case zoom
    case sdkUnknown(String)
}

extension ConferenceProviderType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ConferenceProviderType] {
        return [
            .bluejeans,
            .chime,
            .custom,
            .fuze,
            .googleHangouts,
            .polycom,
            .ringcentral,
            .skypeForBusiness,
            .webex,
            .zoom,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .bluejeans: return "BLUEJEANS"
        case .chime: return "CHIME"
        case .custom: return "CUSTOM"
        case .fuze: return "FUZE"
        case .googleHangouts: return "GOOGLE_HANGOUTS"
        case .polycom: return "POLYCOM"
        case .ringcentral: return "RINGCENTRAL"
        case .skypeForBusiness: return "SKYPE_FOR_BUSINESS"
        case .webex: return "WEBEX"
        case .zoom: return "ZOOM"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ConferenceProviderType(rawValue: rawValue) ?? ConferenceProviderType.sdkUnknown(rawValue)
    }
}

public enum ConnectionStatus {
    case offline
    case online
    case sdkUnknown(String)
}

extension ConnectionStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ConnectionStatus] {
        return [
            .offline,
            .online,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .offline: return "OFFLINE"
        case .online: return "ONLINE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ConnectionStatus(rawValue: rawValue) ?? ConnectionStatus.sdkUnknown(rawValue)
    }
}

extension Contact: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case contactArn = "ContactArn"
        case displayName = "DisplayName"
        case firstName = "FirstName"
        case lastName = "LastName"
        case phoneNumber = "PhoneNumber"
        case phoneNumbers = "PhoneNumbers"
        case sipAddresses = "SipAddresses"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactArn = contactArn {
            try encodeContainer.encode(contactArn, forKey: .contactArn)
        }
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let firstName = firstName {
            try encodeContainer.encode(firstName, forKey: .firstName)
        }
        if let lastName = lastName {
            try encodeContainer.encode(lastName, forKey: .lastName)
        }
        if let phoneNumber = phoneNumber {
            try encodeContainer.encode(phoneNumber, forKey: .phoneNumber)
        }
        if let phoneNumbers = phoneNumbers {
            var phoneNumbersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .phoneNumbers)
            for phonenumberlist0 in phoneNumbers {
                try phoneNumbersContainer.encode(phonenumberlist0)
            }
        }
        if let sipAddresses = sipAddresses {
            var sipAddressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sipAddresses)
            for sipaddresslist0 in sipAddresses {
                try sipAddressesContainer.encode(sipaddresslist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .contactArn)
        contactArn = contactArnDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let firstNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .firstName)
        firstName = firstNameDecoded
        let lastNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastName)
        lastName = lastNameDecoded
        let phoneNumberDecoded = try containerValues.decodeIfPresent(String.self, forKey: .phoneNumber)
        phoneNumber = phoneNumberDecoded
        let phoneNumbersContainer = try containerValues.decodeIfPresent([PhoneNumber?].self, forKey: .phoneNumbers)
        var phoneNumbersDecoded0:[PhoneNumber]? = nil
        if let phoneNumbersContainer = phoneNumbersContainer {
            phoneNumbersDecoded0 = [PhoneNumber]()
            for structure0 in phoneNumbersContainer {
                if let structure0 = structure0 {
                    phoneNumbersDecoded0?.append(structure0)
                }
            }
        }
        phoneNumbers = phoneNumbersDecoded0
        let sipAddressesContainer = try containerValues.decodeIfPresent([SipAddress?].self, forKey: .sipAddresses)
        var sipAddressesDecoded0:[SipAddress]? = nil
        if let sipAddressesContainer = sipAddressesContainer {
            sipAddressesDecoded0 = [SipAddress]()
            for structure0 in sipAddressesContainer {
                if let structure0 = structure0 {
                    sipAddressesDecoded0?.append(structure0)
                }
            }
        }
        sipAddresses = sipAddressesDecoded0
    }
}

extension Contact: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Contact(contactArn: \(String(describing: contactArn)), displayName: \(String(describing: displayName)), firstName: \(String(describing: firstName)), lastName: \(String(describing: lastName)), phoneNumber: \(String(describing: phoneNumber)), phoneNumbers: \(String(describing: phoneNumbers)), sipAddresses: \(String(describing: sipAddresses)))"}
}

/// <p>A contact with attributes.</p>
public struct Contact: Equatable {
    /// <p>The ARN of the contact.</p>
    public let contactArn: String?
    /// <p>The name of the contact to display on the console.</p>
    public let displayName: String?
    /// <p>The first name of the contact, used to call the contact on the device.</p>
    public let firstName: String?
    /// <p>The last name of the contact, used to call the contact on the device.</p>
    public let lastName: String?
    /// <p>The phone number of the contact. The phone number type defaults to WORK. You can
    ///          either specify PhoneNumber or PhoneNumbers. We recommend that you use PhoneNumbers, which
    ///          lets you specify the phone number type and multiple numbers.</p>
    public let phoneNumber: String?
    /// <p>The list of phone numbers for the contact.</p>
    public let phoneNumbers: [PhoneNumber]?
    /// <p>The list of SIP addresses for the contact.</p>
    public let sipAddresses: [SipAddress]?

    public init (
        contactArn: String? = nil,
        displayName: String? = nil,
        firstName: String? = nil,
        lastName: String? = nil,
        phoneNumber: String? = nil,
        phoneNumbers: [PhoneNumber]? = nil,
        sipAddresses: [SipAddress]? = nil
    )
    {
        self.contactArn = contactArn
        self.displayName = displayName
        self.firstName = firstName
        self.lastName = lastName
        self.phoneNumber = phoneNumber
        self.phoneNumbers = phoneNumbers
        self.sipAddresses = sipAddresses
    }
}

extension ContactData: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case contactArn = "ContactArn"
        case displayName = "DisplayName"
        case firstName = "FirstName"
        case lastName = "LastName"
        case phoneNumber = "PhoneNumber"
        case phoneNumbers = "PhoneNumbers"
        case sipAddresses = "SipAddresses"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactArn = contactArn {
            try encodeContainer.encode(contactArn, forKey: .contactArn)
        }
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let firstName = firstName {
            try encodeContainer.encode(firstName, forKey: .firstName)
        }
        if let lastName = lastName {
            try encodeContainer.encode(lastName, forKey: .lastName)
        }
        if let phoneNumber = phoneNumber {
            try encodeContainer.encode(phoneNumber, forKey: .phoneNumber)
        }
        if let phoneNumbers = phoneNumbers {
            var phoneNumbersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .phoneNumbers)
            for phonenumberlist0 in phoneNumbers {
                try phoneNumbersContainer.encode(phonenumberlist0)
            }
        }
        if let sipAddresses = sipAddresses {
            var sipAddressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sipAddresses)
            for sipaddresslist0 in sipAddresses {
                try sipAddressesContainer.encode(sipaddresslist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .contactArn)
        contactArn = contactArnDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let firstNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .firstName)
        firstName = firstNameDecoded
        let lastNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastName)
        lastName = lastNameDecoded
        let phoneNumberDecoded = try containerValues.decodeIfPresent(String.self, forKey: .phoneNumber)
        phoneNumber = phoneNumberDecoded
        let phoneNumbersContainer = try containerValues.decodeIfPresent([PhoneNumber?].self, forKey: .phoneNumbers)
        var phoneNumbersDecoded0:[PhoneNumber]? = nil
        if let phoneNumbersContainer = phoneNumbersContainer {
            phoneNumbersDecoded0 = [PhoneNumber]()
            for structure0 in phoneNumbersContainer {
                if let structure0 = structure0 {
                    phoneNumbersDecoded0?.append(structure0)
                }
            }
        }
        phoneNumbers = phoneNumbersDecoded0
        let sipAddressesContainer = try containerValues.decodeIfPresent([SipAddress?].self, forKey: .sipAddresses)
        var sipAddressesDecoded0:[SipAddress]? = nil
        if let sipAddressesContainer = sipAddressesContainer {
            sipAddressesDecoded0 = [SipAddress]()
            for structure0 in sipAddressesContainer {
                if let structure0 = structure0 {
                    sipAddressesDecoded0?.append(structure0)
                }
            }
        }
        sipAddresses = sipAddressesDecoded0
    }
}

extension ContactData: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ContactData(contactArn: \(String(describing: contactArn)), displayName: \(String(describing: displayName)), firstName: \(String(describing: firstName)), lastName: \(String(describing: lastName)), phoneNumber: \(String(describing: phoneNumber)), phoneNumbers: \(String(describing: phoneNumbers)), sipAddresses: \(String(describing: sipAddresses)))"}
}

/// <p>Information related to a contact.</p>
public struct ContactData: Equatable {
    /// <p>The ARN of the contact.</p>
    public let contactArn: String?
    /// <p>The name of the contact to display on the console.</p>
    public let displayName: String?
    /// <p>The first name of the contact, used to call the contact on the device.</p>
    public let firstName: String?
    /// <p>The last name of the contact, used to call the contact on the device.</p>
    public let lastName: String?
    /// <p>The phone number of the contact. The phone number type defaults to WORK. You can
    ///          specify PhoneNumber or PhoneNumbers. We recommend that you use PhoneNumbers, which lets you
    ///          specify the phone number type and multiple numbers.</p>
    public let phoneNumber: String?
    /// <p>The list of phone numbers for the contact.</p>
    public let phoneNumbers: [PhoneNumber]?
    /// <p>The list of SIP addresses for the contact.</p>
    public let sipAddresses: [SipAddress]?

    public init (
        contactArn: String? = nil,
        displayName: String? = nil,
        firstName: String? = nil,
        lastName: String? = nil,
        phoneNumber: String? = nil,
        phoneNumbers: [PhoneNumber]? = nil,
        sipAddresses: [SipAddress]? = nil
    )
    {
        self.contactArn = contactArn
        self.displayName = displayName
        self.firstName = firstName
        self.lastName = lastName
        self.phoneNumber = phoneNumber
        self.phoneNumbers = phoneNumbers
        self.sipAddresses = sipAddresses
    }
}

extension Content: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case audioList = "AudioList"
        case ssmlList = "SsmlList"
        case textList = "TextList"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let audioList = audioList {
            var audioListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .audioList)
            for audiolist0 in audioList {
                try audioListContainer.encode(audiolist0)
            }
        }
        if let ssmlList = ssmlList {
            var ssmlListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ssmlList)
            for ssmllist0 in ssmlList {
                try ssmlListContainer.encode(ssmllist0)
            }
        }
        if let textList = textList {
            var textListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .textList)
            for textlist0 in textList {
                try textListContainer.encode(textlist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textListContainer = try containerValues.decodeIfPresent([Text?].self, forKey: .textList)
        var textListDecoded0:[Text]? = nil
        if let textListContainer = textListContainer {
            textListDecoded0 = [Text]()
            for structure0 in textListContainer {
                if let structure0 = structure0 {
                    textListDecoded0?.append(structure0)
                }
            }
        }
        textList = textListDecoded0
        let ssmlListContainer = try containerValues.decodeIfPresent([Ssml?].self, forKey: .ssmlList)
        var ssmlListDecoded0:[Ssml]? = nil
        if let ssmlListContainer = ssmlListContainer {
            ssmlListDecoded0 = [Ssml]()
            for structure0 in ssmlListContainer {
                if let structure0 = structure0 {
                    ssmlListDecoded0?.append(structure0)
                }
            }
        }
        ssmlList = ssmlListDecoded0
        let audioListContainer = try containerValues.decodeIfPresent([Audio?].self, forKey: .audioList)
        var audioListDecoded0:[Audio]? = nil
        if let audioListContainer = audioListContainer {
            audioListDecoded0 = [Audio]()
            for structure0 in audioListContainer {
                if let structure0 = structure0 {
                    audioListDecoded0?.append(structure0)
                }
            }
        }
        audioList = audioListDecoded0
    }
}

extension Content: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Content(audioList: \(String(describing: audioList)), ssmlList: \(String(describing: ssmlList)), textList: \(String(describing: textList)))"}
}

/// <p>The content definition. This can contain only one text, SSML, or audio list
///          object.</p>
public struct Content: Equatable {
    /// <p>The list of audio messages.</p>
    public let audioList: [Audio]?
    /// <p>The list of SSML messages.</p>
    public let ssmlList: [Ssml]?
    /// <p>The list of text messages.</p>
    public let textList: [Text]?

    public init (
        audioList: [Audio]? = nil,
        ssmlList: [Ssml]? = nil,
        textList: [Text]? = nil
    )
    {
        self.audioList = audioList
        self.ssmlList = ssmlList
        self.textList = textList
    }
}

public struct CreateAddressBookInputBodyMiddleware: Middleware {
    public let id: String = "CreateAddressBookInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAddressBookInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAddressBookOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAddressBookInput>
    public typealias MOutput = OperationOutput<CreateAddressBookOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAddressBookOutputError>
}

extension CreateAddressBookInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateAddressBookInput(clientRequestToken: \(String(describing: clientRequestToken)), description: \(String(describing: description)), name: \(String(describing: name)), tags: \(String(describing: tags)))"}
}

extension CreateAddressBookInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case description = "Description"
        case name = "Name"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateAddressBookInputHeadersMiddleware: Middleware {
    public let id: String = "CreateAddressBookInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAddressBookInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAddressBookOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAddressBookInput>
    public typealias MOutput = OperationOutput<CreateAddressBookOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAddressBookOutputError>
}

public struct CreateAddressBookInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateAddressBookInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAddressBookInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAddressBookOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAddressBookInput>
    public typealias MOutput = OperationOutput<CreateAddressBookOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAddressBookOutputError>
}

public struct CreateAddressBookInput: Equatable {
    /// <p>A unique, user-specified identifier for the request that ensures
    ///          idempotency.</p>
    public var clientRequestToken: String?
    /// <p>The description of the address book.</p>
    public let description: String?
    /// <p>The name of the address book.</p>
    public let name: String?
    /// <p>The tags to be added to the specified resource. Do not provide system tags.</p>
    public let tags: [Tag]?

    public init (
        clientRequestToken: String? = nil,
        description: String? = nil,
        name: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.description = description
        self.name = name
        self.tags = tags
    }
}

struct CreateAddressBookInputBody: Equatable {
    public let name: String?
    public let description: String?
    public let clientRequestToken: String?
    public let tags: [Tag]?
}

extension CreateAddressBookInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case description = "Description"
        case name = "Name"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateAddressBookOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateAddressBookOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AlreadyExistsException" : self = .alreadyExistsException(try AlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateAddressBookOutputError: Equatable {
    case alreadyExistsException(AlreadyExistsException)
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAddressBookOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateAddressBookOutputResponse(addressBookArn: \(String(describing: addressBookArn)))"}
}

extension CreateAddressBookOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateAddressBookOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.addressBookArn = output.addressBookArn
        } else {
            self.addressBookArn = nil
        }
    }
}

public struct CreateAddressBookOutputResponse: Equatable {
    /// <p>The ARN of the newly created address book.</p>
    public let addressBookArn: String?

    public init (
        addressBookArn: String? = nil
    )
    {
        self.addressBookArn = addressBookArn
    }
}

struct CreateAddressBookOutputResponseBody: Equatable {
    public let addressBookArn: String?
}

extension CreateAddressBookOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case addressBookArn = "AddressBookArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addressBookArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .addressBookArn)
        addressBookArn = addressBookArnDecoded
    }
}

public struct CreateBusinessReportScheduleInputBodyMiddleware: Middleware {
    public let id: String = "CreateBusinessReportScheduleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateBusinessReportScheduleInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateBusinessReportScheduleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateBusinessReportScheduleInput>
    public typealias MOutput = OperationOutput<CreateBusinessReportScheduleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateBusinessReportScheduleOutputError>
}

extension CreateBusinessReportScheduleInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateBusinessReportScheduleInput(clientRequestToken: \(String(describing: clientRequestToken)), contentRange: \(String(describing: contentRange)), format: \(String(describing: format)), recurrence: \(String(describing: recurrence)), s3BucketName: \(String(describing: s3BucketName)), s3KeyPrefix: \(String(describing: s3KeyPrefix)), scheduleName: \(String(describing: scheduleName)), tags: \(String(describing: tags)))"}
}

extension CreateBusinessReportScheduleInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case contentRange = "ContentRange"
        case format = "Format"
        case recurrence = "Recurrence"
        case s3BucketName = "S3BucketName"
        case s3KeyPrefix = "S3KeyPrefix"
        case scheduleName = "ScheduleName"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let contentRange = contentRange {
            try encodeContainer.encode(contentRange, forKey: .contentRange)
        }
        if let format = format {
            try encodeContainer.encode(format.rawValue, forKey: .format)
        }
        if let recurrence = recurrence {
            try encodeContainer.encode(recurrence, forKey: .recurrence)
        }
        if let s3BucketName = s3BucketName {
            try encodeContainer.encode(s3BucketName, forKey: .s3BucketName)
        }
        if let s3KeyPrefix = s3KeyPrefix {
            try encodeContainer.encode(s3KeyPrefix, forKey: .s3KeyPrefix)
        }
        if let scheduleName = scheduleName {
            try encodeContainer.encode(scheduleName, forKey: .scheduleName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateBusinessReportScheduleInputHeadersMiddleware: Middleware {
    public let id: String = "CreateBusinessReportScheduleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateBusinessReportScheduleInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateBusinessReportScheduleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateBusinessReportScheduleInput>
    public typealias MOutput = OperationOutput<CreateBusinessReportScheduleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateBusinessReportScheduleOutputError>
}

public struct CreateBusinessReportScheduleInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateBusinessReportScheduleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateBusinessReportScheduleInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateBusinessReportScheduleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateBusinessReportScheduleInput>
    public typealias MOutput = OperationOutput<CreateBusinessReportScheduleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateBusinessReportScheduleOutputError>
}

public struct CreateBusinessReportScheduleInput: Equatable {
    /// <p>The client request token.</p>
    public var clientRequestToken: String?
    /// <p>The content range of the reports.</p>
    public let contentRange: BusinessReportContentRange?
    /// <p>The format of the generated report (individual CSV files or zipped files of
    ///          individual files).</p>
    public let format: BusinessReportFormat?
    /// <p>The recurrence of the reports. If this isn't specified, the report will only be
    ///          delivered one time when the API is called. </p>
    public let recurrence: BusinessReportRecurrence?
    /// <p>The S3 bucket name of the output reports. If this isn't specified, the report can be
    ///          retrieved from a download link by calling ListBusinessReportSchedule. </p>
    public let s3BucketName: String?
    /// <p>The S3 key where the report is delivered.</p>
    public let s3KeyPrefix: String?
    /// <p>The name identifier of the schedule.</p>
    public let scheduleName: String?
    /// <p>The tags for the business report schedule.</p>
    public let tags: [Tag]?

    public init (
        clientRequestToken: String? = nil,
        contentRange: BusinessReportContentRange? = nil,
        format: BusinessReportFormat? = nil,
        recurrence: BusinessReportRecurrence? = nil,
        s3BucketName: String? = nil,
        s3KeyPrefix: String? = nil,
        scheduleName: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.contentRange = contentRange
        self.format = format
        self.recurrence = recurrence
        self.s3BucketName = s3BucketName
        self.s3KeyPrefix = s3KeyPrefix
        self.scheduleName = scheduleName
        self.tags = tags
    }
}

struct CreateBusinessReportScheduleInputBody: Equatable {
    public let scheduleName: String?
    public let s3BucketName: String?
    public let s3KeyPrefix: String?
    public let format: BusinessReportFormat?
    public let contentRange: BusinessReportContentRange?
    public let recurrence: BusinessReportRecurrence?
    public let clientRequestToken: String?
    public let tags: [Tag]?
}

extension CreateBusinessReportScheduleInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case contentRange = "ContentRange"
        case format = "Format"
        case recurrence = "Recurrence"
        case s3BucketName = "S3BucketName"
        case s3KeyPrefix = "S3KeyPrefix"
        case scheduleName = "ScheduleName"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scheduleNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .scheduleName)
        scheduleName = scheduleNameDecoded
        let s3BucketNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3BucketName)
        s3BucketName = s3BucketNameDecoded
        let s3KeyPrefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3KeyPrefix)
        s3KeyPrefix = s3KeyPrefixDecoded
        let formatDecoded = try containerValues.decodeIfPresent(BusinessReportFormat.self, forKey: .format)
        format = formatDecoded
        let contentRangeDecoded = try containerValues.decodeIfPresent(BusinessReportContentRange.self, forKey: .contentRange)
        contentRange = contentRangeDecoded
        let recurrenceDecoded = try containerValues.decodeIfPresent(BusinessReportRecurrence.self, forKey: .recurrence)
        recurrence = recurrenceDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateBusinessReportScheduleOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateBusinessReportScheduleOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AlreadyExistsException" : self = .alreadyExistsException(try AlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateBusinessReportScheduleOutputError: Equatable {
    case alreadyExistsException(AlreadyExistsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateBusinessReportScheduleOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateBusinessReportScheduleOutputResponse(scheduleArn: \(String(describing: scheduleArn)))"}
}

extension CreateBusinessReportScheduleOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateBusinessReportScheduleOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.scheduleArn = output.scheduleArn
        } else {
            self.scheduleArn = nil
        }
    }
}

public struct CreateBusinessReportScheduleOutputResponse: Equatable {
    /// <p>The ARN of the business report schedule.</p>
    public let scheduleArn: String?

    public init (
        scheduleArn: String? = nil
    )
    {
        self.scheduleArn = scheduleArn
    }
}

struct CreateBusinessReportScheduleOutputResponseBody: Equatable {
    public let scheduleArn: String?
}

extension CreateBusinessReportScheduleOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case scheduleArn = "ScheduleArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scheduleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .scheduleArn)
        scheduleArn = scheduleArnDecoded
    }
}

public struct CreateConferenceProviderInputBodyMiddleware: Middleware {
    public let id: String = "CreateConferenceProviderInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateConferenceProviderInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateConferenceProviderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateConferenceProviderInput>
    public typealias MOutput = OperationOutput<CreateConferenceProviderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateConferenceProviderOutputError>
}

extension CreateConferenceProviderInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateConferenceProviderInput(clientRequestToken: \(String(describing: clientRequestToken)), conferenceProviderName: \(String(describing: conferenceProviderName)), conferenceProviderType: \(String(describing: conferenceProviderType)), iPDialIn: \(String(describing: iPDialIn)), meetingSetting: \(String(describing: meetingSetting)), pSTNDialIn: \(String(describing: pSTNDialIn)), tags: \(String(describing: tags)))"}
}

extension CreateConferenceProviderInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case conferenceProviderName = "ConferenceProviderName"
        case conferenceProviderType = "ConferenceProviderType"
        case iPDialIn = "IPDialIn"
        case meetingSetting = "MeetingSetting"
        case pSTNDialIn = "PSTNDialIn"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let conferenceProviderName = conferenceProviderName {
            try encodeContainer.encode(conferenceProviderName, forKey: .conferenceProviderName)
        }
        if let conferenceProviderType = conferenceProviderType {
            try encodeContainer.encode(conferenceProviderType.rawValue, forKey: .conferenceProviderType)
        }
        if let iPDialIn = iPDialIn {
            try encodeContainer.encode(iPDialIn, forKey: .iPDialIn)
        }
        if let meetingSetting = meetingSetting {
            try encodeContainer.encode(meetingSetting, forKey: .meetingSetting)
        }
        if let pSTNDialIn = pSTNDialIn {
            try encodeContainer.encode(pSTNDialIn, forKey: .pSTNDialIn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateConferenceProviderInputHeadersMiddleware: Middleware {
    public let id: String = "CreateConferenceProviderInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateConferenceProviderInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateConferenceProviderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateConferenceProviderInput>
    public typealias MOutput = OperationOutput<CreateConferenceProviderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateConferenceProviderOutputError>
}

public struct CreateConferenceProviderInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateConferenceProviderInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateConferenceProviderInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateConferenceProviderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateConferenceProviderInput>
    public typealias MOutput = OperationOutput<CreateConferenceProviderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateConferenceProviderOutputError>
}

public struct CreateConferenceProviderInput: Equatable {
    /// <p>The request token of the client.</p>
    public var clientRequestToken: String?
    /// <p>The name of the conference provider.</p>
    public let conferenceProviderName: String?
    /// <p>Represents a type within a list of predefined types.</p>
    public let conferenceProviderType: ConferenceProviderType?
    /// <p>The IP endpoint and protocol for calling.</p>
    public let iPDialIn: IPDialIn?
    /// <p>The meeting settings for the conference provider.</p>
    public let meetingSetting: MeetingSetting?
    /// <p>The information for PSTN conferencing.</p>
    public let pSTNDialIn: PSTNDialIn?
    /// <p>The tags to be added to the specified resource. Do not provide system tags.</p>
    public let tags: [Tag]?

    public init (
        clientRequestToken: String? = nil,
        conferenceProviderName: String? = nil,
        conferenceProviderType: ConferenceProviderType? = nil,
        iPDialIn: IPDialIn? = nil,
        meetingSetting: MeetingSetting? = nil,
        pSTNDialIn: PSTNDialIn? = nil,
        tags: [Tag]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.conferenceProviderName = conferenceProviderName
        self.conferenceProviderType = conferenceProviderType
        self.iPDialIn = iPDialIn
        self.meetingSetting = meetingSetting
        self.pSTNDialIn = pSTNDialIn
        self.tags = tags
    }
}

struct CreateConferenceProviderInputBody: Equatable {
    public let conferenceProviderName: String?
    public let conferenceProviderType: ConferenceProviderType?
    public let iPDialIn: IPDialIn?
    public let pSTNDialIn: PSTNDialIn?
    public let meetingSetting: MeetingSetting?
    public let clientRequestToken: String?
    public let tags: [Tag]?
}

extension CreateConferenceProviderInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case conferenceProviderName = "ConferenceProviderName"
        case conferenceProviderType = "ConferenceProviderType"
        case iPDialIn = "IPDialIn"
        case meetingSetting = "MeetingSetting"
        case pSTNDialIn = "PSTNDialIn"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let conferenceProviderNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .conferenceProviderName)
        conferenceProviderName = conferenceProviderNameDecoded
        let conferenceProviderTypeDecoded = try containerValues.decodeIfPresent(ConferenceProviderType.self, forKey: .conferenceProviderType)
        conferenceProviderType = conferenceProviderTypeDecoded
        let iPDialInDecoded = try containerValues.decodeIfPresent(IPDialIn.self, forKey: .iPDialIn)
        iPDialIn = iPDialInDecoded
        let pSTNDialInDecoded = try containerValues.decodeIfPresent(PSTNDialIn.self, forKey: .pSTNDialIn)
        pSTNDialIn = pSTNDialInDecoded
        let meetingSettingDecoded = try containerValues.decodeIfPresent(MeetingSetting.self, forKey: .meetingSetting)
        meetingSetting = meetingSettingDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateConferenceProviderOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateConferenceProviderOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AlreadyExistsException" : self = .alreadyExistsException(try AlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateConferenceProviderOutputError: Equatable {
    case alreadyExistsException(AlreadyExistsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateConferenceProviderOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateConferenceProviderOutputResponse(conferenceProviderArn: \(String(describing: conferenceProviderArn)))"}
}

extension CreateConferenceProviderOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateConferenceProviderOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.conferenceProviderArn = output.conferenceProviderArn
        } else {
            self.conferenceProviderArn = nil
        }
    }
}

public struct CreateConferenceProviderOutputResponse: Equatable {
    /// <p>The ARN of the newly-created conference provider.</p>
    public let conferenceProviderArn: String?

    public init (
        conferenceProviderArn: String? = nil
    )
    {
        self.conferenceProviderArn = conferenceProviderArn
    }
}

struct CreateConferenceProviderOutputResponseBody: Equatable {
    public let conferenceProviderArn: String?
}

extension CreateConferenceProviderOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case conferenceProviderArn = "ConferenceProviderArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let conferenceProviderArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .conferenceProviderArn)
        conferenceProviderArn = conferenceProviderArnDecoded
    }
}

public struct CreateContactInputBodyMiddleware: Middleware {
    public let id: String = "CreateContactInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateContactInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateContactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateContactInput>
    public typealias MOutput = OperationOutput<CreateContactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateContactOutputError>
}

extension CreateContactInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateContactInput(clientRequestToken: \(String(describing: clientRequestToken)), displayName: \(String(describing: displayName)), firstName: \(String(describing: firstName)), lastName: \(String(describing: lastName)), phoneNumber: \(String(describing: phoneNumber)), phoneNumbers: \(String(describing: phoneNumbers)), sipAddresses: \(String(describing: sipAddresses)), tags: \(String(describing: tags)))"}
}

extension CreateContactInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case displayName = "DisplayName"
        case firstName = "FirstName"
        case lastName = "LastName"
        case phoneNumber = "PhoneNumber"
        case phoneNumbers = "PhoneNumbers"
        case sipAddresses = "SipAddresses"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let firstName = firstName {
            try encodeContainer.encode(firstName, forKey: .firstName)
        }
        if let lastName = lastName {
            try encodeContainer.encode(lastName, forKey: .lastName)
        }
        if let phoneNumber = phoneNumber {
            try encodeContainer.encode(phoneNumber, forKey: .phoneNumber)
        }
        if let phoneNumbers = phoneNumbers {
            var phoneNumbersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .phoneNumbers)
            for phonenumberlist0 in phoneNumbers {
                try phoneNumbersContainer.encode(phonenumberlist0)
            }
        }
        if let sipAddresses = sipAddresses {
            var sipAddressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sipAddresses)
            for sipaddresslist0 in sipAddresses {
                try sipAddressesContainer.encode(sipaddresslist0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateContactInputHeadersMiddleware: Middleware {
    public let id: String = "CreateContactInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateContactInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateContactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateContactInput>
    public typealias MOutput = OperationOutput<CreateContactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateContactOutputError>
}

public struct CreateContactInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateContactInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateContactInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateContactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateContactInput>
    public typealias MOutput = OperationOutput<CreateContactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateContactOutputError>
}

public struct CreateContactInput: Equatable {
    /// <p>A unique, user-specified identifier for this request that ensures
    ///          idempotency.</p>
    public var clientRequestToken: String?
    /// <p>The name of the contact to display on the console.</p>
    public let displayName: String?
    /// <p>The first name of the contact that is used to call the contact on the
    ///          device.</p>
    public let firstName: String?
    /// <p>The last name of the contact that is used to call the contact on the
    ///          device.</p>
    public let lastName: String?
    /// <p>The phone number of the contact in E.164 format. The phone number type defaults to
    ///          WORK. You can specify PhoneNumber or PhoneNumbers. We recommend that you use PhoneNumbers,
    ///          which lets you specify the phone number type and multiple numbers.</p>
    public let phoneNumber: String?
    /// <p>The list of phone numbers for the contact.</p>
    public let phoneNumbers: [PhoneNumber]?
    /// <p>The list of SIP addresses for the contact.</p>
    public let sipAddresses: [SipAddress]?
    /// <p>The tags to be added to the specified resource. Do not provide system tags.</p>
    public let tags: [Tag]?

    public init (
        clientRequestToken: String? = nil,
        displayName: String? = nil,
        firstName: String? = nil,
        lastName: String? = nil,
        phoneNumber: String? = nil,
        phoneNumbers: [PhoneNumber]? = nil,
        sipAddresses: [SipAddress]? = nil,
        tags: [Tag]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.displayName = displayName
        self.firstName = firstName
        self.lastName = lastName
        self.phoneNumber = phoneNumber
        self.phoneNumbers = phoneNumbers
        self.sipAddresses = sipAddresses
        self.tags = tags
    }
}

struct CreateContactInputBody: Equatable {
    public let displayName: String?
    public let firstName: String?
    public let lastName: String?
    public let phoneNumber: String?
    public let phoneNumbers: [PhoneNumber]?
    public let sipAddresses: [SipAddress]?
    public let clientRequestToken: String?
    public let tags: [Tag]?
}

extension CreateContactInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case displayName = "DisplayName"
        case firstName = "FirstName"
        case lastName = "LastName"
        case phoneNumber = "PhoneNumber"
        case phoneNumbers = "PhoneNumbers"
        case sipAddresses = "SipAddresses"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let displayNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let firstNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .firstName)
        firstName = firstNameDecoded
        let lastNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastName)
        lastName = lastNameDecoded
        let phoneNumberDecoded = try containerValues.decodeIfPresent(String.self, forKey: .phoneNumber)
        phoneNumber = phoneNumberDecoded
        let phoneNumbersContainer = try containerValues.decodeIfPresent([PhoneNumber?].self, forKey: .phoneNumbers)
        var phoneNumbersDecoded0:[PhoneNumber]? = nil
        if let phoneNumbersContainer = phoneNumbersContainer {
            phoneNumbersDecoded0 = [PhoneNumber]()
            for structure0 in phoneNumbersContainer {
                if let structure0 = structure0 {
                    phoneNumbersDecoded0?.append(structure0)
                }
            }
        }
        phoneNumbers = phoneNumbersDecoded0
        let sipAddressesContainer = try containerValues.decodeIfPresent([SipAddress?].self, forKey: .sipAddresses)
        var sipAddressesDecoded0:[SipAddress]? = nil
        if let sipAddressesContainer = sipAddressesContainer {
            sipAddressesDecoded0 = [SipAddress]()
            for structure0 in sipAddressesContainer {
                if let structure0 = structure0 {
                    sipAddressesDecoded0?.append(structure0)
                }
            }
        }
        sipAddresses = sipAddressesDecoded0
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateContactOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateContactOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AlreadyExistsException" : self = .alreadyExistsException(try AlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateContactOutputError: Equatable {
    case alreadyExistsException(AlreadyExistsException)
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateContactOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateContactOutputResponse(contactArn: \(String(describing: contactArn)))"}
}

extension CreateContactOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateContactOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.contactArn = output.contactArn
        } else {
            self.contactArn = nil
        }
    }
}

public struct CreateContactOutputResponse: Equatable {
    /// <p>The ARN of the newly created address book.</p>
    public let contactArn: String?

    public init (
        contactArn: String? = nil
    )
    {
        self.contactArn = contactArn
    }
}

struct CreateContactOutputResponseBody: Equatable {
    public let contactArn: String?
}

extension CreateContactOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case contactArn = "ContactArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .contactArn)
        contactArn = contactArnDecoded
    }
}

extension CreateEndOfMeetingReminder: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case enabled = "Enabled"
        case reminderAtMinutes = "ReminderAtMinutes"
        case reminderType = "ReminderType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enabled = enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let reminderAtMinutes = reminderAtMinutes {
            var reminderAtMinutesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .reminderAtMinutes)
            for endofmeetingreminderminuteslist0 in reminderAtMinutes {
                try reminderAtMinutesContainer.encode(endofmeetingreminderminuteslist0)
            }
        }
        if let reminderType = reminderType {
            try encodeContainer.encode(reminderType.rawValue, forKey: .reminderType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reminderAtMinutesContainer = try containerValues.decodeIfPresent([Int?].self, forKey: .reminderAtMinutes)
        var reminderAtMinutesDecoded0:[Int]? = nil
        if let reminderAtMinutesContainer = reminderAtMinutesContainer {
            reminderAtMinutesDecoded0 = [Int]()
            for integer0 in reminderAtMinutesContainer {
                if let integer0 = integer0 {
                    reminderAtMinutesDecoded0?.append(integer0)
                }
            }
        }
        reminderAtMinutes = reminderAtMinutesDecoded0
        let reminderTypeDecoded = try containerValues.decodeIfPresent(EndOfMeetingReminderType.self, forKey: .reminderType)
        reminderType = reminderTypeDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .enabled)
        enabled = enabledDecoded
    }
}

extension CreateEndOfMeetingReminder: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateEndOfMeetingReminder(enabled: \(String(describing: enabled)), reminderAtMinutes: \(String(describing: reminderAtMinutes)), reminderType: \(String(describing: reminderType)))"}
}

/// <p>Creates settings for the end of meeting reminder feature that are applied to a room
///          profile. The end of meeting reminder enables Alexa to remind users when a meeting is
///          ending.</p>
public struct CreateEndOfMeetingReminder: Equatable {
    /// <p>Whether an end of meeting reminder is enabled or not.</p>
    public let enabled: Bool?
    /// <p> A range of 3 to 15 minutes that determines when the reminder begins.</p>
    public let reminderAtMinutes: [Int]?
    /// <p>The type of sound that users hear during the end of meeting reminder. </p>
    public let reminderType: EndOfMeetingReminderType?

    public init (
        enabled: Bool? = nil,
        reminderAtMinutes: [Int]? = nil,
        reminderType: EndOfMeetingReminderType? = nil
    )
    {
        self.enabled = enabled
        self.reminderAtMinutes = reminderAtMinutes
        self.reminderType = reminderType
    }
}

public struct CreateGatewayGroupInputBodyMiddleware: Middleware {
    public let id: String = "CreateGatewayGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateGatewayGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateGatewayGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateGatewayGroupInput>
    public typealias MOutput = OperationOutput<CreateGatewayGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateGatewayGroupOutputError>
}

extension CreateGatewayGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateGatewayGroupInput(clientRequestToken: \(String(describing: clientRequestToken)), description: \(String(describing: description)), name: \(String(describing: name)), tags: \(String(describing: tags)))"}
}

extension CreateGatewayGroupInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case description = "Description"
        case name = "Name"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateGatewayGroupInputHeadersMiddleware: Middleware {
    public let id: String = "CreateGatewayGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateGatewayGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateGatewayGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateGatewayGroupInput>
    public typealias MOutput = OperationOutput<CreateGatewayGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateGatewayGroupOutputError>
}

public struct CreateGatewayGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateGatewayGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateGatewayGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateGatewayGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateGatewayGroupInput>
    public typealias MOutput = OperationOutput<CreateGatewayGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateGatewayGroupOutputError>
}

public struct CreateGatewayGroupInput: Equatable {
    /// <p> A unique, user-specified identifier for the request that ensures idempotency.</p>
    public var clientRequestToken: String?
    /// <p>The description of the gateway group.</p>
    public let description: String?
    /// <p>The name of the gateway group.</p>
    public let name: String?
    /// <p>The tags to be added to the specified resource. Do not provide system tags.</p>
    public let tags: [Tag]?

    public init (
        clientRequestToken: String? = nil,
        description: String? = nil,
        name: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.description = description
        self.name = name
        self.tags = tags
    }
}

struct CreateGatewayGroupInputBody: Equatable {
    public let name: String?
    public let description: String?
    public let clientRequestToken: String?
    public let tags: [Tag]?
}

extension CreateGatewayGroupInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case description = "Description"
        case name = "Name"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateGatewayGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateGatewayGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AlreadyExistsException" : self = .alreadyExistsException(try AlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateGatewayGroupOutputError: Equatable {
    case alreadyExistsException(AlreadyExistsException)
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateGatewayGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateGatewayGroupOutputResponse(gatewayGroupArn: \(String(describing: gatewayGroupArn)))"}
}

extension CreateGatewayGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateGatewayGroupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.gatewayGroupArn = output.gatewayGroupArn
        } else {
            self.gatewayGroupArn = nil
        }
    }
}

public struct CreateGatewayGroupOutputResponse: Equatable {
    /// <p>The ARN of the created gateway group.</p>
    public let gatewayGroupArn: String?

    public init (
        gatewayGroupArn: String? = nil
    )
    {
        self.gatewayGroupArn = gatewayGroupArn
    }
}

struct CreateGatewayGroupOutputResponseBody: Equatable {
    public let gatewayGroupArn: String?
}

extension CreateGatewayGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case gatewayGroupArn = "GatewayGroupArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayGroupArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayGroupArn)
        gatewayGroupArn = gatewayGroupArnDecoded
    }
}

extension CreateInstantBooking: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case durationInMinutes = "DurationInMinutes"
        case enabled = "Enabled"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let durationInMinutes = durationInMinutes {
            try encodeContainer.encode(durationInMinutes, forKey: .durationInMinutes)
        }
        if let enabled = enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let durationInMinutesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .durationInMinutes)
        durationInMinutes = durationInMinutesDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .enabled)
        enabled = enabledDecoded
    }
}

extension CreateInstantBooking: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateInstantBooking(durationInMinutes: \(String(describing: durationInMinutes)), enabled: \(String(describing: enabled)))"}
}

/// <p>Creates settings for the instant booking feature that are applied to a room profile.
///          When users start their meeting with Alexa, Alexa automatically books the room for the
///          configured duration if the room is available.</p>
public struct CreateInstantBooking: Equatable {
    /// <p>Duration between 15 and 240 minutes at increments of 15 that determines how long to book
    ///          an available room when a meeting is started with Alexa.</p>
    public let durationInMinutes: Int?
    /// <p>Whether instant booking is enabled or not.</p>
    public let enabled: Bool?

    public init (
        durationInMinutes: Int? = nil,
        enabled: Bool? = nil
    )
    {
        self.durationInMinutes = durationInMinutes
        self.enabled = enabled
    }
}

extension CreateMeetingRoomConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case endOfMeetingReminder = "EndOfMeetingReminder"
        case instantBooking = "InstantBooking"
        case requireCheckIn = "RequireCheckIn"
        case roomUtilizationMetricsEnabled = "RoomUtilizationMetricsEnabled"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endOfMeetingReminder = endOfMeetingReminder {
            try encodeContainer.encode(endOfMeetingReminder, forKey: .endOfMeetingReminder)
        }
        if let instantBooking = instantBooking {
            try encodeContainer.encode(instantBooking, forKey: .instantBooking)
        }
        if let requireCheckIn = requireCheckIn {
            try encodeContainer.encode(requireCheckIn, forKey: .requireCheckIn)
        }
        if let roomUtilizationMetricsEnabled = roomUtilizationMetricsEnabled {
            try encodeContainer.encode(roomUtilizationMetricsEnabled, forKey: .roomUtilizationMetricsEnabled)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roomUtilizationMetricsEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .roomUtilizationMetricsEnabled)
        roomUtilizationMetricsEnabled = roomUtilizationMetricsEnabledDecoded
        let endOfMeetingReminderDecoded = try containerValues.decodeIfPresent(CreateEndOfMeetingReminder.self, forKey: .endOfMeetingReminder)
        endOfMeetingReminder = endOfMeetingReminderDecoded
        let instantBookingDecoded = try containerValues.decodeIfPresent(CreateInstantBooking.self, forKey: .instantBooking)
        instantBooking = instantBookingDecoded
        let requireCheckInDecoded = try containerValues.decodeIfPresent(CreateRequireCheckIn.self, forKey: .requireCheckIn)
        requireCheckIn = requireCheckInDecoded
    }
}

extension CreateMeetingRoomConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateMeetingRoomConfiguration(endOfMeetingReminder: \(String(describing: endOfMeetingReminder)), instantBooking: \(String(describing: instantBooking)), requireCheckIn: \(String(describing: requireCheckIn)), roomUtilizationMetricsEnabled: \(String(describing: roomUtilizationMetricsEnabled)))"}
}

/// <p>Creates meeting room settings of a room profile.</p>
public struct CreateMeetingRoomConfiguration: Equatable {
    /// <p>Creates settings for the end of meeting reminder feature that are applied to a room
    ///          profile. The end of meeting reminder enables Alexa to remind users when a meeting is
    ///          ending.</p>
    public let endOfMeetingReminder: CreateEndOfMeetingReminder?
    /// <p>Settings to automatically book a room for a configured duration if it's free when joining a meeting with Alexa.</p>
    public let instantBooking: CreateInstantBooking?
    /// <p>Settings for requiring a check in when a room is reserved. Alexa can cancel a room reservation if it's not checked into to make the room available for others. Users can check in by joining the meeting with Alexa or an AVS device, or by saying Alexa, check in.</p>
    public let requireCheckIn: CreateRequireCheckIn?
    /// <p>Whether room utilization metrics are enabled or not.</p>
    public let roomUtilizationMetricsEnabled: Bool?

    public init (
        endOfMeetingReminder: CreateEndOfMeetingReminder? = nil,
        instantBooking: CreateInstantBooking? = nil,
        requireCheckIn: CreateRequireCheckIn? = nil,
        roomUtilizationMetricsEnabled: Bool? = nil
    )
    {
        self.endOfMeetingReminder = endOfMeetingReminder
        self.instantBooking = instantBooking
        self.requireCheckIn = requireCheckIn
        self.roomUtilizationMetricsEnabled = roomUtilizationMetricsEnabled
    }
}

public struct CreateNetworkProfileInputBodyMiddleware: Middleware {
    public let id: String = "CreateNetworkProfileInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateNetworkProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateNetworkProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateNetworkProfileInput>
    public typealias MOutput = OperationOutput<CreateNetworkProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateNetworkProfileOutputError>
}

extension CreateNetworkProfileInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateNetworkProfileInput(certificateAuthorityArn: \(String(describing: certificateAuthorityArn)), clientRequestToken: \(String(describing: clientRequestToken)), currentPassword: \(String(describing: currentPassword)), description: \(String(describing: description)), eapMethod: \(String(describing: eapMethod)), networkProfileName: \(String(describing: networkProfileName)), nextPassword: \(String(describing: nextPassword)), securityType: \(String(describing: securityType)), ssid: \(String(describing: ssid)), tags: \(String(describing: tags)), trustAnchors: \(String(describing: trustAnchors)))"}
}

extension CreateNetworkProfileInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case certificateAuthorityArn = "CertificateAuthorityArn"
        case clientRequestToken = "ClientRequestToken"
        case currentPassword = "CurrentPassword"
        case description = "Description"
        case eapMethod = "EapMethod"
        case networkProfileName = "NetworkProfileName"
        case nextPassword = "NextPassword"
        case securityType = "SecurityType"
        case ssid = "Ssid"
        case tags = "Tags"
        case trustAnchors = "TrustAnchors"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateAuthorityArn = certificateAuthorityArn {
            try encodeContainer.encode(certificateAuthorityArn, forKey: .certificateAuthorityArn)
        }
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let currentPassword = currentPassword {
            try encodeContainer.encode(currentPassword, forKey: .currentPassword)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let eapMethod = eapMethod {
            try encodeContainer.encode(eapMethod.rawValue, forKey: .eapMethod)
        }
        if let networkProfileName = networkProfileName {
            try encodeContainer.encode(networkProfileName, forKey: .networkProfileName)
        }
        if let nextPassword = nextPassword {
            try encodeContainer.encode(nextPassword, forKey: .nextPassword)
        }
        if let securityType = securityType {
            try encodeContainer.encode(securityType.rawValue, forKey: .securityType)
        }
        if let ssid = ssid {
            try encodeContainer.encode(ssid, forKey: .ssid)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let trustAnchors = trustAnchors {
            var trustAnchorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .trustAnchors)
            for trustanchorlist0 in trustAnchors {
                try trustAnchorsContainer.encode(trustanchorlist0)
            }
        }
    }
}

public struct CreateNetworkProfileInputHeadersMiddleware: Middleware {
    public let id: String = "CreateNetworkProfileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateNetworkProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateNetworkProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateNetworkProfileInput>
    public typealias MOutput = OperationOutput<CreateNetworkProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateNetworkProfileOutputError>
}

public struct CreateNetworkProfileInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateNetworkProfileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateNetworkProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateNetworkProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateNetworkProfileInput>
    public typealias MOutput = OperationOutput<CreateNetworkProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateNetworkProfileOutputError>
}

public struct CreateNetworkProfileInput: Equatable {
    /// <p>The ARN of the Private Certificate Authority (PCA) created in AWS Certificate Manager
    ///          (ACM). This is used to issue certificates to the devices. </p>
    public let certificateAuthorityArn: String?
    /// <p>A unique, user-specified identifier for the request that ensures idempotency.</p>
    public var clientRequestToken: String?
    /// <p>The current password of the Wi-Fi network.</p>
    public let currentPassword: String?
    /// <p>Detailed information about a device's network profile.</p>
    public let description: String?
    /// <p>The authentication standard that is used in the EAP framework. Currently, EAP_TLS is
    ///          supported.</p>
    public let eapMethod: NetworkEapMethod?
    /// <p>The name of the network profile associated with a device.</p>
    public let networkProfileName: String?
    /// <p>The next, or subsequent, password of the Wi-Fi network. This password is asynchronously
    ///          transmitted to the device and is used when the password of the network changes to
    ///          NextPassword. </p>
    public let nextPassword: String?
    /// <p>The security type of the Wi-Fi network. This can be WPA2_ENTERPRISE, WPA2_PSK, WPA_PSK,
    ///          WEP, or OPEN.</p>
    public let securityType: NetworkSecurityType?
    /// <p>The SSID of the Wi-Fi network.</p>
    public let ssid: String?
    /// <p>The tags to be added to the specified resource. Do not provide system tags. </p>
    public let tags: [Tag]?
    /// <p>The root certificates of your authentication server that is installed on your devices
    ///          and used to trust your authentication server during EAP negotiation. </p>
    public let trustAnchors: [String]?

    public init (
        certificateAuthorityArn: String? = nil,
        clientRequestToken: String? = nil,
        currentPassword: String? = nil,
        description: String? = nil,
        eapMethod: NetworkEapMethod? = nil,
        networkProfileName: String? = nil,
        nextPassword: String? = nil,
        securityType: NetworkSecurityType? = nil,
        ssid: String? = nil,
        tags: [Tag]? = nil,
        trustAnchors: [String]? = nil
    )
    {
        self.certificateAuthorityArn = certificateAuthorityArn
        self.clientRequestToken = clientRequestToken
        self.currentPassword = currentPassword
        self.description = description
        self.eapMethod = eapMethod
        self.networkProfileName = networkProfileName
        self.nextPassword = nextPassword
        self.securityType = securityType
        self.ssid = ssid
        self.tags = tags
        self.trustAnchors = trustAnchors
    }
}

struct CreateNetworkProfileInputBody: Equatable {
    public let networkProfileName: String?
    public let description: String?
    public let ssid: String?
    public let securityType: NetworkSecurityType?
    public let eapMethod: NetworkEapMethod?
    public let currentPassword: String?
    public let nextPassword: String?
    public let certificateAuthorityArn: String?
    public let trustAnchors: [String]?
    public let clientRequestToken: String?
    public let tags: [Tag]?
}

extension CreateNetworkProfileInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case certificateAuthorityArn = "CertificateAuthorityArn"
        case clientRequestToken = "ClientRequestToken"
        case currentPassword = "CurrentPassword"
        case description = "Description"
        case eapMethod = "EapMethod"
        case networkProfileName = "NetworkProfileName"
        case nextPassword = "NextPassword"
        case securityType = "SecurityType"
        case ssid = "Ssid"
        case tags = "Tags"
        case trustAnchors = "TrustAnchors"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkProfileNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .networkProfileName)
        networkProfileName = networkProfileNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let ssidDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ssid)
        ssid = ssidDecoded
        let securityTypeDecoded = try containerValues.decodeIfPresent(NetworkSecurityType.self, forKey: .securityType)
        securityType = securityTypeDecoded
        let eapMethodDecoded = try containerValues.decodeIfPresent(NetworkEapMethod.self, forKey: .eapMethod)
        eapMethod = eapMethodDecoded
        let currentPasswordDecoded = try containerValues.decodeIfPresent(String.self, forKey: .currentPassword)
        currentPassword = currentPasswordDecoded
        let nextPasswordDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextPassword)
        nextPassword = nextPasswordDecoded
        let certificateAuthorityArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificateAuthorityArn)
        certificateAuthorityArn = certificateAuthorityArnDecoded
        let trustAnchorsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .trustAnchors)
        var trustAnchorsDecoded0:[String]? = nil
        if let trustAnchorsContainer = trustAnchorsContainer {
            trustAnchorsDecoded0 = [String]()
            for string0 in trustAnchorsContainer {
                if let string0 = string0 {
                    trustAnchorsDecoded0?.append(string0)
                }
            }
        }
        trustAnchors = trustAnchorsDecoded0
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateNetworkProfileOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateNetworkProfileOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AlreadyExistsException" : self = .alreadyExistsException(try AlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidCertificateAuthorityException" : self = .invalidCertificateAuthorityException(try InvalidCertificateAuthorityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidServiceLinkedRoleStateException" : self = .invalidServiceLinkedRoleStateException(try InvalidServiceLinkedRoleStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateNetworkProfileOutputError: Equatable {
    case alreadyExistsException(AlreadyExistsException)
    case concurrentModificationException(ConcurrentModificationException)
    case invalidCertificateAuthorityException(InvalidCertificateAuthorityException)
    case invalidServiceLinkedRoleStateException(InvalidServiceLinkedRoleStateException)
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateNetworkProfileOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateNetworkProfileOutputResponse(networkProfileArn: \(String(describing: networkProfileArn)))"}
}

extension CreateNetworkProfileOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateNetworkProfileOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.networkProfileArn = output.networkProfileArn
        } else {
            self.networkProfileArn = nil
        }
    }
}

public struct CreateNetworkProfileOutputResponse: Equatable {
    /// <p>The ARN of the network profile associated with a device.</p>
    public let networkProfileArn: String?

    public init (
        networkProfileArn: String? = nil
    )
    {
        self.networkProfileArn = networkProfileArn
    }
}

struct CreateNetworkProfileOutputResponseBody: Equatable {
    public let networkProfileArn: String?
}

extension CreateNetworkProfileOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case networkProfileArn = "NetworkProfileArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkProfileArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .networkProfileArn)
        networkProfileArn = networkProfileArnDecoded
    }
}

public struct CreateProfileInputBodyMiddleware: Middleware {
    public let id: String = "CreateProfileInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateProfileInput>
    public typealias MOutput = OperationOutput<CreateProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateProfileOutputError>
}

extension CreateProfileInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateProfileInput(address: \(String(describing: address)), clientRequestToken: \(String(describing: clientRequestToken)), dataRetentionOptIn: \(String(describing: dataRetentionOptIn)), distanceUnit: \(String(describing: distanceUnit)), locale: \(String(describing: locale)), maxVolumeLimit: \(String(describing: maxVolumeLimit)), meetingRoomConfiguration: \(String(describing: meetingRoomConfiguration)), pSTNEnabled: \(String(describing: pSTNEnabled)), profileName: \(String(describing: profileName)), setupModeDisabled: \(String(describing: setupModeDisabled)), tags: \(String(describing: tags)), temperatureUnit: \(String(describing: temperatureUnit)), timezone: \(String(describing: timezone)), wakeWord: \(String(describing: wakeWord)))"}
}

extension CreateProfileInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case address = "Address"
        case clientRequestToken = "ClientRequestToken"
        case dataRetentionOptIn = "DataRetentionOptIn"
        case distanceUnit = "DistanceUnit"
        case locale = "Locale"
        case maxVolumeLimit = "MaxVolumeLimit"
        case meetingRoomConfiguration = "MeetingRoomConfiguration"
        case pSTNEnabled = "PSTNEnabled"
        case profileName = "ProfileName"
        case setupModeDisabled = "SetupModeDisabled"
        case tags = "Tags"
        case temperatureUnit = "TemperatureUnit"
        case timezone = "Timezone"
        case wakeWord = "WakeWord"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let address = address {
            try encodeContainer.encode(address, forKey: .address)
        }
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let dataRetentionOptIn = dataRetentionOptIn {
            try encodeContainer.encode(dataRetentionOptIn, forKey: .dataRetentionOptIn)
        }
        if let distanceUnit = distanceUnit {
            try encodeContainer.encode(distanceUnit.rawValue, forKey: .distanceUnit)
        }
        if let locale = locale {
            try encodeContainer.encode(locale, forKey: .locale)
        }
        if let maxVolumeLimit = maxVolumeLimit {
            try encodeContainer.encode(maxVolumeLimit, forKey: .maxVolumeLimit)
        }
        if let meetingRoomConfiguration = meetingRoomConfiguration {
            try encodeContainer.encode(meetingRoomConfiguration, forKey: .meetingRoomConfiguration)
        }
        if let pSTNEnabled = pSTNEnabled {
            try encodeContainer.encode(pSTNEnabled, forKey: .pSTNEnabled)
        }
        if let profileName = profileName {
            try encodeContainer.encode(profileName, forKey: .profileName)
        }
        if let setupModeDisabled = setupModeDisabled {
            try encodeContainer.encode(setupModeDisabled, forKey: .setupModeDisabled)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let temperatureUnit = temperatureUnit {
            try encodeContainer.encode(temperatureUnit.rawValue, forKey: .temperatureUnit)
        }
        if let timezone = timezone {
            try encodeContainer.encode(timezone, forKey: .timezone)
        }
        if let wakeWord = wakeWord {
            try encodeContainer.encode(wakeWord.rawValue, forKey: .wakeWord)
        }
    }
}

public struct CreateProfileInputHeadersMiddleware: Middleware {
    public let id: String = "CreateProfileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateProfileInput>
    public typealias MOutput = OperationOutput<CreateProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateProfileOutputError>
}

public struct CreateProfileInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateProfileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateProfileInput>
    public typealias MOutput = OperationOutput<CreateProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateProfileOutputError>
}

public struct CreateProfileInput: Equatable {
    /// <p>The valid address for the room.</p>
    public let address: String?
    /// <p>The user-specified token that is used during the creation of a profile.</p>
    public var clientRequestToken: String?
    /// <p>Whether data retention of the profile is enabled.</p>
    public let dataRetentionOptIn: Bool?
    /// <p>The distance unit to be used by devices in the profile.</p>
    public let distanceUnit: DistanceUnit?
    /// <p>The locale of the room profile. (This is currently only available to a limited preview audience.)</p>
    public let locale: String?
    /// <p>The maximum volume limit for a room profile.</p>
    public let maxVolumeLimit: Int?
    /// <p>The meeting room settings of a room profile.</p>
    public let meetingRoomConfiguration: CreateMeetingRoomConfiguration?
    /// <p>Whether PSTN calling is enabled.</p>
    public let pSTNEnabled: Bool?
    /// <p>The name of a room profile.</p>
    public let profileName: String?
    /// <p>Whether room profile setup is enabled.</p>
    public let setupModeDisabled: Bool?
    /// <p>The tags for the profile.</p>
    public let tags: [Tag]?
    /// <p>The temperature unit to be used by devices in the profile.</p>
    public let temperatureUnit: TemperatureUnit?
    /// <p>The time zone used by a room profile.</p>
    public let timezone: String?
    /// <p>A wake word for Alexa, Echo, Amazon, or a computer.</p>
    public let wakeWord: WakeWord?

    public init (
        address: String? = nil,
        clientRequestToken: String? = nil,
        dataRetentionOptIn: Bool? = nil,
        distanceUnit: DistanceUnit? = nil,
        locale: String? = nil,
        maxVolumeLimit: Int? = nil,
        meetingRoomConfiguration: CreateMeetingRoomConfiguration? = nil,
        pSTNEnabled: Bool? = nil,
        profileName: String? = nil,
        setupModeDisabled: Bool? = nil,
        tags: [Tag]? = nil,
        temperatureUnit: TemperatureUnit? = nil,
        timezone: String? = nil,
        wakeWord: WakeWord? = nil
    )
    {
        self.address = address
        self.clientRequestToken = clientRequestToken
        self.dataRetentionOptIn = dataRetentionOptIn
        self.distanceUnit = distanceUnit
        self.locale = locale
        self.maxVolumeLimit = maxVolumeLimit
        self.meetingRoomConfiguration = meetingRoomConfiguration
        self.pSTNEnabled = pSTNEnabled
        self.profileName = profileName
        self.setupModeDisabled = setupModeDisabled
        self.tags = tags
        self.temperatureUnit = temperatureUnit
        self.timezone = timezone
        self.wakeWord = wakeWord
    }
}

struct CreateProfileInputBody: Equatable {
    public let profileName: String?
    public let timezone: String?
    public let address: String?
    public let distanceUnit: DistanceUnit?
    public let temperatureUnit: TemperatureUnit?
    public let wakeWord: WakeWord?
    public let locale: String?
    public let clientRequestToken: String?
    public let setupModeDisabled: Bool?
    public let maxVolumeLimit: Int?
    public let pSTNEnabled: Bool?
    public let dataRetentionOptIn: Bool?
    public let meetingRoomConfiguration: CreateMeetingRoomConfiguration?
    public let tags: [Tag]?
}

extension CreateProfileInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case address = "Address"
        case clientRequestToken = "ClientRequestToken"
        case dataRetentionOptIn = "DataRetentionOptIn"
        case distanceUnit = "DistanceUnit"
        case locale = "Locale"
        case maxVolumeLimit = "MaxVolumeLimit"
        case meetingRoomConfiguration = "MeetingRoomConfiguration"
        case pSTNEnabled = "PSTNEnabled"
        case profileName = "ProfileName"
        case setupModeDisabled = "SetupModeDisabled"
        case tags = "Tags"
        case temperatureUnit = "TemperatureUnit"
        case timezone = "Timezone"
        case wakeWord = "WakeWord"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profileNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .profileName)
        profileName = profileNameDecoded
        let timezoneDecoded = try containerValues.decodeIfPresent(String.self, forKey: .timezone)
        timezone = timezoneDecoded
        let addressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .address)
        address = addressDecoded
        let distanceUnitDecoded = try containerValues.decodeIfPresent(DistanceUnit.self, forKey: .distanceUnit)
        distanceUnit = distanceUnitDecoded
        let temperatureUnitDecoded = try containerValues.decodeIfPresent(TemperatureUnit.self, forKey: .temperatureUnit)
        temperatureUnit = temperatureUnitDecoded
        let wakeWordDecoded = try containerValues.decodeIfPresent(WakeWord.self, forKey: .wakeWord)
        wakeWord = wakeWordDecoded
        let localeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .locale)
        locale = localeDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let setupModeDisabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .setupModeDisabled)
        setupModeDisabled = setupModeDisabledDecoded
        let maxVolumeLimitDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxVolumeLimit)
        maxVolumeLimit = maxVolumeLimitDecoded
        let pSTNEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .pSTNEnabled)
        pSTNEnabled = pSTNEnabledDecoded
        let dataRetentionOptInDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .dataRetentionOptIn)
        dataRetentionOptIn = dataRetentionOptInDecoded
        let meetingRoomConfigurationDecoded = try containerValues.decodeIfPresent(CreateMeetingRoomConfiguration.self, forKey: .meetingRoomConfiguration)
        meetingRoomConfiguration = meetingRoomConfigurationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateProfileOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateProfileOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AlreadyExistsException" : self = .alreadyExistsException(try AlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateProfileOutputError: Equatable {
    case alreadyExistsException(AlreadyExistsException)
    case concurrentModificationException(ConcurrentModificationException)
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateProfileOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateProfileOutputResponse(profileArn: \(String(describing: profileArn)))"}
}

extension CreateProfileOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateProfileOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.profileArn = output.profileArn
        } else {
            self.profileArn = nil
        }
    }
}

public struct CreateProfileOutputResponse: Equatable {
    /// <p>The ARN of the newly created room profile in the response.</p>
    public let profileArn: String?

    public init (
        profileArn: String? = nil
    )
    {
        self.profileArn = profileArn
    }
}

struct CreateProfileOutputResponseBody: Equatable {
    public let profileArn: String?
}

extension CreateProfileOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case profileArn = "ProfileArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profileArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .profileArn)
        profileArn = profileArnDecoded
    }
}

extension CreateRequireCheckIn: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case enabled = "Enabled"
        case releaseAfterMinutes = "ReleaseAfterMinutes"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enabled = enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let releaseAfterMinutes = releaseAfterMinutes {
            try encodeContainer.encode(releaseAfterMinutes, forKey: .releaseAfterMinutes)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let releaseAfterMinutesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .releaseAfterMinutes)
        releaseAfterMinutes = releaseAfterMinutesDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .enabled)
        enabled = enabledDecoded
    }
}

extension CreateRequireCheckIn: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateRequireCheckIn(enabled: \(String(describing: enabled)), releaseAfterMinutes: \(String(describing: releaseAfterMinutes)))"}
}

/// <p>Creates settings for the require check in feature that are applied to a room profile. Require check in allows a meeting rooms Alexa or AVS device to prompt the user to check in; otherwise, the room will be released.</p>
public struct CreateRequireCheckIn: Equatable {
    /// <p>Whether require check in is enabled or not.</p>
    public let enabled: Bool?
    /// <p>Duration between 5 and 20 minutes to determine when to release the room if it's not checked into.</p>
    public let releaseAfterMinutes: Int?

    public init (
        enabled: Bool? = nil,
        releaseAfterMinutes: Int? = nil
    )
    {
        self.enabled = enabled
        self.releaseAfterMinutes = releaseAfterMinutes
    }
}

public struct CreateRoomInputBodyMiddleware: Middleware {
    public let id: String = "CreateRoomInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateRoomInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateRoomOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateRoomInput>
    public typealias MOutput = OperationOutput<CreateRoomOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateRoomOutputError>
}

extension CreateRoomInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateRoomInput(clientRequestToken: \(String(describing: clientRequestToken)), description: \(String(describing: description)), profileArn: \(String(describing: profileArn)), providerCalendarId: \(String(describing: providerCalendarId)), roomName: \(String(describing: roomName)), tags: \(String(describing: tags)))"}
}

extension CreateRoomInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case description = "Description"
        case profileArn = "ProfileArn"
        case providerCalendarId = "ProviderCalendarId"
        case roomName = "RoomName"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let profileArn = profileArn {
            try encodeContainer.encode(profileArn, forKey: .profileArn)
        }
        if let providerCalendarId = providerCalendarId {
            try encodeContainer.encode(providerCalendarId, forKey: .providerCalendarId)
        }
        if let roomName = roomName {
            try encodeContainer.encode(roomName, forKey: .roomName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateRoomInputHeadersMiddleware: Middleware {
    public let id: String = "CreateRoomInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateRoomInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateRoomOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateRoomInput>
    public typealias MOutput = OperationOutput<CreateRoomOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateRoomOutputError>
}

public struct CreateRoomInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateRoomInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateRoomInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateRoomOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateRoomInput>
    public typealias MOutput = OperationOutput<CreateRoomOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateRoomOutputError>
}

public struct CreateRoomInput: Equatable {
    /// <p>A unique, user-specified identifier for this request that ensures idempotency.
    ///       </p>
    public var clientRequestToken: String?
    /// <p>The description for the room.</p>
    public let description: String?
    /// <p>The profile ARN for the room. This is required.</p>
    public let profileArn: String?
    /// <p>The calendar ARN for the room.</p>
    public let providerCalendarId: String?
    /// <p>The name for the room.</p>
    public let roomName: String?
    /// <p>The tags for the room.</p>
    public let tags: [Tag]?

    public init (
        clientRequestToken: String? = nil,
        description: String? = nil,
        profileArn: String? = nil,
        providerCalendarId: String? = nil,
        roomName: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.description = description
        self.profileArn = profileArn
        self.providerCalendarId = providerCalendarId
        self.roomName = roomName
        self.tags = tags
    }
}

struct CreateRoomInputBody: Equatable {
    public let roomName: String?
    public let description: String?
    public let profileArn: String?
    public let providerCalendarId: String?
    public let clientRequestToken: String?
    public let tags: [Tag]?
}

extension CreateRoomInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case description = "Description"
        case profileArn = "ProfileArn"
        case providerCalendarId = "ProviderCalendarId"
        case roomName = "RoomName"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roomNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roomName)
        roomName = roomNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let profileArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .profileArn)
        profileArn = profileArnDecoded
        let providerCalendarIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .providerCalendarId)
        providerCalendarId = providerCalendarIdDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateRoomOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateRoomOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AlreadyExistsException" : self = .alreadyExistsException(try AlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateRoomOutputError: Equatable {
    case alreadyExistsException(AlreadyExistsException)
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateRoomOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateRoomOutputResponse(roomArn: \(String(describing: roomArn)))"}
}

extension CreateRoomOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateRoomOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.roomArn = output.roomArn
        } else {
            self.roomArn = nil
        }
    }
}

public struct CreateRoomOutputResponse: Equatable {
    /// <p>The ARN of the newly created room in the response.</p>
    public let roomArn: String?

    public init (
        roomArn: String? = nil
    )
    {
        self.roomArn = roomArn
    }
}

struct CreateRoomOutputResponseBody: Equatable {
    public let roomArn: String?
}

extension CreateRoomOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case roomArn = "RoomArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roomArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roomArn)
        roomArn = roomArnDecoded
    }
}

public struct CreateSkillGroupInputBodyMiddleware: Middleware {
    public let id: String = "CreateSkillGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateSkillGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateSkillGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateSkillGroupInput>
    public typealias MOutput = OperationOutput<CreateSkillGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateSkillGroupOutputError>
}

extension CreateSkillGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateSkillGroupInput(clientRequestToken: \(String(describing: clientRequestToken)), description: \(String(describing: description)), skillGroupName: \(String(describing: skillGroupName)), tags: \(String(describing: tags)))"}
}

extension CreateSkillGroupInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case description = "Description"
        case skillGroupName = "SkillGroupName"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let skillGroupName = skillGroupName {
            try encodeContainer.encode(skillGroupName, forKey: .skillGroupName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateSkillGroupInputHeadersMiddleware: Middleware {
    public let id: String = "CreateSkillGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateSkillGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateSkillGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateSkillGroupInput>
    public typealias MOutput = OperationOutput<CreateSkillGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateSkillGroupOutputError>
}

public struct CreateSkillGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateSkillGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateSkillGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateSkillGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateSkillGroupInput>
    public typealias MOutput = OperationOutput<CreateSkillGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateSkillGroupOutputError>
}

public struct CreateSkillGroupInput: Equatable {
    /// <p>A unique, user-specified identifier for this request that ensures idempotency.
    ///       </p>
    public var clientRequestToken: String?
    /// <p>The description for the skill group.</p>
    public let description: String?
    /// <p>The name for the skill group.</p>
    public let skillGroupName: String?
    /// <p>The tags for the skill group.</p>
    public let tags: [Tag]?

    public init (
        clientRequestToken: String? = nil,
        description: String? = nil,
        skillGroupName: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.description = description
        self.skillGroupName = skillGroupName
        self.tags = tags
    }
}

struct CreateSkillGroupInputBody: Equatable {
    public let skillGroupName: String?
    public let description: String?
    public let clientRequestToken: String?
    public let tags: [Tag]?
}

extension CreateSkillGroupInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case description = "Description"
        case skillGroupName = "SkillGroupName"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let skillGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .skillGroupName)
        skillGroupName = skillGroupNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateSkillGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateSkillGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AlreadyExistsException" : self = .alreadyExistsException(try AlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateSkillGroupOutputError: Equatable {
    case alreadyExistsException(AlreadyExistsException)
    case concurrentModificationException(ConcurrentModificationException)
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateSkillGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateSkillGroupOutputResponse(skillGroupArn: \(String(describing: skillGroupArn)))"}
}

extension CreateSkillGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateSkillGroupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.skillGroupArn = output.skillGroupArn
        } else {
            self.skillGroupArn = nil
        }
    }
}

public struct CreateSkillGroupOutputResponse: Equatable {
    /// <p>The ARN of the newly created skill group in the response.</p>
    public let skillGroupArn: String?

    public init (
        skillGroupArn: String? = nil
    )
    {
        self.skillGroupArn = skillGroupArn
    }
}

struct CreateSkillGroupOutputResponseBody: Equatable {
    public let skillGroupArn: String?
}

extension CreateSkillGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case skillGroupArn = "SkillGroupArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let skillGroupArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .skillGroupArn)
        skillGroupArn = skillGroupArnDecoded
    }
}

public struct CreateUserInputBodyMiddleware: Middleware {
    public let id: String = "CreateUserInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateUserInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateUserInput>
    public typealias MOutput = OperationOutput<CreateUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateUserOutputError>
}

extension CreateUserInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateUserInput(clientRequestToken: \(String(describing: clientRequestToken)), email: \(String(describing: email)), firstName: \(String(describing: firstName)), lastName: \(String(describing: lastName)), tags: \(String(describing: tags)), userId: \(String(describing: userId)))"}
}

extension CreateUserInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case email = "Email"
        case firstName = "FirstName"
        case lastName = "LastName"
        case tags = "Tags"
        case userId = "UserId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let email = email {
            try encodeContainer.encode(email, forKey: .email)
        }
        if let firstName = firstName {
            try encodeContainer.encode(firstName, forKey: .firstName)
        }
        if let lastName = lastName {
            try encodeContainer.encode(lastName, forKey: .lastName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let userId = userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
    }
}

public struct CreateUserInputHeadersMiddleware: Middleware {
    public let id: String = "CreateUserInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateUserInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateUserInput>
    public typealias MOutput = OperationOutput<CreateUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateUserOutputError>
}

public struct CreateUserInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateUserInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateUserInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateUserInput>
    public typealias MOutput = OperationOutput<CreateUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateUserOutputError>
}

public struct CreateUserInput: Equatable {
    /// <p>A unique, user-specified identifier for this request that ensures idempotency.
    ///       </p>
    public var clientRequestToken: String?
    /// <p>The email address for the user.</p>
    public let email: String?
    /// <p>The first name for the user.</p>
    public let firstName: String?
    /// <p>The last name for the user.</p>
    public let lastName: String?
    /// <p>The tags for the user.</p>
    public let tags: [Tag]?
    /// <p>The ARN for the user.</p>
    public let userId: String?

    public init (
        clientRequestToken: String? = nil,
        email: String? = nil,
        firstName: String? = nil,
        lastName: String? = nil,
        tags: [Tag]? = nil,
        userId: String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.email = email
        self.firstName = firstName
        self.lastName = lastName
        self.tags = tags
        self.userId = userId
    }
}

struct CreateUserInputBody: Equatable {
    public let userId: String?
    public let firstName: String?
    public let lastName: String?
    public let email: String?
    public let clientRequestToken: String?
    public let tags: [Tag]?
}

extension CreateUserInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case email = "Email"
        case firstName = "FirstName"
        case lastName = "LastName"
        case tags = "Tags"
        case userId = "UserId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userId)
        userId = userIdDecoded
        let firstNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .firstName)
        firstName = firstNameDecoded
        let lastNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastName)
        lastName = lastNameDecoded
        let emailDecoded = try containerValues.decodeIfPresent(String.self, forKey: .email)
        email = emailDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateUserOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateUserOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateUserOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case limitExceededException(LimitExceededException)
    case resourceInUseException(ResourceInUseException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateUserOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateUserOutputResponse(userArn: \(String(describing: userArn)))"}
}

extension CreateUserOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateUserOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.userArn = output.userArn
        } else {
            self.userArn = nil
        }
    }
}

public struct CreateUserOutputResponse: Equatable {
    /// <p>The ARN of the newly created user in the response.</p>
    public let userArn: String?

    public init (
        userArn: String? = nil
    )
    {
        self.userArn = userArn
    }
}

struct CreateUserOutputResponseBody: Equatable {
    public let userArn: String?
}

extension CreateUserOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case userArn = "UserArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userArn)
        userArn = userArnDecoded
    }
}

public struct DeleteAddressBookInputBodyMiddleware: Middleware {
    public let id: String = "DeleteAddressBookInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAddressBookInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAddressBookOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAddressBookInput>
    public typealias MOutput = OperationOutput<DeleteAddressBookOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAddressBookOutputError>
}

extension DeleteAddressBookInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteAddressBookInput(addressBookArn: \(String(describing: addressBookArn)))"}
}

extension DeleteAddressBookInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case addressBookArn = "AddressBookArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addressBookArn = addressBookArn {
            try encodeContainer.encode(addressBookArn, forKey: .addressBookArn)
        }
    }
}

public struct DeleteAddressBookInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteAddressBookInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAddressBookInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAddressBookOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAddressBookInput>
    public typealias MOutput = OperationOutput<DeleteAddressBookOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAddressBookOutputError>
}

public struct DeleteAddressBookInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteAddressBookInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAddressBookInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAddressBookOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAddressBookInput>
    public typealias MOutput = OperationOutput<DeleteAddressBookOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAddressBookOutputError>
}

public struct DeleteAddressBookInput: Equatable {
    /// <p>The ARN of the address book to delete.</p>
    public let addressBookArn: String?

    public init (
        addressBookArn: String? = nil
    )
    {
        self.addressBookArn = addressBookArn
    }
}

struct DeleteAddressBookInputBody: Equatable {
    public let addressBookArn: String?
}

extension DeleteAddressBookInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case addressBookArn = "AddressBookArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addressBookArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .addressBookArn)
        addressBookArn = addressBookArnDecoded
    }
}

extension DeleteAddressBookOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAddressBookOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteAddressBookOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAddressBookOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteAddressBookOutputResponse()"}
}

extension DeleteAddressBookOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteAddressBookOutputResponse: Equatable {

    public init() {}
}

struct DeleteAddressBookOutputResponseBody: Equatable {
}

extension DeleteAddressBookOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteBusinessReportScheduleInputBodyMiddleware: Middleware {
    public let id: String = "DeleteBusinessReportScheduleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteBusinessReportScheduleInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteBusinessReportScheduleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteBusinessReportScheduleInput>
    public typealias MOutput = OperationOutput<DeleteBusinessReportScheduleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteBusinessReportScheduleOutputError>
}

extension DeleteBusinessReportScheduleInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteBusinessReportScheduleInput(scheduleArn: \(String(describing: scheduleArn)))"}
}

extension DeleteBusinessReportScheduleInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case scheduleArn = "ScheduleArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let scheduleArn = scheduleArn {
            try encodeContainer.encode(scheduleArn, forKey: .scheduleArn)
        }
    }
}

public struct DeleteBusinessReportScheduleInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteBusinessReportScheduleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteBusinessReportScheduleInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteBusinessReportScheduleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteBusinessReportScheduleInput>
    public typealias MOutput = OperationOutput<DeleteBusinessReportScheduleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteBusinessReportScheduleOutputError>
}

public struct DeleteBusinessReportScheduleInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteBusinessReportScheduleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteBusinessReportScheduleInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteBusinessReportScheduleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteBusinessReportScheduleInput>
    public typealias MOutput = OperationOutput<DeleteBusinessReportScheduleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteBusinessReportScheduleOutputError>
}

public struct DeleteBusinessReportScheduleInput: Equatable {
    /// <p>The ARN of the business report schedule.</p>
    public let scheduleArn: String?

    public init (
        scheduleArn: String? = nil
    )
    {
        self.scheduleArn = scheduleArn
    }
}

struct DeleteBusinessReportScheduleInputBody: Equatable {
    public let scheduleArn: String?
}

extension DeleteBusinessReportScheduleInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case scheduleArn = "ScheduleArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scheduleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .scheduleArn)
        scheduleArn = scheduleArnDecoded
    }
}

extension DeleteBusinessReportScheduleOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteBusinessReportScheduleOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteBusinessReportScheduleOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteBusinessReportScheduleOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteBusinessReportScheduleOutputResponse()"}
}

extension DeleteBusinessReportScheduleOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteBusinessReportScheduleOutputResponse: Equatable {

    public init() {}
}

struct DeleteBusinessReportScheduleOutputResponseBody: Equatable {
}

extension DeleteBusinessReportScheduleOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteConferenceProviderInputBodyMiddleware: Middleware {
    public let id: String = "DeleteConferenceProviderInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteConferenceProviderInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteConferenceProviderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteConferenceProviderInput>
    public typealias MOutput = OperationOutput<DeleteConferenceProviderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteConferenceProviderOutputError>
}

extension DeleteConferenceProviderInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteConferenceProviderInput(conferenceProviderArn: \(String(describing: conferenceProviderArn)))"}
}

extension DeleteConferenceProviderInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case conferenceProviderArn = "ConferenceProviderArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let conferenceProviderArn = conferenceProviderArn {
            try encodeContainer.encode(conferenceProviderArn, forKey: .conferenceProviderArn)
        }
    }
}

public struct DeleteConferenceProviderInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteConferenceProviderInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteConferenceProviderInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteConferenceProviderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteConferenceProviderInput>
    public typealias MOutput = OperationOutput<DeleteConferenceProviderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteConferenceProviderOutputError>
}

public struct DeleteConferenceProviderInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteConferenceProviderInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteConferenceProviderInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteConferenceProviderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteConferenceProviderInput>
    public typealias MOutput = OperationOutput<DeleteConferenceProviderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteConferenceProviderOutputError>
}

public struct DeleteConferenceProviderInput: Equatable {
    /// <p>The ARN of the conference provider.</p>
    public let conferenceProviderArn: String?

    public init (
        conferenceProviderArn: String? = nil
    )
    {
        self.conferenceProviderArn = conferenceProviderArn
    }
}

struct DeleteConferenceProviderInputBody: Equatable {
    public let conferenceProviderArn: String?
}

extension DeleteConferenceProviderInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case conferenceProviderArn = "ConferenceProviderArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let conferenceProviderArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .conferenceProviderArn)
        conferenceProviderArn = conferenceProviderArnDecoded
    }
}

extension DeleteConferenceProviderOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteConferenceProviderOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteConferenceProviderOutputError: Equatable {
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteConferenceProviderOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteConferenceProviderOutputResponse()"}
}

extension DeleteConferenceProviderOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteConferenceProviderOutputResponse: Equatable {

    public init() {}
}

struct DeleteConferenceProviderOutputResponseBody: Equatable {
}

extension DeleteConferenceProviderOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteContactInputBodyMiddleware: Middleware {
    public let id: String = "DeleteContactInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteContactInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteContactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteContactInput>
    public typealias MOutput = OperationOutput<DeleteContactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteContactOutputError>
}

extension DeleteContactInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteContactInput(contactArn: \(String(describing: contactArn)))"}
}

extension DeleteContactInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case contactArn = "ContactArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactArn = contactArn {
            try encodeContainer.encode(contactArn, forKey: .contactArn)
        }
    }
}

public struct DeleteContactInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteContactInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteContactInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteContactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteContactInput>
    public typealias MOutput = OperationOutput<DeleteContactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteContactOutputError>
}

public struct DeleteContactInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteContactInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteContactInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteContactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteContactInput>
    public typealias MOutput = OperationOutput<DeleteContactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteContactOutputError>
}

public struct DeleteContactInput: Equatable {
    /// <p>The ARN of the contact to delete.</p>
    public let contactArn: String?

    public init (
        contactArn: String? = nil
    )
    {
        self.contactArn = contactArn
    }
}

struct DeleteContactInputBody: Equatable {
    public let contactArn: String?
}

extension DeleteContactInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case contactArn = "ContactArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .contactArn)
        contactArn = contactArnDecoded
    }
}

extension DeleteContactOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteContactOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteContactOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteContactOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteContactOutputResponse()"}
}

extension DeleteContactOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteContactOutputResponse: Equatable {

    public init() {}
}

struct DeleteContactOutputResponseBody: Equatable {
}

extension DeleteContactOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteDeviceInputBodyMiddleware: Middleware {
    public let id: String = "DeleteDeviceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDeviceInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDeviceInput>
    public typealias MOutput = OperationOutput<DeleteDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDeviceOutputError>
}

extension DeleteDeviceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDeviceInput(deviceArn: \(String(describing: deviceArn)))"}
}

extension DeleteDeviceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case deviceArn = "DeviceArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceArn = deviceArn {
            try encodeContainer.encode(deviceArn, forKey: .deviceArn)
        }
    }
}

public struct DeleteDeviceInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteDeviceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDeviceInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDeviceInput>
    public typealias MOutput = OperationOutput<DeleteDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDeviceOutputError>
}

public struct DeleteDeviceInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteDeviceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDeviceInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDeviceInput>
    public typealias MOutput = OperationOutput<DeleteDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDeviceOutputError>
}

public struct DeleteDeviceInput: Equatable {
    /// <p>The ARN of the device for which to request details.</p>
    public let deviceArn: String?

    public init (
        deviceArn: String? = nil
    )
    {
        self.deviceArn = deviceArn
    }
}

struct DeleteDeviceInputBody: Equatable {
    public let deviceArn: String?
}

extension DeleteDeviceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case deviceArn = "DeviceArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deviceArn)
        deviceArn = deviceArnDecoded
    }
}

extension DeleteDeviceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDeviceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidCertificateAuthorityException" : self = .invalidCertificateAuthorityException(try InvalidCertificateAuthorityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDeviceOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidCertificateAuthorityException(InvalidCertificateAuthorityException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDeviceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDeviceOutputResponse()"}
}

extension DeleteDeviceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDeviceOutputResponse: Equatable {

    public init() {}
}

struct DeleteDeviceOutputResponseBody: Equatable {
}

extension DeleteDeviceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteDeviceUsageDataInputBodyMiddleware: Middleware {
    public let id: String = "DeleteDeviceUsageDataInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDeviceUsageDataInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDeviceUsageDataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDeviceUsageDataInput>
    public typealias MOutput = OperationOutput<DeleteDeviceUsageDataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDeviceUsageDataOutputError>
}

extension DeleteDeviceUsageDataInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDeviceUsageDataInput(deviceArn: \(String(describing: deviceArn)), deviceUsageType: \(String(describing: deviceUsageType)))"}
}

extension DeleteDeviceUsageDataInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case deviceArn = "DeviceArn"
        case deviceUsageType = "DeviceUsageType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceArn = deviceArn {
            try encodeContainer.encode(deviceArn, forKey: .deviceArn)
        }
        if let deviceUsageType = deviceUsageType {
            try encodeContainer.encode(deviceUsageType.rawValue, forKey: .deviceUsageType)
        }
    }
}

public struct DeleteDeviceUsageDataInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteDeviceUsageDataInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDeviceUsageDataInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDeviceUsageDataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDeviceUsageDataInput>
    public typealias MOutput = OperationOutput<DeleteDeviceUsageDataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDeviceUsageDataOutputError>
}

public struct DeleteDeviceUsageDataInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteDeviceUsageDataInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDeviceUsageDataInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDeviceUsageDataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDeviceUsageDataInput>
    public typealias MOutput = OperationOutput<DeleteDeviceUsageDataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDeviceUsageDataOutputError>
}

public struct DeleteDeviceUsageDataInput: Equatable {
    /// <p>The ARN of the device.</p>
    public let deviceArn: String?
    /// <p>The type of usage data to delete.</p>
    public let deviceUsageType: DeviceUsageType?

    public init (
        deviceArn: String? = nil,
        deviceUsageType: DeviceUsageType? = nil
    )
    {
        self.deviceArn = deviceArn
        self.deviceUsageType = deviceUsageType
    }
}

struct DeleteDeviceUsageDataInputBody: Equatable {
    public let deviceArn: String?
    public let deviceUsageType: DeviceUsageType?
}

extension DeleteDeviceUsageDataInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case deviceArn = "DeviceArn"
        case deviceUsageType = "DeviceUsageType"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deviceArn)
        deviceArn = deviceArnDecoded
        let deviceUsageTypeDecoded = try containerValues.decodeIfPresent(DeviceUsageType.self, forKey: .deviceUsageType)
        deviceUsageType = deviceUsageTypeDecoded
    }
}

extension DeleteDeviceUsageDataOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDeviceUsageDataOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DeviceNotRegisteredException" : self = .deviceNotRegisteredException(try DeviceNotRegisteredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDeviceUsageDataOutputError: Equatable {
    case deviceNotRegisteredException(DeviceNotRegisteredException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDeviceUsageDataOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDeviceUsageDataOutputResponse()"}
}

extension DeleteDeviceUsageDataOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDeviceUsageDataOutputResponse: Equatable {

    public init() {}
}

struct DeleteDeviceUsageDataOutputResponseBody: Equatable {
}

extension DeleteDeviceUsageDataOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteGatewayGroupInputBodyMiddleware: Middleware {
    public let id: String = "DeleteGatewayGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteGatewayGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteGatewayGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteGatewayGroupInput>
    public typealias MOutput = OperationOutput<DeleteGatewayGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteGatewayGroupOutputError>
}

extension DeleteGatewayGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteGatewayGroupInput(gatewayGroupArn: \(String(describing: gatewayGroupArn)))"}
}

extension DeleteGatewayGroupInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case gatewayGroupArn = "GatewayGroupArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayGroupArn = gatewayGroupArn {
            try encodeContainer.encode(gatewayGroupArn, forKey: .gatewayGroupArn)
        }
    }
}

public struct DeleteGatewayGroupInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteGatewayGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteGatewayGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteGatewayGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteGatewayGroupInput>
    public typealias MOutput = OperationOutput<DeleteGatewayGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteGatewayGroupOutputError>
}

public struct DeleteGatewayGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteGatewayGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteGatewayGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteGatewayGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteGatewayGroupInput>
    public typealias MOutput = OperationOutput<DeleteGatewayGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteGatewayGroupOutputError>
}

public struct DeleteGatewayGroupInput: Equatable {
    /// <p>The ARN of the gateway group to delete.</p>
    public let gatewayGroupArn: String?

    public init (
        gatewayGroupArn: String? = nil
    )
    {
        self.gatewayGroupArn = gatewayGroupArn
    }
}

struct DeleteGatewayGroupInputBody: Equatable {
    public let gatewayGroupArn: String?
}

extension DeleteGatewayGroupInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case gatewayGroupArn = "GatewayGroupArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayGroupArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayGroupArn)
        gatewayGroupArn = gatewayGroupArnDecoded
    }
}

extension DeleteGatewayGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteGatewayGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceAssociatedException" : self = .resourceAssociatedException(try ResourceAssociatedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteGatewayGroupOutputError: Equatable {
    case resourceAssociatedException(ResourceAssociatedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteGatewayGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteGatewayGroupOutputResponse()"}
}

extension DeleteGatewayGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteGatewayGroupOutputResponse: Equatable {

    public init() {}
}

struct DeleteGatewayGroupOutputResponseBody: Equatable {
}

extension DeleteGatewayGroupOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteNetworkProfileInputBodyMiddleware: Middleware {
    public let id: String = "DeleteNetworkProfileInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteNetworkProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteNetworkProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteNetworkProfileInput>
    public typealias MOutput = OperationOutput<DeleteNetworkProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteNetworkProfileOutputError>
}

extension DeleteNetworkProfileInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteNetworkProfileInput(networkProfileArn: \(String(describing: networkProfileArn)))"}
}

extension DeleteNetworkProfileInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case networkProfileArn = "NetworkProfileArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let networkProfileArn = networkProfileArn {
            try encodeContainer.encode(networkProfileArn, forKey: .networkProfileArn)
        }
    }
}

public struct DeleteNetworkProfileInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteNetworkProfileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteNetworkProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteNetworkProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteNetworkProfileInput>
    public typealias MOutput = OperationOutput<DeleteNetworkProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteNetworkProfileOutputError>
}

public struct DeleteNetworkProfileInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteNetworkProfileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteNetworkProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteNetworkProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteNetworkProfileInput>
    public typealias MOutput = OperationOutput<DeleteNetworkProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteNetworkProfileOutputError>
}

public struct DeleteNetworkProfileInput: Equatable {
    /// <p>The ARN of the network profile associated with a device.</p>
    public let networkProfileArn: String?

    public init (
        networkProfileArn: String? = nil
    )
    {
        self.networkProfileArn = networkProfileArn
    }
}

struct DeleteNetworkProfileInputBody: Equatable {
    public let networkProfileArn: String?
}

extension DeleteNetworkProfileInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case networkProfileArn = "NetworkProfileArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkProfileArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .networkProfileArn)
        networkProfileArn = networkProfileArnDecoded
    }
}

extension DeleteNetworkProfileOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteNetworkProfileOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteNetworkProfileOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case notFoundException(NotFoundException)
    case resourceInUseException(ResourceInUseException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteNetworkProfileOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteNetworkProfileOutputResponse()"}
}

extension DeleteNetworkProfileOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteNetworkProfileOutputResponse: Equatable {

    public init() {}
}

struct DeleteNetworkProfileOutputResponseBody: Equatable {
}

extension DeleteNetworkProfileOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteProfileInputBodyMiddleware: Middleware {
    public let id: String = "DeleteProfileInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteProfileInput>
    public typealias MOutput = OperationOutput<DeleteProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteProfileOutputError>
}

extension DeleteProfileInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteProfileInput(profileArn: \(String(describing: profileArn)))"}
}

extension DeleteProfileInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case profileArn = "ProfileArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let profileArn = profileArn {
            try encodeContainer.encode(profileArn, forKey: .profileArn)
        }
    }
}

public struct DeleteProfileInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteProfileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteProfileInput>
    public typealias MOutput = OperationOutput<DeleteProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteProfileOutputError>
}

public struct DeleteProfileInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteProfileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteProfileInput>
    public typealias MOutput = OperationOutput<DeleteProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteProfileOutputError>
}

public struct DeleteProfileInput: Equatable {
    /// <p>The ARN of the room profile to delete. Required.</p>
    public let profileArn: String?

    public init (
        profileArn: String? = nil
    )
    {
        self.profileArn = profileArn
    }
}

struct DeleteProfileInputBody: Equatable {
    public let profileArn: String?
}

extension DeleteProfileInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case profileArn = "ProfileArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profileArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .profileArn)
        profileArn = profileArnDecoded
    }
}

extension DeleteProfileOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteProfileOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteProfileOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteProfileOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteProfileOutputResponse()"}
}

extension DeleteProfileOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteProfileOutputResponse: Equatable {

    public init() {}
}

struct DeleteProfileOutputResponseBody: Equatable {
}

extension DeleteProfileOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteRoomInputBodyMiddleware: Middleware {
    public let id: String = "DeleteRoomInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRoomInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRoomOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRoomInput>
    public typealias MOutput = OperationOutput<DeleteRoomOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRoomOutputError>
}

extension DeleteRoomInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteRoomInput(roomArn: \(String(describing: roomArn)))"}
}

extension DeleteRoomInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case roomArn = "RoomArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let roomArn = roomArn {
            try encodeContainer.encode(roomArn, forKey: .roomArn)
        }
    }
}

public struct DeleteRoomInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteRoomInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRoomInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRoomOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRoomInput>
    public typealias MOutput = OperationOutput<DeleteRoomOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRoomOutputError>
}

public struct DeleteRoomInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteRoomInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRoomInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRoomOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRoomInput>
    public typealias MOutput = OperationOutput<DeleteRoomOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRoomOutputError>
}

public struct DeleteRoomInput: Equatable {
    /// <p>The ARN of the room to delete. Required.</p>
    public let roomArn: String?

    public init (
        roomArn: String? = nil
    )
    {
        self.roomArn = roomArn
    }
}

struct DeleteRoomInputBody: Equatable {
    public let roomArn: String?
}

extension DeleteRoomInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case roomArn = "RoomArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roomArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roomArn)
        roomArn = roomArnDecoded
    }
}

extension DeleteRoomOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteRoomOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteRoomOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteRoomOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteRoomOutputResponse()"}
}

extension DeleteRoomOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteRoomOutputResponse: Equatable {

    public init() {}
}

struct DeleteRoomOutputResponseBody: Equatable {
}

extension DeleteRoomOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteRoomSkillParameterInputBodyMiddleware: Middleware {
    public let id: String = "DeleteRoomSkillParameterInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRoomSkillParameterInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRoomSkillParameterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRoomSkillParameterInput>
    public typealias MOutput = OperationOutput<DeleteRoomSkillParameterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRoomSkillParameterOutputError>
}

extension DeleteRoomSkillParameterInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteRoomSkillParameterInput(parameterKey: \(String(describing: parameterKey)), roomArn: \(String(describing: roomArn)), skillId: \(String(describing: skillId)))"}
}

extension DeleteRoomSkillParameterInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case parameterKey = "ParameterKey"
        case roomArn = "RoomArn"
        case skillId = "SkillId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let parameterKey = parameterKey {
            try encodeContainer.encode(parameterKey, forKey: .parameterKey)
        }
        if let roomArn = roomArn {
            try encodeContainer.encode(roomArn, forKey: .roomArn)
        }
        if let skillId = skillId {
            try encodeContainer.encode(skillId, forKey: .skillId)
        }
    }
}

public struct DeleteRoomSkillParameterInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteRoomSkillParameterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRoomSkillParameterInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRoomSkillParameterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRoomSkillParameterInput>
    public typealias MOutput = OperationOutput<DeleteRoomSkillParameterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRoomSkillParameterOutputError>
}

public struct DeleteRoomSkillParameterInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteRoomSkillParameterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRoomSkillParameterInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRoomSkillParameterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRoomSkillParameterInput>
    public typealias MOutput = OperationOutput<DeleteRoomSkillParameterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRoomSkillParameterOutputError>
}

public struct DeleteRoomSkillParameterInput: Equatable {
    /// <p>The room skill parameter key for which to remove details.</p>
    public let parameterKey: String?
    /// <p>The ARN of the room from which to remove the room skill parameter details.</p>
    public let roomArn: String?
    /// <p>The ID of the skill from which to remove the room skill parameter details.</p>
    public let skillId: String?

    public init (
        parameterKey: String? = nil,
        roomArn: String? = nil,
        skillId: String? = nil
    )
    {
        self.parameterKey = parameterKey
        self.roomArn = roomArn
        self.skillId = skillId
    }
}

struct DeleteRoomSkillParameterInputBody: Equatable {
    public let roomArn: String?
    public let skillId: String?
    public let parameterKey: String?
}

extension DeleteRoomSkillParameterInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case parameterKey = "ParameterKey"
        case roomArn = "RoomArn"
        case skillId = "SkillId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roomArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roomArn)
        roomArn = roomArnDecoded
        let skillIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .skillId)
        skillId = skillIdDecoded
        let parameterKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .parameterKey)
        parameterKey = parameterKeyDecoded
    }
}

extension DeleteRoomSkillParameterOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteRoomSkillParameterOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteRoomSkillParameterOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteRoomSkillParameterOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteRoomSkillParameterOutputResponse()"}
}

extension DeleteRoomSkillParameterOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteRoomSkillParameterOutputResponse: Equatable {

    public init() {}
}

struct DeleteRoomSkillParameterOutputResponseBody: Equatable {
}

extension DeleteRoomSkillParameterOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteSkillAuthorizationInputBodyMiddleware: Middleware {
    public let id: String = "DeleteSkillAuthorizationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteSkillAuthorizationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteSkillAuthorizationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteSkillAuthorizationInput>
    public typealias MOutput = OperationOutput<DeleteSkillAuthorizationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteSkillAuthorizationOutputError>
}

extension DeleteSkillAuthorizationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteSkillAuthorizationInput(roomArn: \(String(describing: roomArn)), skillId: \(String(describing: skillId)))"}
}

extension DeleteSkillAuthorizationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case roomArn = "RoomArn"
        case skillId = "SkillId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let roomArn = roomArn {
            try encodeContainer.encode(roomArn, forKey: .roomArn)
        }
        if let skillId = skillId {
            try encodeContainer.encode(skillId, forKey: .skillId)
        }
    }
}

public struct DeleteSkillAuthorizationInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteSkillAuthorizationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteSkillAuthorizationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteSkillAuthorizationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteSkillAuthorizationInput>
    public typealias MOutput = OperationOutput<DeleteSkillAuthorizationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteSkillAuthorizationOutputError>
}

public struct DeleteSkillAuthorizationInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteSkillAuthorizationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteSkillAuthorizationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteSkillAuthorizationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteSkillAuthorizationInput>
    public typealias MOutput = OperationOutput<DeleteSkillAuthorizationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteSkillAuthorizationOutputError>
}

public struct DeleteSkillAuthorizationInput: Equatable {
    /// <p>The room that the skill is authorized for.</p>
    public let roomArn: String?
    /// <p>The unique identifier of a skill.</p>
    public let skillId: String?

    public init (
        roomArn: String? = nil,
        skillId: String? = nil
    )
    {
        self.roomArn = roomArn
        self.skillId = skillId
    }
}

struct DeleteSkillAuthorizationInputBody: Equatable {
    public let skillId: String?
    public let roomArn: String?
}

extension DeleteSkillAuthorizationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case roomArn = "RoomArn"
        case skillId = "SkillId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let skillIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .skillId)
        skillId = skillIdDecoded
        let roomArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roomArn)
        roomArn = roomArnDecoded
    }
}

extension DeleteSkillAuthorizationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteSkillAuthorizationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteSkillAuthorizationOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteSkillAuthorizationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteSkillAuthorizationOutputResponse()"}
}

extension DeleteSkillAuthorizationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteSkillAuthorizationOutputResponse: Equatable {

    public init() {}
}

struct DeleteSkillAuthorizationOutputResponseBody: Equatable {
}

extension DeleteSkillAuthorizationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteSkillGroupInputBodyMiddleware: Middleware {
    public let id: String = "DeleteSkillGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteSkillGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteSkillGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteSkillGroupInput>
    public typealias MOutput = OperationOutput<DeleteSkillGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteSkillGroupOutputError>
}

extension DeleteSkillGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteSkillGroupInput(skillGroupArn: \(String(describing: skillGroupArn)))"}
}

extension DeleteSkillGroupInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case skillGroupArn = "SkillGroupArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let skillGroupArn = skillGroupArn {
            try encodeContainer.encode(skillGroupArn, forKey: .skillGroupArn)
        }
    }
}

public struct DeleteSkillGroupInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteSkillGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteSkillGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteSkillGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteSkillGroupInput>
    public typealias MOutput = OperationOutput<DeleteSkillGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteSkillGroupOutputError>
}

public struct DeleteSkillGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteSkillGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteSkillGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteSkillGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteSkillGroupInput>
    public typealias MOutput = OperationOutput<DeleteSkillGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteSkillGroupOutputError>
}

public struct DeleteSkillGroupInput: Equatable {
    /// <p>The ARN of the skill group to delete. Required.</p>
    public let skillGroupArn: String?

    public init (
        skillGroupArn: String? = nil
    )
    {
        self.skillGroupArn = skillGroupArn
    }
}

struct DeleteSkillGroupInputBody: Equatable {
    public let skillGroupArn: String?
}

extension DeleteSkillGroupInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case skillGroupArn = "SkillGroupArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let skillGroupArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .skillGroupArn)
        skillGroupArn = skillGroupArnDecoded
    }
}

extension DeleteSkillGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteSkillGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteSkillGroupOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteSkillGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteSkillGroupOutputResponse()"}
}

extension DeleteSkillGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteSkillGroupOutputResponse: Equatable {

    public init() {}
}

struct DeleteSkillGroupOutputResponseBody: Equatable {
}

extension DeleteSkillGroupOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteUserInputBodyMiddleware: Middleware {
    public let id: String = "DeleteUserInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteUserInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteUserInput>
    public typealias MOutput = OperationOutput<DeleteUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteUserOutputError>
}

extension DeleteUserInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteUserInput(enrollmentId: \(String(describing: enrollmentId)), userArn: \(String(describing: userArn)))"}
}

extension DeleteUserInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case enrollmentId = "EnrollmentId"
        case userArn = "UserArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enrollmentId = enrollmentId {
            try encodeContainer.encode(enrollmentId, forKey: .enrollmentId)
        }
        if let userArn = userArn {
            try encodeContainer.encode(userArn, forKey: .userArn)
        }
    }
}

public struct DeleteUserInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteUserInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteUserInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteUserInput>
    public typealias MOutput = OperationOutput<DeleteUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteUserOutputError>
}

public struct DeleteUserInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteUserInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteUserInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteUserInput>
    public typealias MOutput = OperationOutput<DeleteUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteUserOutputError>
}

public struct DeleteUserInput: Equatable {
    /// <p>The ARN of the user's enrollment in the organization. Required.</p>
    public let enrollmentId: String?
    /// <p>The ARN of the user to delete in the organization. Required.</p>
    public let userArn: String?

    public init (
        enrollmentId: String? = nil,
        userArn: String? = nil
    )
    {
        self.enrollmentId = enrollmentId
        self.userArn = userArn
    }
}

struct DeleteUserInputBody: Equatable {
    public let userArn: String?
    public let enrollmentId: String?
}

extension DeleteUserInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case enrollmentId = "EnrollmentId"
        case userArn = "UserArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userArn)
        userArn = userArnDecoded
        let enrollmentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .enrollmentId)
        enrollmentId = enrollmentIdDecoded
    }
}

extension DeleteUserOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteUserOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteUserOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteUserOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteUserOutputResponse()"}
}

extension DeleteUserOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteUserOutputResponse: Equatable {

    public init() {}
}

struct DeleteUserOutputResponseBody: Equatable {
}

extension DeleteUserOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeveloperInfo: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case developerName = "DeveloperName"
        case email = "Email"
        case privacyPolicy = "PrivacyPolicy"
        case url = "Url"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let developerName = developerName {
            try encodeContainer.encode(developerName, forKey: .developerName)
        }
        if let email = email {
            try encodeContainer.encode(email, forKey: .email)
        }
        if let privacyPolicy = privacyPolicy {
            try encodeContainer.encode(privacyPolicy, forKey: .privacyPolicy)
        }
        if let url = url {
            try encodeContainer.encode(url, forKey: .url)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let developerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .developerName)
        developerName = developerNameDecoded
        let privacyPolicyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .privacyPolicy)
        privacyPolicy = privacyPolicyDecoded
        let emailDecoded = try containerValues.decodeIfPresent(String.self, forKey: .email)
        email = emailDecoded
        let urlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .url)
        url = urlDecoded
    }
}

extension DeveloperInfo: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeveloperInfo(developerName: \(String(describing: developerName)), email: \(String(describing: email)), privacyPolicy: \(String(describing: privacyPolicy)), url: \(String(describing: url)))"}
}

/// <p>The details about the developer that published the skill.</p>
public struct DeveloperInfo: Equatable {
    /// <p>The name of the developer.</p>
    public let developerName: String?
    /// <p>The email of the developer.</p>
    public let email: String?
    /// <p>The URL of the privacy policy.</p>
    public let privacyPolicy: String?
    /// <p>The website of the developer.</p>
    public let url: String?

    public init (
        developerName: String? = nil,
        email: String? = nil,
        privacyPolicy: String? = nil,
        url: String? = nil
    )
    {
        self.developerName = developerName
        self.email = email
        self.privacyPolicy = privacyPolicy
        self.url = url
    }
}

extension Device: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case deviceArn = "DeviceArn"
        case deviceName = "DeviceName"
        case deviceSerialNumber = "DeviceSerialNumber"
        case deviceStatus = "DeviceStatus"
        case deviceStatusInfo = "DeviceStatusInfo"
        case deviceType = "DeviceType"
        case macAddress = "MacAddress"
        case networkProfileInfo = "NetworkProfileInfo"
        case roomArn = "RoomArn"
        case softwareVersion = "SoftwareVersion"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceArn = deviceArn {
            try encodeContainer.encode(deviceArn, forKey: .deviceArn)
        }
        if let deviceName = deviceName {
            try encodeContainer.encode(deviceName, forKey: .deviceName)
        }
        if let deviceSerialNumber = deviceSerialNumber {
            try encodeContainer.encode(deviceSerialNumber, forKey: .deviceSerialNumber)
        }
        if let deviceStatus = deviceStatus {
            try encodeContainer.encode(deviceStatus.rawValue, forKey: .deviceStatus)
        }
        if let deviceStatusInfo = deviceStatusInfo {
            try encodeContainer.encode(deviceStatusInfo, forKey: .deviceStatusInfo)
        }
        if let deviceType = deviceType {
            try encodeContainer.encode(deviceType, forKey: .deviceType)
        }
        if let macAddress = macAddress {
            try encodeContainer.encode(macAddress, forKey: .macAddress)
        }
        if let networkProfileInfo = networkProfileInfo {
            try encodeContainer.encode(networkProfileInfo, forKey: .networkProfileInfo)
        }
        if let roomArn = roomArn {
            try encodeContainer.encode(roomArn, forKey: .roomArn)
        }
        if let softwareVersion = softwareVersion {
            try encodeContainer.encode(softwareVersion, forKey: .softwareVersion)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deviceArn)
        deviceArn = deviceArnDecoded
        let deviceSerialNumberDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deviceSerialNumber)
        deviceSerialNumber = deviceSerialNumberDecoded
        let deviceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deviceType)
        deviceType = deviceTypeDecoded
        let deviceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deviceName)
        deviceName = deviceNameDecoded
        let softwareVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .softwareVersion)
        softwareVersion = softwareVersionDecoded
        let macAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .macAddress)
        macAddress = macAddressDecoded
        let roomArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roomArn)
        roomArn = roomArnDecoded
        let deviceStatusDecoded = try containerValues.decodeIfPresent(DeviceStatus.self, forKey: .deviceStatus)
        deviceStatus = deviceStatusDecoded
        let deviceStatusInfoDecoded = try containerValues.decodeIfPresent(DeviceStatusInfo.self, forKey: .deviceStatusInfo)
        deviceStatusInfo = deviceStatusInfoDecoded
        let networkProfileInfoDecoded = try containerValues.decodeIfPresent(DeviceNetworkProfileInfo.self, forKey: .networkProfileInfo)
        networkProfileInfo = networkProfileInfoDecoded
    }
}

extension Device: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Device(deviceArn: \(String(describing: deviceArn)), deviceName: \(String(describing: deviceName)), deviceSerialNumber: \(String(describing: deviceSerialNumber)), deviceStatus: \(String(describing: deviceStatus)), deviceStatusInfo: \(String(describing: deviceStatusInfo)), deviceType: \(String(describing: deviceType)), macAddress: \(String(describing: macAddress)), networkProfileInfo: \(String(describing: networkProfileInfo)), roomArn: \(String(describing: roomArn)), softwareVersion: \(String(describing: softwareVersion)))"}
}

/// <p>A device with attributes.</p>
public struct Device: Equatable {
    /// <p>The ARN of a device.</p>
    public let deviceArn: String?
    /// <p>The name of a device.</p>
    public let deviceName: String?
    /// <p>The serial number of a device.</p>
    public let deviceSerialNumber: String?
    /// <p>The status of a device. If the status is not READY, check the DeviceStatusInfo value
    ///          for details.</p>
    public let deviceStatus: DeviceStatus?
    /// <p>Detailed information about a device's status.</p>
    public let deviceStatusInfo: DeviceStatusInfo?
    /// <p>The type of a device.</p>
    public let deviceType: String?
    /// <p>The MAC address of a device.</p>
    public let macAddress: String?
    /// <p>Detailed information about a device's network profile.</p>
    public let networkProfileInfo: DeviceNetworkProfileInfo?
    /// <p>The room ARN of a device.</p>
    public let roomArn: String?
    /// <p>The software version of a device.</p>
    public let softwareVersion: String?

    public init (
        deviceArn: String? = nil,
        deviceName: String? = nil,
        deviceSerialNumber: String? = nil,
        deviceStatus: DeviceStatus? = nil,
        deviceStatusInfo: DeviceStatusInfo? = nil,
        deviceType: String? = nil,
        macAddress: String? = nil,
        networkProfileInfo: DeviceNetworkProfileInfo? = nil,
        roomArn: String? = nil,
        softwareVersion: String? = nil
    )
    {
        self.deviceArn = deviceArn
        self.deviceName = deviceName
        self.deviceSerialNumber = deviceSerialNumber
        self.deviceStatus = deviceStatus
        self.deviceStatusInfo = deviceStatusInfo
        self.deviceType = deviceType
        self.macAddress = macAddress
        self.networkProfileInfo = networkProfileInfo
        self.roomArn = roomArn
        self.softwareVersion = softwareVersion
    }
}

extension DeviceData: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case createdTime = "CreatedTime"
        case deviceArn = "DeviceArn"
        case deviceName = "DeviceName"
        case deviceSerialNumber = "DeviceSerialNumber"
        case deviceStatus = "DeviceStatus"
        case deviceStatusInfo = "DeviceStatusInfo"
        case deviceType = "DeviceType"
        case macAddress = "MacAddress"
        case networkProfileArn = "NetworkProfileArn"
        case networkProfileName = "NetworkProfileName"
        case roomArn = "RoomArn"
        case roomName = "RoomName"
        case softwareVersion = "SoftwareVersion"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
        if let deviceArn = deviceArn {
            try encodeContainer.encode(deviceArn, forKey: .deviceArn)
        }
        if let deviceName = deviceName {
            try encodeContainer.encode(deviceName, forKey: .deviceName)
        }
        if let deviceSerialNumber = deviceSerialNumber {
            try encodeContainer.encode(deviceSerialNumber, forKey: .deviceSerialNumber)
        }
        if let deviceStatus = deviceStatus {
            try encodeContainer.encode(deviceStatus.rawValue, forKey: .deviceStatus)
        }
        if let deviceStatusInfo = deviceStatusInfo {
            try encodeContainer.encode(deviceStatusInfo, forKey: .deviceStatusInfo)
        }
        if let deviceType = deviceType {
            try encodeContainer.encode(deviceType, forKey: .deviceType)
        }
        if let macAddress = macAddress {
            try encodeContainer.encode(macAddress, forKey: .macAddress)
        }
        if let networkProfileArn = networkProfileArn {
            try encodeContainer.encode(networkProfileArn, forKey: .networkProfileArn)
        }
        if let networkProfileName = networkProfileName {
            try encodeContainer.encode(networkProfileName, forKey: .networkProfileName)
        }
        if let roomArn = roomArn {
            try encodeContainer.encode(roomArn, forKey: .roomArn)
        }
        if let roomName = roomName {
            try encodeContainer.encode(roomName, forKey: .roomName)
        }
        if let softwareVersion = softwareVersion {
            try encodeContainer.encode(softwareVersion, forKey: .softwareVersion)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deviceArn)
        deviceArn = deviceArnDecoded
        let deviceSerialNumberDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deviceSerialNumber)
        deviceSerialNumber = deviceSerialNumberDecoded
        let deviceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deviceType)
        deviceType = deviceTypeDecoded
        let deviceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deviceName)
        deviceName = deviceNameDecoded
        let softwareVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .softwareVersion)
        softwareVersion = softwareVersionDecoded
        let macAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .macAddress)
        macAddress = macAddressDecoded
        let deviceStatusDecoded = try containerValues.decodeIfPresent(DeviceStatus.self, forKey: .deviceStatus)
        deviceStatus = deviceStatusDecoded
        let networkProfileArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .networkProfileArn)
        networkProfileArn = networkProfileArnDecoded
        let networkProfileNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .networkProfileName)
        networkProfileName = networkProfileNameDecoded
        let roomArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roomArn)
        roomArn = roomArnDecoded
        let roomNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roomName)
        roomName = roomNameDecoded
        let deviceStatusInfoDecoded = try containerValues.decodeIfPresent(DeviceStatusInfo.self, forKey: .deviceStatusInfo)
        deviceStatusInfo = deviceStatusInfoDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
    }
}

extension DeviceData: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeviceData(createdTime: \(String(describing: createdTime)), deviceArn: \(String(describing: deviceArn)), deviceName: \(String(describing: deviceName)), deviceSerialNumber: \(String(describing: deviceSerialNumber)), deviceStatus: \(String(describing: deviceStatus)), deviceStatusInfo: \(String(describing: deviceStatusInfo)), deviceType: \(String(describing: deviceType)), macAddress: \(String(describing: macAddress)), networkProfileArn: \(String(describing: networkProfileArn)), networkProfileName: \(String(describing: networkProfileName)), roomArn: \(String(describing: roomArn)), roomName: \(String(describing: roomName)), softwareVersion: \(String(describing: softwareVersion)))"}
}

/// <p>Device attributes.</p>
public struct DeviceData: Equatable {
    /// <p>The time (in epoch) when the device data was created.</p>
    public let createdTime: Date?
    /// <p>The ARN of a device.</p>
    public let deviceArn: String?
    /// <p>The name of a device.</p>
    public let deviceName: String?
    /// <p>The serial number of a device.</p>
    public let deviceSerialNumber: String?
    /// <p>The status of a device.</p>
    public let deviceStatus: DeviceStatus?
    /// <p>Detailed information about a device's status.</p>
    public let deviceStatusInfo: DeviceStatusInfo?
    /// <p>The type of a device.</p>
    public let deviceType: String?
    /// <p>The MAC address of a device.</p>
    public let macAddress: String?
    /// <p>The ARN of the network profile associated with a device.</p>
    public let networkProfileArn: String?
    /// <p>The name of the network profile associated with a device.</p>
    public let networkProfileName: String?
    /// <p>The room ARN associated with a device.</p>
    public let roomArn: String?
    /// <p>The name of the room associated with a device.</p>
    public let roomName: String?
    /// <p>The software version of a device.</p>
    public let softwareVersion: String?

    public init (
        createdTime: Date? = nil,
        deviceArn: String? = nil,
        deviceName: String? = nil,
        deviceSerialNumber: String? = nil,
        deviceStatus: DeviceStatus? = nil,
        deviceStatusInfo: DeviceStatusInfo? = nil,
        deviceType: String? = nil,
        macAddress: String? = nil,
        networkProfileArn: String? = nil,
        networkProfileName: String? = nil,
        roomArn: String? = nil,
        roomName: String? = nil,
        softwareVersion: String? = nil
    )
    {
        self.createdTime = createdTime
        self.deviceArn = deviceArn
        self.deviceName = deviceName
        self.deviceSerialNumber = deviceSerialNumber
        self.deviceStatus = deviceStatus
        self.deviceStatusInfo = deviceStatusInfo
        self.deviceType = deviceType
        self.macAddress = macAddress
        self.networkProfileArn = networkProfileArn
        self.networkProfileName = networkProfileName
        self.roomArn = roomArn
        self.roomName = roomName
        self.softwareVersion = softwareVersion
    }
}

extension DeviceEvent: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case timestamp = "Timestamp"
        case type = "Type"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let timestamp = timestamp {
            try encodeContainer.encode(timestamp.timeIntervalSince1970, forKey: .timestamp)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(DeviceEventType.self, forKey: .type)
        type = typeDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
        let timestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .timestamp)
        timestamp = timestampDecoded
    }
}

extension DeviceEvent: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeviceEvent(timestamp: \(String(describing: timestamp)), type: \(String(describing: type)), value: \(String(describing: value)))"}
}

/// <p>The list of device events.</p>
public struct DeviceEvent: Equatable {
    /// <p>The time (in epoch) when the event occurred. </p>
    public let timestamp: Date?
    /// <p>The type of device event.</p>
    public let type: DeviceEventType?
    /// <p>The value of the event.</p>
    public let value: String?

    public init (
        timestamp: Date? = nil,
        type: DeviceEventType? = nil,
        value: String? = nil
    )
    {
        self.timestamp = timestamp
        self.type = type
        self.value = value
    }
}

public enum DeviceEventType {
    case connectionStatus
    case deviceStatus
    case sdkUnknown(String)
}

extension DeviceEventType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DeviceEventType] {
        return [
            .connectionStatus,
            .deviceStatus,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .connectionStatus: return "CONNECTION_STATUS"
        case .deviceStatus: return "DEVICE_STATUS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DeviceEventType(rawValue: rawValue) ?? DeviceEventType.sdkUnknown(rawValue)
    }
}

extension DeviceNetworkProfileInfo: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case certificateArn = "CertificateArn"
        case certificateExpirationTime = "CertificateExpirationTime"
        case networkProfileArn = "NetworkProfileArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateArn = certificateArn {
            try encodeContainer.encode(certificateArn, forKey: .certificateArn)
        }
        if let certificateExpirationTime = certificateExpirationTime {
            try encodeContainer.encode(certificateExpirationTime.timeIntervalSince1970, forKey: .certificateExpirationTime)
        }
        if let networkProfileArn = networkProfileArn {
            try encodeContainer.encode(networkProfileArn, forKey: .networkProfileArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkProfileArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .networkProfileArn)
        networkProfileArn = networkProfileArnDecoded
        let certificateArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificateArn)
        certificateArn = certificateArnDecoded
        let certificateExpirationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .certificateExpirationTime)
        certificateExpirationTime = certificateExpirationTimeDecoded
    }
}

extension DeviceNetworkProfileInfo: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeviceNetworkProfileInfo(certificateArn: \(String(describing: certificateArn)), certificateExpirationTime: \(String(describing: certificateExpirationTime)), networkProfileArn: \(String(describing: networkProfileArn)))"}
}

/// <p>Detailed information about a device's network profile.</p>
public struct DeviceNetworkProfileInfo: Equatable {
    /// <p>The ARN of the certificate associated with a device.</p>
    public let certificateArn: String?
    /// <p>The time (in epoch) when the certificate expires.</p>
    public let certificateExpirationTime: Date?
    /// <p>The ARN of the network profile associated with a device.</p>
    public let networkProfileArn: String?

    public init (
        certificateArn: String? = nil,
        certificateExpirationTime: Date? = nil,
        networkProfileArn: String? = nil
    )
    {
        self.certificateArn = certificateArn
        self.certificateExpirationTime = certificateExpirationTime
        self.networkProfileArn = networkProfileArn
    }
}

extension DeviceNotRegisteredException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeviceNotRegisteredException(message: \(String(describing: message)))"}
}

extension DeviceNotRegisteredException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeviceNotRegisteredExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request failed because this device is no longer registered and therefore no longer managed by this account.</p>
public struct DeviceNotRegisteredException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DeviceNotRegisteredExceptionBody: Equatable {
    public let message: String?
}

extension DeviceNotRegisteredExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum DeviceStatus {
    case deregistered
    case failed
    case pending
    case ready
    case wasOffline
    case sdkUnknown(String)
}

extension DeviceStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DeviceStatus] {
        return [
            .deregistered,
            .failed,
            .pending,
            .ready,
            .wasOffline,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .deregistered: return "DEREGISTERED"
        case .failed: return "FAILED"
        case .pending: return "PENDING"
        case .ready: return "READY"
        case .wasOffline: return "WAS_OFFLINE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DeviceStatus(rawValue: rawValue) ?? DeviceStatus.sdkUnknown(rawValue)
    }
}

extension DeviceStatusDetail: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case code = "Code"
        case feature = "Feature"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = code {
            try encodeContainer.encode(code.rawValue, forKey: .code)
        }
        if let feature = feature {
            try encodeContainer.encode(feature.rawValue, forKey: .feature)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let featureDecoded = try containerValues.decodeIfPresent(Feature.self, forKey: .feature)
        feature = featureDecoded
        let codeDecoded = try containerValues.decodeIfPresent(DeviceStatusDetailCode.self, forKey: .code)
        code = codeDecoded
    }
}

extension DeviceStatusDetail: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeviceStatusDetail(code: \(String(describing: code)), feature: \(String(describing: feature)))"}
}

/// <p>Details of a devices status.</p>
public struct DeviceStatusDetail: Equatable {
    /// <p>The device status detail code.</p>
    public let code: DeviceStatusDetailCode?
    /// <p>The list of available features on the device.</p>
    public let feature: Feature?

    public init (
        code: DeviceStatusDetailCode? = nil,
        feature: Feature? = nil
    )
    {
        self.code = code
        self.feature = feature
    }
}

public enum DeviceStatusDetailCode {
    case associationRejection
    case authenticationFailure
    case certificateAuthorityAccessDenied
    case certificateIssuingLimitExceeded
    case credentialsAccessFailure
    case deviceSoftwareUpdateNeeded
    case deviceWasOffline
    case dhcpFailure
    case dnsFailure
    case internetUnavailable
    case invalidCertificateAuthority
    case invalidPasswordState
    case networkProfileNotFound
    case passwordManagerAccessDenied
    case passwordNotFound
    case tlsVersionMismatch
    case unknownFailure
    case sdkUnknown(String)
}

extension DeviceStatusDetailCode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DeviceStatusDetailCode] {
        return [
            .associationRejection,
            .authenticationFailure,
            .certificateAuthorityAccessDenied,
            .certificateIssuingLimitExceeded,
            .credentialsAccessFailure,
            .deviceSoftwareUpdateNeeded,
            .deviceWasOffline,
            .dhcpFailure,
            .dnsFailure,
            .internetUnavailable,
            .invalidCertificateAuthority,
            .invalidPasswordState,
            .networkProfileNotFound,
            .passwordManagerAccessDenied,
            .passwordNotFound,
            .tlsVersionMismatch,
            .unknownFailure,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .associationRejection: return "ASSOCIATION_REJECTION"
        case .authenticationFailure: return "AUTHENTICATION_FAILURE"
        case .certificateAuthorityAccessDenied: return "CERTIFICATE_AUTHORITY_ACCESS_DENIED"
        case .certificateIssuingLimitExceeded: return "CERTIFICATE_ISSUING_LIMIT_EXCEEDED"
        case .credentialsAccessFailure: return "CREDENTIALS_ACCESS_FAILURE"
        case .deviceSoftwareUpdateNeeded: return "DEVICE_SOFTWARE_UPDATE_NEEDED"
        case .deviceWasOffline: return "DEVICE_WAS_OFFLINE"
        case .dhcpFailure: return "DHCP_FAILURE"
        case .dnsFailure: return "DNS_FAILURE"
        case .internetUnavailable: return "INTERNET_UNAVAILABLE"
        case .invalidCertificateAuthority: return "INVALID_CERTIFICATE_AUTHORITY"
        case .invalidPasswordState: return "INVALID_PASSWORD_STATE"
        case .networkProfileNotFound: return "NETWORK_PROFILE_NOT_FOUND"
        case .passwordManagerAccessDenied: return "PASSWORD_MANAGER_ACCESS_DENIED"
        case .passwordNotFound: return "PASSWORD_NOT_FOUND"
        case .tlsVersionMismatch: return "TLS_VERSION_MISMATCH"
        case .unknownFailure: return "UNKNOWN_FAILURE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DeviceStatusDetailCode(rawValue: rawValue) ?? DeviceStatusDetailCode.sdkUnknown(rawValue)
    }
}

extension DeviceStatusInfo: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case connectionStatus = "ConnectionStatus"
        case connectionStatusUpdatedTime = "ConnectionStatusUpdatedTime"
        case deviceStatusDetails = "DeviceStatusDetails"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionStatus = connectionStatus {
            try encodeContainer.encode(connectionStatus.rawValue, forKey: .connectionStatus)
        }
        if let connectionStatusUpdatedTime = connectionStatusUpdatedTime {
            try encodeContainer.encode(connectionStatusUpdatedTime.timeIntervalSince1970, forKey: .connectionStatusUpdatedTime)
        }
        if let deviceStatusDetails = deviceStatusDetails {
            var deviceStatusDetailsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .deviceStatusDetails)
            for devicestatusdetails0 in deviceStatusDetails {
                try deviceStatusDetailsContainer.encode(devicestatusdetails0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceStatusDetailsContainer = try containerValues.decodeIfPresent([DeviceStatusDetail?].self, forKey: .deviceStatusDetails)
        var deviceStatusDetailsDecoded0:[DeviceStatusDetail]? = nil
        if let deviceStatusDetailsContainer = deviceStatusDetailsContainer {
            deviceStatusDetailsDecoded0 = [DeviceStatusDetail]()
            for structure0 in deviceStatusDetailsContainer {
                if let structure0 = structure0 {
                    deviceStatusDetailsDecoded0?.append(structure0)
                }
            }
        }
        deviceStatusDetails = deviceStatusDetailsDecoded0
        let connectionStatusDecoded = try containerValues.decodeIfPresent(ConnectionStatus.self, forKey: .connectionStatus)
        connectionStatus = connectionStatusDecoded
        let connectionStatusUpdatedTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .connectionStatusUpdatedTime)
        connectionStatusUpdatedTime = connectionStatusUpdatedTimeDecoded
    }
}

extension DeviceStatusInfo: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeviceStatusInfo(connectionStatus: \(String(describing: connectionStatus)), connectionStatusUpdatedTime: \(String(describing: connectionStatusUpdatedTime)), deviceStatusDetails: \(String(describing: deviceStatusDetails)))"}
}

/// <p>Detailed information about a device's status.</p>
public struct DeviceStatusInfo: Equatable {
    /// <p>The latest available information about the connection status of a device. </p>
    public let connectionStatus: ConnectionStatus?
    /// <p>The time (in epoch) when the device connection status changed.</p>
    public let connectionStatusUpdatedTime: Date?
    /// <p>One or more device status detail descriptions.</p>
    public let deviceStatusDetails: [DeviceStatusDetail]?

    public init (
        connectionStatus: ConnectionStatus? = nil,
        connectionStatusUpdatedTime: Date? = nil,
        deviceStatusDetails: [DeviceStatusDetail]? = nil
    )
    {
        self.connectionStatus = connectionStatus
        self.connectionStatusUpdatedTime = connectionStatusUpdatedTime
        self.deviceStatusDetails = deviceStatusDetails
    }
}

public enum DeviceUsageType {
    case voice
    case sdkUnknown(String)
}

extension DeviceUsageType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DeviceUsageType] {
        return [
            .voice,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .voice: return "VOICE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DeviceUsageType(rawValue: rawValue) ?? DeviceUsageType.sdkUnknown(rawValue)
    }
}

public struct DisassociateContactFromAddressBookInputBodyMiddleware: Middleware {
    public let id: String = "DisassociateContactFromAddressBookInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateContactFromAddressBookInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateContactFromAddressBookOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateContactFromAddressBookInput>
    public typealias MOutput = OperationOutput<DisassociateContactFromAddressBookOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateContactFromAddressBookOutputError>
}

extension DisassociateContactFromAddressBookInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateContactFromAddressBookInput(addressBookArn: \(String(describing: addressBookArn)), contactArn: \(String(describing: contactArn)))"}
}

extension DisassociateContactFromAddressBookInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case addressBookArn = "AddressBookArn"
        case contactArn = "ContactArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addressBookArn = addressBookArn {
            try encodeContainer.encode(addressBookArn, forKey: .addressBookArn)
        }
        if let contactArn = contactArn {
            try encodeContainer.encode(contactArn, forKey: .contactArn)
        }
    }
}

public struct DisassociateContactFromAddressBookInputHeadersMiddleware: Middleware {
    public let id: String = "DisassociateContactFromAddressBookInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateContactFromAddressBookInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateContactFromAddressBookOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateContactFromAddressBookInput>
    public typealias MOutput = OperationOutput<DisassociateContactFromAddressBookOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateContactFromAddressBookOutputError>
}

public struct DisassociateContactFromAddressBookInputQueryItemMiddleware: Middleware {
    public let id: String = "DisassociateContactFromAddressBookInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateContactFromAddressBookInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateContactFromAddressBookOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateContactFromAddressBookInput>
    public typealias MOutput = OperationOutput<DisassociateContactFromAddressBookOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateContactFromAddressBookOutputError>
}

public struct DisassociateContactFromAddressBookInput: Equatable {
    /// <p>The ARN of the address from which to disassociate the contact.</p>
    public let addressBookArn: String?
    /// <p>The ARN of the contact to disassociate from an address book.</p>
    public let contactArn: String?

    public init (
        addressBookArn: String? = nil,
        contactArn: String? = nil
    )
    {
        self.addressBookArn = addressBookArn
        self.contactArn = contactArn
    }
}

struct DisassociateContactFromAddressBookInputBody: Equatable {
    public let contactArn: String?
    public let addressBookArn: String?
}

extension DisassociateContactFromAddressBookInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case addressBookArn = "AddressBookArn"
        case contactArn = "ContactArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .contactArn)
        contactArn = contactArnDecoded
        let addressBookArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .addressBookArn)
        addressBookArn = addressBookArnDecoded
    }
}

extension DisassociateContactFromAddressBookOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateContactFromAddressBookOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateContactFromAddressBookOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateContactFromAddressBookOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateContactFromAddressBookOutputResponse()"}
}

extension DisassociateContactFromAddressBookOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateContactFromAddressBookOutputResponse: Equatable {

    public init() {}
}

struct DisassociateContactFromAddressBookOutputResponseBody: Equatable {
}

extension DisassociateContactFromAddressBookOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DisassociateDeviceFromRoomInputBodyMiddleware: Middleware {
    public let id: String = "DisassociateDeviceFromRoomInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateDeviceFromRoomInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateDeviceFromRoomOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateDeviceFromRoomInput>
    public typealias MOutput = OperationOutput<DisassociateDeviceFromRoomOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateDeviceFromRoomOutputError>
}

extension DisassociateDeviceFromRoomInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateDeviceFromRoomInput(deviceArn: \(String(describing: deviceArn)))"}
}

extension DisassociateDeviceFromRoomInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case deviceArn = "DeviceArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceArn = deviceArn {
            try encodeContainer.encode(deviceArn, forKey: .deviceArn)
        }
    }
}

public struct DisassociateDeviceFromRoomInputHeadersMiddleware: Middleware {
    public let id: String = "DisassociateDeviceFromRoomInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateDeviceFromRoomInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateDeviceFromRoomOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateDeviceFromRoomInput>
    public typealias MOutput = OperationOutput<DisassociateDeviceFromRoomOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateDeviceFromRoomOutputError>
}

public struct DisassociateDeviceFromRoomInputQueryItemMiddleware: Middleware {
    public let id: String = "DisassociateDeviceFromRoomInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateDeviceFromRoomInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateDeviceFromRoomOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateDeviceFromRoomInput>
    public typealias MOutput = OperationOutput<DisassociateDeviceFromRoomOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateDeviceFromRoomOutputError>
}

public struct DisassociateDeviceFromRoomInput: Equatable {
    /// <p>The ARN of the device to disassociate from a room. Required.</p>
    public let deviceArn: String?

    public init (
        deviceArn: String? = nil
    )
    {
        self.deviceArn = deviceArn
    }
}

struct DisassociateDeviceFromRoomInputBody: Equatable {
    public let deviceArn: String?
}

extension DisassociateDeviceFromRoomInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case deviceArn = "DeviceArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deviceArn)
        deviceArn = deviceArnDecoded
    }
}

extension DisassociateDeviceFromRoomOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateDeviceFromRoomOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DeviceNotRegisteredException" : self = .deviceNotRegisteredException(try DeviceNotRegisteredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateDeviceFromRoomOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case deviceNotRegisteredException(DeviceNotRegisteredException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateDeviceFromRoomOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateDeviceFromRoomOutputResponse()"}
}

extension DisassociateDeviceFromRoomOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateDeviceFromRoomOutputResponse: Equatable {

    public init() {}
}

struct DisassociateDeviceFromRoomOutputResponseBody: Equatable {
}

extension DisassociateDeviceFromRoomOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DisassociateSkillFromSkillGroupInputBodyMiddleware: Middleware {
    public let id: String = "DisassociateSkillFromSkillGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateSkillFromSkillGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateSkillFromSkillGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateSkillFromSkillGroupInput>
    public typealias MOutput = OperationOutput<DisassociateSkillFromSkillGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateSkillFromSkillGroupOutputError>
}

extension DisassociateSkillFromSkillGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateSkillFromSkillGroupInput(skillGroupArn: \(String(describing: skillGroupArn)), skillId: \(String(describing: skillId)))"}
}

extension DisassociateSkillFromSkillGroupInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case skillGroupArn = "SkillGroupArn"
        case skillId = "SkillId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let skillGroupArn = skillGroupArn {
            try encodeContainer.encode(skillGroupArn, forKey: .skillGroupArn)
        }
        if let skillId = skillId {
            try encodeContainer.encode(skillId, forKey: .skillId)
        }
    }
}

public struct DisassociateSkillFromSkillGroupInputHeadersMiddleware: Middleware {
    public let id: String = "DisassociateSkillFromSkillGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateSkillFromSkillGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateSkillFromSkillGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateSkillFromSkillGroupInput>
    public typealias MOutput = OperationOutput<DisassociateSkillFromSkillGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateSkillFromSkillGroupOutputError>
}

public struct DisassociateSkillFromSkillGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "DisassociateSkillFromSkillGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateSkillFromSkillGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateSkillFromSkillGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateSkillFromSkillGroupInput>
    public typealias MOutput = OperationOutput<DisassociateSkillFromSkillGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateSkillFromSkillGroupOutputError>
}

public struct DisassociateSkillFromSkillGroupInput: Equatable {
    /// <p>The unique identifier of a skill. Required.</p>
    public let skillGroupArn: String?
    /// <p>The ARN of a skill group to associate to a skill.</p>
    public let skillId: String?

    public init (
        skillGroupArn: String? = nil,
        skillId: String? = nil
    )
    {
        self.skillGroupArn = skillGroupArn
        self.skillId = skillId
    }
}

struct DisassociateSkillFromSkillGroupInputBody: Equatable {
    public let skillGroupArn: String?
    public let skillId: String?
}

extension DisassociateSkillFromSkillGroupInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case skillGroupArn = "SkillGroupArn"
        case skillId = "SkillId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let skillGroupArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .skillGroupArn)
        skillGroupArn = skillGroupArnDecoded
        let skillIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .skillId)
        skillId = skillIdDecoded
    }
}

extension DisassociateSkillFromSkillGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateSkillFromSkillGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateSkillFromSkillGroupOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateSkillFromSkillGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateSkillFromSkillGroupOutputResponse()"}
}

extension DisassociateSkillFromSkillGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateSkillFromSkillGroupOutputResponse: Equatable {

    public init() {}
}

struct DisassociateSkillFromSkillGroupOutputResponseBody: Equatable {
}

extension DisassociateSkillFromSkillGroupOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DisassociateSkillFromUsersInputBodyMiddleware: Middleware {
    public let id: String = "DisassociateSkillFromUsersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateSkillFromUsersInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateSkillFromUsersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateSkillFromUsersInput>
    public typealias MOutput = OperationOutput<DisassociateSkillFromUsersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateSkillFromUsersOutputError>
}

extension DisassociateSkillFromUsersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateSkillFromUsersInput(skillId: \(String(describing: skillId)))"}
}

extension DisassociateSkillFromUsersInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case skillId = "SkillId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let skillId = skillId {
            try encodeContainer.encode(skillId, forKey: .skillId)
        }
    }
}

public struct DisassociateSkillFromUsersInputHeadersMiddleware: Middleware {
    public let id: String = "DisassociateSkillFromUsersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateSkillFromUsersInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateSkillFromUsersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateSkillFromUsersInput>
    public typealias MOutput = OperationOutput<DisassociateSkillFromUsersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateSkillFromUsersOutputError>
}

public struct DisassociateSkillFromUsersInputQueryItemMiddleware: Middleware {
    public let id: String = "DisassociateSkillFromUsersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateSkillFromUsersInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateSkillFromUsersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateSkillFromUsersInput>
    public typealias MOutput = OperationOutput<DisassociateSkillFromUsersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateSkillFromUsersOutputError>
}

public struct DisassociateSkillFromUsersInput: Equatable {
    /// <p> The private skill ID you want to make unavailable for enrolled users.</p>
    public let skillId: String?

    public init (
        skillId: String? = nil
    )
    {
        self.skillId = skillId
    }
}

struct DisassociateSkillFromUsersInputBody: Equatable {
    public let skillId: String?
}

extension DisassociateSkillFromUsersInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case skillId = "SkillId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let skillIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .skillId)
        skillId = skillIdDecoded
    }
}

extension DisassociateSkillFromUsersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateSkillFromUsersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateSkillFromUsersOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateSkillFromUsersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateSkillFromUsersOutputResponse()"}
}

extension DisassociateSkillFromUsersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateSkillFromUsersOutputResponse: Equatable {

    public init() {}
}

struct DisassociateSkillFromUsersOutputResponseBody: Equatable {
}

extension DisassociateSkillFromUsersOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DisassociateSkillGroupFromRoomInputBodyMiddleware: Middleware {
    public let id: String = "DisassociateSkillGroupFromRoomInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateSkillGroupFromRoomInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateSkillGroupFromRoomOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateSkillGroupFromRoomInput>
    public typealias MOutput = OperationOutput<DisassociateSkillGroupFromRoomOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateSkillGroupFromRoomOutputError>
}

extension DisassociateSkillGroupFromRoomInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateSkillGroupFromRoomInput(roomArn: \(String(describing: roomArn)), skillGroupArn: \(String(describing: skillGroupArn)))"}
}

extension DisassociateSkillGroupFromRoomInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case roomArn = "RoomArn"
        case skillGroupArn = "SkillGroupArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let roomArn = roomArn {
            try encodeContainer.encode(roomArn, forKey: .roomArn)
        }
        if let skillGroupArn = skillGroupArn {
            try encodeContainer.encode(skillGroupArn, forKey: .skillGroupArn)
        }
    }
}

public struct DisassociateSkillGroupFromRoomInputHeadersMiddleware: Middleware {
    public let id: String = "DisassociateSkillGroupFromRoomInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateSkillGroupFromRoomInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateSkillGroupFromRoomOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateSkillGroupFromRoomInput>
    public typealias MOutput = OperationOutput<DisassociateSkillGroupFromRoomOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateSkillGroupFromRoomOutputError>
}

public struct DisassociateSkillGroupFromRoomInputQueryItemMiddleware: Middleware {
    public let id: String = "DisassociateSkillGroupFromRoomInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateSkillGroupFromRoomInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateSkillGroupFromRoomOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateSkillGroupFromRoomInput>
    public typealias MOutput = OperationOutput<DisassociateSkillGroupFromRoomOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateSkillGroupFromRoomOutputError>
}

public struct DisassociateSkillGroupFromRoomInput: Equatable {
    /// <p>The ARN of the room from which the skill group is to be disassociated.
    ///          Required.</p>
    public let roomArn: String?
    /// <p>The ARN of the skill group to disassociate from a room. Required.</p>
    public let skillGroupArn: String?

    public init (
        roomArn: String? = nil,
        skillGroupArn: String? = nil
    )
    {
        self.roomArn = roomArn
        self.skillGroupArn = skillGroupArn
    }
}

struct DisassociateSkillGroupFromRoomInputBody: Equatable {
    public let skillGroupArn: String?
    public let roomArn: String?
}

extension DisassociateSkillGroupFromRoomInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case roomArn = "RoomArn"
        case skillGroupArn = "SkillGroupArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let skillGroupArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .skillGroupArn)
        skillGroupArn = skillGroupArnDecoded
        let roomArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roomArn)
        roomArn = roomArnDecoded
    }
}

extension DisassociateSkillGroupFromRoomOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateSkillGroupFromRoomOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateSkillGroupFromRoomOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateSkillGroupFromRoomOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateSkillGroupFromRoomOutputResponse()"}
}

extension DisassociateSkillGroupFromRoomOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateSkillGroupFromRoomOutputResponse: Equatable {

    public init() {}
}

struct DisassociateSkillGroupFromRoomOutputResponseBody: Equatable {
}

extension DisassociateSkillGroupFromRoomOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public enum DistanceUnit {
    case imperial
    case metric
    case sdkUnknown(String)
}

extension DistanceUnit : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DistanceUnit] {
        return [
            .imperial,
            .metric,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .imperial: return "IMPERIAL"
        case .metric: return "METRIC"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DistanceUnit(rawValue: rawValue) ?? DistanceUnit.sdkUnknown(rawValue)
    }
}

public enum EnablementType {
    case enabled
    case pending
    case sdkUnknown(String)
}

extension EnablementType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [EnablementType] {
        return [
            .enabled,
            .pending,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .enabled: return "ENABLED"
        case .pending: return "PENDING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = EnablementType(rawValue: rawValue) ?? EnablementType.sdkUnknown(rawValue)
    }
}

public enum EnablementTypeFilter {
    case enabled
    case pending
    case sdkUnknown(String)
}

extension EnablementTypeFilter : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [EnablementTypeFilter] {
        return [
            .enabled,
            .pending,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .enabled: return "ENABLED"
        case .pending: return "PENDING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = EnablementTypeFilter(rawValue: rawValue) ?? EnablementTypeFilter.sdkUnknown(rawValue)
    }
}

extension EndOfMeetingReminder: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case enabled = "Enabled"
        case reminderAtMinutes = "ReminderAtMinutes"
        case reminderType = "ReminderType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enabled = enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let reminderAtMinutes = reminderAtMinutes {
            var reminderAtMinutesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .reminderAtMinutes)
            for endofmeetingreminderminuteslist0 in reminderAtMinutes {
                try reminderAtMinutesContainer.encode(endofmeetingreminderminuteslist0)
            }
        }
        if let reminderType = reminderType {
            try encodeContainer.encode(reminderType.rawValue, forKey: .reminderType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reminderAtMinutesContainer = try containerValues.decodeIfPresent([Int?].self, forKey: .reminderAtMinutes)
        var reminderAtMinutesDecoded0:[Int]? = nil
        if let reminderAtMinutesContainer = reminderAtMinutesContainer {
            reminderAtMinutesDecoded0 = [Int]()
            for integer0 in reminderAtMinutesContainer {
                if let integer0 = integer0 {
                    reminderAtMinutesDecoded0?.append(integer0)
                }
            }
        }
        reminderAtMinutes = reminderAtMinutesDecoded0
        let reminderTypeDecoded = try containerValues.decodeIfPresent(EndOfMeetingReminderType.self, forKey: .reminderType)
        reminderType = reminderTypeDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .enabled)
        enabled = enabledDecoded
    }
}

extension EndOfMeetingReminder: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EndOfMeetingReminder(enabled: \(String(describing: enabled)), reminderAtMinutes: \(String(describing: reminderAtMinutes)), reminderType: \(String(describing: reminderType)))"}
}

/// <p>Settings for the end of meeting reminder feature that are applied to a room profile. The
///          end of meeting reminder enables Alexa to remind users when a meeting is ending. </p>
public struct EndOfMeetingReminder: Equatable {
    /// <p>Whether an end of meeting reminder is enabled or not.</p>
    public let enabled: Bool?
    /// <p>A range of 3 to 15 minutes that determines when the reminder begins.</p>
    public let reminderAtMinutes: [Int]?
    /// <p>The type of sound that users hear during the end of meeting reminder. </p>
    public let reminderType: EndOfMeetingReminderType?

    public init (
        enabled: Bool? = nil,
        reminderAtMinutes: [Int]? = nil,
        reminderType: EndOfMeetingReminderType? = nil
    )
    {
        self.enabled = enabled
        self.reminderAtMinutes = reminderAtMinutes
        self.reminderType = reminderType
    }
}

public enum EndOfMeetingReminderType {
    case announcementTimeCheck
    case announcementVariableTimeLeft
    case chime
    case knock
    case sdkUnknown(String)
}

extension EndOfMeetingReminderType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [EndOfMeetingReminderType] {
        return [
            .announcementTimeCheck,
            .announcementVariableTimeLeft,
            .chime,
            .knock,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .announcementTimeCheck: return "ANNOUNCEMENT_TIME_CHECK"
        case .announcementVariableTimeLeft: return "ANNOUNCEMENT_VARIABLE_TIME_LEFT"
        case .chime: return "CHIME"
        case .knock: return "KNOCK"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = EndOfMeetingReminderType(rawValue: rawValue) ?? EndOfMeetingReminderType.sdkUnknown(rawValue)
    }
}

public enum EnrollmentStatus {
    case deregistering
    case disassociating
    case initialized
    case pending
    case registered
    case sdkUnknown(String)
}

extension EnrollmentStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [EnrollmentStatus] {
        return [
            .deregistering,
            .disassociating,
            .initialized,
            .pending,
            .registered,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .deregistering: return "DEREGISTERING"
        case .disassociating: return "DISASSOCIATING"
        case .initialized: return "INITIALIZED"
        case .pending: return "PENDING"
        case .registered: return "REGISTERED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = EnrollmentStatus(rawValue: rawValue) ?? EnrollmentStatus.sdkUnknown(rawValue)
    }
}

public enum Feature {
    case all
    case bluetooth
    case lists
    case networkProfile
    case notifications
    case settings
    case skills
    case volume
    case sdkUnknown(String)
}

extension Feature : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Feature] {
        return [
            .all,
            .bluetooth,
            .lists,
            .networkProfile,
            .notifications,
            .settings,
            .skills,
            .volume,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .all: return "ALL"
        case .bluetooth: return "BLUETOOTH"
        case .lists: return "LISTS"
        case .networkProfile: return "NETWORK_PROFILE"
        case .notifications: return "NOTIFICATIONS"
        case .settings: return "SETTINGS"
        case .skills: return "SKILLS"
        case .volume: return "VOLUME"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Feature(rawValue: rawValue) ?? Feature.sdkUnknown(rawValue)
    }
}

extension Filter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case values = "Values"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for filtervaluelist0 in values {
                try valuesContainer.encode(filtervaluelist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .values)
        var valuesDecoded0:[String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension Filter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Filter(key: \(String(describing: key)), values: \(String(describing: values)))"}
}

/// <p>A filter name and value pair that is used to return a more specific list of results.
///          Filters can be used to match a set of resources by various criteria.</p>
public struct Filter: Equatable {
    /// <p>The key of a filter.</p>
    public let key: String?
    /// <p>The values of a filter.</p>
    public let values: [String]?

    public init (
        key: String? = nil,
        values: [String]? = nil
    )
    {
        self.key = key
        self.values = values
    }
}

public struct ForgetSmartHomeAppliancesInputBodyMiddleware: Middleware {
    public let id: String = "ForgetSmartHomeAppliancesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ForgetSmartHomeAppliancesInput>,
                  next: H) -> Swift.Result<OperationOutput<ForgetSmartHomeAppliancesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ForgetSmartHomeAppliancesInput>
    public typealias MOutput = OperationOutput<ForgetSmartHomeAppliancesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ForgetSmartHomeAppliancesOutputError>
}

extension ForgetSmartHomeAppliancesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ForgetSmartHomeAppliancesInput(roomArn: \(String(describing: roomArn)))"}
}

extension ForgetSmartHomeAppliancesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case roomArn = "RoomArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let roomArn = roomArn {
            try encodeContainer.encode(roomArn, forKey: .roomArn)
        }
    }
}

public struct ForgetSmartHomeAppliancesInputHeadersMiddleware: Middleware {
    public let id: String = "ForgetSmartHomeAppliancesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ForgetSmartHomeAppliancesInput>,
                  next: H) -> Swift.Result<OperationOutput<ForgetSmartHomeAppliancesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ForgetSmartHomeAppliancesInput>
    public typealias MOutput = OperationOutput<ForgetSmartHomeAppliancesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ForgetSmartHomeAppliancesOutputError>
}

public struct ForgetSmartHomeAppliancesInputQueryItemMiddleware: Middleware {
    public let id: String = "ForgetSmartHomeAppliancesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ForgetSmartHomeAppliancesInput>,
                  next: H) -> Swift.Result<OperationOutput<ForgetSmartHomeAppliancesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ForgetSmartHomeAppliancesInput>
    public typealias MOutput = OperationOutput<ForgetSmartHomeAppliancesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ForgetSmartHomeAppliancesOutputError>
}

public struct ForgetSmartHomeAppliancesInput: Equatable {
    /// <p>The room that the appliances are associated with.</p>
    public let roomArn: String?

    public init (
        roomArn: String? = nil
    )
    {
        self.roomArn = roomArn
    }
}

struct ForgetSmartHomeAppliancesInputBody: Equatable {
    public let roomArn: String?
}

extension ForgetSmartHomeAppliancesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case roomArn = "RoomArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roomArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roomArn)
        roomArn = roomArnDecoded
    }
}

extension ForgetSmartHomeAppliancesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ForgetSmartHomeAppliancesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ForgetSmartHomeAppliancesOutputError: Equatable {
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ForgetSmartHomeAppliancesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ForgetSmartHomeAppliancesOutputResponse()"}
}

extension ForgetSmartHomeAppliancesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct ForgetSmartHomeAppliancesOutputResponse: Equatable {

    public init() {}
}

struct ForgetSmartHomeAppliancesOutputResponseBody: Equatable {
}

extension ForgetSmartHomeAppliancesOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension Gateway: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case description = "Description"
        case gatewayGroupArn = "GatewayGroupArn"
        case name = "Name"
        case softwareVersion = "SoftwareVersion"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let gatewayGroupArn = gatewayGroupArn {
            try encodeContainer.encode(gatewayGroupArn, forKey: .gatewayGroupArn)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let softwareVersion = softwareVersion {
            try encodeContainer.encode(softwareVersion, forKey: .softwareVersion)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let gatewayGroupArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayGroupArn)
        gatewayGroupArn = gatewayGroupArnDecoded
        let softwareVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .softwareVersion)
        softwareVersion = softwareVersionDecoded
    }
}

extension Gateway: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Gateway(arn: \(String(describing: arn)), description: \(String(describing: description)), gatewayGroupArn: \(String(describing: gatewayGroupArn)), name: \(String(describing: name)), softwareVersion: \(String(describing: softwareVersion)))"}
}

/// <p>The details of the gateway. </p>
public struct Gateway: Equatable {
    /// <p>The ARN of the gateway.</p>
    public let arn: String?
    /// <p>The description of the gateway.</p>
    public let description: String?
    /// <p>The ARN of the gateway group that the gateway is associated to.</p>
    public let gatewayGroupArn: String?
    /// <p>The name of the gateway.</p>
    public let name: String?
    /// <p>The software version of the gateway. The gateway automatically updates its software
    ///          version during normal operation.</p>
    public let softwareVersion: String?

    public init (
        arn: String? = nil,
        description: String? = nil,
        gatewayGroupArn: String? = nil,
        name: String? = nil,
        softwareVersion: String? = nil
    )
    {
        self.arn = arn
        self.description = description
        self.gatewayGroupArn = gatewayGroupArn
        self.name = name
        self.softwareVersion = softwareVersion
    }
}

extension GatewayGroup: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case description = "Description"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension GatewayGroup: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GatewayGroup(arn: \(String(describing: arn)), description: \(String(describing: description)), name: \(String(describing: name)))"}
}

/// <p>The details of the gateway group.</p>
public struct GatewayGroup: Equatable {
    /// <p>The ARN of the gateway group.</p>
    public let arn: String?
    /// <p>The description of the gateway group.</p>
    public let description: String?
    /// <p>The name of the gateway group.</p>
    public let name: String?

    public init (
        arn: String? = nil,
        description: String? = nil,
        name: String? = nil
    )
    {
        self.arn = arn
        self.description = description
        self.name = name
    }
}

extension GatewayGroupSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case description = "Description"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension GatewayGroupSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GatewayGroupSummary(arn: \(String(describing: arn)), description: \(String(describing: description)), name: \(String(describing: name)))"}
}

/// <p>The summary of a gateway group.</p>
public struct GatewayGroupSummary: Equatable {
    /// <p>The ARN of the gateway group.</p>
    public let arn: String?
    /// <p>The description of the gateway group.</p>
    public let description: String?
    /// <p>The name of the gateway group.</p>
    public let name: String?

    public init (
        arn: String? = nil,
        description: String? = nil,
        name: String? = nil
    )
    {
        self.arn = arn
        self.description = description
        self.name = name
    }
}

extension GatewaySummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case description = "Description"
        case gatewayGroupArn = "GatewayGroupArn"
        case name = "Name"
        case softwareVersion = "SoftwareVersion"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let gatewayGroupArn = gatewayGroupArn {
            try encodeContainer.encode(gatewayGroupArn, forKey: .gatewayGroupArn)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let softwareVersion = softwareVersion {
            try encodeContainer.encode(softwareVersion, forKey: .softwareVersion)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let gatewayGroupArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayGroupArn)
        gatewayGroupArn = gatewayGroupArnDecoded
        let softwareVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .softwareVersion)
        softwareVersion = softwareVersionDecoded
    }
}

extension GatewaySummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GatewaySummary(arn: \(String(describing: arn)), description: \(String(describing: description)), gatewayGroupArn: \(String(describing: gatewayGroupArn)), name: \(String(describing: name)), softwareVersion: \(String(describing: softwareVersion)))"}
}

/// <p>The summary of a gateway.</p>
public struct GatewaySummary: Equatable {
    /// <p>The ARN of the gateway.</p>
    public let arn: String?
    /// <p>The description of the gateway.</p>
    public let description: String?
    /// <p>The ARN of the gateway group that the gateway is associated to.</p>
    public let gatewayGroupArn: String?
    /// <p>The name of the gateway.</p>
    public let name: String?
    /// <p>The software version of the gateway. The gateway automatically updates its software
    ///          version during normal operation.</p>
    public let softwareVersion: String?

    public init (
        arn: String? = nil,
        description: String? = nil,
        gatewayGroupArn: String? = nil,
        name: String? = nil,
        softwareVersion: String? = nil
    )
    {
        self.arn = arn
        self.description = description
        self.gatewayGroupArn = gatewayGroupArn
        self.name = name
        self.softwareVersion = softwareVersion
    }
}

public struct GetAddressBookInputBodyMiddleware: Middleware {
    public let id: String = "GetAddressBookInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAddressBookInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAddressBookOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAddressBookInput>
    public typealias MOutput = OperationOutput<GetAddressBookOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAddressBookOutputError>
}

extension GetAddressBookInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAddressBookInput(addressBookArn: \(String(describing: addressBookArn)))"}
}

extension GetAddressBookInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case addressBookArn = "AddressBookArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addressBookArn = addressBookArn {
            try encodeContainer.encode(addressBookArn, forKey: .addressBookArn)
        }
    }
}

public struct GetAddressBookInputHeadersMiddleware: Middleware {
    public let id: String = "GetAddressBookInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAddressBookInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAddressBookOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAddressBookInput>
    public typealias MOutput = OperationOutput<GetAddressBookOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAddressBookOutputError>
}

public struct GetAddressBookInputQueryItemMiddleware: Middleware {
    public let id: String = "GetAddressBookInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAddressBookInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAddressBookOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAddressBookInput>
    public typealias MOutput = OperationOutput<GetAddressBookOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAddressBookOutputError>
}

public struct GetAddressBookInput: Equatable {
    /// <p>The ARN of the address book for which to request details.</p>
    public let addressBookArn: String?

    public init (
        addressBookArn: String? = nil
    )
    {
        self.addressBookArn = addressBookArn
    }
}

struct GetAddressBookInputBody: Equatable {
    public let addressBookArn: String?
}

extension GetAddressBookInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case addressBookArn = "AddressBookArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addressBookArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .addressBookArn)
        addressBookArn = addressBookArnDecoded
    }
}

extension GetAddressBookOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAddressBookOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAddressBookOutputError: Equatable {
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAddressBookOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAddressBookOutputResponse(addressBook: \(String(describing: addressBook)))"}
}

extension GetAddressBookOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetAddressBookOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.addressBook = output.addressBook
        } else {
            self.addressBook = nil
        }
    }
}

public struct GetAddressBookOutputResponse: Equatable {
    /// <p>The details of the requested address book.</p>
    public let addressBook: AddressBook?

    public init (
        addressBook: AddressBook? = nil
    )
    {
        self.addressBook = addressBook
    }
}

struct GetAddressBookOutputResponseBody: Equatable {
    public let addressBook: AddressBook?
}

extension GetAddressBookOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case addressBook = "AddressBook"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addressBookDecoded = try containerValues.decodeIfPresent(AddressBook.self, forKey: .addressBook)
        addressBook = addressBookDecoded
    }
}

extension GetConferencePreferenceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetConferencePreferenceInput()"}
}

extension GetConferencePreferenceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetConferencePreferenceInputHeadersMiddleware: Middleware {
    public let id: String = "GetConferencePreferenceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetConferencePreferenceInput>,
                  next: H) -> Swift.Result<OperationOutput<GetConferencePreferenceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetConferencePreferenceInput>
    public typealias MOutput = OperationOutput<GetConferencePreferenceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetConferencePreferenceOutputError>
}

public struct GetConferencePreferenceInputQueryItemMiddleware: Middleware {
    public let id: String = "GetConferencePreferenceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetConferencePreferenceInput>,
                  next: H) -> Swift.Result<OperationOutput<GetConferencePreferenceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetConferencePreferenceInput>
    public typealias MOutput = OperationOutput<GetConferencePreferenceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetConferencePreferenceOutputError>
}

public struct GetConferencePreferenceInput: Equatable {

    public init() {}
}

struct GetConferencePreferenceInputBody: Equatable {
}

extension GetConferencePreferenceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetConferencePreferenceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetConferencePreferenceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetConferencePreferenceOutputError: Equatable {
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetConferencePreferenceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetConferencePreferenceOutputResponse(preference: \(String(describing: preference)))"}
}

extension GetConferencePreferenceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetConferencePreferenceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.preference = output.preference
        } else {
            self.preference = nil
        }
    }
}

public struct GetConferencePreferenceOutputResponse: Equatable {
    /// <p>The conference preference.</p>
    public let preference: ConferencePreference?

    public init (
        preference: ConferencePreference? = nil
    )
    {
        self.preference = preference
    }
}

struct GetConferencePreferenceOutputResponseBody: Equatable {
    public let preference: ConferencePreference?
}

extension GetConferencePreferenceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case preference = "Preference"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let preferenceDecoded = try containerValues.decodeIfPresent(ConferencePreference.self, forKey: .preference)
        preference = preferenceDecoded
    }
}

public struct GetConferenceProviderInputBodyMiddleware: Middleware {
    public let id: String = "GetConferenceProviderInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetConferenceProviderInput>,
                  next: H) -> Swift.Result<OperationOutput<GetConferenceProviderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetConferenceProviderInput>
    public typealias MOutput = OperationOutput<GetConferenceProviderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetConferenceProviderOutputError>
}

extension GetConferenceProviderInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetConferenceProviderInput(conferenceProviderArn: \(String(describing: conferenceProviderArn)))"}
}

extension GetConferenceProviderInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case conferenceProviderArn = "ConferenceProviderArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let conferenceProviderArn = conferenceProviderArn {
            try encodeContainer.encode(conferenceProviderArn, forKey: .conferenceProviderArn)
        }
    }
}

public struct GetConferenceProviderInputHeadersMiddleware: Middleware {
    public let id: String = "GetConferenceProviderInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetConferenceProviderInput>,
                  next: H) -> Swift.Result<OperationOutput<GetConferenceProviderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetConferenceProviderInput>
    public typealias MOutput = OperationOutput<GetConferenceProviderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetConferenceProviderOutputError>
}

public struct GetConferenceProviderInputQueryItemMiddleware: Middleware {
    public let id: String = "GetConferenceProviderInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetConferenceProviderInput>,
                  next: H) -> Swift.Result<OperationOutput<GetConferenceProviderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetConferenceProviderInput>
    public typealias MOutput = OperationOutput<GetConferenceProviderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetConferenceProviderOutputError>
}

public struct GetConferenceProviderInput: Equatable {
    /// <p>The ARN of the newly created conference provider.</p>
    public let conferenceProviderArn: String?

    public init (
        conferenceProviderArn: String? = nil
    )
    {
        self.conferenceProviderArn = conferenceProviderArn
    }
}

struct GetConferenceProviderInputBody: Equatable {
    public let conferenceProviderArn: String?
}

extension GetConferenceProviderInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case conferenceProviderArn = "ConferenceProviderArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let conferenceProviderArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .conferenceProviderArn)
        conferenceProviderArn = conferenceProviderArnDecoded
    }
}

extension GetConferenceProviderOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetConferenceProviderOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetConferenceProviderOutputError: Equatable {
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetConferenceProviderOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetConferenceProviderOutputResponse(conferenceProvider: \(String(describing: conferenceProvider)))"}
}

extension GetConferenceProviderOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetConferenceProviderOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.conferenceProvider = output.conferenceProvider
        } else {
            self.conferenceProvider = nil
        }
    }
}

public struct GetConferenceProviderOutputResponse: Equatable {
    /// <p>The conference provider.</p>
    public let conferenceProvider: ConferenceProvider?

    public init (
        conferenceProvider: ConferenceProvider? = nil
    )
    {
        self.conferenceProvider = conferenceProvider
    }
}

struct GetConferenceProviderOutputResponseBody: Equatable {
    public let conferenceProvider: ConferenceProvider?
}

extension GetConferenceProviderOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case conferenceProvider = "ConferenceProvider"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let conferenceProviderDecoded = try containerValues.decodeIfPresent(ConferenceProvider.self, forKey: .conferenceProvider)
        conferenceProvider = conferenceProviderDecoded
    }
}

public struct GetContactInputBodyMiddleware: Middleware {
    public let id: String = "GetContactInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetContactInput>,
                  next: H) -> Swift.Result<OperationOutput<GetContactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetContactInput>
    public typealias MOutput = OperationOutput<GetContactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetContactOutputError>
}

extension GetContactInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetContactInput(contactArn: \(String(describing: contactArn)))"}
}

extension GetContactInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case contactArn = "ContactArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactArn = contactArn {
            try encodeContainer.encode(contactArn, forKey: .contactArn)
        }
    }
}

public struct GetContactInputHeadersMiddleware: Middleware {
    public let id: String = "GetContactInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetContactInput>,
                  next: H) -> Swift.Result<OperationOutput<GetContactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetContactInput>
    public typealias MOutput = OperationOutput<GetContactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetContactOutputError>
}

public struct GetContactInputQueryItemMiddleware: Middleware {
    public let id: String = "GetContactInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetContactInput>,
                  next: H) -> Swift.Result<OperationOutput<GetContactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetContactInput>
    public typealias MOutput = OperationOutput<GetContactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetContactOutputError>
}

public struct GetContactInput: Equatable {
    /// <p>The ARN of the contact for which to request details.</p>
    public let contactArn: String?

    public init (
        contactArn: String? = nil
    )
    {
        self.contactArn = contactArn
    }
}

struct GetContactInputBody: Equatable {
    public let contactArn: String?
}

extension GetContactInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case contactArn = "ContactArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .contactArn)
        contactArn = contactArnDecoded
    }
}

extension GetContactOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetContactOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetContactOutputError: Equatable {
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetContactOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetContactOutputResponse(contact: \(String(describing: contact)))"}
}

extension GetContactOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetContactOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.contact = output.contact
        } else {
            self.contact = nil
        }
    }
}

public struct GetContactOutputResponse: Equatable {
    /// <p>The details of the requested contact.</p>
    public let contact: Contact?

    public init (
        contact: Contact? = nil
    )
    {
        self.contact = contact
    }
}

struct GetContactOutputResponseBody: Equatable {
    public let contact: Contact?
}

extension GetContactOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case contact = "Contact"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactDecoded = try containerValues.decodeIfPresent(Contact.self, forKey: .contact)
        contact = contactDecoded
    }
}

public struct GetDeviceInputBodyMiddleware: Middleware {
    public let id: String = "GetDeviceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDeviceInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDeviceInput>
    public typealias MOutput = OperationOutput<GetDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDeviceOutputError>
}

extension GetDeviceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDeviceInput(deviceArn: \(String(describing: deviceArn)))"}
}

extension GetDeviceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case deviceArn = "DeviceArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceArn = deviceArn {
            try encodeContainer.encode(deviceArn, forKey: .deviceArn)
        }
    }
}

public struct GetDeviceInputHeadersMiddleware: Middleware {
    public let id: String = "GetDeviceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDeviceInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDeviceInput>
    public typealias MOutput = OperationOutput<GetDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDeviceOutputError>
}

public struct GetDeviceInputQueryItemMiddleware: Middleware {
    public let id: String = "GetDeviceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDeviceInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDeviceInput>
    public typealias MOutput = OperationOutput<GetDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDeviceOutputError>
}

public struct GetDeviceInput: Equatable {
    /// <p>The ARN of the device for which to request details. Required.</p>
    public let deviceArn: String?

    public init (
        deviceArn: String? = nil
    )
    {
        self.deviceArn = deviceArn
    }
}

struct GetDeviceInputBody: Equatable {
    public let deviceArn: String?
}

extension GetDeviceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case deviceArn = "DeviceArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deviceArn)
        deviceArn = deviceArnDecoded
    }
}

extension GetDeviceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDeviceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDeviceOutputError: Equatable {
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDeviceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDeviceOutputResponse(device: \(String(describing: device)))"}
}

extension GetDeviceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetDeviceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.device = output.device
        } else {
            self.device = nil
        }
    }
}

public struct GetDeviceOutputResponse: Equatable {
    /// <p>The details of the device requested. Required.</p>
    public let device: Device?

    public init (
        device: Device? = nil
    )
    {
        self.device = device
    }
}

struct GetDeviceOutputResponseBody: Equatable {
    public let device: Device?
}

extension GetDeviceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case device = "Device"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceDecoded = try containerValues.decodeIfPresent(Device.self, forKey: .device)
        device = deviceDecoded
    }
}

public struct GetGatewayGroupInputBodyMiddleware: Middleware {
    public let id: String = "GetGatewayGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetGatewayGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<GetGatewayGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetGatewayGroupInput>
    public typealias MOutput = OperationOutput<GetGatewayGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetGatewayGroupOutputError>
}

extension GetGatewayGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetGatewayGroupInput(gatewayGroupArn: \(String(describing: gatewayGroupArn)))"}
}

extension GetGatewayGroupInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case gatewayGroupArn = "GatewayGroupArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayGroupArn = gatewayGroupArn {
            try encodeContainer.encode(gatewayGroupArn, forKey: .gatewayGroupArn)
        }
    }
}

public struct GetGatewayGroupInputHeadersMiddleware: Middleware {
    public let id: String = "GetGatewayGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetGatewayGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<GetGatewayGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetGatewayGroupInput>
    public typealias MOutput = OperationOutput<GetGatewayGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetGatewayGroupOutputError>
}

public struct GetGatewayGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "GetGatewayGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetGatewayGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<GetGatewayGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetGatewayGroupInput>
    public typealias MOutput = OperationOutput<GetGatewayGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetGatewayGroupOutputError>
}

public struct GetGatewayGroupInput: Equatable {
    /// <p>The ARN of the gateway group to get.</p>
    public let gatewayGroupArn: String?

    public init (
        gatewayGroupArn: String? = nil
    )
    {
        self.gatewayGroupArn = gatewayGroupArn
    }
}

struct GetGatewayGroupInputBody: Equatable {
    public let gatewayGroupArn: String?
}

extension GetGatewayGroupInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case gatewayGroupArn = "GatewayGroupArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayGroupArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayGroupArn)
        gatewayGroupArn = gatewayGroupArnDecoded
    }
}

extension GetGatewayGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetGatewayGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetGatewayGroupOutputError: Equatable {
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetGatewayGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetGatewayGroupOutputResponse(gatewayGroup: \(String(describing: gatewayGroup)))"}
}

extension GetGatewayGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetGatewayGroupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.gatewayGroup = output.gatewayGroup
        } else {
            self.gatewayGroup = nil
        }
    }
}

public struct GetGatewayGroupOutputResponse: Equatable {
    /// <p>The details of the gateway group.</p>
    public let gatewayGroup: GatewayGroup?

    public init (
        gatewayGroup: GatewayGroup? = nil
    )
    {
        self.gatewayGroup = gatewayGroup
    }
}

struct GetGatewayGroupOutputResponseBody: Equatable {
    public let gatewayGroup: GatewayGroup?
}

extension GetGatewayGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case gatewayGroup = "GatewayGroup"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayGroupDecoded = try containerValues.decodeIfPresent(GatewayGroup.self, forKey: .gatewayGroup)
        gatewayGroup = gatewayGroupDecoded
    }
}

public struct GetGatewayInputBodyMiddleware: Middleware {
    public let id: String = "GetGatewayInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetGatewayInput>,
                  next: H) -> Swift.Result<OperationOutput<GetGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetGatewayInput>
    public typealias MOutput = OperationOutput<GetGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetGatewayOutputError>
}

extension GetGatewayInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetGatewayInput(gatewayArn: \(String(describing: gatewayArn)))"}
}

extension GetGatewayInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case gatewayArn = "GatewayArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayArn = gatewayArn {
            try encodeContainer.encode(gatewayArn, forKey: .gatewayArn)
        }
    }
}

public struct GetGatewayInputHeadersMiddleware: Middleware {
    public let id: String = "GetGatewayInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetGatewayInput>,
                  next: H) -> Swift.Result<OperationOutput<GetGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetGatewayInput>
    public typealias MOutput = OperationOutput<GetGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetGatewayOutputError>
}

public struct GetGatewayInputQueryItemMiddleware: Middleware {
    public let id: String = "GetGatewayInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetGatewayInput>,
                  next: H) -> Swift.Result<OperationOutput<GetGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetGatewayInput>
    public typealias MOutput = OperationOutput<GetGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetGatewayOutputError>
}

public struct GetGatewayInput: Equatable {
    /// <p>The ARN of the gateway to get.</p>
    public let gatewayArn: String?

    public init (
        gatewayArn: String? = nil
    )
    {
        self.gatewayArn = gatewayArn
    }
}

struct GetGatewayInputBody: Equatable {
    public let gatewayArn: String?
}

extension GetGatewayInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case gatewayArn = "GatewayArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayArn)
        gatewayArn = gatewayArnDecoded
    }
}

extension GetGatewayOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetGatewayOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetGatewayOutputError: Equatable {
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetGatewayOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetGatewayOutputResponse(gateway: \(String(describing: gateway)))"}
}

extension GetGatewayOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetGatewayOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.gateway = output.gateway
        } else {
            self.gateway = nil
        }
    }
}

public struct GetGatewayOutputResponse: Equatable {
    /// <p>The details of the gateway.</p>
    public let gateway: Gateway?

    public init (
        gateway: Gateway? = nil
    )
    {
        self.gateway = gateway
    }
}

struct GetGatewayOutputResponseBody: Equatable {
    public let gateway: Gateway?
}

extension GetGatewayOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case gateway = "Gateway"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayDecoded = try containerValues.decodeIfPresent(Gateway.self, forKey: .gateway)
        gateway = gatewayDecoded
    }
}

extension GetInvitationConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetInvitationConfigurationInput()"}
}

extension GetInvitationConfigurationInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetInvitationConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "GetInvitationConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetInvitationConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetInvitationConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetInvitationConfigurationInput>
    public typealias MOutput = OperationOutput<GetInvitationConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetInvitationConfigurationOutputError>
}

public struct GetInvitationConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "GetInvitationConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetInvitationConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetInvitationConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetInvitationConfigurationInput>
    public typealias MOutput = OperationOutput<GetInvitationConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetInvitationConfigurationOutputError>
}

public struct GetInvitationConfigurationInput: Equatable {

    public init() {}
}

struct GetInvitationConfigurationInputBody: Equatable {
}

extension GetInvitationConfigurationInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetInvitationConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetInvitationConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetInvitationConfigurationOutputError: Equatable {
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetInvitationConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetInvitationConfigurationOutputResponse(contactEmail: \(String(describing: contactEmail)), organizationName: \(String(describing: organizationName)), privateSkillIds: \(String(describing: privateSkillIds)))"}
}

extension GetInvitationConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetInvitationConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.contactEmail = output.contactEmail
            self.organizationName = output.organizationName
            self.privateSkillIds = output.privateSkillIds
        } else {
            self.contactEmail = nil
            self.organizationName = nil
            self.privateSkillIds = nil
        }
    }
}

public struct GetInvitationConfigurationOutputResponse: Equatable {
    /// <p>The email ID of the organization or individual contact that the enrolled user can use.
    ///       </p>
    public let contactEmail: String?
    /// <p>The name of the organization sending the enrollment invite to a user.</p>
    public let organizationName: String?
    /// <p>The list of private skill IDs that you want to recommend to the user to enable in the
    ///          invitation.</p>
    public let privateSkillIds: [String]?

    public init (
        contactEmail: String? = nil,
        organizationName: String? = nil,
        privateSkillIds: [String]? = nil
    )
    {
        self.contactEmail = contactEmail
        self.organizationName = organizationName
        self.privateSkillIds = privateSkillIds
    }
}

struct GetInvitationConfigurationOutputResponseBody: Equatable {
    public let organizationName: String?
    public let contactEmail: String?
    public let privateSkillIds: [String]?
}

extension GetInvitationConfigurationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case contactEmail = "ContactEmail"
        case organizationName = "OrganizationName"
        case privateSkillIds = "PrivateSkillIds"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .organizationName)
        organizationName = organizationNameDecoded
        let contactEmailDecoded = try containerValues.decodeIfPresent(String.self, forKey: .contactEmail)
        contactEmail = contactEmailDecoded
        let privateSkillIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .privateSkillIds)
        var privateSkillIdsDecoded0:[String]? = nil
        if let privateSkillIdsContainer = privateSkillIdsContainer {
            privateSkillIdsDecoded0 = [String]()
            for string0 in privateSkillIdsContainer {
                if let string0 = string0 {
                    privateSkillIdsDecoded0?.append(string0)
                }
            }
        }
        privateSkillIds = privateSkillIdsDecoded0
    }
}

public struct GetNetworkProfileInputBodyMiddleware: Middleware {
    public let id: String = "GetNetworkProfileInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetNetworkProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<GetNetworkProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetNetworkProfileInput>
    public typealias MOutput = OperationOutput<GetNetworkProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetNetworkProfileOutputError>
}

extension GetNetworkProfileInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetNetworkProfileInput(networkProfileArn: \(String(describing: networkProfileArn)))"}
}

extension GetNetworkProfileInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case networkProfileArn = "NetworkProfileArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let networkProfileArn = networkProfileArn {
            try encodeContainer.encode(networkProfileArn, forKey: .networkProfileArn)
        }
    }
}

public struct GetNetworkProfileInputHeadersMiddleware: Middleware {
    public let id: String = "GetNetworkProfileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetNetworkProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<GetNetworkProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetNetworkProfileInput>
    public typealias MOutput = OperationOutput<GetNetworkProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetNetworkProfileOutputError>
}

public struct GetNetworkProfileInputQueryItemMiddleware: Middleware {
    public let id: String = "GetNetworkProfileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetNetworkProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<GetNetworkProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetNetworkProfileInput>
    public typealias MOutput = OperationOutput<GetNetworkProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetNetworkProfileOutputError>
}

public struct GetNetworkProfileInput: Equatable {
    /// <p>The ARN of the network profile associated with a device.</p>
    public let networkProfileArn: String?

    public init (
        networkProfileArn: String? = nil
    )
    {
        self.networkProfileArn = networkProfileArn
    }
}

struct GetNetworkProfileInputBody: Equatable {
    public let networkProfileArn: String?
}

extension GetNetworkProfileInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case networkProfileArn = "NetworkProfileArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkProfileArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .networkProfileArn)
        networkProfileArn = networkProfileArnDecoded
    }
}

extension GetNetworkProfileOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetNetworkProfileOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidSecretsManagerResourceException" : self = .invalidSecretsManagerResourceException(try InvalidSecretsManagerResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetNetworkProfileOutputError: Equatable {
    case invalidSecretsManagerResourceException(InvalidSecretsManagerResourceException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetNetworkProfileOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetNetworkProfileOutputResponse(networkProfile: \(String(describing: networkProfile)))"}
}

extension GetNetworkProfileOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetNetworkProfileOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.networkProfile = output.networkProfile
        } else {
            self.networkProfile = nil
        }
    }
}

public struct GetNetworkProfileOutputResponse: Equatable {
    /// <p>The network profile associated with a device.</p>
    public let networkProfile: NetworkProfile?

    public init (
        networkProfile: NetworkProfile? = nil
    )
    {
        self.networkProfile = networkProfile
    }
}

struct GetNetworkProfileOutputResponseBody: Equatable {
    public let networkProfile: NetworkProfile?
}

extension GetNetworkProfileOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case networkProfile = "NetworkProfile"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkProfileDecoded = try containerValues.decodeIfPresent(NetworkProfile.self, forKey: .networkProfile)
        networkProfile = networkProfileDecoded
    }
}

public struct GetProfileInputBodyMiddleware: Middleware {
    public let id: String = "GetProfileInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<GetProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetProfileInput>
    public typealias MOutput = OperationOutput<GetProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetProfileOutputError>
}

extension GetProfileInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetProfileInput(profileArn: \(String(describing: profileArn)))"}
}

extension GetProfileInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case profileArn = "ProfileArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let profileArn = profileArn {
            try encodeContainer.encode(profileArn, forKey: .profileArn)
        }
    }
}

public struct GetProfileInputHeadersMiddleware: Middleware {
    public let id: String = "GetProfileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<GetProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetProfileInput>
    public typealias MOutput = OperationOutput<GetProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetProfileOutputError>
}

public struct GetProfileInputQueryItemMiddleware: Middleware {
    public let id: String = "GetProfileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<GetProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetProfileInput>
    public typealias MOutput = OperationOutput<GetProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetProfileOutputError>
}

public struct GetProfileInput: Equatable {
    /// <p>The ARN of the room profile for which to request details. Required.</p>
    public let profileArn: String?

    public init (
        profileArn: String? = nil
    )
    {
        self.profileArn = profileArn
    }
}

struct GetProfileInputBody: Equatable {
    public let profileArn: String?
}

extension GetProfileInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case profileArn = "ProfileArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profileArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .profileArn)
        profileArn = profileArnDecoded
    }
}

extension GetProfileOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetProfileOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetProfileOutputError: Equatable {
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetProfileOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetProfileOutputResponse(profile: \(String(describing: profile)))"}
}

extension GetProfileOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetProfileOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.profile = output.profile
        } else {
            self.profile = nil
        }
    }
}

public struct GetProfileOutputResponse: Equatable {
    /// <p>The details of the room profile requested. Required.</p>
    public let profile: Profile?

    public init (
        profile: Profile? = nil
    )
    {
        self.profile = profile
    }
}

struct GetProfileOutputResponseBody: Equatable {
    public let profile: Profile?
}

extension GetProfileOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case profile = "Profile"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profileDecoded = try containerValues.decodeIfPresent(Profile.self, forKey: .profile)
        profile = profileDecoded
    }
}

public struct GetRoomInputBodyMiddleware: Middleware {
    public let id: String = "GetRoomInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRoomInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRoomOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRoomInput>
    public typealias MOutput = OperationOutput<GetRoomOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRoomOutputError>
}

extension GetRoomInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetRoomInput(roomArn: \(String(describing: roomArn)))"}
}

extension GetRoomInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case roomArn = "RoomArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let roomArn = roomArn {
            try encodeContainer.encode(roomArn, forKey: .roomArn)
        }
    }
}

public struct GetRoomInputHeadersMiddleware: Middleware {
    public let id: String = "GetRoomInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRoomInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRoomOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRoomInput>
    public typealias MOutput = OperationOutput<GetRoomOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRoomOutputError>
}

public struct GetRoomInputQueryItemMiddleware: Middleware {
    public let id: String = "GetRoomInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRoomInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRoomOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRoomInput>
    public typealias MOutput = OperationOutput<GetRoomOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRoomOutputError>
}

public struct GetRoomInput: Equatable {
    /// <p>The ARN of the room for which to request details. Required.</p>
    public let roomArn: String?

    public init (
        roomArn: String? = nil
    )
    {
        self.roomArn = roomArn
    }
}

struct GetRoomInputBody: Equatable {
    public let roomArn: String?
}

extension GetRoomInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case roomArn = "RoomArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roomArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roomArn)
        roomArn = roomArnDecoded
    }
}

extension GetRoomOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetRoomOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetRoomOutputError: Equatable {
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRoomOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetRoomOutputResponse(room: \(String(describing: room)))"}
}

extension GetRoomOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetRoomOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.room = output.room
        } else {
            self.room = nil
        }
    }
}

public struct GetRoomOutputResponse: Equatable {
    /// <p>The details of the room requested.</p>
    public let room: Room?

    public init (
        room: Room? = nil
    )
    {
        self.room = room
    }
}

struct GetRoomOutputResponseBody: Equatable {
    public let room: Room?
}

extension GetRoomOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case room = "Room"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roomDecoded = try containerValues.decodeIfPresent(Room.self, forKey: .room)
        room = roomDecoded
    }
}

public struct GetRoomSkillParameterInputBodyMiddleware: Middleware {
    public let id: String = "GetRoomSkillParameterInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRoomSkillParameterInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRoomSkillParameterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRoomSkillParameterInput>
    public typealias MOutput = OperationOutput<GetRoomSkillParameterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRoomSkillParameterOutputError>
}

extension GetRoomSkillParameterInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetRoomSkillParameterInput(parameterKey: \(String(describing: parameterKey)), roomArn: \(String(describing: roomArn)), skillId: \(String(describing: skillId)))"}
}

extension GetRoomSkillParameterInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case parameterKey = "ParameterKey"
        case roomArn = "RoomArn"
        case skillId = "SkillId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let parameterKey = parameterKey {
            try encodeContainer.encode(parameterKey, forKey: .parameterKey)
        }
        if let roomArn = roomArn {
            try encodeContainer.encode(roomArn, forKey: .roomArn)
        }
        if let skillId = skillId {
            try encodeContainer.encode(skillId, forKey: .skillId)
        }
    }
}

public struct GetRoomSkillParameterInputHeadersMiddleware: Middleware {
    public let id: String = "GetRoomSkillParameterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRoomSkillParameterInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRoomSkillParameterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRoomSkillParameterInput>
    public typealias MOutput = OperationOutput<GetRoomSkillParameterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRoomSkillParameterOutputError>
}

public struct GetRoomSkillParameterInputQueryItemMiddleware: Middleware {
    public let id: String = "GetRoomSkillParameterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRoomSkillParameterInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRoomSkillParameterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRoomSkillParameterInput>
    public typealias MOutput = OperationOutput<GetRoomSkillParameterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRoomSkillParameterOutputError>
}

public struct GetRoomSkillParameterInput: Equatable {
    /// <p>The room skill parameter key for which to get details. Required.</p>
    public let parameterKey: String?
    /// <p>The ARN of the room from which to get the room skill parameter details. </p>
    public let roomArn: String?
    /// <p>The ARN of the skill from which to get the room skill parameter details.
    ///          Required.</p>
    public let skillId: String?

    public init (
        parameterKey: String? = nil,
        roomArn: String? = nil,
        skillId: String? = nil
    )
    {
        self.parameterKey = parameterKey
        self.roomArn = roomArn
        self.skillId = skillId
    }
}

struct GetRoomSkillParameterInputBody: Equatable {
    public let roomArn: String?
    public let skillId: String?
    public let parameterKey: String?
}

extension GetRoomSkillParameterInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case parameterKey = "ParameterKey"
        case roomArn = "RoomArn"
        case skillId = "SkillId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roomArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roomArn)
        roomArn = roomArnDecoded
        let skillIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .skillId)
        skillId = skillIdDecoded
        let parameterKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .parameterKey)
        parameterKey = parameterKeyDecoded
    }
}

extension GetRoomSkillParameterOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetRoomSkillParameterOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetRoomSkillParameterOutputError: Equatable {
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRoomSkillParameterOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetRoomSkillParameterOutputResponse(roomSkillParameter: \(String(describing: roomSkillParameter)))"}
}

extension GetRoomSkillParameterOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetRoomSkillParameterOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.roomSkillParameter = output.roomSkillParameter
        } else {
            self.roomSkillParameter = nil
        }
    }
}

public struct GetRoomSkillParameterOutputResponse: Equatable {
    /// <p>The details of the room skill parameter requested. Required.</p>
    public let roomSkillParameter: RoomSkillParameter?

    public init (
        roomSkillParameter: RoomSkillParameter? = nil
    )
    {
        self.roomSkillParameter = roomSkillParameter
    }
}

struct GetRoomSkillParameterOutputResponseBody: Equatable {
    public let roomSkillParameter: RoomSkillParameter?
}

extension GetRoomSkillParameterOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case roomSkillParameter = "RoomSkillParameter"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roomSkillParameterDecoded = try containerValues.decodeIfPresent(RoomSkillParameter.self, forKey: .roomSkillParameter)
        roomSkillParameter = roomSkillParameterDecoded
    }
}

public struct GetSkillGroupInputBodyMiddleware: Middleware {
    public let id: String = "GetSkillGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSkillGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSkillGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSkillGroupInput>
    public typealias MOutput = OperationOutput<GetSkillGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSkillGroupOutputError>
}

extension GetSkillGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSkillGroupInput(skillGroupArn: \(String(describing: skillGroupArn)))"}
}

extension GetSkillGroupInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case skillGroupArn = "SkillGroupArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let skillGroupArn = skillGroupArn {
            try encodeContainer.encode(skillGroupArn, forKey: .skillGroupArn)
        }
    }
}

public struct GetSkillGroupInputHeadersMiddleware: Middleware {
    public let id: String = "GetSkillGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSkillGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSkillGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSkillGroupInput>
    public typealias MOutput = OperationOutput<GetSkillGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSkillGroupOutputError>
}

public struct GetSkillGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "GetSkillGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSkillGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSkillGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSkillGroupInput>
    public typealias MOutput = OperationOutput<GetSkillGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSkillGroupOutputError>
}

public struct GetSkillGroupInput: Equatable {
    /// <p>The ARN of the skill group for which to get details. Required.</p>
    public let skillGroupArn: String?

    public init (
        skillGroupArn: String? = nil
    )
    {
        self.skillGroupArn = skillGroupArn
    }
}

struct GetSkillGroupInputBody: Equatable {
    public let skillGroupArn: String?
}

extension GetSkillGroupInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case skillGroupArn = "SkillGroupArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let skillGroupArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .skillGroupArn)
        skillGroupArn = skillGroupArnDecoded
    }
}

extension GetSkillGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSkillGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetSkillGroupOutputError: Equatable {
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSkillGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSkillGroupOutputResponse(skillGroup: \(String(describing: skillGroup)))"}
}

extension GetSkillGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetSkillGroupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.skillGroup = output.skillGroup
        } else {
            self.skillGroup = nil
        }
    }
}

public struct GetSkillGroupOutputResponse: Equatable {
    /// <p>The details of the skill group requested. Required.</p>
    public let skillGroup: SkillGroup?

    public init (
        skillGroup: SkillGroup? = nil
    )
    {
        self.skillGroup = skillGroup
    }
}

struct GetSkillGroupOutputResponseBody: Equatable {
    public let skillGroup: SkillGroup?
}

extension GetSkillGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case skillGroup = "SkillGroup"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let skillGroupDecoded = try containerValues.decodeIfPresent(SkillGroup.self, forKey: .skillGroup)
        skillGroup = skillGroupDecoded
    }
}

extension IPDialIn: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case commsProtocol = "CommsProtocol"
        case endpoint = "Endpoint"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let commsProtocol = commsProtocol {
            try encodeContainer.encode(commsProtocol.rawValue, forKey: .commsProtocol)
        }
        if let endpoint = endpoint {
            try encodeContainer.encode(endpoint, forKey: .endpoint)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let commsProtocolDecoded = try containerValues.decodeIfPresent(CommsProtocol.self, forKey: .commsProtocol)
        commsProtocol = commsProtocolDecoded
    }
}

extension IPDialIn: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IPDialIn(commsProtocol: \(String(describing: commsProtocol)), endpoint: \(String(describing: endpoint)))"}
}

/// <p>The IP endpoint and protocol for calling.</p>
public struct IPDialIn: Equatable {
    /// <p>The protocol, including SIP, SIPS, and H323.</p>
    public let commsProtocol: CommsProtocol?
    /// <p>The IP address.</p>
    public let endpoint: String?

    public init (
        commsProtocol: CommsProtocol? = nil,
        endpoint: String? = nil
    )
    {
        self.commsProtocol = commsProtocol
        self.endpoint = endpoint
    }
}

extension InstantBooking: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case durationInMinutes = "DurationInMinutes"
        case enabled = "Enabled"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let durationInMinutes = durationInMinutes {
            try encodeContainer.encode(durationInMinutes, forKey: .durationInMinutes)
        }
        if let enabled = enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let durationInMinutesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .durationInMinutes)
        durationInMinutes = durationInMinutesDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .enabled)
        enabled = enabledDecoded
    }
}

extension InstantBooking: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InstantBooking(durationInMinutes: \(String(describing: durationInMinutes)), enabled: \(String(describing: enabled)))"}
}

/// <p>Settings for the instant booking feature that are applied to a room profile. When users
///          start their meeting with Alexa, Alexa  automatically books the room for the configured
///          duration if the room is available.</p>
public struct InstantBooking: Equatable {
    /// <p>Duration between 15 and 240 minutes at increments of 15 that determines how long to book
    ///          an available room when a meeting is started with Alexa. </p>
    public let durationInMinutes: Int?
    /// <p>Whether instant booking is enabled or not.</p>
    public let enabled: Bool?

    public init (
        durationInMinutes: Int? = nil,
        enabled: Bool? = nil
    )
    {
        self.durationInMinutes = durationInMinutes
        self.enabled = enabled
    }
}

extension InvalidCertificateAuthorityException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidCertificateAuthorityException(message: \(String(describing: message)))"}
}

extension InvalidCertificateAuthorityException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidCertificateAuthorityExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The Certificate Authority can't issue or revoke a certificate.</p>
public struct InvalidCertificateAuthorityException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidCertificateAuthorityExceptionBody: Equatable {
    public let message: String?
}

extension InvalidCertificateAuthorityExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidDeviceException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidDeviceException(message: \(String(describing: message)))"}
}

extension InvalidDeviceException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidDeviceExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The device is in an invalid state.</p>
public struct InvalidDeviceException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidDeviceExceptionBody: Equatable {
    public let message: String?
}

extension InvalidDeviceExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidSecretsManagerResourceException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidSecretsManagerResourceException(message: \(String(describing: message)))"}
}

extension InvalidSecretsManagerResourceException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidSecretsManagerResourceExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A password in SecretsManager is in an invalid state.</p>
public struct InvalidSecretsManagerResourceException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidSecretsManagerResourceExceptionBody: Equatable {
    public let message: String?
}

extension InvalidSecretsManagerResourceExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidServiceLinkedRoleStateException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidServiceLinkedRoleStateException(message: \(String(describing: message)))"}
}

extension InvalidServiceLinkedRoleStateException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidServiceLinkedRoleStateExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The service linked role is locked for deletion. </p>
public struct InvalidServiceLinkedRoleStateException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidServiceLinkedRoleStateExceptionBody: Equatable {
    public let message: String?
}

extension InvalidServiceLinkedRoleStateExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidUserStatusException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidUserStatusException(message: \(String(describing: message)))"}
}

extension InvalidUserStatusException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidUserStatusExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The attempt to update a user is invalid due to the user's current status.</p>
public struct InvalidUserStatusException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidUserStatusExceptionBody: Equatable {
    public let message: String?
}

extension InvalidUserStatusExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LimitExceededException(message: \(String(describing: message)))"}
}

extension LimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You are performing an action that would put you beyond your account's limits.</p>
public struct LimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct LimitExceededExceptionBody: Equatable {
    public let message: String?
}

extension LimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ListBusinessReportSchedulesInputBodyMiddleware: Middleware {
    public let id: String = "ListBusinessReportSchedulesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListBusinessReportSchedulesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListBusinessReportSchedulesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListBusinessReportSchedulesInput>
    public typealias MOutput = OperationOutput<ListBusinessReportSchedulesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListBusinessReportSchedulesOutputError>
}

extension ListBusinessReportSchedulesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListBusinessReportSchedulesInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListBusinessReportSchedulesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListBusinessReportSchedulesInputHeadersMiddleware: Middleware {
    public let id: String = "ListBusinessReportSchedulesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListBusinessReportSchedulesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListBusinessReportSchedulesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListBusinessReportSchedulesInput>
    public typealias MOutput = OperationOutput<ListBusinessReportSchedulesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListBusinessReportSchedulesOutputError>
}

public struct ListBusinessReportSchedulesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListBusinessReportSchedulesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListBusinessReportSchedulesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListBusinessReportSchedulesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListBusinessReportSchedulesInput>
    public typealias MOutput = OperationOutput<ListBusinessReportSchedulesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListBusinessReportSchedulesOutputError>
}

public struct ListBusinessReportSchedulesInput: Equatable {
    /// <p>The maximum number of schedules listed in the call.</p>
    public let maxResults: Int?
    /// <p>The token used to list the remaining schedules from the previous API call.</p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListBusinessReportSchedulesInputBody: Equatable {
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListBusinessReportSchedulesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListBusinessReportSchedulesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListBusinessReportSchedulesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListBusinessReportSchedulesOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension ListBusinessReportSchedulesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListBusinessReportSchedulesOutputResponse(businessReportSchedules: \(String(describing: businessReportSchedules)), nextToken: \(String(describing: nextToken)))"}
}

extension ListBusinessReportSchedulesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListBusinessReportSchedulesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.businessReportSchedules = output.businessReportSchedules
            self.nextToken = output.nextToken
        } else {
            self.businessReportSchedules = nil
            self.nextToken = nil
        }
    }
}

public struct ListBusinessReportSchedulesOutputResponse: Equatable {
    /// <p>The schedule of the reports.</p>
    public let businessReportSchedules: [BusinessReportSchedule]?
    /// <p>The token used to list the remaining schedules from the previous API call.</p>
    public let nextToken: String?

    public init (
        businessReportSchedules: [BusinessReportSchedule]? = nil,
        nextToken: String? = nil
    )
    {
        self.businessReportSchedules = businessReportSchedules
        self.nextToken = nextToken
    }
}

struct ListBusinessReportSchedulesOutputResponseBody: Equatable {
    public let businessReportSchedules: [BusinessReportSchedule]?
    public let nextToken: String?
}

extension ListBusinessReportSchedulesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case businessReportSchedules = "BusinessReportSchedules"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let businessReportSchedulesContainer = try containerValues.decodeIfPresent([BusinessReportSchedule?].self, forKey: .businessReportSchedules)
        var businessReportSchedulesDecoded0:[BusinessReportSchedule]? = nil
        if let businessReportSchedulesContainer = businessReportSchedulesContainer {
            businessReportSchedulesDecoded0 = [BusinessReportSchedule]()
            for structure0 in businessReportSchedulesContainer {
                if let structure0 = structure0 {
                    businessReportSchedulesDecoded0?.append(structure0)
                }
            }
        }
        businessReportSchedules = businessReportSchedulesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListConferenceProvidersInputBodyMiddleware: Middleware {
    public let id: String = "ListConferenceProvidersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListConferenceProvidersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListConferenceProvidersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListConferenceProvidersInput>
    public typealias MOutput = OperationOutput<ListConferenceProvidersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListConferenceProvidersOutputError>
}

extension ListConferenceProvidersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListConferenceProvidersInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListConferenceProvidersInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListConferenceProvidersInputHeadersMiddleware: Middleware {
    public let id: String = "ListConferenceProvidersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListConferenceProvidersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListConferenceProvidersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListConferenceProvidersInput>
    public typealias MOutput = OperationOutput<ListConferenceProvidersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListConferenceProvidersOutputError>
}

public struct ListConferenceProvidersInputQueryItemMiddleware: Middleware {
    public let id: String = "ListConferenceProvidersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListConferenceProvidersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListConferenceProvidersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListConferenceProvidersInput>
    public typealias MOutput = OperationOutput<ListConferenceProvidersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListConferenceProvidersOutputError>
}

public struct ListConferenceProvidersInput: Equatable {
    /// <p>The maximum number of conference providers to be returned, per paginated
    ///          calls.</p>
    public let maxResults: Int?
    /// <p>The tokens used for pagination.</p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListConferenceProvidersInputBody: Equatable {
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListConferenceProvidersInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListConferenceProvidersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListConferenceProvidersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListConferenceProvidersOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension ListConferenceProvidersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListConferenceProvidersOutputResponse(conferenceProviders: \(String(describing: conferenceProviders)), nextToken: \(String(describing: nextToken)))"}
}

extension ListConferenceProvidersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListConferenceProvidersOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.conferenceProviders = output.conferenceProviders
            self.nextToken = output.nextToken
        } else {
            self.conferenceProviders = nil
            self.nextToken = nil
        }
    }
}

public struct ListConferenceProvidersOutputResponse: Equatable {
    /// <p>The conference providers.</p>
    public let conferenceProviders: [ConferenceProvider]?
    /// <p>The tokens used for pagination.</p>
    public let nextToken: String?

    public init (
        conferenceProviders: [ConferenceProvider]? = nil,
        nextToken: String? = nil
    )
    {
        self.conferenceProviders = conferenceProviders
        self.nextToken = nextToken
    }
}

struct ListConferenceProvidersOutputResponseBody: Equatable {
    public let conferenceProviders: [ConferenceProvider]?
    public let nextToken: String?
}

extension ListConferenceProvidersOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case conferenceProviders = "ConferenceProviders"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let conferenceProvidersContainer = try containerValues.decodeIfPresent([ConferenceProvider?].self, forKey: .conferenceProviders)
        var conferenceProvidersDecoded0:[ConferenceProvider]? = nil
        if let conferenceProvidersContainer = conferenceProvidersContainer {
            conferenceProvidersDecoded0 = [ConferenceProvider]()
            for structure0 in conferenceProvidersContainer {
                if let structure0 = structure0 {
                    conferenceProvidersDecoded0?.append(structure0)
                }
            }
        }
        conferenceProviders = conferenceProvidersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListDeviceEventsInputBodyMiddleware: Middleware {
    public let id: String = "ListDeviceEventsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDeviceEventsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDeviceEventsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDeviceEventsInput>
    public typealias MOutput = OperationOutput<ListDeviceEventsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDeviceEventsOutputError>
}

extension ListDeviceEventsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDeviceEventsInput(deviceArn: \(String(describing: deviceArn)), eventType: \(String(describing: eventType)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListDeviceEventsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case deviceArn = "DeviceArn"
        case eventType = "EventType"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceArn = deviceArn {
            try encodeContainer.encode(deviceArn, forKey: .deviceArn)
        }
        if let eventType = eventType {
            try encodeContainer.encode(eventType.rawValue, forKey: .eventType)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListDeviceEventsInputHeadersMiddleware: Middleware {
    public let id: String = "ListDeviceEventsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDeviceEventsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDeviceEventsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDeviceEventsInput>
    public typealias MOutput = OperationOutput<ListDeviceEventsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDeviceEventsOutputError>
}

public struct ListDeviceEventsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListDeviceEventsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDeviceEventsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDeviceEventsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDeviceEventsInput>
    public typealias MOutput = OperationOutput<ListDeviceEventsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDeviceEventsOutputError>
}

public struct ListDeviceEventsInput: Equatable {
    /// <p>The ARN of a device.</p>
    public let deviceArn: String?
    /// <p>The event type to filter device events. If EventType isn't specified, this returns a
    ///          list of all device events in reverse chronological order. If EventType is specified, this
    ///          returns a list of device events for that EventType in reverse chronological order.
    ///       </p>
    public let eventType: DeviceEventType?
    /// <p>The maximum number of results to include in the response. The default value is 50. If
    ///          more results exist than the specified MaxResults value, a token is included in the response
    ///          so that the remaining results can be retrieved. </p>
    public let maxResults: Int?
    /// <p>An optional token returned from a prior request. Use this token for pagination of
    ///          results from this action. If this parameter is specified, the response only includes
    ///          results beyond the token, up to the value specified by MaxResults. When the end of results
    ///          is reached, the response has a value of null.</p>
    public let nextToken: String?

    public init (
        deviceArn: String? = nil,
        eventType: DeviceEventType? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.deviceArn = deviceArn
        self.eventType = eventType
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDeviceEventsInputBody: Equatable {
    public let deviceArn: String?
    public let eventType: DeviceEventType?
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListDeviceEventsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case deviceArn = "DeviceArn"
        case eventType = "EventType"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deviceArn)
        deviceArn = deviceArnDecoded
        let eventTypeDecoded = try containerValues.decodeIfPresent(DeviceEventType.self, forKey: .eventType)
        eventType = eventTypeDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListDeviceEventsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDeviceEventsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDeviceEventsOutputError: Equatable {
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDeviceEventsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDeviceEventsOutputResponse(deviceEvents: \(String(describing: deviceEvents)), nextToken: \(String(describing: nextToken)))"}
}

extension ListDeviceEventsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListDeviceEventsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.deviceEvents = output.deviceEvents
            self.nextToken = output.nextToken
        } else {
            self.deviceEvents = nil
            self.nextToken = nil
        }
    }
}

public struct ListDeviceEventsOutputResponse: Equatable {
    /// <p>The device events requested for the device ARN.</p>
    public let deviceEvents: [DeviceEvent]?
    /// <p>The token returned to indicate that there is more data available.</p>
    public let nextToken: String?

    public init (
        deviceEvents: [DeviceEvent]? = nil,
        nextToken: String? = nil
    )
    {
        self.deviceEvents = deviceEvents
        self.nextToken = nextToken
    }
}

struct ListDeviceEventsOutputResponseBody: Equatable {
    public let deviceEvents: [DeviceEvent]?
    public let nextToken: String?
}

extension ListDeviceEventsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case deviceEvents = "DeviceEvents"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceEventsContainer = try containerValues.decodeIfPresent([DeviceEvent?].self, forKey: .deviceEvents)
        var deviceEventsDecoded0:[DeviceEvent]? = nil
        if let deviceEventsContainer = deviceEventsContainer {
            deviceEventsDecoded0 = [DeviceEvent]()
            for structure0 in deviceEventsContainer {
                if let structure0 = structure0 {
                    deviceEventsDecoded0?.append(structure0)
                }
            }
        }
        deviceEvents = deviceEventsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListGatewayGroupsInputBodyMiddleware: Middleware {
    public let id: String = "ListGatewayGroupsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListGatewayGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListGatewayGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListGatewayGroupsInput>
    public typealias MOutput = OperationOutput<ListGatewayGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListGatewayGroupsOutputError>
}

extension ListGatewayGroupsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListGatewayGroupsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListGatewayGroupsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListGatewayGroupsInputHeadersMiddleware: Middleware {
    public let id: String = "ListGatewayGroupsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListGatewayGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListGatewayGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListGatewayGroupsInput>
    public typealias MOutput = OperationOutput<ListGatewayGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListGatewayGroupsOutputError>
}

public struct ListGatewayGroupsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListGatewayGroupsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListGatewayGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListGatewayGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListGatewayGroupsInput>
    public typealias MOutput = OperationOutput<ListGatewayGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListGatewayGroupsOutputError>
}

public struct ListGatewayGroupsInput: Equatable {
    /// <p>The maximum number of gateway group summaries to return. The default is 50.</p>
    public let maxResults: Int?
    /// <p>The token used to paginate though multiple pages of gateway group summaries.</p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListGatewayGroupsInputBody: Equatable {
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListGatewayGroupsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListGatewayGroupsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListGatewayGroupsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListGatewayGroupsOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension ListGatewayGroupsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListGatewayGroupsOutputResponse(gatewayGroups: \(String(describing: gatewayGroups)), nextToken: \(String(describing: nextToken)))"}
}

extension ListGatewayGroupsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListGatewayGroupsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.gatewayGroups = output.gatewayGroups
            self.nextToken = output.nextToken
        } else {
            self.gatewayGroups = nil
            self.nextToken = nil
        }
    }
}

public struct ListGatewayGroupsOutputResponse: Equatable {
    /// <p>The gateway groups in the list.</p>
    public let gatewayGroups: [GatewayGroupSummary]?
    /// <p>The token used to paginate though multiple pages of gateway group summaries.</p>
    public let nextToken: String?

    public init (
        gatewayGroups: [GatewayGroupSummary]? = nil,
        nextToken: String? = nil
    )
    {
        self.gatewayGroups = gatewayGroups
        self.nextToken = nextToken
    }
}

struct ListGatewayGroupsOutputResponseBody: Equatable {
    public let gatewayGroups: [GatewayGroupSummary]?
    public let nextToken: String?
}

extension ListGatewayGroupsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case gatewayGroups = "GatewayGroups"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayGroupsContainer = try containerValues.decodeIfPresent([GatewayGroupSummary?].self, forKey: .gatewayGroups)
        var gatewayGroupsDecoded0:[GatewayGroupSummary]? = nil
        if let gatewayGroupsContainer = gatewayGroupsContainer {
            gatewayGroupsDecoded0 = [GatewayGroupSummary]()
            for structure0 in gatewayGroupsContainer {
                if let structure0 = structure0 {
                    gatewayGroupsDecoded0?.append(structure0)
                }
            }
        }
        gatewayGroups = gatewayGroupsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListGatewaysInputBodyMiddleware: Middleware {
    public let id: String = "ListGatewaysInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListGatewaysInput>,
                  next: H) -> Swift.Result<OperationOutput<ListGatewaysOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListGatewaysInput>
    public typealias MOutput = OperationOutput<ListGatewaysOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListGatewaysOutputError>
}

extension ListGatewaysInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListGatewaysInput(gatewayGroupArn: \(String(describing: gatewayGroupArn)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListGatewaysInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case gatewayGroupArn = "GatewayGroupArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayGroupArn = gatewayGroupArn {
            try encodeContainer.encode(gatewayGroupArn, forKey: .gatewayGroupArn)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListGatewaysInputHeadersMiddleware: Middleware {
    public let id: String = "ListGatewaysInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListGatewaysInput>,
                  next: H) -> Swift.Result<OperationOutput<ListGatewaysOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListGatewaysInput>
    public typealias MOutput = OperationOutput<ListGatewaysOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListGatewaysOutputError>
}

public struct ListGatewaysInputQueryItemMiddleware: Middleware {
    public let id: String = "ListGatewaysInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListGatewaysInput>,
                  next: H) -> Swift.Result<OperationOutput<ListGatewaysOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListGatewaysInput>
    public typealias MOutput = OperationOutput<ListGatewaysOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListGatewaysOutputError>
}

public struct ListGatewaysInput: Equatable {
    /// <p>The gateway group ARN for which to list gateways.</p>
    public let gatewayGroupArn: String?
    /// <p>The maximum number of gateway summaries to return. The default is 50.</p>
    public let maxResults: Int?
    /// <p>The token used to paginate though multiple pages of gateway summaries.</p>
    public let nextToken: String?

    public init (
        gatewayGroupArn: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.gatewayGroupArn = gatewayGroupArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListGatewaysInputBody: Equatable {
    public let gatewayGroupArn: String?
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListGatewaysInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case gatewayGroupArn = "GatewayGroupArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayGroupArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayGroupArn)
        gatewayGroupArn = gatewayGroupArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListGatewaysOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListGatewaysOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListGatewaysOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension ListGatewaysOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListGatewaysOutputResponse(gateways: \(String(describing: gateways)), nextToken: \(String(describing: nextToken)))"}
}

extension ListGatewaysOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListGatewaysOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.gateways = output.gateways
            self.nextToken = output.nextToken
        } else {
            self.gateways = nil
            self.nextToken = nil
        }
    }
}

public struct ListGatewaysOutputResponse: Equatable {
    /// <p>The gateways in the list.</p>
    public let gateways: [GatewaySummary]?
    /// <p>The token used to paginate though multiple pages of gateway summaries.</p>
    public let nextToken: String?

    public init (
        gateways: [GatewaySummary]? = nil,
        nextToken: String? = nil
    )
    {
        self.gateways = gateways
        self.nextToken = nextToken
    }
}

struct ListGatewaysOutputResponseBody: Equatable {
    public let gateways: [GatewaySummary]?
    public let nextToken: String?
}

extension ListGatewaysOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case gateways = "Gateways"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewaysContainer = try containerValues.decodeIfPresent([GatewaySummary?].self, forKey: .gateways)
        var gatewaysDecoded0:[GatewaySummary]? = nil
        if let gatewaysContainer = gatewaysContainer {
            gatewaysDecoded0 = [GatewaySummary]()
            for structure0 in gatewaysContainer {
                if let structure0 = structure0 {
                    gatewaysDecoded0?.append(structure0)
                }
            }
        }
        gateways = gatewaysDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListSkillsInputBodyMiddleware: Middleware {
    public let id: String = "ListSkillsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSkillsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSkillsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSkillsInput>
    public typealias MOutput = OperationOutput<ListSkillsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSkillsOutputError>
}

extension ListSkillsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListSkillsInput(enablementType: \(String(describing: enablementType)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), skillGroupArn: \(String(describing: skillGroupArn)), skillType: \(String(describing: skillType)))"}
}

extension ListSkillsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case enablementType = "EnablementType"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case skillGroupArn = "SkillGroupArn"
        case skillType = "SkillType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enablementType = enablementType {
            try encodeContainer.encode(enablementType.rawValue, forKey: .enablementType)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let skillGroupArn = skillGroupArn {
            try encodeContainer.encode(skillGroupArn, forKey: .skillGroupArn)
        }
        if let skillType = skillType {
            try encodeContainer.encode(skillType.rawValue, forKey: .skillType)
        }
    }
}

public struct ListSkillsInputHeadersMiddleware: Middleware {
    public let id: String = "ListSkillsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSkillsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSkillsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSkillsInput>
    public typealias MOutput = OperationOutput<ListSkillsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSkillsOutputError>
}

public struct ListSkillsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListSkillsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSkillsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSkillsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSkillsInput>
    public typealias MOutput = OperationOutput<ListSkillsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSkillsOutputError>
}

public struct ListSkillsInput: Equatable {
    /// <p>Whether the skill is enabled under the user's account.</p>
    public let enablementType: EnablementTypeFilter?
    /// <p>The maximum number of results to include in the response. If more results exist than
    ///          the specified <code>MaxResults</code> value, a token is included in the response so that
    ///          the remaining results can be retrieved.</p>
    public let maxResults: Int?
    /// <p>An optional token returned from a prior request. Use this token for pagination of
    ///          results from this action. If this parameter is specified, the response includes only
    ///          results beyond the token, up to the value specified by <code>MaxResults</code>.</p>
    public let nextToken: String?
    /// <p>The ARN of the skill group for which to list enabled skills.</p>
    public let skillGroupArn: String?
    /// <p>Whether the skill is publicly available or is a private skill.</p>
    public let skillType: SkillTypeFilter?

    public init (
        enablementType: EnablementTypeFilter? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        skillGroupArn: String? = nil,
        skillType: SkillTypeFilter? = nil
    )
    {
        self.enablementType = enablementType
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.skillGroupArn = skillGroupArn
        self.skillType = skillType
    }
}

struct ListSkillsInputBody: Equatable {
    public let skillGroupArn: String?
    public let enablementType: EnablementTypeFilter?
    public let skillType: SkillTypeFilter?
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListSkillsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case enablementType = "EnablementType"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case skillGroupArn = "SkillGroupArn"
        case skillType = "SkillType"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let skillGroupArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .skillGroupArn)
        skillGroupArn = skillGroupArnDecoded
        let enablementTypeDecoded = try containerValues.decodeIfPresent(EnablementTypeFilter.self, forKey: .enablementType)
        enablementType = enablementTypeDecoded
        let skillTypeDecoded = try containerValues.decodeIfPresent(SkillTypeFilter.self, forKey: .skillType)
        skillType = skillTypeDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListSkillsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSkillsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListSkillsOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSkillsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListSkillsOutputResponse(nextToken: \(String(describing: nextToken)), skillSummaries: \(String(describing: skillSummaries)))"}
}

extension ListSkillsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListSkillsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.skillSummaries = output.skillSummaries
        } else {
            self.nextToken = nil
            self.skillSummaries = nil
        }
    }
}

public struct ListSkillsOutputResponse: Equatable {
    /// <p>The token returned to indicate that there is more data available.</p>
    public let nextToken: String?
    /// <p>The list of enabled skills requested. Required.</p>
    public let skillSummaries: [SkillSummary]?

    public init (
        nextToken: String? = nil,
        skillSummaries: [SkillSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.skillSummaries = skillSummaries
    }
}

struct ListSkillsOutputResponseBody: Equatable {
    public let skillSummaries: [SkillSummary]?
    public let nextToken: String?
}

extension ListSkillsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case skillSummaries = "SkillSummaries"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let skillSummariesContainer = try containerValues.decodeIfPresent([SkillSummary?].self, forKey: .skillSummaries)
        var skillSummariesDecoded0:[SkillSummary]? = nil
        if let skillSummariesContainer = skillSummariesContainer {
            skillSummariesDecoded0 = [SkillSummary]()
            for structure0 in skillSummariesContainer {
                if let structure0 = structure0 {
                    skillSummariesDecoded0?.append(structure0)
                }
            }
        }
        skillSummaries = skillSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListSkillsStoreCategoriesInputBodyMiddleware: Middleware {
    public let id: String = "ListSkillsStoreCategoriesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSkillsStoreCategoriesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSkillsStoreCategoriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSkillsStoreCategoriesInput>
    public typealias MOutput = OperationOutput<ListSkillsStoreCategoriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSkillsStoreCategoriesOutputError>
}

extension ListSkillsStoreCategoriesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListSkillsStoreCategoriesInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListSkillsStoreCategoriesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListSkillsStoreCategoriesInputHeadersMiddleware: Middleware {
    public let id: String = "ListSkillsStoreCategoriesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSkillsStoreCategoriesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSkillsStoreCategoriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSkillsStoreCategoriesInput>
    public typealias MOutput = OperationOutput<ListSkillsStoreCategoriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSkillsStoreCategoriesOutputError>
}

public struct ListSkillsStoreCategoriesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListSkillsStoreCategoriesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSkillsStoreCategoriesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSkillsStoreCategoriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSkillsStoreCategoriesInput>
    public typealias MOutput = OperationOutput<ListSkillsStoreCategoriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSkillsStoreCategoriesOutputError>
}

public struct ListSkillsStoreCategoriesInput: Equatable {
    /// <p>The maximum number of categories returned, per paginated calls.</p>
    public let maxResults: Int?
    /// <p>The tokens used for pagination.</p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListSkillsStoreCategoriesInputBody: Equatable {
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListSkillsStoreCategoriesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListSkillsStoreCategoriesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSkillsStoreCategoriesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListSkillsStoreCategoriesOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSkillsStoreCategoriesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListSkillsStoreCategoriesOutputResponse(categoryList: \(String(describing: categoryList)), nextToken: \(String(describing: nextToken)))"}
}

extension ListSkillsStoreCategoriesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListSkillsStoreCategoriesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.categoryList = output.categoryList
            self.nextToken = output.nextToken
        } else {
            self.categoryList = nil
            self.nextToken = nil
        }
    }
}

public struct ListSkillsStoreCategoriesOutputResponse: Equatable {
    /// <p>The list of categories.</p>
    public let categoryList: [Category]?
    /// <p>The tokens used for pagination.</p>
    public let nextToken: String?

    public init (
        categoryList: [Category]? = nil,
        nextToken: String? = nil
    )
    {
        self.categoryList = categoryList
        self.nextToken = nextToken
    }
}

struct ListSkillsStoreCategoriesOutputResponseBody: Equatable {
    public let categoryList: [Category]?
    public let nextToken: String?
}

extension ListSkillsStoreCategoriesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case categoryList = "CategoryList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let categoryListContainer = try containerValues.decodeIfPresent([Category?].self, forKey: .categoryList)
        var categoryListDecoded0:[Category]? = nil
        if let categoryListContainer = categoryListContainer {
            categoryListDecoded0 = [Category]()
            for structure0 in categoryListContainer {
                if let structure0 = structure0 {
                    categoryListDecoded0?.append(structure0)
                }
            }
        }
        categoryList = categoryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListSkillsStoreSkillsByCategoryInputBodyMiddleware: Middleware {
    public let id: String = "ListSkillsStoreSkillsByCategoryInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSkillsStoreSkillsByCategoryInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSkillsStoreSkillsByCategoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSkillsStoreSkillsByCategoryInput>
    public typealias MOutput = OperationOutput<ListSkillsStoreSkillsByCategoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSkillsStoreSkillsByCategoryOutputError>
}

extension ListSkillsStoreSkillsByCategoryInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListSkillsStoreSkillsByCategoryInput(categoryId: \(String(describing: categoryId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListSkillsStoreSkillsByCategoryInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case categoryId = "CategoryId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let categoryId = categoryId {
            try encodeContainer.encode(categoryId, forKey: .categoryId)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListSkillsStoreSkillsByCategoryInputHeadersMiddleware: Middleware {
    public let id: String = "ListSkillsStoreSkillsByCategoryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSkillsStoreSkillsByCategoryInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSkillsStoreSkillsByCategoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSkillsStoreSkillsByCategoryInput>
    public typealias MOutput = OperationOutput<ListSkillsStoreSkillsByCategoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSkillsStoreSkillsByCategoryOutputError>
}

public struct ListSkillsStoreSkillsByCategoryInputQueryItemMiddleware: Middleware {
    public let id: String = "ListSkillsStoreSkillsByCategoryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSkillsStoreSkillsByCategoryInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSkillsStoreSkillsByCategoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSkillsStoreSkillsByCategoryInput>
    public typealias MOutput = OperationOutput<ListSkillsStoreSkillsByCategoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSkillsStoreSkillsByCategoryOutputError>
}

public struct ListSkillsStoreSkillsByCategoryInput: Equatable {
    /// <p>The category ID for which the skills are being retrieved from the skill
    ///          store.</p>
    public let categoryId: Int?
    /// <p>The maximum number of skills returned per paginated calls.</p>
    public let maxResults: Int?
    /// <p>The tokens used for pagination.</p>
    public let nextToken: String?

    public init (
        categoryId: Int? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.categoryId = categoryId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListSkillsStoreSkillsByCategoryInputBody: Equatable {
    public let categoryId: Int?
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListSkillsStoreSkillsByCategoryInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case categoryId = "CategoryId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let categoryIdDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .categoryId)
        categoryId = categoryIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListSkillsStoreSkillsByCategoryOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSkillsStoreSkillsByCategoryOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListSkillsStoreSkillsByCategoryOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSkillsStoreSkillsByCategoryOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListSkillsStoreSkillsByCategoryOutputResponse(nextToken: \(String(describing: nextToken)), skillsStoreSkills: \(String(describing: skillsStoreSkills)))"}
}

extension ListSkillsStoreSkillsByCategoryOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListSkillsStoreSkillsByCategoryOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.skillsStoreSkills = output.skillsStoreSkills
        } else {
            self.nextToken = nil
            self.skillsStoreSkills = nil
        }
    }
}

public struct ListSkillsStoreSkillsByCategoryOutputResponse: Equatable {
    /// <p>The tokens used for pagination.</p>
    public let nextToken: String?
    /// <p>The skill store skills.</p>
    public let skillsStoreSkills: [SkillsStoreSkill]?

    public init (
        nextToken: String? = nil,
        skillsStoreSkills: [SkillsStoreSkill]? = nil
    )
    {
        self.nextToken = nextToken
        self.skillsStoreSkills = skillsStoreSkills
    }
}

struct ListSkillsStoreSkillsByCategoryOutputResponseBody: Equatable {
    public let skillsStoreSkills: [SkillsStoreSkill]?
    public let nextToken: String?
}

extension ListSkillsStoreSkillsByCategoryOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case skillsStoreSkills = "SkillsStoreSkills"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let skillsStoreSkillsContainer = try containerValues.decodeIfPresent([SkillsStoreSkill?].self, forKey: .skillsStoreSkills)
        var skillsStoreSkillsDecoded0:[SkillsStoreSkill]? = nil
        if let skillsStoreSkillsContainer = skillsStoreSkillsContainer {
            skillsStoreSkillsDecoded0 = [SkillsStoreSkill]()
            for structure0 in skillsStoreSkillsContainer {
                if let structure0 = structure0 {
                    skillsStoreSkillsDecoded0?.append(structure0)
                }
            }
        }
        skillsStoreSkills = skillsStoreSkillsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListSmartHomeAppliancesInputBodyMiddleware: Middleware {
    public let id: String = "ListSmartHomeAppliancesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSmartHomeAppliancesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSmartHomeAppliancesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSmartHomeAppliancesInput>
    public typealias MOutput = OperationOutput<ListSmartHomeAppliancesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSmartHomeAppliancesOutputError>
}

extension ListSmartHomeAppliancesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListSmartHomeAppliancesInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), roomArn: \(String(describing: roomArn)))"}
}

extension ListSmartHomeAppliancesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case roomArn = "RoomArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let roomArn = roomArn {
            try encodeContainer.encode(roomArn, forKey: .roomArn)
        }
    }
}

public struct ListSmartHomeAppliancesInputHeadersMiddleware: Middleware {
    public let id: String = "ListSmartHomeAppliancesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSmartHomeAppliancesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSmartHomeAppliancesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSmartHomeAppliancesInput>
    public typealias MOutput = OperationOutput<ListSmartHomeAppliancesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSmartHomeAppliancesOutputError>
}

public struct ListSmartHomeAppliancesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListSmartHomeAppliancesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSmartHomeAppliancesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSmartHomeAppliancesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSmartHomeAppliancesInput>
    public typealias MOutput = OperationOutput<ListSmartHomeAppliancesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSmartHomeAppliancesOutputError>
}

public struct ListSmartHomeAppliancesInput: Equatable {
    /// <p>The maximum number of appliances to be returned, per paginated calls.</p>
    public let maxResults: Int?
    /// <p>The tokens used for pagination.</p>
    public let nextToken: String?
    /// <p>The room that the appliances are associated with.</p>
    public let roomArn: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        roomArn: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.roomArn = roomArn
    }
}

struct ListSmartHomeAppliancesInputBody: Equatable {
    public let roomArn: String?
    public let maxResults: Int?
    public let nextToken: String?
}

extension ListSmartHomeAppliancesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case roomArn = "RoomArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roomArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roomArn)
        roomArn = roomArnDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListSmartHomeAppliancesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSmartHomeAppliancesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListSmartHomeAppliancesOutputError: Equatable {
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSmartHomeAppliancesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListSmartHomeAppliancesOutputResponse(nextToken: \(String(describing: nextToken)), smartHomeAppliances: \(String(describing: smartHomeAppliances)))"}
}

extension ListSmartHomeAppliancesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListSmartHomeAppliancesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.smartHomeAppliances = output.smartHomeAppliances
        } else {
            self.nextToken = nil
            self.smartHomeAppliances = nil
        }
    }
}

public struct ListSmartHomeAppliancesOutputResponse: Equatable {
    /// <p>The tokens used for pagination.</p>
    public let nextToken: String?
    /// <p>The smart home appliances.</p>
    public let smartHomeAppliances: [SmartHomeAppliance]?

    public init (
        nextToken: String? = nil,
        smartHomeAppliances: [SmartHomeAppliance]? = nil
    )
    {
        self.nextToken = nextToken
        self.smartHomeAppliances = smartHomeAppliances
    }
}

struct ListSmartHomeAppliancesOutputResponseBody: Equatable {
    public let smartHomeAppliances: [SmartHomeAppliance]?
    public let nextToken: String?
}

extension ListSmartHomeAppliancesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case smartHomeAppliances = "SmartHomeAppliances"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let smartHomeAppliancesContainer = try containerValues.decodeIfPresent([SmartHomeAppliance?].self, forKey: .smartHomeAppliances)
        var smartHomeAppliancesDecoded0:[SmartHomeAppliance]? = nil
        if let smartHomeAppliancesContainer = smartHomeAppliancesContainer {
            smartHomeAppliancesDecoded0 = [SmartHomeAppliance]()
            for structure0 in smartHomeAppliancesContainer {
                if let structure0 = structure0 {
                    smartHomeAppliancesDecoded0?.append(structure0)
                }
            }
        }
        smartHomeAppliances = smartHomeAppliancesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListTagsInputBodyMiddleware: Middleware {
    public let id: String = "ListTagsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsInput>
    public typealias MOutput = OperationOutput<ListTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsOutputError>
}

extension ListTagsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsInput(arn: \(String(describing: arn)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListTagsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListTagsInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsInput>
    public typealias MOutput = OperationOutput<ListTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsOutputError>
}

public struct ListTagsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsInput>
    public typealias MOutput = OperationOutput<ListTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsOutputError>
}

public struct ListTagsInput: Equatable {
    /// <p>The ARN of the specified resource for which to list tags.</p>
    public let arn: String?
    /// <p>The maximum number of results to include in the response. If more results exist than
    ///          the specified <code>MaxResults</code> value, a token is included in the response so that
    ///          the remaining results can be retrieved.</p>
    public let maxResults: Int?
    /// <p>An optional token returned from a prior request. Use this token for pagination of
    ///          results from this action. If this parameter is specified, the response includes only
    ///          results beyond the token, up to the value specified by <code>MaxResults</code>. </p>
    public let nextToken: String?

    public init (
        arn: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.arn = arn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListTagsInputBody: Equatable {
    public let arn: String?
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListTagsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListTagsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsOutputError: Equatable {
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsOutputResponse(nextToken: \(String(describing: nextToken)), tags: \(String(describing: tags)))"}
}

extension ListTagsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTagsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.tags = output.tags
        } else {
            self.nextToken = nil
            self.tags = nil
        }
    }
}

public struct ListTagsOutputResponse: Equatable {
    /// <p>The token returned to indicate that there is more data available.</p>
    public let nextToken: String?
    /// <p>The tags requested for the specified resource.</p>
    public let tags: [Tag]?

    public init (
        nextToken: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.nextToken = nextToken
        self.tags = tags
    }
}

struct ListTagsOutputResponseBody: Equatable {
    public let tags: [Tag]?
    public let nextToken: String?
}

extension ListTagsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public enum Locale {
    case enUs
    case sdkUnknown(String)
}

extension Locale : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Locale] {
        return [
            .enUs,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .enUs: return "en-US"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Locale(rawValue: rawValue) ?? Locale.sdkUnknown(rawValue)
    }
}

extension MeetingRoomConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case endOfMeetingReminder = "EndOfMeetingReminder"
        case instantBooking = "InstantBooking"
        case requireCheckIn = "RequireCheckIn"
        case roomUtilizationMetricsEnabled = "RoomUtilizationMetricsEnabled"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endOfMeetingReminder = endOfMeetingReminder {
            try encodeContainer.encode(endOfMeetingReminder, forKey: .endOfMeetingReminder)
        }
        if let instantBooking = instantBooking {
            try encodeContainer.encode(instantBooking, forKey: .instantBooking)
        }
        if let requireCheckIn = requireCheckIn {
            try encodeContainer.encode(requireCheckIn, forKey: .requireCheckIn)
        }
        if let roomUtilizationMetricsEnabled = roomUtilizationMetricsEnabled {
            try encodeContainer.encode(roomUtilizationMetricsEnabled, forKey: .roomUtilizationMetricsEnabled)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roomUtilizationMetricsEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .roomUtilizationMetricsEnabled)
        roomUtilizationMetricsEnabled = roomUtilizationMetricsEnabledDecoded
        let endOfMeetingReminderDecoded = try containerValues.decodeIfPresent(EndOfMeetingReminder.self, forKey: .endOfMeetingReminder)
        endOfMeetingReminder = endOfMeetingReminderDecoded
        let instantBookingDecoded = try containerValues.decodeIfPresent(InstantBooking.self, forKey: .instantBooking)
        instantBooking = instantBookingDecoded
        let requireCheckInDecoded = try containerValues.decodeIfPresent(RequireCheckIn.self, forKey: .requireCheckIn)
        requireCheckIn = requireCheckInDecoded
    }
}

extension MeetingRoomConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MeetingRoomConfiguration(endOfMeetingReminder: \(String(describing: endOfMeetingReminder)), instantBooking: \(String(describing: instantBooking)), requireCheckIn: \(String(describing: requireCheckIn)), roomUtilizationMetricsEnabled: \(String(describing: roomUtilizationMetricsEnabled)))"}
}

/// <p>Meeting room settings of a room profile.</p>
public struct MeetingRoomConfiguration: Equatable {
    /// <p>Settings for the end of meeting reminder feature that are applied to a room profile. The
    ///          end of meeting reminder enables Alexa to remind users when a meeting is ending. </p>
    public let endOfMeetingReminder: EndOfMeetingReminder?
    /// <p>Settings to automatically book the room if available for a configured duration when
    ///          joining a meeting with Alexa. </p>
    public let instantBooking: InstantBooking?
    /// <p>Settings for requiring a check in when a room is reserved. Alexa can cancel a room
    ///          reservation if it's not checked into. This makes the room available for others. Users can
    ///          check in by joining the meeting with Alexa or an AVS device, or by saying Alexa, check
    ///          in. </p>
    public let requireCheckIn: RequireCheckIn?
    /// <p>Whether room utilization metrics are enabled or not.</p>
    public let roomUtilizationMetricsEnabled: Bool?

    public init (
        endOfMeetingReminder: EndOfMeetingReminder? = nil,
        instantBooking: InstantBooking? = nil,
        requireCheckIn: RequireCheckIn? = nil,
        roomUtilizationMetricsEnabled: Bool? = nil
    )
    {
        self.endOfMeetingReminder = endOfMeetingReminder
        self.instantBooking = instantBooking
        self.requireCheckIn = requireCheckIn
        self.roomUtilizationMetricsEnabled = roomUtilizationMetricsEnabled
    }
}

extension MeetingSetting: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case requirePin = "RequirePin"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let requirePin = requirePin {
            try encodeContainer.encode(requirePin.rawValue, forKey: .requirePin)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requirePinDecoded = try containerValues.decodeIfPresent(RequirePin.self, forKey: .requirePin)
        requirePin = requirePinDecoded
    }
}

extension MeetingSetting: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MeetingSetting(requirePin: \(String(describing: requirePin)))"}
}

/// <p>The values that indicate whether a pin is always required (YES), never required (NO),
///             or OPTIONAL.</p>
///         <ul>
///             <li>
///                 <p>If YES, Alexa will always ask for a meeting pin.</p>
///             </li>
///             <li>
///                 <p>If NO, Alexa will never ask for a meeting pin.</p>
///             </li>
///             <li>
///                 <p>If OPTIONAL, Alexa will ask if you have a meeting pin and if the customer responds
///                     with yes, it will ask for the meeting pin.</p>
///             </li>
///          </ul>
public struct MeetingSetting: Equatable {
    /// <p>The values that indicate whether the pin is always required.</p>
    public let requirePin: RequirePin?

    public init (
        requirePin: RequirePin? = nil
    )
    {
        self.requirePin = requirePin
    }
}

extension NameInUseException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NameInUseException(message: \(String(describing: message)))"}
}

extension NameInUseException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: NameInUseExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The name sent in the request is already in use.</p>
public struct NameInUseException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct NameInUseExceptionBody: Equatable {
    public let message: String?
}

extension NameInUseExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum NetworkEapMethod {
    case eapTls
    case sdkUnknown(String)
}

extension NetworkEapMethod : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [NetworkEapMethod] {
        return [
            .eapTls,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .eapTls: return "EAP_TLS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = NetworkEapMethod(rawValue: rawValue) ?? NetworkEapMethod.sdkUnknown(rawValue)
    }
}

extension NetworkProfile: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case certificateAuthorityArn = "CertificateAuthorityArn"
        case currentPassword = "CurrentPassword"
        case description = "Description"
        case eapMethod = "EapMethod"
        case networkProfileArn = "NetworkProfileArn"
        case networkProfileName = "NetworkProfileName"
        case nextPassword = "NextPassword"
        case securityType = "SecurityType"
        case ssid = "Ssid"
        case trustAnchors = "TrustAnchors"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateAuthorityArn = certificateAuthorityArn {
            try encodeContainer.encode(certificateAuthorityArn, forKey: .certificateAuthorityArn)
        }
        if let currentPassword = currentPassword {
            try encodeContainer.encode(currentPassword, forKey: .currentPassword)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let eapMethod = eapMethod {
            try encodeContainer.encode(eapMethod.rawValue, forKey: .eapMethod)
        }
        if let networkProfileArn = networkProfileArn {
            try encodeContainer.encode(networkProfileArn, forKey: .networkProfileArn)
        }
        if let networkProfileName = networkProfileName {
            try encodeContainer.encode(networkProfileName, forKey: .networkProfileName)
        }
        if let nextPassword = nextPassword {
            try encodeContainer.encode(nextPassword, forKey: .nextPassword)
        }
        if let securityType = securityType {
            try encodeContainer.encode(securityType.rawValue, forKey: .securityType)
        }
        if let ssid = ssid {
            try encodeContainer.encode(ssid, forKey: .ssid)
        }
        if let trustAnchors = trustAnchors {
            var trustAnchorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .trustAnchors)
            for trustanchorlist0 in trustAnchors {
                try trustAnchorsContainer.encode(trustanchorlist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkProfileArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .networkProfileArn)
        networkProfileArn = networkProfileArnDecoded
        let networkProfileNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .networkProfileName)
        networkProfileName = networkProfileNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let ssidDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ssid)
        ssid = ssidDecoded
        let securityTypeDecoded = try containerValues.decodeIfPresent(NetworkSecurityType.self, forKey: .securityType)
        securityType = securityTypeDecoded
        let eapMethodDecoded = try containerValues.decodeIfPresent(NetworkEapMethod.self, forKey: .eapMethod)
        eapMethod = eapMethodDecoded
        let currentPasswordDecoded = try containerValues.decodeIfPresent(String.self, forKey: .currentPassword)
        currentPassword = currentPasswordDecoded
        let nextPasswordDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextPassword)
        nextPassword = nextPasswordDecoded
        let certificateAuthorityArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificateAuthorityArn)
        certificateAuthorityArn = certificateAuthorityArnDecoded
        let trustAnchorsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .trustAnchors)
        var trustAnchorsDecoded0:[String]? = nil
        if let trustAnchorsContainer = trustAnchorsContainer {
            trustAnchorsDecoded0 = [String]()
            for string0 in trustAnchorsContainer {
                if let string0 = string0 {
                    trustAnchorsDecoded0?.append(string0)
                }
            }
        }
        trustAnchors = trustAnchorsDecoded0
    }
}

extension NetworkProfile: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NetworkProfile(certificateAuthorityArn: \(String(describing: certificateAuthorityArn)), currentPassword: \(String(describing: currentPassword)), description: \(String(describing: description)), eapMethod: \(String(describing: eapMethod)), networkProfileArn: \(String(describing: networkProfileArn)), networkProfileName: \(String(describing: networkProfileName)), nextPassword: \(String(describing: nextPassword)), securityType: \(String(describing: securityType)), ssid: \(String(describing: ssid)), trustAnchors: \(String(describing: trustAnchors)))"}
}

/// <p>The network profile associated with a device.</p>
public struct NetworkProfile: Equatable {
    /// <p>The ARN of the Private Certificate Authority (PCA) created in AWS Certificate Manager
    ///          (ACM). This is used to issue certificates to the devices. </p>
    public let certificateAuthorityArn: String?
    /// <p>The current password of the Wi-Fi network.</p>
    public let currentPassword: String?
    /// <p>Detailed information about a device's network profile.</p>
    public let description: String?
    /// <p>The authentication standard that is used in the EAP framework. Currently, EAP_TLS is
    ///          supported. </p>
    public let eapMethod: NetworkEapMethod?
    /// <p>The ARN of the network profile associated with a device.</p>
    public let networkProfileArn: String?
    /// <p>The name of the network profile associated with a device.</p>
    public let networkProfileName: String?
    /// <p>The next, or subsequent, password of the Wi-Fi network. This password is asynchronously
    ///          transmitted to the device and is used when the password of the network changes to
    ///          NextPassword. </p>
    public let nextPassword: String?
    /// <p>The security type of the Wi-Fi network. This can be WPA2_ENTERPRISE, WPA2_PSK, WPA_PSK,
    ///          WEP, or OPEN.</p>
    public let securityType: NetworkSecurityType?
    /// <p>The SSID of the Wi-Fi network.</p>
    public let ssid: String?
    /// <p>The root certificates of your authentication server, which is installed on your devices
    ///          and used to trust your authentication server during EAP negotiation.</p>
    public let trustAnchors: [String]?

    public init (
        certificateAuthorityArn: String? = nil,
        currentPassword: String? = nil,
        description: String? = nil,
        eapMethod: NetworkEapMethod? = nil,
        networkProfileArn: String? = nil,
        networkProfileName: String? = nil,
        nextPassword: String? = nil,
        securityType: NetworkSecurityType? = nil,
        ssid: String? = nil,
        trustAnchors: [String]? = nil
    )
    {
        self.certificateAuthorityArn = certificateAuthorityArn
        self.currentPassword = currentPassword
        self.description = description
        self.eapMethod = eapMethod
        self.networkProfileArn = networkProfileArn
        self.networkProfileName = networkProfileName
        self.nextPassword = nextPassword
        self.securityType = securityType
        self.ssid = ssid
        self.trustAnchors = trustAnchors
    }
}

extension NetworkProfileData: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case certificateAuthorityArn = "CertificateAuthorityArn"
        case description = "Description"
        case eapMethod = "EapMethod"
        case networkProfileArn = "NetworkProfileArn"
        case networkProfileName = "NetworkProfileName"
        case securityType = "SecurityType"
        case ssid = "Ssid"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateAuthorityArn = certificateAuthorityArn {
            try encodeContainer.encode(certificateAuthorityArn, forKey: .certificateAuthorityArn)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let eapMethod = eapMethod {
            try encodeContainer.encode(eapMethod.rawValue, forKey: .eapMethod)
        }
        if let networkProfileArn = networkProfileArn {
            try encodeContainer.encode(networkProfileArn, forKey: .networkProfileArn)
        }
        if let networkProfileName = networkProfileName {
            try encodeContainer.encode(networkProfileName, forKey: .networkProfileName)
        }
        if let securityType = securityType {
            try encodeContainer.encode(securityType.rawValue, forKey: .securityType)
        }
        if let ssid = ssid {
            try encodeContainer.encode(ssid, forKey: .ssid)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkProfileArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .networkProfileArn)
        networkProfileArn = networkProfileArnDecoded
        let networkProfileNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .networkProfileName)
        networkProfileName = networkProfileNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let ssidDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ssid)
        ssid = ssidDecoded
        let securityTypeDecoded = try containerValues.decodeIfPresent(NetworkSecurityType.self, forKey: .securityType)
        securityType = securityTypeDecoded
        let eapMethodDecoded = try containerValues.decodeIfPresent(NetworkEapMethod.self, forKey: .eapMethod)
        eapMethod = eapMethodDecoded
        let certificateAuthorityArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificateAuthorityArn)
        certificateAuthorityArn = certificateAuthorityArnDecoded
    }
}

extension NetworkProfileData: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NetworkProfileData(certificateAuthorityArn: \(String(describing: certificateAuthorityArn)), description: \(String(describing: description)), eapMethod: \(String(describing: eapMethod)), networkProfileArn: \(String(describing: networkProfileArn)), networkProfileName: \(String(describing: networkProfileName)), securityType: \(String(describing: securityType)), ssid: \(String(describing: ssid)))"}
}

/// <p>The data associated with a network profile.</p>
public struct NetworkProfileData: Equatable {
    /// <p>The ARN of the Private Certificate Authority (PCA) created in AWS Certificate Manager
    ///          (ACM). This is used to issue certificates to the devices.</p>
    public let certificateAuthorityArn: String?
    /// <p>Detailed information about a device's network profile.</p>
    public let description: String?
    /// <p>The authentication standard that is used in the EAP framework. Currently, EAP_TLS is
    ///          supported.</p>
    public let eapMethod: NetworkEapMethod?
    /// <p>The ARN of the network profile associated with a device.</p>
    public let networkProfileArn: String?
    /// <p>The name of the network profile associated with a device.</p>
    public let networkProfileName: String?
    /// <p>The security type of the Wi-Fi network. This can be WPA2_ENTERPRISE, WPA2_PSK, WPA_PSK,
    ///          WEP, or OPEN.</p>
    public let securityType: NetworkSecurityType?
    /// <p>The SSID of the Wi-Fi network.</p>
    public let ssid: String?

    public init (
        certificateAuthorityArn: String? = nil,
        description: String? = nil,
        eapMethod: NetworkEapMethod? = nil,
        networkProfileArn: String? = nil,
        networkProfileName: String? = nil,
        securityType: NetworkSecurityType? = nil,
        ssid: String? = nil
    )
    {
        self.certificateAuthorityArn = certificateAuthorityArn
        self.description = description
        self.eapMethod = eapMethod
        self.networkProfileArn = networkProfileArn
        self.networkProfileName = networkProfileName
        self.securityType = securityType
        self.ssid = ssid
    }
}

public enum NetworkSecurityType {
    case `open`
    case wep
    case wpa2Enterprise
    case wpa2Psk
    case wpaPsk
    case sdkUnknown(String)
}

extension NetworkSecurityType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [NetworkSecurityType] {
        return [
            .open,
            .wep,
            .wpa2Enterprise,
            .wpa2Psk,
            .wpaPsk,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .open: return "OPEN"
        case .wep: return "WEP"
        case .wpa2Enterprise: return "WPA2_ENTERPRISE"
        case .wpa2Psk: return "WPA2_PSK"
        case .wpaPsk: return "WPA_PSK"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = NetworkSecurityType(rawValue: rawValue) ?? NetworkSecurityType.sdkUnknown(rawValue)
    }
}

extension NotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NotFoundException(message: \(String(describing: message)))"}
}

extension NotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: NotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The resource is not found.</p>
public struct NotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct NotFoundExceptionBody: Equatable {
    public let message: String?
}

extension NotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PSTNDialIn: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case countryCode = "CountryCode"
        case oneClickIdDelay = "OneClickIdDelay"
        case oneClickPinDelay = "OneClickPinDelay"
        case phoneNumber = "PhoneNumber"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let countryCode = countryCode {
            try encodeContainer.encode(countryCode, forKey: .countryCode)
        }
        if let oneClickIdDelay = oneClickIdDelay {
            try encodeContainer.encode(oneClickIdDelay, forKey: .oneClickIdDelay)
        }
        if let oneClickPinDelay = oneClickPinDelay {
            try encodeContainer.encode(oneClickPinDelay, forKey: .oneClickPinDelay)
        }
        if let phoneNumber = phoneNumber {
            try encodeContainer.encode(phoneNumber, forKey: .phoneNumber)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let countryCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .countryCode)
        countryCode = countryCodeDecoded
        let phoneNumberDecoded = try containerValues.decodeIfPresent(String.self, forKey: .phoneNumber)
        phoneNumber = phoneNumberDecoded
        let oneClickIdDelayDecoded = try containerValues.decodeIfPresent(String.self, forKey: .oneClickIdDelay)
        oneClickIdDelay = oneClickIdDelayDecoded
        let oneClickPinDelayDecoded = try containerValues.decodeIfPresent(String.self, forKey: .oneClickPinDelay)
        oneClickPinDelay = oneClickPinDelayDecoded
    }
}

extension PSTNDialIn: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PSTNDialIn(countryCode: \(String(describing: countryCode)), oneClickIdDelay: \(String(describing: oneClickIdDelay)), oneClickPinDelay: \(String(describing: oneClickPinDelay)), phoneNumber: \(String(describing: phoneNumber)))"}
}

/// <p>The information for public switched telephone network (PSTN) conferencing.</p>
public struct PSTNDialIn: Equatable {
    /// <p>The zip code.</p>
    public let countryCode: String?
    /// <p>The delay duration before Alexa enters the conference ID with dual-tone multi-frequency (DTMF). Each number on the dial pad corresponds to a DTMF tone, which is how we send data over the telephone network.</p>
    public let oneClickIdDelay: String?
    /// <p>The delay duration before Alexa enters the conference pin with dual-tone multi-frequency (DTMF). Each number on the dial pad corresponds to a DTMF tone, which is how we send data over the telephone network.</p>
    public let oneClickPinDelay: String?
    /// <p>The phone number to call to join the conference.</p>
    public let phoneNumber: String?

    public init (
        countryCode: String? = nil,
        oneClickIdDelay: String? = nil,
        oneClickPinDelay: String? = nil,
        phoneNumber: String? = nil
    )
    {
        self.countryCode = countryCode
        self.oneClickIdDelay = oneClickIdDelay
        self.oneClickPinDelay = oneClickPinDelay
        self.phoneNumber = phoneNumber
    }
}

extension PhoneNumber: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case number = "Number"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let number = number {
            try encodeContainer.encode(number, forKey: .number)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let numberDecoded = try containerValues.decodeIfPresent(String.self, forKey: .number)
        number = numberDecoded
        let typeDecoded = try containerValues.decodeIfPresent(PhoneNumberType.self, forKey: .type)
        type = typeDecoded
    }
}

extension PhoneNumber: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PhoneNumber(number: \(String(describing: number)), type: \(String(describing: type)))"}
}

/// <p>The phone number for the contact containing the raw number and phone number type.</p>
public struct PhoneNumber: Equatable {
    /// <p>The raw value of the phone number.</p>
    public let number: String?
    /// <p>The type of the phone number.</p>
    public let type: PhoneNumberType?

    public init (
        number: String? = nil,
        type: PhoneNumberType? = nil
    )
    {
        self.number = number
        self.type = type
    }
}

public enum PhoneNumberType {
    case home
    case mobile
    case work
    case sdkUnknown(String)
}

extension PhoneNumberType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [PhoneNumberType] {
        return [
            .home,
            .mobile,
            .work,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .home: return "HOME"
        case .mobile: return "MOBILE"
        case .work: return "WORK"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = PhoneNumberType(rawValue: rawValue) ?? PhoneNumberType.sdkUnknown(rawValue)
    }
}

extension Profile: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case address = "Address"
        case addressBookArn = "AddressBookArn"
        case dataRetentionOptIn = "DataRetentionOptIn"
        case distanceUnit = "DistanceUnit"
        case isDefault = "IsDefault"
        case locale = "Locale"
        case maxVolumeLimit = "MaxVolumeLimit"
        case meetingRoomConfiguration = "MeetingRoomConfiguration"
        case pSTNEnabled = "PSTNEnabled"
        case profileArn = "ProfileArn"
        case profileName = "ProfileName"
        case setupModeDisabled = "SetupModeDisabled"
        case temperatureUnit = "TemperatureUnit"
        case timezone = "Timezone"
        case wakeWord = "WakeWord"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let address = address {
            try encodeContainer.encode(address, forKey: .address)
        }
        if let addressBookArn = addressBookArn {
            try encodeContainer.encode(addressBookArn, forKey: .addressBookArn)
        }
        if let dataRetentionOptIn = dataRetentionOptIn {
            try encodeContainer.encode(dataRetentionOptIn, forKey: .dataRetentionOptIn)
        }
        if let distanceUnit = distanceUnit {
            try encodeContainer.encode(distanceUnit.rawValue, forKey: .distanceUnit)
        }
        if let isDefault = isDefault {
            try encodeContainer.encode(isDefault, forKey: .isDefault)
        }
        if let locale = locale {
            try encodeContainer.encode(locale, forKey: .locale)
        }
        if let maxVolumeLimit = maxVolumeLimit {
            try encodeContainer.encode(maxVolumeLimit, forKey: .maxVolumeLimit)
        }
        if let meetingRoomConfiguration = meetingRoomConfiguration {
            try encodeContainer.encode(meetingRoomConfiguration, forKey: .meetingRoomConfiguration)
        }
        if let pSTNEnabled = pSTNEnabled {
            try encodeContainer.encode(pSTNEnabled, forKey: .pSTNEnabled)
        }
        if let profileArn = profileArn {
            try encodeContainer.encode(profileArn, forKey: .profileArn)
        }
        if let profileName = profileName {
            try encodeContainer.encode(profileName, forKey: .profileName)
        }
        if let setupModeDisabled = setupModeDisabled {
            try encodeContainer.encode(setupModeDisabled, forKey: .setupModeDisabled)
        }
        if let temperatureUnit = temperatureUnit {
            try encodeContainer.encode(temperatureUnit.rawValue, forKey: .temperatureUnit)
        }
        if let timezone = timezone {
            try encodeContainer.encode(timezone, forKey: .timezone)
        }
        if let wakeWord = wakeWord {
            try encodeContainer.encode(wakeWord.rawValue, forKey: .wakeWord)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profileArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .profileArn)
        profileArn = profileArnDecoded
        let profileNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .profileName)
        profileName = profileNameDecoded
        let isDefaultDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .isDefault)
        isDefault = isDefaultDecoded
        let addressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .address)
        address = addressDecoded
        let timezoneDecoded = try containerValues.decodeIfPresent(String.self, forKey: .timezone)
        timezone = timezoneDecoded
        let distanceUnitDecoded = try containerValues.decodeIfPresent(DistanceUnit.self, forKey: .distanceUnit)
        distanceUnit = distanceUnitDecoded
        let temperatureUnitDecoded = try containerValues.decodeIfPresent(TemperatureUnit.self, forKey: .temperatureUnit)
        temperatureUnit = temperatureUnitDecoded
        let wakeWordDecoded = try containerValues.decodeIfPresent(WakeWord.self, forKey: .wakeWord)
        wakeWord = wakeWordDecoded
        let localeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .locale)
        locale = localeDecoded
        let setupModeDisabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .setupModeDisabled)
        setupModeDisabled = setupModeDisabledDecoded
        let maxVolumeLimitDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxVolumeLimit)
        maxVolumeLimit = maxVolumeLimitDecoded
        let pSTNEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .pSTNEnabled)
        pSTNEnabled = pSTNEnabledDecoded
        let dataRetentionOptInDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .dataRetentionOptIn)
        dataRetentionOptIn = dataRetentionOptInDecoded
        let addressBookArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .addressBookArn)
        addressBookArn = addressBookArnDecoded
        let meetingRoomConfigurationDecoded = try containerValues.decodeIfPresent(MeetingRoomConfiguration.self, forKey: .meetingRoomConfiguration)
        meetingRoomConfiguration = meetingRoomConfigurationDecoded
    }
}

extension Profile: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Profile(address: \(String(describing: address)), addressBookArn: \(String(describing: addressBookArn)), dataRetentionOptIn: \(String(describing: dataRetentionOptIn)), distanceUnit: \(String(describing: distanceUnit)), isDefault: \(String(describing: isDefault)), locale: \(String(describing: locale)), maxVolumeLimit: \(String(describing: maxVolumeLimit)), meetingRoomConfiguration: \(String(describing: meetingRoomConfiguration)), pSTNEnabled: \(String(describing: pSTNEnabled)), profileArn: \(String(describing: profileArn)), profileName: \(String(describing: profileName)), setupModeDisabled: \(String(describing: setupModeDisabled)), temperatureUnit: \(String(describing: temperatureUnit)), timezone: \(String(describing: timezone)), wakeWord: \(String(describing: wakeWord)))"}
}

/// <p>A room profile with attributes.</p>
public struct Profile: Equatable {
    /// <p>The address of a room profile.</p>
    public let address: String?
    /// <p>The ARN of the address book.</p>
    public let addressBookArn: String?
    /// <p>Whether data retention of the profile is enabled.</p>
    public let dataRetentionOptIn: Bool?
    /// <p>The distance unit of a room profile.</p>
    public let distanceUnit: DistanceUnit?
    /// <p>Retrieves if the profile is default or not.</p>
    public let isDefault: Bool?
    /// <p>The locale of a room profile. (This is currently available only to a limited preview
    ///          audience.)</p>
    public let locale: String?
    /// <p>The max volume limit of a room profile.</p>
    public let maxVolumeLimit: Int?
    /// <p>Meeting room settings of a room profile.</p>
    public let meetingRoomConfiguration: MeetingRoomConfiguration?
    /// <p>The PSTN setting of a room profile.</p>
    public let pSTNEnabled: Bool?
    /// <p>The ARN of a room profile.</p>
    public let profileArn: String?
    /// <p>The name of a room profile.</p>
    public let profileName: String?
    /// <p>The setup mode of a room profile.</p>
    public let setupModeDisabled: Bool?
    /// <p>The temperature unit of a room profile.</p>
    public let temperatureUnit: TemperatureUnit?
    /// <p>The time zone of a room profile.</p>
    public let timezone: String?
    /// <p>The wake word of a room profile.</p>
    public let wakeWord: WakeWord?

    public init (
        address: String? = nil,
        addressBookArn: String? = nil,
        dataRetentionOptIn: Bool? = nil,
        distanceUnit: DistanceUnit? = nil,
        isDefault: Bool? = nil,
        locale: String? = nil,
        maxVolumeLimit: Int? = nil,
        meetingRoomConfiguration: MeetingRoomConfiguration? = nil,
        pSTNEnabled: Bool? = nil,
        profileArn: String? = nil,
        profileName: String? = nil,
        setupModeDisabled: Bool? = nil,
        temperatureUnit: TemperatureUnit? = nil,
        timezone: String? = nil,
        wakeWord: WakeWord? = nil
    )
    {
        self.address = address
        self.addressBookArn = addressBookArn
        self.dataRetentionOptIn = dataRetentionOptIn
        self.distanceUnit = distanceUnit
        self.isDefault = isDefault
        self.locale = locale
        self.maxVolumeLimit = maxVolumeLimit
        self.meetingRoomConfiguration = meetingRoomConfiguration
        self.pSTNEnabled = pSTNEnabled
        self.profileArn = profileArn
        self.profileName = profileName
        self.setupModeDisabled = setupModeDisabled
        self.temperatureUnit = temperatureUnit
        self.timezone = timezone
        self.wakeWord = wakeWord
    }
}

extension ProfileData: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case address = "Address"
        case distanceUnit = "DistanceUnit"
        case isDefault = "IsDefault"
        case locale = "Locale"
        case profileArn = "ProfileArn"
        case profileName = "ProfileName"
        case temperatureUnit = "TemperatureUnit"
        case timezone = "Timezone"
        case wakeWord = "WakeWord"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let address = address {
            try encodeContainer.encode(address, forKey: .address)
        }
        if let distanceUnit = distanceUnit {
            try encodeContainer.encode(distanceUnit.rawValue, forKey: .distanceUnit)
        }
        if let isDefault = isDefault {
            try encodeContainer.encode(isDefault, forKey: .isDefault)
        }
        if let locale = locale {
            try encodeContainer.encode(locale, forKey: .locale)
        }
        if let profileArn = profileArn {
            try encodeContainer.encode(profileArn, forKey: .profileArn)
        }
        if let profileName = profileName {
            try encodeContainer.encode(profileName, forKey: .profileName)
        }
        if let temperatureUnit = temperatureUnit {
            try encodeContainer.encode(temperatureUnit.rawValue, forKey: .temperatureUnit)
        }
        if let timezone = timezone {
            try encodeContainer.encode(timezone, forKey: .timezone)
        }
        if let wakeWord = wakeWord {
            try encodeContainer.encode(wakeWord.rawValue, forKey: .wakeWord)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profileArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .profileArn)
        profileArn = profileArnDecoded
        let profileNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .profileName)
        profileName = profileNameDecoded
        let isDefaultDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .isDefault)
        isDefault = isDefaultDecoded
        let addressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .address)
        address = addressDecoded
        let timezoneDecoded = try containerValues.decodeIfPresent(String.self, forKey: .timezone)
        timezone = timezoneDecoded
        let distanceUnitDecoded = try containerValues.decodeIfPresent(DistanceUnit.self, forKey: .distanceUnit)
        distanceUnit = distanceUnitDecoded
        let temperatureUnitDecoded = try containerValues.decodeIfPresent(TemperatureUnit.self, forKey: .temperatureUnit)
        temperatureUnit = temperatureUnitDecoded
        let wakeWordDecoded = try containerValues.decodeIfPresent(WakeWord.self, forKey: .wakeWord)
        wakeWord = wakeWordDecoded
        let localeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .locale)
        locale = localeDecoded
    }
}

extension ProfileData: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ProfileData(address: \(String(describing: address)), distanceUnit: \(String(describing: distanceUnit)), isDefault: \(String(describing: isDefault)), locale: \(String(describing: locale)), profileArn: \(String(describing: profileArn)), profileName: \(String(describing: profileName)), temperatureUnit: \(String(describing: temperatureUnit)), timezone: \(String(describing: timezone)), wakeWord: \(String(describing: wakeWord)))"}
}

/// <p>The data of a room profile.</p>
public struct ProfileData: Equatable {
    /// <p>The address of a room profile.</p>
    public let address: String?
    /// <p>The distance unit of a room profile.</p>
    public let distanceUnit: DistanceUnit?
    /// <p>Retrieves if the profile data is default or not.</p>
    public let isDefault: Bool?
    /// <p>The locale of a room profile. (This is currently available only to a limited preview
    ///          audience.)</p>
    public let locale: String?
    /// <p>The ARN of a room profile.</p>
    public let profileArn: String?
    /// <p>The name of a room profile.</p>
    public let profileName: String?
    /// <p>The temperature unit of a room profile.</p>
    public let temperatureUnit: TemperatureUnit?
    /// <p>The time zone of a room profile.</p>
    public let timezone: String?
    /// <p>The wake word of a room profile.</p>
    public let wakeWord: WakeWord?

    public init (
        address: String? = nil,
        distanceUnit: DistanceUnit? = nil,
        isDefault: Bool? = nil,
        locale: String? = nil,
        profileArn: String? = nil,
        profileName: String? = nil,
        temperatureUnit: TemperatureUnit? = nil,
        timezone: String? = nil,
        wakeWord: WakeWord? = nil
    )
    {
        self.address = address
        self.distanceUnit = distanceUnit
        self.isDefault = isDefault
        self.locale = locale
        self.profileArn = profileArn
        self.profileName = profileName
        self.temperatureUnit = temperatureUnit
        self.timezone = timezone
        self.wakeWord = wakeWord
    }
}

public struct PutConferencePreferenceInputBodyMiddleware: Middleware {
    public let id: String = "PutConferencePreferenceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutConferencePreferenceInput>,
                  next: H) -> Swift.Result<OperationOutput<PutConferencePreferenceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutConferencePreferenceInput>
    public typealias MOutput = OperationOutput<PutConferencePreferenceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutConferencePreferenceOutputError>
}

extension PutConferencePreferenceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutConferencePreferenceInput(conferencePreference: \(String(describing: conferencePreference)))"}
}

extension PutConferencePreferenceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case conferencePreference = "ConferencePreference"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let conferencePreference = conferencePreference {
            try encodeContainer.encode(conferencePreference, forKey: .conferencePreference)
        }
    }
}

public struct PutConferencePreferenceInputHeadersMiddleware: Middleware {
    public let id: String = "PutConferencePreferenceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutConferencePreferenceInput>,
                  next: H) -> Swift.Result<OperationOutput<PutConferencePreferenceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutConferencePreferenceInput>
    public typealias MOutput = OperationOutput<PutConferencePreferenceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutConferencePreferenceOutputError>
}

public struct PutConferencePreferenceInputQueryItemMiddleware: Middleware {
    public let id: String = "PutConferencePreferenceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutConferencePreferenceInput>,
                  next: H) -> Swift.Result<OperationOutput<PutConferencePreferenceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutConferencePreferenceInput>
    public typealias MOutput = OperationOutput<PutConferencePreferenceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutConferencePreferenceOutputError>
}

public struct PutConferencePreferenceInput: Equatable {
    /// <p>The conference preference of a specific conference provider.</p>
    public let conferencePreference: ConferencePreference?

    public init (
        conferencePreference: ConferencePreference? = nil
    )
    {
        self.conferencePreference = conferencePreference
    }
}

struct PutConferencePreferenceInputBody: Equatable {
    public let conferencePreference: ConferencePreference?
}

extension PutConferencePreferenceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case conferencePreference = "ConferencePreference"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let conferencePreferenceDecoded = try containerValues.decodeIfPresent(ConferencePreference.self, forKey: .conferencePreference)
        conferencePreference = conferencePreferenceDecoded
    }
}

extension PutConferencePreferenceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutConferencePreferenceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutConferencePreferenceOutputError: Equatable {
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutConferencePreferenceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutConferencePreferenceOutputResponse()"}
}

extension PutConferencePreferenceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct PutConferencePreferenceOutputResponse: Equatable {

    public init() {}
}

struct PutConferencePreferenceOutputResponseBody: Equatable {
}

extension PutConferencePreferenceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct PutInvitationConfigurationInputBodyMiddleware: Middleware {
    public let id: String = "PutInvitationConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutInvitationConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<PutInvitationConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutInvitationConfigurationInput>
    public typealias MOutput = OperationOutput<PutInvitationConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutInvitationConfigurationOutputError>
}

extension PutInvitationConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutInvitationConfigurationInput(contactEmail: \(String(describing: contactEmail)), organizationName: \(String(describing: organizationName)), privateSkillIds: \(String(describing: privateSkillIds)))"}
}

extension PutInvitationConfigurationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case contactEmail = "ContactEmail"
        case organizationName = "OrganizationName"
        case privateSkillIds = "PrivateSkillIds"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactEmail = contactEmail {
            try encodeContainer.encode(contactEmail, forKey: .contactEmail)
        }
        if let organizationName = organizationName {
            try encodeContainer.encode(organizationName, forKey: .organizationName)
        }
        if let privateSkillIds = privateSkillIds {
            var privateSkillIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .privateSkillIds)
            for shortskillidlist0 in privateSkillIds {
                try privateSkillIdsContainer.encode(shortskillidlist0)
            }
        }
    }
}

public struct PutInvitationConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "PutInvitationConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutInvitationConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<PutInvitationConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutInvitationConfigurationInput>
    public typealias MOutput = OperationOutput<PutInvitationConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutInvitationConfigurationOutputError>
}

public struct PutInvitationConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "PutInvitationConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutInvitationConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<PutInvitationConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutInvitationConfigurationInput>
    public typealias MOutput = OperationOutput<PutInvitationConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutInvitationConfigurationOutputError>
}

public struct PutInvitationConfigurationInput: Equatable {
    /// <p>The email ID of the organization or individual contact that the enrolled user can use.
    ///       </p>
    public let contactEmail: String?
    /// <p>The name of the organization sending the enrollment invite to a user.</p>
    public let organizationName: String?
    /// <p>The list of private skill IDs that you want to recommend to the user to enable in the
    ///          invitation.</p>
    public let privateSkillIds: [String]?

    public init (
        contactEmail: String? = nil,
        organizationName: String? = nil,
        privateSkillIds: [String]? = nil
    )
    {
        self.contactEmail = contactEmail
        self.organizationName = organizationName
        self.privateSkillIds = privateSkillIds
    }
}

struct PutInvitationConfigurationInputBody: Equatable {
    public let organizationName: String?
    public let contactEmail: String?
    public let privateSkillIds: [String]?
}

extension PutInvitationConfigurationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case contactEmail = "ContactEmail"
        case organizationName = "OrganizationName"
        case privateSkillIds = "PrivateSkillIds"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .organizationName)
        organizationName = organizationNameDecoded
        let contactEmailDecoded = try containerValues.decodeIfPresent(String.self, forKey: .contactEmail)
        contactEmail = contactEmailDecoded
        let privateSkillIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .privateSkillIds)
        var privateSkillIdsDecoded0:[String]? = nil
        if let privateSkillIdsContainer = privateSkillIdsContainer {
            privateSkillIdsDecoded0 = [String]()
            for string0 in privateSkillIdsContainer {
                if let string0 = string0 {
                    privateSkillIdsDecoded0?.append(string0)
                }
            }
        }
        privateSkillIds = privateSkillIdsDecoded0
    }
}

extension PutInvitationConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutInvitationConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutInvitationConfigurationOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutInvitationConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutInvitationConfigurationOutputResponse()"}
}

extension PutInvitationConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct PutInvitationConfigurationOutputResponse: Equatable {

    public init() {}
}

struct PutInvitationConfigurationOutputResponseBody: Equatable {
}

extension PutInvitationConfigurationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct PutRoomSkillParameterInputBodyMiddleware: Middleware {
    public let id: String = "PutRoomSkillParameterInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutRoomSkillParameterInput>,
                  next: H) -> Swift.Result<OperationOutput<PutRoomSkillParameterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutRoomSkillParameterInput>
    public typealias MOutput = OperationOutput<PutRoomSkillParameterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutRoomSkillParameterOutputError>
}

extension PutRoomSkillParameterInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutRoomSkillParameterInput(roomArn: \(String(describing: roomArn)), roomSkillParameter: \(String(describing: roomSkillParameter)), skillId: \(String(describing: skillId)))"}
}

extension PutRoomSkillParameterInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case roomArn = "RoomArn"
        case roomSkillParameter = "RoomSkillParameter"
        case skillId = "SkillId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let roomArn = roomArn {
            try encodeContainer.encode(roomArn, forKey: .roomArn)
        }
        if let roomSkillParameter = roomSkillParameter {
            try encodeContainer.encode(roomSkillParameter, forKey: .roomSkillParameter)
        }
        if let skillId = skillId {
            try encodeContainer.encode(skillId, forKey: .skillId)
        }
    }
}

public struct PutRoomSkillParameterInputHeadersMiddleware: Middleware {
    public let id: String = "PutRoomSkillParameterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutRoomSkillParameterInput>,
                  next: H) -> Swift.Result<OperationOutput<PutRoomSkillParameterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutRoomSkillParameterInput>
    public typealias MOutput = OperationOutput<PutRoomSkillParameterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutRoomSkillParameterOutputError>
}

public struct PutRoomSkillParameterInputQueryItemMiddleware: Middleware {
    public let id: String = "PutRoomSkillParameterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutRoomSkillParameterInput>,
                  next: H) -> Swift.Result<OperationOutput<PutRoomSkillParameterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutRoomSkillParameterInput>
    public typealias MOutput = OperationOutput<PutRoomSkillParameterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutRoomSkillParameterOutputError>
}

public struct PutRoomSkillParameterInput: Equatable {
    /// <p>The ARN of the room associated with the room skill parameter. Required.</p>
    public let roomArn: String?
    /// <p>The updated room skill parameter. Required.</p>
    public let roomSkillParameter: RoomSkillParameter?
    /// <p>The ARN of the skill associated with the room skill parameter. Required.</p>
    public let skillId: String?

    public init (
        roomArn: String? = nil,
        roomSkillParameter: RoomSkillParameter? = nil,
        skillId: String? = nil
    )
    {
        self.roomArn = roomArn
        self.roomSkillParameter = roomSkillParameter
        self.skillId = skillId
    }
}

struct PutRoomSkillParameterInputBody: Equatable {
    public let roomArn: String?
    public let skillId: String?
    public let roomSkillParameter: RoomSkillParameter?
}

extension PutRoomSkillParameterInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case roomArn = "RoomArn"
        case roomSkillParameter = "RoomSkillParameter"
        case skillId = "SkillId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roomArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roomArn)
        roomArn = roomArnDecoded
        let skillIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .skillId)
        skillId = skillIdDecoded
        let roomSkillParameterDecoded = try containerValues.decodeIfPresent(RoomSkillParameter.self, forKey: .roomSkillParameter)
        roomSkillParameter = roomSkillParameterDecoded
    }
}

extension PutRoomSkillParameterOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutRoomSkillParameterOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutRoomSkillParameterOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutRoomSkillParameterOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutRoomSkillParameterOutputResponse()"}
}

extension PutRoomSkillParameterOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct PutRoomSkillParameterOutputResponse: Equatable {

    public init() {}
}

struct PutRoomSkillParameterOutputResponseBody: Equatable {
}

extension PutRoomSkillParameterOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct PutSkillAuthorizationInputBodyMiddleware: Middleware {
    public let id: String = "PutSkillAuthorizationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutSkillAuthorizationInput>,
                  next: H) -> Swift.Result<OperationOutput<PutSkillAuthorizationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutSkillAuthorizationInput>
    public typealias MOutput = OperationOutput<PutSkillAuthorizationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutSkillAuthorizationOutputError>
}

extension PutSkillAuthorizationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutSkillAuthorizationInput(authorizationResult: \(String(describing: authorizationResult)), roomArn: \(String(describing: roomArn)), skillId: \(String(describing: skillId)))"}
}

extension PutSkillAuthorizationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case authorizationResult = "AuthorizationResult"
        case roomArn = "RoomArn"
        case skillId = "SkillId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authorizationResult = authorizationResult {
            var authorizationResultContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .authorizationResult)
            for (dictKey0, authorizationresult0) in authorizationResult {
                try authorizationResultContainer.encode(authorizationresult0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let roomArn = roomArn {
            try encodeContainer.encode(roomArn, forKey: .roomArn)
        }
        if let skillId = skillId {
            try encodeContainer.encode(skillId, forKey: .skillId)
        }
    }
}

public struct PutSkillAuthorizationInputHeadersMiddleware: Middleware {
    public let id: String = "PutSkillAuthorizationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutSkillAuthorizationInput>,
                  next: H) -> Swift.Result<OperationOutput<PutSkillAuthorizationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutSkillAuthorizationInput>
    public typealias MOutput = OperationOutput<PutSkillAuthorizationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutSkillAuthorizationOutputError>
}

public struct PutSkillAuthorizationInputQueryItemMiddleware: Middleware {
    public let id: String = "PutSkillAuthorizationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutSkillAuthorizationInput>,
                  next: H) -> Swift.Result<OperationOutput<PutSkillAuthorizationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutSkillAuthorizationInput>
    public typealias MOutput = OperationOutput<PutSkillAuthorizationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutSkillAuthorizationOutputError>
}

public struct PutSkillAuthorizationInput: Equatable {
    /// <p>The authorization result specific to OAUTH code grant output. "Code must be
    ///          populated in the AuthorizationResult map to establish the authorization.</p>
    public let authorizationResult: [String:String]?
    /// <p>The room that the skill is authorized for.</p>
    public let roomArn: String?
    /// <p>The unique identifier of a skill.</p>
    public let skillId: String?

    public init (
        authorizationResult: [String:String]? = nil,
        roomArn: String? = nil,
        skillId: String? = nil
    )
    {
        self.authorizationResult = authorizationResult
        self.roomArn = roomArn
        self.skillId = skillId
    }
}

struct PutSkillAuthorizationInputBody: Equatable {
    public let authorizationResult: [String:String]?
    public let skillId: String?
    public let roomArn: String?
}

extension PutSkillAuthorizationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case authorizationResult = "AuthorizationResult"
        case roomArn = "RoomArn"
        case skillId = "SkillId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authorizationResultContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .authorizationResult)
        var authorizationResultDecoded0: [String:String]? = nil
        if let authorizationResultContainer = authorizationResultContainer {
            authorizationResultDecoded0 = [String:String]()
            for (key0, value0) in authorizationResultContainer {
                if let value0 = value0 {
                    authorizationResultDecoded0?[key0] = value0
                }
            }
        }
        authorizationResult = authorizationResultDecoded0
        let skillIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .skillId)
        skillId = skillIdDecoded
        let roomArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roomArn)
        roomArn = roomArnDecoded
    }
}

extension PutSkillAuthorizationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutSkillAuthorizationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutSkillAuthorizationOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutSkillAuthorizationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutSkillAuthorizationOutputResponse()"}
}

extension PutSkillAuthorizationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct PutSkillAuthorizationOutputResponse: Equatable {

    public init() {}
}

struct PutSkillAuthorizationOutputResponseBody: Equatable {
}

extension PutSkillAuthorizationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct RegisterAVSDeviceInputBodyMiddleware: Middleware {
    public let id: String = "RegisterAVSDeviceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RegisterAVSDeviceInput>,
                  next: H) -> Swift.Result<OperationOutput<RegisterAVSDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RegisterAVSDeviceInput>
    public typealias MOutput = OperationOutput<RegisterAVSDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RegisterAVSDeviceOutputError>
}

extension RegisterAVSDeviceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RegisterAVSDeviceInput(amazonId: \(String(describing: amazonId)), clientId: \(String(describing: clientId)), deviceSerialNumber: \(String(describing: deviceSerialNumber)), productId: \(String(describing: productId)), roomArn: \(String(describing: roomArn)), tags: \(String(describing: tags)), userCode: \(String(describing: userCode)))"}
}

extension RegisterAVSDeviceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case amazonId = "AmazonId"
        case clientId = "ClientId"
        case deviceSerialNumber = "DeviceSerialNumber"
        case productId = "ProductId"
        case roomArn = "RoomArn"
        case tags = "Tags"
        case userCode = "UserCode"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amazonId = amazonId {
            try encodeContainer.encode(amazonId, forKey: .amazonId)
        }
        if let clientId = clientId {
            try encodeContainer.encode(clientId, forKey: .clientId)
        }
        if let deviceSerialNumber = deviceSerialNumber {
            try encodeContainer.encode(deviceSerialNumber, forKey: .deviceSerialNumber)
        }
        if let productId = productId {
            try encodeContainer.encode(productId, forKey: .productId)
        }
        if let roomArn = roomArn {
            try encodeContainer.encode(roomArn, forKey: .roomArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let userCode = userCode {
            try encodeContainer.encode(userCode, forKey: .userCode)
        }
    }
}

public struct RegisterAVSDeviceInputHeadersMiddleware: Middleware {
    public let id: String = "RegisterAVSDeviceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RegisterAVSDeviceInput>,
                  next: H) -> Swift.Result<OperationOutput<RegisterAVSDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RegisterAVSDeviceInput>
    public typealias MOutput = OperationOutput<RegisterAVSDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RegisterAVSDeviceOutputError>
}

public struct RegisterAVSDeviceInputQueryItemMiddleware: Middleware {
    public let id: String = "RegisterAVSDeviceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RegisterAVSDeviceInput>,
                  next: H) -> Swift.Result<OperationOutput<RegisterAVSDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RegisterAVSDeviceInput>
    public typealias MOutput = OperationOutput<RegisterAVSDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RegisterAVSDeviceOutputError>
}

public struct RegisterAVSDeviceInput: Equatable {
    /// <p>The device type ID for your AVS device generated by Amazon when the OEM creates a new
    ///          product on Amazon's Developer Console.</p>
    public let amazonId: String?
    /// <p>The client ID of the OEM used for code-based linking authorization on an AVS
    ///          device.</p>
    public let clientId: String?
    /// <p>The key generated by the OEM that uniquely identifies a specified instance of your
    ///          AVS device.</p>
    public let deviceSerialNumber: String?
    /// <p>The product ID used to identify your AVS device during authorization.</p>
    public let productId: String?
    /// <p>The Amazon Resource Name (ARN) of the room with which to associate your AVS device.</p>
    public let roomArn: String?
    /// <p>The tags to be added to the specified resource. Do not provide system tags.</p>
    public let tags: [Tag]?
    /// <p>The code that is obtained after your AVS device has made a POST request to LWA as a
    ///          part of the Device Authorization Request component of the OAuth code-based linking
    ///          specification.</p>
    public let userCode: String?

    public init (
        amazonId: String? = nil,
        clientId: String? = nil,
        deviceSerialNumber: String? = nil,
        productId: String? = nil,
        roomArn: String? = nil,
        tags: [Tag]? = nil,
        userCode: String? = nil
    )
    {
        self.amazonId = amazonId
        self.clientId = clientId
        self.deviceSerialNumber = deviceSerialNumber
        self.productId = productId
        self.roomArn = roomArn
        self.tags = tags
        self.userCode = userCode
    }
}

struct RegisterAVSDeviceInputBody: Equatable {
    public let clientId: String?
    public let userCode: String?
    public let productId: String?
    public let deviceSerialNumber: String?
    public let amazonId: String?
    public let roomArn: String?
    public let tags: [Tag]?
}

extension RegisterAVSDeviceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case amazonId = "AmazonId"
        case clientId = "ClientId"
        case deviceSerialNumber = "DeviceSerialNumber"
        case productId = "ProductId"
        case roomArn = "RoomArn"
        case tags = "Tags"
        case userCode = "UserCode"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientId)
        clientId = clientIdDecoded
        let userCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userCode)
        userCode = userCodeDecoded
        let productIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .productId)
        productId = productIdDecoded
        let deviceSerialNumberDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deviceSerialNumber)
        deviceSerialNumber = deviceSerialNumberDecoded
        let amazonIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .amazonId)
        amazonId = amazonIdDecoded
        let roomArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roomArn)
        roomArn = roomArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension RegisterAVSDeviceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RegisterAVSDeviceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDeviceException" : self = .invalidDeviceException(try InvalidDeviceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RegisterAVSDeviceOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidDeviceException(InvalidDeviceException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RegisterAVSDeviceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RegisterAVSDeviceOutputResponse(deviceArn: \(String(describing: deviceArn)))"}
}

extension RegisterAVSDeviceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RegisterAVSDeviceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.deviceArn = output.deviceArn
        } else {
            self.deviceArn = nil
        }
    }
}

public struct RegisterAVSDeviceOutputResponse: Equatable {
    /// <p>The ARN of the device.</p>
    public let deviceArn: String?

    public init (
        deviceArn: String? = nil
    )
    {
        self.deviceArn = deviceArn
    }
}

struct RegisterAVSDeviceOutputResponseBody: Equatable {
    public let deviceArn: String?
}

extension RegisterAVSDeviceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case deviceArn = "DeviceArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deviceArn)
        deviceArn = deviceArnDecoded
    }
}

public struct RejectSkillInputBodyMiddleware: Middleware {
    public let id: String = "RejectSkillInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RejectSkillInput>,
                  next: H) -> Swift.Result<OperationOutput<RejectSkillOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RejectSkillInput>
    public typealias MOutput = OperationOutput<RejectSkillOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RejectSkillOutputError>
}

extension RejectSkillInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RejectSkillInput(skillId: \(String(describing: skillId)))"}
}

extension RejectSkillInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case skillId = "SkillId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let skillId = skillId {
            try encodeContainer.encode(skillId, forKey: .skillId)
        }
    }
}

public struct RejectSkillInputHeadersMiddleware: Middleware {
    public let id: String = "RejectSkillInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RejectSkillInput>,
                  next: H) -> Swift.Result<OperationOutput<RejectSkillOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RejectSkillInput>
    public typealias MOutput = OperationOutput<RejectSkillOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RejectSkillOutputError>
}

public struct RejectSkillInputQueryItemMiddleware: Middleware {
    public let id: String = "RejectSkillInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RejectSkillInput>,
                  next: H) -> Swift.Result<OperationOutput<RejectSkillOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RejectSkillInput>
    public typealias MOutput = OperationOutput<RejectSkillOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RejectSkillOutputError>
}

public struct RejectSkillInput: Equatable {
    /// <p>The unique identifier of the skill.</p>
    public let skillId: String?

    public init (
        skillId: String? = nil
    )
    {
        self.skillId = skillId
    }
}

struct RejectSkillInputBody: Equatable {
    public let skillId: String?
}

extension RejectSkillInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case skillId = "SkillId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let skillIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .skillId)
        skillId = skillIdDecoded
    }
}

extension RejectSkillOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RejectSkillOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RejectSkillOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RejectSkillOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RejectSkillOutputResponse()"}
}

extension RejectSkillOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct RejectSkillOutputResponse: Equatable {

    public init() {}
}

struct RejectSkillOutputResponseBody: Equatable {
}

extension RejectSkillOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension RequireCheckIn: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case enabled = "Enabled"
        case releaseAfterMinutes = "ReleaseAfterMinutes"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enabled = enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let releaseAfterMinutes = releaseAfterMinutes {
            try encodeContainer.encode(releaseAfterMinutes, forKey: .releaseAfterMinutes)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let releaseAfterMinutesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .releaseAfterMinutes)
        releaseAfterMinutes = releaseAfterMinutesDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .enabled)
        enabled = enabledDecoded
    }
}

extension RequireCheckIn: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RequireCheckIn(enabled: \(String(describing: enabled)), releaseAfterMinutes: \(String(describing: releaseAfterMinutes)))"}
}

/// <p>Settings for the require check in feature that are applied to a room profile. Require check in allows a meeting rooms Alexa or AVS device to prompt the user to check in; otherwise, the room will be released. </p>
public struct RequireCheckIn: Equatable {
    /// <p>Whether require check in is enabled or not.</p>
    public let enabled: Bool?
    /// <p>Duration between 5 and 20 minutes to determine when to release the room if it's not checked into. </p>
    public let releaseAfterMinutes: Int?

    public init (
        enabled: Bool? = nil,
        releaseAfterMinutes: Int? = nil
    )
    {
        self.enabled = enabled
        self.releaseAfterMinutes = releaseAfterMinutes
    }
}

public enum RequirePin {
    case no
    case `optional`
    case yes
    case sdkUnknown(String)
}

extension RequirePin : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [RequirePin] {
        return [
            .no,
            .optional,
            .yes,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .no: return "NO"
        case .optional: return "OPTIONAL"
        case .yes: return "YES"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = RequirePin(rawValue: rawValue) ?? RequirePin.sdkUnknown(rawValue)
    }
}

public struct ResolveRoomInputBodyMiddleware: Middleware {
    public let id: String = "ResolveRoomInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ResolveRoomInput>,
                  next: H) -> Swift.Result<OperationOutput<ResolveRoomOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ResolveRoomInput>
    public typealias MOutput = OperationOutput<ResolveRoomOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ResolveRoomOutputError>
}

extension ResolveRoomInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResolveRoomInput(skillId: \(String(describing: skillId)), userId: \(String(describing: userId)))"}
}

extension ResolveRoomInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case skillId = "SkillId"
        case userId = "UserId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let skillId = skillId {
            try encodeContainer.encode(skillId, forKey: .skillId)
        }
        if let userId = userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
    }
}

public struct ResolveRoomInputHeadersMiddleware: Middleware {
    public let id: String = "ResolveRoomInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ResolveRoomInput>,
                  next: H) -> Swift.Result<OperationOutput<ResolveRoomOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ResolveRoomInput>
    public typealias MOutput = OperationOutput<ResolveRoomOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ResolveRoomOutputError>
}

public struct ResolveRoomInputQueryItemMiddleware: Middleware {
    public let id: String = "ResolveRoomInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ResolveRoomInput>,
                  next: H) -> Swift.Result<OperationOutput<ResolveRoomOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ResolveRoomInput>
    public typealias MOutput = OperationOutput<ResolveRoomOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ResolveRoomOutputError>
}

public struct ResolveRoomInput: Equatable {
    /// <p>The ARN of the skill that was requested. Required.</p>
    public let skillId: String?
    /// <p>The ARN of the user. Required.</p>
    public let userId: String?

    public init (
        skillId: String? = nil,
        userId: String? = nil
    )
    {
        self.skillId = skillId
        self.userId = userId
    }
}

struct ResolveRoomInputBody: Equatable {
    public let userId: String?
    public let skillId: String?
}

extension ResolveRoomInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case skillId = "SkillId"
        case userId = "UserId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userId)
        userId = userIdDecoded
        let skillIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .skillId)
        skillId = skillIdDecoded
    }
}

extension ResolveRoomOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ResolveRoomOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ResolveRoomOutputError: Equatable {
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ResolveRoomOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResolveRoomOutputResponse(roomArn: \(String(describing: roomArn)), roomName: \(String(describing: roomName)), roomSkillParameters: \(String(describing: roomSkillParameters)))"}
}

extension ResolveRoomOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResolveRoomOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.roomArn = output.roomArn
            self.roomName = output.roomName
            self.roomSkillParameters = output.roomSkillParameters
        } else {
            self.roomArn = nil
            self.roomName = nil
            self.roomSkillParameters = nil
        }
    }
}

public struct ResolveRoomOutputResponse: Equatable {
    /// <p>The ARN of the room from which the skill request was invoked.</p>
    public let roomArn: String?
    /// <p>The name of the room from which the skill request was invoked.</p>
    public let roomName: String?
    /// <p>Response to get the room profile request. Required.</p>
    public let roomSkillParameters: [RoomSkillParameter]?

    public init (
        roomArn: String? = nil,
        roomName: String? = nil,
        roomSkillParameters: [RoomSkillParameter]? = nil
    )
    {
        self.roomArn = roomArn
        self.roomName = roomName
        self.roomSkillParameters = roomSkillParameters
    }
}

struct ResolveRoomOutputResponseBody: Equatable {
    public let roomArn: String?
    public let roomName: String?
    public let roomSkillParameters: [RoomSkillParameter]?
}

extension ResolveRoomOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case roomArn = "RoomArn"
        case roomName = "RoomName"
        case roomSkillParameters = "RoomSkillParameters"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roomArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roomArn)
        roomArn = roomArnDecoded
        let roomNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roomName)
        roomName = roomNameDecoded
        let roomSkillParametersContainer = try containerValues.decodeIfPresent([RoomSkillParameter?].self, forKey: .roomSkillParameters)
        var roomSkillParametersDecoded0:[RoomSkillParameter]? = nil
        if let roomSkillParametersContainer = roomSkillParametersContainer {
            roomSkillParametersDecoded0 = [RoomSkillParameter]()
            for structure0 in roomSkillParametersContainer {
                if let structure0 = structure0 {
                    roomSkillParametersDecoded0?.append(structure0)
                }
            }
        }
        roomSkillParameters = roomSkillParametersDecoded0
    }
}

extension ResourceAssociatedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceAssociatedException(message: \(String(describing: message)))"}
}

extension ResourceAssociatedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceAssociatedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Another resource is associated with the resource in the request.</p>
public struct ResourceAssociatedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceAssociatedExceptionBody: Equatable {
    public let message: String?
}

extension ResourceAssociatedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceInUseException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceInUseException(clientRequestToken: \(String(describing: clientRequestToken)), message: \(String(describing: message)))"}
}

extension ResourceInUseException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceInUseExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.clientRequestToken = output.clientRequestToken
            self.message = output.message
        } else {
            self.clientRequestToken = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The resource in the request is already in use.</p>
public struct ResourceInUseException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A unique, user-specified identifier for the request that ensures idempotency.</p>
    public var clientRequestToken: String?
    public var message: String?

    public init (
        clientRequestToken: String? = nil,
        message: String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.message = message
    }
}

struct ResourceInUseExceptionBody: Equatable {
    public let message: String?
    public let clientRequestToken: String?
}

extension ResourceInUseExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
    }
}

public struct RevokeInvitationInputBodyMiddleware: Middleware {
    public let id: String = "RevokeInvitationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RevokeInvitationInput>,
                  next: H) -> Swift.Result<OperationOutput<RevokeInvitationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RevokeInvitationInput>
    public typealias MOutput = OperationOutput<RevokeInvitationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RevokeInvitationOutputError>
}

extension RevokeInvitationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RevokeInvitationInput(enrollmentId: \(String(describing: enrollmentId)), userArn: \(String(describing: userArn)))"}
}

extension RevokeInvitationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case enrollmentId = "EnrollmentId"
        case userArn = "UserArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enrollmentId = enrollmentId {
            try encodeContainer.encode(enrollmentId, forKey: .enrollmentId)
        }
        if let userArn = userArn {
            try encodeContainer.encode(userArn, forKey: .userArn)
        }
    }
}

public struct RevokeInvitationInputHeadersMiddleware: Middleware {
    public let id: String = "RevokeInvitationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RevokeInvitationInput>,
                  next: H) -> Swift.Result<OperationOutput<RevokeInvitationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RevokeInvitationInput>
    public typealias MOutput = OperationOutput<RevokeInvitationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RevokeInvitationOutputError>
}

public struct RevokeInvitationInputQueryItemMiddleware: Middleware {
    public let id: String = "RevokeInvitationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RevokeInvitationInput>,
                  next: H) -> Swift.Result<OperationOutput<RevokeInvitationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RevokeInvitationInput>
    public typealias MOutput = OperationOutput<RevokeInvitationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RevokeInvitationOutputError>
}

public struct RevokeInvitationInput: Equatable {
    /// <p>The ARN of the enrollment invitation to revoke. Required.</p>
    public let enrollmentId: String?
    /// <p>The ARN of the user for whom to revoke an enrollment invitation. Required.</p>
    public let userArn: String?

    public init (
        enrollmentId: String? = nil,
        userArn: String? = nil
    )
    {
        self.enrollmentId = enrollmentId
        self.userArn = userArn
    }
}

struct RevokeInvitationInputBody: Equatable {
    public let userArn: String?
    public let enrollmentId: String?
}

extension RevokeInvitationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case enrollmentId = "EnrollmentId"
        case userArn = "UserArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userArn)
        userArn = userArnDecoded
        let enrollmentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .enrollmentId)
        enrollmentId = enrollmentIdDecoded
    }
}

extension RevokeInvitationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RevokeInvitationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RevokeInvitationOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RevokeInvitationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RevokeInvitationOutputResponse()"}
}

extension RevokeInvitationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct RevokeInvitationOutputResponse: Equatable {

    public init() {}
}

struct RevokeInvitationOutputResponseBody: Equatable {
}

extension RevokeInvitationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension Room: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case profileArn = "ProfileArn"
        case providerCalendarId = "ProviderCalendarId"
        case roomArn = "RoomArn"
        case roomName = "RoomName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let profileArn = profileArn {
            try encodeContainer.encode(profileArn, forKey: .profileArn)
        }
        if let providerCalendarId = providerCalendarId {
            try encodeContainer.encode(providerCalendarId, forKey: .providerCalendarId)
        }
        if let roomArn = roomArn {
            try encodeContainer.encode(roomArn, forKey: .roomArn)
        }
        if let roomName = roomName {
            try encodeContainer.encode(roomName, forKey: .roomName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roomArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roomArn)
        roomArn = roomArnDecoded
        let roomNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roomName)
        roomName = roomNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let providerCalendarIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .providerCalendarId)
        providerCalendarId = providerCalendarIdDecoded
        let profileArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .profileArn)
        profileArn = profileArnDecoded
    }
}

extension Room: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Room(description: \(String(describing: description)), profileArn: \(String(describing: profileArn)), providerCalendarId: \(String(describing: providerCalendarId)), roomArn: \(String(describing: roomArn)), roomName: \(String(describing: roomName)))"}
}

/// <p>A room with attributes.</p>
public struct Room: Equatable {
    /// <p>The description of a room.</p>
    public let description: String?
    /// <p>The profile ARN of a room.</p>
    public let profileArn: String?
    /// <p>The provider calendar ARN of a room.</p>
    public let providerCalendarId: String?
    /// <p>The ARN of a room.</p>
    public let roomArn: String?
    /// <p>The name of a room.</p>
    public let roomName: String?

    public init (
        description: String? = nil,
        profileArn: String? = nil,
        providerCalendarId: String? = nil,
        roomArn: String? = nil,
        roomName: String? = nil
    )
    {
        self.description = description
        self.profileArn = profileArn
        self.providerCalendarId = providerCalendarId
        self.roomArn = roomArn
        self.roomName = roomName
    }
}

extension RoomData: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case profileArn = "ProfileArn"
        case profileName = "ProfileName"
        case providerCalendarId = "ProviderCalendarId"
        case roomArn = "RoomArn"
        case roomName = "RoomName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let profileArn = profileArn {
            try encodeContainer.encode(profileArn, forKey: .profileArn)
        }
        if let profileName = profileName {
            try encodeContainer.encode(profileName, forKey: .profileName)
        }
        if let providerCalendarId = providerCalendarId {
            try encodeContainer.encode(providerCalendarId, forKey: .providerCalendarId)
        }
        if let roomArn = roomArn {
            try encodeContainer.encode(roomArn, forKey: .roomArn)
        }
        if let roomName = roomName {
            try encodeContainer.encode(roomName, forKey: .roomName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roomArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roomArn)
        roomArn = roomArnDecoded
        let roomNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roomName)
        roomName = roomNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let providerCalendarIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .providerCalendarId)
        providerCalendarId = providerCalendarIdDecoded
        let profileArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .profileArn)
        profileArn = profileArnDecoded
        let profileNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .profileName)
        profileName = profileNameDecoded
    }
}

extension RoomData: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RoomData(description: \(String(describing: description)), profileArn: \(String(describing: profileArn)), profileName: \(String(describing: profileName)), providerCalendarId: \(String(describing: providerCalendarId)), roomArn: \(String(describing: roomArn)), roomName: \(String(describing: roomName)))"}
}

/// <p>The data of a room.</p>
public struct RoomData: Equatable {
    /// <p>The description of a room.</p>
    public let description: String?
    /// <p>The profile ARN of a room.</p>
    public let profileArn: String?
    /// <p>The profile name of a room.</p>
    public let profileName: String?
    /// <p>The provider calendar ARN of a room.</p>
    public let providerCalendarId: String?
    /// <p>The ARN of a room.</p>
    public let roomArn: String?
    /// <p>The name of a room.</p>
    public let roomName: String?

    public init (
        description: String? = nil,
        profileArn: String? = nil,
        profileName: String? = nil,
        providerCalendarId: String? = nil,
        roomArn: String? = nil,
        roomName: String? = nil
    )
    {
        self.description = description
        self.profileArn = profileArn
        self.profileName = profileName
        self.providerCalendarId = providerCalendarId
        self.roomArn = roomArn
        self.roomName = roomName
    }
}

extension RoomSkillParameter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case parameterKey = "ParameterKey"
        case parameterValue = "ParameterValue"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let parameterKey = parameterKey {
            try encodeContainer.encode(parameterKey, forKey: .parameterKey)
        }
        if let parameterValue = parameterValue {
            try encodeContainer.encode(parameterValue, forKey: .parameterValue)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parameterKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .parameterKey)
        parameterKey = parameterKeyDecoded
        let parameterValueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .parameterValue)
        parameterValue = parameterValueDecoded
    }
}

extension RoomSkillParameter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RoomSkillParameter(parameterKey: \(String(describing: parameterKey)), parameterValue: \(String(describing: parameterValue)))"}
}

/// <p>A skill parameter associated with a room.</p>
public struct RoomSkillParameter: Equatable {
    /// <p>The parameter key of a room skill parameter. ParameterKey is an enumerated type that
    ///          only takes DEFAULT or SCOPE as valid values.</p>
    public let parameterKey: String?
    /// <p>The parameter value of a room skill parameter.</p>
    public let parameterValue: String?

    public init (
        parameterKey: String? = nil,
        parameterValue: String? = nil
    )
    {
        self.parameterKey = parameterKey
        self.parameterValue = parameterValue
    }
}

public struct SearchAddressBooksInputBodyMiddleware: Middleware {
    public let id: String = "SearchAddressBooksInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SearchAddressBooksInput>,
                  next: H) -> Swift.Result<OperationOutput<SearchAddressBooksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SearchAddressBooksInput>
    public typealias MOutput = OperationOutput<SearchAddressBooksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SearchAddressBooksOutputError>
}

extension SearchAddressBooksInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SearchAddressBooksInput(filters: \(String(describing: filters)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), sortCriteria: \(String(describing: sortCriteria)))"}
}

extension SearchAddressBooksInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sortCriteria = "SortCriteria"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filterlist0 in filters {
                try filtersContainer.encode(filterlist0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sortCriteria = sortCriteria {
            var sortCriteriaContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sortCriteria)
            for sortlist0 in sortCriteria {
                try sortCriteriaContainer.encode(sortlist0)
            }
        }
    }
}

public struct SearchAddressBooksInputHeadersMiddleware: Middleware {
    public let id: String = "SearchAddressBooksInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SearchAddressBooksInput>,
                  next: H) -> Swift.Result<OperationOutput<SearchAddressBooksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SearchAddressBooksInput>
    public typealias MOutput = OperationOutput<SearchAddressBooksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SearchAddressBooksOutputError>
}

public struct SearchAddressBooksInputQueryItemMiddleware: Middleware {
    public let id: String = "SearchAddressBooksInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SearchAddressBooksInput>,
                  next: H) -> Swift.Result<OperationOutput<SearchAddressBooksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SearchAddressBooksInput>
    public typealias MOutput = OperationOutput<SearchAddressBooksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SearchAddressBooksOutputError>
}

public struct SearchAddressBooksInput: Equatable {
    /// <p>The filters to use to list a specified set of address books. The supported filter key
    ///          is AddressBookName.</p>
    public let filters: [Filter]?
    /// <p>The maximum number of results to include in the response. If more results exist than
    ///          the specified MaxResults value, a token is included in the response so that the remaining
    ///          results can be retrieved.</p>
    public let maxResults: Int?
    /// <p>An optional token returned from a prior request. Use this token for pagination of
    ///          results from this action. If this parameter is specified, the response only includes
    ///          results beyond the token, up to the value specified by MaxResults.</p>
    public let nextToken: String?
    /// <p>The sort order to use in listing the specified set of address books. The supported
    ///          sort key is AddressBookName.</p>
    public let sortCriteria: [Sort]?

    public init (
        filters: [Filter]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        sortCriteria: [Sort]? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortCriteria = sortCriteria
    }
}

struct SearchAddressBooksInputBody: Equatable {
    public let filters: [Filter]?
    public let sortCriteria: [Sort]?
    public let nextToken: String?
    public let maxResults: Int?
}

extension SearchAddressBooksInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sortCriteria = "SortCriteria"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([Filter?].self, forKey: .filters)
        var filtersDecoded0:[Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let sortCriteriaContainer = try containerValues.decodeIfPresent([Sort?].self, forKey: .sortCriteria)
        var sortCriteriaDecoded0:[Sort]? = nil
        if let sortCriteriaContainer = sortCriteriaContainer {
            sortCriteriaDecoded0 = [Sort]()
            for structure0 in sortCriteriaContainer {
                if let structure0 = structure0 {
                    sortCriteriaDecoded0?.append(structure0)
                }
            }
        }
        sortCriteria = sortCriteriaDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension SearchAddressBooksOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SearchAddressBooksOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SearchAddressBooksOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension SearchAddressBooksOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SearchAddressBooksOutputResponse(addressBooks: \(String(describing: addressBooks)), nextToken: \(String(describing: nextToken)), totalCount: \(String(describing: totalCount)))"}
}

extension SearchAddressBooksOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: SearchAddressBooksOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.addressBooks = output.addressBooks
            self.nextToken = output.nextToken
            self.totalCount = output.totalCount
        } else {
            self.addressBooks = nil
            self.nextToken = nil
            self.totalCount = nil
        }
    }
}

public struct SearchAddressBooksOutputResponse: Equatable {
    /// <p>The address books that meet the specified set of filter criteria, in sort
    ///          order.</p>
    public let addressBooks: [AddressBookData]?
    /// <p>The token returned to indicate that there is more data available.</p>
    public let nextToken: String?
    /// <p>The total number of address books returned.</p>
    public let totalCount: Int?

    public init (
        addressBooks: [AddressBookData]? = nil,
        nextToken: String? = nil,
        totalCount: Int? = nil
    )
    {
        self.addressBooks = addressBooks
        self.nextToken = nextToken
        self.totalCount = totalCount
    }
}

struct SearchAddressBooksOutputResponseBody: Equatable {
    public let addressBooks: [AddressBookData]?
    public let nextToken: String?
    public let totalCount: Int?
}

extension SearchAddressBooksOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case addressBooks = "AddressBooks"
        case nextToken = "NextToken"
        case totalCount = "TotalCount"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addressBooksContainer = try containerValues.decodeIfPresent([AddressBookData?].self, forKey: .addressBooks)
        var addressBooksDecoded0:[AddressBookData]? = nil
        if let addressBooksContainer = addressBooksContainer {
            addressBooksDecoded0 = [AddressBookData]()
            for structure0 in addressBooksContainer {
                if let structure0 = structure0 {
                    addressBooksDecoded0?.append(structure0)
                }
            }
        }
        addressBooks = addressBooksDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let totalCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .totalCount)
        totalCount = totalCountDecoded
    }
}

public struct SearchContactsInputBodyMiddleware: Middleware {
    public let id: String = "SearchContactsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SearchContactsInput>,
                  next: H) -> Swift.Result<OperationOutput<SearchContactsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SearchContactsInput>
    public typealias MOutput = OperationOutput<SearchContactsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SearchContactsOutputError>
}

extension SearchContactsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SearchContactsInput(filters: \(String(describing: filters)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), sortCriteria: \(String(describing: sortCriteria)))"}
}

extension SearchContactsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sortCriteria = "SortCriteria"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filterlist0 in filters {
                try filtersContainer.encode(filterlist0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sortCriteria = sortCriteria {
            var sortCriteriaContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sortCriteria)
            for sortlist0 in sortCriteria {
                try sortCriteriaContainer.encode(sortlist0)
            }
        }
    }
}

public struct SearchContactsInputHeadersMiddleware: Middleware {
    public let id: String = "SearchContactsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SearchContactsInput>,
                  next: H) -> Swift.Result<OperationOutput<SearchContactsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SearchContactsInput>
    public typealias MOutput = OperationOutput<SearchContactsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SearchContactsOutputError>
}

public struct SearchContactsInputQueryItemMiddleware: Middleware {
    public let id: String = "SearchContactsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SearchContactsInput>,
                  next: H) -> Swift.Result<OperationOutput<SearchContactsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SearchContactsInput>
    public typealias MOutput = OperationOutput<SearchContactsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SearchContactsOutputError>
}

public struct SearchContactsInput: Equatable {
    /// <p>The filters to use to list a specified set of address books. The supported filter
    ///          keys are DisplayName, FirstName, LastName, and AddressBookArns.</p>
    public let filters: [Filter]?
    /// <p>The maximum number of results to include in the response. If more results exist than
    ///          the specified MaxResults value, a token is included in the response so that the remaining
    ///          results can be retrieved.</p>
    public let maxResults: Int?
    /// <p>An optional token returned from a prior request. Use this token for pagination of
    ///          results from this action. If this parameter is specified, the response only includes
    ///          results beyond the token, up to the value specified by MaxResults.</p>
    public let nextToken: String?
    /// <p>The sort order to use in listing the specified set of contacts. The supported sort
    ///          keys are DisplayName, FirstName, and LastName.</p>
    public let sortCriteria: [Sort]?

    public init (
        filters: [Filter]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        sortCriteria: [Sort]? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortCriteria = sortCriteria
    }
}

struct SearchContactsInputBody: Equatable {
    public let filters: [Filter]?
    public let sortCriteria: [Sort]?
    public let nextToken: String?
    public let maxResults: Int?
}

extension SearchContactsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sortCriteria = "SortCriteria"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([Filter?].self, forKey: .filters)
        var filtersDecoded0:[Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let sortCriteriaContainer = try containerValues.decodeIfPresent([Sort?].self, forKey: .sortCriteria)
        var sortCriteriaDecoded0:[Sort]? = nil
        if let sortCriteriaContainer = sortCriteriaContainer {
            sortCriteriaDecoded0 = [Sort]()
            for structure0 in sortCriteriaContainer {
                if let structure0 = structure0 {
                    sortCriteriaDecoded0?.append(structure0)
                }
            }
        }
        sortCriteria = sortCriteriaDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension SearchContactsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SearchContactsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SearchContactsOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension SearchContactsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SearchContactsOutputResponse(contacts: \(String(describing: contacts)), nextToken: \(String(describing: nextToken)), totalCount: \(String(describing: totalCount)))"}
}

extension SearchContactsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: SearchContactsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.contacts = output.contacts
            self.nextToken = output.nextToken
            self.totalCount = output.totalCount
        } else {
            self.contacts = nil
            self.nextToken = nil
            self.totalCount = nil
        }
    }
}

public struct SearchContactsOutputResponse: Equatable {
    /// <p>The contacts that meet the specified set of filter criteria, in sort order.</p>
    public let contacts: [ContactData]?
    /// <p>The token returned to indicate that there is more data available.</p>
    public let nextToken: String?
    /// <p>The total number of contacts returned.</p>
    public let totalCount: Int?

    public init (
        contacts: [ContactData]? = nil,
        nextToken: String? = nil,
        totalCount: Int? = nil
    )
    {
        self.contacts = contacts
        self.nextToken = nextToken
        self.totalCount = totalCount
    }
}

struct SearchContactsOutputResponseBody: Equatable {
    public let contacts: [ContactData]?
    public let nextToken: String?
    public let totalCount: Int?
}

extension SearchContactsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case contacts = "Contacts"
        case nextToken = "NextToken"
        case totalCount = "TotalCount"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactsContainer = try containerValues.decodeIfPresent([ContactData?].self, forKey: .contacts)
        var contactsDecoded0:[ContactData]? = nil
        if let contactsContainer = contactsContainer {
            contactsDecoded0 = [ContactData]()
            for structure0 in contactsContainer {
                if let structure0 = structure0 {
                    contactsDecoded0?.append(structure0)
                }
            }
        }
        contacts = contactsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let totalCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .totalCount)
        totalCount = totalCountDecoded
    }
}

public struct SearchDevicesInputBodyMiddleware: Middleware {
    public let id: String = "SearchDevicesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SearchDevicesInput>,
                  next: H) -> Swift.Result<OperationOutput<SearchDevicesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SearchDevicesInput>
    public typealias MOutput = OperationOutput<SearchDevicesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SearchDevicesOutputError>
}

extension SearchDevicesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SearchDevicesInput(filters: \(String(describing: filters)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), sortCriteria: \(String(describing: sortCriteria)))"}
}

extension SearchDevicesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sortCriteria = "SortCriteria"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filterlist0 in filters {
                try filtersContainer.encode(filterlist0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sortCriteria = sortCriteria {
            var sortCriteriaContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sortCriteria)
            for sortlist0 in sortCriteria {
                try sortCriteriaContainer.encode(sortlist0)
            }
        }
    }
}

public struct SearchDevicesInputHeadersMiddleware: Middleware {
    public let id: String = "SearchDevicesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SearchDevicesInput>,
                  next: H) -> Swift.Result<OperationOutput<SearchDevicesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SearchDevicesInput>
    public typealias MOutput = OperationOutput<SearchDevicesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SearchDevicesOutputError>
}

public struct SearchDevicesInputQueryItemMiddleware: Middleware {
    public let id: String = "SearchDevicesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SearchDevicesInput>,
                  next: H) -> Swift.Result<OperationOutput<SearchDevicesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SearchDevicesInput>
    public typealias MOutput = OperationOutput<SearchDevicesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SearchDevicesOutputError>
}

public struct SearchDevicesInput: Equatable {
    /// <p>The filters to use to list a specified set of devices. Supported filter keys are
    ///          DeviceName, DeviceStatus, DeviceStatusDetailCode, RoomName, DeviceType, DeviceSerialNumber,
    ///          UnassociatedOnly, ConnectionStatus (ONLINE and OFFLINE), NetworkProfileName,
    ///          NetworkProfileArn, Feature, and FailureCode.</p>
    public let filters: [Filter]?
    /// <p>The maximum number of results to include in the response. If more results exist than
    ///          the specified <code>MaxResults</code> value, a token is included in the response so that
    ///          the remaining results can be retrieved.</p>
    public let maxResults: Int?
    /// <p>An optional token returned from a prior request. Use this token for pagination of
    ///          results from this action. If this parameter is specified, the response includes only
    ///          results beyond the token, up to the value specified by <code>MaxResults</code>.</p>
    public let nextToken: String?
    /// <p>The sort order to use in listing the specified set of devices. Supported sort keys
    ///          are DeviceName, DeviceStatus, RoomName, DeviceType, DeviceSerialNumber, ConnectionStatus,
    ///          NetworkProfileName, NetworkProfileArn, Feature, and FailureCode.</p>
    public let sortCriteria: [Sort]?

    public init (
        filters: [Filter]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        sortCriteria: [Sort]? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortCriteria = sortCriteria
    }
}

struct SearchDevicesInputBody: Equatable {
    public let nextToken: String?
    public let maxResults: Int?
    public let filters: [Filter]?
    public let sortCriteria: [Sort]?
}

extension SearchDevicesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sortCriteria = "SortCriteria"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([Filter?].self, forKey: .filters)
        var filtersDecoded0:[Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let sortCriteriaContainer = try containerValues.decodeIfPresent([Sort?].self, forKey: .sortCriteria)
        var sortCriteriaDecoded0:[Sort]? = nil
        if let sortCriteriaContainer = sortCriteriaContainer {
            sortCriteriaDecoded0 = [Sort]()
            for structure0 in sortCriteriaContainer {
                if let structure0 = structure0 {
                    sortCriteriaDecoded0?.append(structure0)
                }
            }
        }
        sortCriteria = sortCriteriaDecoded0
    }
}

extension SearchDevicesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SearchDevicesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SearchDevicesOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension SearchDevicesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SearchDevicesOutputResponse(devices: \(String(describing: devices)), nextToken: \(String(describing: nextToken)), totalCount: \(String(describing: totalCount)))"}
}

extension SearchDevicesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: SearchDevicesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.devices = output.devices
            self.nextToken = output.nextToken
            self.totalCount = output.totalCount
        } else {
            self.devices = nil
            self.nextToken = nil
            self.totalCount = nil
        }
    }
}

public struct SearchDevicesOutputResponse: Equatable {
    /// <p>The devices that meet the specified set of filter criteria, in sort order.</p>
    public let devices: [DeviceData]?
    /// <p>The token returned to indicate that there is more data available.</p>
    public let nextToken: String?
    /// <p>The total number of devices returned.</p>
    public let totalCount: Int?

    public init (
        devices: [DeviceData]? = nil,
        nextToken: String? = nil,
        totalCount: Int? = nil
    )
    {
        self.devices = devices
        self.nextToken = nextToken
        self.totalCount = totalCount
    }
}

struct SearchDevicesOutputResponseBody: Equatable {
    public let devices: [DeviceData]?
    public let nextToken: String?
    public let totalCount: Int?
}

extension SearchDevicesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case devices = "Devices"
        case nextToken = "NextToken"
        case totalCount = "TotalCount"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let devicesContainer = try containerValues.decodeIfPresent([DeviceData?].self, forKey: .devices)
        var devicesDecoded0:[DeviceData]? = nil
        if let devicesContainer = devicesContainer {
            devicesDecoded0 = [DeviceData]()
            for structure0 in devicesContainer {
                if let structure0 = structure0 {
                    devicesDecoded0?.append(structure0)
                }
            }
        }
        devices = devicesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let totalCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .totalCount)
        totalCount = totalCountDecoded
    }
}

public struct SearchNetworkProfilesInputBodyMiddleware: Middleware {
    public let id: String = "SearchNetworkProfilesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SearchNetworkProfilesInput>,
                  next: H) -> Swift.Result<OperationOutput<SearchNetworkProfilesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SearchNetworkProfilesInput>
    public typealias MOutput = OperationOutput<SearchNetworkProfilesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SearchNetworkProfilesOutputError>
}

extension SearchNetworkProfilesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SearchNetworkProfilesInput(filters: \(String(describing: filters)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), sortCriteria: \(String(describing: sortCriteria)))"}
}

extension SearchNetworkProfilesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sortCriteria = "SortCriteria"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filterlist0 in filters {
                try filtersContainer.encode(filterlist0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sortCriteria = sortCriteria {
            var sortCriteriaContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sortCriteria)
            for sortlist0 in sortCriteria {
                try sortCriteriaContainer.encode(sortlist0)
            }
        }
    }
}

public struct SearchNetworkProfilesInputHeadersMiddleware: Middleware {
    public let id: String = "SearchNetworkProfilesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SearchNetworkProfilesInput>,
                  next: H) -> Swift.Result<OperationOutput<SearchNetworkProfilesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SearchNetworkProfilesInput>
    public typealias MOutput = OperationOutput<SearchNetworkProfilesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SearchNetworkProfilesOutputError>
}

public struct SearchNetworkProfilesInputQueryItemMiddleware: Middleware {
    public let id: String = "SearchNetworkProfilesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SearchNetworkProfilesInput>,
                  next: H) -> Swift.Result<OperationOutput<SearchNetworkProfilesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SearchNetworkProfilesInput>
    public typealias MOutput = OperationOutput<SearchNetworkProfilesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SearchNetworkProfilesOutputError>
}

public struct SearchNetworkProfilesInput: Equatable {
    /// <p>The filters to use to list a specified set of network profiles. Valid filters are
    ///          NetworkProfileName, Ssid, and SecurityType.</p>
    public let filters: [Filter]?
    /// <p>The maximum number of results to include in the response. If more results exist than the
    ///          specified MaxResults value, a token is included in the response so that the remaining
    ///          results can be retrieved. </p>
    public let maxResults: Int?
    /// <p>An optional token returned from a prior request. Use this token for pagination of
    ///          results from this action. If this parameter is specified, the response includes only
    ///          results beyond the token, up to the value specified by MaxResults. </p>
    public let nextToken: String?
    /// <p>The sort order to use to list the specified set of network profiles. Valid sort criteria
    ///          includes NetworkProfileName, Ssid, and SecurityType.</p>
    public let sortCriteria: [Sort]?

    public init (
        filters: [Filter]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        sortCriteria: [Sort]? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortCriteria = sortCriteria
    }
}

struct SearchNetworkProfilesInputBody: Equatable {
    public let nextToken: String?
    public let maxResults: Int?
    public let filters: [Filter]?
    public let sortCriteria: [Sort]?
}

extension SearchNetworkProfilesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sortCriteria = "SortCriteria"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([Filter?].self, forKey: .filters)
        var filtersDecoded0:[Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let sortCriteriaContainer = try containerValues.decodeIfPresent([Sort?].self, forKey: .sortCriteria)
        var sortCriteriaDecoded0:[Sort]? = nil
        if let sortCriteriaContainer = sortCriteriaContainer {
            sortCriteriaDecoded0 = [Sort]()
            for structure0 in sortCriteriaContainer {
                if let structure0 = structure0 {
                    sortCriteriaDecoded0?.append(structure0)
                }
            }
        }
        sortCriteria = sortCriteriaDecoded0
    }
}

extension SearchNetworkProfilesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SearchNetworkProfilesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SearchNetworkProfilesOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension SearchNetworkProfilesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SearchNetworkProfilesOutputResponse(networkProfiles: \(String(describing: networkProfiles)), nextToken: \(String(describing: nextToken)), totalCount: \(String(describing: totalCount)))"}
}

extension SearchNetworkProfilesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: SearchNetworkProfilesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.networkProfiles = output.networkProfiles
            self.nextToken = output.nextToken
            self.totalCount = output.totalCount
        } else {
            self.networkProfiles = nil
            self.nextToken = nil
            self.totalCount = nil
        }
    }
}

public struct SearchNetworkProfilesOutputResponse: Equatable {
    /// <p>The network profiles that meet the specified set of filter criteria, in sort order. It
    ///          is a list of NetworkProfileData objects. </p>
    public let networkProfiles: [NetworkProfileData]?
    /// <p>An optional token returned from a prior request. Use this token for pagination of
    ///          results from this action. If this parameter is specified, the response includes only
    ///          results beyond the token, up to the value specified by MaxResults.</p>
    public let nextToken: String?
    /// <p>The total number of network profiles returned.</p>
    public let totalCount: Int?

    public init (
        networkProfiles: [NetworkProfileData]? = nil,
        nextToken: String? = nil,
        totalCount: Int? = nil
    )
    {
        self.networkProfiles = networkProfiles
        self.nextToken = nextToken
        self.totalCount = totalCount
    }
}

struct SearchNetworkProfilesOutputResponseBody: Equatable {
    public let networkProfiles: [NetworkProfileData]?
    public let nextToken: String?
    public let totalCount: Int?
}

extension SearchNetworkProfilesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case networkProfiles = "NetworkProfiles"
        case nextToken = "NextToken"
        case totalCount = "TotalCount"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkProfilesContainer = try containerValues.decodeIfPresent([NetworkProfileData?].self, forKey: .networkProfiles)
        var networkProfilesDecoded0:[NetworkProfileData]? = nil
        if let networkProfilesContainer = networkProfilesContainer {
            networkProfilesDecoded0 = [NetworkProfileData]()
            for structure0 in networkProfilesContainer {
                if let structure0 = structure0 {
                    networkProfilesDecoded0?.append(structure0)
                }
            }
        }
        networkProfiles = networkProfilesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let totalCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .totalCount)
        totalCount = totalCountDecoded
    }
}

public struct SearchProfilesInputBodyMiddleware: Middleware {
    public let id: String = "SearchProfilesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SearchProfilesInput>,
                  next: H) -> Swift.Result<OperationOutput<SearchProfilesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SearchProfilesInput>
    public typealias MOutput = OperationOutput<SearchProfilesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SearchProfilesOutputError>
}

extension SearchProfilesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SearchProfilesInput(filters: \(String(describing: filters)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), sortCriteria: \(String(describing: sortCriteria)))"}
}

extension SearchProfilesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sortCriteria = "SortCriteria"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filterlist0 in filters {
                try filtersContainer.encode(filterlist0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sortCriteria = sortCriteria {
            var sortCriteriaContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sortCriteria)
            for sortlist0 in sortCriteria {
                try sortCriteriaContainer.encode(sortlist0)
            }
        }
    }
}

public struct SearchProfilesInputHeadersMiddleware: Middleware {
    public let id: String = "SearchProfilesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SearchProfilesInput>,
                  next: H) -> Swift.Result<OperationOutput<SearchProfilesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SearchProfilesInput>
    public typealias MOutput = OperationOutput<SearchProfilesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SearchProfilesOutputError>
}

public struct SearchProfilesInputQueryItemMiddleware: Middleware {
    public let id: String = "SearchProfilesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SearchProfilesInput>,
                  next: H) -> Swift.Result<OperationOutput<SearchProfilesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SearchProfilesInput>
    public typealias MOutput = OperationOutput<SearchProfilesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SearchProfilesOutputError>
}

public struct SearchProfilesInput: Equatable {
    /// <p>The filters to use to list a specified set of room profiles. Supported filter keys
    ///          are ProfileName and Address. Required. </p>
    public let filters: [Filter]?
    /// <p>The maximum number of results to include in the response. If more results exist than
    ///          the specified <code>MaxResults</code> value, a token is included in the response so that
    ///          the remaining results can be retrieved.</p>
    public let maxResults: Int?
    /// <p>An optional token returned from a prior request. Use this token for pagination of
    ///          results from this action. If this parameter is specified, the response includes only
    ///          results beyond the token, up to the value specified by <code>MaxResults</code>.</p>
    public let nextToken: String?
    /// <p>The sort order to use in listing the specified set of room profiles. Supported sort
    ///          keys are ProfileName and Address.</p>
    public let sortCriteria: [Sort]?

    public init (
        filters: [Filter]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        sortCriteria: [Sort]? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortCriteria = sortCriteria
    }
}

struct SearchProfilesInputBody: Equatable {
    public let nextToken: String?
    public let maxResults: Int?
    public let filters: [Filter]?
    public let sortCriteria: [Sort]?
}

extension SearchProfilesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sortCriteria = "SortCriteria"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([Filter?].self, forKey: .filters)
        var filtersDecoded0:[Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let sortCriteriaContainer = try containerValues.decodeIfPresent([Sort?].self, forKey: .sortCriteria)
        var sortCriteriaDecoded0:[Sort]? = nil
        if let sortCriteriaContainer = sortCriteriaContainer {
            sortCriteriaDecoded0 = [Sort]()
            for structure0 in sortCriteriaContainer {
                if let structure0 = structure0 {
                    sortCriteriaDecoded0?.append(structure0)
                }
            }
        }
        sortCriteria = sortCriteriaDecoded0
    }
}

extension SearchProfilesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SearchProfilesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SearchProfilesOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension SearchProfilesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SearchProfilesOutputResponse(nextToken: \(String(describing: nextToken)), profiles: \(String(describing: profiles)), totalCount: \(String(describing: totalCount)))"}
}

extension SearchProfilesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: SearchProfilesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.profiles = output.profiles
            self.totalCount = output.totalCount
        } else {
            self.nextToken = nil
            self.profiles = nil
            self.totalCount = nil
        }
    }
}

public struct SearchProfilesOutputResponse: Equatable {
    /// <p>The token returned to indicate that there is more data available.</p>
    public let nextToken: String?
    /// <p>The profiles that meet the specified set of filter criteria, in sort order.</p>
    public let profiles: [ProfileData]?
    /// <p>The total number of room profiles returned.</p>
    public let totalCount: Int?

    public init (
        nextToken: String? = nil,
        profiles: [ProfileData]? = nil,
        totalCount: Int? = nil
    )
    {
        self.nextToken = nextToken
        self.profiles = profiles
        self.totalCount = totalCount
    }
}

struct SearchProfilesOutputResponseBody: Equatable {
    public let profiles: [ProfileData]?
    public let nextToken: String?
    public let totalCount: Int?
}

extension SearchProfilesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case profiles = "Profiles"
        case totalCount = "TotalCount"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profilesContainer = try containerValues.decodeIfPresent([ProfileData?].self, forKey: .profiles)
        var profilesDecoded0:[ProfileData]? = nil
        if let profilesContainer = profilesContainer {
            profilesDecoded0 = [ProfileData]()
            for structure0 in profilesContainer {
                if let structure0 = structure0 {
                    profilesDecoded0?.append(structure0)
                }
            }
        }
        profiles = profilesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let totalCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .totalCount)
        totalCount = totalCountDecoded
    }
}

public struct SearchRoomsInputBodyMiddleware: Middleware {
    public let id: String = "SearchRoomsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SearchRoomsInput>,
                  next: H) -> Swift.Result<OperationOutput<SearchRoomsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SearchRoomsInput>
    public typealias MOutput = OperationOutput<SearchRoomsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SearchRoomsOutputError>
}

extension SearchRoomsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SearchRoomsInput(filters: \(String(describing: filters)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), sortCriteria: \(String(describing: sortCriteria)))"}
}

extension SearchRoomsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sortCriteria = "SortCriteria"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filterlist0 in filters {
                try filtersContainer.encode(filterlist0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sortCriteria = sortCriteria {
            var sortCriteriaContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sortCriteria)
            for sortlist0 in sortCriteria {
                try sortCriteriaContainer.encode(sortlist0)
            }
        }
    }
}

public struct SearchRoomsInputHeadersMiddleware: Middleware {
    public let id: String = "SearchRoomsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SearchRoomsInput>,
                  next: H) -> Swift.Result<OperationOutput<SearchRoomsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SearchRoomsInput>
    public typealias MOutput = OperationOutput<SearchRoomsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SearchRoomsOutputError>
}

public struct SearchRoomsInputQueryItemMiddleware: Middleware {
    public let id: String = "SearchRoomsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SearchRoomsInput>,
                  next: H) -> Swift.Result<OperationOutput<SearchRoomsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SearchRoomsInput>
    public typealias MOutput = OperationOutput<SearchRoomsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SearchRoomsOutputError>
}

public struct SearchRoomsInput: Equatable {
    /// <p>The filters to use to list a specified set of rooms. The supported filter keys are
    ///          RoomName and ProfileName.</p>
    public let filters: [Filter]?
    /// <p>The maximum number of results to include in the response. If more results exist than
    ///          the specified <code>MaxResults</code> value, a token is included in the response so that
    ///          the remaining results can be retrieved. </p>
    public let maxResults: Int?
    /// <p>An optional token returned from a prior request. Use this token for pagination of
    ///          results from this action. If this parameter is specified, the response includes only
    ///          results beyond the token, up to the value specified by <code>MaxResults</code>.</p>
    public let nextToken: String?
    /// <p>The sort order to use in listing the specified set of rooms. The supported sort keys
    ///          are RoomName and ProfileName.</p>
    public let sortCriteria: [Sort]?

    public init (
        filters: [Filter]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        sortCriteria: [Sort]? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortCriteria = sortCriteria
    }
}

struct SearchRoomsInputBody: Equatable {
    public let nextToken: String?
    public let maxResults: Int?
    public let filters: [Filter]?
    public let sortCriteria: [Sort]?
}

extension SearchRoomsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sortCriteria = "SortCriteria"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([Filter?].self, forKey: .filters)
        var filtersDecoded0:[Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let sortCriteriaContainer = try containerValues.decodeIfPresent([Sort?].self, forKey: .sortCriteria)
        var sortCriteriaDecoded0:[Sort]? = nil
        if let sortCriteriaContainer = sortCriteriaContainer {
            sortCriteriaDecoded0 = [Sort]()
            for structure0 in sortCriteriaContainer {
                if let structure0 = structure0 {
                    sortCriteriaDecoded0?.append(structure0)
                }
            }
        }
        sortCriteria = sortCriteriaDecoded0
    }
}

extension SearchRoomsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SearchRoomsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SearchRoomsOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension SearchRoomsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SearchRoomsOutputResponse(nextToken: \(String(describing: nextToken)), rooms: \(String(describing: rooms)), totalCount: \(String(describing: totalCount)))"}
}

extension SearchRoomsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: SearchRoomsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.rooms = output.rooms
            self.totalCount = output.totalCount
        } else {
            self.nextToken = nil
            self.rooms = nil
            self.totalCount = nil
        }
    }
}

public struct SearchRoomsOutputResponse: Equatable {
    /// <p>The token returned to indicate that there is more data available.</p>
    public let nextToken: String?
    /// <p>The rooms that meet the specified set of filter criteria, in sort order.</p>
    public let rooms: [RoomData]?
    /// <p>The total number of rooms returned.</p>
    public let totalCount: Int?

    public init (
        nextToken: String? = nil,
        rooms: [RoomData]? = nil,
        totalCount: Int? = nil
    )
    {
        self.nextToken = nextToken
        self.rooms = rooms
        self.totalCount = totalCount
    }
}

struct SearchRoomsOutputResponseBody: Equatable {
    public let rooms: [RoomData]?
    public let nextToken: String?
    public let totalCount: Int?
}

extension SearchRoomsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case rooms = "Rooms"
        case totalCount = "TotalCount"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roomsContainer = try containerValues.decodeIfPresent([RoomData?].self, forKey: .rooms)
        var roomsDecoded0:[RoomData]? = nil
        if let roomsContainer = roomsContainer {
            roomsDecoded0 = [RoomData]()
            for structure0 in roomsContainer {
                if let structure0 = structure0 {
                    roomsDecoded0?.append(structure0)
                }
            }
        }
        rooms = roomsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let totalCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .totalCount)
        totalCount = totalCountDecoded
    }
}

public struct SearchSkillGroupsInputBodyMiddleware: Middleware {
    public let id: String = "SearchSkillGroupsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SearchSkillGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<SearchSkillGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SearchSkillGroupsInput>
    public typealias MOutput = OperationOutput<SearchSkillGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SearchSkillGroupsOutputError>
}

extension SearchSkillGroupsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SearchSkillGroupsInput(filters: \(String(describing: filters)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), sortCriteria: \(String(describing: sortCriteria)))"}
}

extension SearchSkillGroupsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sortCriteria = "SortCriteria"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filterlist0 in filters {
                try filtersContainer.encode(filterlist0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sortCriteria = sortCriteria {
            var sortCriteriaContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sortCriteria)
            for sortlist0 in sortCriteria {
                try sortCriteriaContainer.encode(sortlist0)
            }
        }
    }
}

public struct SearchSkillGroupsInputHeadersMiddleware: Middleware {
    public let id: String = "SearchSkillGroupsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SearchSkillGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<SearchSkillGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SearchSkillGroupsInput>
    public typealias MOutput = OperationOutput<SearchSkillGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SearchSkillGroupsOutputError>
}

public struct SearchSkillGroupsInputQueryItemMiddleware: Middleware {
    public let id: String = "SearchSkillGroupsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SearchSkillGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<SearchSkillGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SearchSkillGroupsInput>
    public typealias MOutput = OperationOutput<SearchSkillGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SearchSkillGroupsOutputError>
}

public struct SearchSkillGroupsInput: Equatable {
    /// <p>The filters to use to list a specified set of skill groups. The supported filter key
    ///          is SkillGroupName. </p>
    public let filters: [Filter]?
    /// <p>The maximum number of results to include in the response. If more results exist than
    ///          the specified <code>MaxResults</code> value, a token is included in the response so that
    ///          the remaining results can be retrieved. </p>
    public let maxResults: Int?
    /// <p>An optional token returned from a prior request. Use this token for pagination of
    ///          results from this action. If this parameter is specified, the response includes only
    ///          results beyond the token, up to the value specified by <code>MaxResults</code>.
    ///          Required.</p>
    public let nextToken: String?
    /// <p>The sort order to use in listing the specified set of skill groups. The supported
    ///          sort key is SkillGroupName. </p>
    public let sortCriteria: [Sort]?

    public init (
        filters: [Filter]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        sortCriteria: [Sort]? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortCriteria = sortCriteria
    }
}

struct SearchSkillGroupsInputBody: Equatable {
    public let nextToken: String?
    public let maxResults: Int?
    public let filters: [Filter]?
    public let sortCriteria: [Sort]?
}

extension SearchSkillGroupsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sortCriteria = "SortCriteria"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([Filter?].self, forKey: .filters)
        var filtersDecoded0:[Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let sortCriteriaContainer = try containerValues.decodeIfPresent([Sort?].self, forKey: .sortCriteria)
        var sortCriteriaDecoded0:[Sort]? = nil
        if let sortCriteriaContainer = sortCriteriaContainer {
            sortCriteriaDecoded0 = [Sort]()
            for structure0 in sortCriteriaContainer {
                if let structure0 = structure0 {
                    sortCriteriaDecoded0?.append(structure0)
                }
            }
        }
        sortCriteria = sortCriteriaDecoded0
    }
}

extension SearchSkillGroupsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SearchSkillGroupsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SearchSkillGroupsOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension SearchSkillGroupsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SearchSkillGroupsOutputResponse(nextToken: \(String(describing: nextToken)), skillGroups: \(String(describing: skillGroups)), totalCount: \(String(describing: totalCount)))"}
}

extension SearchSkillGroupsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: SearchSkillGroupsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.skillGroups = output.skillGroups
            self.totalCount = output.totalCount
        } else {
            self.nextToken = nil
            self.skillGroups = nil
            self.totalCount = nil
        }
    }
}

public struct SearchSkillGroupsOutputResponse: Equatable {
    /// <p>The token returned to indicate that there is more data available.</p>
    public let nextToken: String?
    /// <p>The skill groups that meet the filter criteria, in sort order.</p>
    public let skillGroups: [SkillGroupData]?
    /// <p>The total number of skill groups returned.</p>
    public let totalCount: Int?

    public init (
        nextToken: String? = nil,
        skillGroups: [SkillGroupData]? = nil,
        totalCount: Int? = nil
    )
    {
        self.nextToken = nextToken
        self.skillGroups = skillGroups
        self.totalCount = totalCount
    }
}

struct SearchSkillGroupsOutputResponseBody: Equatable {
    public let skillGroups: [SkillGroupData]?
    public let nextToken: String?
    public let totalCount: Int?
}

extension SearchSkillGroupsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case skillGroups = "SkillGroups"
        case totalCount = "TotalCount"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let skillGroupsContainer = try containerValues.decodeIfPresent([SkillGroupData?].self, forKey: .skillGroups)
        var skillGroupsDecoded0:[SkillGroupData]? = nil
        if let skillGroupsContainer = skillGroupsContainer {
            skillGroupsDecoded0 = [SkillGroupData]()
            for structure0 in skillGroupsContainer {
                if let structure0 = structure0 {
                    skillGroupsDecoded0?.append(structure0)
                }
            }
        }
        skillGroups = skillGroupsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let totalCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .totalCount)
        totalCount = totalCountDecoded
    }
}

public struct SearchUsersInputBodyMiddleware: Middleware {
    public let id: String = "SearchUsersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SearchUsersInput>,
                  next: H) -> Swift.Result<OperationOutput<SearchUsersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SearchUsersInput>
    public typealias MOutput = OperationOutput<SearchUsersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SearchUsersOutputError>
}

extension SearchUsersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SearchUsersInput(filters: \(String(describing: filters)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), sortCriteria: \(String(describing: sortCriteria)))"}
}

extension SearchUsersInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sortCriteria = "SortCriteria"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filterlist0 in filters {
                try filtersContainer.encode(filterlist0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sortCriteria = sortCriteria {
            var sortCriteriaContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sortCriteria)
            for sortlist0 in sortCriteria {
                try sortCriteriaContainer.encode(sortlist0)
            }
        }
    }
}

public struct SearchUsersInputHeadersMiddleware: Middleware {
    public let id: String = "SearchUsersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SearchUsersInput>,
                  next: H) -> Swift.Result<OperationOutput<SearchUsersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SearchUsersInput>
    public typealias MOutput = OperationOutput<SearchUsersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SearchUsersOutputError>
}

public struct SearchUsersInputQueryItemMiddleware: Middleware {
    public let id: String = "SearchUsersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SearchUsersInput>,
                  next: H) -> Swift.Result<OperationOutput<SearchUsersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SearchUsersInput>
    public typealias MOutput = OperationOutput<SearchUsersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SearchUsersOutputError>
}

public struct SearchUsersInput: Equatable {
    /// <p>The filters to use for listing a specific set of users. Required. Supported filter
    ///          keys are UserId, FirstName, LastName, Email, and EnrollmentStatus.</p>
    public let filters: [Filter]?
    /// <p>The maximum number of results to include in the response. If more results exist than
    ///          the specified <code>MaxResults</code> value, a token is included in the response so that
    ///          the remaining results can be retrieved. Required.</p>
    public let maxResults: Int?
    /// <p>An optional token returned from a prior request. Use this token for pagination of
    ///          results from this action. If this parameter is specified, the response includes only
    ///          results beyond the token, up to the value specified by <code>MaxResults</code>.
    ///          Required.</p>
    public let nextToken: String?
    /// <p>The sort order to use in listing the filtered set of users. Required. Supported sort
    ///          keys are UserId, FirstName, LastName, Email, and EnrollmentStatus.</p>
    public let sortCriteria: [Sort]?

    public init (
        filters: [Filter]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        sortCriteria: [Sort]? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortCriteria = sortCriteria
    }
}

struct SearchUsersInputBody: Equatable {
    public let nextToken: String?
    public let maxResults: Int?
    public let filters: [Filter]?
    public let sortCriteria: [Sort]?
}

extension SearchUsersInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sortCriteria = "SortCriteria"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([Filter?].self, forKey: .filters)
        var filtersDecoded0:[Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let sortCriteriaContainer = try containerValues.decodeIfPresent([Sort?].self, forKey: .sortCriteria)
        var sortCriteriaDecoded0:[Sort]? = nil
        if let sortCriteriaContainer = sortCriteriaContainer {
            sortCriteriaDecoded0 = [Sort]()
            for structure0 in sortCriteriaContainer {
                if let structure0 = structure0 {
                    sortCriteriaDecoded0?.append(structure0)
                }
            }
        }
        sortCriteria = sortCriteriaDecoded0
    }
}

extension SearchUsersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SearchUsersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SearchUsersOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension SearchUsersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SearchUsersOutputResponse(nextToken: \(String(describing: nextToken)), totalCount: \(String(describing: totalCount)), users: \(String(describing: users)))"}
}

extension SearchUsersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: SearchUsersOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.totalCount = output.totalCount
            self.users = output.users
        } else {
            self.nextToken = nil
            self.totalCount = nil
            self.users = nil
        }
    }
}

public struct SearchUsersOutputResponse: Equatable {
    /// <p>The token returned to indicate that there is more data available.</p>
    public let nextToken: String?
    /// <p>The total number of users returned.</p>
    public let totalCount: Int?
    /// <p>The users that meet the specified set of filter criteria, in sort order.</p>
    public let users: [UserData]?

    public init (
        nextToken: String? = nil,
        totalCount: Int? = nil,
        users: [UserData]? = nil
    )
    {
        self.nextToken = nextToken
        self.totalCount = totalCount
        self.users = users
    }
}

struct SearchUsersOutputResponseBody: Equatable {
    public let users: [UserData]?
    public let nextToken: String?
    public let totalCount: Int?
}

extension SearchUsersOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case totalCount = "TotalCount"
        case users = "Users"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usersContainer = try containerValues.decodeIfPresent([UserData?].self, forKey: .users)
        var usersDecoded0:[UserData]? = nil
        if let usersContainer = usersContainer {
            usersDecoded0 = [UserData]()
            for structure0 in usersContainer {
                if let structure0 = structure0 {
                    usersDecoded0?.append(structure0)
                }
            }
        }
        users = usersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let totalCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .totalCount)
        totalCount = totalCountDecoded
    }
}

public struct SendAnnouncementInputBodyMiddleware: Middleware {
    public let id: String = "SendAnnouncementInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SendAnnouncementInput>,
                  next: H) -> Swift.Result<OperationOutput<SendAnnouncementOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SendAnnouncementInput>
    public typealias MOutput = OperationOutput<SendAnnouncementOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SendAnnouncementOutputError>
}

extension SendAnnouncementInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SendAnnouncementInput(clientRequestToken: \(String(describing: clientRequestToken)), content: \(String(describing: content)), roomFilters: \(String(describing: roomFilters)), timeToLiveInSeconds: \(String(describing: timeToLiveInSeconds)))"}
}

extension SendAnnouncementInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case content = "Content"
        case roomFilters = "RoomFilters"
        case timeToLiveInSeconds = "TimeToLiveInSeconds"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let content = content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let roomFilters = roomFilters {
            var roomFiltersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .roomFilters)
            for filterlist0 in roomFilters {
                try roomFiltersContainer.encode(filterlist0)
            }
        }
        if let timeToLiveInSeconds = timeToLiveInSeconds {
            try encodeContainer.encode(timeToLiveInSeconds, forKey: .timeToLiveInSeconds)
        }
    }
}

public struct SendAnnouncementInputHeadersMiddleware: Middleware {
    public let id: String = "SendAnnouncementInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SendAnnouncementInput>,
                  next: H) -> Swift.Result<OperationOutput<SendAnnouncementOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SendAnnouncementInput>
    public typealias MOutput = OperationOutput<SendAnnouncementOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SendAnnouncementOutputError>
}

public struct SendAnnouncementInputQueryItemMiddleware: Middleware {
    public let id: String = "SendAnnouncementInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SendAnnouncementInput>,
                  next: H) -> Swift.Result<OperationOutput<SendAnnouncementOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SendAnnouncementInput>
    public typealias MOutput = OperationOutput<SendAnnouncementOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SendAnnouncementOutputError>
}

public struct SendAnnouncementInput: Equatable {
    /// <p>The unique, user-specified identifier for the request that ensures idempotency.</p>
    public var clientRequestToken: String?
    /// <p>The announcement content. This can contain only one of the three possible announcement types (text, SSML or audio).</p>
    public let content: Content?
    /// <p>The filters to use to send an announcement to a specified list of rooms. The supported filter keys are RoomName, ProfileName, RoomArn, and ProfileArn. To send to all rooms, specify an empty RoomFilters list.</p>
    public let roomFilters: [Filter]?
    /// <p>The time to live for an announcement. Default is 300. If delivery doesn't occur within this time, the
    ///          announcement is not delivered.</p>
    public let timeToLiveInSeconds: Int?

    public init (
        clientRequestToken: String? = nil,
        content: Content? = nil,
        roomFilters: [Filter]? = nil,
        timeToLiveInSeconds: Int? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.content = content
        self.roomFilters = roomFilters
        self.timeToLiveInSeconds = timeToLiveInSeconds
    }
}

struct SendAnnouncementInputBody: Equatable {
    public let roomFilters: [Filter]?
    public let content: Content?
    public let timeToLiveInSeconds: Int?
    public let clientRequestToken: String?
}

extension SendAnnouncementInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case content = "Content"
        case roomFilters = "RoomFilters"
        case timeToLiveInSeconds = "TimeToLiveInSeconds"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roomFiltersContainer = try containerValues.decodeIfPresent([Filter?].self, forKey: .roomFilters)
        var roomFiltersDecoded0:[Filter]? = nil
        if let roomFiltersContainer = roomFiltersContainer {
            roomFiltersDecoded0 = [Filter]()
            for structure0 in roomFiltersContainer {
                if let structure0 = structure0 {
                    roomFiltersDecoded0?.append(structure0)
                }
            }
        }
        roomFilters = roomFiltersDecoded0
        let contentDecoded = try containerValues.decodeIfPresent(Content.self, forKey: .content)
        content = contentDecoded
        let timeToLiveInSecondsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .timeToLiveInSeconds)
        timeToLiveInSeconds = timeToLiveInSecondsDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
    }
}

extension SendAnnouncementOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SendAnnouncementOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AlreadyExistsException" : self = .alreadyExistsException(try AlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SendAnnouncementOutputError: Equatable {
    case alreadyExistsException(AlreadyExistsException)
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SendAnnouncementOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SendAnnouncementOutputResponse(announcementArn: \(String(describing: announcementArn)))"}
}

extension SendAnnouncementOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: SendAnnouncementOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.announcementArn = output.announcementArn
        } else {
            self.announcementArn = nil
        }
    }
}

public struct SendAnnouncementOutputResponse: Equatable {
    /// <p>The identifier of the announcement.</p>
    public let announcementArn: String?

    public init (
        announcementArn: String? = nil
    )
    {
        self.announcementArn = announcementArn
    }
}

struct SendAnnouncementOutputResponseBody: Equatable {
    public let announcementArn: String?
}

extension SendAnnouncementOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case announcementArn = "AnnouncementArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let announcementArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .announcementArn)
        announcementArn = announcementArnDecoded
    }
}

public struct SendInvitationInputBodyMiddleware: Middleware {
    public let id: String = "SendInvitationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SendInvitationInput>,
                  next: H) -> Swift.Result<OperationOutput<SendInvitationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SendInvitationInput>
    public typealias MOutput = OperationOutput<SendInvitationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SendInvitationOutputError>
}

extension SendInvitationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SendInvitationInput(userArn: \(String(describing: userArn)))"}
}

extension SendInvitationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case userArn = "UserArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let userArn = userArn {
            try encodeContainer.encode(userArn, forKey: .userArn)
        }
    }
}

public struct SendInvitationInputHeadersMiddleware: Middleware {
    public let id: String = "SendInvitationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SendInvitationInput>,
                  next: H) -> Swift.Result<OperationOutput<SendInvitationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SendInvitationInput>
    public typealias MOutput = OperationOutput<SendInvitationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SendInvitationOutputError>
}

public struct SendInvitationInputQueryItemMiddleware: Middleware {
    public let id: String = "SendInvitationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SendInvitationInput>,
                  next: H) -> Swift.Result<OperationOutput<SendInvitationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SendInvitationInput>
    public typealias MOutput = OperationOutput<SendInvitationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SendInvitationOutputError>
}

public struct SendInvitationInput: Equatable {
    /// <p>The ARN of the user to whom to send an invitation. Required.</p>
    public let userArn: String?

    public init (
        userArn: String? = nil
    )
    {
        self.userArn = userArn
    }
}

struct SendInvitationInputBody: Equatable {
    public let userArn: String?
}

extension SendInvitationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case userArn = "UserArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userArn)
        userArn = userArnDecoded
    }
}

extension SendInvitationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SendInvitationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidUserStatusException" : self = .invalidUserStatusException(try InvalidUserStatusException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SendInvitationOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidUserStatusException(InvalidUserStatusException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SendInvitationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SendInvitationOutputResponse()"}
}

extension SendInvitationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct SendInvitationOutputResponse: Equatable {

    public init() {}
}

struct SendInvitationOutputResponseBody: Equatable {
}

extension SendInvitationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension SipAddress: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case type = "Type"
        case uri = "Uri"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let uri = uri {
            try encodeContainer.encode(uri, forKey: .uri)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let uriDecoded = try containerValues.decodeIfPresent(String.self, forKey: .uri)
        uri = uriDecoded
        let typeDecoded = try containerValues.decodeIfPresent(SipType.self, forKey: .type)
        type = typeDecoded
    }
}

extension SipAddress: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SipAddress(type: \(String(describing: type)), uri: \(String(describing: uri)))"}
}

/// <p>The SIP address for the contact containing the URI and SIP address type.</p>
public struct SipAddress: Equatable {
    /// <p>The type of the SIP address.</p>
    public let type: SipType?
    /// <p>The URI for the SIP address.</p>
    public let uri: String?

    public init (
        type: SipType? = nil,
        uri: String? = nil
    )
    {
        self.type = type
        self.uri = uri
    }
}

public enum SipType {
    case work
    case sdkUnknown(String)
}

extension SipType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SipType] {
        return [
            .work,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .work: return "WORK"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SipType(rawValue: rawValue) ?? SipType.sdkUnknown(rawValue)
    }
}

extension SkillDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bulletPoints = "BulletPoints"
        case developerInfo = "DeveloperInfo"
        case endUserLicenseAgreement = "EndUserLicenseAgreement"
        case genericKeywords = "GenericKeywords"
        case invocationPhrase = "InvocationPhrase"
        case newInThisVersionBulletPoints = "NewInThisVersionBulletPoints"
        case productDescription = "ProductDescription"
        case releaseDate = "ReleaseDate"
        case reviews = "Reviews"
        case skillTypes = "SkillTypes"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bulletPoints = bulletPoints {
            var bulletPointsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .bulletPoints)
            for bulletpoints0 in bulletPoints {
                try bulletPointsContainer.encode(bulletpoints0)
            }
        }
        if let developerInfo = developerInfo {
            try encodeContainer.encode(developerInfo, forKey: .developerInfo)
        }
        if let endUserLicenseAgreement = endUserLicenseAgreement {
            try encodeContainer.encode(endUserLicenseAgreement, forKey: .endUserLicenseAgreement)
        }
        if let genericKeywords = genericKeywords {
            var genericKeywordsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .genericKeywords)
            for generickeywords0 in genericKeywords {
                try genericKeywordsContainer.encode(generickeywords0)
            }
        }
        if let invocationPhrase = invocationPhrase {
            try encodeContainer.encode(invocationPhrase, forKey: .invocationPhrase)
        }
        if let newInThisVersionBulletPoints = newInThisVersionBulletPoints {
            var newInThisVersionBulletPointsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .newInThisVersionBulletPoints)
            for newinthisversionbulletpoints0 in newInThisVersionBulletPoints {
                try newInThisVersionBulletPointsContainer.encode(newinthisversionbulletpoints0)
            }
        }
        if let productDescription = productDescription {
            try encodeContainer.encode(productDescription, forKey: .productDescription)
        }
        if let releaseDate = releaseDate {
            try encodeContainer.encode(releaseDate, forKey: .releaseDate)
        }
        if let reviews = reviews {
            var reviewsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .reviews)
            for (dictKey0, reviews0) in reviews {
                try reviewsContainer.encode(reviews0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let skillTypes = skillTypes {
            var skillTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .skillTypes)
            for skilltypes0 in skillTypes {
                try skillTypesContainer.encode(skilltypes0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let productDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .productDescription)
        productDescription = productDescriptionDecoded
        let invocationPhraseDecoded = try containerValues.decodeIfPresent(String.self, forKey: .invocationPhrase)
        invocationPhrase = invocationPhraseDecoded
        let releaseDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .releaseDate)
        releaseDate = releaseDateDecoded
        let endUserLicenseAgreementDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endUserLicenseAgreement)
        endUserLicenseAgreement = endUserLicenseAgreementDecoded
        let genericKeywordsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .genericKeywords)
        var genericKeywordsDecoded0:[String]? = nil
        if let genericKeywordsContainer = genericKeywordsContainer {
            genericKeywordsDecoded0 = [String]()
            for string0 in genericKeywordsContainer {
                if let string0 = string0 {
                    genericKeywordsDecoded0?.append(string0)
                }
            }
        }
        genericKeywords = genericKeywordsDecoded0
        let bulletPointsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .bulletPoints)
        var bulletPointsDecoded0:[String]? = nil
        if let bulletPointsContainer = bulletPointsContainer {
            bulletPointsDecoded0 = [String]()
            for string0 in bulletPointsContainer {
                if let string0 = string0 {
                    bulletPointsDecoded0?.append(string0)
                }
            }
        }
        bulletPoints = bulletPointsDecoded0
        let newInThisVersionBulletPointsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .newInThisVersionBulletPoints)
        var newInThisVersionBulletPointsDecoded0:[String]? = nil
        if let newInThisVersionBulletPointsContainer = newInThisVersionBulletPointsContainer {
            newInThisVersionBulletPointsDecoded0 = [String]()
            for string0 in newInThisVersionBulletPointsContainer {
                if let string0 = string0 {
                    newInThisVersionBulletPointsDecoded0?.append(string0)
                }
            }
        }
        newInThisVersionBulletPoints = newInThisVersionBulletPointsDecoded0
        let skillTypesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .skillTypes)
        var skillTypesDecoded0:[String]? = nil
        if let skillTypesContainer = skillTypesContainer {
            skillTypesDecoded0 = [String]()
            for string0 in skillTypesContainer {
                if let string0 = string0 {
                    skillTypesDecoded0?.append(string0)
                }
            }
        }
        skillTypes = skillTypesDecoded0
        let reviewsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .reviews)
        var reviewsDecoded0: [String:String]? = nil
        if let reviewsContainer = reviewsContainer {
            reviewsDecoded0 = [String:String]()
            for (key0, reviewvalue0) in reviewsContainer {
                if let reviewvalue0 = reviewvalue0 {
                    reviewsDecoded0?[key0] = reviewvalue0
                }
            }
        }
        reviews = reviewsDecoded0
        let developerInfoDecoded = try containerValues.decodeIfPresent(DeveloperInfo.self, forKey: .developerInfo)
        developerInfo = developerInfoDecoded
    }
}

extension SkillDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SkillDetails(bulletPoints: \(String(describing: bulletPoints)), developerInfo: \(String(describing: developerInfo)), endUserLicenseAgreement: \(String(describing: endUserLicenseAgreement)), genericKeywords: \(String(describing: genericKeywords)), invocationPhrase: \(String(describing: invocationPhrase)), newInThisVersionBulletPoints: \(String(describing: newInThisVersionBulletPoints)), productDescription: \(String(describing: productDescription)), releaseDate: \(String(describing: releaseDate)), reviews: \(String(describing: reviews)), skillTypes: \(String(describing: skillTypes)))"}
}

/// <p>Granular information about the skill.</p>
public struct SkillDetails: Equatable {
    /// <p>The details about what the skill supports organized as bullet points.</p>
    public let bulletPoints: [String]?
    /// <p>The details about the developer that published the skill.</p>
    public let developerInfo: DeveloperInfo?
    /// <p>The URL of the end user license agreement.</p>
    public let endUserLicenseAgreement: String?
    /// <p>The generic keywords associated with the skill that can be used to find a
    ///          skill.</p>
    public let genericKeywords: [String]?
    /// <p>The phrase used to trigger the skill.</p>
    public let invocationPhrase: String?
    /// <p>The updates added in bullet points.</p>
    public let newInThisVersionBulletPoints: [String]?
    /// <p>The description of the product.</p>
    public let productDescription: String?
    /// <p>The date when the skill was released.</p>
    public let releaseDate: String?
    /// <p>
    ///             <i>This member has been deprecated.</i>
    ///          </p>
    ///          <p>The list of reviews for the skill, including Key and Value pair.</p>
    public let reviews: [String:String]?
    /// <p>The types of skills.</p>
    public let skillTypes: [String]?

    public init (
        bulletPoints: [String]? = nil,
        developerInfo: DeveloperInfo? = nil,
        endUserLicenseAgreement: String? = nil,
        genericKeywords: [String]? = nil,
        invocationPhrase: String? = nil,
        newInThisVersionBulletPoints: [String]? = nil,
        productDescription: String? = nil,
        releaseDate: String? = nil,
        reviews: [String:String]? = nil,
        skillTypes: [String]? = nil
    )
    {
        self.bulletPoints = bulletPoints
        self.developerInfo = developerInfo
        self.endUserLicenseAgreement = endUserLicenseAgreement
        self.genericKeywords = genericKeywords
        self.invocationPhrase = invocationPhrase
        self.newInThisVersionBulletPoints = newInThisVersionBulletPoints
        self.productDescription = productDescription
        self.releaseDate = releaseDate
        self.reviews = reviews
        self.skillTypes = skillTypes
    }
}

extension SkillGroup: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case skillGroupArn = "SkillGroupArn"
        case skillGroupName = "SkillGroupName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let skillGroupArn = skillGroupArn {
            try encodeContainer.encode(skillGroupArn, forKey: .skillGroupArn)
        }
        if let skillGroupName = skillGroupName {
            try encodeContainer.encode(skillGroupName, forKey: .skillGroupName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let skillGroupArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .skillGroupArn)
        skillGroupArn = skillGroupArnDecoded
        let skillGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .skillGroupName)
        skillGroupName = skillGroupNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension SkillGroup: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SkillGroup(description: \(String(describing: description)), skillGroupArn: \(String(describing: skillGroupArn)), skillGroupName: \(String(describing: skillGroupName)))"}
}

/// <p>A skill group with attributes.</p>
public struct SkillGroup: Equatable {
    /// <p>The description of a skill group.</p>
    public let description: String?
    /// <p>The ARN of a skill group.</p>
    public let skillGroupArn: String?
    /// <p>The name of a skill group.</p>
    public let skillGroupName: String?

    public init (
        description: String? = nil,
        skillGroupArn: String? = nil,
        skillGroupName: String? = nil
    )
    {
        self.description = description
        self.skillGroupArn = skillGroupArn
        self.skillGroupName = skillGroupName
    }
}

extension SkillGroupData: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case skillGroupArn = "SkillGroupArn"
        case skillGroupName = "SkillGroupName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let skillGroupArn = skillGroupArn {
            try encodeContainer.encode(skillGroupArn, forKey: .skillGroupArn)
        }
        if let skillGroupName = skillGroupName {
            try encodeContainer.encode(skillGroupName, forKey: .skillGroupName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let skillGroupArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .skillGroupArn)
        skillGroupArn = skillGroupArnDecoded
        let skillGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .skillGroupName)
        skillGroupName = skillGroupNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension SkillGroupData: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SkillGroupData(description: \(String(describing: description)), skillGroupArn: \(String(describing: skillGroupArn)), skillGroupName: \(String(describing: skillGroupName)))"}
}

/// <p>The attributes of a skill group.</p>
public struct SkillGroupData: Equatable {
    /// <p>The description of a skill group.</p>
    public let description: String?
    /// <p>The skill group ARN of a skill group.</p>
    public let skillGroupArn: String?
    /// <p>The skill group name of a skill group.</p>
    public let skillGroupName: String?

    public init (
        description: String? = nil,
        skillGroupArn: String? = nil,
        skillGroupName: String? = nil
    )
    {
        self.description = description
        self.skillGroupArn = skillGroupArn
        self.skillGroupName = skillGroupName
    }
}

extension SkillNotLinkedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SkillNotLinkedException(message: \(String(describing: message)))"}
}

extension SkillNotLinkedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: SkillNotLinkedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The skill must be linked to a third-party account.</p>
public struct SkillNotLinkedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct SkillNotLinkedExceptionBody: Equatable {
    public let message: String?
}

extension SkillNotLinkedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SkillSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case enablementType = "EnablementType"
        case skillId = "SkillId"
        case skillName = "SkillName"
        case skillType = "SkillType"
        case supportsLinking = "SupportsLinking"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enablementType = enablementType {
            try encodeContainer.encode(enablementType.rawValue, forKey: .enablementType)
        }
        if let skillId = skillId {
            try encodeContainer.encode(skillId, forKey: .skillId)
        }
        if let skillName = skillName {
            try encodeContainer.encode(skillName, forKey: .skillName)
        }
        if let skillType = skillType {
            try encodeContainer.encode(skillType.rawValue, forKey: .skillType)
        }
        if supportsLinking != false {
            try encodeContainer.encode(supportsLinking, forKey: .supportsLinking)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let skillIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .skillId)
        skillId = skillIdDecoded
        let skillNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .skillName)
        skillName = skillNameDecoded
        let supportsLinkingDecoded = try containerValues.decode(Bool.self, forKey: .supportsLinking)
        supportsLinking = supportsLinkingDecoded
        let enablementTypeDecoded = try containerValues.decodeIfPresent(EnablementType.self, forKey: .enablementType)
        enablementType = enablementTypeDecoded
        let skillTypeDecoded = try containerValues.decodeIfPresent(SkillType.self, forKey: .skillType)
        skillType = skillTypeDecoded
    }
}

extension SkillSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SkillSummary(enablementType: \(String(describing: enablementType)), skillId: \(String(describing: skillId)), skillName: \(String(describing: skillName)), skillType: \(String(describing: skillType)), supportsLinking: \(String(describing: supportsLinking)))"}
}

/// <p>The summary of skills.</p>
public struct SkillSummary: Equatable {
    /// <p>Whether the skill is enabled under the user's account, or if it requires linking to be
    ///          used.</p>
    public let enablementType: EnablementType?
    /// <p>The ARN of the skill summary.</p>
    public let skillId: String?
    /// <p>The name of the skill.</p>
    public let skillName: String?
    /// <p>Whether the skill is publicly available or is a private skill.</p>
    public let skillType: SkillType?
    /// <p>Linking support for a skill.</p>
    public let supportsLinking: Bool

    public init (
        enablementType: EnablementType? = nil,
        skillId: String? = nil,
        skillName: String? = nil,
        skillType: SkillType? = nil,
        supportsLinking: Bool = false
    )
    {
        self.enablementType = enablementType
        self.skillId = skillId
        self.skillName = skillName
        self.skillType = skillType
        self.supportsLinking = supportsLinking
    }
}

public enum SkillType {
    case `private`
    case `public`
    case sdkUnknown(String)
}

extension SkillType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SkillType] {
        return [
            .private,
            .public,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .private: return "PRIVATE"
        case .public: return "PUBLIC"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SkillType(rawValue: rawValue) ?? SkillType.sdkUnknown(rawValue)
    }
}

public enum SkillTypeFilter {
    case all
    case `private`
    case `public`
    case sdkUnknown(String)
}

extension SkillTypeFilter : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SkillTypeFilter] {
        return [
            .all,
            .private,
            .public,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .all: return "ALL"
        case .private: return "PRIVATE"
        case .public: return "PUBLIC"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SkillTypeFilter(rawValue: rawValue) ?? SkillTypeFilter.sdkUnknown(rawValue)
    }
}

extension SkillsStoreSkill: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case iconUrl = "IconUrl"
        case sampleUtterances = "SampleUtterances"
        case shortDescription = "ShortDescription"
        case skillDetails = "SkillDetails"
        case skillId = "SkillId"
        case skillName = "SkillName"
        case supportsLinking = "SupportsLinking"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let iconUrl = iconUrl {
            try encodeContainer.encode(iconUrl, forKey: .iconUrl)
        }
        if let sampleUtterances = sampleUtterances {
            var sampleUtterancesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sampleUtterances)
            for sampleutterances0 in sampleUtterances {
                try sampleUtterancesContainer.encode(sampleutterances0)
            }
        }
        if let shortDescription = shortDescription {
            try encodeContainer.encode(shortDescription, forKey: .shortDescription)
        }
        if let skillDetails = skillDetails {
            try encodeContainer.encode(skillDetails, forKey: .skillDetails)
        }
        if let skillId = skillId {
            try encodeContainer.encode(skillId, forKey: .skillId)
        }
        if let skillName = skillName {
            try encodeContainer.encode(skillName, forKey: .skillName)
        }
        if supportsLinking != false {
            try encodeContainer.encode(supportsLinking, forKey: .supportsLinking)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let skillIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .skillId)
        skillId = skillIdDecoded
        let skillNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .skillName)
        skillName = skillNameDecoded
        let shortDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .shortDescription)
        shortDescription = shortDescriptionDecoded
        let iconUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .iconUrl)
        iconUrl = iconUrlDecoded
        let sampleUtterancesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .sampleUtterances)
        var sampleUtterancesDecoded0:[String]? = nil
        if let sampleUtterancesContainer = sampleUtterancesContainer {
            sampleUtterancesDecoded0 = [String]()
            for string0 in sampleUtterancesContainer {
                if let string0 = string0 {
                    sampleUtterancesDecoded0?.append(string0)
                }
            }
        }
        sampleUtterances = sampleUtterancesDecoded0
        let skillDetailsDecoded = try containerValues.decodeIfPresent(SkillDetails.self, forKey: .skillDetails)
        skillDetails = skillDetailsDecoded
        let supportsLinkingDecoded = try containerValues.decode(Bool.self, forKey: .supportsLinking)
        supportsLinking = supportsLinkingDecoded
    }
}

extension SkillsStoreSkill: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SkillsStoreSkill(iconUrl: \(String(describing: iconUrl)), sampleUtterances: \(String(describing: sampleUtterances)), shortDescription: \(String(describing: shortDescription)), skillDetails: \(String(describing: skillDetails)), skillId: \(String(describing: skillId)), skillName: \(String(describing: skillName)), supportsLinking: \(String(describing: supportsLinking)))"}
}

/// <p>The detailed information about an Alexa skill.</p>
public struct SkillsStoreSkill: Equatable {
    /// <p>The URL where the skill icon resides.</p>
    public let iconUrl: String?
    /// <p>Sample utterances that interact with the skill.</p>
    public let sampleUtterances: [String]?
    /// <p>Short description about the skill.</p>
    public let shortDescription: String?
    /// <p>Information about the skill.</p>
    public let skillDetails: SkillDetails?
    /// <p>The ARN of the skill.</p>
    public let skillId: String?
    /// <p>The name of the skill.</p>
    public let skillName: String?
    /// <p>Linking support for a skill.</p>
    public let supportsLinking: Bool

    public init (
        iconUrl: String? = nil,
        sampleUtterances: [String]? = nil,
        shortDescription: String? = nil,
        skillDetails: SkillDetails? = nil,
        skillId: String? = nil,
        skillName: String? = nil,
        supportsLinking: Bool = false
    )
    {
        self.iconUrl = iconUrl
        self.sampleUtterances = sampleUtterances
        self.shortDescription = shortDescription
        self.skillDetails = skillDetails
        self.skillId = skillId
        self.skillName = skillName
        self.supportsLinking = supportsLinking
    }
}

extension SmartHomeAppliance: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case friendlyName = "FriendlyName"
        case manufacturerName = "ManufacturerName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let friendlyName = friendlyName {
            try encodeContainer.encode(friendlyName, forKey: .friendlyName)
        }
        if let manufacturerName = manufacturerName {
            try encodeContainer.encode(manufacturerName, forKey: .manufacturerName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let friendlyNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .friendlyName)
        friendlyName = friendlyNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let manufacturerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .manufacturerName)
        manufacturerName = manufacturerNameDecoded
    }
}

extension SmartHomeAppliance: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SmartHomeAppliance(description: \(String(describing: description)), friendlyName: \(String(describing: friendlyName)), manufacturerName: \(String(describing: manufacturerName)))"}
}

/// <p>A smart home appliance that can connect to a central system. Any domestic device can be
///          a smart appliance. </p>
public struct SmartHomeAppliance: Equatable {
    /// <p>The description of the smart home appliance.</p>
    public let description: String?
    /// <p>The friendly name of the smart home appliance.</p>
    public let friendlyName: String?
    /// <p>The name of the manufacturer of the smart home appliance.</p>
    public let manufacturerName: String?

    public init (
        description: String? = nil,
        friendlyName: String? = nil,
        manufacturerName: String? = nil
    )
    {
        self.description = description
        self.friendlyName = friendlyName
        self.manufacturerName = manufacturerName
    }
}

extension Sort: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value.rawValue, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(SortValue.self, forKey: .value)
        value = valueDecoded
    }
}

extension Sort: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Sort(key: \(String(describing: key)), value: \(String(describing: value)))"}
}

/// <p>An object representing a sort criteria. </p>
public struct Sort: Equatable {
    /// <p>The sort key of a sort object.</p>
    public let key: String?
    /// <p>The sort value of a sort object.</p>
    public let value: SortValue?

    public init (
        key: String? = nil,
        value: SortValue? = nil
    )
    {
        self.key = key
        self.value = value
    }
}

public enum SortValue {
    case asc
    case desc
    case sdkUnknown(String)
}

extension SortValue : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SortValue] {
        return [
            .asc,
            .desc,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .asc: return "ASC"
        case .desc: return "DESC"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SortValue(rawValue: rawValue) ?? SortValue.sdkUnknown(rawValue)
    }
}

extension Ssml: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case locale = "Locale"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let locale = locale {
            try encodeContainer.encode(locale.rawValue, forKey: .locale)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let localeDecoded = try containerValues.decodeIfPresent(Locale.self, forKey: .locale)
        locale = localeDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Ssml: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Ssml(locale: \(String(describing: locale)), value: \(String(describing: value)))"}
}

/// <p>The SSML message. For more information, see <a href="https://developer.amazon.com/docs/custom-skills/speech-synthesis-markup-language-ssml-reference.html">SSML Reference</a>.</p>
public struct Ssml: Equatable {
    /// <p>The locale of the SSML message. Currently, en-US is supported.</p>
    public let locale: Locale?
    /// <p>The value of the SSML message in the correct SSML format. The audio tag is not supported.</p>
    public let value: String?

    public init (
        locale: Locale? = nil,
        value: String? = nil
    )
    {
        self.locale = locale
        self.value = value
    }
}

public struct StartDeviceSyncInputBodyMiddleware: Middleware {
    public let id: String = "StartDeviceSyncInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartDeviceSyncInput>,
                  next: H) -> Swift.Result<OperationOutput<StartDeviceSyncOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartDeviceSyncInput>
    public typealias MOutput = OperationOutput<StartDeviceSyncOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartDeviceSyncOutputError>
}

extension StartDeviceSyncInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartDeviceSyncInput(deviceArn: \(String(describing: deviceArn)), features: \(String(describing: features)), roomArn: \(String(describing: roomArn)))"}
}

extension StartDeviceSyncInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case deviceArn = "DeviceArn"
        case features = "Features"
        case roomArn = "RoomArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceArn = deviceArn {
            try encodeContainer.encode(deviceArn, forKey: .deviceArn)
        }
        if let features = features {
            var featuresContainer = encodeContainer.nestedUnkeyedContainer(forKey: .features)
            for features0 in features {
                try featuresContainer.encode(features0.rawValue)
            }
        }
        if let roomArn = roomArn {
            try encodeContainer.encode(roomArn, forKey: .roomArn)
        }
    }
}

public struct StartDeviceSyncInputHeadersMiddleware: Middleware {
    public let id: String = "StartDeviceSyncInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartDeviceSyncInput>,
                  next: H) -> Swift.Result<OperationOutput<StartDeviceSyncOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartDeviceSyncInput>
    public typealias MOutput = OperationOutput<StartDeviceSyncOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartDeviceSyncOutputError>
}

public struct StartDeviceSyncInputQueryItemMiddleware: Middleware {
    public let id: String = "StartDeviceSyncInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartDeviceSyncInput>,
                  next: H) -> Swift.Result<OperationOutput<StartDeviceSyncOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartDeviceSyncInput>
    public typealias MOutput = OperationOutput<StartDeviceSyncOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartDeviceSyncOutputError>
}

public struct StartDeviceSyncInput: Equatable {
    /// <p>The ARN of the device to sync. Required.</p>
    public let deviceArn: String?
    /// <p>Request structure to start the device sync. Required.</p>
    public let features: [Feature]?
    /// <p>The ARN of the room with which the device to sync is associated. Required.</p>
    public let roomArn: String?

    public init (
        deviceArn: String? = nil,
        features: [Feature]? = nil,
        roomArn: String? = nil
    )
    {
        self.deviceArn = deviceArn
        self.features = features
        self.roomArn = roomArn
    }
}

struct StartDeviceSyncInputBody: Equatable {
    public let roomArn: String?
    public let deviceArn: String?
    public let features: [Feature]?
}

extension StartDeviceSyncInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case deviceArn = "DeviceArn"
        case features = "Features"
        case roomArn = "RoomArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roomArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roomArn)
        roomArn = roomArnDecoded
        let deviceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deviceArn)
        deviceArn = deviceArnDecoded
        let featuresContainer = try containerValues.decodeIfPresent([Feature?].self, forKey: .features)
        var featuresDecoded0:[Feature]? = nil
        if let featuresContainer = featuresContainer {
            featuresDecoded0 = [Feature]()
            for string0 in featuresContainer {
                if let string0 = string0 {
                    featuresDecoded0?.append(string0)
                }
            }
        }
        features = featuresDecoded0
    }
}

extension StartDeviceSyncOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartDeviceSyncOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DeviceNotRegisteredException" : self = .deviceNotRegisteredException(try DeviceNotRegisteredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartDeviceSyncOutputError: Equatable {
    case deviceNotRegisteredException(DeviceNotRegisteredException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartDeviceSyncOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartDeviceSyncOutputResponse()"}
}

extension StartDeviceSyncOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct StartDeviceSyncOutputResponse: Equatable {

    public init() {}
}

struct StartDeviceSyncOutputResponseBody: Equatable {
}

extension StartDeviceSyncOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct StartSmartHomeApplianceDiscoveryInputBodyMiddleware: Middleware {
    public let id: String = "StartSmartHomeApplianceDiscoveryInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartSmartHomeApplianceDiscoveryInput>,
                  next: H) -> Swift.Result<OperationOutput<StartSmartHomeApplianceDiscoveryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartSmartHomeApplianceDiscoveryInput>
    public typealias MOutput = OperationOutput<StartSmartHomeApplianceDiscoveryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartSmartHomeApplianceDiscoveryOutputError>
}

extension StartSmartHomeApplianceDiscoveryInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartSmartHomeApplianceDiscoveryInput(roomArn: \(String(describing: roomArn)))"}
}

extension StartSmartHomeApplianceDiscoveryInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case roomArn = "RoomArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let roomArn = roomArn {
            try encodeContainer.encode(roomArn, forKey: .roomArn)
        }
    }
}

public struct StartSmartHomeApplianceDiscoveryInputHeadersMiddleware: Middleware {
    public let id: String = "StartSmartHomeApplianceDiscoveryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartSmartHomeApplianceDiscoveryInput>,
                  next: H) -> Swift.Result<OperationOutput<StartSmartHomeApplianceDiscoveryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartSmartHomeApplianceDiscoveryInput>
    public typealias MOutput = OperationOutput<StartSmartHomeApplianceDiscoveryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartSmartHomeApplianceDiscoveryOutputError>
}

public struct StartSmartHomeApplianceDiscoveryInputQueryItemMiddleware: Middleware {
    public let id: String = "StartSmartHomeApplianceDiscoveryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartSmartHomeApplianceDiscoveryInput>,
                  next: H) -> Swift.Result<OperationOutput<StartSmartHomeApplianceDiscoveryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartSmartHomeApplianceDiscoveryInput>
    public typealias MOutput = OperationOutput<StartSmartHomeApplianceDiscoveryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartSmartHomeApplianceDiscoveryOutputError>
}

public struct StartSmartHomeApplianceDiscoveryInput: Equatable {
    /// <p>The room where smart home appliance discovery was initiated.</p>
    public let roomArn: String?

    public init (
        roomArn: String? = nil
    )
    {
        self.roomArn = roomArn
    }
}

struct StartSmartHomeApplianceDiscoveryInputBody: Equatable {
    public let roomArn: String?
}

extension StartSmartHomeApplianceDiscoveryInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case roomArn = "RoomArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roomArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roomArn)
        roomArn = roomArnDecoded
    }
}

extension StartSmartHomeApplianceDiscoveryOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartSmartHomeApplianceDiscoveryOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartSmartHomeApplianceDiscoveryOutputError: Equatable {
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartSmartHomeApplianceDiscoveryOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartSmartHomeApplianceDiscoveryOutputResponse()"}
}

extension StartSmartHomeApplianceDiscoveryOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct StartSmartHomeApplianceDiscoveryOutputResponse: Equatable {

    public init() {}
}

struct StartSmartHomeApplianceDiscoveryOutputResponseBody: Equatable {
}

extension StartSmartHomeApplianceDiscoveryOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension Tag: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Tag: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Tag(key: \(String(describing: key)), value: \(String(describing: value)))"}
}

/// <p>A key-value pair that can be associated with a resource. </p>
public struct Tag: Equatable {
    /// <p>The key of a tag. Tag keys are case-sensitive. </p>
    public let key: String?
    /// <p>The value of a tag. Tag values are case sensitive and can be null.</p>
    public let value: String?

    public init (
        key: String? = nil,
        value: String? = nil
    )
    {
        self.key = key
        self.value = value
    }
}

public struct TagResourceInputBodyMiddleware: Middleware {
    public let id: String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

extension TagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceInput(arn: \(String(describing: arn)), tags: \(String(describing: tags)))"}
}

extension TagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Equatable {
    /// <p>The ARN of the resource to which to add metadata tags. Required. </p>
    public let arn: String?
    /// <p>The tags to be added to the specified resource. Do not provide system tags. Required.
    ///       </p>
    public let tags: [Tag]?

    public init (
        arn: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.arn = arn
        self.tags = tags
    }
}

struct TagResourceInputBody: Equatable {
    public let arn: String?
    public let tags: [Tag]?
}

extension TagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Equatable {
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Equatable {
}

extension TagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public enum TemperatureUnit {
    case celsius
    case fahrenheit
    case sdkUnknown(String)
}

extension TemperatureUnit : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [TemperatureUnit] {
        return [
            .celsius,
            .fahrenheit,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .celsius: return "CELSIUS"
        case .fahrenheit: return "FAHRENHEIT"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = TemperatureUnit(rawValue: rawValue) ?? TemperatureUnit.sdkUnknown(rawValue)
    }
}

extension Text: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case locale = "Locale"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let locale = locale {
            try encodeContainer.encode(locale.rawValue, forKey: .locale)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let localeDecoded = try containerValues.decodeIfPresent(Locale.self, forKey: .locale)
        locale = localeDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Text: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Text(locale: \(String(describing: locale)), value: \(String(describing: value)))"}
}

/// <p>The text message.</p>
public struct Text: Equatable {
    /// <p>The locale of the text message. Currently, en-US is supported.</p>
    public let locale: Locale?
    /// <p>The value of the text message.</p>
    public let value: String?

    public init (
        locale: Locale? = nil,
        value: String? = nil
    )
    {
        self.locale = locale
        self.value = value
    }
}

extension UnauthorizedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UnauthorizedException(message: \(String(describing: message)))"}
}

extension UnauthorizedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UnauthorizedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The caller has no permissions to operate on the resource involved in the API call.</p>
public struct UnauthorizedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct UnauthorizedExceptionBody: Equatable {
    public let message: String?
}

extension UnauthorizedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct UntagResourceInputBodyMiddleware: Middleware {
    public let id: String = "UntagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

extension UntagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceInput(arn: \(String(describing: arn)), tagKeys: \(String(describing: tagKeys)))"}
}

extension UntagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkeylist0 in tagKeys {
                try tagKeysContainer.encode(tagkeylist0)
            }
        }
    }
}

public struct UntagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Equatable {
    /// <p>The ARN of the resource from which to remove metadata tags. Required. </p>
    public let arn: String?
    /// <p>The tags to be removed from the specified resource. Do not provide system tags.
    ///          Required. </p>
    public let tagKeys: [String]?

    public init (
        arn: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.arn = arn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Equatable {
    public let arn: String?
    public let tagKeys: [String]?
}

extension UntagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Equatable {
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Equatable {
}

extension UntagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateAddressBookInputBodyMiddleware: Middleware {
    public let id: String = "UpdateAddressBookInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAddressBookInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAddressBookOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAddressBookInput>
    public typealias MOutput = OperationOutput<UpdateAddressBookOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAddressBookOutputError>
}

extension UpdateAddressBookInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateAddressBookInput(addressBookArn: \(String(describing: addressBookArn)), description: \(String(describing: description)), name: \(String(describing: name)))"}
}

extension UpdateAddressBookInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case addressBookArn = "AddressBookArn"
        case description = "Description"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addressBookArn = addressBookArn {
            try encodeContainer.encode(addressBookArn, forKey: .addressBookArn)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct UpdateAddressBookInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateAddressBookInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAddressBookInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAddressBookOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAddressBookInput>
    public typealias MOutput = OperationOutput<UpdateAddressBookOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAddressBookOutputError>
}

public struct UpdateAddressBookInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateAddressBookInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAddressBookInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAddressBookOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAddressBookInput>
    public typealias MOutput = OperationOutput<UpdateAddressBookOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAddressBookOutputError>
}

public struct UpdateAddressBookInput: Equatable {
    /// <p>The ARN of the room to update.</p>
    public let addressBookArn: String?
    /// <p>The updated description of the room.</p>
    public let description: String?
    /// <p>The updated name of the room.</p>
    public let name: String?

    public init (
        addressBookArn: String? = nil,
        description: String? = nil,
        name: String? = nil
    )
    {
        self.addressBookArn = addressBookArn
        self.description = description
        self.name = name
    }
}

struct UpdateAddressBookInputBody: Equatable {
    public let addressBookArn: String?
    public let name: String?
    public let description: String?
}

extension UpdateAddressBookInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case addressBookArn = "AddressBookArn"
        case description = "Description"
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addressBookArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .addressBookArn)
        addressBookArn = addressBookArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateAddressBookOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateAddressBookOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NameInUseException" : self = .nameInUseException(try NameInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateAddressBookOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case nameInUseException(NameInUseException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateAddressBookOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateAddressBookOutputResponse()"}
}

extension UpdateAddressBookOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateAddressBookOutputResponse: Equatable {

    public init() {}
}

struct UpdateAddressBookOutputResponseBody: Equatable {
}

extension UpdateAddressBookOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateBusinessReportScheduleInputBodyMiddleware: Middleware {
    public let id: String = "UpdateBusinessReportScheduleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateBusinessReportScheduleInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateBusinessReportScheduleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateBusinessReportScheduleInput>
    public typealias MOutput = OperationOutput<UpdateBusinessReportScheduleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateBusinessReportScheduleOutputError>
}

extension UpdateBusinessReportScheduleInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateBusinessReportScheduleInput(format: \(String(describing: format)), recurrence: \(String(describing: recurrence)), s3BucketName: \(String(describing: s3BucketName)), s3KeyPrefix: \(String(describing: s3KeyPrefix)), scheduleArn: \(String(describing: scheduleArn)), scheduleName: \(String(describing: scheduleName)))"}
}

extension UpdateBusinessReportScheduleInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case format = "Format"
        case recurrence = "Recurrence"
        case s3BucketName = "S3BucketName"
        case s3KeyPrefix = "S3KeyPrefix"
        case scheduleArn = "ScheduleArn"
        case scheduleName = "ScheduleName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let format = format {
            try encodeContainer.encode(format.rawValue, forKey: .format)
        }
        if let recurrence = recurrence {
            try encodeContainer.encode(recurrence, forKey: .recurrence)
        }
        if let s3BucketName = s3BucketName {
            try encodeContainer.encode(s3BucketName, forKey: .s3BucketName)
        }
        if let s3KeyPrefix = s3KeyPrefix {
            try encodeContainer.encode(s3KeyPrefix, forKey: .s3KeyPrefix)
        }
        if let scheduleArn = scheduleArn {
            try encodeContainer.encode(scheduleArn, forKey: .scheduleArn)
        }
        if let scheduleName = scheduleName {
            try encodeContainer.encode(scheduleName, forKey: .scheduleName)
        }
    }
}

public struct UpdateBusinessReportScheduleInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateBusinessReportScheduleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateBusinessReportScheduleInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateBusinessReportScheduleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateBusinessReportScheduleInput>
    public typealias MOutput = OperationOutput<UpdateBusinessReportScheduleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateBusinessReportScheduleOutputError>
}

public struct UpdateBusinessReportScheduleInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateBusinessReportScheduleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateBusinessReportScheduleInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateBusinessReportScheduleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateBusinessReportScheduleInput>
    public typealias MOutput = OperationOutput<UpdateBusinessReportScheduleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateBusinessReportScheduleOutputError>
}

public struct UpdateBusinessReportScheduleInput: Equatable {
    /// <p>The format of the generated report (individual CSV files or zipped files of
    ///          individual files).</p>
    public let format: BusinessReportFormat?
    /// <p>The recurrence of the reports.</p>
    public let recurrence: BusinessReportRecurrence?
    /// <p>The S3 location of the output reports.</p>
    public let s3BucketName: String?
    /// <p>The S3 key where the report is delivered.</p>
    public let s3KeyPrefix: String?
    /// <p>The ARN of the business report schedule.</p>
    public let scheduleArn: String?
    /// <p>The name identifier of the schedule.</p>
    public let scheduleName: String?

    public init (
        format: BusinessReportFormat? = nil,
        recurrence: BusinessReportRecurrence? = nil,
        s3BucketName: String? = nil,
        s3KeyPrefix: String? = nil,
        scheduleArn: String? = nil,
        scheduleName: String? = nil
    )
    {
        self.format = format
        self.recurrence = recurrence
        self.s3BucketName = s3BucketName
        self.s3KeyPrefix = s3KeyPrefix
        self.scheduleArn = scheduleArn
        self.scheduleName = scheduleName
    }
}

struct UpdateBusinessReportScheduleInputBody: Equatable {
    public let scheduleArn: String?
    public let s3BucketName: String?
    public let s3KeyPrefix: String?
    public let format: BusinessReportFormat?
    public let scheduleName: String?
    public let recurrence: BusinessReportRecurrence?
}

extension UpdateBusinessReportScheduleInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case format = "Format"
        case recurrence = "Recurrence"
        case s3BucketName = "S3BucketName"
        case s3KeyPrefix = "S3KeyPrefix"
        case scheduleArn = "ScheduleArn"
        case scheduleName = "ScheduleName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scheduleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .scheduleArn)
        scheduleArn = scheduleArnDecoded
        let s3BucketNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3BucketName)
        s3BucketName = s3BucketNameDecoded
        let s3KeyPrefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3KeyPrefix)
        s3KeyPrefix = s3KeyPrefixDecoded
        let formatDecoded = try containerValues.decodeIfPresent(BusinessReportFormat.self, forKey: .format)
        format = formatDecoded
        let scheduleNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .scheduleName)
        scheduleName = scheduleNameDecoded
        let recurrenceDecoded = try containerValues.decodeIfPresent(BusinessReportRecurrence.self, forKey: .recurrence)
        recurrence = recurrenceDecoded
    }
}

extension UpdateBusinessReportScheduleOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateBusinessReportScheduleOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateBusinessReportScheduleOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateBusinessReportScheduleOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateBusinessReportScheduleOutputResponse()"}
}

extension UpdateBusinessReportScheduleOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateBusinessReportScheduleOutputResponse: Equatable {

    public init() {}
}

struct UpdateBusinessReportScheduleOutputResponseBody: Equatable {
}

extension UpdateBusinessReportScheduleOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateConferenceProviderInputBodyMiddleware: Middleware {
    public let id: String = "UpdateConferenceProviderInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateConferenceProviderInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateConferenceProviderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateConferenceProviderInput>
    public typealias MOutput = OperationOutput<UpdateConferenceProviderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateConferenceProviderOutputError>
}

extension UpdateConferenceProviderInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateConferenceProviderInput(conferenceProviderArn: \(String(describing: conferenceProviderArn)), conferenceProviderType: \(String(describing: conferenceProviderType)), iPDialIn: \(String(describing: iPDialIn)), meetingSetting: \(String(describing: meetingSetting)), pSTNDialIn: \(String(describing: pSTNDialIn)))"}
}

extension UpdateConferenceProviderInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case conferenceProviderArn = "ConferenceProviderArn"
        case conferenceProviderType = "ConferenceProviderType"
        case iPDialIn = "IPDialIn"
        case meetingSetting = "MeetingSetting"
        case pSTNDialIn = "PSTNDialIn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let conferenceProviderArn = conferenceProviderArn {
            try encodeContainer.encode(conferenceProviderArn, forKey: .conferenceProviderArn)
        }
        if let conferenceProviderType = conferenceProviderType {
            try encodeContainer.encode(conferenceProviderType.rawValue, forKey: .conferenceProviderType)
        }
        if let iPDialIn = iPDialIn {
            try encodeContainer.encode(iPDialIn, forKey: .iPDialIn)
        }
        if let meetingSetting = meetingSetting {
            try encodeContainer.encode(meetingSetting, forKey: .meetingSetting)
        }
        if let pSTNDialIn = pSTNDialIn {
            try encodeContainer.encode(pSTNDialIn, forKey: .pSTNDialIn)
        }
    }
}

public struct UpdateConferenceProviderInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateConferenceProviderInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateConferenceProviderInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateConferenceProviderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateConferenceProviderInput>
    public typealias MOutput = OperationOutput<UpdateConferenceProviderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateConferenceProviderOutputError>
}

public struct UpdateConferenceProviderInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateConferenceProviderInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateConferenceProviderInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateConferenceProviderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateConferenceProviderInput>
    public typealias MOutput = OperationOutput<UpdateConferenceProviderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateConferenceProviderOutputError>
}

public struct UpdateConferenceProviderInput: Equatable {
    /// <p>The ARN of the conference provider.</p>
    public let conferenceProviderArn: String?
    /// <p>The type of the conference provider.</p>
    public let conferenceProviderType: ConferenceProviderType?
    /// <p>The IP endpoint and protocol for calling.</p>
    public let iPDialIn: IPDialIn?
    /// <p>The meeting settings for the conference provider.</p>
    public let meetingSetting: MeetingSetting?
    /// <p>The information for PSTN conferencing.</p>
    public let pSTNDialIn: PSTNDialIn?

    public init (
        conferenceProviderArn: String? = nil,
        conferenceProviderType: ConferenceProviderType? = nil,
        iPDialIn: IPDialIn? = nil,
        meetingSetting: MeetingSetting? = nil,
        pSTNDialIn: PSTNDialIn? = nil
    )
    {
        self.conferenceProviderArn = conferenceProviderArn
        self.conferenceProviderType = conferenceProviderType
        self.iPDialIn = iPDialIn
        self.meetingSetting = meetingSetting
        self.pSTNDialIn = pSTNDialIn
    }
}

struct UpdateConferenceProviderInputBody: Equatable {
    public let conferenceProviderArn: String?
    public let conferenceProviderType: ConferenceProviderType?
    public let iPDialIn: IPDialIn?
    public let pSTNDialIn: PSTNDialIn?
    public let meetingSetting: MeetingSetting?
}

extension UpdateConferenceProviderInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case conferenceProviderArn = "ConferenceProviderArn"
        case conferenceProviderType = "ConferenceProviderType"
        case iPDialIn = "IPDialIn"
        case meetingSetting = "MeetingSetting"
        case pSTNDialIn = "PSTNDialIn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let conferenceProviderArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .conferenceProviderArn)
        conferenceProviderArn = conferenceProviderArnDecoded
        let conferenceProviderTypeDecoded = try containerValues.decodeIfPresent(ConferenceProviderType.self, forKey: .conferenceProviderType)
        conferenceProviderType = conferenceProviderTypeDecoded
        let iPDialInDecoded = try containerValues.decodeIfPresent(IPDialIn.self, forKey: .iPDialIn)
        iPDialIn = iPDialInDecoded
        let pSTNDialInDecoded = try containerValues.decodeIfPresent(PSTNDialIn.self, forKey: .pSTNDialIn)
        pSTNDialIn = pSTNDialInDecoded
        let meetingSettingDecoded = try containerValues.decodeIfPresent(MeetingSetting.self, forKey: .meetingSetting)
        meetingSetting = meetingSettingDecoded
    }
}

extension UpdateConferenceProviderOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateConferenceProviderOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateConferenceProviderOutputError: Equatable {
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateConferenceProviderOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateConferenceProviderOutputResponse()"}
}

extension UpdateConferenceProviderOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateConferenceProviderOutputResponse: Equatable {

    public init() {}
}

struct UpdateConferenceProviderOutputResponseBody: Equatable {
}

extension UpdateConferenceProviderOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateContactInputBodyMiddleware: Middleware {
    public let id: String = "UpdateContactInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateContactInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateContactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateContactInput>
    public typealias MOutput = OperationOutput<UpdateContactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateContactOutputError>
}

extension UpdateContactInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateContactInput(contactArn: \(String(describing: contactArn)), displayName: \(String(describing: displayName)), firstName: \(String(describing: firstName)), lastName: \(String(describing: lastName)), phoneNumber: \(String(describing: phoneNumber)), phoneNumbers: \(String(describing: phoneNumbers)), sipAddresses: \(String(describing: sipAddresses)))"}
}

extension UpdateContactInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case contactArn = "ContactArn"
        case displayName = "DisplayName"
        case firstName = "FirstName"
        case lastName = "LastName"
        case phoneNumber = "PhoneNumber"
        case phoneNumbers = "PhoneNumbers"
        case sipAddresses = "SipAddresses"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactArn = contactArn {
            try encodeContainer.encode(contactArn, forKey: .contactArn)
        }
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let firstName = firstName {
            try encodeContainer.encode(firstName, forKey: .firstName)
        }
        if let lastName = lastName {
            try encodeContainer.encode(lastName, forKey: .lastName)
        }
        if let phoneNumber = phoneNumber {
            try encodeContainer.encode(phoneNumber, forKey: .phoneNumber)
        }
        if let phoneNumbers = phoneNumbers {
            var phoneNumbersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .phoneNumbers)
            for phonenumberlist0 in phoneNumbers {
                try phoneNumbersContainer.encode(phonenumberlist0)
            }
        }
        if let sipAddresses = sipAddresses {
            var sipAddressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sipAddresses)
            for sipaddresslist0 in sipAddresses {
                try sipAddressesContainer.encode(sipaddresslist0)
            }
        }
    }
}

public struct UpdateContactInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateContactInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateContactInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateContactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateContactInput>
    public typealias MOutput = OperationOutput<UpdateContactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateContactOutputError>
}

public struct UpdateContactInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateContactInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateContactInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateContactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateContactInput>
    public typealias MOutput = OperationOutput<UpdateContactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateContactOutputError>
}

public struct UpdateContactInput: Equatable {
    /// <p>The ARN of the contact to update.</p>
    public let contactArn: String?
    /// <p>The updated display name of the contact.</p>
    public let displayName: String?
    /// <p>The updated first name of the contact.</p>
    public let firstName: String?
    /// <p>The updated last name of the contact.</p>
    public let lastName: String?
    /// <p>The updated phone number of the contact. The phone number type defaults to WORK. You
    ///          can either specify PhoneNumber or PhoneNumbers. We recommend that you use PhoneNumbers,
    ///          which lets you specify the phone number type and multiple numbers.</p>
    public let phoneNumber: String?
    /// <p>The list of phone numbers for the contact.</p>
    public let phoneNumbers: [PhoneNumber]?
    /// <p>The list of SIP addresses for the contact.</p>
    public let sipAddresses: [SipAddress]?

    public init (
        contactArn: String? = nil,
        displayName: String? = nil,
        firstName: String? = nil,
        lastName: String? = nil,
        phoneNumber: String? = nil,
        phoneNumbers: [PhoneNumber]? = nil,
        sipAddresses: [SipAddress]? = nil
    )
    {
        self.contactArn = contactArn
        self.displayName = displayName
        self.firstName = firstName
        self.lastName = lastName
        self.phoneNumber = phoneNumber
        self.phoneNumbers = phoneNumbers
        self.sipAddresses = sipAddresses
    }
}

struct UpdateContactInputBody: Equatable {
    public let contactArn: String?
    public let displayName: String?
    public let firstName: String?
    public let lastName: String?
    public let phoneNumber: String?
    public let phoneNumbers: [PhoneNumber]?
    public let sipAddresses: [SipAddress]?
}

extension UpdateContactInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case contactArn = "ContactArn"
        case displayName = "DisplayName"
        case firstName = "FirstName"
        case lastName = "LastName"
        case phoneNumber = "PhoneNumber"
        case phoneNumbers = "PhoneNumbers"
        case sipAddresses = "SipAddresses"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .contactArn)
        contactArn = contactArnDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let firstNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .firstName)
        firstName = firstNameDecoded
        let lastNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastName)
        lastName = lastNameDecoded
        let phoneNumberDecoded = try containerValues.decodeIfPresent(String.self, forKey: .phoneNumber)
        phoneNumber = phoneNumberDecoded
        let phoneNumbersContainer = try containerValues.decodeIfPresent([PhoneNumber?].self, forKey: .phoneNumbers)
        var phoneNumbersDecoded0:[PhoneNumber]? = nil
        if let phoneNumbersContainer = phoneNumbersContainer {
            phoneNumbersDecoded0 = [PhoneNumber]()
            for structure0 in phoneNumbersContainer {
                if let structure0 = structure0 {
                    phoneNumbersDecoded0?.append(structure0)
                }
            }
        }
        phoneNumbers = phoneNumbersDecoded0
        let sipAddressesContainer = try containerValues.decodeIfPresent([SipAddress?].self, forKey: .sipAddresses)
        var sipAddressesDecoded0:[SipAddress]? = nil
        if let sipAddressesContainer = sipAddressesContainer {
            sipAddressesDecoded0 = [SipAddress]()
            for structure0 in sipAddressesContainer {
                if let structure0 = structure0 {
                    sipAddressesDecoded0?.append(structure0)
                }
            }
        }
        sipAddresses = sipAddressesDecoded0
    }
}

extension UpdateContactOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateContactOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateContactOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateContactOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateContactOutputResponse()"}
}

extension UpdateContactOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateContactOutputResponse: Equatable {

    public init() {}
}

struct UpdateContactOutputResponseBody: Equatable {
}

extension UpdateContactOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateDeviceInputBodyMiddleware: Middleware {
    public let id: String = "UpdateDeviceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDeviceInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDeviceInput>
    public typealias MOutput = OperationOutput<UpdateDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDeviceOutputError>
}

extension UpdateDeviceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateDeviceInput(deviceArn: \(String(describing: deviceArn)), deviceName: \(String(describing: deviceName)))"}
}

extension UpdateDeviceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case deviceArn = "DeviceArn"
        case deviceName = "DeviceName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceArn = deviceArn {
            try encodeContainer.encode(deviceArn, forKey: .deviceArn)
        }
        if let deviceName = deviceName {
            try encodeContainer.encode(deviceName, forKey: .deviceName)
        }
    }
}

public struct UpdateDeviceInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateDeviceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDeviceInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDeviceInput>
    public typealias MOutput = OperationOutput<UpdateDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDeviceOutputError>
}

public struct UpdateDeviceInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateDeviceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDeviceInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDeviceInput>
    public typealias MOutput = OperationOutput<UpdateDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDeviceOutputError>
}

public struct UpdateDeviceInput: Equatable {
    /// <p>The ARN of the device to update. Required.</p>
    public let deviceArn: String?
    /// <p>The updated device name. Required.</p>
    public let deviceName: String?

    public init (
        deviceArn: String? = nil,
        deviceName: String? = nil
    )
    {
        self.deviceArn = deviceArn
        self.deviceName = deviceName
    }
}

struct UpdateDeviceInputBody: Equatable {
    public let deviceArn: String?
    public let deviceName: String?
}

extension UpdateDeviceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case deviceArn = "DeviceArn"
        case deviceName = "DeviceName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deviceArn)
        deviceArn = deviceArnDecoded
        let deviceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deviceName)
        deviceName = deviceNameDecoded
    }
}

extension UpdateDeviceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDeviceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DeviceNotRegisteredException" : self = .deviceNotRegisteredException(try DeviceNotRegisteredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateDeviceOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case deviceNotRegisteredException(DeviceNotRegisteredException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDeviceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateDeviceOutputResponse()"}
}

extension UpdateDeviceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateDeviceOutputResponse: Equatable {

    public init() {}
}

struct UpdateDeviceOutputResponseBody: Equatable {
}

extension UpdateDeviceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension UpdateEndOfMeetingReminder: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case enabled = "Enabled"
        case reminderAtMinutes = "ReminderAtMinutes"
        case reminderType = "ReminderType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enabled = enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let reminderAtMinutes = reminderAtMinutes {
            var reminderAtMinutesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .reminderAtMinutes)
            for endofmeetingreminderminuteslist0 in reminderAtMinutes {
                try reminderAtMinutesContainer.encode(endofmeetingreminderminuteslist0)
            }
        }
        if let reminderType = reminderType {
            try encodeContainer.encode(reminderType.rawValue, forKey: .reminderType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reminderAtMinutesContainer = try containerValues.decodeIfPresent([Int?].self, forKey: .reminderAtMinutes)
        var reminderAtMinutesDecoded0:[Int]? = nil
        if let reminderAtMinutesContainer = reminderAtMinutesContainer {
            reminderAtMinutesDecoded0 = [Int]()
            for integer0 in reminderAtMinutesContainer {
                if let integer0 = integer0 {
                    reminderAtMinutesDecoded0?.append(integer0)
                }
            }
        }
        reminderAtMinutes = reminderAtMinutesDecoded0
        let reminderTypeDecoded = try containerValues.decodeIfPresent(EndOfMeetingReminderType.self, forKey: .reminderType)
        reminderType = reminderTypeDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .enabled)
        enabled = enabledDecoded
    }
}

extension UpdateEndOfMeetingReminder: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateEndOfMeetingReminder(enabled: \(String(describing: enabled)), reminderAtMinutes: \(String(describing: reminderAtMinutes)), reminderType: \(String(describing: reminderType)))"}
}

/// <p>Settings for the end of meeting reminder feature that are applied to a room profile. The
///          end of meeting reminder enables Alexa to remind users when a meeting is ending. </p>
public struct UpdateEndOfMeetingReminder: Equatable {
    /// <p>Whether an end of meeting reminder is enabled or not.</p>
    public let enabled: Bool?
    /// <p>Updates settings for the end of meeting reminder feature that are applied to a room
    ///          profile. The end of meeting reminder enables Alexa to remind users when a meeting is
    ///          ending. </p>
    public let reminderAtMinutes: [Int]?
    /// <p>The type of sound that users hear during the end of meeting reminder. </p>
    public let reminderType: EndOfMeetingReminderType?

    public init (
        enabled: Bool? = nil,
        reminderAtMinutes: [Int]? = nil,
        reminderType: EndOfMeetingReminderType? = nil
    )
    {
        self.enabled = enabled
        self.reminderAtMinutes = reminderAtMinutes
        self.reminderType = reminderType
    }
}

public struct UpdateGatewayGroupInputBodyMiddleware: Middleware {
    public let id: String = "UpdateGatewayGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateGatewayGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateGatewayGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateGatewayGroupInput>
    public typealias MOutput = OperationOutput<UpdateGatewayGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateGatewayGroupOutputError>
}

extension UpdateGatewayGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateGatewayGroupInput(description: \(String(describing: description)), gatewayGroupArn: \(String(describing: gatewayGroupArn)), name: \(String(describing: name)))"}
}

extension UpdateGatewayGroupInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case gatewayGroupArn = "GatewayGroupArn"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let gatewayGroupArn = gatewayGroupArn {
            try encodeContainer.encode(gatewayGroupArn, forKey: .gatewayGroupArn)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct UpdateGatewayGroupInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateGatewayGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateGatewayGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateGatewayGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateGatewayGroupInput>
    public typealias MOutput = OperationOutput<UpdateGatewayGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateGatewayGroupOutputError>
}

public struct UpdateGatewayGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateGatewayGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateGatewayGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateGatewayGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateGatewayGroupInput>
    public typealias MOutput = OperationOutput<UpdateGatewayGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateGatewayGroupOutputError>
}

public struct UpdateGatewayGroupInput: Equatable {
    /// <p>The updated description of the gateway group.</p>
    public let description: String?
    /// <p>The ARN of the gateway group to update.</p>
    public let gatewayGroupArn: String?
    /// <p>The updated name of the gateway group.</p>
    public let name: String?

    public init (
        description: String? = nil,
        gatewayGroupArn: String? = nil,
        name: String? = nil
    )
    {
        self.description = description
        self.gatewayGroupArn = gatewayGroupArn
        self.name = name
    }
}

struct UpdateGatewayGroupInputBody: Equatable {
    public let gatewayGroupArn: String?
    public let name: String?
    public let description: String?
}

extension UpdateGatewayGroupInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case gatewayGroupArn = "GatewayGroupArn"
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayGroupArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayGroupArn)
        gatewayGroupArn = gatewayGroupArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateGatewayGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateGatewayGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NameInUseException" : self = .nameInUseException(try NameInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateGatewayGroupOutputError: Equatable {
    case nameInUseException(NameInUseException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateGatewayGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateGatewayGroupOutputResponse()"}
}

extension UpdateGatewayGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateGatewayGroupOutputResponse: Equatable {

    public init() {}
}

struct UpdateGatewayGroupOutputResponseBody: Equatable {
}

extension UpdateGatewayGroupOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateGatewayInputBodyMiddleware: Middleware {
    public let id: String = "UpdateGatewayInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateGatewayInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateGatewayInput>
    public typealias MOutput = OperationOutput<UpdateGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateGatewayOutputError>
}

extension UpdateGatewayInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateGatewayInput(description: \(String(describing: description)), gatewayArn: \(String(describing: gatewayArn)), name: \(String(describing: name)), softwareVersion: \(String(describing: softwareVersion)))"}
}

extension UpdateGatewayInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case gatewayArn = "GatewayArn"
        case name = "Name"
        case softwareVersion = "SoftwareVersion"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let gatewayArn = gatewayArn {
            try encodeContainer.encode(gatewayArn, forKey: .gatewayArn)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let softwareVersion = softwareVersion {
            try encodeContainer.encode(softwareVersion, forKey: .softwareVersion)
        }
    }
}

public struct UpdateGatewayInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateGatewayInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateGatewayInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateGatewayInput>
    public typealias MOutput = OperationOutput<UpdateGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateGatewayOutputError>
}

public struct UpdateGatewayInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateGatewayInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateGatewayInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateGatewayInput>
    public typealias MOutput = OperationOutput<UpdateGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateGatewayOutputError>
}

public struct UpdateGatewayInput: Equatable {
    /// <p>The updated description of the gateway.</p>
    public let description: String?
    /// <p>The ARN of the gateway to update.</p>
    public let gatewayArn: String?
    /// <p>The updated name of the gateway.</p>
    public let name: String?
    /// <p>The updated software version of the gateway. The gateway automatically updates its
    ///          software version during normal operation.</p>
    public let softwareVersion: String?

    public init (
        description: String? = nil,
        gatewayArn: String? = nil,
        name: String? = nil,
        softwareVersion: String? = nil
    )
    {
        self.description = description
        self.gatewayArn = gatewayArn
        self.name = name
        self.softwareVersion = softwareVersion
    }
}

struct UpdateGatewayInputBody: Equatable {
    public let gatewayArn: String?
    public let name: String?
    public let description: String?
    public let softwareVersion: String?
}

extension UpdateGatewayInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case gatewayArn = "GatewayArn"
        case name = "Name"
        case softwareVersion = "SoftwareVersion"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayArn)
        gatewayArn = gatewayArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let softwareVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .softwareVersion)
        softwareVersion = softwareVersionDecoded
    }
}

extension UpdateGatewayOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateGatewayOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NameInUseException" : self = .nameInUseException(try NameInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateGatewayOutputError: Equatable {
    case nameInUseException(NameInUseException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateGatewayOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateGatewayOutputResponse()"}
}

extension UpdateGatewayOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateGatewayOutputResponse: Equatable {

    public init() {}
}

struct UpdateGatewayOutputResponseBody: Equatable {
}

extension UpdateGatewayOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension UpdateInstantBooking: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case durationInMinutes = "DurationInMinutes"
        case enabled = "Enabled"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let durationInMinutes = durationInMinutes {
            try encodeContainer.encode(durationInMinutes, forKey: .durationInMinutes)
        }
        if let enabled = enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let durationInMinutesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .durationInMinutes)
        durationInMinutes = durationInMinutesDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .enabled)
        enabled = enabledDecoded
    }
}

extension UpdateInstantBooking: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateInstantBooking(durationInMinutes: \(String(describing: durationInMinutes)), enabled: \(String(describing: enabled)))"}
}

/// <p>Updates settings for the instant booking feature that are applied to a room profile. If
///          instant booking is enabled, Alexa automatically reserves a room if it is free when a user
///          joins a meeting with Alexa.</p>
public struct UpdateInstantBooking: Equatable {
    /// <p>Duration between 15 and 240 minutes at increments of 15 that determines how long to book
    ///          an available room when a meeting is started with Alexa.</p>
    public let durationInMinutes: Int?
    /// <p>Whether instant booking is enabled or not.</p>
    public let enabled: Bool?

    public init (
        durationInMinutes: Int? = nil,
        enabled: Bool? = nil
    )
    {
        self.durationInMinutes = durationInMinutes
        self.enabled = enabled
    }
}

extension UpdateMeetingRoomConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case endOfMeetingReminder = "EndOfMeetingReminder"
        case instantBooking = "InstantBooking"
        case requireCheckIn = "RequireCheckIn"
        case roomUtilizationMetricsEnabled = "RoomUtilizationMetricsEnabled"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endOfMeetingReminder = endOfMeetingReminder {
            try encodeContainer.encode(endOfMeetingReminder, forKey: .endOfMeetingReminder)
        }
        if let instantBooking = instantBooking {
            try encodeContainer.encode(instantBooking, forKey: .instantBooking)
        }
        if let requireCheckIn = requireCheckIn {
            try encodeContainer.encode(requireCheckIn, forKey: .requireCheckIn)
        }
        if let roomUtilizationMetricsEnabled = roomUtilizationMetricsEnabled {
            try encodeContainer.encode(roomUtilizationMetricsEnabled, forKey: .roomUtilizationMetricsEnabled)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roomUtilizationMetricsEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .roomUtilizationMetricsEnabled)
        roomUtilizationMetricsEnabled = roomUtilizationMetricsEnabledDecoded
        let endOfMeetingReminderDecoded = try containerValues.decodeIfPresent(UpdateEndOfMeetingReminder.self, forKey: .endOfMeetingReminder)
        endOfMeetingReminder = endOfMeetingReminderDecoded
        let instantBookingDecoded = try containerValues.decodeIfPresent(UpdateInstantBooking.self, forKey: .instantBooking)
        instantBooking = instantBookingDecoded
        let requireCheckInDecoded = try containerValues.decodeIfPresent(UpdateRequireCheckIn.self, forKey: .requireCheckIn)
        requireCheckIn = requireCheckInDecoded
    }
}

extension UpdateMeetingRoomConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateMeetingRoomConfiguration(endOfMeetingReminder: \(String(describing: endOfMeetingReminder)), instantBooking: \(String(describing: instantBooking)), requireCheckIn: \(String(describing: requireCheckIn)), roomUtilizationMetricsEnabled: \(String(describing: roomUtilizationMetricsEnabled)))"}
}

/// <p>Updates meeting room settings of a room profile.</p>
public struct UpdateMeetingRoomConfiguration: Equatable {
    /// <p>Settings for the end of meeting reminder feature that are applied to a room profile. The
    ///          end of meeting reminder enables Alexa to remind users when a meeting is ending. </p>
    public let endOfMeetingReminder: UpdateEndOfMeetingReminder?
    /// <p>Settings to automatically book an available room available for a configured duration
    ///          when joining a meeting with Alexa.</p>
    public let instantBooking: UpdateInstantBooking?
    /// <p>Settings for requiring a check in when a room is reserved. Alexa can cancel a room reservation if it's not checked into to make the room available for others. Users can check in by joining the meeting with Alexa or an AVS device, or by saying Alexa, check in. </p>
    public let requireCheckIn: UpdateRequireCheckIn?
    /// <p>Whether room utilization metrics are enabled or not.</p>
    public let roomUtilizationMetricsEnabled: Bool?

    public init (
        endOfMeetingReminder: UpdateEndOfMeetingReminder? = nil,
        instantBooking: UpdateInstantBooking? = nil,
        requireCheckIn: UpdateRequireCheckIn? = nil,
        roomUtilizationMetricsEnabled: Bool? = nil
    )
    {
        self.endOfMeetingReminder = endOfMeetingReminder
        self.instantBooking = instantBooking
        self.requireCheckIn = requireCheckIn
        self.roomUtilizationMetricsEnabled = roomUtilizationMetricsEnabled
    }
}

public struct UpdateNetworkProfileInputBodyMiddleware: Middleware {
    public let id: String = "UpdateNetworkProfileInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateNetworkProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateNetworkProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateNetworkProfileInput>
    public typealias MOutput = OperationOutput<UpdateNetworkProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateNetworkProfileOutputError>
}

extension UpdateNetworkProfileInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateNetworkProfileInput(certificateAuthorityArn: \(String(describing: certificateAuthorityArn)), currentPassword: \(String(describing: currentPassword)), description: \(String(describing: description)), networkProfileArn: \(String(describing: networkProfileArn)), networkProfileName: \(String(describing: networkProfileName)), nextPassword: \(String(describing: nextPassword)), trustAnchors: \(String(describing: trustAnchors)))"}
}

extension UpdateNetworkProfileInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case certificateAuthorityArn = "CertificateAuthorityArn"
        case currentPassword = "CurrentPassword"
        case description = "Description"
        case networkProfileArn = "NetworkProfileArn"
        case networkProfileName = "NetworkProfileName"
        case nextPassword = "NextPassword"
        case trustAnchors = "TrustAnchors"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateAuthorityArn = certificateAuthorityArn {
            try encodeContainer.encode(certificateAuthorityArn, forKey: .certificateAuthorityArn)
        }
        if let currentPassword = currentPassword {
            try encodeContainer.encode(currentPassword, forKey: .currentPassword)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let networkProfileArn = networkProfileArn {
            try encodeContainer.encode(networkProfileArn, forKey: .networkProfileArn)
        }
        if let networkProfileName = networkProfileName {
            try encodeContainer.encode(networkProfileName, forKey: .networkProfileName)
        }
        if let nextPassword = nextPassword {
            try encodeContainer.encode(nextPassword, forKey: .nextPassword)
        }
        if let trustAnchors = trustAnchors {
            var trustAnchorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .trustAnchors)
            for trustanchorlist0 in trustAnchors {
                try trustAnchorsContainer.encode(trustanchorlist0)
            }
        }
    }
}

public struct UpdateNetworkProfileInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateNetworkProfileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateNetworkProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateNetworkProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateNetworkProfileInput>
    public typealias MOutput = OperationOutput<UpdateNetworkProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateNetworkProfileOutputError>
}

public struct UpdateNetworkProfileInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateNetworkProfileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateNetworkProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateNetworkProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateNetworkProfileInput>
    public typealias MOutput = OperationOutput<UpdateNetworkProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateNetworkProfileOutputError>
}

public struct UpdateNetworkProfileInput: Equatable {
    /// <p>The ARN of the Private Certificate Authority (PCA) created in AWS Certificate Manager
    ///          (ACM). This is used to issue certificates to the devices. </p>
    public let certificateAuthorityArn: String?
    /// <p>The current password of the Wi-Fi network.</p>
    public let currentPassword: String?
    /// <p>Detailed information about a device's network profile.</p>
    public let description: String?
    /// <p>The ARN of the network profile associated with a device.</p>
    public let networkProfileArn: String?
    /// <p>The name of the network profile associated with a device.</p>
    public let networkProfileName: String?
    /// <p>The next, or subsequent, password of the Wi-Fi network. This password is asynchronously
    ///          transmitted to the device and is used when the password of the network changes to
    ///          NextPassword. </p>
    public let nextPassword: String?
    /// <p>The root certificate(s) of your authentication server that will be installed on your
    ///          devices and used to trust your authentication server during EAP negotiation. </p>
    public let trustAnchors: [String]?

    public init (
        certificateAuthorityArn: String? = nil,
        currentPassword: String? = nil,
        description: String? = nil,
        networkProfileArn: String? = nil,
        networkProfileName: String? = nil,
        nextPassword: String? = nil,
        trustAnchors: [String]? = nil
    )
    {
        self.certificateAuthorityArn = certificateAuthorityArn
        self.currentPassword = currentPassword
        self.description = description
        self.networkProfileArn = networkProfileArn
        self.networkProfileName = networkProfileName
        self.nextPassword = nextPassword
        self.trustAnchors = trustAnchors
    }
}

struct UpdateNetworkProfileInputBody: Equatable {
    public let networkProfileArn: String?
    public let networkProfileName: String?
    public let description: String?
    public let currentPassword: String?
    public let nextPassword: String?
    public let certificateAuthorityArn: String?
    public let trustAnchors: [String]?
}

extension UpdateNetworkProfileInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case certificateAuthorityArn = "CertificateAuthorityArn"
        case currentPassword = "CurrentPassword"
        case description = "Description"
        case networkProfileArn = "NetworkProfileArn"
        case networkProfileName = "NetworkProfileName"
        case nextPassword = "NextPassword"
        case trustAnchors = "TrustAnchors"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkProfileArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .networkProfileArn)
        networkProfileArn = networkProfileArnDecoded
        let networkProfileNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .networkProfileName)
        networkProfileName = networkProfileNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let currentPasswordDecoded = try containerValues.decodeIfPresent(String.self, forKey: .currentPassword)
        currentPassword = currentPasswordDecoded
        let nextPasswordDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextPassword)
        nextPassword = nextPasswordDecoded
        let certificateAuthorityArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificateAuthorityArn)
        certificateAuthorityArn = certificateAuthorityArnDecoded
        let trustAnchorsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .trustAnchors)
        var trustAnchorsDecoded0:[String]? = nil
        if let trustAnchorsContainer = trustAnchorsContainer {
            trustAnchorsDecoded0 = [String]()
            for string0 in trustAnchorsContainer {
                if let string0 = string0 {
                    trustAnchorsDecoded0?.append(string0)
                }
            }
        }
        trustAnchors = trustAnchorsDecoded0
    }
}

extension UpdateNetworkProfileOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateNetworkProfileOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidCertificateAuthorityException" : self = .invalidCertificateAuthorityException(try InvalidCertificateAuthorityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSecretsManagerResourceException" : self = .invalidSecretsManagerResourceException(try InvalidSecretsManagerResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NameInUseException" : self = .nameInUseException(try NameInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateNetworkProfileOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidCertificateAuthorityException(InvalidCertificateAuthorityException)
    case invalidSecretsManagerResourceException(InvalidSecretsManagerResourceException)
    case nameInUseException(NameInUseException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateNetworkProfileOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateNetworkProfileOutputResponse()"}
}

extension UpdateNetworkProfileOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateNetworkProfileOutputResponse: Equatable {

    public init() {}
}

struct UpdateNetworkProfileOutputResponseBody: Equatable {
}

extension UpdateNetworkProfileOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateProfileInputBodyMiddleware: Middleware {
    public let id: String = "UpdateProfileInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateProfileInput>
    public typealias MOutput = OperationOutput<UpdateProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateProfileOutputError>
}

extension UpdateProfileInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateProfileInput(address: \(String(describing: address)), dataRetentionOptIn: \(String(describing: dataRetentionOptIn)), distanceUnit: \(String(describing: distanceUnit)), isDefault: \(String(describing: isDefault)), locale: \(String(describing: locale)), maxVolumeLimit: \(String(describing: maxVolumeLimit)), meetingRoomConfiguration: \(String(describing: meetingRoomConfiguration)), pSTNEnabled: \(String(describing: pSTNEnabled)), profileArn: \(String(describing: profileArn)), profileName: \(String(describing: profileName)), setupModeDisabled: \(String(describing: setupModeDisabled)), temperatureUnit: \(String(describing: temperatureUnit)), timezone: \(String(describing: timezone)), wakeWord: \(String(describing: wakeWord)))"}
}

extension UpdateProfileInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case address = "Address"
        case dataRetentionOptIn = "DataRetentionOptIn"
        case distanceUnit = "DistanceUnit"
        case isDefault = "IsDefault"
        case locale = "Locale"
        case maxVolumeLimit = "MaxVolumeLimit"
        case meetingRoomConfiguration = "MeetingRoomConfiguration"
        case pSTNEnabled = "PSTNEnabled"
        case profileArn = "ProfileArn"
        case profileName = "ProfileName"
        case setupModeDisabled = "SetupModeDisabled"
        case temperatureUnit = "TemperatureUnit"
        case timezone = "Timezone"
        case wakeWord = "WakeWord"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let address = address {
            try encodeContainer.encode(address, forKey: .address)
        }
        if let dataRetentionOptIn = dataRetentionOptIn {
            try encodeContainer.encode(dataRetentionOptIn, forKey: .dataRetentionOptIn)
        }
        if let distanceUnit = distanceUnit {
            try encodeContainer.encode(distanceUnit.rawValue, forKey: .distanceUnit)
        }
        if let isDefault = isDefault {
            try encodeContainer.encode(isDefault, forKey: .isDefault)
        }
        if let locale = locale {
            try encodeContainer.encode(locale, forKey: .locale)
        }
        if let maxVolumeLimit = maxVolumeLimit {
            try encodeContainer.encode(maxVolumeLimit, forKey: .maxVolumeLimit)
        }
        if let meetingRoomConfiguration = meetingRoomConfiguration {
            try encodeContainer.encode(meetingRoomConfiguration, forKey: .meetingRoomConfiguration)
        }
        if let pSTNEnabled = pSTNEnabled {
            try encodeContainer.encode(pSTNEnabled, forKey: .pSTNEnabled)
        }
        if let profileArn = profileArn {
            try encodeContainer.encode(profileArn, forKey: .profileArn)
        }
        if let profileName = profileName {
            try encodeContainer.encode(profileName, forKey: .profileName)
        }
        if let setupModeDisabled = setupModeDisabled {
            try encodeContainer.encode(setupModeDisabled, forKey: .setupModeDisabled)
        }
        if let temperatureUnit = temperatureUnit {
            try encodeContainer.encode(temperatureUnit.rawValue, forKey: .temperatureUnit)
        }
        if let timezone = timezone {
            try encodeContainer.encode(timezone, forKey: .timezone)
        }
        if let wakeWord = wakeWord {
            try encodeContainer.encode(wakeWord.rawValue, forKey: .wakeWord)
        }
    }
}

public struct UpdateProfileInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateProfileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateProfileInput>
    public typealias MOutput = OperationOutput<UpdateProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateProfileOutputError>
}

public struct UpdateProfileInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateProfileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateProfileInput>
    public typealias MOutput = OperationOutput<UpdateProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateProfileOutputError>
}

public struct UpdateProfileInput: Equatable {
    /// <p>The updated address for the room profile.</p>
    public let address: String?
    /// <p>Whether data retention of the profile is enabled.</p>
    public let dataRetentionOptIn: Bool?
    /// <p>The updated distance unit for the room profile.</p>
    public let distanceUnit: DistanceUnit?
    /// <p>Sets the profile as default if selected. If this is missing, no update is done to the
    ///          default status.</p>
    public let isDefault: Bool?
    /// <p>The updated locale for the room profile. (This is currently only available to a limited preview audience.)</p>
    public let locale: String?
    /// <p>The updated maximum volume limit for the room profile.</p>
    public let maxVolumeLimit: Int?
    /// <p>The updated meeting room settings of a room profile.</p>
    public let meetingRoomConfiguration: UpdateMeetingRoomConfiguration?
    /// <p>Whether the PSTN setting of the room profile is enabled.</p>
    public let pSTNEnabled: Bool?
    /// <p>The ARN of the room profile to update. Required.</p>
    public let profileArn: String?
    /// <p>The updated name for the room profile.</p>
    public let profileName: String?
    /// <p>Whether the setup mode of the profile is enabled.</p>
    public let setupModeDisabled: Bool?
    /// <p>The updated temperature unit for the room profile.</p>
    public let temperatureUnit: TemperatureUnit?
    /// <p>The updated timezone for the room profile.</p>
    public let timezone: String?
    /// <p>The updated wake word for the room profile.</p>
    public let wakeWord: WakeWord?

    public init (
        address: String? = nil,
        dataRetentionOptIn: Bool? = nil,
        distanceUnit: DistanceUnit? = nil,
        isDefault: Bool? = nil,
        locale: String? = nil,
        maxVolumeLimit: Int? = nil,
        meetingRoomConfiguration: UpdateMeetingRoomConfiguration? = nil,
        pSTNEnabled: Bool? = nil,
        profileArn: String? = nil,
        profileName: String? = nil,
        setupModeDisabled: Bool? = nil,
        temperatureUnit: TemperatureUnit? = nil,
        timezone: String? = nil,
        wakeWord: WakeWord? = nil
    )
    {
        self.address = address
        self.dataRetentionOptIn = dataRetentionOptIn
        self.distanceUnit = distanceUnit
        self.isDefault = isDefault
        self.locale = locale
        self.maxVolumeLimit = maxVolumeLimit
        self.meetingRoomConfiguration = meetingRoomConfiguration
        self.pSTNEnabled = pSTNEnabled
        self.profileArn = profileArn
        self.profileName = profileName
        self.setupModeDisabled = setupModeDisabled
        self.temperatureUnit = temperatureUnit
        self.timezone = timezone
        self.wakeWord = wakeWord
    }
}

struct UpdateProfileInputBody: Equatable {
    public let profileArn: String?
    public let profileName: String?
    public let isDefault: Bool?
    public let timezone: String?
    public let address: String?
    public let distanceUnit: DistanceUnit?
    public let temperatureUnit: TemperatureUnit?
    public let wakeWord: WakeWord?
    public let locale: String?
    public let setupModeDisabled: Bool?
    public let maxVolumeLimit: Int?
    public let pSTNEnabled: Bool?
    public let dataRetentionOptIn: Bool?
    public let meetingRoomConfiguration: UpdateMeetingRoomConfiguration?
}

extension UpdateProfileInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case address = "Address"
        case dataRetentionOptIn = "DataRetentionOptIn"
        case distanceUnit = "DistanceUnit"
        case isDefault = "IsDefault"
        case locale = "Locale"
        case maxVolumeLimit = "MaxVolumeLimit"
        case meetingRoomConfiguration = "MeetingRoomConfiguration"
        case pSTNEnabled = "PSTNEnabled"
        case profileArn = "ProfileArn"
        case profileName = "ProfileName"
        case setupModeDisabled = "SetupModeDisabled"
        case temperatureUnit = "TemperatureUnit"
        case timezone = "Timezone"
        case wakeWord = "WakeWord"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profileArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .profileArn)
        profileArn = profileArnDecoded
        let profileNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .profileName)
        profileName = profileNameDecoded
        let isDefaultDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .isDefault)
        isDefault = isDefaultDecoded
        let timezoneDecoded = try containerValues.decodeIfPresent(String.self, forKey: .timezone)
        timezone = timezoneDecoded
        let addressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .address)
        address = addressDecoded
        let distanceUnitDecoded = try containerValues.decodeIfPresent(DistanceUnit.self, forKey: .distanceUnit)
        distanceUnit = distanceUnitDecoded
        let temperatureUnitDecoded = try containerValues.decodeIfPresent(TemperatureUnit.self, forKey: .temperatureUnit)
        temperatureUnit = temperatureUnitDecoded
        let wakeWordDecoded = try containerValues.decodeIfPresent(WakeWord.self, forKey: .wakeWord)
        wakeWord = wakeWordDecoded
        let localeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .locale)
        locale = localeDecoded
        let setupModeDisabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .setupModeDisabled)
        setupModeDisabled = setupModeDisabledDecoded
        let maxVolumeLimitDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxVolumeLimit)
        maxVolumeLimit = maxVolumeLimitDecoded
        let pSTNEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .pSTNEnabled)
        pSTNEnabled = pSTNEnabledDecoded
        let dataRetentionOptInDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .dataRetentionOptIn)
        dataRetentionOptIn = dataRetentionOptInDecoded
        let meetingRoomConfigurationDecoded = try containerValues.decodeIfPresent(UpdateMeetingRoomConfiguration.self, forKey: .meetingRoomConfiguration)
        meetingRoomConfiguration = meetingRoomConfigurationDecoded
    }
}

extension UpdateProfileOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateProfileOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NameInUseException" : self = .nameInUseException(try NameInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateProfileOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case nameInUseException(NameInUseException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateProfileOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateProfileOutputResponse()"}
}

extension UpdateProfileOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateProfileOutputResponse: Equatable {

    public init() {}
}

struct UpdateProfileOutputResponseBody: Equatable {
}

extension UpdateProfileOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension UpdateRequireCheckIn: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case enabled = "Enabled"
        case releaseAfterMinutes = "ReleaseAfterMinutes"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enabled = enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let releaseAfterMinutes = releaseAfterMinutes {
            try encodeContainer.encode(releaseAfterMinutes, forKey: .releaseAfterMinutes)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let releaseAfterMinutesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .releaseAfterMinutes)
        releaseAfterMinutes = releaseAfterMinutesDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .enabled)
        enabled = enabledDecoded
    }
}

extension UpdateRequireCheckIn: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateRequireCheckIn(enabled: \(String(describing: enabled)), releaseAfterMinutes: \(String(describing: releaseAfterMinutes)))"}
}

/// <p>Updates settings for the require check in feature that are applied to a room profile. Require check in allows a meeting rooms Alexa or AVS device to prompt the user to check in; otherwise, the room will be released. </p>
public struct UpdateRequireCheckIn: Equatable {
    /// <p>Whether require check in is enabled or not.</p>
    public let enabled: Bool?
    /// <p>Duration between 5 and 20 minutes to determine when to release the room if it's not checked into. </p>
    public let releaseAfterMinutes: Int?

    public init (
        enabled: Bool? = nil,
        releaseAfterMinutes: Int? = nil
    )
    {
        self.enabled = enabled
        self.releaseAfterMinutes = releaseAfterMinutes
    }
}

public struct UpdateRoomInputBodyMiddleware: Middleware {
    public let id: String = "UpdateRoomInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateRoomInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateRoomOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateRoomInput>
    public typealias MOutput = OperationOutput<UpdateRoomOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateRoomOutputError>
}

extension UpdateRoomInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateRoomInput(description: \(String(describing: description)), profileArn: \(String(describing: profileArn)), providerCalendarId: \(String(describing: providerCalendarId)), roomArn: \(String(describing: roomArn)), roomName: \(String(describing: roomName)))"}
}

extension UpdateRoomInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case profileArn = "ProfileArn"
        case providerCalendarId = "ProviderCalendarId"
        case roomArn = "RoomArn"
        case roomName = "RoomName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let profileArn = profileArn {
            try encodeContainer.encode(profileArn, forKey: .profileArn)
        }
        if let providerCalendarId = providerCalendarId {
            try encodeContainer.encode(providerCalendarId, forKey: .providerCalendarId)
        }
        if let roomArn = roomArn {
            try encodeContainer.encode(roomArn, forKey: .roomArn)
        }
        if let roomName = roomName {
            try encodeContainer.encode(roomName, forKey: .roomName)
        }
    }
}

public struct UpdateRoomInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateRoomInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateRoomInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateRoomOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateRoomInput>
    public typealias MOutput = OperationOutput<UpdateRoomOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateRoomOutputError>
}

public struct UpdateRoomInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateRoomInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateRoomInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateRoomOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateRoomInput>
    public typealias MOutput = OperationOutput<UpdateRoomOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateRoomOutputError>
}

public struct UpdateRoomInput: Equatable {
    /// <p>The updated description for the room.</p>
    public let description: String?
    /// <p>The updated profile ARN for the room.</p>
    public let profileArn: String?
    /// <p>The updated provider calendar ARN for the room.</p>
    public let providerCalendarId: String?
    /// <p>The ARN of the room to update. </p>
    public let roomArn: String?
    /// <p>The updated name for the room.</p>
    public let roomName: String?

    public init (
        description: String? = nil,
        profileArn: String? = nil,
        providerCalendarId: String? = nil,
        roomArn: String? = nil,
        roomName: String? = nil
    )
    {
        self.description = description
        self.profileArn = profileArn
        self.providerCalendarId = providerCalendarId
        self.roomArn = roomArn
        self.roomName = roomName
    }
}

struct UpdateRoomInputBody: Equatable {
    public let roomArn: String?
    public let roomName: String?
    public let description: String?
    public let providerCalendarId: String?
    public let profileArn: String?
}

extension UpdateRoomInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case profileArn = "ProfileArn"
        case providerCalendarId = "ProviderCalendarId"
        case roomArn = "RoomArn"
        case roomName = "RoomName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roomArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roomArn)
        roomArn = roomArnDecoded
        let roomNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roomName)
        roomName = roomNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let providerCalendarIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .providerCalendarId)
        providerCalendarId = providerCalendarIdDecoded
        let profileArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .profileArn)
        profileArn = profileArnDecoded
    }
}

extension UpdateRoomOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateRoomOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NameInUseException" : self = .nameInUseException(try NameInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateRoomOutputError: Equatable {
    case nameInUseException(NameInUseException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateRoomOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateRoomOutputResponse()"}
}

extension UpdateRoomOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateRoomOutputResponse: Equatable {

    public init() {}
}

struct UpdateRoomOutputResponseBody: Equatable {
}

extension UpdateRoomOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateSkillGroupInputBodyMiddleware: Middleware {
    public let id: String = "UpdateSkillGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateSkillGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateSkillGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateSkillGroupInput>
    public typealias MOutput = OperationOutput<UpdateSkillGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateSkillGroupOutputError>
}

extension UpdateSkillGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateSkillGroupInput(description: \(String(describing: description)), skillGroupArn: \(String(describing: skillGroupArn)), skillGroupName: \(String(describing: skillGroupName)))"}
}

extension UpdateSkillGroupInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case skillGroupArn = "SkillGroupArn"
        case skillGroupName = "SkillGroupName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let skillGroupArn = skillGroupArn {
            try encodeContainer.encode(skillGroupArn, forKey: .skillGroupArn)
        }
        if let skillGroupName = skillGroupName {
            try encodeContainer.encode(skillGroupName, forKey: .skillGroupName)
        }
    }
}

public struct UpdateSkillGroupInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateSkillGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateSkillGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateSkillGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateSkillGroupInput>
    public typealias MOutput = OperationOutput<UpdateSkillGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateSkillGroupOutputError>
}

public struct UpdateSkillGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateSkillGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateSkillGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateSkillGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateSkillGroupInput>
    public typealias MOutput = OperationOutput<UpdateSkillGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateSkillGroupOutputError>
}

public struct UpdateSkillGroupInput: Equatable {
    /// <p>The updated description for the skill group.</p>
    public let description: String?
    /// <p>The ARN of the skill group to update. </p>
    public let skillGroupArn: String?
    /// <p>The updated name for the skill group.</p>
    public let skillGroupName: String?

    public init (
        description: String? = nil,
        skillGroupArn: String? = nil,
        skillGroupName: String? = nil
    )
    {
        self.description = description
        self.skillGroupArn = skillGroupArn
        self.skillGroupName = skillGroupName
    }
}

struct UpdateSkillGroupInputBody: Equatable {
    public let skillGroupArn: String?
    public let skillGroupName: String?
    public let description: String?
}

extension UpdateSkillGroupInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case skillGroupArn = "SkillGroupArn"
        case skillGroupName = "SkillGroupName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let skillGroupArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .skillGroupArn)
        skillGroupArn = skillGroupArnDecoded
        let skillGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .skillGroupName)
        skillGroupName = skillGroupNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateSkillGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateSkillGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NameInUseException" : self = .nameInUseException(try NameInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateSkillGroupOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case nameInUseException(NameInUseException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateSkillGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateSkillGroupOutputResponse()"}
}

extension UpdateSkillGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateSkillGroupOutputResponse: Equatable {

    public init() {}
}

struct UpdateSkillGroupOutputResponseBody: Equatable {
}

extension UpdateSkillGroupOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension UserData: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case email = "Email"
        case enrollmentId = "EnrollmentId"
        case enrollmentStatus = "EnrollmentStatus"
        case firstName = "FirstName"
        case lastName = "LastName"
        case userArn = "UserArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let email = email {
            try encodeContainer.encode(email, forKey: .email)
        }
        if let enrollmentId = enrollmentId {
            try encodeContainer.encode(enrollmentId, forKey: .enrollmentId)
        }
        if let enrollmentStatus = enrollmentStatus {
            try encodeContainer.encode(enrollmentStatus.rawValue, forKey: .enrollmentStatus)
        }
        if let firstName = firstName {
            try encodeContainer.encode(firstName, forKey: .firstName)
        }
        if let lastName = lastName {
            try encodeContainer.encode(lastName, forKey: .lastName)
        }
        if let userArn = userArn {
            try encodeContainer.encode(userArn, forKey: .userArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userArn)
        userArn = userArnDecoded
        let firstNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .firstName)
        firstName = firstNameDecoded
        let lastNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastName)
        lastName = lastNameDecoded
        let emailDecoded = try containerValues.decodeIfPresent(String.self, forKey: .email)
        email = emailDecoded
        let enrollmentStatusDecoded = try containerValues.decodeIfPresent(EnrollmentStatus.self, forKey: .enrollmentStatus)
        enrollmentStatus = enrollmentStatusDecoded
        let enrollmentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .enrollmentId)
        enrollmentId = enrollmentIdDecoded
    }
}

extension UserData: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UserData(email: \(String(describing: email)), enrollmentId: \(String(describing: enrollmentId)), enrollmentStatus: \(String(describing: enrollmentStatus)), firstName: \(String(describing: firstName)), lastName: \(String(describing: lastName)), userArn: \(String(describing: userArn)))"}
}

/// <p>Information related to a user.</p>
public struct UserData: Equatable {
    /// <p>The email of a user.</p>
    public let email: String?
    /// <p>The enrollment ARN of a user.</p>
    public let enrollmentId: String?
    /// <p>The enrollment status of a user.</p>
    public let enrollmentStatus: EnrollmentStatus?
    /// <p>The first name of a user.</p>
    public let firstName: String?
    /// <p>The last name of a user.</p>
    public let lastName: String?
    /// <p>The ARN of a user.</p>
    public let userArn: String?

    public init (
        email: String? = nil,
        enrollmentId: String? = nil,
        enrollmentStatus: EnrollmentStatus? = nil,
        firstName: String? = nil,
        lastName: String? = nil,
        userArn: String? = nil
    )
    {
        self.email = email
        self.enrollmentId = enrollmentId
        self.enrollmentStatus = enrollmentStatus
        self.firstName = firstName
        self.lastName = lastName
        self.userArn = userArn
    }
}

public enum WakeWord {
    case alexa
    case amazon
    case computer
    case echo
    case sdkUnknown(String)
}

extension WakeWord : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [WakeWord] {
        return [
            .alexa,
            .amazon,
            .computer,
            .echo,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .alexa: return "ALEXA"
        case .amazon: return "AMAZON"
        case .computer: return "COMPUTER"
        case .echo: return "ECHO"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = WakeWord(rawValue: rawValue) ?? WakeWord.sdkUnknown(rawValue)
    }
}
