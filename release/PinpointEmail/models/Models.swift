// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccountSuspendedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccountSuspendedException(message: \(String(describing: message)))"}
}

extension AccountSuspendedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AccountSuspendedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The message can't be sent because the account's ability to send email has been
///             permanently restricted.</p>
public struct AccountSuspendedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct AccountSuspendedExceptionBody: Equatable {
    public let message: String?
}

extension AccountSuspendedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AlreadyExistsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AlreadyExistsException(message: \(String(describing: message)))"}
}

extension AlreadyExistsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The resource specified in your request already exists.</p>
public struct AlreadyExistsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct AlreadyExistsExceptionBody: Equatable {
    public let message: String?
}

extension AlreadyExistsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BadRequestException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BadRequestException(message: \(String(describing: message)))"}
}

extension BadRequestException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BadRequestExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The input you provided is invalid.</p>
public struct BadRequestException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct BadRequestExceptionBody: Equatable {
    public let message: String?
}

extension BadRequestExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

/// <p>The action that you want Amazon Pinpoint to take if it can't read the required MX record for a
///             custom MAIL FROM domain. When you set this value to <code>UseDefaultValue</code>, Amazon Pinpoint
///             uses <i>amazonses.com</i> as the MAIL FROM domain. When you set this value
///             to <code>RejectMessage</code>, Amazon Pinpoint returns a <code>MailFromDomainNotVerified</code>
///             error, and doesn't attempt to deliver the email.</p>
///         <p>These behaviors are taken when the custom MAIL FROM domain configuration is in the
///                 <code>Pending</code>, <code>Failed</code>, and <code>TemporaryFailure</code>
///             states.</p>
public enum BehaviorOnMxFailure {
    case rejectMessage
    case useDefaultValue
    case sdkUnknown(String)
}

extension BehaviorOnMxFailure : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [BehaviorOnMxFailure] {
        return [
            .rejectMessage,
            .useDefaultValue,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .rejectMessage: return "REJECT_MESSAGE"
        case .useDefaultValue: return "USE_DEFAULT_VALUE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = BehaviorOnMxFailure(rawValue: rawValue) ?? BehaviorOnMxFailure.sdkUnknown(rawValue)
    }
}

extension BlacklistEntry: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case listingTime = "ListingTime"
        case rblName = "RblName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let listingTime = listingTime {
            try encodeContainer.encode(listingTime.timeIntervalSince1970, forKey: .listingTime)
        }
        if let rblName = rblName {
            try encodeContainer.encode(rblName, forKey: .rblName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rblNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .rblName)
        rblName = rblNameDecoded
        let listingTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .listingTime)
        listingTime = listingTimeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension BlacklistEntry: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BlacklistEntry(description: \(String(describing: description)), listingTime: \(String(describing: listingTime)), rblName: \(String(describing: rblName)))"}
}

/// <p>An object that contains information about a blacklisting event that impacts one of the
///             dedicated IP addresses that is associated with your account.</p>
public struct BlacklistEntry: Equatable {
    /// <p>Additional information about the blacklisting event, as provided by the blacklist
    ///             maintainer.</p>
    public let description: String?
    /// <p>The time when the blacklisting event occurred, shown in Unix time format.</p>
    public let listingTime: Date?
    /// <p>The name of the blacklist that the IP address appears on.</p>
    public let rblName: String?

    public init (
        description: String? = nil,
        listingTime: Date? = nil,
        rblName: String? = nil
    )
    {
        self.description = description
        self.listingTime = listingTime
        self.rblName = rblName
    }
}

extension Body: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case html = "Html"
        case text = "Text"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let html = html {
            try encodeContainer.encode(html, forKey: .html)
        }
        if let text = text {
            try encodeContainer.encode(text, forKey: .text)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textDecoded = try containerValues.decodeIfPresent(Content.self, forKey: .text)
        text = textDecoded
        let htmlDecoded = try containerValues.decodeIfPresent(Content.self, forKey: .html)
        html = htmlDecoded
    }
}

extension Body: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Body(html: \(String(describing: html)), text: \(String(describing: text)))"}
}

/// <p>Represents the body of the email message.</p>
public struct Body: Equatable {
    /// <p>An object that represents the version of the message that is displayed in email
    ///             clients that support HTML. HTML messages can include formatted text, hyperlinks, images,
    ///             and more. </p>
    public let html: Content?
    /// <p>An object that represents the version of the message that is displayed in email
    ///             clients that don't support HTML, or clients where the recipient has disabled HTML
    ///             rendering.</p>
    public let text: Content?

    public init (
        html: Content? = nil,
        text: Content? = nil
    )
    {
        self.html = html
        self.text = text
    }
}

extension CloudWatchDestination: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dimensionConfigurations = "DimensionConfigurations"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dimensionConfigurations = dimensionConfigurations {
            var dimensionConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dimensionConfigurations)
            for cloudwatchdimensionconfigurations0 in dimensionConfigurations {
                try dimensionConfigurationsContainer.encode(cloudwatchdimensionconfigurations0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dimensionConfigurationsContainer = try containerValues.decodeIfPresent([CloudWatchDimensionConfiguration?].self, forKey: .dimensionConfigurations)
        var dimensionConfigurationsDecoded0:[CloudWatchDimensionConfiguration]? = nil
        if let dimensionConfigurationsContainer = dimensionConfigurationsContainer {
            dimensionConfigurationsDecoded0 = [CloudWatchDimensionConfiguration]()
            for structure0 in dimensionConfigurationsContainer {
                if let structure0 = structure0 {
                    dimensionConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        dimensionConfigurations = dimensionConfigurationsDecoded0
    }
}

extension CloudWatchDestination: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CloudWatchDestination(dimensionConfigurations: \(String(describing: dimensionConfigurations)))"}
}

/// <p>An object that defines an Amazon CloudWatch destination for email events. You can use Amazon CloudWatch to
///             monitor and gain insights on your email sending metrics.</p>
public struct CloudWatchDestination: Equatable {
    /// <p>An array of objects that define the dimensions to use when you send email events to
    ///             Amazon CloudWatch.</p>
    public let dimensionConfigurations: [CloudWatchDimensionConfiguration]?

    public init (
        dimensionConfigurations: [CloudWatchDimensionConfiguration]? = nil
    )
    {
        self.dimensionConfigurations = dimensionConfigurations
    }
}

extension CloudWatchDimensionConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case defaultDimensionValue = "DefaultDimensionValue"
        case dimensionName = "DimensionName"
        case dimensionValueSource = "DimensionValueSource"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultDimensionValue = defaultDimensionValue {
            try encodeContainer.encode(defaultDimensionValue, forKey: .defaultDimensionValue)
        }
        if let dimensionName = dimensionName {
            try encodeContainer.encode(dimensionName, forKey: .dimensionName)
        }
        if let dimensionValueSource = dimensionValueSource {
            try encodeContainer.encode(dimensionValueSource.rawValue, forKey: .dimensionValueSource)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dimensionNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dimensionName)
        dimensionName = dimensionNameDecoded
        let dimensionValueSourceDecoded = try containerValues.decodeIfPresent(DimensionValueSource.self, forKey: .dimensionValueSource)
        dimensionValueSource = dimensionValueSourceDecoded
        let defaultDimensionValueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .defaultDimensionValue)
        defaultDimensionValue = defaultDimensionValueDecoded
    }
}

extension CloudWatchDimensionConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CloudWatchDimensionConfiguration(defaultDimensionValue: \(String(describing: defaultDimensionValue)), dimensionName: \(String(describing: dimensionName)), dimensionValueSource: \(String(describing: dimensionValueSource)))"}
}

/// <p>An object that defines the dimension configuration to use when you send Amazon Pinpoint email
///             events to Amazon CloudWatch.</p>
public struct CloudWatchDimensionConfiguration: Equatable {
    /// <p>The default value of the dimension that is published to Amazon CloudWatch if you don't provide the
    ///             value of the dimension when you send an email. This value has to meet the following
    ///             criteria:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>It can only contain ASCII letters (a-z, A-Z), numbers (0-9), underscores (_),
    ///                     or dashes (-).</p>
    ///             </li>
    ///             <li>
    ///                 <p>It can contain no more than 256 characters.</p>
    ///             </li>
    ///          </ul>
    public let defaultDimensionValue: String?
    /// <p>The name of an Amazon CloudWatch dimension associated with an email sending metric. The name has to
    ///             meet the following criteria:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>It can only contain ASCII letters (a-z, A-Z), numbers (0-9), underscores (_),
    ///                     or dashes (-).</p>
    ///             </li>
    ///             <li>
    ///                 <p>It can contain no more than 256 characters.</p>
    ///             </li>
    ///          </ul>
    public let dimensionName: String?
    /// <p>The location where Amazon Pinpoint finds the value of a dimension to publish to Amazon CloudWatch. If you
    ///             want Amazon Pinpoint to use the message tags that you specify using an X-SES-MESSAGE-TAGS header
    ///             or a parameter to the SendEmail/SendRawEmail API, choose <code>messageTag</code>. If you
    ///             want Amazon Pinpoint to use your own email headers, choose <code>emailHeader</code>. If you want
    ///             Amazon Pinpoint to use link tags, choose <code>linkTags</code>.</p>
    public let dimensionValueSource: DimensionValueSource?

    public init (
        defaultDimensionValue: String? = nil,
        dimensionName: String? = nil,
        dimensionValueSource: DimensionValueSource? = nil
    )
    {
        self.defaultDimensionValue = defaultDimensionValue
        self.dimensionName = dimensionName
        self.dimensionValueSource = dimensionValueSource
    }
}

extension ConcurrentModificationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConcurrentModificationException(message: \(String(describing: message)))"}
}

extension ConcurrentModificationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ConcurrentModificationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The resource is being modified by another operation or thread.</p>
public struct ConcurrentModificationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ConcurrentModificationExceptionBody: Equatable {
    public let message: String?
}

extension ConcurrentModificationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Content: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case charset = "Charset"
        case data = "Data"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let charset = charset {
            try encodeContainer.encode(charset, forKey: .charset)
        }
        if let data = data {
            try encodeContainer.encode(data, forKey: .data)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataDecoded = try containerValues.decodeIfPresent(String.self, forKey: .data)
        data = dataDecoded
        let charsetDecoded = try containerValues.decodeIfPresent(String.self, forKey: .charset)
        charset = charsetDecoded
    }
}

extension Content: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Content(charset: \(String(describing: charset)), data: \(String(describing: data)))"}
}

/// <p>An object that represents the content of the email, and optionally a character set
///             specification.</p>
public struct Content: Equatable {
    /// <p>The character set for the content. Because of the constraints of the SMTP protocol,
    ///             Amazon Pinpoint uses 7-bit ASCII by default. If the text includes characters outside of the ASCII
    ///             range, you have to specify a character set. For example, you could specify
    ///                 <code>UTF-8</code>, <code>ISO-8859-1</code>, or <code>Shift_JIS</code>.</p>
    public let charset: String?
    /// <p>The content of the message itself.</p>
    public let data: String?

    public init (
        charset: String? = nil,
        data: String? = nil
    )
    {
        self.charset = charset
        self.data = data
    }
}

public struct CreateConfigurationSetEventDestinationInputBodyMiddleware: Middleware {
    public let id: String = "CreateConfigurationSetEventDestinationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateConfigurationSetEventDestinationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateConfigurationSetEventDestinationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateConfigurationSetEventDestinationInput>
    public typealias MOutput = OperationOutput<CreateConfigurationSetEventDestinationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateConfigurationSetEventDestinationOutputError>
}

extension CreateConfigurationSetEventDestinationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateConfigurationSetEventDestinationInput(configurationSetName: \(String(describing: configurationSetName)), eventDestination: \(String(describing: eventDestination)), eventDestinationName: \(String(describing: eventDestinationName)))"}
}

extension CreateConfigurationSetEventDestinationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case eventDestination = "EventDestination"
        case eventDestinationName = "EventDestinationName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventDestination = eventDestination {
            try encodeContainer.encode(eventDestination, forKey: .eventDestination)
        }
        if let eventDestinationName = eventDestinationName {
            try encodeContainer.encode(eventDestinationName, forKey: .eventDestinationName)
        }
    }
}

public struct CreateConfigurationSetEventDestinationInputHeadersMiddleware: Middleware {
    public let id: String = "CreateConfigurationSetEventDestinationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateConfigurationSetEventDestinationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateConfigurationSetEventDestinationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateConfigurationSetEventDestinationInput>
    public typealias MOutput = OperationOutput<CreateConfigurationSetEventDestinationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateConfigurationSetEventDestinationOutputError>
}

public struct CreateConfigurationSetEventDestinationInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateConfigurationSetEventDestinationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateConfigurationSetEventDestinationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateConfigurationSetEventDestinationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateConfigurationSetEventDestinationInput>
    public typealias MOutput = OperationOutput<CreateConfigurationSetEventDestinationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateConfigurationSetEventDestinationOutputError>
}

/// <p>A request to add an event destination to a configuration set.</p>
public struct CreateConfigurationSetEventDestinationInput: Equatable {
    /// <p>The name of the configuration set that you want to add an event destination to.</p>
    public let configurationSetName: String?
    /// <p>An object that defines the event destination.</p>
    public let eventDestination: EventDestinationDefinition?
    /// <p>A name that identifies the event destination within the configuration set.</p>
    public let eventDestinationName: String?

    public init (
        configurationSetName: String? = nil,
        eventDestination: EventDestinationDefinition? = nil,
        eventDestinationName: String? = nil
    )
    {
        self.configurationSetName = configurationSetName
        self.eventDestination = eventDestination
        self.eventDestinationName = eventDestinationName
    }
}

struct CreateConfigurationSetEventDestinationInputBody: Equatable {
    public let eventDestinationName: String?
    public let eventDestination: EventDestinationDefinition?
}

extension CreateConfigurationSetEventDestinationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case eventDestination = "EventDestination"
        case eventDestinationName = "EventDestinationName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventDestinationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventDestinationName)
        eventDestinationName = eventDestinationNameDecoded
        let eventDestinationDecoded = try containerValues.decodeIfPresent(EventDestinationDefinition.self, forKey: .eventDestination)
        eventDestination = eventDestinationDecoded
    }
}

extension CreateConfigurationSetEventDestinationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateConfigurationSetEventDestinationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AlreadyExistsException" : self = .alreadyExistsException(try AlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateConfigurationSetEventDestinationOutputError: Swift.Error, Equatable {
    case alreadyExistsException(AlreadyExistsException)
    case badRequestException(BadRequestException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateConfigurationSetEventDestinationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateConfigurationSetEventDestinationOutputResponse()"}
}

extension CreateConfigurationSetEventDestinationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>An HTTP 200 response if the request succeeds, or an error message if the request
///             fails.</p>
public struct CreateConfigurationSetEventDestinationOutputResponse: Equatable {

    public init() {}
}

struct CreateConfigurationSetEventDestinationOutputResponseBody: Equatable {
}

extension CreateConfigurationSetEventDestinationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct CreateConfigurationSetInputBodyMiddleware: Middleware {
    public let id: String = "CreateConfigurationSetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateConfigurationSetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateConfigurationSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateConfigurationSetInput>
    public typealias MOutput = OperationOutput<CreateConfigurationSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateConfigurationSetOutputError>
}

extension CreateConfigurationSetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateConfigurationSetInput(configurationSetName: \(String(describing: configurationSetName)), deliveryOptions: \(String(describing: deliveryOptions)), reputationOptions: \(String(describing: reputationOptions)), sendingOptions: \(String(describing: sendingOptions)), tags: \(String(describing: tags)), trackingOptions: \(String(describing: trackingOptions)))"}
}

extension CreateConfigurationSetInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case configurationSetName = "ConfigurationSetName"
        case deliveryOptions = "DeliveryOptions"
        case reputationOptions = "ReputationOptions"
        case sendingOptions = "SendingOptions"
        case tags = "Tags"
        case trackingOptions = "TrackingOptions"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationSetName = configurationSetName {
            try encodeContainer.encode(configurationSetName, forKey: .configurationSetName)
        }
        if let deliveryOptions = deliveryOptions {
            try encodeContainer.encode(deliveryOptions, forKey: .deliveryOptions)
        }
        if let reputationOptions = reputationOptions {
            try encodeContainer.encode(reputationOptions, forKey: .reputationOptions)
        }
        if let sendingOptions = sendingOptions {
            try encodeContainer.encode(sendingOptions, forKey: .sendingOptions)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let trackingOptions = trackingOptions {
            try encodeContainer.encode(trackingOptions, forKey: .trackingOptions)
        }
    }
}

public struct CreateConfigurationSetInputHeadersMiddleware: Middleware {
    public let id: String = "CreateConfigurationSetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateConfigurationSetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateConfigurationSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateConfigurationSetInput>
    public typealias MOutput = OperationOutput<CreateConfigurationSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateConfigurationSetOutputError>
}

public struct CreateConfigurationSetInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateConfigurationSetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateConfigurationSetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateConfigurationSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateConfigurationSetInput>
    public typealias MOutput = OperationOutput<CreateConfigurationSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateConfigurationSetOutputError>
}

/// <p>A request to create a configuration set.</p>
public struct CreateConfigurationSetInput: Equatable {
    /// <p>The name of the configuration set.</p>
    public let configurationSetName: String?
    /// <p>An object that defines the dedicated IP pool that is used to send emails that you send
    ///             using the configuration set.</p>
    public let deliveryOptions: DeliveryOptions?
    /// <p>An object that defines whether or not Amazon Pinpoint collects reputation metrics for the emails
    ///             that you send that use the configuration set.</p>
    public let reputationOptions: ReputationOptions?
    /// <p>An object that defines whether or not Amazon Pinpoint can send email that you send using the
    ///             configuration set.</p>
    public let sendingOptions: SendingOptions?
    /// <p>An array of objects that define the tags (keys and values) that you want to associate
    ///             with the configuration set.</p>
    public let tags: [Tag]?
    /// <p>An object that defines the open and click tracking options for emails that you send
    ///             using the configuration set.</p>
    public let trackingOptions: TrackingOptions?

    public init (
        configurationSetName: String? = nil,
        deliveryOptions: DeliveryOptions? = nil,
        reputationOptions: ReputationOptions? = nil,
        sendingOptions: SendingOptions? = nil,
        tags: [Tag]? = nil,
        trackingOptions: TrackingOptions? = nil
    )
    {
        self.configurationSetName = configurationSetName
        self.deliveryOptions = deliveryOptions
        self.reputationOptions = reputationOptions
        self.sendingOptions = sendingOptions
        self.tags = tags
        self.trackingOptions = trackingOptions
    }
}

struct CreateConfigurationSetInputBody: Equatable {
    public let configurationSetName: String?
    public let trackingOptions: TrackingOptions?
    public let deliveryOptions: DeliveryOptions?
    public let reputationOptions: ReputationOptions?
    public let sendingOptions: SendingOptions?
    public let tags: [Tag]?
}

extension CreateConfigurationSetInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case configurationSetName = "ConfigurationSetName"
        case deliveryOptions = "DeliveryOptions"
        case reputationOptions = "ReputationOptions"
        case sendingOptions = "SendingOptions"
        case tags = "Tags"
        case trackingOptions = "TrackingOptions"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationSetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .configurationSetName)
        configurationSetName = configurationSetNameDecoded
        let trackingOptionsDecoded = try containerValues.decodeIfPresent(TrackingOptions.self, forKey: .trackingOptions)
        trackingOptions = trackingOptionsDecoded
        let deliveryOptionsDecoded = try containerValues.decodeIfPresent(DeliveryOptions.self, forKey: .deliveryOptions)
        deliveryOptions = deliveryOptionsDecoded
        let reputationOptionsDecoded = try containerValues.decodeIfPresent(ReputationOptions.self, forKey: .reputationOptions)
        reputationOptions = reputationOptionsDecoded
        let sendingOptionsDecoded = try containerValues.decodeIfPresent(SendingOptions.self, forKey: .sendingOptions)
        sendingOptions = sendingOptionsDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateConfigurationSetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateConfigurationSetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AlreadyExistsException" : self = .alreadyExistsException(try AlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateConfigurationSetOutputError: Swift.Error, Equatable {
    case alreadyExistsException(AlreadyExistsException)
    case badRequestException(BadRequestException)
    case concurrentModificationException(ConcurrentModificationException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateConfigurationSetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateConfigurationSetOutputResponse()"}
}

extension CreateConfigurationSetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>An HTTP 200 response if the request succeeds, or an error message if the request
///             fails.</p>
public struct CreateConfigurationSetOutputResponse: Equatable {

    public init() {}
}

struct CreateConfigurationSetOutputResponseBody: Equatable {
}

extension CreateConfigurationSetOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct CreateDedicatedIpPoolInputBodyMiddleware: Middleware {
    public let id: String = "CreateDedicatedIpPoolInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDedicatedIpPoolInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDedicatedIpPoolOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDedicatedIpPoolInput>
    public typealias MOutput = OperationOutput<CreateDedicatedIpPoolOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDedicatedIpPoolOutputError>
}

extension CreateDedicatedIpPoolInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDedicatedIpPoolInput(poolName: \(String(describing: poolName)), tags: \(String(describing: tags)))"}
}

extension CreateDedicatedIpPoolInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case poolName = "PoolName"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let poolName = poolName {
            try encodeContainer.encode(poolName, forKey: .poolName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateDedicatedIpPoolInputHeadersMiddleware: Middleware {
    public let id: String = "CreateDedicatedIpPoolInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDedicatedIpPoolInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDedicatedIpPoolOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDedicatedIpPoolInput>
    public typealias MOutput = OperationOutput<CreateDedicatedIpPoolOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDedicatedIpPoolOutputError>
}

public struct CreateDedicatedIpPoolInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateDedicatedIpPoolInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDedicatedIpPoolInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDedicatedIpPoolOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDedicatedIpPoolInput>
    public typealias MOutput = OperationOutput<CreateDedicatedIpPoolOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDedicatedIpPoolOutputError>
}

/// <p>A request to create a new dedicated IP pool.</p>
public struct CreateDedicatedIpPoolInput: Equatable {
    /// <p>The name of the dedicated IP pool.</p>
    public let poolName: String?
    /// <p>An object that defines the tags (keys and values) that you want to associate with the
    ///             pool.</p>
    public let tags: [Tag]?

    public init (
        poolName: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.poolName = poolName
        self.tags = tags
    }
}

struct CreateDedicatedIpPoolInputBody: Equatable {
    public let poolName: String?
    public let tags: [Tag]?
}

extension CreateDedicatedIpPoolInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case poolName = "PoolName"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let poolNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .poolName)
        poolName = poolNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateDedicatedIpPoolOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDedicatedIpPoolOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AlreadyExistsException" : self = .alreadyExistsException(try AlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDedicatedIpPoolOutputError: Swift.Error, Equatable {
    case alreadyExistsException(AlreadyExistsException)
    case badRequestException(BadRequestException)
    case concurrentModificationException(ConcurrentModificationException)
    case limitExceededException(LimitExceededException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDedicatedIpPoolOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDedicatedIpPoolOutputResponse()"}
}

extension CreateDedicatedIpPoolOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>An HTTP 200 response if the request succeeds, or an error message if the request
///             fails.</p>
public struct CreateDedicatedIpPoolOutputResponse: Equatable {

    public init() {}
}

struct CreateDedicatedIpPoolOutputResponseBody: Equatable {
}

extension CreateDedicatedIpPoolOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct CreateDeliverabilityTestReportInputBodyMiddleware: Middleware {
    public let id: String = "CreateDeliverabilityTestReportInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDeliverabilityTestReportInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDeliverabilityTestReportOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDeliverabilityTestReportInput>
    public typealias MOutput = OperationOutput<CreateDeliverabilityTestReportOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDeliverabilityTestReportOutputError>
}

extension CreateDeliverabilityTestReportInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDeliverabilityTestReportInput(content: \(String(describing: content)), fromEmailAddress: \(String(describing: fromEmailAddress)), reportName: \(String(describing: reportName)), tags: \(String(describing: tags)))"}
}

extension CreateDeliverabilityTestReportInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case content = "Content"
        case fromEmailAddress = "FromEmailAddress"
        case reportName = "ReportName"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let content = content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let fromEmailAddress = fromEmailAddress {
            try encodeContainer.encode(fromEmailAddress, forKey: .fromEmailAddress)
        }
        if let reportName = reportName {
            try encodeContainer.encode(reportName, forKey: .reportName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateDeliverabilityTestReportInputHeadersMiddleware: Middleware {
    public let id: String = "CreateDeliverabilityTestReportInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDeliverabilityTestReportInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDeliverabilityTestReportOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDeliverabilityTestReportInput>
    public typealias MOutput = OperationOutput<CreateDeliverabilityTestReportOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDeliverabilityTestReportOutputError>
}

public struct CreateDeliverabilityTestReportInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateDeliverabilityTestReportInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDeliverabilityTestReportInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDeliverabilityTestReportOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDeliverabilityTestReportInput>
    public typealias MOutput = OperationOutput<CreateDeliverabilityTestReportOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDeliverabilityTestReportOutputError>
}

/// <p>A request to perform a predictive inbox placement test. Predictive inbox placement tests can help you predict how your messages will
///             be handled by various email providers around the world. When you perform a predictive inbox placement test, you
///             provide a sample message that contains the content that you plan to send to your
///             customers. Amazon Pinpoint then sends that message to special email addresses spread across
///             several major email providers. After about 24 hours, the test is complete, and you can
///             use the <code>GetDeliverabilityTestReport</code> operation to view the results of the
///             test.</p>
public struct CreateDeliverabilityTestReportInput: Equatable {
    /// <p>The HTML body of the message that you sent when you performed the predictive inbox placement test.</p>
    public let content: EmailContent?
    /// <p>The email address that the predictive inbox placement test email was sent from.</p>
    public let fromEmailAddress: String?
    /// <p>A unique name that helps you to identify the predictive inbox placement test when you retrieve the
    ///             results.</p>
    public let reportName: String?
    /// <p>An array of objects that define the tags (keys and values) that you want to associate
    ///             with the predictive inbox placement test.</p>
    public let tags: [Tag]?

    public init (
        content: EmailContent? = nil,
        fromEmailAddress: String? = nil,
        reportName: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.content = content
        self.fromEmailAddress = fromEmailAddress
        self.reportName = reportName
        self.tags = tags
    }
}

struct CreateDeliverabilityTestReportInputBody: Equatable {
    public let reportName: String?
    public let fromEmailAddress: String?
    public let content: EmailContent?
    public let tags: [Tag]?
}

extension CreateDeliverabilityTestReportInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case content = "Content"
        case fromEmailAddress = "FromEmailAddress"
        case reportName = "ReportName"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .reportName)
        reportName = reportNameDecoded
        let fromEmailAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fromEmailAddress)
        fromEmailAddress = fromEmailAddressDecoded
        let contentDecoded = try containerValues.decodeIfPresent(EmailContent.self, forKey: .content)
        content = contentDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateDeliverabilityTestReportOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDeliverabilityTestReportOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccountSuspendedException" : self = .accountSuspendedException(try AccountSuspendedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MailFromDomainNotVerifiedException" : self = .mailFromDomainNotVerifiedException(try MailFromDomainNotVerifiedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MessageRejected" : self = .messageRejected(try MessageRejected(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SendingPausedException" : self = .sendingPausedException(try SendingPausedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDeliverabilityTestReportOutputError: Swift.Error, Equatable {
    case accountSuspendedException(AccountSuspendedException)
    case badRequestException(BadRequestException)
    case concurrentModificationException(ConcurrentModificationException)
    case limitExceededException(LimitExceededException)
    case mailFromDomainNotVerifiedException(MailFromDomainNotVerifiedException)
    case messageRejected(MessageRejected)
    case notFoundException(NotFoundException)
    case sendingPausedException(SendingPausedException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDeliverabilityTestReportOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDeliverabilityTestReportOutputResponse(deliverabilityTestStatus: \(String(describing: deliverabilityTestStatus)), reportId: \(String(describing: reportId)))"}
}

extension CreateDeliverabilityTestReportOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateDeliverabilityTestReportOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.deliverabilityTestStatus = output.deliverabilityTestStatus
            self.reportId = output.reportId
        } else {
            self.deliverabilityTestStatus = nil
            self.reportId = nil
        }
    }
}

/// <p>Information about the predictive inbox placement test that you created.</p>
public struct CreateDeliverabilityTestReportOutputResponse: Equatable {
    /// <p>The status of the predictive inbox placement test. If the status is <code>IN_PROGRESS</code>, then the predictive inbox placement test
    ///             is currently running. Predictive inbox placement tests are usually complete within 24 hours of creating the
    ///             test. If the status is <code>COMPLETE</code>, then the test is finished, and you can use
    ///             the <code>GetDeliverabilityTestReport</code> to view the results of the test.</p>
    public let deliverabilityTestStatus: DeliverabilityTestStatus?
    /// <p>A unique string that identifies the predictive inbox placement test.</p>
    public let reportId: String?

    public init (
        deliverabilityTestStatus: DeliverabilityTestStatus? = nil,
        reportId: String? = nil
    )
    {
        self.deliverabilityTestStatus = deliverabilityTestStatus
        self.reportId = reportId
    }
}

struct CreateDeliverabilityTestReportOutputResponseBody: Equatable {
    public let reportId: String?
    public let deliverabilityTestStatus: DeliverabilityTestStatus?
}

extension CreateDeliverabilityTestReportOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case deliverabilityTestStatus = "DeliverabilityTestStatus"
        case reportId = "ReportId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .reportId)
        reportId = reportIdDecoded
        let deliverabilityTestStatusDecoded = try containerValues.decodeIfPresent(DeliverabilityTestStatus.self, forKey: .deliverabilityTestStatus)
        deliverabilityTestStatus = deliverabilityTestStatusDecoded
    }
}

public struct CreateEmailIdentityInputBodyMiddleware: Middleware {
    public let id: String = "CreateEmailIdentityInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateEmailIdentityInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateEmailIdentityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateEmailIdentityInput>
    public typealias MOutput = OperationOutput<CreateEmailIdentityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateEmailIdentityOutputError>
}

extension CreateEmailIdentityInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateEmailIdentityInput(emailIdentity: \(String(describing: emailIdentity)), tags: \(String(describing: tags)))"}
}

extension CreateEmailIdentityInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case emailIdentity = "EmailIdentity"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let emailIdentity = emailIdentity {
            try encodeContainer.encode(emailIdentity, forKey: .emailIdentity)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateEmailIdentityInputHeadersMiddleware: Middleware {
    public let id: String = "CreateEmailIdentityInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateEmailIdentityInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateEmailIdentityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateEmailIdentityInput>
    public typealias MOutput = OperationOutput<CreateEmailIdentityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateEmailIdentityOutputError>
}

public struct CreateEmailIdentityInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateEmailIdentityInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateEmailIdentityInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateEmailIdentityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateEmailIdentityInput>
    public typealias MOutput = OperationOutput<CreateEmailIdentityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateEmailIdentityOutputError>
}

/// <p>A request to begin the verification process for an email identity (an email address or
///             domain).</p>
public struct CreateEmailIdentityInput: Equatable {
    /// <p>The email address or domain that you want to verify.</p>
    public let emailIdentity: String?
    /// <p>An array of objects that define the tags (keys and values) that you want to associate
    ///             with the email identity.</p>
    public let tags: [Tag]?

    public init (
        emailIdentity: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.emailIdentity = emailIdentity
        self.tags = tags
    }
}

struct CreateEmailIdentityInputBody: Equatable {
    public let emailIdentity: String?
    public let tags: [Tag]?
}

extension CreateEmailIdentityInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case emailIdentity = "EmailIdentity"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let emailIdentityDecoded = try containerValues.decodeIfPresent(String.self, forKey: .emailIdentity)
        emailIdentity = emailIdentityDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateEmailIdentityOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateEmailIdentityOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateEmailIdentityOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case concurrentModificationException(ConcurrentModificationException)
    case limitExceededException(LimitExceededException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateEmailIdentityOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateEmailIdentityOutputResponse(dkimAttributes: \(String(describing: dkimAttributes)), identityType: \(String(describing: identityType)), verifiedForSendingStatus: \(String(describing: verifiedForSendingStatus)))"}
}

extension CreateEmailIdentityOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateEmailIdentityOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dkimAttributes = output.dkimAttributes
            self.identityType = output.identityType
            self.verifiedForSendingStatus = output.verifiedForSendingStatus
        } else {
            self.dkimAttributes = nil
            self.identityType = nil
            self.verifiedForSendingStatus = false
        }
    }
}

/// <p>If the email identity is a domain, this object contains tokens that you can use to
///             create a set of CNAME records. To sucessfully verify your domain, you have to add these
///             records to the DNS configuration for your domain.</p>
///         <p>If the email identity is an email address, this object is empty. </p>
public struct CreateEmailIdentityOutputResponse: Equatable {
    /// <p>An object that contains information about the DKIM attributes for the identity. This
    ///             object includes the tokens that you use to create the CNAME records that are required to
    ///             complete the DKIM verification process.</p>
    public let dkimAttributes: DkimAttributes?
    /// <p>The email identity type.</p>
    public let identityType: IdentityType?
    /// <p>Specifies whether or not the identity is verified. In Amazon Pinpoint, you can only send email
    ///             from verified email addresses or domains. For more information about verifying
    ///             identities, see the <a href="https://docs.aws.amazon.com/pinpoint/latest/userguide/channels-email-manage-verify.html">Amazon Pinpoint User Guide</a>.</p>
    public let verifiedForSendingStatus: Bool

    public init (
        dkimAttributes: DkimAttributes? = nil,
        identityType: IdentityType? = nil,
        verifiedForSendingStatus: Bool = false
    )
    {
        self.dkimAttributes = dkimAttributes
        self.identityType = identityType
        self.verifiedForSendingStatus = verifiedForSendingStatus
    }
}

struct CreateEmailIdentityOutputResponseBody: Equatable {
    public let identityType: IdentityType?
    public let verifiedForSendingStatus: Bool
    public let dkimAttributes: DkimAttributes?
}

extension CreateEmailIdentityOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dkimAttributes = "DkimAttributes"
        case identityType = "IdentityType"
        case verifiedForSendingStatus = "VerifiedForSendingStatus"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityTypeDecoded = try containerValues.decodeIfPresent(IdentityType.self, forKey: .identityType)
        identityType = identityTypeDecoded
        let verifiedForSendingStatusDecoded = try containerValues.decode(Bool.self, forKey: .verifiedForSendingStatus)
        verifiedForSendingStatus = verifiedForSendingStatusDecoded
        let dkimAttributesDecoded = try containerValues.decodeIfPresent(DkimAttributes.self, forKey: .dkimAttributes)
        dkimAttributes = dkimAttributesDecoded
    }
}

extension DailyVolume: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case domainIspPlacements = "DomainIspPlacements"
        case startDate = "StartDate"
        case volumeStatistics = "VolumeStatistics"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainIspPlacements = domainIspPlacements {
            var domainIspPlacementsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .domainIspPlacements)
            for domainispplacements0 in domainIspPlacements {
                try domainIspPlacementsContainer.encode(domainispplacements0)
            }
        }
        if let startDate = startDate {
            try encodeContainer.encode(startDate.timeIntervalSince1970, forKey: .startDate)
        }
        if let volumeStatistics = volumeStatistics {
            try encodeContainer.encode(volumeStatistics, forKey: .volumeStatistics)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startDate)
        startDate = startDateDecoded
        let volumeStatisticsDecoded = try containerValues.decodeIfPresent(VolumeStatistics.self, forKey: .volumeStatistics)
        volumeStatistics = volumeStatisticsDecoded
        let domainIspPlacementsContainer = try containerValues.decodeIfPresent([DomainIspPlacement?].self, forKey: .domainIspPlacements)
        var domainIspPlacementsDecoded0:[DomainIspPlacement]? = nil
        if let domainIspPlacementsContainer = domainIspPlacementsContainer {
            domainIspPlacementsDecoded0 = [DomainIspPlacement]()
            for structure0 in domainIspPlacementsContainer {
                if let structure0 = structure0 {
                    domainIspPlacementsDecoded0?.append(structure0)
                }
            }
        }
        domainIspPlacements = domainIspPlacementsDecoded0
    }
}

extension DailyVolume: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DailyVolume(domainIspPlacements: \(String(describing: domainIspPlacements)), startDate: \(String(describing: startDate)), volumeStatistics: \(String(describing: volumeStatistics)))"}
}

/// <p>An object that contains information about the volume of email sent on each day of the
///             analysis period.</p>
public struct DailyVolume: Equatable {
    /// <p>An object that contains inbox placement metrics for a specified day in the analysis
    ///             period, broken out by the recipient's email provider.</p>
    public let domainIspPlacements: [DomainIspPlacement]?
    /// <p>The date that the DailyVolume metrics apply to, in Unix time.</p>
    public let startDate: Date?
    /// <p>An object that contains inbox placement metrics for a specific day in the analysis
    ///             period.</p>
    public let volumeStatistics: VolumeStatistics?

    public init (
        domainIspPlacements: [DomainIspPlacement]? = nil,
        startDate: Date? = nil,
        volumeStatistics: VolumeStatistics? = nil
    )
    {
        self.domainIspPlacements = domainIspPlacements
        self.startDate = startDate
        self.volumeStatistics = volumeStatistics
    }
}

extension DedicatedIp: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case ip = "Ip"
        case poolName = "PoolName"
        case warmupPercentage = "WarmupPercentage"
        case warmupStatus = "WarmupStatus"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ip = ip {
            try encodeContainer.encode(ip, forKey: .ip)
        }
        if let poolName = poolName {
            try encodeContainer.encode(poolName, forKey: .poolName)
        }
        if let warmupPercentage = warmupPercentage {
            try encodeContainer.encode(warmupPercentage, forKey: .warmupPercentage)
        }
        if let warmupStatus = warmupStatus {
            try encodeContainer.encode(warmupStatus.rawValue, forKey: .warmupStatus)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ipDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ip)
        ip = ipDecoded
        let warmupStatusDecoded = try containerValues.decodeIfPresent(WarmupStatus.self, forKey: .warmupStatus)
        warmupStatus = warmupStatusDecoded
        let warmupPercentageDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .warmupPercentage)
        warmupPercentage = warmupPercentageDecoded
        let poolNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .poolName)
        poolName = poolNameDecoded
    }
}

extension DedicatedIp: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DedicatedIp(ip: \(String(describing: ip)), poolName: \(String(describing: poolName)), warmupPercentage: \(String(describing: warmupPercentage)), warmupStatus: \(String(describing: warmupStatus)))"}
}

/// <p>Contains information about a dedicated IP address that is associated with your Amazon Pinpoint
///             account.</p>
///         <p></p>
public struct DedicatedIp: Equatable {
    /// <p>An IP address that is reserved for use by your Amazon Pinpoint account.</p>
    public let ip: String?
    /// <p>The name of the dedicated IP pool that the IP address is associated with.</p>
    public let poolName: String?
    /// <p>Indicates how complete the dedicated IP warm-up process is. When this value equals 1,
    ///             the address has completed the warm-up process and is ready for use.</p>
    public let warmupPercentage: Int?
    /// <p>The warm-up status of a dedicated IP address. The status can have one of the following
    ///             values:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <code>IN_PROGRESS</code>  The IP address isn't ready to use because the
    ///                     dedicated IP warm-up process is ongoing.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>DONE</code>  The dedicated IP warm-up process is complete, and
    ///                     the IP address is ready to use.</p>
    ///             </li>
    ///          </ul>
    public let warmupStatus: WarmupStatus?

    public init (
        ip: String? = nil,
        poolName: String? = nil,
        warmupPercentage: Int? = nil,
        warmupStatus: WarmupStatus? = nil
    )
    {
        self.ip = ip
        self.poolName = poolName
        self.warmupPercentage = warmupPercentage
        self.warmupStatus = warmupStatus
    }
}

extension DeleteConfigurationSetEventDestinationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteConfigurationSetEventDestinationInput(configurationSetName: \(String(describing: configurationSetName)), eventDestinationName: \(String(describing: eventDestinationName)))"}
}

extension DeleteConfigurationSetEventDestinationInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteConfigurationSetEventDestinationInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteConfigurationSetEventDestinationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteConfigurationSetEventDestinationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteConfigurationSetEventDestinationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteConfigurationSetEventDestinationInput>
    public typealias MOutput = OperationOutput<DeleteConfigurationSetEventDestinationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteConfigurationSetEventDestinationOutputError>
}

public struct DeleteConfigurationSetEventDestinationInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteConfigurationSetEventDestinationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteConfigurationSetEventDestinationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteConfigurationSetEventDestinationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteConfigurationSetEventDestinationInput>
    public typealias MOutput = OperationOutput<DeleteConfigurationSetEventDestinationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteConfigurationSetEventDestinationOutputError>
}

/// <p>A request to delete an event destination from a configuration set.</p>
public struct DeleteConfigurationSetEventDestinationInput: Equatable {
    /// <p>The name of the configuration set that contains the event destination that you want to
    ///             delete.</p>
    public let configurationSetName: String?
    /// <p>The name of the event destination that you want to delete.</p>
    public let eventDestinationName: String?

    public init (
        configurationSetName: String? = nil,
        eventDestinationName: String? = nil
    )
    {
        self.configurationSetName = configurationSetName
        self.eventDestinationName = eventDestinationName
    }
}

struct DeleteConfigurationSetEventDestinationInputBody: Equatable {
}

extension DeleteConfigurationSetEventDestinationInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteConfigurationSetEventDestinationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteConfigurationSetEventDestinationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteConfigurationSetEventDestinationOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteConfigurationSetEventDestinationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteConfigurationSetEventDestinationOutputResponse()"}
}

extension DeleteConfigurationSetEventDestinationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>An HTTP 200 response if the request succeeds, or an error message if the request
///             fails.</p>
public struct DeleteConfigurationSetEventDestinationOutputResponse: Equatable {

    public init() {}
}

struct DeleteConfigurationSetEventDestinationOutputResponseBody: Equatable {
}

extension DeleteConfigurationSetEventDestinationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteConfigurationSetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteConfigurationSetInput(configurationSetName: \(String(describing: configurationSetName)))"}
}

extension DeleteConfigurationSetInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteConfigurationSetInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteConfigurationSetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteConfigurationSetInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteConfigurationSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteConfigurationSetInput>
    public typealias MOutput = OperationOutput<DeleteConfigurationSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteConfigurationSetOutputError>
}

public struct DeleteConfigurationSetInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteConfigurationSetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteConfigurationSetInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteConfigurationSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteConfigurationSetInput>
    public typealias MOutput = OperationOutput<DeleteConfigurationSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteConfigurationSetOutputError>
}

/// <p>A request to delete a configuration set.</p>
public struct DeleteConfigurationSetInput: Equatable {
    /// <p>The name of the configuration set that you want to delete.</p>
    public let configurationSetName: String?

    public init (
        configurationSetName: String? = nil
    )
    {
        self.configurationSetName = configurationSetName
    }
}

struct DeleteConfigurationSetInputBody: Equatable {
}

extension DeleteConfigurationSetInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteConfigurationSetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteConfigurationSetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteConfigurationSetOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case concurrentModificationException(ConcurrentModificationException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteConfigurationSetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteConfigurationSetOutputResponse()"}
}

extension DeleteConfigurationSetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>An HTTP 200 response if the request succeeds, or an error message if the request
///             fails.</p>
public struct DeleteConfigurationSetOutputResponse: Equatable {

    public init() {}
}

struct DeleteConfigurationSetOutputResponseBody: Equatable {
}

extension DeleteConfigurationSetOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteDedicatedIpPoolInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDedicatedIpPoolInput(poolName: \(String(describing: poolName)))"}
}

extension DeleteDedicatedIpPoolInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteDedicatedIpPoolInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteDedicatedIpPoolInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDedicatedIpPoolInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDedicatedIpPoolOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDedicatedIpPoolInput>
    public typealias MOutput = OperationOutput<DeleteDedicatedIpPoolOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDedicatedIpPoolOutputError>
}

public struct DeleteDedicatedIpPoolInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteDedicatedIpPoolInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDedicatedIpPoolInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDedicatedIpPoolOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDedicatedIpPoolInput>
    public typealias MOutput = OperationOutput<DeleteDedicatedIpPoolOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDedicatedIpPoolOutputError>
}

/// <p>A request to delete a dedicated IP pool.</p>
public struct DeleteDedicatedIpPoolInput: Equatable {
    /// <p>The name of the dedicated IP pool that you want to delete.</p>
    public let poolName: String?

    public init (
        poolName: String? = nil
    )
    {
        self.poolName = poolName
    }
}

struct DeleteDedicatedIpPoolInputBody: Equatable {
}

extension DeleteDedicatedIpPoolInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteDedicatedIpPoolOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDedicatedIpPoolOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDedicatedIpPoolOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case concurrentModificationException(ConcurrentModificationException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDedicatedIpPoolOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDedicatedIpPoolOutputResponse()"}
}

extension DeleteDedicatedIpPoolOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>An HTTP 200 response if the request succeeds, or an error message if the request
///             fails.</p>
public struct DeleteDedicatedIpPoolOutputResponse: Equatable {

    public init() {}
}

struct DeleteDedicatedIpPoolOutputResponseBody: Equatable {
}

extension DeleteDedicatedIpPoolOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteEmailIdentityInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteEmailIdentityInput(emailIdentity: \(String(describing: emailIdentity)))"}
}

extension DeleteEmailIdentityInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteEmailIdentityInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteEmailIdentityInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteEmailIdentityInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteEmailIdentityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteEmailIdentityInput>
    public typealias MOutput = OperationOutput<DeleteEmailIdentityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteEmailIdentityOutputError>
}

public struct DeleteEmailIdentityInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteEmailIdentityInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteEmailIdentityInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteEmailIdentityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteEmailIdentityInput>
    public typealias MOutput = OperationOutput<DeleteEmailIdentityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteEmailIdentityOutputError>
}

/// <p>A request to delete an existing email identity. When you delete an identity, you lose
///             the ability to use Amazon Pinpoint to send email from that identity. You can restore your ability
///             to send email by completing the verification process for the identity again.</p>
public struct DeleteEmailIdentityInput: Equatable {
    /// <p>The identity (that is, the email address or domain) that you want to delete from your
    ///             Amazon Pinpoint account.</p>
    public let emailIdentity: String?

    public init (
        emailIdentity: String? = nil
    )
    {
        self.emailIdentity = emailIdentity
    }
}

struct DeleteEmailIdentityInputBody: Equatable {
}

extension DeleteEmailIdentityInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteEmailIdentityOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteEmailIdentityOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteEmailIdentityOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case concurrentModificationException(ConcurrentModificationException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteEmailIdentityOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteEmailIdentityOutputResponse()"}
}

extension DeleteEmailIdentityOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>An HTTP 200 response if the request succeeds, or an error message if the request
///             fails.</p>
public struct DeleteEmailIdentityOutputResponse: Equatable {

    public init() {}
}

struct DeleteEmailIdentityOutputResponseBody: Equatable {
}

extension DeleteEmailIdentityOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

/// <p>The current status of your Deliverability dashboard subscription. If this value is
///                 <code>PENDING_EXPIRATION</code>, your subscription is scheduled to expire at the end
///             of the current calendar month.</p>
public enum DeliverabilityDashboardAccountStatus {
    case active
    case disabled
    case pendingExpiration
    case sdkUnknown(String)
}

extension DeliverabilityDashboardAccountStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DeliverabilityDashboardAccountStatus] {
        return [
            .active,
            .disabled,
            .pendingExpiration,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .active: return "ACTIVE"
        case .disabled: return "DISABLED"
        case .pendingExpiration: return "PENDING_EXPIRATION"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DeliverabilityDashboardAccountStatus(rawValue: rawValue) ?? DeliverabilityDashboardAccountStatus.sdkUnknown(rawValue)
    }
}

extension DeliverabilityTestReport: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case createDate = "CreateDate"
        case deliverabilityTestStatus = "DeliverabilityTestStatus"
        case fromEmailAddress = "FromEmailAddress"
        case reportId = "ReportId"
        case reportName = "ReportName"
        case subject = "Subject"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createDate = createDate {
            try encodeContainer.encode(createDate.timeIntervalSince1970, forKey: .createDate)
        }
        if let deliverabilityTestStatus = deliverabilityTestStatus {
            try encodeContainer.encode(deliverabilityTestStatus.rawValue, forKey: .deliverabilityTestStatus)
        }
        if let fromEmailAddress = fromEmailAddress {
            try encodeContainer.encode(fromEmailAddress, forKey: .fromEmailAddress)
        }
        if let reportId = reportId {
            try encodeContainer.encode(reportId, forKey: .reportId)
        }
        if let reportName = reportName {
            try encodeContainer.encode(reportName, forKey: .reportName)
        }
        if let subject = subject {
            try encodeContainer.encode(subject, forKey: .subject)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .reportId)
        reportId = reportIdDecoded
        let reportNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .reportName)
        reportName = reportNameDecoded
        let subjectDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subject)
        subject = subjectDecoded
        let fromEmailAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fromEmailAddress)
        fromEmailAddress = fromEmailAddressDecoded
        let createDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createDate)
        createDate = createDateDecoded
        let deliverabilityTestStatusDecoded = try containerValues.decodeIfPresent(DeliverabilityTestStatus.self, forKey: .deliverabilityTestStatus)
        deliverabilityTestStatus = deliverabilityTestStatusDecoded
    }
}

extension DeliverabilityTestReport: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeliverabilityTestReport(createDate: \(String(describing: createDate)), deliverabilityTestStatus: \(String(describing: deliverabilityTestStatus)), fromEmailAddress: \(String(describing: fromEmailAddress)), reportId: \(String(describing: reportId)), reportName: \(String(describing: reportName)), subject: \(String(describing: subject)))"}
}

/// <p>An object that contains metadata related to a predictive inbox placement test.</p>
public struct DeliverabilityTestReport: Equatable {
    /// <p>The date and time when the predictive inbox placement test was created, in Unix time format.</p>
    public let createDate: Date?
    /// <p>The status of the predictive inbox placement test. If the status is <code>IN_PROGRESS</code>, then the predictive inbox placement test
    ///             is currently running. Predictive inbox placement tests are usually complete within 24 hours of creating the
    ///             test. If the status is <code>COMPLETE</code>, then the test is finished, and you can use
    ///             the <code>GetDeliverabilityTestReport</code> to view the results of the test.</p>
    public let deliverabilityTestStatus: DeliverabilityTestStatus?
    /// <p>The sender address that you specified for the predictive inbox placement test.</p>
    public let fromEmailAddress: String?
    /// <p>A unique string that identifies the predictive inbox placement test.</p>
    public let reportId: String?
    /// <p>A name that helps you identify a predictive inbox placement test report.</p>
    public let reportName: String?
    /// <p>The subject line for an email that you submitted in a predictive inbox placement test.</p>
    public let subject: String?

    public init (
        createDate: Date? = nil,
        deliverabilityTestStatus: DeliverabilityTestStatus? = nil,
        fromEmailAddress: String? = nil,
        reportId: String? = nil,
        reportName: String? = nil,
        subject: String? = nil
    )
    {
        self.createDate = createDate
        self.deliverabilityTestStatus = deliverabilityTestStatus
        self.fromEmailAddress = fromEmailAddress
        self.reportId = reportId
        self.reportName = reportName
        self.subject = subject
    }
}

/// <p>The status of a predictive inbox placement test. If the status is <code>IN_PROGRESS</code>, then the predictive inbox placement test is
///             currently running. Predictive inbox placement tests are usually complete within 24 hours of creating the test.
///             If the status is <code>COMPLETE</code>, then the test is finished, and you can use the
///                 <code>GetDeliverabilityTestReport</code> operation to view the results of the
///             test.</p>
public enum DeliverabilityTestStatus {
    case completed
    case inProgress
    case sdkUnknown(String)
}

extension DeliverabilityTestStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DeliverabilityTestStatus] {
        return [
            .completed,
            .inProgress,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .completed: return "COMPLETED"
        case .inProgress: return "IN_PROGRESS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DeliverabilityTestStatus(rawValue: rawValue) ?? DeliverabilityTestStatus.sdkUnknown(rawValue)
    }
}

extension DeliveryOptions: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case sendingPoolName = "SendingPoolName"
        case tlsPolicy = "TlsPolicy"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sendingPoolName = sendingPoolName {
            try encodeContainer.encode(sendingPoolName, forKey: .sendingPoolName)
        }
        if let tlsPolicy = tlsPolicy {
            try encodeContainer.encode(tlsPolicy.rawValue, forKey: .tlsPolicy)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tlsPolicyDecoded = try containerValues.decodeIfPresent(TlsPolicy.self, forKey: .tlsPolicy)
        tlsPolicy = tlsPolicyDecoded
        let sendingPoolNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sendingPoolName)
        sendingPoolName = sendingPoolNameDecoded
    }
}

extension DeliveryOptions: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeliveryOptions(sendingPoolName: \(String(describing: sendingPoolName)), tlsPolicy: \(String(describing: tlsPolicy)))"}
}

/// <p>Used to associate a configuration set with a dedicated IP pool.</p>
public struct DeliveryOptions: Equatable {
    /// <p>The name of the dedicated IP pool that you want to associate with the configuration
    ///             set.</p>
    public let sendingPoolName: String?
    /// <p>Specifies whether messages that use the configuration set are required to use
    ///             Transport Layer Security (TLS). If the value is <code>Require</code>, messages are only
    ///             delivered if a TLS connection can be established. If the value is <code>Optional</code>,
    ///             messages can be delivered in plain text if a TLS connection can't be established.</p>
    public let tlsPolicy: TlsPolicy?

    public init (
        sendingPoolName: String? = nil,
        tlsPolicy: TlsPolicy? = nil
    )
    {
        self.sendingPoolName = sendingPoolName
        self.tlsPolicy = tlsPolicy
    }
}

extension Destination: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bccAddresses = "BccAddresses"
        case ccAddresses = "CcAddresses"
        case toAddresses = "ToAddresses"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bccAddresses = bccAddresses {
            var bccAddressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .bccAddresses)
            for emailaddresslist0 in bccAddresses {
                try bccAddressesContainer.encode(emailaddresslist0)
            }
        }
        if let ccAddresses = ccAddresses {
            var ccAddressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ccAddresses)
            for emailaddresslist0 in ccAddresses {
                try ccAddressesContainer.encode(emailaddresslist0)
            }
        }
        if let toAddresses = toAddresses {
            var toAddressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .toAddresses)
            for emailaddresslist0 in toAddresses {
                try toAddressesContainer.encode(emailaddresslist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let toAddressesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .toAddresses)
        var toAddressesDecoded0:[String]? = nil
        if let toAddressesContainer = toAddressesContainer {
            toAddressesDecoded0 = [String]()
            for string0 in toAddressesContainer {
                if let string0 = string0 {
                    toAddressesDecoded0?.append(string0)
                }
            }
        }
        toAddresses = toAddressesDecoded0
        let ccAddressesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .ccAddresses)
        var ccAddressesDecoded0:[String]? = nil
        if let ccAddressesContainer = ccAddressesContainer {
            ccAddressesDecoded0 = [String]()
            for string0 in ccAddressesContainer {
                if let string0 = string0 {
                    ccAddressesDecoded0?.append(string0)
                }
            }
        }
        ccAddresses = ccAddressesDecoded0
        let bccAddressesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .bccAddresses)
        var bccAddressesDecoded0:[String]? = nil
        if let bccAddressesContainer = bccAddressesContainer {
            bccAddressesDecoded0 = [String]()
            for string0 in bccAddressesContainer {
                if let string0 = string0 {
                    bccAddressesDecoded0?.append(string0)
                }
            }
        }
        bccAddresses = bccAddressesDecoded0
    }
}

extension Destination: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Destination(bccAddresses: \(String(describing: bccAddresses)), ccAddresses: \(String(describing: ccAddresses)), toAddresses: \(String(describing: toAddresses)))"}
}

/// <p>An object that describes the recipients for an email.</p>
public struct Destination: Equatable {
    /// <p>An array that contains the email addresses of the "BCC" (blind carbon copy) recipients
    ///             for the email.</p>
    public let bccAddresses: [String]?
    /// <p>An array that contains the email addresses of the "CC" (carbon copy) recipients for
    ///             the email.</p>
    public let ccAddresses: [String]?
    /// <p>An array that contains the email addresses of the "To" recipients for the
    ///             email.</p>
    public let toAddresses: [String]?

    public init (
        bccAddresses: [String]? = nil,
        ccAddresses: [String]? = nil,
        toAddresses: [String]? = nil
    )
    {
        self.bccAddresses = bccAddresses
        self.ccAddresses = ccAddresses
        self.toAddresses = toAddresses
    }
}

/// <p>The location where Amazon Pinpoint finds the value of a dimension to publish to Amazon CloudWatch. If you
///             want Amazon Pinpoint to use the message tags that you specify using an X-SES-MESSAGE-TAGS header
///             or a parameter to the SendEmail/SendRawEmail API, choose <code>messageTag</code>. If you
///             want Amazon Pinpoint to use your own email headers, choose <code>emailHeader</code>. If you want
///             Amazon Pinpoint to use link tags, choose <code>linkTags</code>.</p>
public enum DimensionValueSource {
    case emailHeader
    case linkTag
    case messageTag
    case sdkUnknown(String)
}

extension DimensionValueSource : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DimensionValueSource] {
        return [
            .emailHeader,
            .linkTag,
            .messageTag,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .emailHeader: return "EMAIL_HEADER"
        case .linkTag: return "LINK_TAG"
        case .messageTag: return "MESSAGE_TAG"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DimensionValueSource(rawValue: rawValue) ?? DimensionValueSource.sdkUnknown(rawValue)
    }
}

extension DkimAttributes: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case signingEnabled = "SigningEnabled"
        case status = "Status"
        case tokens = "Tokens"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if signingEnabled != false {
            try encodeContainer.encode(signingEnabled, forKey: .signingEnabled)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let tokens = tokens {
            var tokensContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tokens)
            for dnstokenlist0 in tokens {
                try tokensContainer.encode(dnstokenlist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let signingEnabledDecoded = try containerValues.decode(Bool.self, forKey: .signingEnabled)
        signingEnabled = signingEnabledDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DkimStatus.self, forKey: .status)
        status = statusDecoded
        let tokensContainer = try containerValues.decodeIfPresent([String?].self, forKey: .tokens)
        var tokensDecoded0:[String]? = nil
        if let tokensContainer = tokensContainer {
            tokensDecoded0 = [String]()
            for string0 in tokensContainer {
                if let string0 = string0 {
                    tokensDecoded0?.append(string0)
                }
            }
        }
        tokens = tokensDecoded0
    }
}

extension DkimAttributes: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DkimAttributes(signingEnabled: \(String(describing: signingEnabled)), status: \(String(describing: status)), tokens: \(String(describing: tokens)))"}
}

/// <p>An object that contains information about the DKIM configuration for an email
///             identity.</p>
public struct DkimAttributes: Equatable {
    /// <p>If the value is <code>true</code>, then the messages that Amazon Pinpoint sends from the
    ///             identity are DKIM-signed. If the value is <code>false</code>, then the messages that
    ///             Amazon Pinpoint sends from the identity aren't DKIM-signed.</p>
    public let signingEnabled: Bool
    /// <p>Describes whether or not Amazon Pinpoint has successfully located the DKIM records in the DNS
    ///             records for the domain. The status can be one of the following:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <code>PENDING</code>  Amazon Pinpoint hasn't yet located the DKIM records in the
    ///                     DNS configuration for the domain, but will continue to attempt to locate
    ///                     them.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>SUCCESS</code>  Amazon Pinpoint located the DKIM records in the DNS
    ///                     configuration for the domain and determined that they're correct. Amazon Pinpoint can now
    ///                     send DKIM-signed email from the identity.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>FAILED</code>  Amazon Pinpoint was unable to locate the DKIM records in the
    ///                     DNS settings for the domain, and won't continue to search for them.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>TEMPORARY_FAILURE</code>  A temporary issue occurred, which
    ///                     prevented Amazon Pinpoint from determining the DKIM status for the domain.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>NOT_STARTED</code>  Amazon Pinpoint hasn't yet started searching for the
    ///                     DKIM records in the DKIM records for the domain.</p>
    ///             </li>
    ///          </ul>
    public let status: DkimStatus?
    /// <p>A set of unique strings that you use to create a set of CNAME records that you add to
    ///             the DNS configuration for your domain. When Amazon Pinpoint detects these records in the DNS
    ///             configuration for your domain, the DKIM authentication process is complete. Amazon Pinpoint
    ///             usually detects these records within about 72 hours of adding them to the DNS
    ///             configuration for your domain.</p>
    public let tokens: [String]?

    public init (
        signingEnabled: Bool = false,
        status: DkimStatus? = nil,
        tokens: [String]? = nil
    )
    {
        self.signingEnabled = signingEnabled
        self.status = status
        self.tokens = tokens
    }
}

/// <p>The DKIM authentication status of the identity. The status can be one of the
///             following:</p>
///         <ul>
///             <li>
///                 <p>
///                   <code>PENDING</code>  The DKIM verification process was initiated, and
///                     Amazon Pinpoint is still waiting for the required CNAME records to appear in the DNS
///                     configuration for the domain.</p>
///             </li>
///             <li>
///                 <p>
///                   <code>SUCCESS</code>  The DKIM authentication process completed
///                     successfully.</p>
///             </li>
///             <li>
///                 <p>
///                   <code>FAILED</code>  The DKIM authentication process failed. This can
///                     happen when Amazon Pinpoint fails to find the required CNAME records in the DNS
///                     configuration of the domain.</p>
///             </li>
///             <li>
///                 <p>
///                   <code>TEMPORARY_FAILURE</code>  A temporary issue is preventing Amazon Pinpoint
///                     from determining the DKIM authentication status of the domain.</p>
///             </li>
///             <li>
///                 <p>
///                   <code>NOT_STARTED</code>  The DKIM verification process hasn't been
///                     initiated for the domain.</p>
///             </li>
///          </ul>
public enum DkimStatus {
    case failed
    case notStarted
    case pending
    case success
    case temporaryFailure
    case sdkUnknown(String)
}

extension DkimStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DkimStatus] {
        return [
            .failed,
            .notStarted,
            .pending,
            .success,
            .temporaryFailure,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .failed: return "FAILED"
        case .notStarted: return "NOT_STARTED"
        case .pending: return "PENDING"
        case .success: return "SUCCESS"
        case .temporaryFailure: return "TEMPORARY_FAILURE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DkimStatus(rawValue: rawValue) ?? DkimStatus.sdkUnknown(rawValue)
    }
}

extension DomainDeliverabilityCampaign: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case campaignId = "CampaignId"
        case deleteRate = "DeleteRate"
        case esps = "Esps"
        case firstSeenDateTime = "FirstSeenDateTime"
        case fromAddress = "FromAddress"
        case imageUrl = "ImageUrl"
        case inboxCount = "InboxCount"
        case lastSeenDateTime = "LastSeenDateTime"
        case projectedVolume = "ProjectedVolume"
        case readDeleteRate = "ReadDeleteRate"
        case readRate = "ReadRate"
        case sendingIps = "SendingIps"
        case spamCount = "SpamCount"
        case subject = "Subject"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let campaignId = campaignId {
            try encodeContainer.encode(campaignId, forKey: .campaignId)
        }
        if let deleteRate = deleteRate {
            try encodeContainer.encode(deleteRate, forKey: .deleteRate)
        }
        if let esps = esps {
            var espsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .esps)
            for esps0 in esps {
                try espsContainer.encode(esps0)
            }
        }
        if let firstSeenDateTime = firstSeenDateTime {
            try encodeContainer.encode(firstSeenDateTime.timeIntervalSince1970, forKey: .firstSeenDateTime)
        }
        if let fromAddress = fromAddress {
            try encodeContainer.encode(fromAddress, forKey: .fromAddress)
        }
        if let imageUrl = imageUrl {
            try encodeContainer.encode(imageUrl, forKey: .imageUrl)
        }
        if let inboxCount = inboxCount {
            try encodeContainer.encode(inboxCount, forKey: .inboxCount)
        }
        if let lastSeenDateTime = lastSeenDateTime {
            try encodeContainer.encode(lastSeenDateTime.timeIntervalSince1970, forKey: .lastSeenDateTime)
        }
        if let projectedVolume = projectedVolume {
            try encodeContainer.encode(projectedVolume, forKey: .projectedVolume)
        }
        if let readDeleteRate = readDeleteRate {
            try encodeContainer.encode(readDeleteRate, forKey: .readDeleteRate)
        }
        if let readRate = readRate {
            try encodeContainer.encode(readRate, forKey: .readRate)
        }
        if let sendingIps = sendingIps {
            var sendingIpsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sendingIps)
            for iplist0 in sendingIps {
                try sendingIpsContainer.encode(iplist0)
            }
        }
        if let spamCount = spamCount {
            try encodeContainer.encode(spamCount, forKey: .spamCount)
        }
        if let subject = subject {
            try encodeContainer.encode(subject, forKey: .subject)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let campaignIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .campaignId)
        campaignId = campaignIdDecoded
        let imageUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .imageUrl)
        imageUrl = imageUrlDecoded
        let subjectDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subject)
        subject = subjectDecoded
        let fromAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fromAddress)
        fromAddress = fromAddressDecoded
        let sendingIpsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .sendingIps)
        var sendingIpsDecoded0:[String]? = nil
        if let sendingIpsContainer = sendingIpsContainer {
            sendingIpsDecoded0 = [String]()
            for string0 in sendingIpsContainer {
                if let string0 = string0 {
                    sendingIpsDecoded0?.append(string0)
                }
            }
        }
        sendingIps = sendingIpsDecoded0
        let firstSeenDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .firstSeenDateTime)
        firstSeenDateTime = firstSeenDateTimeDecoded
        let lastSeenDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastSeenDateTime)
        lastSeenDateTime = lastSeenDateTimeDecoded
        let inboxCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .inboxCount)
        inboxCount = inboxCountDecoded
        let spamCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .spamCount)
        spamCount = spamCountDecoded
        let readRateDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .readRate)
        readRate = readRateDecoded
        let deleteRateDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .deleteRate)
        deleteRate = deleteRateDecoded
        let readDeleteRateDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .readDeleteRate)
        readDeleteRate = readDeleteRateDecoded
        let projectedVolumeDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .projectedVolume)
        projectedVolume = projectedVolumeDecoded
        let espsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .esps)
        var espsDecoded0:[String]? = nil
        if let espsContainer = espsContainer {
            espsDecoded0 = [String]()
            for string0 in espsContainer {
                if let string0 = string0 {
                    espsDecoded0?.append(string0)
                }
            }
        }
        esps = espsDecoded0
    }
}

extension DomainDeliverabilityCampaign: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DomainDeliverabilityCampaign(campaignId: \(String(describing: campaignId)), deleteRate: \(String(describing: deleteRate)), esps: \(String(describing: esps)), firstSeenDateTime: \(String(describing: firstSeenDateTime)), fromAddress: \(String(describing: fromAddress)), imageUrl: \(String(describing: imageUrl)), inboxCount: \(String(describing: inboxCount)), lastSeenDateTime: \(String(describing: lastSeenDateTime)), projectedVolume: \(String(describing: projectedVolume)), readDeleteRate: \(String(describing: readDeleteRate)), readRate: \(String(describing: readRate)), sendingIps: \(String(describing: sendingIps)), spamCount: \(String(describing: spamCount)), subject: \(String(describing: subject)))"}
}

/// <p>An object that contains the deliverability data for a specific campaign. This data is
///             available for a campaign only if the campaign sent email by using a domain that the
///             Deliverability dashboard is enabled for (<code>PutDeliverabilityDashboardOption</code>
///             operation).</p>
public struct DomainDeliverabilityCampaign: Equatable {
    /// <p>The unique identifier for the campaign. Amazon Pinpoint automatically generates and assigns this
    ///             identifier to a campaign. This value is not the same as the campaign identifier that
    ///             Amazon Pinpoint assigns to campaigns that you create and manage by using the Amazon Pinpoint API or the
    ///             Amazon Pinpoint console.</p>
    public let campaignId: String?
    /// <p>The percentage of email messages that were deleted by recipients, without being opened
    ///             first. Due to technical limitations, this value only includes recipients who opened the
    ///             message by using an email client that supports images.</p>
    public let deleteRate: Double?
    /// <p>The major email providers who handled the email message.</p>
    public let esps: [String]?
    /// <p>The first time, in Unix time format, when the email message was delivered to any
    ///             recipient's inbox. This value can help you determine how long it took for a campaign to
    ///             deliver an email message.</p>
    public let firstSeenDateTime: Date?
    /// <p>The verified email address that the email message was sent from.</p>
    public let fromAddress: String?
    /// <p>The URL of an image that contains a snapshot of the email message that was
    ///             sent.</p>
    public let imageUrl: String?
    /// <p>The number of email messages that were delivered to recipients inboxes.</p>
    public let inboxCount: Int?
    /// <p>The last time, in Unix time format, when the email message was delivered to any
    ///             recipient's inbox. This value can help you determine how long it took for a campaign to
    ///             deliver an email message.</p>
    public let lastSeenDateTime: Date?
    /// <p>The projected number of recipients that the email message was sent to.</p>
    public let projectedVolume: Int?
    /// <p>The percentage of email messages that were opened and then deleted by recipients. Due
    ///             to technical limitations, this value only includes recipients who opened the message by
    ///             using an email client that supports images.</p>
    public let readDeleteRate: Double?
    /// <p>The percentage of email messages that were opened by recipients. Due to technical
    ///             limitations, this value only includes recipients who opened the message by using an
    ///             email client that supports images.</p>
    public let readRate: Double?
    /// <p>The IP addresses that were used to send the email message.</p>
    public let sendingIps: [String]?
    /// <p>The number of email messages that were delivered to recipients' spam or junk mail
    ///             folders.</p>
    public let spamCount: Int?
    /// <p>The subject line, or title, of the email message.</p>
    public let subject: String?

    public init (
        campaignId: String? = nil,
        deleteRate: Double? = nil,
        esps: [String]? = nil,
        firstSeenDateTime: Date? = nil,
        fromAddress: String? = nil,
        imageUrl: String? = nil,
        inboxCount: Int? = nil,
        lastSeenDateTime: Date? = nil,
        projectedVolume: Int? = nil,
        readDeleteRate: Double? = nil,
        readRate: Double? = nil,
        sendingIps: [String]? = nil,
        spamCount: Int? = nil,
        subject: String? = nil
    )
    {
        self.campaignId = campaignId
        self.deleteRate = deleteRate
        self.esps = esps
        self.firstSeenDateTime = firstSeenDateTime
        self.fromAddress = fromAddress
        self.imageUrl = imageUrl
        self.inboxCount = inboxCount
        self.lastSeenDateTime = lastSeenDateTime
        self.projectedVolume = projectedVolume
        self.readDeleteRate = readDeleteRate
        self.readRate = readRate
        self.sendingIps = sendingIps
        self.spamCount = spamCount
        self.subject = subject
    }
}

extension DomainDeliverabilityTrackingOption: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case domain = "Domain"
        case inboxPlacementTrackingOption = "InboxPlacementTrackingOption"
        case subscriptionStartDate = "SubscriptionStartDate"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domain = domain {
            try encodeContainer.encode(domain, forKey: .domain)
        }
        if let inboxPlacementTrackingOption = inboxPlacementTrackingOption {
            try encodeContainer.encode(inboxPlacementTrackingOption, forKey: .inboxPlacementTrackingOption)
        }
        if let subscriptionStartDate = subscriptionStartDate {
            try encodeContainer.encode(subscriptionStartDate.timeIntervalSince1970, forKey: .subscriptionStartDate)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domain)
        domain = domainDecoded
        let subscriptionStartDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .subscriptionStartDate)
        subscriptionStartDate = subscriptionStartDateDecoded
        let inboxPlacementTrackingOptionDecoded = try containerValues.decodeIfPresent(InboxPlacementTrackingOption.self, forKey: .inboxPlacementTrackingOption)
        inboxPlacementTrackingOption = inboxPlacementTrackingOptionDecoded
    }
}

extension DomainDeliverabilityTrackingOption: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DomainDeliverabilityTrackingOption(domain: \(String(describing: domain)), inboxPlacementTrackingOption: \(String(describing: inboxPlacementTrackingOption)), subscriptionStartDate: \(String(describing: subscriptionStartDate)))"}
}

/// <p>An object that contains information about the Deliverability dashboard subscription for a
///             verified domain that you use to send email and currently has an active Deliverability dashboard
///             subscription. If a Deliverability dashboard subscription is active for a domain, you gain access
///             to reputation, inbox placement, and other metrics for the domain.</p>
public struct DomainDeliverabilityTrackingOption: Equatable {
    /// <p>A verified domain thats associated with your AWS account and currently has an
    ///             active Deliverability dashboard subscription.</p>
    public let domain: String?
    /// <p>An object that contains information about the inbox placement data settings for the
    ///             domain.</p>
    public let inboxPlacementTrackingOption: InboxPlacementTrackingOption?
    /// <p>The date, in Unix time format, when you enabled the Deliverability dashboard for the
    ///             domain.</p>
    public let subscriptionStartDate: Date?

    public init (
        domain: String? = nil,
        inboxPlacementTrackingOption: InboxPlacementTrackingOption? = nil,
        subscriptionStartDate: Date? = nil
    )
    {
        self.domain = domain
        self.inboxPlacementTrackingOption = inboxPlacementTrackingOption
        self.subscriptionStartDate = subscriptionStartDate
    }
}

extension DomainIspPlacement: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case inboxPercentage = "InboxPercentage"
        case inboxRawCount = "InboxRawCount"
        case ispName = "IspName"
        case spamPercentage = "SpamPercentage"
        case spamRawCount = "SpamRawCount"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inboxPercentage = inboxPercentage {
            try encodeContainer.encode(inboxPercentage, forKey: .inboxPercentage)
        }
        if let inboxRawCount = inboxRawCount {
            try encodeContainer.encode(inboxRawCount, forKey: .inboxRawCount)
        }
        if let ispName = ispName {
            try encodeContainer.encode(ispName, forKey: .ispName)
        }
        if let spamPercentage = spamPercentage {
            try encodeContainer.encode(spamPercentage, forKey: .spamPercentage)
        }
        if let spamRawCount = spamRawCount {
            try encodeContainer.encode(spamRawCount, forKey: .spamRawCount)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ispNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ispName)
        ispName = ispNameDecoded
        let inboxRawCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .inboxRawCount)
        inboxRawCount = inboxRawCountDecoded
        let spamRawCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .spamRawCount)
        spamRawCount = spamRawCountDecoded
        let inboxPercentageDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .inboxPercentage)
        inboxPercentage = inboxPercentageDecoded
        let spamPercentageDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .spamPercentage)
        spamPercentage = spamPercentageDecoded
    }
}

extension DomainIspPlacement: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DomainIspPlacement(inboxPercentage: \(String(describing: inboxPercentage)), inboxRawCount: \(String(describing: inboxRawCount)), ispName: \(String(describing: ispName)), spamPercentage: \(String(describing: spamPercentage)), spamRawCount: \(String(describing: spamRawCount)))"}
}

/// <p>An object that contains inbox placement data for email sent from one of your email
///             domains to a specific email provider.</p>
public struct DomainIspPlacement: Equatable {
    /// <p>The percentage of messages that were sent from the selected domain to the specified
    ///             email provider that arrived in recipients' inboxes.</p>
    public let inboxPercentage: Double?
    /// <p>The total number of messages that were sent from the selected domain to the specified
    ///             email provider that arrived in recipients' inboxes.</p>
    public let inboxRawCount: Int?
    /// <p>The name of the email provider that the inbox placement data applies to.</p>
    public let ispName: String?
    /// <p>The percentage of messages that were sent from the selected domain to the specified
    ///             email provider that arrived in recipients' spam or junk mail folders.</p>
    public let spamPercentage: Double?
    /// <p>The total number of messages that were sent from the selected domain to the specified
    ///             email provider that arrived in recipients' spam or junk mail folders.</p>
    public let spamRawCount: Int?

    public init (
        inboxPercentage: Double? = nil,
        inboxRawCount: Int? = nil,
        ispName: String? = nil,
        spamPercentage: Double? = nil,
        spamRawCount: Int? = nil
    )
    {
        self.inboxPercentage = inboxPercentage
        self.inboxRawCount = inboxRawCount
        self.ispName = ispName
        self.spamPercentage = spamPercentage
        self.spamRawCount = spamRawCount
    }
}

extension EmailContent: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case raw = "Raw"
        case simple = "Simple"
        case template = "Template"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let raw = raw {
            try encodeContainer.encode(raw, forKey: .raw)
        }
        if let simple = simple {
            try encodeContainer.encode(simple, forKey: .simple)
        }
        if let template = template {
            try encodeContainer.encode(template, forKey: .template)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let simpleDecoded = try containerValues.decodeIfPresent(Message.self, forKey: .simple)
        simple = simpleDecoded
        let rawDecoded = try containerValues.decodeIfPresent(RawMessage.self, forKey: .raw)
        raw = rawDecoded
        let templateDecoded = try containerValues.decodeIfPresent(Template.self, forKey: .template)
        template = templateDecoded
    }
}

extension EmailContent: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EmailContent(raw: \(String(describing: raw)), simple: \(String(describing: simple)), template: \(String(describing: template)))"}
}

/// <p>An object that defines the entire content of the email, including the message headers
///             and the body content. You can create a simple email message, in which you specify the
///             subject and the text and HTML versions of the message body. You can also create raw
///             messages, in which you specify a complete MIME-formatted message. Raw messages can
///             include attachments and custom headers.</p>
public struct EmailContent: Equatable {
    /// <p>The raw email message. The message has to meet the following criteria:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>The message has to contain a header and a body, separated by one blank
    ///                     line.</p>
    ///             </li>
    ///             <li>
    ///                 <p>All of the required header fields must be present in the message.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Each part of a multipart MIME message must be formatted properly.</p>
    ///             </li>
    ///             <li>
    ///                 <p>If you include attachments, they must be in a file format that Amazon Pinpoint supports.
    ///                     </p>
    ///             </li>
    ///             <li>
    ///                 <p>The entire message must be Base64 encoded.</p>
    ///             </li>
    ///             <li>
    ///                 <p>If any of the MIME parts in your message contain content that is outside of
    ///                     the 7-bit ASCII character range, you should encode that content to ensure that
    ///                     recipients' email clients render the message properly.</p>
    ///             </li>
    ///             <li>
    ///                 <p>The length of any single line of text in the message can't exceed 1,000
    ///                     characters. This restriction is defined in <a href="https://tools.ietf.org/html/rfc5321">RFC 5321</a>.</p>
    ///             </li>
    ///          </ul>
    public let raw: RawMessage?
    /// <p>The simple email message. The message consists of a subject and a message body.</p>
    public let simple: Message?
    /// <p>The template to use for the email message.</p>
    public let template: Template?

    public init (
        raw: RawMessage? = nil,
        simple: Message? = nil,
        template: Template? = nil
    )
    {
        self.raw = raw
        self.simple = simple
        self.template = template
    }
}

extension EventDestination: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cloudWatchDestination = "CloudWatchDestination"
        case enabled = "Enabled"
        case kinesisFirehoseDestination = "KinesisFirehoseDestination"
        case matchingEventTypes = "MatchingEventTypes"
        case name = "Name"
        case pinpointDestination = "PinpointDestination"
        case snsDestination = "SnsDestination"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudWatchDestination = cloudWatchDestination {
            try encodeContainer.encode(cloudWatchDestination, forKey: .cloudWatchDestination)
        }
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let kinesisFirehoseDestination = kinesisFirehoseDestination {
            try encodeContainer.encode(kinesisFirehoseDestination, forKey: .kinesisFirehoseDestination)
        }
        if let matchingEventTypes = matchingEventTypes {
            var matchingEventTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .matchingEventTypes)
            for eventtypes0 in matchingEventTypes {
                try matchingEventTypesContainer.encode(eventtypes0.rawValue)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let pinpointDestination = pinpointDestination {
            try encodeContainer.encode(pinpointDestination, forKey: .pinpointDestination)
        }
        if let snsDestination = snsDestination {
            try encodeContainer.encode(snsDestination, forKey: .snsDestination)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let enabledDecoded = try containerValues.decode(Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let matchingEventTypesContainer = try containerValues.decodeIfPresent([EventType?].self, forKey: .matchingEventTypes)
        var matchingEventTypesDecoded0:[EventType]? = nil
        if let matchingEventTypesContainer = matchingEventTypesContainer {
            matchingEventTypesDecoded0 = [EventType]()
            for string0 in matchingEventTypesContainer {
                if let string0 = string0 {
                    matchingEventTypesDecoded0?.append(string0)
                }
            }
        }
        matchingEventTypes = matchingEventTypesDecoded0
        let kinesisFirehoseDestinationDecoded = try containerValues.decodeIfPresent(KinesisFirehoseDestination.self, forKey: .kinesisFirehoseDestination)
        kinesisFirehoseDestination = kinesisFirehoseDestinationDecoded
        let cloudWatchDestinationDecoded = try containerValues.decodeIfPresent(CloudWatchDestination.self, forKey: .cloudWatchDestination)
        cloudWatchDestination = cloudWatchDestinationDecoded
        let snsDestinationDecoded = try containerValues.decodeIfPresent(SnsDestination.self, forKey: .snsDestination)
        snsDestination = snsDestinationDecoded
        let pinpointDestinationDecoded = try containerValues.decodeIfPresent(PinpointDestination.self, forKey: .pinpointDestination)
        pinpointDestination = pinpointDestinationDecoded
    }
}

extension EventDestination: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EventDestination(cloudWatchDestination: \(String(describing: cloudWatchDestination)), enabled: \(String(describing: enabled)), kinesisFirehoseDestination: \(String(describing: kinesisFirehoseDestination)), matchingEventTypes: \(String(describing: matchingEventTypes)), name: \(String(describing: name)), pinpointDestination: \(String(describing: pinpointDestination)), snsDestination: \(String(describing: snsDestination)))"}
}

/// <p>In Amazon Pinpoint, <i>events</i> include message sends, deliveries, opens,
///             clicks, bounces, and complaints. <i>Event destinations</i> are places that
///             you can send information about these events to. For example, you can send event data to
///             Amazon SNS to receive notifications when you receive bounces or complaints, or you can use
///             Amazon Kinesis Data Firehose to stream data to Amazon S3 for long-term storage.</p>
public struct EventDestination: Equatable {
    /// <p>An object that defines an Amazon CloudWatch destination for email events. You can use Amazon CloudWatch to
    ///             monitor and gain insights on your email sending metrics.</p>
    public let cloudWatchDestination: CloudWatchDestination?
    /// <p>If <code>true</code>, the event destination is enabled. When the event destination is
    ///             enabled, the specified event types are sent to the destinations in this
    ///                 <code>EventDestinationDefinition</code>.</p>
    ///         <p>If <code>false</code>, the event destination is disabled. When the event destination
    ///             is disabled, events aren't sent to the specified destinations.</p>
    public let enabled: Bool
    /// <p>An object that defines an Amazon Kinesis Data Firehose destination for email events. You can use Amazon Kinesis Data Firehose to
    ///             stream data to other services, such as Amazon S3 and Amazon Redshift.</p>
    public let kinesisFirehoseDestination: KinesisFirehoseDestination?
    /// <p>The types of events that Amazon Pinpoint sends to the specified event destinations.</p>
    public let matchingEventTypes: [EventType]?
    /// <p>A name that identifies the event destination.</p>
    public let name: String?
    /// <p>An object that defines a Amazon Pinpoint destination for email events. You can use Amazon Pinpoint events
    ///             to create attributes in Amazon Pinpoint projects. You can use these attributes to create segments
    ///             for your campaigns.</p>
    public let pinpointDestination: PinpointDestination?
    /// <p>An object that defines an Amazon SNS destination for email events. You can use Amazon SNS to
    ///             send notification when certain email events occur.</p>
    public let snsDestination: SnsDestination?

    public init (
        cloudWatchDestination: CloudWatchDestination? = nil,
        enabled: Bool = false,
        kinesisFirehoseDestination: KinesisFirehoseDestination? = nil,
        matchingEventTypes: [EventType]? = nil,
        name: String? = nil,
        pinpointDestination: PinpointDestination? = nil,
        snsDestination: SnsDestination? = nil
    )
    {
        self.cloudWatchDestination = cloudWatchDestination
        self.enabled = enabled
        self.kinesisFirehoseDestination = kinesisFirehoseDestination
        self.matchingEventTypes = matchingEventTypes
        self.name = name
        self.pinpointDestination = pinpointDestination
        self.snsDestination = snsDestination
    }
}

extension EventDestinationDefinition: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cloudWatchDestination = "CloudWatchDestination"
        case enabled = "Enabled"
        case kinesisFirehoseDestination = "KinesisFirehoseDestination"
        case matchingEventTypes = "MatchingEventTypes"
        case pinpointDestination = "PinpointDestination"
        case snsDestination = "SnsDestination"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudWatchDestination = cloudWatchDestination {
            try encodeContainer.encode(cloudWatchDestination, forKey: .cloudWatchDestination)
        }
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let kinesisFirehoseDestination = kinesisFirehoseDestination {
            try encodeContainer.encode(kinesisFirehoseDestination, forKey: .kinesisFirehoseDestination)
        }
        if let matchingEventTypes = matchingEventTypes {
            var matchingEventTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .matchingEventTypes)
            for eventtypes0 in matchingEventTypes {
                try matchingEventTypesContainer.encode(eventtypes0.rawValue)
            }
        }
        if let pinpointDestination = pinpointDestination {
            try encodeContainer.encode(pinpointDestination, forKey: .pinpointDestination)
        }
        if let snsDestination = snsDestination {
            try encodeContainer.encode(snsDestination, forKey: .snsDestination)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decode(Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let matchingEventTypesContainer = try containerValues.decodeIfPresent([EventType?].self, forKey: .matchingEventTypes)
        var matchingEventTypesDecoded0:[EventType]? = nil
        if let matchingEventTypesContainer = matchingEventTypesContainer {
            matchingEventTypesDecoded0 = [EventType]()
            for string0 in matchingEventTypesContainer {
                if let string0 = string0 {
                    matchingEventTypesDecoded0?.append(string0)
                }
            }
        }
        matchingEventTypes = matchingEventTypesDecoded0
        let kinesisFirehoseDestinationDecoded = try containerValues.decodeIfPresent(KinesisFirehoseDestination.self, forKey: .kinesisFirehoseDestination)
        kinesisFirehoseDestination = kinesisFirehoseDestinationDecoded
        let cloudWatchDestinationDecoded = try containerValues.decodeIfPresent(CloudWatchDestination.self, forKey: .cloudWatchDestination)
        cloudWatchDestination = cloudWatchDestinationDecoded
        let snsDestinationDecoded = try containerValues.decodeIfPresent(SnsDestination.self, forKey: .snsDestination)
        snsDestination = snsDestinationDecoded
        let pinpointDestinationDecoded = try containerValues.decodeIfPresent(PinpointDestination.self, forKey: .pinpointDestination)
        pinpointDestination = pinpointDestinationDecoded
    }
}

extension EventDestinationDefinition: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EventDestinationDefinition(cloudWatchDestination: \(String(describing: cloudWatchDestination)), enabled: \(String(describing: enabled)), kinesisFirehoseDestination: \(String(describing: kinesisFirehoseDestination)), matchingEventTypes: \(String(describing: matchingEventTypes)), pinpointDestination: \(String(describing: pinpointDestination)), snsDestination: \(String(describing: snsDestination)))"}
}

/// <p>An object that defines the event destination. Specifically, it defines which services
///             receive events from emails sent using the configuration set that the event destination
///             is associated with. Also defines the types of events that are sent to the event
///             destination.</p>
public struct EventDestinationDefinition: Equatable {
    /// <p>An object that defines an Amazon CloudWatch destination for email events. You can use Amazon CloudWatch to
    ///             monitor and gain insights on your email sending metrics.</p>
    public let cloudWatchDestination: CloudWatchDestination?
    /// <p>If <code>true</code>, the event destination is enabled. When the event destination is
    ///             enabled, the specified event types are sent to the destinations in this
    ///                 <code>EventDestinationDefinition</code>.</p>
    ///         <p>If <code>false</code>, the event destination is disabled. When the event destination
    ///             is disabled, events aren't sent to the specified destinations.</p>
    public let enabled: Bool
    /// <p>An object that defines an Amazon Kinesis Data Firehose destination for email events. You can use Amazon Kinesis Data Firehose to
    ///             stream data to other services, such as Amazon S3 and Amazon Redshift.</p>
    public let kinesisFirehoseDestination: KinesisFirehoseDestination?
    /// <p>An array that specifies which events Amazon Pinpoint should send to the destinations in this
    ///                 <code>EventDestinationDefinition</code>.</p>
    public let matchingEventTypes: [EventType]?
    /// <p>An object that defines a Amazon Pinpoint destination for email events. You can use Amazon Pinpoint events
    ///             to create attributes in Amazon Pinpoint projects. You can use these attributes to create segments
    ///             for your campaigns.</p>
    public let pinpointDestination: PinpointDestination?
    /// <p>An object that defines an Amazon SNS destination for email events. You can use Amazon SNS to
    ///             send notification when certain email events occur.</p>
    public let snsDestination: SnsDestination?

    public init (
        cloudWatchDestination: CloudWatchDestination? = nil,
        enabled: Bool = false,
        kinesisFirehoseDestination: KinesisFirehoseDestination? = nil,
        matchingEventTypes: [EventType]? = nil,
        pinpointDestination: PinpointDestination? = nil,
        snsDestination: SnsDestination? = nil
    )
    {
        self.cloudWatchDestination = cloudWatchDestination
        self.enabled = enabled
        self.kinesisFirehoseDestination = kinesisFirehoseDestination
        self.matchingEventTypes = matchingEventTypes
        self.pinpointDestination = pinpointDestination
        self.snsDestination = snsDestination
    }
}

/// <p>An email sending event type. For example, email sends, opens, and bounces are all
///             email events.</p>
public enum EventType {
    case bounce
    case click
    case complaint
    case delivery
    case `open`
    case reject
    case renderingFailure
    case send
    case sdkUnknown(String)
}

extension EventType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [EventType] {
        return [
            .bounce,
            .click,
            .complaint,
            .delivery,
            .open,
            .reject,
            .renderingFailure,
            .send,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .bounce: return "BOUNCE"
        case .click: return "CLICK"
        case .complaint: return "COMPLAINT"
        case .delivery: return "DELIVERY"
        case .open: return "OPEN"
        case .reject: return "REJECT"
        case .renderingFailure: return "RENDERING_FAILURE"
        case .send: return "SEND"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = EventType(rawValue: rawValue) ?? EventType.sdkUnknown(rawValue)
    }
}

extension GetAccountInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAccountInput()"}
}

extension GetAccountInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetAccountInputHeadersMiddleware: Middleware {
    public let id: String = "GetAccountInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAccountInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAccountInput>
    public typealias MOutput = OperationOutput<GetAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAccountOutputError>
}

public struct GetAccountInputQueryItemMiddleware: Middleware {
    public let id: String = "GetAccountInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAccountInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAccountInput>
    public typealias MOutput = OperationOutput<GetAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAccountOutputError>
}

/// <p>A request to obtain information about the email-sending capabilities of your Amazon Pinpoint
///             account.</p>
public struct GetAccountInput: Equatable {

    public init() {}
}

struct GetAccountInputBody: Equatable {
}

extension GetAccountInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetAccountOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAccountOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAccountOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAccountOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAccountOutputResponse(dedicatedIpAutoWarmupEnabled: \(String(describing: dedicatedIpAutoWarmupEnabled)), enforcementStatus: \(String(describing: enforcementStatus)), productionAccessEnabled: \(String(describing: productionAccessEnabled)), sendQuota: \(String(describing: sendQuota)), sendingEnabled: \(String(describing: sendingEnabled)))"}
}

extension GetAccountOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetAccountOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dedicatedIpAutoWarmupEnabled = output.dedicatedIpAutoWarmupEnabled
            self.enforcementStatus = output.enforcementStatus
            self.productionAccessEnabled = output.productionAccessEnabled
            self.sendQuota = output.sendQuota
            self.sendingEnabled = output.sendingEnabled
        } else {
            self.dedicatedIpAutoWarmupEnabled = false
            self.enforcementStatus = nil
            self.productionAccessEnabled = false
            self.sendQuota = nil
            self.sendingEnabled = false
        }
    }
}

/// <p>A list of details about the email-sending capabilities of your Amazon Pinpoint account in the
///             current AWS Region.</p>
public struct GetAccountOutputResponse: Equatable {
    /// <p>Indicates whether or not the automatic warm-up feature is enabled for dedicated IP
    ///             addresses that are associated with your account.</p>
    public let dedicatedIpAutoWarmupEnabled: Bool
    /// <p>The reputation status of your Amazon Pinpoint account. The status can be one of the
    ///             following:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <code>HEALTHY</code>  There are no reputation-related issues that
    ///                     currently impact your account.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>PROBATION</code>  We've identified some issues with your Amazon Pinpoint
    ///                     account. We're placing your account under review while you work on correcting
    ///                     these issues.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>SHUTDOWN</code>  Your account's ability to send email is
    ///                     currently paused because of an issue with the email sent from your account. When
    ///                     you correct the issue, you can contact us and request that your account's
    ///                     ability to send email is resumed.</p>
    ///             </li>
    ///          </ul>
    public let enforcementStatus: String?
    /// <p>Indicates whether or not your account has production access in the current AWS
    ///             Region.</p>
    ///         <p>If the value is <code>false</code>, then your account is in the
    ///                 <i>sandbox</i>. When your account is in the sandbox, you can only send
    ///             email to verified identities. Additionally, the maximum number of emails you can send in
    ///             a 24-hour period (your sending quota) is 200, and the maximum number of emails you can
    ///             send per second (your maximum sending rate) is 1.</p>
    ///         <p>If the value is <code>true</code>, then your account has production access. When your
    ///             account has production access, you can send email to any address. The sending quota and
    ///             maximum sending rate for your account vary based on your specific use case.</p>
    public let productionAccessEnabled: Bool
    /// <p>An object that contains information about the per-day and per-second sending limits
    ///             for your Amazon Pinpoint account in the current AWS Region.</p>
    public let sendQuota: SendQuota?
    /// <p>Indicates whether or not email sending is enabled for your Amazon Pinpoint account in the
    ///             current AWS Region.</p>
    public let sendingEnabled: Bool

    public init (
        dedicatedIpAutoWarmupEnabled: Bool = false,
        enforcementStatus: String? = nil,
        productionAccessEnabled: Bool = false,
        sendQuota: SendQuota? = nil,
        sendingEnabled: Bool = false
    )
    {
        self.dedicatedIpAutoWarmupEnabled = dedicatedIpAutoWarmupEnabled
        self.enforcementStatus = enforcementStatus
        self.productionAccessEnabled = productionAccessEnabled
        self.sendQuota = sendQuota
        self.sendingEnabled = sendingEnabled
    }
}

struct GetAccountOutputResponseBody: Equatable {
    public let sendQuota: SendQuota?
    public let sendingEnabled: Bool
    public let dedicatedIpAutoWarmupEnabled: Bool
    public let enforcementStatus: String?
    public let productionAccessEnabled: Bool
}

extension GetAccountOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dedicatedIpAutoWarmupEnabled = "DedicatedIpAutoWarmupEnabled"
        case enforcementStatus = "EnforcementStatus"
        case productionAccessEnabled = "ProductionAccessEnabled"
        case sendQuota = "SendQuota"
        case sendingEnabled = "SendingEnabled"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sendQuotaDecoded = try containerValues.decodeIfPresent(SendQuota.self, forKey: .sendQuota)
        sendQuota = sendQuotaDecoded
        let sendingEnabledDecoded = try containerValues.decode(Bool.self, forKey: .sendingEnabled)
        sendingEnabled = sendingEnabledDecoded
        let dedicatedIpAutoWarmupEnabledDecoded = try containerValues.decode(Bool.self, forKey: .dedicatedIpAutoWarmupEnabled)
        dedicatedIpAutoWarmupEnabled = dedicatedIpAutoWarmupEnabledDecoded
        let enforcementStatusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .enforcementStatus)
        enforcementStatus = enforcementStatusDecoded
        let productionAccessEnabledDecoded = try containerValues.decode(Bool.self, forKey: .productionAccessEnabled)
        productionAccessEnabled = productionAccessEnabledDecoded
    }
}

extension GetBlacklistReportsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetBlacklistReportsInput(blacklistItemNames: \(String(describing: blacklistItemNames)))"}
}

extension GetBlacklistReportsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetBlacklistReportsInputHeadersMiddleware: Middleware {
    public let id: String = "GetBlacklistReportsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetBlacklistReportsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetBlacklistReportsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetBlacklistReportsInput>
    public typealias MOutput = OperationOutput<GetBlacklistReportsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetBlacklistReportsOutputError>
}

public struct GetBlacklistReportsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetBlacklistReportsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetBlacklistReportsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetBlacklistReportsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let blacklistItemNames = input.operationInput.blacklistItemNames {
            blacklistItemNames.forEach { queryItemValue in
                let queryItem = URLQueryItem(name: "BlacklistItemNames".urlPercentEncoding(), value: String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetBlacklistReportsInput>
    public typealias MOutput = OperationOutput<GetBlacklistReportsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetBlacklistReportsOutputError>
}

/// <p>A request to retrieve a list of the blacklists that your dedicated IP addresses appear
///             on.</p>
public struct GetBlacklistReportsInput: Equatable {
    /// <p>A list of IP addresses that you want to retrieve blacklist information about. You can
    ///             only specify the dedicated IP addresses that you use to send email using Amazon Pinpoint or
    ///             Amazon SES.</p>
    public let blacklistItemNames: [String]?

    public init (
        blacklistItemNames: [String]? = nil
    )
    {
        self.blacklistItemNames = blacklistItemNames
    }
}

struct GetBlacklistReportsInputBody: Equatable {
}

extension GetBlacklistReportsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetBlacklistReportsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetBlacklistReportsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetBlacklistReportsOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetBlacklistReportsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetBlacklistReportsOutputResponse(blacklistReport: \(String(describing: blacklistReport)))"}
}

extension GetBlacklistReportsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetBlacklistReportsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.blacklistReport = output.blacklistReport
        } else {
            self.blacklistReport = nil
        }
    }
}

/// <p>An object that contains information about blacklist events.</p>
public struct GetBlacklistReportsOutputResponse: Equatable {
    /// <p>An object that contains information about a blacklist that one of your dedicated IP
    ///             addresses appears on.</p>
    public let blacklistReport: [String:[BlacklistEntry]]?

    public init (
        blacklistReport: [String:[BlacklistEntry]]? = nil
    )
    {
        self.blacklistReport = blacklistReport
    }
}

struct GetBlacklistReportsOutputResponseBody: Equatable {
    public let blacklistReport: [String:[BlacklistEntry]]?
}

extension GetBlacklistReportsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case blacklistReport = "BlacklistReport"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let blacklistReportContainer = try containerValues.decodeIfPresent([String: [BlacklistEntry?]?].self, forKey: .blacklistReport)
        var blacklistReportDecoded0: [String:[BlacklistEntry]]? = nil
        if let blacklistReportContainer = blacklistReportContainer {
            blacklistReportDecoded0 = [String:[BlacklistEntry]]()
            for (key0, blacklistentries0) in blacklistReportContainer {
                var blacklistentries0Decoded0: [BlacklistEntry]? = nil
                if let blacklistentries0 = blacklistentries0 {
                    blacklistentries0Decoded0 = [BlacklistEntry]()
                    for structure1 in blacklistentries0 {
                        if let structure1 = structure1 {
                            blacklistentries0Decoded0?.append(structure1)
                        }
                    }
                }
                blacklistReportDecoded0?[key0] = blacklistentries0Decoded0
            }
        }
        blacklistReport = blacklistReportDecoded0
    }
}

extension GetConfigurationSetEventDestinationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetConfigurationSetEventDestinationsInput(configurationSetName: \(String(describing: configurationSetName)))"}
}

extension GetConfigurationSetEventDestinationsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetConfigurationSetEventDestinationsInputHeadersMiddleware: Middleware {
    public let id: String = "GetConfigurationSetEventDestinationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetConfigurationSetEventDestinationsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetConfigurationSetEventDestinationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetConfigurationSetEventDestinationsInput>
    public typealias MOutput = OperationOutput<GetConfigurationSetEventDestinationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetConfigurationSetEventDestinationsOutputError>
}

public struct GetConfigurationSetEventDestinationsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetConfigurationSetEventDestinationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetConfigurationSetEventDestinationsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetConfigurationSetEventDestinationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetConfigurationSetEventDestinationsInput>
    public typealias MOutput = OperationOutput<GetConfigurationSetEventDestinationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetConfigurationSetEventDestinationsOutputError>
}

/// <p>A request to obtain information about the event destinations for a configuration
///             set.</p>
public struct GetConfigurationSetEventDestinationsInput: Equatable {
    /// <p>The name of the configuration set that contains the event destination.</p>
    public let configurationSetName: String?

    public init (
        configurationSetName: String? = nil
    )
    {
        self.configurationSetName = configurationSetName
    }
}

struct GetConfigurationSetEventDestinationsInputBody: Equatable {
}

extension GetConfigurationSetEventDestinationsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetConfigurationSetEventDestinationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetConfigurationSetEventDestinationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetConfigurationSetEventDestinationsOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetConfigurationSetEventDestinationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetConfigurationSetEventDestinationsOutputResponse(eventDestinations: \(String(describing: eventDestinations)))"}
}

extension GetConfigurationSetEventDestinationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetConfigurationSetEventDestinationsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.eventDestinations = output.eventDestinations
        } else {
            self.eventDestinations = nil
        }
    }
}

/// <p>Information about an event destination for a configuration set.</p>
public struct GetConfigurationSetEventDestinationsOutputResponse: Equatable {
    /// <p>An array that includes all of the events destinations that have been configured for
    ///             the configuration set.</p>
    public let eventDestinations: [EventDestination]?

    public init (
        eventDestinations: [EventDestination]? = nil
    )
    {
        self.eventDestinations = eventDestinations
    }
}

struct GetConfigurationSetEventDestinationsOutputResponseBody: Equatable {
    public let eventDestinations: [EventDestination]?
}

extension GetConfigurationSetEventDestinationsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case eventDestinations = "EventDestinations"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventDestinationsContainer = try containerValues.decodeIfPresent([EventDestination?].self, forKey: .eventDestinations)
        var eventDestinationsDecoded0:[EventDestination]? = nil
        if let eventDestinationsContainer = eventDestinationsContainer {
            eventDestinationsDecoded0 = [EventDestination]()
            for structure0 in eventDestinationsContainer {
                if let structure0 = structure0 {
                    eventDestinationsDecoded0?.append(structure0)
                }
            }
        }
        eventDestinations = eventDestinationsDecoded0
    }
}

extension GetConfigurationSetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetConfigurationSetInput(configurationSetName: \(String(describing: configurationSetName)))"}
}

extension GetConfigurationSetInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetConfigurationSetInputHeadersMiddleware: Middleware {
    public let id: String = "GetConfigurationSetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetConfigurationSetInput>,
                  next: H) -> Swift.Result<OperationOutput<GetConfigurationSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetConfigurationSetInput>
    public typealias MOutput = OperationOutput<GetConfigurationSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetConfigurationSetOutputError>
}

public struct GetConfigurationSetInputQueryItemMiddleware: Middleware {
    public let id: String = "GetConfigurationSetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetConfigurationSetInput>,
                  next: H) -> Swift.Result<OperationOutput<GetConfigurationSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetConfigurationSetInput>
    public typealias MOutput = OperationOutput<GetConfigurationSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetConfigurationSetOutputError>
}

/// <p>A request to obtain information about a configuration set.</p>
public struct GetConfigurationSetInput: Equatable {
    /// <p>The name of the configuration set that you want to obtain more information
    ///             about.</p>
    public let configurationSetName: String?

    public init (
        configurationSetName: String? = nil
    )
    {
        self.configurationSetName = configurationSetName
    }
}

struct GetConfigurationSetInputBody: Equatable {
}

extension GetConfigurationSetInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetConfigurationSetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetConfigurationSetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetConfigurationSetOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetConfigurationSetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetConfigurationSetOutputResponse(configurationSetName: \(String(describing: configurationSetName)), deliveryOptions: \(String(describing: deliveryOptions)), reputationOptions: \(String(describing: reputationOptions)), sendingOptions: \(String(describing: sendingOptions)), tags: \(String(describing: tags)), trackingOptions: \(String(describing: trackingOptions)))"}
}

extension GetConfigurationSetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetConfigurationSetOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.configurationSetName = output.configurationSetName
            self.deliveryOptions = output.deliveryOptions
            self.reputationOptions = output.reputationOptions
            self.sendingOptions = output.sendingOptions
            self.tags = output.tags
            self.trackingOptions = output.trackingOptions
        } else {
            self.configurationSetName = nil
            self.deliveryOptions = nil
            self.reputationOptions = nil
            self.sendingOptions = nil
            self.tags = nil
            self.trackingOptions = nil
        }
    }
}

/// <p>Information about a configuration set.</p>
public struct GetConfigurationSetOutputResponse: Equatable {
    /// <p>The name of the configuration set.</p>
    public let configurationSetName: String?
    /// <p>An object that defines the dedicated IP pool that is used to send emails that you send
    ///             using the configuration set.</p>
    public let deliveryOptions: DeliveryOptions?
    /// <p>An object that defines whether or not Amazon Pinpoint collects reputation metrics for the emails
    ///             that you send that use the configuration set.</p>
    public let reputationOptions: ReputationOptions?
    /// <p>An object that defines whether or not Amazon Pinpoint can send email that you send using the
    ///             configuration set.</p>
    public let sendingOptions: SendingOptions?
    /// <p>An array of objects that define the tags (keys and values) that are associated with
    ///             the configuration set.</p>
    public let tags: [Tag]?
    /// <p>An object that defines the open and click tracking options for emails that you send
    ///             using the configuration set.</p>
    public let trackingOptions: TrackingOptions?

    public init (
        configurationSetName: String? = nil,
        deliveryOptions: DeliveryOptions? = nil,
        reputationOptions: ReputationOptions? = nil,
        sendingOptions: SendingOptions? = nil,
        tags: [Tag]? = nil,
        trackingOptions: TrackingOptions? = nil
    )
    {
        self.configurationSetName = configurationSetName
        self.deliveryOptions = deliveryOptions
        self.reputationOptions = reputationOptions
        self.sendingOptions = sendingOptions
        self.tags = tags
        self.trackingOptions = trackingOptions
    }
}

struct GetConfigurationSetOutputResponseBody: Equatable {
    public let configurationSetName: String?
    public let trackingOptions: TrackingOptions?
    public let deliveryOptions: DeliveryOptions?
    public let reputationOptions: ReputationOptions?
    public let sendingOptions: SendingOptions?
    public let tags: [Tag]?
}

extension GetConfigurationSetOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case configurationSetName = "ConfigurationSetName"
        case deliveryOptions = "DeliveryOptions"
        case reputationOptions = "ReputationOptions"
        case sendingOptions = "SendingOptions"
        case tags = "Tags"
        case trackingOptions = "TrackingOptions"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationSetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .configurationSetName)
        configurationSetName = configurationSetNameDecoded
        let trackingOptionsDecoded = try containerValues.decodeIfPresent(TrackingOptions.self, forKey: .trackingOptions)
        trackingOptions = trackingOptionsDecoded
        let deliveryOptionsDecoded = try containerValues.decodeIfPresent(DeliveryOptions.self, forKey: .deliveryOptions)
        deliveryOptions = deliveryOptionsDecoded
        let reputationOptionsDecoded = try containerValues.decodeIfPresent(ReputationOptions.self, forKey: .reputationOptions)
        reputationOptions = reputationOptionsDecoded
        let sendingOptionsDecoded = try containerValues.decodeIfPresent(SendingOptions.self, forKey: .sendingOptions)
        sendingOptions = sendingOptionsDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension GetDedicatedIpInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDedicatedIpInput(ip: \(String(describing: ip)))"}
}

extension GetDedicatedIpInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetDedicatedIpInputHeadersMiddleware: Middleware {
    public let id: String = "GetDedicatedIpInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDedicatedIpInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDedicatedIpOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDedicatedIpInput>
    public typealias MOutput = OperationOutput<GetDedicatedIpOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDedicatedIpOutputError>
}

public struct GetDedicatedIpInputQueryItemMiddleware: Middleware {
    public let id: String = "GetDedicatedIpInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDedicatedIpInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDedicatedIpOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDedicatedIpInput>
    public typealias MOutput = OperationOutput<GetDedicatedIpOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDedicatedIpOutputError>
}

/// <p>A request to obtain more information about a dedicated IP address.</p>
public struct GetDedicatedIpInput: Equatable {
    /// <p>The IP address that you want to obtain more information about. The value you specify
    ///             has to be a dedicated IP address that's assocaited with your Amazon Pinpoint account.</p>
    public let ip: String?

    public init (
        ip: String? = nil
    )
    {
        self.ip = ip
    }
}

struct GetDedicatedIpInputBody: Equatable {
}

extension GetDedicatedIpInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetDedicatedIpOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDedicatedIpOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDedicatedIpOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDedicatedIpOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDedicatedIpOutputResponse(dedicatedIp: \(String(describing: dedicatedIp)))"}
}

extension GetDedicatedIpOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetDedicatedIpOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dedicatedIp = output.dedicatedIp
        } else {
            self.dedicatedIp = nil
        }
    }
}

/// <p>Information about a dedicated IP address.</p>
public struct GetDedicatedIpOutputResponse: Equatable {
    /// <p>An object that contains information about a dedicated IP address.</p>
    public let dedicatedIp: DedicatedIp?

    public init (
        dedicatedIp: DedicatedIp? = nil
    )
    {
        self.dedicatedIp = dedicatedIp
    }
}

struct GetDedicatedIpOutputResponseBody: Equatable {
    public let dedicatedIp: DedicatedIp?
}

extension GetDedicatedIpOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dedicatedIp = "DedicatedIp"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dedicatedIpDecoded = try containerValues.decodeIfPresent(DedicatedIp.self, forKey: .dedicatedIp)
        dedicatedIp = dedicatedIpDecoded
    }
}

extension GetDedicatedIpsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDedicatedIpsInput(nextToken: \(String(describing: nextToken)), pageSize: \(String(describing: pageSize)), poolName: \(String(describing: poolName)))"}
}

extension GetDedicatedIpsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetDedicatedIpsInputHeadersMiddleware: Middleware {
    public let id: String = "GetDedicatedIpsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDedicatedIpsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDedicatedIpsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDedicatedIpsInput>
    public typealias MOutput = OperationOutput<GetDedicatedIpsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDedicatedIpsOutputError>
}

public struct GetDedicatedIpsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetDedicatedIpsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDedicatedIpsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDedicatedIpsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "NextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let pageSize = input.operationInput.pageSize {
            let pageSizeQueryItem = URLQueryItem(name: "PageSize".urlPercentEncoding(), value: String(pageSize).urlPercentEncoding())
            input.builder.withQueryItem(pageSizeQueryItem)
        }
        if let poolName = input.operationInput.poolName {
            let poolNameQueryItem = URLQueryItem(name: "PoolName".urlPercentEncoding(), value: String(poolName).urlPercentEncoding())
            input.builder.withQueryItem(poolNameQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDedicatedIpsInput>
    public typealias MOutput = OperationOutput<GetDedicatedIpsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDedicatedIpsOutputError>
}

/// <p>A request to obtain more information about dedicated IP pools.</p>
public struct GetDedicatedIpsInput: Equatable {
    /// <p>A token returned from a previous call to <code>GetDedicatedIps</code> to indicate the
    ///             position of the dedicated IP pool in the list of IP pools.</p>
    public let nextToken: String?
    /// <p>The number of results to show in a single call to <code>GetDedicatedIpsRequest</code>.
    ///             If the number of results is larger than the number you specified in this parameter, then
    ///             the response includes a <code>NextToken</code> element, which you can use to obtain
    ///             additional results.</p>
    public let pageSize: Int?
    /// <p>The name of the IP pool that the dedicated IP address is associated with.</p>
    public let poolName: String?

    public init (
        nextToken: String? = nil,
        pageSize: Int? = nil,
        poolName: String? = nil
    )
    {
        self.nextToken = nextToken
        self.pageSize = pageSize
        self.poolName = poolName
    }
}

struct GetDedicatedIpsInputBody: Equatable {
}

extension GetDedicatedIpsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetDedicatedIpsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDedicatedIpsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDedicatedIpsOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDedicatedIpsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDedicatedIpsOutputResponse(dedicatedIps: \(String(describing: dedicatedIps)), nextToken: \(String(describing: nextToken)))"}
}

extension GetDedicatedIpsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetDedicatedIpsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dedicatedIps = output.dedicatedIps
            self.nextToken = output.nextToken
        } else {
            self.dedicatedIps = nil
            self.nextToken = nil
        }
    }
}

/// <p>Information about the dedicated IP addresses that are associated with your Amazon Pinpoint
///             account.</p>
public struct GetDedicatedIpsOutputResponse: Equatable {
    /// <p>A list of dedicated IP addresses that are reserved for use by your Amazon Pinpoint
    ///             account.</p>
    public let dedicatedIps: [DedicatedIp]?
    /// <p>A token that indicates that there are additional dedicated IP addresses to list. To
    ///             view additional addresses, issue another request to <code>GetDedicatedIps</code>,
    ///             passing this token in the <code>NextToken</code> parameter.</p>
    public let nextToken: String?

    public init (
        dedicatedIps: [DedicatedIp]? = nil,
        nextToken: String? = nil
    )
    {
        self.dedicatedIps = dedicatedIps
        self.nextToken = nextToken
    }
}

struct GetDedicatedIpsOutputResponseBody: Equatable {
    public let dedicatedIps: [DedicatedIp]?
    public let nextToken: String?
}

extension GetDedicatedIpsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dedicatedIps = "DedicatedIps"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dedicatedIpsContainer = try containerValues.decodeIfPresent([DedicatedIp?].self, forKey: .dedicatedIps)
        var dedicatedIpsDecoded0:[DedicatedIp]? = nil
        if let dedicatedIpsContainer = dedicatedIpsContainer {
            dedicatedIpsDecoded0 = [DedicatedIp]()
            for structure0 in dedicatedIpsContainer {
                if let structure0 = structure0 {
                    dedicatedIpsDecoded0?.append(structure0)
                }
            }
        }
        dedicatedIps = dedicatedIpsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetDeliverabilityDashboardOptionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDeliverabilityDashboardOptionsInput()"}
}

extension GetDeliverabilityDashboardOptionsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetDeliverabilityDashboardOptionsInputHeadersMiddleware: Middleware {
    public let id: String = "GetDeliverabilityDashboardOptionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDeliverabilityDashboardOptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDeliverabilityDashboardOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDeliverabilityDashboardOptionsInput>
    public typealias MOutput = OperationOutput<GetDeliverabilityDashboardOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDeliverabilityDashboardOptionsOutputError>
}

public struct GetDeliverabilityDashboardOptionsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetDeliverabilityDashboardOptionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDeliverabilityDashboardOptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDeliverabilityDashboardOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDeliverabilityDashboardOptionsInput>
    public typealias MOutput = OperationOutput<GetDeliverabilityDashboardOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDeliverabilityDashboardOptionsOutputError>
}

/// <p>Retrieve information about the status of the Deliverability dashboard for your Amazon Pinpoint account.
///             When the Deliverability dashboard is enabled, you gain access to reputation, deliverability, and
///             other metrics for the domains that you use to send email using Amazon Pinpoint. You also gain the
///             ability to perform predictive inbox placement tests.</p>
///         <p>When you use the Deliverability dashboard, you pay a monthly subscription charge, in addition
///             to any other fees that you accrue by using Amazon Pinpoint. For more information about the
///             features and cost of a Deliverability dashboard subscription, see <a href="http://aws.amazon.com/pinpoint/pricing/">Amazon Pinpoint Pricing</a>.</p>
public struct GetDeliverabilityDashboardOptionsInput: Equatable {

    public init() {}
}

struct GetDeliverabilityDashboardOptionsInputBody: Equatable {
}

extension GetDeliverabilityDashboardOptionsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetDeliverabilityDashboardOptionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDeliverabilityDashboardOptionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDeliverabilityDashboardOptionsOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case limitExceededException(LimitExceededException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDeliverabilityDashboardOptionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDeliverabilityDashboardOptionsOutputResponse(accountStatus: \(String(describing: accountStatus)), activeSubscribedDomains: \(String(describing: activeSubscribedDomains)), dashboardEnabled: \(String(describing: dashboardEnabled)), pendingExpirationSubscribedDomains: \(String(describing: pendingExpirationSubscribedDomains)), subscriptionExpiryDate: \(String(describing: subscriptionExpiryDate)))"}
}

extension GetDeliverabilityDashboardOptionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetDeliverabilityDashboardOptionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.accountStatus = output.accountStatus
            self.activeSubscribedDomains = output.activeSubscribedDomains
            self.dashboardEnabled = output.dashboardEnabled
            self.pendingExpirationSubscribedDomains = output.pendingExpirationSubscribedDomains
            self.subscriptionExpiryDate = output.subscriptionExpiryDate
        } else {
            self.accountStatus = nil
            self.activeSubscribedDomains = nil
            self.dashboardEnabled = false
            self.pendingExpirationSubscribedDomains = nil
            self.subscriptionExpiryDate = nil
        }
    }
}

/// <p>An object that shows the status of the Deliverability dashboard for your Amazon Pinpoint account.</p>
public struct GetDeliverabilityDashboardOptionsOutputResponse: Equatable {
    /// <p>The current status of your Deliverability dashboard subscription. If this value is
    ///                 <code>PENDING_EXPIRATION</code>, your subscription is scheduled to expire at the end
    ///             of the current calendar month.</p>
    public let accountStatus: DeliverabilityDashboardAccountStatus?
    /// <p>An array of objects, one for each verified domain that you use to send email and
    ///             currently has an active Deliverability dashboard subscription that isnt scheduled to expire at
    ///             the end of the current calendar month.</p>
    public let activeSubscribedDomains: [DomainDeliverabilityTrackingOption]?
    /// <p>Specifies whether the Deliverability dashboard is enabled for your Amazon Pinpoint account. If this value
    ///             is <code>true</code>, the dashboard is enabled.</p>
    public let dashboardEnabled: Bool
    /// <p>An array of objects, one for each verified domain that you use to send email and
    ///             currently has an active Deliverability dashboard subscription that's scheduled to expire at the
    ///             end of the current calendar month.</p>
    public let pendingExpirationSubscribedDomains: [DomainDeliverabilityTrackingOption]?
    /// <p>The date, in Unix time format, when your current subscription to the Deliverability dashboard
    ///             is scheduled to expire, if your subscription is scheduled to expire at the end of the
    ///             current calendar month. This value is null if you have an active subscription that isnt
    ///             due to expire at the end of the month.</p>
    public let subscriptionExpiryDate: Date?

    public init (
        accountStatus: DeliverabilityDashboardAccountStatus? = nil,
        activeSubscribedDomains: [DomainDeliverabilityTrackingOption]? = nil,
        dashboardEnabled: Bool = false,
        pendingExpirationSubscribedDomains: [DomainDeliverabilityTrackingOption]? = nil,
        subscriptionExpiryDate: Date? = nil
    )
    {
        self.accountStatus = accountStatus
        self.activeSubscribedDomains = activeSubscribedDomains
        self.dashboardEnabled = dashboardEnabled
        self.pendingExpirationSubscribedDomains = pendingExpirationSubscribedDomains
        self.subscriptionExpiryDate = subscriptionExpiryDate
    }
}

struct GetDeliverabilityDashboardOptionsOutputResponseBody: Equatable {
    public let dashboardEnabled: Bool
    public let subscriptionExpiryDate: Date?
    public let accountStatus: DeliverabilityDashboardAccountStatus?
    public let activeSubscribedDomains: [DomainDeliverabilityTrackingOption]?
    public let pendingExpirationSubscribedDomains: [DomainDeliverabilityTrackingOption]?
}

extension GetDeliverabilityDashboardOptionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accountStatus = "AccountStatus"
        case activeSubscribedDomains = "ActiveSubscribedDomains"
        case dashboardEnabled = "DashboardEnabled"
        case pendingExpirationSubscribedDomains = "PendingExpirationSubscribedDomains"
        case subscriptionExpiryDate = "SubscriptionExpiryDate"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dashboardEnabledDecoded = try containerValues.decode(Bool.self, forKey: .dashboardEnabled)
        dashboardEnabled = dashboardEnabledDecoded
        let subscriptionExpiryDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .subscriptionExpiryDate)
        subscriptionExpiryDate = subscriptionExpiryDateDecoded
        let accountStatusDecoded = try containerValues.decodeIfPresent(DeliverabilityDashboardAccountStatus.self, forKey: .accountStatus)
        accountStatus = accountStatusDecoded
        let activeSubscribedDomainsContainer = try containerValues.decodeIfPresent([DomainDeliverabilityTrackingOption?].self, forKey: .activeSubscribedDomains)
        var activeSubscribedDomainsDecoded0:[DomainDeliverabilityTrackingOption]? = nil
        if let activeSubscribedDomainsContainer = activeSubscribedDomainsContainer {
            activeSubscribedDomainsDecoded0 = [DomainDeliverabilityTrackingOption]()
            for structure0 in activeSubscribedDomainsContainer {
                if let structure0 = structure0 {
                    activeSubscribedDomainsDecoded0?.append(structure0)
                }
            }
        }
        activeSubscribedDomains = activeSubscribedDomainsDecoded0
        let pendingExpirationSubscribedDomainsContainer = try containerValues.decodeIfPresent([DomainDeliverabilityTrackingOption?].self, forKey: .pendingExpirationSubscribedDomains)
        var pendingExpirationSubscribedDomainsDecoded0:[DomainDeliverabilityTrackingOption]? = nil
        if let pendingExpirationSubscribedDomainsContainer = pendingExpirationSubscribedDomainsContainer {
            pendingExpirationSubscribedDomainsDecoded0 = [DomainDeliverabilityTrackingOption]()
            for structure0 in pendingExpirationSubscribedDomainsContainer {
                if let structure0 = structure0 {
                    pendingExpirationSubscribedDomainsDecoded0?.append(structure0)
                }
            }
        }
        pendingExpirationSubscribedDomains = pendingExpirationSubscribedDomainsDecoded0
    }
}

extension GetDeliverabilityTestReportInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDeliverabilityTestReportInput(reportId: \(String(describing: reportId)))"}
}

extension GetDeliverabilityTestReportInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetDeliverabilityTestReportInputHeadersMiddleware: Middleware {
    public let id: String = "GetDeliverabilityTestReportInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDeliverabilityTestReportInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDeliverabilityTestReportOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDeliverabilityTestReportInput>
    public typealias MOutput = OperationOutput<GetDeliverabilityTestReportOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDeliverabilityTestReportOutputError>
}

public struct GetDeliverabilityTestReportInputQueryItemMiddleware: Middleware {
    public let id: String = "GetDeliverabilityTestReportInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDeliverabilityTestReportInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDeliverabilityTestReportOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDeliverabilityTestReportInput>
    public typealias MOutput = OperationOutput<GetDeliverabilityTestReportOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDeliverabilityTestReportOutputError>
}

/// <p>A request to retrieve the results of a predictive inbox placement test.</p>
public struct GetDeliverabilityTestReportInput: Equatable {
    /// <p>A unique string that identifies the predictive inbox placement test.</p>
    public let reportId: String?

    public init (
        reportId: String? = nil
    )
    {
        self.reportId = reportId
    }
}

struct GetDeliverabilityTestReportInputBody: Equatable {
}

extension GetDeliverabilityTestReportInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetDeliverabilityTestReportOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDeliverabilityTestReportOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDeliverabilityTestReportOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDeliverabilityTestReportOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDeliverabilityTestReportOutputResponse(deliverabilityTestReport: \(String(describing: deliverabilityTestReport)), ispPlacements: \(String(describing: ispPlacements)), message: \(String(describing: message)), overallPlacement: \(String(describing: overallPlacement)), tags: \(String(describing: tags)))"}
}

extension GetDeliverabilityTestReportOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetDeliverabilityTestReportOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.deliverabilityTestReport = output.deliverabilityTestReport
            self.ispPlacements = output.ispPlacements
            self.message = output.message
            self.overallPlacement = output.overallPlacement
            self.tags = output.tags
        } else {
            self.deliverabilityTestReport = nil
            self.ispPlacements = nil
            self.message = nil
            self.overallPlacement = nil
            self.tags = nil
        }
    }
}

/// <p>The results of the predictive inbox placement test.</p>
public struct GetDeliverabilityTestReportOutputResponse: Equatable {
    /// <p>An object that contains the results of the predictive inbox placement test.</p>
    public let deliverabilityTestReport: DeliverabilityTestReport?
    /// <p>An object that describes how the test email was handled by several email providers,
    ///             including Gmail, Hotmail, Yahoo, AOL, and others.</p>
    public let ispPlacements: [IspPlacement]?
    /// <p>An object that contains the message that you sent when you performed this
    ///             predictive inbox placement test.</p>
    public let message: String?
    /// <p>An object that specifies how many test messages that were sent during the predictive inbox placement test were
    ///             delivered to recipients' inboxes, how many were sent to recipients' spam folders, and
    ///             how many weren't delivered.</p>
    public let overallPlacement: PlacementStatistics?
    /// <p>An array of objects that define the tags (keys and values) that are associated with
    ///             the predictive inbox placement test.</p>
    public let tags: [Tag]?

    public init (
        deliverabilityTestReport: DeliverabilityTestReport? = nil,
        ispPlacements: [IspPlacement]? = nil,
        message: String? = nil,
        overallPlacement: PlacementStatistics? = nil,
        tags: [Tag]? = nil
    )
    {
        self.deliverabilityTestReport = deliverabilityTestReport
        self.ispPlacements = ispPlacements
        self.message = message
        self.overallPlacement = overallPlacement
        self.tags = tags
    }
}

struct GetDeliverabilityTestReportOutputResponseBody: Equatable {
    public let deliverabilityTestReport: DeliverabilityTestReport?
    public let overallPlacement: PlacementStatistics?
    public let ispPlacements: [IspPlacement]?
    public let message: String?
    public let tags: [Tag]?
}

extension GetDeliverabilityTestReportOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case deliverabilityTestReport = "DeliverabilityTestReport"
        case ispPlacements = "IspPlacements"
        case message = "Message"
        case overallPlacement = "OverallPlacement"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deliverabilityTestReportDecoded = try containerValues.decodeIfPresent(DeliverabilityTestReport.self, forKey: .deliverabilityTestReport)
        deliverabilityTestReport = deliverabilityTestReportDecoded
        let overallPlacementDecoded = try containerValues.decodeIfPresent(PlacementStatistics.self, forKey: .overallPlacement)
        overallPlacement = overallPlacementDecoded
        let ispPlacementsContainer = try containerValues.decodeIfPresent([IspPlacement?].self, forKey: .ispPlacements)
        var ispPlacementsDecoded0:[IspPlacement]? = nil
        if let ispPlacementsContainer = ispPlacementsContainer {
            ispPlacementsDecoded0 = [IspPlacement]()
            for structure0 in ispPlacementsContainer {
                if let structure0 = structure0 {
                    ispPlacementsDecoded0?.append(structure0)
                }
            }
        }
        ispPlacements = ispPlacementsDecoded0
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension GetDomainDeliverabilityCampaignInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDomainDeliverabilityCampaignInput(campaignId: \(String(describing: campaignId)))"}
}

extension GetDomainDeliverabilityCampaignInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetDomainDeliverabilityCampaignInputHeadersMiddleware: Middleware {
    public let id: String = "GetDomainDeliverabilityCampaignInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDomainDeliverabilityCampaignInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDomainDeliverabilityCampaignOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDomainDeliverabilityCampaignInput>
    public typealias MOutput = OperationOutput<GetDomainDeliverabilityCampaignOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDomainDeliverabilityCampaignOutputError>
}

public struct GetDomainDeliverabilityCampaignInputQueryItemMiddleware: Middleware {
    public let id: String = "GetDomainDeliverabilityCampaignInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDomainDeliverabilityCampaignInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDomainDeliverabilityCampaignOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDomainDeliverabilityCampaignInput>
    public typealias MOutput = OperationOutput<GetDomainDeliverabilityCampaignOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDomainDeliverabilityCampaignOutputError>
}

/// <p>Retrieve all the deliverability data for a specific campaign. This data is available
///             for a campaign only if the campaign sent email by using a domain that the
///             Deliverability dashboard is enabled for (<code>PutDeliverabilityDashboardOption</code>
///             operation).</p>
public struct GetDomainDeliverabilityCampaignInput: Equatable {
    /// <p>The unique identifier for the campaign. Amazon Pinpoint automatically generates and assigns this
    ///             identifier to a campaign. This value is not the same as the campaign identifier that
    ///             Amazon Pinpoint assigns to campaigns that you create and manage by using the Amazon Pinpoint API or the
    ///             Amazon Pinpoint console.</p>
    public let campaignId: String?

    public init (
        campaignId: String? = nil
    )
    {
        self.campaignId = campaignId
    }
}

struct GetDomainDeliverabilityCampaignInputBody: Equatable {
}

extension GetDomainDeliverabilityCampaignInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetDomainDeliverabilityCampaignOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDomainDeliverabilityCampaignOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDomainDeliverabilityCampaignOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDomainDeliverabilityCampaignOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDomainDeliverabilityCampaignOutputResponse(domainDeliverabilityCampaign: \(String(describing: domainDeliverabilityCampaign)))"}
}

extension GetDomainDeliverabilityCampaignOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetDomainDeliverabilityCampaignOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.domainDeliverabilityCampaign = output.domainDeliverabilityCampaign
        } else {
            self.domainDeliverabilityCampaign = nil
        }
    }
}

/// <p>An object that contains all the deliverability data for a specific campaign. This data
///             is available for a campaign only if the campaign sent email by using a domain that the
///             Deliverability dashboard is enabled for (<code>PutDeliverabilityDashboardOption</code>
///             operation).</p>
public struct GetDomainDeliverabilityCampaignOutputResponse: Equatable {
    /// <p>An object that contains the deliverability data for the campaign.</p>
    public let domainDeliverabilityCampaign: DomainDeliverabilityCampaign?

    public init (
        domainDeliverabilityCampaign: DomainDeliverabilityCampaign? = nil
    )
    {
        self.domainDeliverabilityCampaign = domainDeliverabilityCampaign
    }
}

struct GetDomainDeliverabilityCampaignOutputResponseBody: Equatable {
    public let domainDeliverabilityCampaign: DomainDeliverabilityCampaign?
}

extension GetDomainDeliverabilityCampaignOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case domainDeliverabilityCampaign = "DomainDeliverabilityCampaign"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainDeliverabilityCampaignDecoded = try containerValues.decodeIfPresent(DomainDeliverabilityCampaign.self, forKey: .domainDeliverabilityCampaign)
        domainDeliverabilityCampaign = domainDeliverabilityCampaignDecoded
    }
}

extension GetDomainStatisticsReportInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDomainStatisticsReportInput(domain: \(String(describing: domain)), endDate: \(String(describing: endDate)), startDate: \(String(describing: startDate)))"}
}

extension GetDomainStatisticsReportInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetDomainStatisticsReportInputHeadersMiddleware: Middleware {
    public let id: String = "GetDomainStatisticsReportInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDomainStatisticsReportInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDomainStatisticsReportOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDomainStatisticsReportInput>
    public typealias MOutput = OperationOutput<GetDomainStatisticsReportOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDomainStatisticsReportOutputError>
}

public struct GetDomainStatisticsReportInputQueryItemMiddleware: Middleware {
    public let id: String = "GetDomainStatisticsReportInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDomainStatisticsReportInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDomainStatisticsReportOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let startDate = input.operationInput.startDate {
            let startDateQueryItem = URLQueryItem(name: "StartDate".urlPercentEncoding(), value: String(startDate.iso8601WithoutFractionalSeconds()).urlPercentEncoding())
            input.builder.withQueryItem(startDateQueryItem)
        }
        if let endDate = input.operationInput.endDate {
            let endDateQueryItem = URLQueryItem(name: "EndDate".urlPercentEncoding(), value: String(endDate.iso8601WithoutFractionalSeconds()).urlPercentEncoding())
            input.builder.withQueryItem(endDateQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDomainStatisticsReportInput>
    public typealias MOutput = OperationOutput<GetDomainStatisticsReportOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDomainStatisticsReportOutputError>
}

/// <p>A request to obtain deliverability metrics for a domain.</p>
public struct GetDomainStatisticsReportInput: Equatable {
    /// <p>The domain that you want to obtain deliverability metrics for.</p>
    public let domain: String?
    /// <p>The last day (in Unix time) that you want to obtain domain deliverability metrics for.
    ///             The <code>EndDate</code> that you specify has to be less than or equal to 30 days after
    ///             the <code>StartDate</code>.</p>
    public let endDate: Date?
    /// <p>The first day (in Unix time) that you want to obtain domain deliverability metrics
    ///             for.</p>
    public let startDate: Date?

    public init (
        domain: String? = nil,
        endDate: Date? = nil,
        startDate: Date? = nil
    )
    {
        self.domain = domain
        self.endDate = endDate
        self.startDate = startDate
    }
}

struct GetDomainStatisticsReportInputBody: Equatable {
}

extension GetDomainStatisticsReportInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetDomainStatisticsReportOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDomainStatisticsReportOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDomainStatisticsReportOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDomainStatisticsReportOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDomainStatisticsReportOutputResponse(dailyVolumes: \(String(describing: dailyVolumes)), overallVolume: \(String(describing: overallVolume)))"}
}

extension GetDomainStatisticsReportOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetDomainStatisticsReportOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dailyVolumes = output.dailyVolumes
            self.overallVolume = output.overallVolume
        } else {
            self.dailyVolumes = nil
            self.overallVolume = nil
        }
    }
}

/// <p>An object that includes statistics that are related to the domain that you
///             specified.</p>
public struct GetDomainStatisticsReportOutputResponse: Equatable {
    /// <p>An object that contains deliverability metrics for the domain that you specified. This
    ///             object contains data for each day, starting on the <code>StartDate</code> and ending on
    ///             the <code>EndDate</code>.</p>
    public let dailyVolumes: [DailyVolume]?
    /// <p>An object that contains deliverability metrics for the domain that you specified. The
    ///             data in this object is a summary of all of the data that was collected from the
    ///                 <code>StartDate</code> to the <code>EndDate</code>.</p>
    public let overallVolume: OverallVolume?

    public init (
        dailyVolumes: [DailyVolume]? = nil,
        overallVolume: OverallVolume? = nil
    )
    {
        self.dailyVolumes = dailyVolumes
        self.overallVolume = overallVolume
    }
}

struct GetDomainStatisticsReportOutputResponseBody: Equatable {
    public let overallVolume: OverallVolume?
    public let dailyVolumes: [DailyVolume]?
}

extension GetDomainStatisticsReportOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dailyVolumes = "DailyVolumes"
        case overallVolume = "OverallVolume"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let overallVolumeDecoded = try containerValues.decodeIfPresent(OverallVolume.self, forKey: .overallVolume)
        overallVolume = overallVolumeDecoded
        let dailyVolumesContainer = try containerValues.decodeIfPresent([DailyVolume?].self, forKey: .dailyVolumes)
        var dailyVolumesDecoded0:[DailyVolume]? = nil
        if let dailyVolumesContainer = dailyVolumesContainer {
            dailyVolumesDecoded0 = [DailyVolume]()
            for structure0 in dailyVolumesContainer {
                if let structure0 = structure0 {
                    dailyVolumesDecoded0?.append(structure0)
                }
            }
        }
        dailyVolumes = dailyVolumesDecoded0
    }
}

extension GetEmailIdentityInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetEmailIdentityInput(emailIdentity: \(String(describing: emailIdentity)))"}
}

extension GetEmailIdentityInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetEmailIdentityInputHeadersMiddleware: Middleware {
    public let id: String = "GetEmailIdentityInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetEmailIdentityInput>,
                  next: H) -> Swift.Result<OperationOutput<GetEmailIdentityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetEmailIdentityInput>
    public typealias MOutput = OperationOutput<GetEmailIdentityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetEmailIdentityOutputError>
}

public struct GetEmailIdentityInputQueryItemMiddleware: Middleware {
    public let id: String = "GetEmailIdentityInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetEmailIdentityInput>,
                  next: H) -> Swift.Result<OperationOutput<GetEmailIdentityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetEmailIdentityInput>
    public typealias MOutput = OperationOutput<GetEmailIdentityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetEmailIdentityOutputError>
}

/// <p>A request to return details about an email identity.</p>
public struct GetEmailIdentityInput: Equatable {
    /// <p>The email identity that you want to retrieve details for.</p>
    public let emailIdentity: String?

    public init (
        emailIdentity: String? = nil
    )
    {
        self.emailIdentity = emailIdentity
    }
}

struct GetEmailIdentityInputBody: Equatable {
}

extension GetEmailIdentityInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetEmailIdentityOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetEmailIdentityOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetEmailIdentityOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetEmailIdentityOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetEmailIdentityOutputResponse(dkimAttributes: \(String(describing: dkimAttributes)), feedbackForwardingStatus: \(String(describing: feedbackForwardingStatus)), identityType: \(String(describing: identityType)), mailFromAttributes: \(String(describing: mailFromAttributes)), tags: \(String(describing: tags)), verifiedForSendingStatus: \(String(describing: verifiedForSendingStatus)))"}
}

extension GetEmailIdentityOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetEmailIdentityOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dkimAttributes = output.dkimAttributes
            self.feedbackForwardingStatus = output.feedbackForwardingStatus
            self.identityType = output.identityType
            self.mailFromAttributes = output.mailFromAttributes
            self.tags = output.tags
            self.verifiedForSendingStatus = output.verifiedForSendingStatus
        } else {
            self.dkimAttributes = nil
            self.feedbackForwardingStatus = false
            self.identityType = nil
            self.mailFromAttributes = nil
            self.tags = nil
            self.verifiedForSendingStatus = false
        }
    }
}

/// <p>Details about an email identity.</p>
public struct GetEmailIdentityOutputResponse: Equatable {
    /// <p>An object that contains information about the DKIM attributes for the identity. This
    ///             object includes the tokens that you use to create the CNAME records that are required to
    ///             complete the DKIM verification process.</p>
    public let dkimAttributes: DkimAttributes?
    /// <p>The feedback forwarding configuration for the identity.</p>
    ///         <p>If the value is <code>true</code>, Amazon Pinpoint sends you email notifications when bounce or
    ///             complaint events occur. Amazon Pinpoint sends this notification to the address that you specified
    ///             in the Return-Path header of the original email.</p>
    ///         <p>When you set this value to <code>false</code>, Amazon Pinpoint sends notifications through other
    ///             mechanisms, such as by notifying an Amazon SNS topic or another event destination. You're
    ///             required to have a method of tracking bounces and complaints. If you haven't set up
    ///             another mechanism for receiving bounce or complaint notifications, Amazon Pinpoint sends an email
    ///             notification when these events occur (even if this setting is disabled).</p>
    public let feedbackForwardingStatus: Bool
    /// <p>The email identity type.</p>
    public let identityType: IdentityType?
    /// <p>An object that contains information about the Mail-From attributes for the email
    ///             identity.</p>
    public let mailFromAttributes: MailFromAttributes?
    /// <p>An array of objects that define the tags (keys and values) that are associated with
    ///             the email identity.</p>
    public let tags: [Tag]?
    /// <p>Specifies whether or not the identity is verified. In Amazon Pinpoint, you can only send email
    ///             from verified email addresses or domains. For more information about verifying
    ///             identities, see the <a href="https://docs.aws.amazon.com/pinpoint/latest/userguide/channels-email-manage-verify.html">Amazon Pinpoint User Guide</a>.</p>
    public let verifiedForSendingStatus: Bool

    public init (
        dkimAttributes: DkimAttributes? = nil,
        feedbackForwardingStatus: Bool = false,
        identityType: IdentityType? = nil,
        mailFromAttributes: MailFromAttributes? = nil,
        tags: [Tag]? = nil,
        verifiedForSendingStatus: Bool = false
    )
    {
        self.dkimAttributes = dkimAttributes
        self.feedbackForwardingStatus = feedbackForwardingStatus
        self.identityType = identityType
        self.mailFromAttributes = mailFromAttributes
        self.tags = tags
        self.verifiedForSendingStatus = verifiedForSendingStatus
    }
}

struct GetEmailIdentityOutputResponseBody: Equatable {
    public let identityType: IdentityType?
    public let feedbackForwardingStatus: Bool
    public let verifiedForSendingStatus: Bool
    public let dkimAttributes: DkimAttributes?
    public let mailFromAttributes: MailFromAttributes?
    public let tags: [Tag]?
}

extension GetEmailIdentityOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dkimAttributes = "DkimAttributes"
        case feedbackForwardingStatus = "FeedbackForwardingStatus"
        case identityType = "IdentityType"
        case mailFromAttributes = "MailFromAttributes"
        case tags = "Tags"
        case verifiedForSendingStatus = "VerifiedForSendingStatus"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityTypeDecoded = try containerValues.decodeIfPresent(IdentityType.self, forKey: .identityType)
        identityType = identityTypeDecoded
        let feedbackForwardingStatusDecoded = try containerValues.decode(Bool.self, forKey: .feedbackForwardingStatus)
        feedbackForwardingStatus = feedbackForwardingStatusDecoded
        let verifiedForSendingStatusDecoded = try containerValues.decode(Bool.self, forKey: .verifiedForSendingStatus)
        verifiedForSendingStatus = verifiedForSendingStatusDecoded
        let dkimAttributesDecoded = try containerValues.decodeIfPresent(DkimAttributes.self, forKey: .dkimAttributes)
        dkimAttributes = dkimAttributesDecoded
        let mailFromAttributesDecoded = try containerValues.decodeIfPresent(MailFromAttributes.self, forKey: .mailFromAttributes)
        mailFromAttributes = mailFromAttributesDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension IdentityInfo: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case identityName = "IdentityName"
        case identityType = "IdentityType"
        case sendingEnabled = "SendingEnabled"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identityName = identityName {
            try encodeContainer.encode(identityName, forKey: .identityName)
        }
        if let identityType = identityType {
            try encodeContainer.encode(identityType.rawValue, forKey: .identityType)
        }
        if sendingEnabled != false {
            try encodeContainer.encode(sendingEnabled, forKey: .sendingEnabled)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityTypeDecoded = try containerValues.decodeIfPresent(IdentityType.self, forKey: .identityType)
        identityType = identityTypeDecoded
        let identityNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .identityName)
        identityName = identityNameDecoded
        let sendingEnabledDecoded = try containerValues.decode(Bool.self, forKey: .sendingEnabled)
        sendingEnabled = sendingEnabledDecoded
    }
}

extension IdentityInfo: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IdentityInfo(identityName: \(String(describing: identityName)), identityType: \(String(describing: identityType)), sendingEnabled: \(String(describing: sendingEnabled)))"}
}

/// <p>Information about an email identity.</p>
public struct IdentityInfo: Equatable {
    /// <p>The address or domain of the identity.</p>
    public let identityName: String?
    /// <p>The email identity type. The identity type can be one of the following:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <code>EMAIL_ADDRESS</code>  The identity is an email address.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>DOMAIN</code>  The identity is a domain.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>MANAGED_DOMAIN</code>  The identity is a domain that is managed
    ///                     by AWS.</p>
    ///             </li>
    ///          </ul>
    public let identityType: IdentityType?
    /// <p>Indicates whether or not you can send email from the identity.</p>
    ///         <p>In Amazon Pinpoint, an identity is an email address or domain that you send email from. Before
    ///             you can send email from an identity, you have to demostrate that you own the identity,
    ///             and that you authorize Amazon Pinpoint to send email from that identity.</p>
    public let sendingEnabled: Bool

    public init (
        identityName: String? = nil,
        identityType: IdentityType? = nil,
        sendingEnabled: Bool = false
    )
    {
        self.identityName = identityName
        self.identityType = identityType
        self.sendingEnabled = sendingEnabled
    }
}

/// <p>The email identity type. The identity type can be one of the following:</p>
///         <ul>
///             <li>
///                 <p>
///                   <code>EMAIL_ADDRESS</code>  The identity is an email address.</p>
///             </li>
///             <li>
///                 <p>
///                   <code>DOMAIN</code>  The identity is a domain.</p>
///             </li>
///          </ul>
public enum IdentityType {
    case domain
    case emailAddress
    case managedDomain
    case sdkUnknown(String)
}

extension IdentityType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [IdentityType] {
        return [
            .domain,
            .emailAddress,
            .managedDomain,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .domain: return "DOMAIN"
        case .emailAddress: return "EMAIL_ADDRESS"
        case .managedDomain: return "MANAGED_DOMAIN"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = IdentityType(rawValue: rawValue) ?? IdentityType.sdkUnknown(rawValue)
    }
}

extension InboxPlacementTrackingOption: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case global = "Global"
        case trackedIsps = "TrackedIsps"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if global != false {
            try encodeContainer.encode(global, forKey: .global)
        }
        if let trackedIsps = trackedIsps {
            var trackedIspsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .trackedIsps)
            for ispnamelist0 in trackedIsps {
                try trackedIspsContainer.encode(ispnamelist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let globalDecoded = try containerValues.decode(Bool.self, forKey: .global)
        global = globalDecoded
        let trackedIspsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .trackedIsps)
        var trackedIspsDecoded0:[String]? = nil
        if let trackedIspsContainer = trackedIspsContainer {
            trackedIspsDecoded0 = [String]()
            for string0 in trackedIspsContainer {
                if let string0 = string0 {
                    trackedIspsDecoded0?.append(string0)
                }
            }
        }
        trackedIsps = trackedIspsDecoded0
    }
}

extension InboxPlacementTrackingOption: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InboxPlacementTrackingOption(global: \(String(describing: global)), trackedIsps: \(String(describing: trackedIsps)))"}
}

/// <p>An object that contains information about the inbox placement data settings for a
///             verified domain thats associated with your AWS account. This data is available only
///             if you enabled the Deliverability dashboard for the domain
///                 (<code>PutDeliverabilityDashboardOption</code> operation).</p>
public struct InboxPlacementTrackingOption: Equatable {
    /// <p>Specifies whether inbox placement data is being tracked for the domain.</p>
    public let global: Bool
    /// <p>An array of strings, one for each major email provider that the inbox placement data
    ///             applies to.</p>
    public let trackedIsps: [String]?

    public init (
        global: Bool = false,
        trackedIsps: [String]? = nil
    )
    {
        self.global = global
        self.trackedIsps = trackedIsps
    }
}

extension IspPlacement: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case ispName = "IspName"
        case placementStatistics = "PlacementStatistics"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ispName = ispName {
            try encodeContainer.encode(ispName, forKey: .ispName)
        }
        if let placementStatistics = placementStatistics {
            try encodeContainer.encode(placementStatistics, forKey: .placementStatistics)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ispNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ispName)
        ispName = ispNameDecoded
        let placementStatisticsDecoded = try containerValues.decodeIfPresent(PlacementStatistics.self, forKey: .placementStatistics)
        placementStatistics = placementStatisticsDecoded
    }
}

extension IspPlacement: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IspPlacement(ispName: \(String(describing: ispName)), placementStatistics: \(String(describing: placementStatistics)))"}
}

/// <p>An object that describes how email sent during the predictive inbox placement test was handled by a certain
///             email provider.</p>
public struct IspPlacement: Equatable {
    /// <p>The name of the email provider that the inbox placement data applies to.</p>
    public let ispName: String?
    /// <p>An object that contains inbox placement metrics for a specific email provider.</p>
    public let placementStatistics: PlacementStatistics?

    public init (
        ispName: String? = nil,
        placementStatistics: PlacementStatistics? = nil
    )
    {
        self.ispName = ispName
        self.placementStatistics = placementStatistics
    }
}

extension KinesisFirehoseDestination: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case deliveryStreamArn = "DeliveryStreamArn"
        case iamRoleArn = "IamRoleArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deliveryStreamArn = deliveryStreamArn {
            try encodeContainer.encode(deliveryStreamArn, forKey: .deliveryStreamArn)
        }
        if let iamRoleArn = iamRoleArn {
            try encodeContainer.encode(iamRoleArn, forKey: .iamRoleArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let deliveryStreamArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deliveryStreamArn)
        deliveryStreamArn = deliveryStreamArnDecoded
    }
}

extension KinesisFirehoseDestination: CustomDebugStringConvertible {
    public var debugDescription: String {
        "KinesisFirehoseDestination(deliveryStreamArn: \(String(describing: deliveryStreamArn)), iamRoleArn: \(String(describing: iamRoleArn)))"}
}

/// <p>An object that defines an Amazon Kinesis Data Firehose destination for email events. You can use Amazon Kinesis Data Firehose to
///             stream data to other services, such as Amazon S3 and Amazon Redshift.</p>
public struct KinesisFirehoseDestination: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the Amazon Kinesis Data Firehose stream that Amazon Pinpoint sends email events
    ///             to.</p>
    public let deliveryStreamArn: String?
    /// <p>The Amazon Resource Name (ARN) of the IAM role that Amazon Pinpoint uses when sending email
    ///             events to the Amazon Kinesis Data Firehose stream.</p>
    public let iamRoleArn: String?

    public init (
        deliveryStreamArn: String? = nil,
        iamRoleArn: String? = nil
    )
    {
        self.deliveryStreamArn = deliveryStreamArn
        self.iamRoleArn = iamRoleArn
    }
}

extension LimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LimitExceededException(message: \(String(describing: message)))"}
}

extension LimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>There are too many instances of the specified resource type.</p>
public struct LimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct LimitExceededExceptionBody: Equatable {
    public let message: String?
}

extension LimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListConfigurationSetsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListConfigurationSetsInput(nextToken: \(String(describing: nextToken)), pageSize: \(String(describing: pageSize)))"}
}

extension ListConfigurationSetsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListConfigurationSetsInputHeadersMiddleware: Middleware {
    public let id: String = "ListConfigurationSetsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListConfigurationSetsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListConfigurationSetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListConfigurationSetsInput>
    public typealias MOutput = OperationOutput<ListConfigurationSetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListConfigurationSetsOutputError>
}

public struct ListConfigurationSetsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListConfigurationSetsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListConfigurationSetsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListConfigurationSetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "NextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let pageSize = input.operationInput.pageSize {
            let pageSizeQueryItem = URLQueryItem(name: "PageSize".urlPercentEncoding(), value: String(pageSize).urlPercentEncoding())
            input.builder.withQueryItem(pageSizeQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListConfigurationSetsInput>
    public typealias MOutput = OperationOutput<ListConfigurationSetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListConfigurationSetsOutputError>
}

/// <p>A request to obtain a list of configuration sets for your Amazon Pinpoint account in the current
///             AWS Region.</p>
public struct ListConfigurationSetsInput: Equatable {
    /// <p>A token returned from a previous call to <code>ListConfigurationSets</code> to
    ///             indicate the position in the list of configuration sets.</p>
    public let nextToken: String?
    /// <p>The number of results to show in a single call to <code>ListConfigurationSets</code>.
    ///             If the number of results is larger than the number you specified in this parameter, then
    ///             the response includes a <code>NextToken</code> element, which you can use to obtain
    ///             additional results.</p>
    public let pageSize: Int?

    public init (
        nextToken: String? = nil,
        pageSize: Int? = nil
    )
    {
        self.nextToken = nextToken
        self.pageSize = pageSize
    }
}

struct ListConfigurationSetsInputBody: Equatable {
}

extension ListConfigurationSetsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListConfigurationSetsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListConfigurationSetsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListConfigurationSetsOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListConfigurationSetsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListConfigurationSetsOutputResponse(configurationSets: \(String(describing: configurationSets)), nextToken: \(String(describing: nextToken)))"}
}

extension ListConfigurationSetsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListConfigurationSetsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.configurationSets = output.configurationSets
            self.nextToken = output.nextToken
        } else {
            self.configurationSets = nil
            self.nextToken = nil
        }
    }
}

/// <p>A list of configuration sets in your Amazon Pinpoint account in the current AWS Region.</p>
public struct ListConfigurationSetsOutputResponse: Equatable {
    /// <p>An array that contains all of the configuration sets in your Amazon Pinpoint account in the
    ///             current AWS Region.</p>
    public let configurationSets: [String]?
    /// <p>A token that indicates that there are additional configuration sets to list. To view
    ///             additional configuration sets, issue another request to
    ///                 <code>ListConfigurationSets</code>, and pass this token in the
    ///                 <code>NextToken</code> parameter.</p>
    public let nextToken: String?

    public init (
        configurationSets: [String]? = nil,
        nextToken: String? = nil
    )
    {
        self.configurationSets = configurationSets
        self.nextToken = nextToken
    }
}

struct ListConfigurationSetsOutputResponseBody: Equatable {
    public let configurationSets: [String]?
    public let nextToken: String?
}

extension ListConfigurationSetsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case configurationSets = "ConfigurationSets"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationSetsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .configurationSets)
        var configurationSetsDecoded0:[String]? = nil
        if let configurationSetsContainer = configurationSetsContainer {
            configurationSetsDecoded0 = [String]()
            for string0 in configurationSetsContainer {
                if let string0 = string0 {
                    configurationSetsDecoded0?.append(string0)
                }
            }
        }
        configurationSets = configurationSetsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListDedicatedIpPoolsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDedicatedIpPoolsInput(nextToken: \(String(describing: nextToken)), pageSize: \(String(describing: pageSize)))"}
}

extension ListDedicatedIpPoolsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListDedicatedIpPoolsInputHeadersMiddleware: Middleware {
    public let id: String = "ListDedicatedIpPoolsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDedicatedIpPoolsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDedicatedIpPoolsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDedicatedIpPoolsInput>
    public typealias MOutput = OperationOutput<ListDedicatedIpPoolsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDedicatedIpPoolsOutputError>
}

public struct ListDedicatedIpPoolsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListDedicatedIpPoolsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDedicatedIpPoolsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDedicatedIpPoolsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "NextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let pageSize = input.operationInput.pageSize {
            let pageSizeQueryItem = URLQueryItem(name: "PageSize".urlPercentEncoding(), value: String(pageSize).urlPercentEncoding())
            input.builder.withQueryItem(pageSizeQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDedicatedIpPoolsInput>
    public typealias MOutput = OperationOutput<ListDedicatedIpPoolsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDedicatedIpPoolsOutputError>
}

/// <p>A request to obtain a list of dedicated IP pools.</p>
public struct ListDedicatedIpPoolsInput: Equatable {
    /// <p>A token returned from a previous call to <code>ListDedicatedIpPools</code> to indicate
    ///             the position in the list of dedicated IP pools.</p>
    public let nextToken: String?
    /// <p>The number of results to show in a single call to <code>ListDedicatedIpPools</code>.
    ///             If the number of results is larger than the number you specified in this parameter, then
    ///             the response includes a <code>NextToken</code> element, which you can use to obtain
    ///             additional results.</p>
    public let pageSize: Int?

    public init (
        nextToken: String? = nil,
        pageSize: Int? = nil
    )
    {
        self.nextToken = nextToken
        self.pageSize = pageSize
    }
}

struct ListDedicatedIpPoolsInputBody: Equatable {
}

extension ListDedicatedIpPoolsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListDedicatedIpPoolsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDedicatedIpPoolsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDedicatedIpPoolsOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDedicatedIpPoolsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDedicatedIpPoolsOutputResponse(dedicatedIpPools: \(String(describing: dedicatedIpPools)), nextToken: \(String(describing: nextToken)))"}
}

extension ListDedicatedIpPoolsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListDedicatedIpPoolsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dedicatedIpPools = output.dedicatedIpPools
            self.nextToken = output.nextToken
        } else {
            self.dedicatedIpPools = nil
            self.nextToken = nil
        }
    }
}

/// <p>A list of dedicated IP pools.</p>
public struct ListDedicatedIpPoolsOutputResponse: Equatable {
    /// <p>A list of all of the dedicated IP pools that are associated with your Amazon Pinpoint
    ///             account.</p>
    public let dedicatedIpPools: [String]?
    /// <p>A token that indicates that there are additional IP pools to list. To view additional
    ///             IP pools, issue another request to <code>ListDedicatedIpPools</code>, passing this token
    ///             in the <code>NextToken</code> parameter.</p>
    public let nextToken: String?

    public init (
        dedicatedIpPools: [String]? = nil,
        nextToken: String? = nil
    )
    {
        self.dedicatedIpPools = dedicatedIpPools
        self.nextToken = nextToken
    }
}

struct ListDedicatedIpPoolsOutputResponseBody: Equatable {
    public let dedicatedIpPools: [String]?
    public let nextToken: String?
}

extension ListDedicatedIpPoolsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dedicatedIpPools = "DedicatedIpPools"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dedicatedIpPoolsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .dedicatedIpPools)
        var dedicatedIpPoolsDecoded0:[String]? = nil
        if let dedicatedIpPoolsContainer = dedicatedIpPoolsContainer {
            dedicatedIpPoolsDecoded0 = [String]()
            for string0 in dedicatedIpPoolsContainer {
                if let string0 = string0 {
                    dedicatedIpPoolsDecoded0?.append(string0)
                }
            }
        }
        dedicatedIpPools = dedicatedIpPoolsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListDeliverabilityTestReportsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDeliverabilityTestReportsInput(nextToken: \(String(describing: nextToken)), pageSize: \(String(describing: pageSize)))"}
}

extension ListDeliverabilityTestReportsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListDeliverabilityTestReportsInputHeadersMiddleware: Middleware {
    public let id: String = "ListDeliverabilityTestReportsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDeliverabilityTestReportsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDeliverabilityTestReportsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDeliverabilityTestReportsInput>
    public typealias MOutput = OperationOutput<ListDeliverabilityTestReportsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDeliverabilityTestReportsOutputError>
}

public struct ListDeliverabilityTestReportsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListDeliverabilityTestReportsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDeliverabilityTestReportsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDeliverabilityTestReportsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "NextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let pageSize = input.operationInput.pageSize {
            let pageSizeQueryItem = URLQueryItem(name: "PageSize".urlPercentEncoding(), value: String(pageSize).urlPercentEncoding())
            input.builder.withQueryItem(pageSizeQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDeliverabilityTestReportsInput>
    public typealias MOutput = OperationOutput<ListDeliverabilityTestReportsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDeliverabilityTestReportsOutputError>
}

/// <p>A request to list all of the predictive inbox placement tests that you've performed.</p>
public struct ListDeliverabilityTestReportsInput: Equatable {
    /// <p>A token returned from a previous call to <code>ListDeliverabilityTestReports</code> to
    ///             indicate the position in the list of predictive inbox placement tests.</p>
    public let nextToken: String?
    /// <p>The number of results to show in a single call to
    ///                 <code>ListDeliverabilityTestReports</code>. If the number of results is larger than
    ///             the number you specified in this parameter, then the response includes a
    ///                 <code>NextToken</code> element, which you can use to obtain additional
    ///             results.</p>
    ///         <p>The value you specify has to be at least 0, and can be no more than 1000.</p>
    public let pageSize: Int?

    public init (
        nextToken: String? = nil,
        pageSize: Int? = nil
    )
    {
        self.nextToken = nextToken
        self.pageSize = pageSize
    }
}

struct ListDeliverabilityTestReportsInputBody: Equatable {
}

extension ListDeliverabilityTestReportsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListDeliverabilityTestReportsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDeliverabilityTestReportsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDeliverabilityTestReportsOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDeliverabilityTestReportsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDeliverabilityTestReportsOutputResponse(deliverabilityTestReports: \(String(describing: deliverabilityTestReports)), nextToken: \(String(describing: nextToken)))"}
}

extension ListDeliverabilityTestReportsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListDeliverabilityTestReportsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.deliverabilityTestReports = output.deliverabilityTestReports
            self.nextToken = output.nextToken
        } else {
            self.deliverabilityTestReports = nil
            self.nextToken = nil
        }
    }
}

/// <p>A list of the predictive inbox placement test reports that are available for your account, regardless of
///             whether or not those tests are complete.</p>
public struct ListDeliverabilityTestReportsOutputResponse: Equatable {
    /// <p>An object that contains a lists of predictive inbox placement tests that you've performed.</p>
    public let deliverabilityTestReports: [DeliverabilityTestReport]?
    /// <p>A token that indicates that there are additional predictive inbox placement tests to list. To view additional
    ///             predictive inbox placement tests, issue another request to <code>ListDeliverabilityTestReports</code>, and pass
    ///             this token in the <code>NextToken</code> parameter.</p>
    public let nextToken: String?

    public init (
        deliverabilityTestReports: [DeliverabilityTestReport]? = nil,
        nextToken: String? = nil
    )
    {
        self.deliverabilityTestReports = deliverabilityTestReports
        self.nextToken = nextToken
    }
}

struct ListDeliverabilityTestReportsOutputResponseBody: Equatable {
    public let deliverabilityTestReports: [DeliverabilityTestReport]?
    public let nextToken: String?
}

extension ListDeliverabilityTestReportsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case deliverabilityTestReports = "DeliverabilityTestReports"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deliverabilityTestReportsContainer = try containerValues.decodeIfPresent([DeliverabilityTestReport?].self, forKey: .deliverabilityTestReports)
        var deliverabilityTestReportsDecoded0:[DeliverabilityTestReport]? = nil
        if let deliverabilityTestReportsContainer = deliverabilityTestReportsContainer {
            deliverabilityTestReportsDecoded0 = [DeliverabilityTestReport]()
            for structure0 in deliverabilityTestReportsContainer {
                if let structure0 = structure0 {
                    deliverabilityTestReportsDecoded0?.append(structure0)
                }
            }
        }
        deliverabilityTestReports = deliverabilityTestReportsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListDomainDeliverabilityCampaignsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDomainDeliverabilityCampaignsInput(endDate: \(String(describing: endDate)), nextToken: \(String(describing: nextToken)), pageSize: \(String(describing: pageSize)), startDate: \(String(describing: startDate)), subscribedDomain: \(String(describing: subscribedDomain)))"}
}

extension ListDomainDeliverabilityCampaignsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListDomainDeliverabilityCampaignsInputHeadersMiddleware: Middleware {
    public let id: String = "ListDomainDeliverabilityCampaignsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDomainDeliverabilityCampaignsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDomainDeliverabilityCampaignsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDomainDeliverabilityCampaignsInput>
    public typealias MOutput = OperationOutput<ListDomainDeliverabilityCampaignsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDomainDeliverabilityCampaignsOutputError>
}

public struct ListDomainDeliverabilityCampaignsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListDomainDeliverabilityCampaignsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDomainDeliverabilityCampaignsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDomainDeliverabilityCampaignsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let startDate = input.operationInput.startDate {
            let startDateQueryItem = URLQueryItem(name: "StartDate".urlPercentEncoding(), value: String(startDate.iso8601WithoutFractionalSeconds()).urlPercentEncoding())
            input.builder.withQueryItem(startDateQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "NextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let pageSize = input.operationInput.pageSize {
            let pageSizeQueryItem = URLQueryItem(name: "PageSize".urlPercentEncoding(), value: String(pageSize).urlPercentEncoding())
            input.builder.withQueryItem(pageSizeQueryItem)
        }
        if let endDate = input.operationInput.endDate {
            let endDateQueryItem = URLQueryItem(name: "EndDate".urlPercentEncoding(), value: String(endDate.iso8601WithoutFractionalSeconds()).urlPercentEncoding())
            input.builder.withQueryItem(endDateQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDomainDeliverabilityCampaignsInput>
    public typealias MOutput = OperationOutput<ListDomainDeliverabilityCampaignsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDomainDeliverabilityCampaignsOutputError>
}

/// <p>Retrieve deliverability data for all the campaigns that used a specific domain to send
///             email during a specified time range. This data is available for a domain only if you
///             enabled the Deliverability dashboard (<code>PutDeliverabilityDashboardOption</code> operation)
///             for the domain.</p>
public struct ListDomainDeliverabilityCampaignsInput: Equatable {
    /// <p>The last day, in Unix time format, that you want to obtain deliverability data for.
    ///             This value has to be less than or equal to 30 days after the value of the
    ///                 <code>StartDate</code> parameter.</p>
    public let endDate: Date?
    /// <p>A token thats returned from a previous call to the
    ///                 <code>ListDomainDeliverabilityCampaigns</code> operation. This token indicates the
    ///             position of a campaign in the list of campaigns.</p>
    public let nextToken: String?
    /// <p>The maximum number of results to include in response to a single call to the
    ///                 <code>ListDomainDeliverabilityCampaigns</code> operation. If the number of results
    ///             is larger than the number that you specify in this parameter, the response includes a
    ///                 <code>NextToken</code> element, which you can use to obtain additional
    ///             results.</p>
    public let pageSize: Int?
    /// <p>The first day, in Unix time format, that you want to obtain deliverability data
    ///             for.</p>
    public let startDate: Date?
    /// <p>The domain to obtain deliverability data for.</p>
    public let subscribedDomain: String?

    public init (
        endDate: Date? = nil,
        nextToken: String? = nil,
        pageSize: Int? = nil,
        startDate: Date? = nil,
        subscribedDomain: String? = nil
    )
    {
        self.endDate = endDate
        self.nextToken = nextToken
        self.pageSize = pageSize
        self.startDate = startDate
        self.subscribedDomain = subscribedDomain
    }
}

struct ListDomainDeliverabilityCampaignsInputBody: Equatable {
}

extension ListDomainDeliverabilityCampaignsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListDomainDeliverabilityCampaignsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDomainDeliverabilityCampaignsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDomainDeliverabilityCampaignsOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDomainDeliverabilityCampaignsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDomainDeliverabilityCampaignsOutputResponse(domainDeliverabilityCampaigns: \(String(describing: domainDeliverabilityCampaigns)), nextToken: \(String(describing: nextToken)))"}
}

extension ListDomainDeliverabilityCampaignsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListDomainDeliverabilityCampaignsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.domainDeliverabilityCampaigns = output.domainDeliverabilityCampaigns
            self.nextToken = output.nextToken
        } else {
            self.domainDeliverabilityCampaigns = nil
            self.nextToken = nil
        }
    }
}

/// <p>An array of objects that provide deliverability data for all the campaigns that used a
///             specific domain to send email during a specified time range. This data is available for
///             a domain only if you enabled the Deliverability dashboard
///                 (<code>PutDeliverabilityDashboardOption</code> operation) for the domain.</p>
public struct ListDomainDeliverabilityCampaignsOutputResponse: Equatable {
    /// <p>An array of responses, one for each campaign that used the domain to send email during
    ///             the specified time range.</p>
    public let domainDeliverabilityCampaigns: [DomainDeliverabilityCampaign]?
    /// <p>A token thats returned from a previous call to the
    ///                 <code>ListDomainDeliverabilityCampaigns</code> operation. This token indicates the
    ///             position of the campaign in the list of campaigns.</p>
    public let nextToken: String?

    public init (
        domainDeliverabilityCampaigns: [DomainDeliverabilityCampaign]? = nil,
        nextToken: String? = nil
    )
    {
        self.domainDeliverabilityCampaigns = domainDeliverabilityCampaigns
        self.nextToken = nextToken
    }
}

struct ListDomainDeliverabilityCampaignsOutputResponseBody: Equatable {
    public let domainDeliverabilityCampaigns: [DomainDeliverabilityCampaign]?
    public let nextToken: String?
}

extension ListDomainDeliverabilityCampaignsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case domainDeliverabilityCampaigns = "DomainDeliverabilityCampaigns"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainDeliverabilityCampaignsContainer = try containerValues.decodeIfPresent([DomainDeliverabilityCampaign?].self, forKey: .domainDeliverabilityCampaigns)
        var domainDeliverabilityCampaignsDecoded0:[DomainDeliverabilityCampaign]? = nil
        if let domainDeliverabilityCampaignsContainer = domainDeliverabilityCampaignsContainer {
            domainDeliverabilityCampaignsDecoded0 = [DomainDeliverabilityCampaign]()
            for structure0 in domainDeliverabilityCampaignsContainer {
                if let structure0 = structure0 {
                    domainDeliverabilityCampaignsDecoded0?.append(structure0)
                }
            }
        }
        domainDeliverabilityCampaigns = domainDeliverabilityCampaignsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListEmailIdentitiesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListEmailIdentitiesInput(nextToken: \(String(describing: nextToken)), pageSize: \(String(describing: pageSize)))"}
}

extension ListEmailIdentitiesInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListEmailIdentitiesInputHeadersMiddleware: Middleware {
    public let id: String = "ListEmailIdentitiesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListEmailIdentitiesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListEmailIdentitiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListEmailIdentitiesInput>
    public typealias MOutput = OperationOutput<ListEmailIdentitiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListEmailIdentitiesOutputError>
}

public struct ListEmailIdentitiesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListEmailIdentitiesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListEmailIdentitiesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListEmailIdentitiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "NextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let pageSize = input.operationInput.pageSize {
            let pageSizeQueryItem = URLQueryItem(name: "PageSize".urlPercentEncoding(), value: String(pageSize).urlPercentEncoding())
            input.builder.withQueryItem(pageSizeQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListEmailIdentitiesInput>
    public typealias MOutput = OperationOutput<ListEmailIdentitiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListEmailIdentitiesOutputError>
}

/// <p>A request to list all of the email identities associated with your Amazon Pinpoint account. This
///             list includes identities that you've already verified, identities that are unverified,
///             and identities that were verified in the past, but are no longer verified.</p>
public struct ListEmailIdentitiesInput: Equatable {
    /// <p>A token returned from a previous call to <code>ListEmailIdentities</code> to indicate
    ///             the position in the list of identities.</p>
    public let nextToken: String?
    /// <p>The number of results to show in a single call to <code>ListEmailIdentities</code>. If
    ///             the number of results is larger than the number you specified in this parameter, then
    ///             the response includes a <code>NextToken</code> element, which you can use to obtain
    ///             additional results.</p>
    ///         <p>The value you specify has to be at least 0, and can be no more than 1000.</p>
    public let pageSize: Int?

    public init (
        nextToken: String? = nil,
        pageSize: Int? = nil
    )
    {
        self.nextToken = nextToken
        self.pageSize = pageSize
    }
}

struct ListEmailIdentitiesInputBody: Equatable {
}

extension ListEmailIdentitiesInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListEmailIdentitiesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListEmailIdentitiesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListEmailIdentitiesOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListEmailIdentitiesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListEmailIdentitiesOutputResponse(emailIdentities: \(String(describing: emailIdentities)), nextToken: \(String(describing: nextToken)))"}
}

extension ListEmailIdentitiesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListEmailIdentitiesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.emailIdentities = output.emailIdentities
            self.nextToken = output.nextToken
        } else {
            self.emailIdentities = nil
            self.nextToken = nil
        }
    }
}

/// <p>A list of all of the identities that you've attempted to verify for use with Amazon Pinpoint,
///             regardless of whether or not those identities were successfully verified.</p>
public struct ListEmailIdentitiesOutputResponse: Equatable {
    /// <p>An array that includes all of the identities associated with your Amazon Pinpoint
    ///             account.</p>
    public let emailIdentities: [IdentityInfo]?
    /// <p>A token that indicates that there are additional configuration sets to list. To view
    ///             additional configuration sets, issue another request to
    ///             <code>ListEmailIdentities</code>, and pass this token in the <code>NextToken</code>
    ///             parameter.</p>
    public let nextToken: String?

    public init (
        emailIdentities: [IdentityInfo]? = nil,
        nextToken: String? = nil
    )
    {
        self.emailIdentities = emailIdentities
        self.nextToken = nextToken
    }
}

struct ListEmailIdentitiesOutputResponseBody: Equatable {
    public let emailIdentities: [IdentityInfo]?
    public let nextToken: String?
}

extension ListEmailIdentitiesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case emailIdentities = "EmailIdentities"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let emailIdentitiesContainer = try containerValues.decodeIfPresent([IdentityInfo?].self, forKey: .emailIdentities)
        var emailIdentitiesDecoded0:[IdentityInfo]? = nil
        if let emailIdentitiesContainer = emailIdentitiesContainer {
            emailIdentitiesDecoded0 = [IdentityInfo]()
            for structure0 in emailIdentitiesContainer {
                if let structure0 = structure0 {
                    emailIdentitiesDecoded0?.append(structure0)
                }
            }
        }
        emailIdentities = emailIdentitiesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceInput(resourceArn: \(String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let resourceArn = input.operationInput.resourceArn {
            let resourceArnQueryItem = URLQueryItem(name: "ResourceArn".urlPercentEncoding(), value: String(resourceArn).urlPercentEncoding())
            input.builder.withQueryItem(resourceArnQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the resource that you want to retrieve tag
    ///             information for.</p>
    public let resourceArn: String?

    public init (
        resourceArn: String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Equatable {
}

extension ListTagsForResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceOutputResponse(tags: \(String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Equatable {
    /// <p>An array that lists all the tags that are associated with the resource. Each tag
    ///             consists of a required tag key (<code>Key</code>) and an associated tag value
    ///                 (<code>Value</code>)</p>
    public let tags: [Tag]?

    public init (
        tags: [Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Equatable {
    public let tags: [Tag]?
}

extension ListTagsForResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension MailFromAttributes: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case behaviorOnMxFailure = "BehaviorOnMxFailure"
        case mailFromDomain = "MailFromDomain"
        case mailFromDomainStatus = "MailFromDomainStatus"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let behaviorOnMxFailure = behaviorOnMxFailure {
            try encodeContainer.encode(behaviorOnMxFailure.rawValue, forKey: .behaviorOnMxFailure)
        }
        if let mailFromDomain = mailFromDomain {
            try encodeContainer.encode(mailFromDomain, forKey: .mailFromDomain)
        }
        if let mailFromDomainStatus = mailFromDomainStatus {
            try encodeContainer.encode(mailFromDomainStatus.rawValue, forKey: .mailFromDomainStatus)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mailFromDomainDecoded = try containerValues.decodeIfPresent(String.self, forKey: .mailFromDomain)
        mailFromDomain = mailFromDomainDecoded
        let mailFromDomainStatusDecoded = try containerValues.decodeIfPresent(MailFromDomainStatus.self, forKey: .mailFromDomainStatus)
        mailFromDomainStatus = mailFromDomainStatusDecoded
        let behaviorOnMxFailureDecoded = try containerValues.decodeIfPresent(BehaviorOnMxFailure.self, forKey: .behaviorOnMxFailure)
        behaviorOnMxFailure = behaviorOnMxFailureDecoded
    }
}

extension MailFromAttributes: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MailFromAttributes(behaviorOnMxFailure: \(String(describing: behaviorOnMxFailure)), mailFromDomain: \(String(describing: mailFromDomain)), mailFromDomainStatus: \(String(describing: mailFromDomainStatus)))"}
}

/// <p>A list of attributes that are associated with a MAIL FROM domain.</p>
public struct MailFromAttributes: Equatable {
    /// <p>The action that Amazon Pinpoint to takes if it can't read the required MX record for a custom
    ///             MAIL FROM domain. When you set this value to <code>UseDefaultValue</code>, Amazon Pinpoint uses
    ///                 <i>amazonses.com</i> as the MAIL FROM domain. When you set this value
    ///             to <code>RejectMessage</code>, Amazon Pinpoint returns a <code>MailFromDomainNotVerified</code>
    ///             error, and doesn't attempt to deliver the email.</p>
    ///         <p>These behaviors are taken when the custom MAIL FROM domain configuration is in the
    ///                 <code>Pending</code>, <code>Failed</code>, and <code>TemporaryFailure</code>
    ///             states.</p>
    public let behaviorOnMxFailure: BehaviorOnMxFailure?
    /// <p>The name of a domain that an email identity uses as a custom MAIL FROM domain.</p>
    public let mailFromDomain: String?
    /// <p>The status of the MAIL FROM domain. This status can have the following values:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <code>PENDING</code>  Amazon Pinpoint hasn't started searching for the MX record
    ///                     yet.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>SUCCESS</code>  Amazon Pinpoint detected the required MX record for the
    ///                     MAIL FROM domain.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>FAILED</code>  Amazon Pinpoint can't find the required MX record, or the
    ///                     record no longer exists.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>TEMPORARY_FAILURE</code>  A temporary issue occurred, which
    ///                     prevented Amazon Pinpoint from determining the status of the MAIL FROM domain.</p>
    ///             </li>
    ///          </ul>
    public let mailFromDomainStatus: MailFromDomainStatus?

    public init (
        behaviorOnMxFailure: BehaviorOnMxFailure? = nil,
        mailFromDomain: String? = nil,
        mailFromDomainStatus: MailFromDomainStatus? = nil
    )
    {
        self.behaviorOnMxFailure = behaviorOnMxFailure
        self.mailFromDomain = mailFromDomain
        self.mailFromDomainStatus = mailFromDomainStatus
    }
}

extension MailFromDomainNotVerifiedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MailFromDomainNotVerifiedException(message: \(String(describing: message)))"}
}

extension MailFromDomainNotVerifiedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: MailFromDomainNotVerifiedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The message can't be sent because the sending domain isn't verified.</p>
public struct MailFromDomainNotVerifiedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct MailFromDomainNotVerifiedExceptionBody: Equatable {
    public let message: String?
}

extension MailFromDomainNotVerifiedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

/// <p>The status of the MAIL FROM domain. This status can have the following values:</p>
///         <ul>
///             <li>
///                 <p>
///                   <code>PENDING</code>  Amazon Pinpoint hasn't started searching for the MX record
///                     yet.</p>
///             </li>
///             <li>
///                 <p>
///                   <code>SUCCESS</code>  Amazon Pinpoint detected the required MX record for the
///                     MAIL FROM domain.</p>
///             </li>
///             <li>
///                 <p>
///                   <code>FAILED</code>  Amazon Pinpoint can't find the required MX record, or the
///                     record no longer exists.</p>
///             </li>
///             <li>
///                 <p>
///                   <code>TEMPORARY_FAILURE</code>  A temporary issue occurred, which
///                     prevented Amazon Pinpoint from determining the status of the MAIL FROM domain.</p>
///             </li>
///          </ul>
public enum MailFromDomainStatus {
    case failed
    case pending
    case success
    case temporaryFailure
    case sdkUnknown(String)
}

extension MailFromDomainStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [MailFromDomainStatus] {
        return [
            .failed,
            .pending,
            .success,
            .temporaryFailure,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .failed: return "FAILED"
        case .pending: return "PENDING"
        case .success: return "SUCCESS"
        case .temporaryFailure: return "TEMPORARY_FAILURE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = MailFromDomainStatus(rawValue: rawValue) ?? MailFromDomainStatus.sdkUnknown(rawValue)
    }
}

extension Message: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case body = "Body"
        case subject = "Subject"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let body = body {
            try encodeContainer.encode(body, forKey: .body)
        }
        if let subject = subject {
            try encodeContainer.encode(subject, forKey: .subject)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subjectDecoded = try containerValues.decodeIfPresent(Content.self, forKey: .subject)
        subject = subjectDecoded
        let bodyDecoded = try containerValues.decodeIfPresent(Body.self, forKey: .body)
        body = bodyDecoded
    }
}

extension Message: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Message(body: \(String(describing: body)), subject: \(String(describing: subject)))"}
}

/// <p>Represents the email message that you're sending. The <code>Message</code> object
///             consists of a subject line and a message body.</p>
public struct Message: Equatable {
    /// <p>The body of the message. You can specify an HTML version of the message, a text-only
    ///             version of the message, or both.</p>
    public let body: Body?
    /// <p>The subject line of the email. The subject line can only contain 7-bit ASCII
    ///             characters. However, you can specify non-ASCII characters in the subject line by using
    ///             encoded-word syntax, as described in <a href="https://tools.ietf.org/html/rfc2047">RFC 2047</a>.</p>
    public let subject: Content?

    public init (
        body: Body? = nil,
        subject: Content? = nil
    )
    {
        self.body = body
        self.subject = subject
    }
}

extension MessageRejected: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MessageRejected(message: \(String(describing: message)))"}
}

extension MessageRejected: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: MessageRejectedBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The message can't be sent because it contains invalid content.</p>
public struct MessageRejected: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct MessageRejectedBody: Equatable {
    public let message: String?
}

extension MessageRejectedBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MessageTag: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension MessageTag: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MessageTag(name: \(String(describing: name)), value: \(String(describing: value)))"}
}

/// <p>Contains the name and value of a tag that you apply to an email. You can use message
///             tags when you publish email sending events.
///             </p>
public struct MessageTag: Equatable {
    /// <p>The name of the message tag. The message tag name has to meet the following
    ///             criteria:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>It can only contain ASCII letters (az, AZ), numbers (09),
    ///                     underscores (_), or dashes (-).</p>
    ///             </li>
    ///             <li>
    ///                 <p>It can contain no more than 256 characters.</p>
    ///             </li>
    ///          </ul>
    public let name: String?
    /// <p>The value of the message tag. The message tag value has to meet the following
    ///             criteria:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>It can only contain ASCII letters (az, AZ), numbers (09),
    ///                     underscores (_), or dashes (-).</p>
    ///             </li>
    ///             <li>
    ///                 <p>It can contain no more than 256 characters.</p>
    ///             </li>
    ///          </ul>
    public let value: String?

    public init (
        name: String? = nil,
        value: String? = nil
    )
    {
        self.name = name
        self.value = value
    }
}

extension NotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NotFoundException(message: \(String(describing: message)))"}
}

extension NotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: NotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The resource you attempted to access doesn't exist.</p>
public struct NotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct NotFoundExceptionBody: Equatable {
    public let message: String?
}

extension NotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OverallVolume: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case domainIspPlacements = "DomainIspPlacements"
        case readRatePercent = "ReadRatePercent"
        case volumeStatistics = "VolumeStatistics"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainIspPlacements = domainIspPlacements {
            var domainIspPlacementsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .domainIspPlacements)
            for domainispplacements0 in domainIspPlacements {
                try domainIspPlacementsContainer.encode(domainispplacements0)
            }
        }
        if let readRatePercent = readRatePercent {
            try encodeContainer.encode(readRatePercent, forKey: .readRatePercent)
        }
        if let volumeStatistics = volumeStatistics {
            try encodeContainer.encode(volumeStatistics, forKey: .volumeStatistics)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let volumeStatisticsDecoded = try containerValues.decodeIfPresent(VolumeStatistics.self, forKey: .volumeStatistics)
        volumeStatistics = volumeStatisticsDecoded
        let readRatePercentDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .readRatePercent)
        readRatePercent = readRatePercentDecoded
        let domainIspPlacementsContainer = try containerValues.decodeIfPresent([DomainIspPlacement?].self, forKey: .domainIspPlacements)
        var domainIspPlacementsDecoded0:[DomainIspPlacement]? = nil
        if let domainIspPlacementsContainer = domainIspPlacementsContainer {
            domainIspPlacementsDecoded0 = [DomainIspPlacement]()
            for structure0 in domainIspPlacementsContainer {
                if let structure0 = structure0 {
                    domainIspPlacementsDecoded0?.append(structure0)
                }
            }
        }
        domainIspPlacements = domainIspPlacementsDecoded0
    }
}

extension OverallVolume: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OverallVolume(domainIspPlacements: \(String(describing: domainIspPlacements)), readRatePercent: \(String(describing: readRatePercent)), volumeStatistics: \(String(describing: volumeStatistics)))"}
}

/// <p>An object that contains information about email that was sent from the selected
///             domain.</p>
public struct OverallVolume: Equatable {
    /// <p>An object that contains inbox and junk mail placement metrics for individual email
    ///             providers.</p>
    public let domainIspPlacements: [DomainIspPlacement]?
    /// <p>The percentage of emails that were sent from the domain that were read by their
    ///             recipients.</p>
    public let readRatePercent: Double?
    /// <p>An object that contains information about the numbers of messages that arrived in
    ///             recipients' inboxes and junk mail folders.</p>
    public let volumeStatistics: VolumeStatistics?

    public init (
        domainIspPlacements: [DomainIspPlacement]? = nil,
        readRatePercent: Double? = nil,
        volumeStatistics: VolumeStatistics? = nil
    )
    {
        self.domainIspPlacements = domainIspPlacements
        self.readRatePercent = readRatePercent
        self.volumeStatistics = volumeStatistics
    }
}

extension PinpointDestination: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applicationArn = "ApplicationArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationArn = applicationArn {
            try encodeContainer.encode(applicationArn, forKey: .applicationArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationArn)
        applicationArn = applicationArnDecoded
    }
}

extension PinpointDestination: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PinpointDestination(applicationArn: \(String(describing: applicationArn)))"}
}

/// <p>An object that defines a Amazon Pinpoint destination for email events. You can use Amazon Pinpoint events
///             to create attributes in Amazon Pinpoint projects. You can use these attributes to create segments
///             for your campaigns.</p>
public struct PinpointDestination: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the Amazon Pinpoint project that you want to send email
    ///             events to.</p>
    public let applicationArn: String?

    public init (
        applicationArn: String? = nil
    )
    {
        self.applicationArn = applicationArn
    }
}

extension PlacementStatistics: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dkimPercentage = "DkimPercentage"
        case inboxPercentage = "InboxPercentage"
        case missingPercentage = "MissingPercentage"
        case spamPercentage = "SpamPercentage"
        case spfPercentage = "SpfPercentage"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dkimPercentage = dkimPercentage {
            try encodeContainer.encode(dkimPercentage, forKey: .dkimPercentage)
        }
        if let inboxPercentage = inboxPercentage {
            try encodeContainer.encode(inboxPercentage, forKey: .inboxPercentage)
        }
        if let missingPercentage = missingPercentage {
            try encodeContainer.encode(missingPercentage, forKey: .missingPercentage)
        }
        if let spamPercentage = spamPercentage {
            try encodeContainer.encode(spamPercentage, forKey: .spamPercentage)
        }
        if let spfPercentage = spfPercentage {
            try encodeContainer.encode(spfPercentage, forKey: .spfPercentage)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inboxPercentageDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .inboxPercentage)
        inboxPercentage = inboxPercentageDecoded
        let spamPercentageDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .spamPercentage)
        spamPercentage = spamPercentageDecoded
        let missingPercentageDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .missingPercentage)
        missingPercentage = missingPercentageDecoded
        let spfPercentageDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .spfPercentage)
        spfPercentage = spfPercentageDecoded
        let dkimPercentageDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .dkimPercentage)
        dkimPercentage = dkimPercentageDecoded
    }
}

extension PlacementStatistics: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PlacementStatistics(dkimPercentage: \(String(describing: dkimPercentage)), inboxPercentage: \(String(describing: inboxPercentage)), missingPercentage: \(String(describing: missingPercentage)), spamPercentage: \(String(describing: spamPercentage)), spfPercentage: \(String(describing: spfPercentage)))"}
}

/// <p>An object that contains inbox placement data for an email provider.</p>
public struct PlacementStatistics: Equatable {
    /// <p>The percentage of emails that were authenticated by using DomainKeys Identified Mail
    ///             (DKIM) during the predictive inbox placement test.</p>
    public let dkimPercentage: Double?
    /// <p>The percentage of emails that arrived in recipients' inboxes during the predictive inbox placement test.</p>
    public let inboxPercentage: Double?
    /// <p>The percentage of emails that didn't arrive in recipients' inboxes at all during the
    ///             predictive inbox placement test.</p>
    public let missingPercentage: Double?
    /// <p>The percentage of emails that arrived in recipients' spam or junk mail folders during
    ///             the predictive inbox placement test.</p>
    public let spamPercentage: Double?
    /// <p>The percentage of emails that were authenticated by using Sender Policy Framework
    ///             (SPF) during the predictive inbox placement test.</p>
    public let spfPercentage: Double?

    public init (
        dkimPercentage: Double? = nil,
        inboxPercentage: Double? = nil,
        missingPercentage: Double? = nil,
        spamPercentage: Double? = nil,
        spfPercentage: Double? = nil
    )
    {
        self.dkimPercentage = dkimPercentage
        self.inboxPercentage = inboxPercentage
        self.missingPercentage = missingPercentage
        self.spamPercentage = spamPercentage
        self.spfPercentage = spfPercentage
    }
}

public struct PutAccountDedicatedIpWarmupAttributesInputBodyMiddleware: Middleware {
    public let id: String = "PutAccountDedicatedIpWarmupAttributesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutAccountDedicatedIpWarmupAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<PutAccountDedicatedIpWarmupAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutAccountDedicatedIpWarmupAttributesInput>
    public typealias MOutput = OperationOutput<PutAccountDedicatedIpWarmupAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutAccountDedicatedIpWarmupAttributesOutputError>
}

extension PutAccountDedicatedIpWarmupAttributesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutAccountDedicatedIpWarmupAttributesInput(autoWarmupEnabled: \(String(describing: autoWarmupEnabled)))"}
}

extension PutAccountDedicatedIpWarmupAttributesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case autoWarmupEnabled = "AutoWarmupEnabled"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if autoWarmupEnabled != false {
            try encodeContainer.encode(autoWarmupEnabled, forKey: .autoWarmupEnabled)
        }
    }
}

public struct PutAccountDedicatedIpWarmupAttributesInputHeadersMiddleware: Middleware {
    public let id: String = "PutAccountDedicatedIpWarmupAttributesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutAccountDedicatedIpWarmupAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<PutAccountDedicatedIpWarmupAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutAccountDedicatedIpWarmupAttributesInput>
    public typealias MOutput = OperationOutput<PutAccountDedicatedIpWarmupAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutAccountDedicatedIpWarmupAttributesOutputError>
}

public struct PutAccountDedicatedIpWarmupAttributesInputQueryItemMiddleware: Middleware {
    public let id: String = "PutAccountDedicatedIpWarmupAttributesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutAccountDedicatedIpWarmupAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<PutAccountDedicatedIpWarmupAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutAccountDedicatedIpWarmupAttributesInput>
    public typealias MOutput = OperationOutput<PutAccountDedicatedIpWarmupAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutAccountDedicatedIpWarmupAttributesOutputError>
}

/// <p>A request to enable or disable the automatic IP address warm-up feature.</p>
public struct PutAccountDedicatedIpWarmupAttributesInput: Equatable {
    /// <p>Enables or disables the automatic warm-up feature for dedicated IP addresses that are
    ///             associated with your Amazon Pinpoint account in the current AWS Region. Set to <code>true</code>
    ///             to enable the automatic warm-up feature, or set to <code>false</code> to disable
    ///             it.</p>
    public let autoWarmupEnabled: Bool

    public init (
        autoWarmupEnabled: Bool = false
    )
    {
        self.autoWarmupEnabled = autoWarmupEnabled
    }
}

struct PutAccountDedicatedIpWarmupAttributesInputBody: Equatable {
    public let autoWarmupEnabled: Bool
}

extension PutAccountDedicatedIpWarmupAttributesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case autoWarmupEnabled = "AutoWarmupEnabled"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoWarmupEnabledDecoded = try containerValues.decode(Bool.self, forKey: .autoWarmupEnabled)
        autoWarmupEnabled = autoWarmupEnabledDecoded
    }
}

extension PutAccountDedicatedIpWarmupAttributesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutAccountDedicatedIpWarmupAttributesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutAccountDedicatedIpWarmupAttributesOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutAccountDedicatedIpWarmupAttributesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutAccountDedicatedIpWarmupAttributesOutputResponse()"}
}

extension PutAccountDedicatedIpWarmupAttributesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>An HTTP 200 response if the request succeeds, or an error message if the request
///             fails.</p>
public struct PutAccountDedicatedIpWarmupAttributesOutputResponse: Equatable {

    public init() {}
}

struct PutAccountDedicatedIpWarmupAttributesOutputResponseBody: Equatable {
}

extension PutAccountDedicatedIpWarmupAttributesOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct PutAccountSendingAttributesInputBodyMiddleware: Middleware {
    public let id: String = "PutAccountSendingAttributesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutAccountSendingAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<PutAccountSendingAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutAccountSendingAttributesInput>
    public typealias MOutput = OperationOutput<PutAccountSendingAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutAccountSendingAttributesOutputError>
}

extension PutAccountSendingAttributesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutAccountSendingAttributesInput(sendingEnabled: \(String(describing: sendingEnabled)))"}
}

extension PutAccountSendingAttributesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case sendingEnabled = "SendingEnabled"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if sendingEnabled != false {
            try encodeContainer.encode(sendingEnabled, forKey: .sendingEnabled)
        }
    }
}

public struct PutAccountSendingAttributesInputHeadersMiddleware: Middleware {
    public let id: String = "PutAccountSendingAttributesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutAccountSendingAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<PutAccountSendingAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutAccountSendingAttributesInput>
    public typealias MOutput = OperationOutput<PutAccountSendingAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutAccountSendingAttributesOutputError>
}

public struct PutAccountSendingAttributesInputQueryItemMiddleware: Middleware {
    public let id: String = "PutAccountSendingAttributesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutAccountSendingAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<PutAccountSendingAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutAccountSendingAttributesInput>
    public typealias MOutput = OperationOutput<PutAccountSendingAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutAccountSendingAttributesOutputError>
}

/// <p>A request to change the ability of your account to send email.</p>
public struct PutAccountSendingAttributesInput: Equatable {
    /// <p>Enables or disables your account's ability to send email. Set to <code>true</code> to
    ///             enable email sending, or set to <code>false</code> to disable email sending.</p>
    ///         <note>
    ///             <p>If AWS paused your account's ability to send email, you can't use this operation
    ///                 to resume your account's ability to send email.</p>
    ///         </note>
    public let sendingEnabled: Bool

    public init (
        sendingEnabled: Bool = false
    )
    {
        self.sendingEnabled = sendingEnabled
    }
}

struct PutAccountSendingAttributesInputBody: Equatable {
    public let sendingEnabled: Bool
}

extension PutAccountSendingAttributesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case sendingEnabled = "SendingEnabled"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sendingEnabledDecoded = try containerValues.decode(Bool.self, forKey: .sendingEnabled)
        sendingEnabled = sendingEnabledDecoded
    }
}

extension PutAccountSendingAttributesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutAccountSendingAttributesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutAccountSendingAttributesOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutAccountSendingAttributesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutAccountSendingAttributesOutputResponse()"}
}

extension PutAccountSendingAttributesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>An HTTP 200 response if the request succeeds, or an error message if the request
///             fails.</p>
public struct PutAccountSendingAttributesOutputResponse: Equatable {

    public init() {}
}

struct PutAccountSendingAttributesOutputResponseBody: Equatable {
}

extension PutAccountSendingAttributesOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct PutConfigurationSetDeliveryOptionsInputBodyMiddleware: Middleware {
    public let id: String = "PutConfigurationSetDeliveryOptionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutConfigurationSetDeliveryOptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<PutConfigurationSetDeliveryOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutConfigurationSetDeliveryOptionsInput>
    public typealias MOutput = OperationOutput<PutConfigurationSetDeliveryOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutConfigurationSetDeliveryOptionsOutputError>
}

extension PutConfigurationSetDeliveryOptionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutConfigurationSetDeliveryOptionsInput(configurationSetName: \(String(describing: configurationSetName)), sendingPoolName: \(String(describing: sendingPoolName)), tlsPolicy: \(String(describing: tlsPolicy)))"}
}

extension PutConfigurationSetDeliveryOptionsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case sendingPoolName = "SendingPoolName"
        case tlsPolicy = "TlsPolicy"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sendingPoolName = sendingPoolName {
            try encodeContainer.encode(sendingPoolName, forKey: .sendingPoolName)
        }
        if let tlsPolicy = tlsPolicy {
            try encodeContainer.encode(tlsPolicy.rawValue, forKey: .tlsPolicy)
        }
    }
}

public struct PutConfigurationSetDeliveryOptionsInputHeadersMiddleware: Middleware {
    public let id: String = "PutConfigurationSetDeliveryOptionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutConfigurationSetDeliveryOptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<PutConfigurationSetDeliveryOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutConfigurationSetDeliveryOptionsInput>
    public typealias MOutput = OperationOutput<PutConfigurationSetDeliveryOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutConfigurationSetDeliveryOptionsOutputError>
}

public struct PutConfigurationSetDeliveryOptionsInputQueryItemMiddleware: Middleware {
    public let id: String = "PutConfigurationSetDeliveryOptionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutConfigurationSetDeliveryOptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<PutConfigurationSetDeliveryOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutConfigurationSetDeliveryOptionsInput>
    public typealias MOutput = OperationOutput<PutConfigurationSetDeliveryOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutConfigurationSetDeliveryOptionsOutputError>
}

/// <p>A request to associate a configuration set with a dedicated IP pool.</p>
public struct PutConfigurationSetDeliveryOptionsInput: Equatable {
    /// <p>The name of the configuration set that you want to associate with a dedicated IP
    ///             pool.</p>
    public let configurationSetName: String?
    /// <p>The name of the dedicated IP pool that you want to associate with the configuration
    ///             set.</p>
    public let sendingPoolName: String?
    /// <p>Specifies whether messages that use the configuration set are required to use
    ///             Transport Layer Security (TLS). If the value is <code>Require</code>, messages are only
    ///             delivered if a TLS connection can be established. If the value is <code>Optional</code>,
    ///             messages can be delivered in plain text if a TLS connection can't be established.</p>
    public let tlsPolicy: TlsPolicy?

    public init (
        configurationSetName: String? = nil,
        sendingPoolName: String? = nil,
        tlsPolicy: TlsPolicy? = nil
    )
    {
        self.configurationSetName = configurationSetName
        self.sendingPoolName = sendingPoolName
        self.tlsPolicy = tlsPolicy
    }
}

struct PutConfigurationSetDeliveryOptionsInputBody: Equatable {
    public let tlsPolicy: TlsPolicy?
    public let sendingPoolName: String?
}

extension PutConfigurationSetDeliveryOptionsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case sendingPoolName = "SendingPoolName"
        case tlsPolicy = "TlsPolicy"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tlsPolicyDecoded = try containerValues.decodeIfPresent(TlsPolicy.self, forKey: .tlsPolicy)
        tlsPolicy = tlsPolicyDecoded
        let sendingPoolNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sendingPoolName)
        sendingPoolName = sendingPoolNameDecoded
    }
}

extension PutConfigurationSetDeliveryOptionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutConfigurationSetDeliveryOptionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutConfigurationSetDeliveryOptionsOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutConfigurationSetDeliveryOptionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutConfigurationSetDeliveryOptionsOutputResponse()"}
}

extension PutConfigurationSetDeliveryOptionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>An HTTP 200 response if the request succeeds, or an error message if the request
///             fails.</p>
public struct PutConfigurationSetDeliveryOptionsOutputResponse: Equatable {

    public init() {}
}

struct PutConfigurationSetDeliveryOptionsOutputResponseBody: Equatable {
}

extension PutConfigurationSetDeliveryOptionsOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct PutConfigurationSetReputationOptionsInputBodyMiddleware: Middleware {
    public let id: String = "PutConfigurationSetReputationOptionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutConfigurationSetReputationOptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<PutConfigurationSetReputationOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutConfigurationSetReputationOptionsInput>
    public typealias MOutput = OperationOutput<PutConfigurationSetReputationOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutConfigurationSetReputationOptionsOutputError>
}

extension PutConfigurationSetReputationOptionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutConfigurationSetReputationOptionsInput(configurationSetName: \(String(describing: configurationSetName)), reputationMetricsEnabled: \(String(describing: reputationMetricsEnabled)))"}
}

extension PutConfigurationSetReputationOptionsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case reputationMetricsEnabled = "ReputationMetricsEnabled"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if reputationMetricsEnabled != false {
            try encodeContainer.encode(reputationMetricsEnabled, forKey: .reputationMetricsEnabled)
        }
    }
}

public struct PutConfigurationSetReputationOptionsInputHeadersMiddleware: Middleware {
    public let id: String = "PutConfigurationSetReputationOptionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutConfigurationSetReputationOptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<PutConfigurationSetReputationOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutConfigurationSetReputationOptionsInput>
    public typealias MOutput = OperationOutput<PutConfigurationSetReputationOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutConfigurationSetReputationOptionsOutputError>
}

public struct PutConfigurationSetReputationOptionsInputQueryItemMiddleware: Middleware {
    public let id: String = "PutConfigurationSetReputationOptionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutConfigurationSetReputationOptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<PutConfigurationSetReputationOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutConfigurationSetReputationOptionsInput>
    public typealias MOutput = OperationOutput<PutConfigurationSetReputationOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutConfigurationSetReputationOptionsOutputError>
}

/// <p>A request to enable or disable tracking of reputation metrics for a configuration
///             set.</p>
public struct PutConfigurationSetReputationOptionsInput: Equatable {
    /// <p>The name of the configuration set that you want to enable or disable reputation metric
    ///             tracking for.</p>
    public let configurationSetName: String?
    /// <p>If <code>true</code>, tracking of reputation metrics is enabled for the configuration
    ///             set. If <code>false</code>, tracking of reputation metrics is disabled for the
    ///             configuration set.</p>
    public let reputationMetricsEnabled: Bool

    public init (
        configurationSetName: String? = nil,
        reputationMetricsEnabled: Bool = false
    )
    {
        self.configurationSetName = configurationSetName
        self.reputationMetricsEnabled = reputationMetricsEnabled
    }
}

struct PutConfigurationSetReputationOptionsInputBody: Equatable {
    public let reputationMetricsEnabled: Bool
}

extension PutConfigurationSetReputationOptionsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case reputationMetricsEnabled = "ReputationMetricsEnabled"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reputationMetricsEnabledDecoded = try containerValues.decode(Bool.self, forKey: .reputationMetricsEnabled)
        reputationMetricsEnabled = reputationMetricsEnabledDecoded
    }
}

extension PutConfigurationSetReputationOptionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutConfigurationSetReputationOptionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutConfigurationSetReputationOptionsOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutConfigurationSetReputationOptionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutConfigurationSetReputationOptionsOutputResponse()"}
}

extension PutConfigurationSetReputationOptionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>An HTTP 200 response if the request succeeds, or an error message if the request
///             fails.</p>
public struct PutConfigurationSetReputationOptionsOutputResponse: Equatable {

    public init() {}
}

struct PutConfigurationSetReputationOptionsOutputResponseBody: Equatable {
}

extension PutConfigurationSetReputationOptionsOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct PutConfigurationSetSendingOptionsInputBodyMiddleware: Middleware {
    public let id: String = "PutConfigurationSetSendingOptionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutConfigurationSetSendingOptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<PutConfigurationSetSendingOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutConfigurationSetSendingOptionsInput>
    public typealias MOutput = OperationOutput<PutConfigurationSetSendingOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutConfigurationSetSendingOptionsOutputError>
}

extension PutConfigurationSetSendingOptionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutConfigurationSetSendingOptionsInput(configurationSetName: \(String(describing: configurationSetName)), sendingEnabled: \(String(describing: sendingEnabled)))"}
}

extension PutConfigurationSetSendingOptionsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case sendingEnabled = "SendingEnabled"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if sendingEnabled != false {
            try encodeContainer.encode(sendingEnabled, forKey: .sendingEnabled)
        }
    }
}

public struct PutConfigurationSetSendingOptionsInputHeadersMiddleware: Middleware {
    public let id: String = "PutConfigurationSetSendingOptionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutConfigurationSetSendingOptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<PutConfigurationSetSendingOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutConfigurationSetSendingOptionsInput>
    public typealias MOutput = OperationOutput<PutConfigurationSetSendingOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutConfigurationSetSendingOptionsOutputError>
}

public struct PutConfigurationSetSendingOptionsInputQueryItemMiddleware: Middleware {
    public let id: String = "PutConfigurationSetSendingOptionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutConfigurationSetSendingOptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<PutConfigurationSetSendingOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutConfigurationSetSendingOptionsInput>
    public typealias MOutput = OperationOutput<PutConfigurationSetSendingOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutConfigurationSetSendingOptionsOutputError>
}

/// <p>A request to enable or disable the ability of Amazon Pinpoint to send emails that use a specific
///             configuration set.</p>
public struct PutConfigurationSetSendingOptionsInput: Equatable {
    /// <p>The name of the configuration set that you want to enable or disable email sending
    ///             for.</p>
    public let configurationSetName: String?
    /// <p>If <code>true</code>, email sending is enabled for the configuration set. If
    ///                 <code>false</code>, email sending is disabled for the configuration set.</p>
    public let sendingEnabled: Bool

    public init (
        configurationSetName: String? = nil,
        sendingEnabled: Bool = false
    )
    {
        self.configurationSetName = configurationSetName
        self.sendingEnabled = sendingEnabled
    }
}

struct PutConfigurationSetSendingOptionsInputBody: Equatable {
    public let sendingEnabled: Bool
}

extension PutConfigurationSetSendingOptionsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case sendingEnabled = "SendingEnabled"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sendingEnabledDecoded = try containerValues.decode(Bool.self, forKey: .sendingEnabled)
        sendingEnabled = sendingEnabledDecoded
    }
}

extension PutConfigurationSetSendingOptionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutConfigurationSetSendingOptionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutConfigurationSetSendingOptionsOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutConfigurationSetSendingOptionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutConfigurationSetSendingOptionsOutputResponse()"}
}

extension PutConfigurationSetSendingOptionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>An HTTP 200 response if the request succeeds, or an error message if the request
///             fails.</p>
public struct PutConfigurationSetSendingOptionsOutputResponse: Equatable {

    public init() {}
}

struct PutConfigurationSetSendingOptionsOutputResponseBody: Equatable {
}

extension PutConfigurationSetSendingOptionsOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct PutConfigurationSetTrackingOptionsInputBodyMiddleware: Middleware {
    public let id: String = "PutConfigurationSetTrackingOptionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutConfigurationSetTrackingOptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<PutConfigurationSetTrackingOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutConfigurationSetTrackingOptionsInput>
    public typealias MOutput = OperationOutput<PutConfigurationSetTrackingOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutConfigurationSetTrackingOptionsOutputError>
}

extension PutConfigurationSetTrackingOptionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutConfigurationSetTrackingOptionsInput(configurationSetName: \(String(describing: configurationSetName)), customRedirectDomain: \(String(describing: customRedirectDomain)))"}
}

extension PutConfigurationSetTrackingOptionsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case customRedirectDomain = "CustomRedirectDomain"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customRedirectDomain = customRedirectDomain {
            try encodeContainer.encode(customRedirectDomain, forKey: .customRedirectDomain)
        }
    }
}

public struct PutConfigurationSetTrackingOptionsInputHeadersMiddleware: Middleware {
    public let id: String = "PutConfigurationSetTrackingOptionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutConfigurationSetTrackingOptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<PutConfigurationSetTrackingOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutConfigurationSetTrackingOptionsInput>
    public typealias MOutput = OperationOutput<PutConfigurationSetTrackingOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutConfigurationSetTrackingOptionsOutputError>
}

public struct PutConfigurationSetTrackingOptionsInputQueryItemMiddleware: Middleware {
    public let id: String = "PutConfigurationSetTrackingOptionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutConfigurationSetTrackingOptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<PutConfigurationSetTrackingOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutConfigurationSetTrackingOptionsInput>
    public typealias MOutput = OperationOutput<PutConfigurationSetTrackingOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutConfigurationSetTrackingOptionsOutputError>
}

/// <p>A request to add a custom domain for tracking open and click events to a configuration
///             set.</p>
public struct PutConfigurationSetTrackingOptionsInput: Equatable {
    /// <p>The name of the configuration set that you want to add a custom tracking domain
    ///             to.</p>
    public let configurationSetName: String?
    /// <p>The domain that you want to use to track open and click events.</p>
    public let customRedirectDomain: String?

    public init (
        configurationSetName: String? = nil,
        customRedirectDomain: String? = nil
    )
    {
        self.configurationSetName = configurationSetName
        self.customRedirectDomain = customRedirectDomain
    }
}

struct PutConfigurationSetTrackingOptionsInputBody: Equatable {
    public let customRedirectDomain: String?
}

extension PutConfigurationSetTrackingOptionsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case customRedirectDomain = "CustomRedirectDomain"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let customRedirectDomainDecoded = try containerValues.decodeIfPresent(String.self, forKey: .customRedirectDomain)
        customRedirectDomain = customRedirectDomainDecoded
    }
}

extension PutConfigurationSetTrackingOptionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutConfigurationSetTrackingOptionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutConfigurationSetTrackingOptionsOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutConfigurationSetTrackingOptionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutConfigurationSetTrackingOptionsOutputResponse()"}
}

extension PutConfigurationSetTrackingOptionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>An HTTP 200 response if the request succeeds, or an error message if the request
///             fails.</p>
public struct PutConfigurationSetTrackingOptionsOutputResponse: Equatable {

    public init() {}
}

struct PutConfigurationSetTrackingOptionsOutputResponseBody: Equatable {
}

extension PutConfigurationSetTrackingOptionsOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct PutDedicatedIpInPoolInputBodyMiddleware: Middleware {
    public let id: String = "PutDedicatedIpInPoolInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutDedicatedIpInPoolInput>,
                  next: H) -> Swift.Result<OperationOutput<PutDedicatedIpInPoolOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutDedicatedIpInPoolInput>
    public typealias MOutput = OperationOutput<PutDedicatedIpInPoolOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutDedicatedIpInPoolOutputError>
}

extension PutDedicatedIpInPoolInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutDedicatedIpInPoolInput(destinationPoolName: \(String(describing: destinationPoolName)), ip: \(String(describing: ip)))"}
}

extension PutDedicatedIpInPoolInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case destinationPoolName = "DestinationPoolName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationPoolName = destinationPoolName {
            try encodeContainer.encode(destinationPoolName, forKey: .destinationPoolName)
        }
    }
}

public struct PutDedicatedIpInPoolInputHeadersMiddleware: Middleware {
    public let id: String = "PutDedicatedIpInPoolInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutDedicatedIpInPoolInput>,
                  next: H) -> Swift.Result<OperationOutput<PutDedicatedIpInPoolOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutDedicatedIpInPoolInput>
    public typealias MOutput = OperationOutput<PutDedicatedIpInPoolOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutDedicatedIpInPoolOutputError>
}

public struct PutDedicatedIpInPoolInputQueryItemMiddleware: Middleware {
    public let id: String = "PutDedicatedIpInPoolInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutDedicatedIpInPoolInput>,
                  next: H) -> Swift.Result<OperationOutput<PutDedicatedIpInPoolOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutDedicatedIpInPoolInput>
    public typealias MOutput = OperationOutput<PutDedicatedIpInPoolOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutDedicatedIpInPoolOutputError>
}

/// <p>A request to move a dedicated IP address to a dedicated IP pool.</p>
public struct PutDedicatedIpInPoolInput: Equatable {
    /// <p>The name of the IP pool that you want to add the dedicated IP address to. You have to
    ///             specify an IP pool that already exists.</p>
    public let destinationPoolName: String?
    /// <p>The IP address that you want to move to the dedicated IP pool. The value you specify
    ///             has to be a dedicated IP address that's associated with your Amazon Pinpoint account.</p>
    public let ip: String?

    public init (
        destinationPoolName: String? = nil,
        ip: String? = nil
    )
    {
        self.destinationPoolName = destinationPoolName
        self.ip = ip
    }
}

struct PutDedicatedIpInPoolInputBody: Equatable {
    public let destinationPoolName: String?
}

extension PutDedicatedIpInPoolInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case destinationPoolName = "DestinationPoolName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationPoolNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .destinationPoolName)
        destinationPoolName = destinationPoolNameDecoded
    }
}

extension PutDedicatedIpInPoolOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutDedicatedIpInPoolOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutDedicatedIpInPoolOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutDedicatedIpInPoolOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutDedicatedIpInPoolOutputResponse()"}
}

extension PutDedicatedIpInPoolOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>An HTTP 200 response if the request succeeds, or an error message if the request
///             fails.</p>
public struct PutDedicatedIpInPoolOutputResponse: Equatable {

    public init() {}
}

struct PutDedicatedIpInPoolOutputResponseBody: Equatable {
}

extension PutDedicatedIpInPoolOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct PutDedicatedIpWarmupAttributesInputBodyMiddleware: Middleware {
    public let id: String = "PutDedicatedIpWarmupAttributesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutDedicatedIpWarmupAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<PutDedicatedIpWarmupAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutDedicatedIpWarmupAttributesInput>
    public typealias MOutput = OperationOutput<PutDedicatedIpWarmupAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutDedicatedIpWarmupAttributesOutputError>
}

extension PutDedicatedIpWarmupAttributesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutDedicatedIpWarmupAttributesInput(ip: \(String(describing: ip)), warmupPercentage: \(String(describing: warmupPercentage)))"}
}

extension PutDedicatedIpWarmupAttributesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case warmupPercentage = "WarmupPercentage"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let warmupPercentage = warmupPercentage {
            try encodeContainer.encode(warmupPercentage, forKey: .warmupPercentage)
        }
    }
}

public struct PutDedicatedIpWarmupAttributesInputHeadersMiddleware: Middleware {
    public let id: String = "PutDedicatedIpWarmupAttributesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutDedicatedIpWarmupAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<PutDedicatedIpWarmupAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutDedicatedIpWarmupAttributesInput>
    public typealias MOutput = OperationOutput<PutDedicatedIpWarmupAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutDedicatedIpWarmupAttributesOutputError>
}

public struct PutDedicatedIpWarmupAttributesInputQueryItemMiddleware: Middleware {
    public let id: String = "PutDedicatedIpWarmupAttributesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutDedicatedIpWarmupAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<PutDedicatedIpWarmupAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutDedicatedIpWarmupAttributesInput>
    public typealias MOutput = OperationOutput<PutDedicatedIpWarmupAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutDedicatedIpWarmupAttributesOutputError>
}

/// <p>A request to change the warm-up attributes for a dedicated IP address. This operation
///             is useful when you want to resume the warm-up process for an existing IP address.</p>
public struct PutDedicatedIpWarmupAttributesInput: Equatable {
    /// <p>The dedicated IP address that you want to update the warm-up attributes for.</p>
    public let ip: String?
    /// <p>The warm-up percentage that you want to associate with the dedicated IP
    ///             address.</p>
    public let warmupPercentage: Int?

    public init (
        ip: String? = nil,
        warmupPercentage: Int? = nil
    )
    {
        self.ip = ip
        self.warmupPercentage = warmupPercentage
    }
}

struct PutDedicatedIpWarmupAttributesInputBody: Equatable {
    public let warmupPercentage: Int?
}

extension PutDedicatedIpWarmupAttributesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case warmupPercentage = "WarmupPercentage"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let warmupPercentageDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .warmupPercentage)
        warmupPercentage = warmupPercentageDecoded
    }
}

extension PutDedicatedIpWarmupAttributesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutDedicatedIpWarmupAttributesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutDedicatedIpWarmupAttributesOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutDedicatedIpWarmupAttributesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutDedicatedIpWarmupAttributesOutputResponse()"}
}

extension PutDedicatedIpWarmupAttributesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>An HTTP 200 response if the request succeeds, or an error message if the request
///             fails.</p>
public struct PutDedicatedIpWarmupAttributesOutputResponse: Equatable {

    public init() {}
}

struct PutDedicatedIpWarmupAttributesOutputResponseBody: Equatable {
}

extension PutDedicatedIpWarmupAttributesOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct PutDeliverabilityDashboardOptionInputBodyMiddleware: Middleware {
    public let id: String = "PutDeliverabilityDashboardOptionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutDeliverabilityDashboardOptionInput>,
                  next: H) -> Swift.Result<OperationOutput<PutDeliverabilityDashboardOptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutDeliverabilityDashboardOptionInput>
    public typealias MOutput = OperationOutput<PutDeliverabilityDashboardOptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutDeliverabilityDashboardOptionOutputError>
}

extension PutDeliverabilityDashboardOptionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutDeliverabilityDashboardOptionInput(dashboardEnabled: \(String(describing: dashboardEnabled)), subscribedDomains: \(String(describing: subscribedDomains)))"}
}

extension PutDeliverabilityDashboardOptionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dashboardEnabled = "DashboardEnabled"
        case subscribedDomains = "SubscribedDomains"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if dashboardEnabled != false {
            try encodeContainer.encode(dashboardEnabled, forKey: .dashboardEnabled)
        }
        if let subscribedDomains = subscribedDomains {
            var subscribedDomainsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subscribedDomains)
            for domaindeliverabilitytrackingoptions0 in subscribedDomains {
                try subscribedDomainsContainer.encode(domaindeliverabilitytrackingoptions0)
            }
        }
    }
}

public struct PutDeliverabilityDashboardOptionInputHeadersMiddleware: Middleware {
    public let id: String = "PutDeliverabilityDashboardOptionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutDeliverabilityDashboardOptionInput>,
                  next: H) -> Swift.Result<OperationOutput<PutDeliverabilityDashboardOptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutDeliverabilityDashboardOptionInput>
    public typealias MOutput = OperationOutput<PutDeliverabilityDashboardOptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutDeliverabilityDashboardOptionOutputError>
}

public struct PutDeliverabilityDashboardOptionInputQueryItemMiddleware: Middleware {
    public let id: String = "PutDeliverabilityDashboardOptionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutDeliverabilityDashboardOptionInput>,
                  next: H) -> Swift.Result<OperationOutput<PutDeliverabilityDashboardOptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutDeliverabilityDashboardOptionInput>
    public typealias MOutput = OperationOutput<PutDeliverabilityDashboardOptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutDeliverabilityDashboardOptionOutputError>
}

/// <p>Enable or disable the Deliverability dashboard for your Amazon Pinpoint account. When you enable the
///             Deliverability dashboard, you gain access to reputation, deliverability, and other metrics for
///             the domains that you use to send email using Amazon Pinpoint. You also gain the ability to perform
///             predictive inbox placement tests.</p>
///         <p>When you use the Deliverability dashboard, you pay a monthly subscription charge, in addition
///             to any other fees that you accrue by using Amazon Pinpoint. For more information about the
///             features and cost of a Deliverability dashboard subscription, see <a href="http://aws.amazon.com/pinpoint/pricing/">Amazon Pinpoint Pricing</a>.</p>
public struct PutDeliverabilityDashboardOptionInput: Equatable {
    /// <p>Specifies whether to enable the Deliverability dashboard for your Amazon Pinpoint account. To enable the
    ///             dashboard, set this value to <code>true</code>.</p>
    public let dashboardEnabled: Bool
    /// <p>An array of objects, one for each verified domain that you use to send email and
    ///             enabled the Deliverability dashboard for.</p>
    public let subscribedDomains: [DomainDeliverabilityTrackingOption]?

    public init (
        dashboardEnabled: Bool = false,
        subscribedDomains: [DomainDeliverabilityTrackingOption]? = nil
    )
    {
        self.dashboardEnabled = dashboardEnabled
        self.subscribedDomains = subscribedDomains
    }
}

struct PutDeliverabilityDashboardOptionInputBody: Equatable {
    public let dashboardEnabled: Bool
    public let subscribedDomains: [DomainDeliverabilityTrackingOption]?
}

extension PutDeliverabilityDashboardOptionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dashboardEnabled = "DashboardEnabled"
        case subscribedDomains = "SubscribedDomains"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dashboardEnabledDecoded = try containerValues.decode(Bool.self, forKey: .dashboardEnabled)
        dashboardEnabled = dashboardEnabledDecoded
        let subscribedDomainsContainer = try containerValues.decodeIfPresent([DomainDeliverabilityTrackingOption?].self, forKey: .subscribedDomains)
        var subscribedDomainsDecoded0:[DomainDeliverabilityTrackingOption]? = nil
        if let subscribedDomainsContainer = subscribedDomainsContainer {
            subscribedDomainsDecoded0 = [DomainDeliverabilityTrackingOption]()
            for structure0 in subscribedDomainsContainer {
                if let structure0 = structure0 {
                    subscribedDomainsDecoded0?.append(structure0)
                }
            }
        }
        subscribedDomains = subscribedDomainsDecoded0
    }
}

extension PutDeliverabilityDashboardOptionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutDeliverabilityDashboardOptionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AlreadyExistsException" : self = .alreadyExistsException(try AlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutDeliverabilityDashboardOptionOutputError: Swift.Error, Equatable {
    case alreadyExistsException(AlreadyExistsException)
    case badRequestException(BadRequestException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutDeliverabilityDashboardOptionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutDeliverabilityDashboardOptionOutputResponse()"}
}

extension PutDeliverabilityDashboardOptionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>A response that indicates whether the Deliverability dashboard is enabled for your Amazon Pinpoint
///             account.</p>
public struct PutDeliverabilityDashboardOptionOutputResponse: Equatable {

    public init() {}
}

struct PutDeliverabilityDashboardOptionOutputResponseBody: Equatable {
}

extension PutDeliverabilityDashboardOptionOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct PutEmailIdentityDkimAttributesInputBodyMiddleware: Middleware {
    public let id: String = "PutEmailIdentityDkimAttributesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutEmailIdentityDkimAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<PutEmailIdentityDkimAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutEmailIdentityDkimAttributesInput>
    public typealias MOutput = OperationOutput<PutEmailIdentityDkimAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutEmailIdentityDkimAttributesOutputError>
}

extension PutEmailIdentityDkimAttributesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutEmailIdentityDkimAttributesInput(emailIdentity: \(String(describing: emailIdentity)), signingEnabled: \(String(describing: signingEnabled)))"}
}

extension PutEmailIdentityDkimAttributesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case signingEnabled = "SigningEnabled"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if signingEnabled != false {
            try encodeContainer.encode(signingEnabled, forKey: .signingEnabled)
        }
    }
}

public struct PutEmailIdentityDkimAttributesInputHeadersMiddleware: Middleware {
    public let id: String = "PutEmailIdentityDkimAttributesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutEmailIdentityDkimAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<PutEmailIdentityDkimAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutEmailIdentityDkimAttributesInput>
    public typealias MOutput = OperationOutput<PutEmailIdentityDkimAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutEmailIdentityDkimAttributesOutputError>
}

public struct PutEmailIdentityDkimAttributesInputQueryItemMiddleware: Middleware {
    public let id: String = "PutEmailIdentityDkimAttributesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutEmailIdentityDkimAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<PutEmailIdentityDkimAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutEmailIdentityDkimAttributesInput>
    public typealias MOutput = OperationOutput<PutEmailIdentityDkimAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutEmailIdentityDkimAttributesOutputError>
}

/// <p>A request to enable or disable DKIM signing of email that you send from an email
///             identity.</p>
public struct PutEmailIdentityDkimAttributesInput: Equatable {
    /// <p>The email identity that you want to change the DKIM settings for.</p>
    public let emailIdentity: String?
    /// <p>Sets the DKIM signing configuration for the identity.</p>
    ///         <p>When you set this value <code>true</code>, then the messages that Amazon Pinpoint sends from the
    ///             identity are DKIM-signed. When you set this value to <code>false</code>, then the
    ///             messages that Amazon Pinpoint sends from the identity aren't DKIM-signed.</p>
    public let signingEnabled: Bool

    public init (
        emailIdentity: String? = nil,
        signingEnabled: Bool = false
    )
    {
        self.emailIdentity = emailIdentity
        self.signingEnabled = signingEnabled
    }
}

struct PutEmailIdentityDkimAttributesInputBody: Equatable {
    public let signingEnabled: Bool
}

extension PutEmailIdentityDkimAttributesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case signingEnabled = "SigningEnabled"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let signingEnabledDecoded = try containerValues.decode(Bool.self, forKey: .signingEnabled)
        signingEnabled = signingEnabledDecoded
    }
}

extension PutEmailIdentityDkimAttributesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutEmailIdentityDkimAttributesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutEmailIdentityDkimAttributesOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutEmailIdentityDkimAttributesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutEmailIdentityDkimAttributesOutputResponse()"}
}

extension PutEmailIdentityDkimAttributesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>An HTTP 200 response if the request succeeds, or an error message if the request
///             fails.</p>
public struct PutEmailIdentityDkimAttributesOutputResponse: Equatable {

    public init() {}
}

struct PutEmailIdentityDkimAttributesOutputResponseBody: Equatable {
}

extension PutEmailIdentityDkimAttributesOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct PutEmailIdentityFeedbackAttributesInputBodyMiddleware: Middleware {
    public let id: String = "PutEmailIdentityFeedbackAttributesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutEmailIdentityFeedbackAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<PutEmailIdentityFeedbackAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutEmailIdentityFeedbackAttributesInput>
    public typealias MOutput = OperationOutput<PutEmailIdentityFeedbackAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutEmailIdentityFeedbackAttributesOutputError>
}

extension PutEmailIdentityFeedbackAttributesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutEmailIdentityFeedbackAttributesInput(emailForwardingEnabled: \(String(describing: emailForwardingEnabled)), emailIdentity: \(String(describing: emailIdentity)))"}
}

extension PutEmailIdentityFeedbackAttributesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case emailForwardingEnabled = "EmailForwardingEnabled"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if emailForwardingEnabled != false {
            try encodeContainer.encode(emailForwardingEnabled, forKey: .emailForwardingEnabled)
        }
    }
}

public struct PutEmailIdentityFeedbackAttributesInputHeadersMiddleware: Middleware {
    public let id: String = "PutEmailIdentityFeedbackAttributesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutEmailIdentityFeedbackAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<PutEmailIdentityFeedbackAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutEmailIdentityFeedbackAttributesInput>
    public typealias MOutput = OperationOutput<PutEmailIdentityFeedbackAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutEmailIdentityFeedbackAttributesOutputError>
}

public struct PutEmailIdentityFeedbackAttributesInputQueryItemMiddleware: Middleware {
    public let id: String = "PutEmailIdentityFeedbackAttributesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutEmailIdentityFeedbackAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<PutEmailIdentityFeedbackAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutEmailIdentityFeedbackAttributesInput>
    public typealias MOutput = OperationOutput<PutEmailIdentityFeedbackAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutEmailIdentityFeedbackAttributesOutputError>
}

/// <p>A request to set the attributes that control how bounce and complaint events are
///             processed.</p>
public struct PutEmailIdentityFeedbackAttributesInput: Equatable {
    /// <p>Sets the feedback forwarding configuration for the identity.</p>
    ///         <p>If the value is <code>true</code>, Amazon Pinpoint sends you email notifications when bounce or
    ///             complaint events occur. Amazon Pinpoint sends this notification to the address that you specified
    ///             in the Return-Path header of the original email.</p>
    ///         <p>When you set this value to <code>false</code>, Amazon Pinpoint sends notifications through other
    ///             mechanisms, such as by notifying an Amazon SNS topic or another event destination. You're
    ///             required to have a method of tracking bounces and complaints. If you haven't set up
    ///             another mechanism for receiving bounce or complaint notifications, Amazon Pinpoint sends an email
    ///             notification when these events occur (even if this setting is disabled).</p>
    public let emailForwardingEnabled: Bool
    /// <p>The email identity that you want to configure bounce and complaint feedback forwarding
    ///             for.</p>
    public let emailIdentity: String?

    public init (
        emailForwardingEnabled: Bool = false,
        emailIdentity: String? = nil
    )
    {
        self.emailForwardingEnabled = emailForwardingEnabled
        self.emailIdentity = emailIdentity
    }
}

struct PutEmailIdentityFeedbackAttributesInputBody: Equatable {
    public let emailForwardingEnabled: Bool
}

extension PutEmailIdentityFeedbackAttributesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case emailForwardingEnabled = "EmailForwardingEnabled"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let emailForwardingEnabledDecoded = try containerValues.decode(Bool.self, forKey: .emailForwardingEnabled)
        emailForwardingEnabled = emailForwardingEnabledDecoded
    }
}

extension PutEmailIdentityFeedbackAttributesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutEmailIdentityFeedbackAttributesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutEmailIdentityFeedbackAttributesOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutEmailIdentityFeedbackAttributesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutEmailIdentityFeedbackAttributesOutputResponse()"}
}

extension PutEmailIdentityFeedbackAttributesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>An HTTP 200 response if the request succeeds, or an error message if the request
///             fails.</p>
public struct PutEmailIdentityFeedbackAttributesOutputResponse: Equatable {

    public init() {}
}

struct PutEmailIdentityFeedbackAttributesOutputResponseBody: Equatable {
}

extension PutEmailIdentityFeedbackAttributesOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct PutEmailIdentityMailFromAttributesInputBodyMiddleware: Middleware {
    public let id: String = "PutEmailIdentityMailFromAttributesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutEmailIdentityMailFromAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<PutEmailIdentityMailFromAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutEmailIdentityMailFromAttributesInput>
    public typealias MOutput = OperationOutput<PutEmailIdentityMailFromAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutEmailIdentityMailFromAttributesOutputError>
}

extension PutEmailIdentityMailFromAttributesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutEmailIdentityMailFromAttributesInput(behaviorOnMxFailure: \(String(describing: behaviorOnMxFailure)), emailIdentity: \(String(describing: emailIdentity)), mailFromDomain: \(String(describing: mailFromDomain)))"}
}

extension PutEmailIdentityMailFromAttributesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case behaviorOnMxFailure = "BehaviorOnMxFailure"
        case mailFromDomain = "MailFromDomain"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let behaviorOnMxFailure = behaviorOnMxFailure {
            try encodeContainer.encode(behaviorOnMxFailure.rawValue, forKey: .behaviorOnMxFailure)
        }
        if let mailFromDomain = mailFromDomain {
            try encodeContainer.encode(mailFromDomain, forKey: .mailFromDomain)
        }
    }
}

public struct PutEmailIdentityMailFromAttributesInputHeadersMiddleware: Middleware {
    public let id: String = "PutEmailIdentityMailFromAttributesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutEmailIdentityMailFromAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<PutEmailIdentityMailFromAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutEmailIdentityMailFromAttributesInput>
    public typealias MOutput = OperationOutput<PutEmailIdentityMailFromAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutEmailIdentityMailFromAttributesOutputError>
}

public struct PutEmailIdentityMailFromAttributesInputQueryItemMiddleware: Middleware {
    public let id: String = "PutEmailIdentityMailFromAttributesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutEmailIdentityMailFromAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<PutEmailIdentityMailFromAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutEmailIdentityMailFromAttributesInput>
    public typealias MOutput = OperationOutput<PutEmailIdentityMailFromAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutEmailIdentityMailFromAttributesOutputError>
}

/// <p>A request to configure the custom MAIL FROM domain for a verified identity.</p>
public struct PutEmailIdentityMailFromAttributesInput: Equatable {
    /// <p>The action that you want Amazon Pinpoint to take if it can't read the required MX record when
    ///             you send an email. When you set this value to <code>UseDefaultValue</code>, Amazon Pinpoint uses
    ///                 <i>amazonses.com</i> as the MAIL FROM domain. When you set this value
    ///             to <code>RejectMessage</code>, Amazon Pinpoint returns a <code>MailFromDomainNotVerified</code>
    ///             error, and doesn't attempt to deliver the email.</p>
    ///         <p>These behaviors are taken when the custom MAIL FROM domain configuration is in the
    ///                 <code>Pending</code>, <code>Failed</code>, and <code>TemporaryFailure</code>
    ///             states.</p>
    public let behaviorOnMxFailure: BehaviorOnMxFailure?
    /// <p>The verified email identity that you want to set up the custom MAIL FROM domain
    ///             for.</p>
    public let emailIdentity: String?
    /// <p> The custom MAIL FROM domain that you want the verified identity to use. The MAIL FROM
    ///             domain must meet the following criteria:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>It has to be a subdomain of the verified identity.</p>
    ///             </li>
    ///             <li>
    ///                 <p>It can't be used to receive email.</p>
    ///             </li>
    ///             <li>
    ///                 <p>It can't be used in a "From" address if the MAIL FROM domain is a destination
    ///                     for feedback forwarding emails.</p>
    ///             </li>
    ///          </ul>
    public let mailFromDomain: String?

    public init (
        behaviorOnMxFailure: BehaviorOnMxFailure? = nil,
        emailIdentity: String? = nil,
        mailFromDomain: String? = nil
    )
    {
        self.behaviorOnMxFailure = behaviorOnMxFailure
        self.emailIdentity = emailIdentity
        self.mailFromDomain = mailFromDomain
    }
}

struct PutEmailIdentityMailFromAttributesInputBody: Equatable {
    public let mailFromDomain: String?
    public let behaviorOnMxFailure: BehaviorOnMxFailure?
}

extension PutEmailIdentityMailFromAttributesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case behaviorOnMxFailure = "BehaviorOnMxFailure"
        case mailFromDomain = "MailFromDomain"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mailFromDomainDecoded = try containerValues.decodeIfPresent(String.self, forKey: .mailFromDomain)
        mailFromDomain = mailFromDomainDecoded
        let behaviorOnMxFailureDecoded = try containerValues.decodeIfPresent(BehaviorOnMxFailure.self, forKey: .behaviorOnMxFailure)
        behaviorOnMxFailure = behaviorOnMxFailureDecoded
    }
}

extension PutEmailIdentityMailFromAttributesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutEmailIdentityMailFromAttributesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutEmailIdentityMailFromAttributesOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutEmailIdentityMailFromAttributesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutEmailIdentityMailFromAttributesOutputResponse()"}
}

extension PutEmailIdentityMailFromAttributesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>An HTTP 200 response if the request succeeds, or an error message if the request
///             fails.</p>
public struct PutEmailIdentityMailFromAttributesOutputResponse: Equatable {

    public init() {}
}

struct PutEmailIdentityMailFromAttributesOutputResponseBody: Equatable {
}

extension PutEmailIdentityMailFromAttributesOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension RawMessage: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case data = "Data"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let data = data {
            try encodeContainer.encode(data.base64EncodedString(), forKey: .data)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .data)
        data = dataDecoded
    }
}

extension RawMessage: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RawMessage(data: \(String(describing: data)))"}
}

/// <p>The raw email message.</p>
public struct RawMessage: Equatable {
    /// <p>The raw email message. The message has to meet the following criteria:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>The message has to contain a header and a body, separated by one blank
    ///                     line.</p>
    ///             </li>
    ///             <li>
    ///                 <p>All of the required header fields must be present in the message.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Each part of a multipart MIME message must be formatted properly.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Attachments must be in a file format that Amazon Pinpoint supports.
    ///                     </p>
    ///             </li>
    ///             <li>
    ///                 <p>The entire message must be Base64 encoded.</p>
    ///             </li>
    ///             <li>
    ///                 <p>If any of the MIME parts in your message contain content that is outside of
    ///                     the 7-bit ASCII character range, you should encode that content to ensure that
    ///                     recipients' email clients render the message properly.</p>
    ///             </li>
    ///             <li>
    ///                 <p>The length of any single line of text in the message can't exceed 1,000
    ///                     characters. This restriction is defined in <a href="https://tools.ietf.org/html/rfc5321">RFC 5321</a>.</p>
    ///             </li>
    ///          </ul>
    public let data: Data?

    public init (
        data: Data? = nil
    )
    {
        self.data = data
    }
}

extension ReputationOptions: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case lastFreshStart = "LastFreshStart"
        case reputationMetricsEnabled = "ReputationMetricsEnabled"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lastFreshStart = lastFreshStart {
            try encodeContainer.encode(lastFreshStart.timeIntervalSince1970, forKey: .lastFreshStart)
        }
        if reputationMetricsEnabled != false {
            try encodeContainer.encode(reputationMetricsEnabled, forKey: .reputationMetricsEnabled)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reputationMetricsEnabledDecoded = try containerValues.decode(Bool.self, forKey: .reputationMetricsEnabled)
        reputationMetricsEnabled = reputationMetricsEnabledDecoded
        let lastFreshStartDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastFreshStart)
        lastFreshStart = lastFreshStartDecoded
    }
}

extension ReputationOptions: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReputationOptions(lastFreshStart: \(String(describing: lastFreshStart)), reputationMetricsEnabled: \(String(describing: reputationMetricsEnabled)))"}
}

/// <p>Enable or disable collection of reputation metrics for emails that you send using this
///             configuration set in the current AWS Region. </p>
public struct ReputationOptions: Equatable {
    /// <p>The date and time (in Unix time) when the reputation metrics were last given a fresh
    ///             start. When your account is given a fresh start, your reputation metrics are calculated
    ///             starting from the date of the fresh start.</p>
    public let lastFreshStart: Date?
    /// <p>If <code>true</code>, tracking of reputation metrics is enabled for the configuration
    ///             set. If <code>false</code>, tracking of reputation metrics is disabled for the
    ///             configuration set.</p>
    public let reputationMetricsEnabled: Bool

    public init (
        lastFreshStart: Date? = nil,
        reputationMetricsEnabled: Bool = false
    )
    {
        self.lastFreshStart = lastFreshStart
        self.reputationMetricsEnabled = reputationMetricsEnabled
    }
}

public struct SendEmailInputBodyMiddleware: Middleware {
    public let id: String = "SendEmailInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SendEmailInput>,
                  next: H) -> Swift.Result<OperationOutput<SendEmailOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SendEmailInput>
    public typealias MOutput = OperationOutput<SendEmailOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SendEmailOutputError>
}

extension SendEmailInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SendEmailInput(configurationSetName: \(String(describing: configurationSetName)), content: \(String(describing: content)), destination: \(String(describing: destination)), emailTags: \(String(describing: emailTags)), feedbackForwardingEmailAddress: \(String(describing: feedbackForwardingEmailAddress)), fromEmailAddress: \(String(describing: fromEmailAddress)), replyToAddresses: \(String(describing: replyToAddresses)))"}
}

extension SendEmailInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case configurationSetName = "ConfigurationSetName"
        case content = "Content"
        case destination = "Destination"
        case emailTags = "EmailTags"
        case feedbackForwardingEmailAddress = "FeedbackForwardingEmailAddress"
        case fromEmailAddress = "FromEmailAddress"
        case replyToAddresses = "ReplyToAddresses"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationSetName = configurationSetName {
            try encodeContainer.encode(configurationSetName, forKey: .configurationSetName)
        }
        if let content = content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let destination = destination {
            try encodeContainer.encode(destination, forKey: .destination)
        }
        if let emailTags = emailTags {
            var emailTagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .emailTags)
            for messagetaglist0 in emailTags {
                try emailTagsContainer.encode(messagetaglist0)
            }
        }
        if let feedbackForwardingEmailAddress = feedbackForwardingEmailAddress {
            try encodeContainer.encode(feedbackForwardingEmailAddress, forKey: .feedbackForwardingEmailAddress)
        }
        if let fromEmailAddress = fromEmailAddress {
            try encodeContainer.encode(fromEmailAddress, forKey: .fromEmailAddress)
        }
        if let replyToAddresses = replyToAddresses {
            var replyToAddressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .replyToAddresses)
            for emailaddresslist0 in replyToAddresses {
                try replyToAddressesContainer.encode(emailaddresslist0)
            }
        }
    }
}

public struct SendEmailInputHeadersMiddleware: Middleware {
    public let id: String = "SendEmailInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SendEmailInput>,
                  next: H) -> Swift.Result<OperationOutput<SendEmailOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SendEmailInput>
    public typealias MOutput = OperationOutput<SendEmailOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SendEmailOutputError>
}

public struct SendEmailInputQueryItemMiddleware: Middleware {
    public let id: String = "SendEmailInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SendEmailInput>,
                  next: H) -> Swift.Result<OperationOutput<SendEmailOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SendEmailInput>
    public typealias MOutput = OperationOutput<SendEmailOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SendEmailOutputError>
}

/// <p>A request to send an email message.</p>
public struct SendEmailInput: Equatable {
    /// <p>The name of the configuration set that you want to use when sending the email.</p>
    public let configurationSetName: String?
    /// <p>An object that contains the body of the message. You can send either a Simple message
    ///             or a Raw message.</p>
    public let content: EmailContent?
    /// <p>An object that contains the recipients of the email message.</p>
    public let destination: Destination?
    /// <p>A list of tags, in the form of name/value pairs, to apply to an email that you send
    ///             using the <code>SendEmail</code> operation. Tags correspond to characteristics of the
    ///             email that you define, so that you can publish email sending events. </p>
    public let emailTags: [MessageTag]?
    /// <p>The address that Amazon Pinpoint should send bounce and complaint notifications to.</p>
    public let feedbackForwardingEmailAddress: String?
    /// <p>The email address that you want to use as the "From" address for the email. The
    ///             address that you specify has to be verified.
    ///             </p>
    public let fromEmailAddress: String?
    /// <p>The "Reply-to" email addresses for the message. When the recipient replies to the
    ///             message, each Reply-to address receives the reply.</p>
    public let replyToAddresses: [String]?

    public init (
        configurationSetName: String? = nil,
        content: EmailContent? = nil,
        destination: Destination? = nil,
        emailTags: [MessageTag]? = nil,
        feedbackForwardingEmailAddress: String? = nil,
        fromEmailAddress: String? = nil,
        replyToAddresses: [String]? = nil
    )
    {
        self.configurationSetName = configurationSetName
        self.content = content
        self.destination = destination
        self.emailTags = emailTags
        self.feedbackForwardingEmailAddress = feedbackForwardingEmailAddress
        self.fromEmailAddress = fromEmailAddress
        self.replyToAddresses = replyToAddresses
    }
}

struct SendEmailInputBody: Equatable {
    public let fromEmailAddress: String?
    public let destination: Destination?
    public let replyToAddresses: [String]?
    public let feedbackForwardingEmailAddress: String?
    public let content: EmailContent?
    public let emailTags: [MessageTag]?
    public let configurationSetName: String?
}

extension SendEmailInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case configurationSetName = "ConfigurationSetName"
        case content = "Content"
        case destination = "Destination"
        case emailTags = "EmailTags"
        case feedbackForwardingEmailAddress = "FeedbackForwardingEmailAddress"
        case fromEmailAddress = "FromEmailAddress"
        case replyToAddresses = "ReplyToAddresses"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fromEmailAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fromEmailAddress)
        fromEmailAddress = fromEmailAddressDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(Destination.self, forKey: .destination)
        destination = destinationDecoded
        let replyToAddressesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .replyToAddresses)
        var replyToAddressesDecoded0:[String]? = nil
        if let replyToAddressesContainer = replyToAddressesContainer {
            replyToAddressesDecoded0 = [String]()
            for string0 in replyToAddressesContainer {
                if let string0 = string0 {
                    replyToAddressesDecoded0?.append(string0)
                }
            }
        }
        replyToAddresses = replyToAddressesDecoded0
        let feedbackForwardingEmailAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .feedbackForwardingEmailAddress)
        feedbackForwardingEmailAddress = feedbackForwardingEmailAddressDecoded
        let contentDecoded = try containerValues.decodeIfPresent(EmailContent.self, forKey: .content)
        content = contentDecoded
        let emailTagsContainer = try containerValues.decodeIfPresent([MessageTag?].self, forKey: .emailTags)
        var emailTagsDecoded0:[MessageTag]? = nil
        if let emailTagsContainer = emailTagsContainer {
            emailTagsDecoded0 = [MessageTag]()
            for structure0 in emailTagsContainer {
                if let structure0 = structure0 {
                    emailTagsDecoded0?.append(structure0)
                }
            }
        }
        emailTags = emailTagsDecoded0
        let configurationSetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .configurationSetName)
        configurationSetName = configurationSetNameDecoded
    }
}

extension SendEmailOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SendEmailOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccountSuspendedException" : self = .accountSuspendedException(try AccountSuspendedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MailFromDomainNotVerifiedException" : self = .mailFromDomainNotVerifiedException(try MailFromDomainNotVerifiedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MessageRejected" : self = .messageRejected(try MessageRejected(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SendingPausedException" : self = .sendingPausedException(try SendingPausedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SendEmailOutputError: Swift.Error, Equatable {
    case accountSuspendedException(AccountSuspendedException)
    case badRequestException(BadRequestException)
    case limitExceededException(LimitExceededException)
    case mailFromDomainNotVerifiedException(MailFromDomainNotVerifiedException)
    case messageRejected(MessageRejected)
    case notFoundException(NotFoundException)
    case sendingPausedException(SendingPausedException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SendEmailOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SendEmailOutputResponse(messageId: \(String(describing: messageId)))"}
}

extension SendEmailOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: SendEmailOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.messageId = output.messageId
        } else {
            self.messageId = nil
        }
    }
}

/// <p>A unique message ID that you receive when Amazon Pinpoint accepts an email for sending.</p>
public struct SendEmailOutputResponse: Equatable {
    /// <p>A unique identifier for the message that is generated when Amazon Pinpoint accepts the
    ///             message.</p>
    ///         <note>
    ///             <p>It is possible for Amazon Pinpoint to accept a message without sending it. This can happen
    ///                 when the message you're trying to send has an attachment doesn't pass a virus check,
    ///                 or when you send a templated email that contains invalid personalization content,
    ///                 for example.</p>
    ///         </note>
    public let messageId: String?

    public init (
        messageId: String? = nil
    )
    {
        self.messageId = messageId
    }
}

struct SendEmailOutputResponseBody: Equatable {
    public let messageId: String?
}

extension SendEmailOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case messageId = "MessageId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .messageId)
        messageId = messageIdDecoded
    }
}

extension SendQuota: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case max24HourSend = "Max24HourSend"
        case maxSendRate = "MaxSendRate"
        case sentLast24Hours = "SentLast24Hours"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if max24HourSend != 0.0 {
            try encodeContainer.encode(max24HourSend, forKey: .max24HourSend)
        }
        if maxSendRate != 0.0 {
            try encodeContainer.encode(maxSendRate, forKey: .maxSendRate)
        }
        if sentLast24Hours != 0.0 {
            try encodeContainer.encode(sentLast24Hours, forKey: .sentLast24Hours)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let max24HourSendDecoded = try containerValues.decode(Double.self, forKey: .max24HourSend)
        max24HourSend = max24HourSendDecoded
        let maxSendRateDecoded = try containerValues.decode(Double.self, forKey: .maxSendRate)
        maxSendRate = maxSendRateDecoded
        let sentLast24HoursDecoded = try containerValues.decode(Double.self, forKey: .sentLast24Hours)
        sentLast24Hours = sentLast24HoursDecoded
    }
}

extension SendQuota: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SendQuota(max24HourSend: \(String(describing: max24HourSend)), maxSendRate: \(String(describing: maxSendRate)), sentLast24Hours: \(String(describing: sentLast24Hours)))"}
}

/// <p>An object that contains information about the per-day and per-second sending limits
///             for your Amazon Pinpoint account in the current AWS Region.</p>
public struct SendQuota: Equatable {
    /// <p>The maximum number of emails that you can send in the current AWS Region over a
    ///             24-hour period. This value is also called your <i>sending
    ///             quota</i>.</p>
    public let max24HourSend: Double
    /// <p>The maximum number of emails that you can send per second in the current AWS Region.
    ///             This value is also called your <i>maximum sending rate</i> or your
    ///                 <i>maximum TPS (transactions per second) rate</i>.</p>
    public let maxSendRate: Double
    /// <p>The number of emails sent from your Amazon Pinpoint account in the current AWS Region over the
    ///             past 24 hours.</p>
    public let sentLast24Hours: Double

    public init (
        max24HourSend: Double = 0.0,
        maxSendRate: Double = 0.0,
        sentLast24Hours: Double = 0.0
    )
    {
        self.max24HourSend = max24HourSend
        self.maxSendRate = maxSendRate
        self.sentLast24Hours = sentLast24Hours
    }
}

extension SendingOptions: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case sendingEnabled = "SendingEnabled"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if sendingEnabled != false {
            try encodeContainer.encode(sendingEnabled, forKey: .sendingEnabled)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sendingEnabledDecoded = try containerValues.decode(Bool.self, forKey: .sendingEnabled)
        sendingEnabled = sendingEnabledDecoded
    }
}

extension SendingOptions: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SendingOptions(sendingEnabled: \(String(describing: sendingEnabled)))"}
}

/// <p>Used to enable or disable email sending for messages that use this configuration set
///             in the current AWS Region.</p>
public struct SendingOptions: Equatable {
    /// <p>If <code>true</code>, email sending is enabled for the configuration set. If
    ///                 <code>false</code>, email sending is disabled for the configuration set.</p>
    public let sendingEnabled: Bool

    public init (
        sendingEnabled: Bool = false
    )
    {
        self.sendingEnabled = sendingEnabled
    }
}

extension SendingPausedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SendingPausedException(message: \(String(describing: message)))"}
}

extension SendingPausedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: SendingPausedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The message can't be sent because the account's ability to send email is currently
///             paused.</p>
public struct SendingPausedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct SendingPausedExceptionBody: Equatable {
    public let message: String?
}

extension SendingPausedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SnsDestination: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case topicArn = "TopicArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let topicArn = topicArn {
            try encodeContainer.encode(topicArn, forKey: .topicArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let topicArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .topicArn)
        topicArn = topicArnDecoded
    }
}

extension SnsDestination: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SnsDestination(topicArn: \(String(describing: topicArn)))"}
}

/// <p>An object that defines an Amazon SNS destination for email events. You can use Amazon SNS to
///             send notification when certain email events occur.</p>
public struct SnsDestination: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the Amazon SNS topic that you want to publish email
    ///             events to. For more information about Amazon SNS topics, see the <a href="https://docs.aws.amazon.com/sns/latest/dg/CreateTopic.html">Amazon SNS Developer
    ///                 Guide</a>.</p>
    public let topicArn: String?

    public init (
        topicArn: String? = nil
    )
    {
        self.topicArn = topicArn
    }
}

extension Tag: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Tag: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Tag(key: \(String(describing: key)), value: \(String(describing: value)))"}
}

/// <p>An object that defines the tags that are associated with a resource.
///                 A<i>tag</i>is a label that you optionally define and associate with
///             a resource in Amazon Pinpoint. Tags can help you categorize and manage resources in different
///             ways, such as by purpose, owner, environment, or other criteria. A resource can have as
///             many as 50 tags.</p>
///         <p>Each tag consists of a required<i>tag key</i>and an
///                 associated<i>tag value</i>, both of which you define. A tag key is a
///             general label that acts as a category for a more specific tag value. A tag value acts as
///             a descriptor within a tag key. A tag key can contain as many as 128 characters. A tag
///             value can contain as many as 256 characters. The characters can be Unicode letters,
///             digits, white space, or one of the following symbols: _ . : / = + -. The following
///             additional restrictions apply to tags:</p>
///         <ul>
///             <li>
///                 <p>Tag keys and values are case sensitive.</p>
///             </li>
///             <li>
///                 <p>For each associated resource, each tag key must be unique and it can have only
///                     one value.</p>
///             </li>
///             <li>
///                 <p>The<code>aws:</code>prefix is reserved for use by AWS; you cant use it in
///                     any tag keys or values that you define. In addition, you can't edit or remove
///                     tag keys or values that use this prefix. Tags that use this prefix dont count
///                     against the limit of 50 tags per resource.</p>
///             </li>
///             <li>
///                 <p>You can associate tags with public or shared resources, but the tags are
///                     available only for your AWS account, not any other accounts that share the
///                     resource. In addition, the tags are available only for resources that are
///                     located in the specified AWS Region for your AWS account.</p>
///             </li>
///          </ul>
public struct Tag: Equatable {
    /// <p>One part of a key-value pair that defines a tag. The maximum length of a tag key is
    ///             128 characters. The minimum length is 1 character.</p>
    public let key: String?
    /// <p>The optional part of a key-value pair that defines a tag. The maximum length of a tag
    ///             value is 256 characters. The minimum length is 0 characters. If you dont want a
    ///             resource to have a specific tag value, dont specify a value for thisparameter. Amazon Pinpoint
    ///             will set the value to an empty string.</p>
    public let value: String?

    public init (
        key: String? = nil,
        value: String? = nil
    )
    {
        self.key = key
        self.value = value
    }
}

public struct TagResourceInputBodyMiddleware: Middleware {
    public let id: String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

extension TagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceInput(resourceArn: \(String(describing: resourceArn)), tags: \(String(describing: tags)))"}
}

extension TagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the resource that you want to add one or more tags
    ///             to.</p>
    public let resourceArn: String?
    /// <p>A list of the tags that you want to add to the resource. A tag consists of a required
    ///             tag key (<code>Key</code>) and an associated tag value (<code>Value</code>). The maximum
    ///             length of a tag key is 128 characters. The maximum length of a tag value is 256
    ///             characters.</p>
    public let tags: [Tag]?

    public init (
        resourceArn: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Equatable {
    public let resourceArn: String?
    public let tags: [Tag]?
}

extension TagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case concurrentModificationException(ConcurrentModificationException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Equatable {
}

extension TagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension Template: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case templateArn = "TemplateArn"
        case templateData = "TemplateData"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let templateArn = templateArn {
            try encodeContainer.encode(templateArn, forKey: .templateArn)
        }
        if let templateData = templateData {
            try encodeContainer.encode(templateData, forKey: .templateData)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateArn)
        templateArn = templateArnDecoded
        let templateDataDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateData)
        templateData = templateDataDecoded
    }
}

extension Template: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Template(templateArn: \(String(describing: templateArn)), templateData: \(String(describing: templateData)))"}
}

public struct Template: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the template.</p>
    public let templateArn: String?
    /// <p>An object that defines the values to use for message variables in the template. This object is a set of key-value pairs. Each key defines a message variable in the template. The corresponding value defines the value to use for that variable.</p>
    public let templateData: String?

    public init (
        templateArn: String? = nil,
        templateData: String? = nil
    )
    {
        self.templateArn = templateArn
        self.templateData = templateData
    }
}

/// <p>Specifies whether messages that use the configuration set are required to use
///             Transport Layer Security (TLS). If the value is <code>Require</code>, messages are only
///             delivered if a TLS connection can be established. If the value is <code>Optional</code>,
///             messages can be delivered in plain text if a TLS connection can't be established.</p>
public enum TlsPolicy {
    case `optional`
    case require
    case sdkUnknown(String)
}

extension TlsPolicy : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [TlsPolicy] {
        return [
            .optional,
            .require,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .optional: return "OPTIONAL"
        case .require: return "REQUIRE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = TlsPolicy(rawValue: rawValue) ?? TlsPolicy.sdkUnknown(rawValue)
    }
}

extension TooManyRequestsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TooManyRequestsException(message: \(String(describing: message)))"}
}

extension TooManyRequestsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: TooManyRequestsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Too many requests have been made to the operation.</p>
public struct TooManyRequestsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyRequestsExceptionBody: Equatable {
    public let message: String?
}

extension TooManyRequestsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TrackingOptions: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case customRedirectDomain = "CustomRedirectDomain"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customRedirectDomain = customRedirectDomain {
            try encodeContainer.encode(customRedirectDomain, forKey: .customRedirectDomain)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let customRedirectDomainDecoded = try containerValues.decodeIfPresent(String.self, forKey: .customRedirectDomain)
        customRedirectDomain = customRedirectDomainDecoded
    }
}

extension TrackingOptions: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TrackingOptions(customRedirectDomain: \(String(describing: customRedirectDomain)))"}
}

/// <p>An object that defines the tracking options for a configuration set. When you use
///             Amazon Pinpoint to send an email, it contains an invisible image that's used to track when
///             recipients open your email. If your email contains links, those links are changed
///             slightly in order to track when recipients click them.</p>
///         <p>These images and links include references to a domain operated by AWS. You can
///             optionally configure Amazon Pinpoint to use a domain that you operate for these images and
///             links.</p>
public struct TrackingOptions: Equatable {
    /// <p>The domain that you want to use for tracking open and click events.</p>
    public let customRedirectDomain: String?

    public init (
        customRedirectDomain: String? = nil
    )
    {
        self.customRedirectDomain = customRedirectDomain
    }
}

extension UntagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceInput(resourceArn: \(String(describing: resourceArn)), tagKeys: \(String(describing: tagKeys)))"}
}

extension UntagResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct UntagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let resourceArn = input.operationInput.resourceArn {
            let resourceArnQueryItem = URLQueryItem(name: "ResourceArn".urlPercentEncoding(), value: String(resourceArn).urlPercentEncoding())
            input.builder.withQueryItem(resourceArnQueryItem)
        }
        if let tagKeys = input.operationInput.tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = URLQueryItem(name: "TagKeys".urlPercentEncoding(), value: String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the resource that you want to remove one or more
    ///             tags from.</p>
    public let resourceArn: String?
    /// <p>The tags (tag keys) that you want to remove from the resource. When you specify a tag
    ///             key, the action removes both that key and its associated tag value.</p>
    ///         <p>To remove more than one tag from the resource, append the <code>TagKeys</code>
    ///             parameter and argument for each additional tag to remove, separated by an ampersand. For
    ///             example:
    ///                 <code>/v1/email/tags?ResourceArn=ResourceArn&TagKeys=Key1&TagKeys=Key2</code>
    ///         </p>
    public let tagKeys: [String]?

    public init (
        resourceArn: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Equatable {
}

extension UntagResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension UntagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case concurrentModificationException(ConcurrentModificationException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Equatable {
}

extension UntagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateConfigurationSetEventDestinationInputBodyMiddleware: Middleware {
    public let id: String = "UpdateConfigurationSetEventDestinationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateConfigurationSetEventDestinationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateConfigurationSetEventDestinationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateConfigurationSetEventDestinationInput>
    public typealias MOutput = OperationOutput<UpdateConfigurationSetEventDestinationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateConfigurationSetEventDestinationOutputError>
}

extension UpdateConfigurationSetEventDestinationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateConfigurationSetEventDestinationInput(configurationSetName: \(String(describing: configurationSetName)), eventDestination: \(String(describing: eventDestination)), eventDestinationName: \(String(describing: eventDestinationName)))"}
}

extension UpdateConfigurationSetEventDestinationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case eventDestination = "EventDestination"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventDestination = eventDestination {
            try encodeContainer.encode(eventDestination, forKey: .eventDestination)
        }
    }
}

public struct UpdateConfigurationSetEventDestinationInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateConfigurationSetEventDestinationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateConfigurationSetEventDestinationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateConfigurationSetEventDestinationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateConfigurationSetEventDestinationInput>
    public typealias MOutput = OperationOutput<UpdateConfigurationSetEventDestinationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateConfigurationSetEventDestinationOutputError>
}

public struct UpdateConfigurationSetEventDestinationInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateConfigurationSetEventDestinationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateConfigurationSetEventDestinationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateConfigurationSetEventDestinationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateConfigurationSetEventDestinationInput>
    public typealias MOutput = OperationOutput<UpdateConfigurationSetEventDestinationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateConfigurationSetEventDestinationOutputError>
}

/// <p>A request to change the settings for an event destination for a configuration
///             set.</p>
public struct UpdateConfigurationSetEventDestinationInput: Equatable {
    /// <p>The name of the configuration set that contains the event destination that you want to
    ///             modify.</p>
    public let configurationSetName: String?
    /// <p>An object that defines the event destination.</p>
    public let eventDestination: EventDestinationDefinition?
    /// <p>The name of the event destination that you want to modify.</p>
    public let eventDestinationName: String?

    public init (
        configurationSetName: String? = nil,
        eventDestination: EventDestinationDefinition? = nil,
        eventDestinationName: String? = nil
    )
    {
        self.configurationSetName = configurationSetName
        self.eventDestination = eventDestination
        self.eventDestinationName = eventDestinationName
    }
}

struct UpdateConfigurationSetEventDestinationInputBody: Equatable {
    public let eventDestination: EventDestinationDefinition?
}

extension UpdateConfigurationSetEventDestinationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case eventDestination = "EventDestination"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventDestinationDecoded = try containerValues.decodeIfPresent(EventDestinationDefinition.self, forKey: .eventDestination)
        eventDestination = eventDestinationDecoded
    }
}

extension UpdateConfigurationSetEventDestinationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateConfigurationSetEventDestinationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateConfigurationSetEventDestinationOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateConfigurationSetEventDestinationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateConfigurationSetEventDestinationOutputResponse()"}
}

extension UpdateConfigurationSetEventDestinationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>An HTTP 200 response if the request succeeds, or an error message if the request
///             fails.</p>
public struct UpdateConfigurationSetEventDestinationOutputResponse: Equatable {

    public init() {}
}

struct UpdateConfigurationSetEventDestinationOutputResponseBody: Equatable {
}

extension UpdateConfigurationSetEventDestinationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension VolumeStatistics: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case inboxRawCount = "InboxRawCount"
        case projectedInbox = "ProjectedInbox"
        case projectedSpam = "ProjectedSpam"
        case spamRawCount = "SpamRawCount"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inboxRawCount = inboxRawCount {
            try encodeContainer.encode(inboxRawCount, forKey: .inboxRawCount)
        }
        if let projectedInbox = projectedInbox {
            try encodeContainer.encode(projectedInbox, forKey: .projectedInbox)
        }
        if let projectedSpam = projectedSpam {
            try encodeContainer.encode(projectedSpam, forKey: .projectedSpam)
        }
        if let spamRawCount = spamRawCount {
            try encodeContainer.encode(spamRawCount, forKey: .spamRawCount)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inboxRawCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .inboxRawCount)
        inboxRawCount = inboxRawCountDecoded
        let spamRawCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .spamRawCount)
        spamRawCount = spamRawCountDecoded
        let projectedInboxDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .projectedInbox)
        projectedInbox = projectedInboxDecoded
        let projectedSpamDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .projectedSpam)
        projectedSpam = projectedSpamDecoded
    }
}

extension VolumeStatistics: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VolumeStatistics(inboxRawCount: \(String(describing: inboxRawCount)), projectedInbox: \(String(describing: projectedInbox)), projectedSpam: \(String(describing: projectedSpam)), spamRawCount: \(String(describing: spamRawCount)))"}
}

/// <p>An object that contains information about the amount of email that was delivered to
///             recipients.</p>
public struct VolumeStatistics: Equatable {
    /// <p>The total number of emails that arrived in recipients' inboxes.</p>
    public let inboxRawCount: Int?
    /// <p>An estimate of the percentage of emails sent from the current domain that will arrive
    ///             in recipients' inboxes.</p>
    public let projectedInbox: Int?
    /// <p>An estimate of the percentage of emails sent from the current domain that will arrive
    ///             in recipients' spam or junk mail folders.</p>
    public let projectedSpam: Int?
    /// <p>The total number of emails that arrived in recipients' spam or junk mail
    ///             folders.</p>
    public let spamRawCount: Int?

    public init (
        inboxRawCount: Int? = nil,
        projectedInbox: Int? = nil,
        projectedSpam: Int? = nil,
        spamRawCount: Int? = nil
    )
    {
        self.inboxRawCount = inboxRawCount
        self.projectedInbox = projectedInbox
        self.projectedSpam = projectedSpam
        self.spamRawCount = spamRawCount
    }
}

/// <p>The warmup status of a dedicated IP.</p>
public enum WarmupStatus {
    case done
    case inProgress
    case sdkUnknown(String)
}

extension WarmupStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [WarmupStatus] {
        return [
            .done,
            .inProgress,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .done: return "DONE"
        case .inProgress: return "IN_PROGRESS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = WarmupStatus(rawValue: rawValue) ?? WarmupStatus.sdkUnknown(rawValue)
    }
}
