// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

public struct AcceptResourceShareInvitationInputBodyMiddleware: Middleware {
    public let id: String = "AcceptResourceShareInvitationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AcceptResourceShareInvitationInput>,
                  next: H) -> Swift.Result<OperationOutput<AcceptResourceShareInvitationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AcceptResourceShareInvitationInput>
    public typealias MOutput = OperationOutput<AcceptResourceShareInvitationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AcceptResourceShareInvitationOutputError>
}

extension AcceptResourceShareInvitationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AcceptResourceShareInvitationInput(clientToken: \(String(describing: clientToken)), resourceShareInvitationArn: \(String(describing: resourceShareInvitationArn)))"}
}

extension AcceptResourceShareInvitationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientToken
        case resourceShareInvitationArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let resourceShareInvitationArn = resourceShareInvitationArn {
            try encodeContainer.encode(resourceShareInvitationArn, forKey: .resourceShareInvitationArn)
        }
    }
}

public struct AcceptResourceShareInvitationInputHeadersMiddleware: Middleware {
    public let id: String = "AcceptResourceShareInvitationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AcceptResourceShareInvitationInput>,
                  next: H) -> Swift.Result<OperationOutput<AcceptResourceShareInvitationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AcceptResourceShareInvitationInput>
    public typealias MOutput = OperationOutput<AcceptResourceShareInvitationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AcceptResourceShareInvitationOutputError>
}

public struct AcceptResourceShareInvitationInputQueryItemMiddleware: Middleware {
    public let id: String = "AcceptResourceShareInvitationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AcceptResourceShareInvitationInput>,
                  next: H) -> Swift.Result<OperationOutput<AcceptResourceShareInvitationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AcceptResourceShareInvitationInput>
    public typealias MOutput = OperationOutput<AcceptResourceShareInvitationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AcceptResourceShareInvitationOutputError>
}

public struct AcceptResourceShareInvitationInput: Equatable {
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.</p>
    public let clientToken: String?
    /// <p>The Amazon Resource Name (ARN) of the invitation.</p>
    public let resourceShareInvitationArn: String?

    public init (
        clientToken: String? = nil,
        resourceShareInvitationArn: String? = nil
    )
    {
        self.clientToken = clientToken
        self.resourceShareInvitationArn = resourceShareInvitationArn
    }
}

struct AcceptResourceShareInvitationInputBody: Equatable {
    public let resourceShareInvitationArn: String?
    public let clientToken: String?
}

extension AcceptResourceShareInvitationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientToken
        case resourceShareInvitationArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceShareInvitationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceShareInvitationArn)
        resourceShareInvitationArn = resourceShareInvitationArnDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension AcceptResourceShareInvitationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AcceptResourceShareInvitationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "IdempotentParameterMismatchException" : self = .idempotentParameterMismatchException(try IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClientTokenException" : self = .invalidClientTokenException(try InvalidClientTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MalformedArnException" : self = .malformedArnException(try MalformedArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceShareInvitationAlreadyAcceptedException" : self = .resourceShareInvitationAlreadyAcceptedException(try ResourceShareInvitationAlreadyAcceptedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceShareInvitationAlreadyRejectedException" : self = .resourceShareInvitationAlreadyRejectedException(try ResourceShareInvitationAlreadyRejectedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceShareInvitationArnNotFoundException" : self = .resourceShareInvitationArnNotFoundException(try ResourceShareInvitationArnNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceShareInvitationExpiredException" : self = .resourceShareInvitationExpiredException(try ResourceShareInvitationExpiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalException" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AcceptResourceShareInvitationOutputError: Swift.Error, Equatable {
    case idempotentParameterMismatchException(IdempotentParameterMismatchException)
    case invalidClientTokenException(InvalidClientTokenException)
    case malformedArnException(MalformedArnException)
    case operationNotPermittedException(OperationNotPermittedException)
    case resourceShareInvitationAlreadyAcceptedException(ResourceShareInvitationAlreadyAcceptedException)
    case resourceShareInvitationAlreadyRejectedException(ResourceShareInvitationAlreadyRejectedException)
    case resourceShareInvitationArnNotFoundException(ResourceShareInvitationArnNotFoundException)
    case resourceShareInvitationExpiredException(ResourceShareInvitationExpiredException)
    case serverInternalException(ServerInternalException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AcceptResourceShareInvitationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AcceptResourceShareInvitationOutputResponse(clientToken: \(String(describing: clientToken)), resourceShareInvitation: \(String(describing: resourceShareInvitation)))"}
}

extension AcceptResourceShareInvitationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AcceptResourceShareInvitationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.clientToken = output.clientToken
            self.resourceShareInvitation = output.resourceShareInvitation
        } else {
            self.clientToken = nil
            self.resourceShareInvitation = nil
        }
    }
}

public struct AcceptResourceShareInvitationOutputResponse: Equatable {
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.</p>
    public let clientToken: String?
    /// <p>Information about the invitation.</p>
    public let resourceShareInvitation: ResourceShareInvitation?

    public init (
        clientToken: String? = nil,
        resourceShareInvitation: ResourceShareInvitation? = nil
    )
    {
        self.clientToken = clientToken
        self.resourceShareInvitation = resourceShareInvitation
    }
}

struct AcceptResourceShareInvitationOutputResponseBody: Equatable {
    public let resourceShareInvitation: ResourceShareInvitation?
    public let clientToken: String?
}

extension AcceptResourceShareInvitationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientToken
        case resourceShareInvitation
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceShareInvitationDecoded = try containerValues.decodeIfPresent(ResourceShareInvitation.self, forKey: .resourceShareInvitation)
        resourceShareInvitation = resourceShareInvitationDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

public struct AssociateResourceShareInputBodyMiddleware: Middleware {
    public let id: String = "AssociateResourceShareInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateResourceShareInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateResourceShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateResourceShareInput>
    public typealias MOutput = OperationOutput<AssociateResourceShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateResourceShareOutputError>
}

extension AssociateResourceShareInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateResourceShareInput(clientToken: \(String(describing: clientToken)), principals: \(String(describing: principals)), resourceArns: \(String(describing: resourceArns)), resourceShareArn: \(String(describing: resourceShareArn)))"}
}

extension AssociateResourceShareInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientToken
        case principals
        case resourceArns
        case resourceShareArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let principals = principals {
            var principalsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .principals)
            for principalarnoridlist0 in principals {
                try principalsContainer.encode(principalarnoridlist0)
            }
        }
        if let resourceArns = resourceArns {
            var resourceArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceArns)
            for resourcearnlist0 in resourceArns {
                try resourceArnsContainer.encode(resourcearnlist0)
            }
        }
        if let resourceShareArn = resourceShareArn {
            try encodeContainer.encode(resourceShareArn, forKey: .resourceShareArn)
        }
    }
}

public struct AssociateResourceShareInputHeadersMiddleware: Middleware {
    public let id: String = "AssociateResourceShareInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateResourceShareInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateResourceShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateResourceShareInput>
    public typealias MOutput = OperationOutput<AssociateResourceShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateResourceShareOutputError>
}

public struct AssociateResourceShareInputQueryItemMiddleware: Middleware {
    public let id: String = "AssociateResourceShareInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateResourceShareInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateResourceShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateResourceShareInput>
    public typealias MOutput = OperationOutput<AssociateResourceShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateResourceShareOutputError>
}

public struct AssociateResourceShareInput: Equatable {
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.</p>
    public let clientToken: String?
    /// <p>The principals to associate with the resource share. The possible values are IDs of
    ///        	AWS accounts, and the ARNs of organizational units (OU) or organizations from AWS
    ///        	Organizations.</p>
    public let principals: [String]?
    /// <p>The Amazon Resource Names (ARN) of the resources.</p>
    public let resourceArns: [String]?
    /// <p>The Amazon Resource Name (ARN) of the resource share.</p>
    public let resourceShareArn: String?

    public init (
        clientToken: String? = nil,
        principals: [String]? = nil,
        resourceArns: [String]? = nil,
        resourceShareArn: String? = nil
    )
    {
        self.clientToken = clientToken
        self.principals = principals
        self.resourceArns = resourceArns
        self.resourceShareArn = resourceShareArn
    }
}

struct AssociateResourceShareInputBody: Equatable {
    public let resourceShareArn: String?
    public let resourceArns: [String]?
    public let principals: [String]?
    public let clientToken: String?
}

extension AssociateResourceShareInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientToken
        case principals
        case resourceArns
        case resourceShareArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceShareArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceShareArn)
        resourceShareArn = resourceShareArnDecoded
        let resourceArnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .resourceArns)
        var resourceArnsDecoded0:[String]? = nil
        if let resourceArnsContainer = resourceArnsContainer {
            resourceArnsDecoded0 = [String]()
            for string0 in resourceArnsContainer {
                if let string0 = string0 {
                    resourceArnsDecoded0?.append(string0)
                }
            }
        }
        resourceArns = resourceArnsDecoded0
        let principalsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .principals)
        var principalsDecoded0:[String]? = nil
        if let principalsContainer = principalsContainer {
            principalsDecoded0 = [String]()
            for string0 in principalsContainer {
                if let string0 = string0 {
                    principalsDecoded0?.append(string0)
                }
            }
        }
        principals = principalsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension AssociateResourceShareOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateResourceShareOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "IdempotentParameterMismatchException" : self = .idempotentParameterMismatchException(try IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClientTokenException" : self = .invalidClientTokenException(try InvalidClientTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidStateTransitionException" : self = .invalidStateTransitionException(try InvalidStateTransitionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MalformedArnException" : self = .malformedArnException(try MalformedArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceShareLimitExceededException" : self = .resourceShareLimitExceededException(try ResourceShareLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalException" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnknownResourceException" : self = .unknownResourceException(try UnknownResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateResourceShareOutputError: Swift.Error, Equatable {
    case idempotentParameterMismatchException(IdempotentParameterMismatchException)
    case invalidClientTokenException(InvalidClientTokenException)
    case invalidParameterException(InvalidParameterException)
    case invalidStateTransitionException(InvalidStateTransitionException)
    case malformedArnException(MalformedArnException)
    case operationNotPermittedException(OperationNotPermittedException)
    case resourceShareLimitExceededException(ResourceShareLimitExceededException)
    case serverInternalException(ServerInternalException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknownResourceException(UnknownResourceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateResourceShareOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateResourceShareOutputResponse(clientToken: \(String(describing: clientToken)), resourceShareAssociations: \(String(describing: resourceShareAssociations)))"}
}

extension AssociateResourceShareOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AssociateResourceShareOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.clientToken = output.clientToken
            self.resourceShareAssociations = output.resourceShareAssociations
        } else {
            self.clientToken = nil
            self.resourceShareAssociations = nil
        }
    }
}

public struct AssociateResourceShareOutputResponse: Equatable {
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.</p>
    public let clientToken: String?
    /// <p>Information about the associations.</p>
    public let resourceShareAssociations: [ResourceShareAssociation]?

    public init (
        clientToken: String? = nil,
        resourceShareAssociations: [ResourceShareAssociation]? = nil
    )
    {
        self.clientToken = clientToken
        self.resourceShareAssociations = resourceShareAssociations
    }
}

struct AssociateResourceShareOutputResponseBody: Equatable {
    public let resourceShareAssociations: [ResourceShareAssociation]?
    public let clientToken: String?
}

extension AssociateResourceShareOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientToken
        case resourceShareAssociations
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceShareAssociationsContainer = try containerValues.decodeIfPresent([ResourceShareAssociation?].self, forKey: .resourceShareAssociations)
        var resourceShareAssociationsDecoded0:[ResourceShareAssociation]? = nil
        if let resourceShareAssociationsContainer = resourceShareAssociationsContainer {
            resourceShareAssociationsDecoded0 = [ResourceShareAssociation]()
            for structure0 in resourceShareAssociationsContainer {
                if let structure0 = structure0 {
                    resourceShareAssociationsDecoded0?.append(structure0)
                }
            }
        }
        resourceShareAssociations = resourceShareAssociationsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

public struct AssociateResourceSharePermissionInputBodyMiddleware: Middleware {
    public let id: String = "AssociateResourceSharePermissionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateResourceSharePermissionInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateResourceSharePermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateResourceSharePermissionInput>
    public typealias MOutput = OperationOutput<AssociateResourceSharePermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateResourceSharePermissionOutputError>
}

extension AssociateResourceSharePermissionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateResourceSharePermissionInput(clientToken: \(String(describing: clientToken)), permissionArn: \(String(describing: permissionArn)), replace: \(String(describing: replace)), resourceShareArn: \(String(describing: resourceShareArn)))"}
}

extension AssociateResourceSharePermissionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientToken
        case permissionArn
        case replace
        case resourceShareArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let permissionArn = permissionArn {
            try encodeContainer.encode(permissionArn, forKey: .permissionArn)
        }
        if let replace = replace {
            try encodeContainer.encode(replace, forKey: .replace)
        }
        if let resourceShareArn = resourceShareArn {
            try encodeContainer.encode(resourceShareArn, forKey: .resourceShareArn)
        }
    }
}

public struct AssociateResourceSharePermissionInputHeadersMiddleware: Middleware {
    public let id: String = "AssociateResourceSharePermissionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateResourceSharePermissionInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateResourceSharePermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateResourceSharePermissionInput>
    public typealias MOutput = OperationOutput<AssociateResourceSharePermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateResourceSharePermissionOutputError>
}

public struct AssociateResourceSharePermissionInputQueryItemMiddleware: Middleware {
    public let id: String = "AssociateResourceSharePermissionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateResourceSharePermissionInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateResourceSharePermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateResourceSharePermissionInput>
    public typealias MOutput = OperationOutput<AssociateResourceSharePermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateResourceSharePermissionOutputError>
}

public struct AssociateResourceSharePermissionInput: Equatable {
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.</p>
    public let clientToken: String?
    /// <p>The ARN of the AWS RAM permission to associate with the resource share.</p>
    public let permissionArn: String?
    /// <p>Indicates whether the permission should replace the permissions that are currently
    ///         	associated with the resource share. Use <code>true</code> to replace the current permissions.
    ///         	Use <code>false</code> to add the permission to the current permission.</p>
    public let replace: Bool?
    /// <p>The Amazon Resource Name (ARN) of the resource share.</p>
    public let resourceShareArn: String?

    public init (
        clientToken: String? = nil,
        permissionArn: String? = nil,
        replace: Bool? = nil,
        resourceShareArn: String? = nil
    )
    {
        self.clientToken = clientToken
        self.permissionArn = permissionArn
        self.replace = replace
        self.resourceShareArn = resourceShareArn
    }
}

struct AssociateResourceSharePermissionInputBody: Equatable {
    public let resourceShareArn: String?
    public let permissionArn: String?
    public let replace: Bool?
    public let clientToken: String?
}

extension AssociateResourceSharePermissionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientToken
        case permissionArn
        case replace
        case resourceShareArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceShareArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceShareArn)
        resourceShareArn = resourceShareArnDecoded
        let permissionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .permissionArn)
        permissionArn = permissionArnDecoded
        let replaceDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .replace)
        replace = replaceDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension AssociateResourceSharePermissionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateResourceSharePermissionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidClientTokenException" : self = .invalidClientTokenException(try InvalidClientTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MalformedArnException" : self = .malformedArnException(try MalformedArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalException" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnknownResourceException" : self = .unknownResourceException(try UnknownResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateResourceSharePermissionOutputError: Swift.Error, Equatable {
    case invalidClientTokenException(InvalidClientTokenException)
    case invalidParameterException(InvalidParameterException)
    case malformedArnException(MalformedArnException)
    case operationNotPermittedException(OperationNotPermittedException)
    case serverInternalException(ServerInternalException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknownResourceException(UnknownResourceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateResourceSharePermissionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateResourceSharePermissionOutputResponse(clientToken: \(String(describing: clientToken)), returnValue: \(String(describing: returnValue)))"}
}

extension AssociateResourceSharePermissionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AssociateResourceSharePermissionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.clientToken = output.clientToken
            self.returnValue = output.returnValue
        } else {
            self.clientToken = nil
            self.returnValue = nil
        }
    }
}

public struct AssociateResourceSharePermissionOutputResponse: Equatable {
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.</p>
    public let clientToken: String?
    /// <p>Indicates whether the request succeeded.</p>
    public let returnValue: Bool?

    public init (
        clientToken: String? = nil,
        returnValue: Bool? = nil
    )
    {
        self.clientToken = clientToken
        self.returnValue = returnValue
    }
}

struct AssociateResourceSharePermissionOutputResponseBody: Equatable {
    public let returnValue: Bool?
    public let clientToken: String?
}

extension AssociateResourceSharePermissionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientToken
        case returnValue
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let returnValueDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .returnValue)
        returnValue = returnValueDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

public struct CreateResourceShareInputBodyMiddleware: Middleware {
    public let id: String = "CreateResourceShareInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateResourceShareInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateResourceShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateResourceShareInput>
    public typealias MOutput = OperationOutput<CreateResourceShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateResourceShareOutputError>
}

extension CreateResourceShareInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateResourceShareInput(allowExternalPrincipals: \(String(describing: allowExternalPrincipals)), clientToken: \(String(describing: clientToken)), name: \(String(describing: name)), permissionArns: \(String(describing: permissionArns)), principals: \(String(describing: principals)), resourceArns: \(String(describing: resourceArns)), tags: \(String(describing: tags)))"}
}

extension CreateResourceShareInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case allowExternalPrincipals
        case clientToken
        case name
        case permissionArns
        case principals
        case resourceArns
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowExternalPrincipals = allowExternalPrincipals {
            try encodeContainer.encode(allowExternalPrincipals, forKey: .allowExternalPrincipals)
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let permissionArns = permissionArns {
            var permissionArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .permissionArns)
            for permissionarnlist0 in permissionArns {
                try permissionArnsContainer.encode(permissionarnlist0)
            }
        }
        if let principals = principals {
            var principalsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .principals)
            for principalarnoridlist0 in principals {
                try principalsContainer.encode(principalarnoridlist0)
            }
        }
        if let resourceArns = resourceArns {
            var resourceArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceArns)
            for resourcearnlist0 in resourceArns {
                try resourceArnsContainer.encode(resourcearnlist0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateResourceShareInputHeadersMiddleware: Middleware {
    public let id: String = "CreateResourceShareInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateResourceShareInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateResourceShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateResourceShareInput>
    public typealias MOutput = OperationOutput<CreateResourceShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateResourceShareOutputError>
}

public struct CreateResourceShareInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateResourceShareInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateResourceShareInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateResourceShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateResourceShareInput>
    public typealias MOutput = OperationOutput<CreateResourceShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateResourceShareOutputError>
}

public struct CreateResourceShareInput: Equatable {
    /// <p>Indicates whether principals outside your AWS organization can be associated with a resource share.</p>
    public let allowExternalPrincipals: Bool?
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.</p>
    public let clientToken: String?
    /// <p>The name of the resource share.</p>
    public let name: String?
    /// <p>The ARNs of the permissions to associate with the resource share. If you do not specify an ARN
    /// 			for the permission, AWS RAM automatically attaches the default version of the permission
    /// 			for each resource type.</p>
    public let permissionArns: [String]?
    /// <p>The principals to associate with the resource share. The possible values are IDs of AWS accounts,
    ///           the ARN of an OU or organization from AWS Organizations.</p>
    public let principals: [String]?
    /// <p>The Amazon Resource Names (ARN) of the resources to associate with the resource share.</p>
    public let resourceArns: [String]?
    /// <p>One or more tags.</p>
    public let tags: [Tag]?

    public init (
        allowExternalPrincipals: Bool? = nil,
        clientToken: String? = nil,
        name: String? = nil,
        permissionArns: [String]? = nil,
        principals: [String]? = nil,
        resourceArns: [String]? = nil,
        tags: [Tag]? = nil
    )
    {
        self.allowExternalPrincipals = allowExternalPrincipals
        self.clientToken = clientToken
        self.name = name
        self.permissionArns = permissionArns
        self.principals = principals
        self.resourceArns = resourceArns
        self.tags = tags
    }
}

struct CreateResourceShareInputBody: Equatable {
    public let name: String?
    public let resourceArns: [String]?
    public let principals: [String]?
    public let tags: [Tag]?
    public let allowExternalPrincipals: Bool?
    public let clientToken: String?
    public let permissionArns: [String]?
}

extension CreateResourceShareInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case allowExternalPrincipals
        case clientToken
        case name
        case permissionArns
        case principals
        case resourceArns
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let resourceArnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .resourceArns)
        var resourceArnsDecoded0:[String]? = nil
        if let resourceArnsContainer = resourceArnsContainer {
            resourceArnsDecoded0 = [String]()
            for string0 in resourceArnsContainer {
                if let string0 = string0 {
                    resourceArnsDecoded0?.append(string0)
                }
            }
        }
        resourceArns = resourceArnsDecoded0
        let principalsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .principals)
        var principalsDecoded0:[String]? = nil
        if let principalsContainer = principalsContainer {
            principalsDecoded0 = [String]()
            for string0 in principalsContainer {
                if let string0 = string0 {
                    principalsDecoded0?.append(string0)
                }
            }
        }
        principals = principalsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let allowExternalPrincipalsDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .allowExternalPrincipals)
        allowExternalPrincipals = allowExternalPrincipalsDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let permissionArnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .permissionArns)
        var permissionArnsDecoded0:[String]? = nil
        if let permissionArnsContainer = permissionArnsContainer {
            permissionArnsDecoded0 = [String]()
            for string0 in permissionArnsContainer {
                if let string0 = string0 {
                    permissionArnsDecoded0?.append(string0)
                }
            }
        }
        permissionArns = permissionArnsDecoded0
    }
}

extension CreateResourceShareOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateResourceShareOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "IdempotentParameterMismatchException" : self = .idempotentParameterMismatchException(try IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClientTokenException" : self = .invalidClientTokenException(try InvalidClientTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidStateTransitionException" : self = .invalidStateTransitionException(try InvalidStateTransitionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MalformedArnException" : self = .malformedArnException(try MalformedArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceShareLimitExceededException" : self = .resourceShareLimitExceededException(try ResourceShareLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalException" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagPolicyViolationException" : self = .tagPolicyViolationException(try TagPolicyViolationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnknownResourceException" : self = .unknownResourceException(try UnknownResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateResourceShareOutputError: Swift.Error, Equatable {
    case idempotentParameterMismatchException(IdempotentParameterMismatchException)
    case invalidClientTokenException(InvalidClientTokenException)
    case invalidParameterException(InvalidParameterException)
    case invalidStateTransitionException(InvalidStateTransitionException)
    case malformedArnException(MalformedArnException)
    case operationNotPermittedException(OperationNotPermittedException)
    case resourceShareLimitExceededException(ResourceShareLimitExceededException)
    case serverInternalException(ServerInternalException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tagPolicyViolationException(TagPolicyViolationException)
    case unknownResourceException(UnknownResourceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateResourceShareOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateResourceShareOutputResponse(clientToken: \(String(describing: clientToken)), resourceShare: \(String(describing: resourceShare)))"}
}

extension CreateResourceShareOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateResourceShareOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.clientToken = output.clientToken
            self.resourceShare = output.resourceShare
        } else {
            self.clientToken = nil
            self.resourceShare = nil
        }
    }
}

public struct CreateResourceShareOutputResponse: Equatable {
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.</p>
    public let clientToken: String?
    /// <p>Information about the resource share.</p>
    public let resourceShare: ResourceShare?

    public init (
        clientToken: String? = nil,
        resourceShare: ResourceShare? = nil
    )
    {
        self.clientToken = clientToken
        self.resourceShare = resourceShare
    }
}

struct CreateResourceShareOutputResponseBody: Equatable {
    public let resourceShare: ResourceShare?
    public let clientToken: String?
}

extension CreateResourceShareOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientToken
        case resourceShare
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceShareDecoded = try containerValues.decodeIfPresent(ResourceShare.self, forKey: .resourceShare)
        resourceShare = resourceShareDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension DeleteResourceShareInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteResourceShareInput(clientToken: \(String(describing: clientToken)), resourceShareArn: \(String(describing: resourceShareArn)))"}
}

extension DeleteResourceShareInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteResourceShareInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteResourceShareInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteResourceShareInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteResourceShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteResourceShareInput>
    public typealias MOutput = OperationOutput<DeleteResourceShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteResourceShareOutputError>
}

public struct DeleteResourceShareInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteResourceShareInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteResourceShareInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteResourceShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let resourceShareArn = input.operationInput.resourceShareArn {
            let resourceShareArnQueryItem = URLQueryItem(name: "resourceShareArn".urlPercentEncoding(), value: String(resourceShareArn).urlPercentEncoding())
            input.builder.withQueryItem(resourceShareArnQueryItem)
        }
        if let clientToken = input.operationInput.clientToken {
            let clientTokenQueryItem = URLQueryItem(name: "clientToken".urlPercentEncoding(), value: String(clientToken).urlPercentEncoding())
            input.builder.withQueryItem(clientTokenQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteResourceShareInput>
    public typealias MOutput = OperationOutput<DeleteResourceShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteResourceShareOutputError>
}

public struct DeleteResourceShareInput: Equatable {
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.</p>
    public let clientToken: String?
    /// <p>The Amazon Resource Name (ARN) of the resource share.</p>
    public let resourceShareArn: String?

    public init (
        clientToken: String? = nil,
        resourceShareArn: String? = nil
    )
    {
        self.clientToken = clientToken
        self.resourceShareArn = resourceShareArn
    }
}

struct DeleteResourceShareInputBody: Equatable {
}

extension DeleteResourceShareInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteResourceShareOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteResourceShareOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "IdempotentParameterMismatchException" : self = .idempotentParameterMismatchException(try IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClientTokenException" : self = .invalidClientTokenException(try InvalidClientTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidStateTransitionException" : self = .invalidStateTransitionException(try InvalidStateTransitionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MalformedArnException" : self = .malformedArnException(try MalformedArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalException" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnknownResourceException" : self = .unknownResourceException(try UnknownResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteResourceShareOutputError: Swift.Error, Equatable {
    case idempotentParameterMismatchException(IdempotentParameterMismatchException)
    case invalidClientTokenException(InvalidClientTokenException)
    case invalidParameterException(InvalidParameterException)
    case invalidStateTransitionException(InvalidStateTransitionException)
    case malformedArnException(MalformedArnException)
    case operationNotPermittedException(OperationNotPermittedException)
    case serverInternalException(ServerInternalException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknownResourceException(UnknownResourceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteResourceShareOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteResourceShareOutputResponse(clientToken: \(String(describing: clientToken)), returnValue: \(String(describing: returnValue)))"}
}

extension DeleteResourceShareOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteResourceShareOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.clientToken = output.clientToken
            self.returnValue = output.returnValue
        } else {
            self.clientToken = nil
            self.returnValue = nil
        }
    }
}

public struct DeleteResourceShareOutputResponse: Equatable {
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.</p>
    public let clientToken: String?
    /// <p>Indicates whether the request succeeded.</p>
    public let returnValue: Bool?

    public init (
        clientToken: String? = nil,
        returnValue: Bool? = nil
    )
    {
        self.clientToken = clientToken
        self.returnValue = returnValue
    }
}

struct DeleteResourceShareOutputResponseBody: Equatable {
    public let returnValue: Bool?
    public let clientToken: String?
}

extension DeleteResourceShareOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientToken
        case returnValue
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let returnValueDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .returnValue)
        returnValue = returnValueDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

public struct DisassociateResourceShareInputBodyMiddleware: Middleware {
    public let id: String = "DisassociateResourceShareInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateResourceShareInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateResourceShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateResourceShareInput>
    public typealias MOutput = OperationOutput<DisassociateResourceShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateResourceShareOutputError>
}

extension DisassociateResourceShareInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateResourceShareInput(clientToken: \(String(describing: clientToken)), principals: \(String(describing: principals)), resourceArns: \(String(describing: resourceArns)), resourceShareArn: \(String(describing: resourceShareArn)))"}
}

extension DisassociateResourceShareInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientToken
        case principals
        case resourceArns
        case resourceShareArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let principals = principals {
            var principalsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .principals)
            for principalarnoridlist0 in principals {
                try principalsContainer.encode(principalarnoridlist0)
            }
        }
        if let resourceArns = resourceArns {
            var resourceArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceArns)
            for resourcearnlist0 in resourceArns {
                try resourceArnsContainer.encode(resourcearnlist0)
            }
        }
        if let resourceShareArn = resourceShareArn {
            try encodeContainer.encode(resourceShareArn, forKey: .resourceShareArn)
        }
    }
}

public struct DisassociateResourceShareInputHeadersMiddleware: Middleware {
    public let id: String = "DisassociateResourceShareInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateResourceShareInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateResourceShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateResourceShareInput>
    public typealias MOutput = OperationOutput<DisassociateResourceShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateResourceShareOutputError>
}

public struct DisassociateResourceShareInputQueryItemMiddleware: Middleware {
    public let id: String = "DisassociateResourceShareInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateResourceShareInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateResourceShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateResourceShareInput>
    public typealias MOutput = OperationOutput<DisassociateResourceShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateResourceShareOutputError>
}

public struct DisassociateResourceShareInput: Equatable {
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.</p>
    public let clientToken: String?
    /// <p>The principals.</p>
    public let principals: [String]?
    /// <p>The Amazon Resource Names (ARNs) of the resources.</p>
    public let resourceArns: [String]?
    /// <p>The Amazon Resource Name (ARN) of the resource share.</p>
    public let resourceShareArn: String?

    public init (
        clientToken: String? = nil,
        principals: [String]? = nil,
        resourceArns: [String]? = nil,
        resourceShareArn: String? = nil
    )
    {
        self.clientToken = clientToken
        self.principals = principals
        self.resourceArns = resourceArns
        self.resourceShareArn = resourceShareArn
    }
}

struct DisassociateResourceShareInputBody: Equatable {
    public let resourceShareArn: String?
    public let resourceArns: [String]?
    public let principals: [String]?
    public let clientToken: String?
}

extension DisassociateResourceShareInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientToken
        case principals
        case resourceArns
        case resourceShareArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceShareArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceShareArn)
        resourceShareArn = resourceShareArnDecoded
        let resourceArnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .resourceArns)
        var resourceArnsDecoded0:[String]? = nil
        if let resourceArnsContainer = resourceArnsContainer {
            resourceArnsDecoded0 = [String]()
            for string0 in resourceArnsContainer {
                if let string0 = string0 {
                    resourceArnsDecoded0?.append(string0)
                }
            }
        }
        resourceArns = resourceArnsDecoded0
        let principalsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .principals)
        var principalsDecoded0:[String]? = nil
        if let principalsContainer = principalsContainer {
            principalsDecoded0 = [String]()
            for string0 in principalsContainer {
                if let string0 = string0 {
                    principalsDecoded0?.append(string0)
                }
            }
        }
        principals = principalsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension DisassociateResourceShareOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateResourceShareOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "IdempotentParameterMismatchException" : self = .idempotentParameterMismatchException(try IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClientTokenException" : self = .invalidClientTokenException(try InvalidClientTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidStateTransitionException" : self = .invalidStateTransitionException(try InvalidStateTransitionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MalformedArnException" : self = .malformedArnException(try MalformedArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceShareLimitExceededException" : self = .resourceShareLimitExceededException(try ResourceShareLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalException" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnknownResourceException" : self = .unknownResourceException(try UnknownResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateResourceShareOutputError: Swift.Error, Equatable {
    case idempotentParameterMismatchException(IdempotentParameterMismatchException)
    case invalidClientTokenException(InvalidClientTokenException)
    case invalidParameterException(InvalidParameterException)
    case invalidStateTransitionException(InvalidStateTransitionException)
    case malformedArnException(MalformedArnException)
    case operationNotPermittedException(OperationNotPermittedException)
    case resourceShareLimitExceededException(ResourceShareLimitExceededException)
    case serverInternalException(ServerInternalException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknownResourceException(UnknownResourceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateResourceShareOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateResourceShareOutputResponse(clientToken: \(String(describing: clientToken)), resourceShareAssociations: \(String(describing: resourceShareAssociations)))"}
}

extension DisassociateResourceShareOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DisassociateResourceShareOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.clientToken = output.clientToken
            self.resourceShareAssociations = output.resourceShareAssociations
        } else {
            self.clientToken = nil
            self.resourceShareAssociations = nil
        }
    }
}

public struct DisassociateResourceShareOutputResponse: Equatable {
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.</p>
    public let clientToken: String?
    /// <p>Information about the associations.</p>
    public let resourceShareAssociations: [ResourceShareAssociation]?

    public init (
        clientToken: String? = nil,
        resourceShareAssociations: [ResourceShareAssociation]? = nil
    )
    {
        self.clientToken = clientToken
        self.resourceShareAssociations = resourceShareAssociations
    }
}

struct DisassociateResourceShareOutputResponseBody: Equatable {
    public let resourceShareAssociations: [ResourceShareAssociation]?
    public let clientToken: String?
}

extension DisassociateResourceShareOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientToken
        case resourceShareAssociations
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceShareAssociationsContainer = try containerValues.decodeIfPresent([ResourceShareAssociation?].self, forKey: .resourceShareAssociations)
        var resourceShareAssociationsDecoded0:[ResourceShareAssociation]? = nil
        if let resourceShareAssociationsContainer = resourceShareAssociationsContainer {
            resourceShareAssociationsDecoded0 = [ResourceShareAssociation]()
            for structure0 in resourceShareAssociationsContainer {
                if let structure0 = structure0 {
                    resourceShareAssociationsDecoded0?.append(structure0)
                }
            }
        }
        resourceShareAssociations = resourceShareAssociationsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

public struct DisassociateResourceSharePermissionInputBodyMiddleware: Middleware {
    public let id: String = "DisassociateResourceSharePermissionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateResourceSharePermissionInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateResourceSharePermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateResourceSharePermissionInput>
    public typealias MOutput = OperationOutput<DisassociateResourceSharePermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateResourceSharePermissionOutputError>
}

extension DisassociateResourceSharePermissionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateResourceSharePermissionInput(clientToken: \(String(describing: clientToken)), permissionArn: \(String(describing: permissionArn)), resourceShareArn: \(String(describing: resourceShareArn)))"}
}

extension DisassociateResourceSharePermissionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientToken
        case permissionArn
        case resourceShareArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let permissionArn = permissionArn {
            try encodeContainer.encode(permissionArn, forKey: .permissionArn)
        }
        if let resourceShareArn = resourceShareArn {
            try encodeContainer.encode(resourceShareArn, forKey: .resourceShareArn)
        }
    }
}

public struct DisassociateResourceSharePermissionInputHeadersMiddleware: Middleware {
    public let id: String = "DisassociateResourceSharePermissionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateResourceSharePermissionInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateResourceSharePermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateResourceSharePermissionInput>
    public typealias MOutput = OperationOutput<DisassociateResourceSharePermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateResourceSharePermissionOutputError>
}

public struct DisassociateResourceSharePermissionInputQueryItemMiddleware: Middleware {
    public let id: String = "DisassociateResourceSharePermissionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateResourceSharePermissionInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateResourceSharePermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateResourceSharePermissionInput>
    public typealias MOutput = OperationOutput<DisassociateResourceSharePermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateResourceSharePermissionOutputError>
}

public struct DisassociateResourceSharePermissionInput: Equatable {
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.</p>
    public let clientToken: String?
    /// <p>The ARN of the permission to disassociate from the resource share.</p>
    public let permissionArn: String?
    /// <p>The Amazon Resource Name (ARN) of the resource share.</p>
    public let resourceShareArn: String?

    public init (
        clientToken: String? = nil,
        permissionArn: String? = nil,
        resourceShareArn: String? = nil
    )
    {
        self.clientToken = clientToken
        self.permissionArn = permissionArn
        self.resourceShareArn = resourceShareArn
    }
}

struct DisassociateResourceSharePermissionInputBody: Equatable {
    public let resourceShareArn: String?
    public let permissionArn: String?
    public let clientToken: String?
}

extension DisassociateResourceSharePermissionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientToken
        case permissionArn
        case resourceShareArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceShareArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceShareArn)
        resourceShareArn = resourceShareArnDecoded
        let permissionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .permissionArn)
        permissionArn = permissionArnDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension DisassociateResourceSharePermissionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateResourceSharePermissionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidClientTokenException" : self = .invalidClientTokenException(try InvalidClientTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MalformedArnException" : self = .malformedArnException(try MalformedArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalException" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnknownResourceException" : self = .unknownResourceException(try UnknownResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateResourceSharePermissionOutputError: Swift.Error, Equatable {
    case invalidClientTokenException(InvalidClientTokenException)
    case invalidParameterException(InvalidParameterException)
    case malformedArnException(MalformedArnException)
    case operationNotPermittedException(OperationNotPermittedException)
    case serverInternalException(ServerInternalException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknownResourceException(UnknownResourceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateResourceSharePermissionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateResourceSharePermissionOutputResponse(clientToken: \(String(describing: clientToken)), returnValue: \(String(describing: returnValue)))"}
}

extension DisassociateResourceSharePermissionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DisassociateResourceSharePermissionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.clientToken = output.clientToken
            self.returnValue = output.returnValue
        } else {
            self.clientToken = nil
            self.returnValue = nil
        }
    }
}

public struct DisassociateResourceSharePermissionOutputResponse: Equatable {
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.</p>
    public let clientToken: String?
    /// <p>Indicates whether the request succeeded.</p>
    public let returnValue: Bool?

    public init (
        clientToken: String? = nil,
        returnValue: Bool? = nil
    )
    {
        self.clientToken = clientToken
        self.returnValue = returnValue
    }
}

struct DisassociateResourceSharePermissionOutputResponseBody: Equatable {
    public let returnValue: Bool?
    public let clientToken: String?
}

extension DisassociateResourceSharePermissionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientToken
        case returnValue
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let returnValueDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .returnValue)
        returnValue = returnValueDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension EnableSharingWithAwsOrganizationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EnableSharingWithAwsOrganizationInput()"}
}

extension EnableSharingWithAwsOrganizationInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct EnableSharingWithAwsOrganizationInputHeadersMiddleware: Middleware {
    public let id: String = "EnableSharingWithAwsOrganizationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<EnableSharingWithAwsOrganizationInput>,
                  next: H) -> Swift.Result<OperationOutput<EnableSharingWithAwsOrganizationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<EnableSharingWithAwsOrganizationInput>
    public typealias MOutput = OperationOutput<EnableSharingWithAwsOrganizationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<EnableSharingWithAwsOrganizationOutputError>
}

public struct EnableSharingWithAwsOrganizationInputQueryItemMiddleware: Middleware {
    public let id: String = "EnableSharingWithAwsOrganizationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<EnableSharingWithAwsOrganizationInput>,
                  next: H) -> Swift.Result<OperationOutput<EnableSharingWithAwsOrganizationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<EnableSharingWithAwsOrganizationInput>
    public typealias MOutput = OperationOutput<EnableSharingWithAwsOrganizationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<EnableSharingWithAwsOrganizationOutputError>
}

public struct EnableSharingWithAwsOrganizationInput: Equatable {

    public init() {}
}

struct EnableSharingWithAwsOrganizationInputBody: Equatable {
}

extension EnableSharingWithAwsOrganizationInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension EnableSharingWithAwsOrganizationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension EnableSharingWithAwsOrganizationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalException" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum EnableSharingWithAwsOrganizationOutputError: Swift.Error, Equatable {
    case operationNotPermittedException(OperationNotPermittedException)
    case serverInternalException(ServerInternalException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension EnableSharingWithAwsOrganizationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EnableSharingWithAwsOrganizationOutputResponse(returnValue: \(String(describing: returnValue)))"}
}

extension EnableSharingWithAwsOrganizationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: EnableSharingWithAwsOrganizationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.returnValue = output.returnValue
        } else {
            self.returnValue = nil
        }
    }
}

public struct EnableSharingWithAwsOrganizationOutputResponse: Equatable {
    /// <p>Indicates whether the request succeeded.</p>
    public let returnValue: Bool?

    public init (
        returnValue: Bool? = nil
    )
    {
        self.returnValue = returnValue
    }
}

struct EnableSharingWithAwsOrganizationOutputResponseBody: Equatable {
    public let returnValue: Bool?
}

extension EnableSharingWithAwsOrganizationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case returnValue
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let returnValueDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .returnValue)
        returnValue = returnValueDecoded
    }
}

public struct GetPermissionInputBodyMiddleware: Middleware {
    public let id: String = "GetPermissionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetPermissionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetPermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetPermissionInput>
    public typealias MOutput = OperationOutput<GetPermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetPermissionOutputError>
}

extension GetPermissionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetPermissionInput(permissionArn: \(String(describing: permissionArn)), permissionVersion: \(String(describing: permissionVersion)))"}
}

extension GetPermissionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case permissionArn
        case permissionVersion
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let permissionArn = permissionArn {
            try encodeContainer.encode(permissionArn, forKey: .permissionArn)
        }
        if let permissionVersion = permissionVersion {
            try encodeContainer.encode(permissionVersion, forKey: .permissionVersion)
        }
    }
}

public struct GetPermissionInputHeadersMiddleware: Middleware {
    public let id: String = "GetPermissionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetPermissionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetPermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetPermissionInput>
    public typealias MOutput = OperationOutput<GetPermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetPermissionOutputError>
}

public struct GetPermissionInputQueryItemMiddleware: Middleware {
    public let id: String = "GetPermissionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetPermissionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetPermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetPermissionInput>
    public typealias MOutput = OperationOutput<GetPermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetPermissionOutputError>
}

public struct GetPermissionInput: Equatable {
    /// <p>The ARN of the permission.</p>
    public let permissionArn: String?
    /// <p>The identifier for the version of the permission.</p>
    public let permissionVersion: Int?

    public init (
        permissionArn: String? = nil,
        permissionVersion: Int? = nil
    )
    {
        self.permissionArn = permissionArn
        self.permissionVersion = permissionVersion
    }
}

struct GetPermissionInputBody: Equatable {
    public let permissionArn: String?
    public let permissionVersion: Int?
}

extension GetPermissionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case permissionArn
        case permissionVersion
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let permissionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .permissionArn)
        permissionArn = permissionArnDecoded
        let permissionVersionDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .permissionVersion)
        permissionVersion = permissionVersionDecoded
    }
}

extension GetPermissionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetPermissionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MalformedArnException" : self = .malformedArnException(try MalformedArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalException" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnknownResourceException" : self = .unknownResourceException(try UnknownResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetPermissionOutputError: Swift.Error, Equatable {
    case invalidParameterException(InvalidParameterException)
    case malformedArnException(MalformedArnException)
    case operationNotPermittedException(OperationNotPermittedException)
    case serverInternalException(ServerInternalException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknownResourceException(UnknownResourceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetPermissionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetPermissionOutputResponse(permission: \(String(describing: permission)))"}
}

extension GetPermissionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetPermissionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.permission = output.permission
        } else {
            self.permission = nil
        }
    }
}

public struct GetPermissionOutputResponse: Equatable {
    /// <p>Information about the permission.</p>
    public let permission: ResourceSharePermissionDetail?

    public init (
        permission: ResourceSharePermissionDetail? = nil
    )
    {
        self.permission = permission
    }
}

struct GetPermissionOutputResponseBody: Equatable {
    public let permission: ResourceSharePermissionDetail?
}

extension GetPermissionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case permission
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let permissionDecoded = try containerValues.decodeIfPresent(ResourceSharePermissionDetail.self, forKey: .permission)
        permission = permissionDecoded
    }
}

public struct GetResourcePoliciesInputBodyMiddleware: Middleware {
    public let id: String = "GetResourcePoliciesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetResourcePoliciesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetResourcePoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetResourcePoliciesInput>
    public typealias MOutput = OperationOutput<GetResourcePoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetResourcePoliciesOutputError>
}

extension GetResourcePoliciesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetResourcePoliciesInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), principal: \(String(describing: principal)), resourceArns: \(String(describing: resourceArns)))"}
}

extension GetResourcePoliciesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case nextToken
        case principal
        case resourceArns
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let principal = principal {
            try encodeContainer.encode(principal, forKey: .principal)
        }
        if let resourceArns = resourceArns {
            var resourceArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceArns)
            for resourcearnlist0 in resourceArns {
                try resourceArnsContainer.encode(resourcearnlist0)
            }
        }
    }
}

public struct GetResourcePoliciesInputHeadersMiddleware: Middleware {
    public let id: String = "GetResourcePoliciesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetResourcePoliciesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetResourcePoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetResourcePoliciesInput>
    public typealias MOutput = OperationOutput<GetResourcePoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetResourcePoliciesOutputError>
}

public struct GetResourcePoliciesInputQueryItemMiddleware: Middleware {
    public let id: String = "GetResourcePoliciesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetResourcePoliciesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetResourcePoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetResourcePoliciesInput>
    public typealias MOutput = OperationOutput<GetResourcePoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetResourcePoliciesOutputError>
}

public struct GetResourcePoliciesInput: Equatable {
    /// <p>The maximum number of results to return with a single call.
    ///   To retrieve the remaining results, make another call with the returned <code>nextToken</code> value.</p>
    public let maxResults: Int?
    /// <p>The token for the next page of results.</p>
    public let nextToken: String?
    /// <p>The principal.</p>
    public let principal: String?
    /// <p>The Amazon Resource Names (ARN) of the resources.</p>
    public let resourceArns: [String]?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        principal: String? = nil,
        resourceArns: [String]? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.principal = principal
        self.resourceArns = resourceArns
    }
}

struct GetResourcePoliciesInputBody: Equatable {
    public let resourceArns: [String]?
    public let principal: String?
    public let nextToken: String?
    public let maxResults: Int?
}

extension GetResourcePoliciesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case nextToken
        case principal
        case resourceArns
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .resourceArns)
        var resourceArnsDecoded0:[String]? = nil
        if let resourceArnsContainer = resourceArnsContainer {
            resourceArnsDecoded0 = [String]()
            for string0 in resourceArnsContainer {
                if let string0 = string0 {
                    resourceArnsDecoded0?.append(string0)
                }
            }
        }
        resourceArns = resourceArnsDecoded0
        let principalDecoded = try containerValues.decodeIfPresent(String.self, forKey: .principal)
        principal = principalDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension GetResourcePoliciesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetResourcePoliciesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MalformedArnException" : self = .malformedArnException(try MalformedArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceArnNotFoundException" : self = .resourceArnNotFoundException(try ResourceArnNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalException" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetResourcePoliciesOutputError: Swift.Error, Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterException(InvalidParameterException)
    case malformedArnException(MalformedArnException)
    case resourceArnNotFoundException(ResourceArnNotFoundException)
    case serverInternalException(ServerInternalException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetResourcePoliciesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetResourcePoliciesOutputResponse(nextToken: \(String(describing: nextToken)), policies: \(String(describing: policies)))"}
}

extension GetResourcePoliciesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetResourcePoliciesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.policies = output.policies
        } else {
            self.nextToken = nil
            self.policies = nil
        }
    }
}

public struct GetResourcePoliciesOutputResponse: Equatable {
    /// <p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>
    public let nextToken: String?
    /// <p>A key policy document, in JSON format.</p>
    public let policies: [String]?

    public init (
        nextToken: String? = nil,
        policies: [String]? = nil
    )
    {
        self.nextToken = nextToken
        self.policies = policies
    }
}

struct GetResourcePoliciesOutputResponseBody: Equatable {
    public let policies: [String]?
    public let nextToken: String?
}

extension GetResourcePoliciesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case policies
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policiesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .policies)
        var policiesDecoded0:[String]? = nil
        if let policiesContainer = policiesContainer {
            policiesDecoded0 = [String]()
            for string0 in policiesContainer {
                if let string0 = string0 {
                    policiesDecoded0?.append(string0)
                }
            }
        }
        policies = policiesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct GetResourceShareAssociationsInputBodyMiddleware: Middleware {
    public let id: String = "GetResourceShareAssociationsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetResourceShareAssociationsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetResourceShareAssociationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetResourceShareAssociationsInput>
    public typealias MOutput = OperationOutput<GetResourceShareAssociationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetResourceShareAssociationsOutputError>
}

extension GetResourceShareAssociationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetResourceShareAssociationsInput(associationStatus: \(String(describing: associationStatus)), associationType: \(String(describing: associationType)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), principal: \(String(describing: principal)), resourceArn: \(String(describing: resourceArn)), resourceShareArns: \(String(describing: resourceShareArns)))"}
}

extension GetResourceShareAssociationsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case associationStatus
        case associationType
        case maxResults
        case nextToken
        case principal
        case resourceArn
        case resourceShareArns
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associationStatus = associationStatus {
            try encodeContainer.encode(associationStatus.rawValue, forKey: .associationStatus)
        }
        if let associationType = associationType {
            try encodeContainer.encode(associationType.rawValue, forKey: .associationType)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let principal = principal {
            try encodeContainer.encode(principal, forKey: .principal)
        }
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let resourceShareArns = resourceShareArns {
            var resourceShareArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceShareArns)
            for resourcesharearnlist0 in resourceShareArns {
                try resourceShareArnsContainer.encode(resourcesharearnlist0)
            }
        }
    }
}

public struct GetResourceShareAssociationsInputHeadersMiddleware: Middleware {
    public let id: String = "GetResourceShareAssociationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetResourceShareAssociationsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetResourceShareAssociationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetResourceShareAssociationsInput>
    public typealias MOutput = OperationOutput<GetResourceShareAssociationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetResourceShareAssociationsOutputError>
}

public struct GetResourceShareAssociationsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetResourceShareAssociationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetResourceShareAssociationsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetResourceShareAssociationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetResourceShareAssociationsInput>
    public typealias MOutput = OperationOutput<GetResourceShareAssociationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetResourceShareAssociationsOutputError>
}

public struct GetResourceShareAssociationsInput: Equatable {
    /// <p>The association status.</p>
    public let associationStatus: ResourceShareAssociationStatus?
    /// <p>The association type. Specify <code>PRINCIPAL</code> to list the principals that are
    ///    		associated with the specified resource share. Specify <code>RESOURCE</code> to list
    ///    		the resources that are associated with the specified resource share.</p>
    public let associationType: ResourceShareAssociationType?
    /// <p>The maximum number of results to return with a single call.
    ///   To retrieve the remaining results, make another call with the returned <code>nextToken</code> value.</p>
    public let maxResults: Int?
    /// <p>The token for the next page of results.</p>
    public let nextToken: String?
    /// <p>The principal. You cannot specify this parameter if the association type is
    ///      	<code>RESOURCE</code>.</p>
    public let principal: String?
    /// <p>The Amazon Resource Name (ARN) of the resource. You cannot specify this parameter if the
    ///       	association type is <code>PRINCIPAL</code>.</p>
    public let resourceArn: String?
    /// <p>The Amazon Resource Names (ARN) of the resource shares.</p>
    public let resourceShareArns: [String]?

    public init (
        associationStatus: ResourceShareAssociationStatus? = nil,
        associationType: ResourceShareAssociationType? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        principal: String? = nil,
        resourceArn: String? = nil,
        resourceShareArns: [String]? = nil
    )
    {
        self.associationStatus = associationStatus
        self.associationType = associationType
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.principal = principal
        self.resourceArn = resourceArn
        self.resourceShareArns = resourceShareArns
    }
}

struct GetResourceShareAssociationsInputBody: Equatable {
    public let associationType: ResourceShareAssociationType?
    public let resourceShareArns: [String]?
    public let resourceArn: String?
    public let principal: String?
    public let associationStatus: ResourceShareAssociationStatus?
    public let nextToken: String?
    public let maxResults: Int?
}

extension GetResourceShareAssociationsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case associationStatus
        case associationType
        case maxResults
        case nextToken
        case principal
        case resourceArn
        case resourceShareArns
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associationTypeDecoded = try containerValues.decodeIfPresent(ResourceShareAssociationType.self, forKey: .associationType)
        associationType = associationTypeDecoded
        let resourceShareArnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .resourceShareArns)
        var resourceShareArnsDecoded0:[String]? = nil
        if let resourceShareArnsContainer = resourceShareArnsContainer {
            resourceShareArnsDecoded0 = [String]()
            for string0 in resourceShareArnsContainer {
                if let string0 = string0 {
                    resourceShareArnsDecoded0?.append(string0)
                }
            }
        }
        resourceShareArns = resourceShareArnsDecoded0
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let principalDecoded = try containerValues.decodeIfPresent(String.self, forKey: .principal)
        principal = principalDecoded
        let associationStatusDecoded = try containerValues.decodeIfPresent(ResourceShareAssociationStatus.self, forKey: .associationStatus)
        associationStatus = associationStatusDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension GetResourceShareAssociationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetResourceShareAssociationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MalformedArnException" : self = .malformedArnException(try MalformedArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalException" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnknownResourceException" : self = .unknownResourceException(try UnknownResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetResourceShareAssociationsOutputError: Swift.Error, Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterException(InvalidParameterException)
    case malformedArnException(MalformedArnException)
    case operationNotPermittedException(OperationNotPermittedException)
    case serverInternalException(ServerInternalException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknownResourceException(UnknownResourceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetResourceShareAssociationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetResourceShareAssociationsOutputResponse(nextToken: \(String(describing: nextToken)), resourceShareAssociations: \(String(describing: resourceShareAssociations)))"}
}

extension GetResourceShareAssociationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetResourceShareAssociationsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.resourceShareAssociations = output.resourceShareAssociations
        } else {
            self.nextToken = nil
            self.resourceShareAssociations = nil
        }
    }
}

public struct GetResourceShareAssociationsOutputResponse: Equatable {
    /// <p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>
    public let nextToken: String?
    /// <p>Information about the associations.</p>
    public let resourceShareAssociations: [ResourceShareAssociation]?

    public init (
        nextToken: String? = nil,
        resourceShareAssociations: [ResourceShareAssociation]? = nil
    )
    {
        self.nextToken = nextToken
        self.resourceShareAssociations = resourceShareAssociations
    }
}

struct GetResourceShareAssociationsOutputResponseBody: Equatable {
    public let resourceShareAssociations: [ResourceShareAssociation]?
    public let nextToken: String?
}

extension GetResourceShareAssociationsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case resourceShareAssociations
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceShareAssociationsContainer = try containerValues.decodeIfPresent([ResourceShareAssociation?].self, forKey: .resourceShareAssociations)
        var resourceShareAssociationsDecoded0:[ResourceShareAssociation]? = nil
        if let resourceShareAssociationsContainer = resourceShareAssociationsContainer {
            resourceShareAssociationsDecoded0 = [ResourceShareAssociation]()
            for structure0 in resourceShareAssociationsContainer {
                if let structure0 = structure0 {
                    resourceShareAssociationsDecoded0?.append(structure0)
                }
            }
        }
        resourceShareAssociations = resourceShareAssociationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct GetResourceShareInvitationsInputBodyMiddleware: Middleware {
    public let id: String = "GetResourceShareInvitationsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetResourceShareInvitationsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetResourceShareInvitationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetResourceShareInvitationsInput>
    public typealias MOutput = OperationOutput<GetResourceShareInvitationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetResourceShareInvitationsOutputError>
}

extension GetResourceShareInvitationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetResourceShareInvitationsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), resourceShareArns: \(String(describing: resourceShareArns)), resourceShareInvitationArns: \(String(describing: resourceShareInvitationArns)))"}
}

extension GetResourceShareInvitationsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case nextToken
        case resourceShareArns
        case resourceShareInvitationArns
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceShareArns = resourceShareArns {
            var resourceShareArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceShareArns)
            for resourcesharearnlist0 in resourceShareArns {
                try resourceShareArnsContainer.encode(resourcesharearnlist0)
            }
        }
        if let resourceShareInvitationArns = resourceShareInvitationArns {
            var resourceShareInvitationArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceShareInvitationArns)
            for resourceshareinvitationarnlist0 in resourceShareInvitationArns {
                try resourceShareInvitationArnsContainer.encode(resourceshareinvitationarnlist0)
            }
        }
    }
}

public struct GetResourceShareInvitationsInputHeadersMiddleware: Middleware {
    public let id: String = "GetResourceShareInvitationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetResourceShareInvitationsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetResourceShareInvitationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetResourceShareInvitationsInput>
    public typealias MOutput = OperationOutput<GetResourceShareInvitationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetResourceShareInvitationsOutputError>
}

public struct GetResourceShareInvitationsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetResourceShareInvitationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetResourceShareInvitationsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetResourceShareInvitationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetResourceShareInvitationsInput>
    public typealias MOutput = OperationOutput<GetResourceShareInvitationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetResourceShareInvitationsOutputError>
}

public struct GetResourceShareInvitationsInput: Equatable {
    /// <p>The maximum number of results to return with a single call.
    ///   To retrieve the remaining results, make another call with the returned <code>nextToken</code> value.</p>
    public let maxResults: Int?
    /// <p>The token for the next page of results.</p>
    public let nextToken: String?
    /// <p>The Amazon Resource Names (ARN) of the resource shares.</p>
    public let resourceShareArns: [String]?
    /// <p>The Amazon Resource Names (ARN) of the invitations.</p>
    public let resourceShareInvitationArns: [String]?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        resourceShareArns: [String]? = nil,
        resourceShareInvitationArns: [String]? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceShareArns = resourceShareArns
        self.resourceShareInvitationArns = resourceShareInvitationArns
    }
}

struct GetResourceShareInvitationsInputBody: Equatable {
    public let resourceShareInvitationArns: [String]?
    public let resourceShareArns: [String]?
    public let nextToken: String?
    public let maxResults: Int?
}

extension GetResourceShareInvitationsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case nextToken
        case resourceShareArns
        case resourceShareInvitationArns
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceShareInvitationArnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .resourceShareInvitationArns)
        var resourceShareInvitationArnsDecoded0:[String]? = nil
        if let resourceShareInvitationArnsContainer = resourceShareInvitationArnsContainer {
            resourceShareInvitationArnsDecoded0 = [String]()
            for string0 in resourceShareInvitationArnsContainer {
                if let string0 = string0 {
                    resourceShareInvitationArnsDecoded0?.append(string0)
                }
            }
        }
        resourceShareInvitationArns = resourceShareInvitationArnsDecoded0
        let resourceShareArnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .resourceShareArns)
        var resourceShareArnsDecoded0:[String]? = nil
        if let resourceShareArnsContainer = resourceShareArnsContainer {
            resourceShareArnsDecoded0 = [String]()
            for string0 in resourceShareArnsContainer {
                if let string0 = string0 {
                    resourceShareArnsDecoded0?.append(string0)
                }
            }
        }
        resourceShareArns = resourceShareArnsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension GetResourceShareInvitationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetResourceShareInvitationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidMaxResultsException" : self = .invalidMaxResultsException(try InvalidMaxResultsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MalformedArnException" : self = .malformedArnException(try MalformedArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceShareInvitationArnNotFoundException" : self = .resourceShareInvitationArnNotFoundException(try ResourceShareInvitationArnNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalException" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnknownResourceException" : self = .unknownResourceException(try UnknownResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetResourceShareInvitationsOutputError: Swift.Error, Equatable {
    case invalidMaxResultsException(InvalidMaxResultsException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterException(InvalidParameterException)
    case malformedArnException(MalformedArnException)
    case resourceShareInvitationArnNotFoundException(ResourceShareInvitationArnNotFoundException)
    case serverInternalException(ServerInternalException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknownResourceException(UnknownResourceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetResourceShareInvitationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetResourceShareInvitationsOutputResponse(nextToken: \(String(describing: nextToken)), resourceShareInvitations: \(String(describing: resourceShareInvitations)))"}
}

extension GetResourceShareInvitationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetResourceShareInvitationsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.resourceShareInvitations = output.resourceShareInvitations
        } else {
            self.nextToken = nil
            self.resourceShareInvitations = nil
        }
    }
}

public struct GetResourceShareInvitationsOutputResponse: Equatable {
    /// <p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>
    public let nextToken: String?
    /// <p>Information about the invitations.</p>
    public let resourceShareInvitations: [ResourceShareInvitation]?

    public init (
        nextToken: String? = nil,
        resourceShareInvitations: [ResourceShareInvitation]? = nil
    )
    {
        self.nextToken = nextToken
        self.resourceShareInvitations = resourceShareInvitations
    }
}

struct GetResourceShareInvitationsOutputResponseBody: Equatable {
    public let resourceShareInvitations: [ResourceShareInvitation]?
    public let nextToken: String?
}

extension GetResourceShareInvitationsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case resourceShareInvitations
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceShareInvitationsContainer = try containerValues.decodeIfPresent([ResourceShareInvitation?].self, forKey: .resourceShareInvitations)
        var resourceShareInvitationsDecoded0:[ResourceShareInvitation]? = nil
        if let resourceShareInvitationsContainer = resourceShareInvitationsContainer {
            resourceShareInvitationsDecoded0 = [ResourceShareInvitation]()
            for structure0 in resourceShareInvitationsContainer {
                if let structure0 = structure0 {
                    resourceShareInvitationsDecoded0?.append(structure0)
                }
            }
        }
        resourceShareInvitations = resourceShareInvitationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct GetResourceSharesInputBodyMiddleware: Middleware {
    public let id: String = "GetResourceSharesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetResourceSharesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetResourceSharesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetResourceSharesInput>
    public typealias MOutput = OperationOutput<GetResourceSharesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetResourceSharesOutputError>
}

extension GetResourceSharesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetResourceSharesInput(maxResults: \(String(describing: maxResults)), name: \(String(describing: name)), nextToken: \(String(describing: nextToken)), resourceOwner: \(String(describing: resourceOwner)), resourceShareArns: \(String(describing: resourceShareArns)), resourceShareStatus: \(String(describing: resourceShareStatus)), tagFilters: \(String(describing: tagFilters)))"}
}

extension GetResourceSharesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case name
        case nextToken
        case resourceOwner
        case resourceShareArns
        case resourceShareStatus
        case tagFilters
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceOwner = resourceOwner {
            try encodeContainer.encode(resourceOwner.rawValue, forKey: .resourceOwner)
        }
        if let resourceShareArns = resourceShareArns {
            var resourceShareArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceShareArns)
            for resourcesharearnlist0 in resourceShareArns {
                try resourceShareArnsContainer.encode(resourcesharearnlist0)
            }
        }
        if let resourceShareStatus = resourceShareStatus {
            try encodeContainer.encode(resourceShareStatus.rawValue, forKey: .resourceShareStatus)
        }
        if let tagFilters = tagFilters {
            var tagFiltersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagFilters)
            for tagfilters0 in tagFilters {
                try tagFiltersContainer.encode(tagfilters0)
            }
        }
    }
}

public struct GetResourceSharesInputHeadersMiddleware: Middleware {
    public let id: String = "GetResourceSharesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetResourceSharesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetResourceSharesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetResourceSharesInput>
    public typealias MOutput = OperationOutput<GetResourceSharesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetResourceSharesOutputError>
}

public struct GetResourceSharesInputQueryItemMiddleware: Middleware {
    public let id: String = "GetResourceSharesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetResourceSharesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetResourceSharesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetResourceSharesInput>
    public typealias MOutput = OperationOutput<GetResourceSharesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetResourceSharesOutputError>
}

public struct GetResourceSharesInput: Equatable {
    /// <p>The maximum number of results to return with a single call.
    ///   To retrieve the remaining results, make another call with the returned <code>nextToken</code> value.</p>
    public let maxResults: Int?
    /// <p>The name of the resource share.</p>
    public let name: String?
    /// <p>The token for the next page of results.</p>
    public let nextToken: String?
    /// <p>The type of owner.</p>
    public let resourceOwner: ResourceOwner?
    /// <p>The Amazon Resource Names (ARN) of the resource shares.</p>
    public let resourceShareArns: [String]?
    /// <p>The status of the resource share.</p>
    public let resourceShareStatus: ResourceShareStatus?
    /// <p>One or more tag filters.</p>
    public let tagFilters: [TagFilter]?

    public init (
        maxResults: Int? = nil,
        name: String? = nil,
        nextToken: String? = nil,
        resourceOwner: ResourceOwner? = nil,
        resourceShareArns: [String]? = nil,
        resourceShareStatus: ResourceShareStatus? = nil,
        tagFilters: [TagFilter]? = nil
    )
    {
        self.maxResults = maxResults
        self.name = name
        self.nextToken = nextToken
        self.resourceOwner = resourceOwner
        self.resourceShareArns = resourceShareArns
        self.resourceShareStatus = resourceShareStatus
        self.tagFilters = tagFilters
    }
}

struct GetResourceSharesInputBody: Equatable {
    public let resourceShareArns: [String]?
    public let resourceShareStatus: ResourceShareStatus?
    public let resourceOwner: ResourceOwner?
    public let name: String?
    public let tagFilters: [TagFilter]?
    public let nextToken: String?
    public let maxResults: Int?
}

extension GetResourceSharesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case name
        case nextToken
        case resourceOwner
        case resourceShareArns
        case resourceShareStatus
        case tagFilters
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceShareArnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .resourceShareArns)
        var resourceShareArnsDecoded0:[String]? = nil
        if let resourceShareArnsContainer = resourceShareArnsContainer {
            resourceShareArnsDecoded0 = [String]()
            for string0 in resourceShareArnsContainer {
                if let string0 = string0 {
                    resourceShareArnsDecoded0?.append(string0)
                }
            }
        }
        resourceShareArns = resourceShareArnsDecoded0
        let resourceShareStatusDecoded = try containerValues.decodeIfPresent(ResourceShareStatus.self, forKey: .resourceShareStatus)
        resourceShareStatus = resourceShareStatusDecoded
        let resourceOwnerDecoded = try containerValues.decodeIfPresent(ResourceOwner.self, forKey: .resourceOwner)
        resourceOwner = resourceOwnerDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let tagFiltersContainer = try containerValues.decodeIfPresent([TagFilter?].self, forKey: .tagFilters)
        var tagFiltersDecoded0:[TagFilter]? = nil
        if let tagFiltersContainer = tagFiltersContainer {
            tagFiltersDecoded0 = [TagFilter]()
            for structure0 in tagFiltersContainer {
                if let structure0 = structure0 {
                    tagFiltersDecoded0?.append(structure0)
                }
            }
        }
        tagFilters = tagFiltersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension GetResourceSharesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetResourceSharesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MalformedArnException" : self = .malformedArnException(try MalformedArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalException" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnknownResourceException" : self = .unknownResourceException(try UnknownResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetResourceSharesOutputError: Swift.Error, Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterException(InvalidParameterException)
    case malformedArnException(MalformedArnException)
    case serverInternalException(ServerInternalException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknownResourceException(UnknownResourceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetResourceSharesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetResourceSharesOutputResponse(nextToken: \(String(describing: nextToken)), resourceShares: \(String(describing: resourceShares)))"}
}

extension GetResourceSharesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetResourceSharesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.resourceShares = output.resourceShares
        } else {
            self.nextToken = nil
            self.resourceShares = nil
        }
    }
}

public struct GetResourceSharesOutputResponse: Equatable {
    /// <p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>
    public let nextToken: String?
    /// <p>Information about the resource shares.</p>
    public let resourceShares: [ResourceShare]?

    public init (
        nextToken: String? = nil,
        resourceShares: [ResourceShare]? = nil
    )
    {
        self.nextToken = nextToken
        self.resourceShares = resourceShares
    }
}

struct GetResourceSharesOutputResponseBody: Equatable {
    public let resourceShares: [ResourceShare]?
    public let nextToken: String?
}

extension GetResourceSharesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case resourceShares
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceSharesContainer = try containerValues.decodeIfPresent([ResourceShare?].self, forKey: .resourceShares)
        var resourceSharesDecoded0:[ResourceShare]? = nil
        if let resourceSharesContainer = resourceSharesContainer {
            resourceSharesDecoded0 = [ResourceShare]()
            for structure0 in resourceSharesContainer {
                if let structure0 = structure0 {
                    resourceSharesDecoded0?.append(structure0)
                }
            }
        }
        resourceShares = resourceSharesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension IdempotentParameterMismatchException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IdempotentParameterMismatchException(message: \(String(describing: message)))"}
}

extension IdempotentParameterMismatchException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: IdempotentParameterMismatchExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A client token input parameter was reused with an operation, but at least one of
///         the other input parameters is different from the previous call to the operation.</p>
public struct IdempotentParameterMismatchException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct IdempotentParameterMismatchExceptionBody: Equatable {
    public let message: String?
}

extension IdempotentParameterMismatchExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidClientTokenException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidClientTokenException(message: \(String(describing: message)))"}
}

extension InvalidClientTokenException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidClientTokenExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A client token is not valid.</p>
public struct InvalidClientTokenException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidClientTokenExceptionBody: Equatable {
    public let message: String?
}

extension InvalidClientTokenExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidMaxResultsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidMaxResultsException(message: \(String(describing: message)))"}
}

extension InvalidMaxResultsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidMaxResultsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified value for MaxResults is not valid.</p>
public struct InvalidMaxResultsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidMaxResultsExceptionBody: Equatable {
    public let message: String?
}

extension InvalidMaxResultsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidNextTokenException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidNextTokenException(message: \(String(describing: message)))"}
}

extension InvalidNextTokenException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidNextTokenExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified value for NextToken is not valid.</p>
public struct InvalidNextTokenException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidNextTokenExceptionBody: Equatable {
    public let message: String?
}

extension InvalidNextTokenExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidParameterException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidParameterException(message: \(String(describing: message)))"}
}

extension InvalidParameterException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidParameterExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A parameter is not valid.</p>
public struct InvalidParameterException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidParameterExceptionBody: Equatable {
    public let message: String?
}

extension InvalidParameterExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidResourceTypeException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidResourceTypeException(message: \(String(describing: message)))"}
}

extension InvalidResourceTypeException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidResourceTypeExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified resource type is not valid.</p>
public struct InvalidResourceTypeException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidResourceTypeExceptionBody: Equatable {
    public let message: String?
}

extension InvalidResourceTypeExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidStateTransitionException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidStateTransitionException(message: \(String(describing: message)))"}
}

extension InvalidStateTransitionException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidStateTransitionExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The requested state transition is not valid.</p>
public struct InvalidStateTransitionException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidStateTransitionExceptionBody: Equatable {
    public let message: String?
}

extension InvalidStateTransitionExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ListPendingInvitationResourcesInputBodyMiddleware: Middleware {
    public let id: String = "ListPendingInvitationResourcesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPendingInvitationResourcesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPendingInvitationResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPendingInvitationResourcesInput>
    public typealias MOutput = OperationOutput<ListPendingInvitationResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPendingInvitationResourcesOutputError>
}

extension ListPendingInvitationResourcesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListPendingInvitationResourcesInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), resourceShareInvitationArn: \(String(describing: resourceShareInvitationArn)))"}
}

extension ListPendingInvitationResourcesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case nextToken
        case resourceShareInvitationArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceShareInvitationArn = resourceShareInvitationArn {
            try encodeContainer.encode(resourceShareInvitationArn, forKey: .resourceShareInvitationArn)
        }
    }
}

public struct ListPendingInvitationResourcesInputHeadersMiddleware: Middleware {
    public let id: String = "ListPendingInvitationResourcesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPendingInvitationResourcesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPendingInvitationResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPendingInvitationResourcesInput>
    public typealias MOutput = OperationOutput<ListPendingInvitationResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPendingInvitationResourcesOutputError>
}

public struct ListPendingInvitationResourcesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListPendingInvitationResourcesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPendingInvitationResourcesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPendingInvitationResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPendingInvitationResourcesInput>
    public typealias MOutput = OperationOutput<ListPendingInvitationResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPendingInvitationResourcesOutputError>
}

public struct ListPendingInvitationResourcesInput: Equatable {
    /// <p>The maximum number of results to return with a single call.
    ///   To retrieve the remaining results, make another call with the returned <code>nextToken</code> value.</p>
    public let maxResults: Int?
    /// <p>The token for the next page of results.</p>
    public let nextToken: String?
    /// <p>The Amazon Resource Name (ARN) of the invitation.</p>
    public let resourceShareInvitationArn: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        resourceShareInvitationArn: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceShareInvitationArn = resourceShareInvitationArn
    }
}

struct ListPendingInvitationResourcesInputBody: Equatable {
    public let resourceShareInvitationArn: String?
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListPendingInvitationResourcesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case nextToken
        case resourceShareInvitationArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceShareInvitationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceShareInvitationArn)
        resourceShareInvitationArn = resourceShareInvitationArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListPendingInvitationResourcesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPendingInvitationResourcesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MalformedArnException" : self = .malformedArnException(try MalformedArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingRequiredParameterException" : self = .missingRequiredParameterException(try MissingRequiredParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceShareInvitationAlreadyRejectedException" : self = .resourceShareInvitationAlreadyRejectedException(try ResourceShareInvitationAlreadyRejectedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceShareInvitationArnNotFoundException" : self = .resourceShareInvitationArnNotFoundException(try ResourceShareInvitationArnNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceShareInvitationExpiredException" : self = .resourceShareInvitationExpiredException(try ResourceShareInvitationExpiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalException" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPendingInvitationResourcesOutputError: Swift.Error, Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterException(InvalidParameterException)
    case malformedArnException(MalformedArnException)
    case missingRequiredParameterException(MissingRequiredParameterException)
    case resourceShareInvitationAlreadyRejectedException(ResourceShareInvitationAlreadyRejectedException)
    case resourceShareInvitationArnNotFoundException(ResourceShareInvitationArnNotFoundException)
    case resourceShareInvitationExpiredException(ResourceShareInvitationExpiredException)
    case serverInternalException(ServerInternalException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPendingInvitationResourcesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListPendingInvitationResourcesOutputResponse(nextToken: \(String(describing: nextToken)), resources: \(String(describing: resources)))"}
}

extension ListPendingInvitationResourcesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListPendingInvitationResourcesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.resources = output.resources
        } else {
            self.nextToken = nil
            self.resources = nil
        }
    }
}

public struct ListPendingInvitationResourcesOutputResponse: Equatable {
    /// <p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>
    public let nextToken: String?
    /// <p>Information about the resources included the resource share.</p>
    public let resources: [Resource]?

    public init (
        nextToken: String? = nil,
        resources: [Resource]? = nil
    )
    {
        self.nextToken = nextToken
        self.resources = resources
    }
}

struct ListPendingInvitationResourcesOutputResponseBody: Equatable {
    public let resources: [Resource]?
    public let nextToken: String?
}

extension ListPendingInvitationResourcesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case resources
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourcesContainer = try containerValues.decodeIfPresent([Resource?].self, forKey: .resources)
        var resourcesDecoded0:[Resource]? = nil
        if let resourcesContainer = resourcesContainer {
            resourcesDecoded0 = [Resource]()
            for structure0 in resourcesContainer {
                if let structure0 = structure0 {
                    resourcesDecoded0?.append(structure0)
                }
            }
        }
        resources = resourcesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListPermissionsInputBodyMiddleware: Middleware {
    public let id: String = "ListPermissionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPermissionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPermissionsInput>
    public typealias MOutput = OperationOutput<ListPermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPermissionsOutputError>
}

extension ListPermissionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListPermissionsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), resourceType: \(String(describing: resourceType)))"}
}

extension ListPermissionsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case nextToken
        case resourceType
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
    }
}

public struct ListPermissionsInputHeadersMiddleware: Middleware {
    public let id: String = "ListPermissionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPermissionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPermissionsInput>
    public typealias MOutput = OperationOutput<ListPermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPermissionsOutputError>
}

public struct ListPermissionsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListPermissionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPermissionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPermissionsInput>
    public typealias MOutput = OperationOutput<ListPermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPermissionsOutputError>
}

public struct ListPermissionsInput: Equatable {
    /// <p>The maximum number of results to return with a single call.
    ///   To retrieve the remaining results, make another call with the returned <code>nextToken</code> value.</p>
    public let maxResults: Int?
    /// <p>The token for the next page of results.</p>
    public let nextToken: String?
    /// <p>Specifies the resource type for which to list permissions. For example, to list only
    /// 		permissions that apply to EC2 subnets, specify <code>ec2:Subnet</code>.</p>
    public let resourceType: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        resourceType: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceType = resourceType
    }
}

struct ListPermissionsInputBody: Equatable {
    public let resourceType: String?
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListPermissionsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case nextToken
        case resourceType
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListPermissionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPermissionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalException" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPermissionsOutputError: Swift.Error, Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterException(InvalidParameterException)
    case operationNotPermittedException(OperationNotPermittedException)
    case serverInternalException(ServerInternalException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPermissionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListPermissionsOutputResponse(nextToken: \(String(describing: nextToken)), permissions: \(String(describing: permissions)))"}
}

extension ListPermissionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListPermissionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.permissions = output.permissions
        } else {
            self.nextToken = nil
            self.permissions = nil
        }
    }
}

public struct ListPermissionsOutputResponse: Equatable {
    /// <p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>
    public let nextToken: String?
    /// <p>Information about the permissions.</p>
    public let permissions: [ResourceSharePermissionSummary]?

    public init (
        nextToken: String? = nil,
        permissions: [ResourceSharePermissionSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.permissions = permissions
    }
}

struct ListPermissionsOutputResponseBody: Equatable {
    public let permissions: [ResourceSharePermissionSummary]?
    public let nextToken: String?
}

extension ListPermissionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case permissions
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let permissionsContainer = try containerValues.decodeIfPresent([ResourceSharePermissionSummary?].self, forKey: .permissions)
        var permissionsDecoded0:[ResourceSharePermissionSummary]? = nil
        if let permissionsContainer = permissionsContainer {
            permissionsDecoded0 = [ResourceSharePermissionSummary]()
            for structure0 in permissionsContainer {
                if let structure0 = structure0 {
                    permissionsDecoded0?.append(structure0)
                }
            }
        }
        permissions = permissionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListPrincipalsInputBodyMiddleware: Middleware {
    public let id: String = "ListPrincipalsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPrincipalsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPrincipalsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPrincipalsInput>
    public typealias MOutput = OperationOutput<ListPrincipalsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPrincipalsOutputError>
}

extension ListPrincipalsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListPrincipalsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), principals: \(String(describing: principals)), resourceArn: \(String(describing: resourceArn)), resourceOwner: \(String(describing: resourceOwner)), resourceShareArns: \(String(describing: resourceShareArns)), resourceType: \(String(describing: resourceType)))"}
}

extension ListPrincipalsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case nextToken
        case principals
        case resourceArn
        case resourceOwner
        case resourceShareArns
        case resourceType
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let principals = principals {
            var principalsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .principals)
            for principalarnoridlist0 in principals {
                try principalsContainer.encode(principalarnoridlist0)
            }
        }
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let resourceOwner = resourceOwner {
            try encodeContainer.encode(resourceOwner.rawValue, forKey: .resourceOwner)
        }
        if let resourceShareArns = resourceShareArns {
            var resourceShareArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceShareArns)
            for resourcesharearnlist0 in resourceShareArns {
                try resourceShareArnsContainer.encode(resourcesharearnlist0)
            }
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
    }
}

public struct ListPrincipalsInputHeadersMiddleware: Middleware {
    public let id: String = "ListPrincipalsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPrincipalsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPrincipalsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPrincipalsInput>
    public typealias MOutput = OperationOutput<ListPrincipalsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPrincipalsOutputError>
}

public struct ListPrincipalsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListPrincipalsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPrincipalsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPrincipalsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPrincipalsInput>
    public typealias MOutput = OperationOutput<ListPrincipalsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPrincipalsOutputError>
}

public struct ListPrincipalsInput: Equatable {
    /// <p>The maximum number of results to return with a single call.
    ///   To retrieve the remaining results, make another call with the returned <code>nextToken</code> value.</p>
    public let maxResults: Int?
    /// <p>The token for the next page of results.</p>
    public let nextToken: String?
    /// <p>The principals.</p>
    public let principals: [String]?
    /// <p>The Amazon Resource Name (ARN) of the resource.</p>
    public let resourceArn: String?
    /// <p>The type of owner.</p>
    public let resourceOwner: ResourceOwner?
    /// <p>The Amazon Resource Names (ARN) of the resource shares.</p>
    public let resourceShareArns: [String]?
    /// <p>The resource type.</p>
    ///    	     <p>Valid values: <code>acm-pca:CertificateAuthority</code> | <code>appmesh:Mesh</code> | <code>codebuild:Project</code> | <code>codebuild:ReportGroup</code> | <code>ec2:CapacityReservation</code> | <code>ec2:DedicatedHost</code> | <code>ec2:LocalGatewayRouteTable</code> | <code>ec2:PrefixList</code> | <code>ec2:Subnet</code> | <code>ec2:TrafficMirrorTarget</code> | <code>ec2:TransitGateway</code> | <code>imagebuilder:Component</code> | <code>imagebuilder:Image</code> | <code>imagebuilder:ImageRecipe</code> | <code>imagebuilder:ContainerRecipe</code> | <code>glue:Catalog</code> | <code>glue:Database</code> | <code>glue:Table</code> | <code>license-manager:LicenseConfiguration</code> I <code>network-firewall:FirewallPolicy</code> | <code>network-firewall:StatefulRuleGroup</code> | <code>network-firewall:StatelessRuleGroup</code> | <code>outposts:Outpost</code> | <code>resource-groups:Group</code> | <code>rds:Cluster</code> | <code>route53resolver:FirewallRuleGroup</code> |<code>route53resolver:ResolverQueryLogConfig</code> | <code>route53resolver:ResolverRule</code>
    ///          </p>
    public let resourceType: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        principals: [String]? = nil,
        resourceArn: String? = nil,
        resourceOwner: ResourceOwner? = nil,
        resourceShareArns: [String]? = nil,
        resourceType: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.principals = principals
        self.resourceArn = resourceArn
        self.resourceOwner = resourceOwner
        self.resourceShareArns = resourceShareArns
        self.resourceType = resourceType
    }
}

struct ListPrincipalsInputBody: Equatable {
    public let resourceOwner: ResourceOwner?
    public let resourceArn: String?
    public let principals: [String]?
    public let resourceType: String?
    public let resourceShareArns: [String]?
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListPrincipalsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case nextToken
        case principals
        case resourceArn
        case resourceOwner
        case resourceShareArns
        case resourceType
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceOwnerDecoded = try containerValues.decodeIfPresent(ResourceOwner.self, forKey: .resourceOwner)
        resourceOwner = resourceOwnerDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let principalsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .principals)
        var principalsDecoded0:[String]? = nil
        if let principalsContainer = principalsContainer {
            principalsDecoded0 = [String]()
            for string0 in principalsContainer {
                if let string0 = string0 {
                    principalsDecoded0?.append(string0)
                }
            }
        }
        principals = principalsDecoded0
        let resourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceShareArnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .resourceShareArns)
        var resourceShareArnsDecoded0:[String]? = nil
        if let resourceShareArnsContainer = resourceShareArnsContainer {
            resourceShareArnsDecoded0 = [String]()
            for string0 in resourceShareArnsContainer {
                if let string0 = string0 {
                    resourceShareArnsDecoded0?.append(string0)
                }
            }
        }
        resourceShareArns = resourceShareArnsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListPrincipalsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPrincipalsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MalformedArnException" : self = .malformedArnException(try MalformedArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalException" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnknownResourceException" : self = .unknownResourceException(try UnknownResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPrincipalsOutputError: Swift.Error, Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterException(InvalidParameterException)
    case malformedArnException(MalformedArnException)
    case serverInternalException(ServerInternalException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknownResourceException(UnknownResourceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPrincipalsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListPrincipalsOutputResponse(nextToken: \(String(describing: nextToken)), principals: \(String(describing: principals)))"}
}

extension ListPrincipalsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListPrincipalsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.principals = output.principals
        } else {
            self.nextToken = nil
            self.principals = nil
        }
    }
}

public struct ListPrincipalsOutputResponse: Equatable {
    /// <p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>
    public let nextToken: String?
    /// <p>The principals.</p>
    public let principals: [Principal]?

    public init (
        nextToken: String? = nil,
        principals: [Principal]? = nil
    )
    {
        self.nextToken = nextToken
        self.principals = principals
    }
}

struct ListPrincipalsOutputResponseBody: Equatable {
    public let principals: [Principal]?
    public let nextToken: String?
}

extension ListPrincipalsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case principals
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let principalsContainer = try containerValues.decodeIfPresent([Principal?].self, forKey: .principals)
        var principalsDecoded0:[Principal]? = nil
        if let principalsContainer = principalsContainer {
            principalsDecoded0 = [Principal]()
            for structure0 in principalsContainer {
                if let structure0 = structure0 {
                    principalsDecoded0?.append(structure0)
                }
            }
        }
        principals = principalsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListResourceSharePermissionsInputBodyMiddleware: Middleware {
    public let id: String = "ListResourceSharePermissionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListResourceSharePermissionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListResourceSharePermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListResourceSharePermissionsInput>
    public typealias MOutput = OperationOutput<ListResourceSharePermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListResourceSharePermissionsOutputError>
}

extension ListResourceSharePermissionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListResourceSharePermissionsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), resourceShareArn: \(String(describing: resourceShareArn)))"}
}

extension ListResourceSharePermissionsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case nextToken
        case resourceShareArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceShareArn = resourceShareArn {
            try encodeContainer.encode(resourceShareArn, forKey: .resourceShareArn)
        }
    }
}

public struct ListResourceSharePermissionsInputHeadersMiddleware: Middleware {
    public let id: String = "ListResourceSharePermissionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListResourceSharePermissionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListResourceSharePermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListResourceSharePermissionsInput>
    public typealias MOutput = OperationOutput<ListResourceSharePermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListResourceSharePermissionsOutputError>
}

public struct ListResourceSharePermissionsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListResourceSharePermissionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListResourceSharePermissionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListResourceSharePermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListResourceSharePermissionsInput>
    public typealias MOutput = OperationOutput<ListResourceSharePermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListResourceSharePermissionsOutputError>
}

public struct ListResourceSharePermissionsInput: Equatable {
    /// <p>The maximum number of results to return with a single call.
    ///   To retrieve the remaining results, make another call with the returned <code>nextToken</code> value.</p>
    public let maxResults: Int?
    /// <p>The token for the next page of results.</p>
    public let nextToken: String?
    /// <p>The Amazon Resource Name (ARN) of the resource share.</p>
    public let resourceShareArn: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        resourceShareArn: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceShareArn = resourceShareArn
    }
}

struct ListResourceSharePermissionsInputBody: Equatable {
    public let resourceShareArn: String?
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListResourceSharePermissionsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case nextToken
        case resourceShareArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceShareArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceShareArn)
        resourceShareArn = resourceShareArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListResourceSharePermissionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListResourceSharePermissionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MalformedArnException" : self = .malformedArnException(try MalformedArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalException" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnknownResourceException" : self = .unknownResourceException(try UnknownResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListResourceSharePermissionsOutputError: Swift.Error, Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterException(InvalidParameterException)
    case malformedArnException(MalformedArnException)
    case operationNotPermittedException(OperationNotPermittedException)
    case serverInternalException(ServerInternalException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknownResourceException(UnknownResourceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListResourceSharePermissionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListResourceSharePermissionsOutputResponse(nextToken: \(String(describing: nextToken)), permissions: \(String(describing: permissions)))"}
}

extension ListResourceSharePermissionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListResourceSharePermissionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.permissions = output.permissions
        } else {
            self.nextToken = nil
            self.permissions = nil
        }
    }
}

public struct ListResourceSharePermissionsOutputResponse: Equatable {
    /// <p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>
    public let nextToken: String?
    /// <p>The permissions associated with the resource share.</p>
    public let permissions: [ResourceSharePermissionSummary]?

    public init (
        nextToken: String? = nil,
        permissions: [ResourceSharePermissionSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.permissions = permissions
    }
}

struct ListResourceSharePermissionsOutputResponseBody: Equatable {
    public let permissions: [ResourceSharePermissionSummary]?
    public let nextToken: String?
}

extension ListResourceSharePermissionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case permissions
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let permissionsContainer = try containerValues.decodeIfPresent([ResourceSharePermissionSummary?].self, forKey: .permissions)
        var permissionsDecoded0:[ResourceSharePermissionSummary]? = nil
        if let permissionsContainer = permissionsContainer {
            permissionsDecoded0 = [ResourceSharePermissionSummary]()
            for structure0 in permissionsContainer {
                if let structure0 = structure0 {
                    permissionsDecoded0?.append(structure0)
                }
            }
        }
        permissions = permissionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListResourceTypesInputBodyMiddleware: Middleware {
    public let id: String = "ListResourceTypesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListResourceTypesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListResourceTypesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListResourceTypesInput>
    public typealias MOutput = OperationOutput<ListResourceTypesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListResourceTypesOutputError>
}

extension ListResourceTypesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListResourceTypesInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListResourceTypesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListResourceTypesInputHeadersMiddleware: Middleware {
    public let id: String = "ListResourceTypesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListResourceTypesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListResourceTypesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListResourceTypesInput>
    public typealias MOutput = OperationOutput<ListResourceTypesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListResourceTypesOutputError>
}

public struct ListResourceTypesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListResourceTypesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListResourceTypesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListResourceTypesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListResourceTypesInput>
    public typealias MOutput = OperationOutput<ListResourceTypesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListResourceTypesOutputError>
}

public struct ListResourceTypesInput: Equatable {
    /// <p>The maximum number of results to return with a single call.
    ///   To retrieve the remaining results, make another call with the returned <code>nextToken</code> value.</p>
    public let maxResults: Int?
    /// <p>The token for the next page of results.</p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListResourceTypesInputBody: Equatable {
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListResourceTypesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListResourceTypesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListResourceTypesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalException" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListResourceTypesOutputError: Swift.Error, Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterException(InvalidParameterException)
    case serverInternalException(ServerInternalException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListResourceTypesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListResourceTypesOutputResponse(nextToken: \(String(describing: nextToken)), resourceTypes: \(String(describing: resourceTypes)))"}
}

extension ListResourceTypesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListResourceTypesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.resourceTypes = output.resourceTypes
        } else {
            self.nextToken = nil
            self.resourceTypes = nil
        }
    }
}

public struct ListResourceTypesOutputResponse: Equatable {
    /// <p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>
    public let nextToken: String?
    /// <p>The shareable resource types supported by AWS RAM.</p>
    public let resourceTypes: [ServiceNameAndResourceType]?

    public init (
        nextToken: String? = nil,
        resourceTypes: [ServiceNameAndResourceType]? = nil
    )
    {
        self.nextToken = nextToken
        self.resourceTypes = resourceTypes
    }
}

struct ListResourceTypesOutputResponseBody: Equatable {
    public let resourceTypes: [ServiceNameAndResourceType]?
    public let nextToken: String?
}

extension ListResourceTypesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case resourceTypes
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypesContainer = try containerValues.decodeIfPresent([ServiceNameAndResourceType?].self, forKey: .resourceTypes)
        var resourceTypesDecoded0:[ServiceNameAndResourceType]? = nil
        if let resourceTypesContainer = resourceTypesContainer {
            resourceTypesDecoded0 = [ServiceNameAndResourceType]()
            for structure0 in resourceTypesContainer {
                if let structure0 = structure0 {
                    resourceTypesDecoded0?.append(structure0)
                }
            }
        }
        resourceTypes = resourceTypesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListResourcesInputBodyMiddleware: Middleware {
    public let id: String = "ListResourcesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListResourcesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListResourcesInput>
    public typealias MOutput = OperationOutput<ListResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListResourcesOutputError>
}

extension ListResourcesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListResourcesInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), principal: \(String(describing: principal)), resourceArns: \(String(describing: resourceArns)), resourceOwner: \(String(describing: resourceOwner)), resourceShareArns: \(String(describing: resourceShareArns)), resourceType: \(String(describing: resourceType)))"}
}

extension ListResourcesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case nextToken
        case principal
        case resourceArns
        case resourceOwner
        case resourceShareArns
        case resourceType
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let principal = principal {
            try encodeContainer.encode(principal, forKey: .principal)
        }
        if let resourceArns = resourceArns {
            var resourceArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceArns)
            for resourcearnlist0 in resourceArns {
                try resourceArnsContainer.encode(resourcearnlist0)
            }
        }
        if let resourceOwner = resourceOwner {
            try encodeContainer.encode(resourceOwner.rawValue, forKey: .resourceOwner)
        }
        if let resourceShareArns = resourceShareArns {
            var resourceShareArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceShareArns)
            for resourcesharearnlist0 in resourceShareArns {
                try resourceShareArnsContainer.encode(resourcesharearnlist0)
            }
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
    }
}

public struct ListResourcesInputHeadersMiddleware: Middleware {
    public let id: String = "ListResourcesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListResourcesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListResourcesInput>
    public typealias MOutput = OperationOutput<ListResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListResourcesOutputError>
}

public struct ListResourcesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListResourcesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListResourcesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListResourcesInput>
    public typealias MOutput = OperationOutput<ListResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListResourcesOutputError>
}

public struct ListResourcesInput: Equatable {
    /// <p>The maximum number of results to return with a single call.
    ///   To retrieve the remaining results, make another call with the returned <code>nextToken</code> value.</p>
    public let maxResults: Int?
    /// <p>The token for the next page of results.</p>
    public let nextToken: String?
    /// <p>The principal.</p>
    public let principal: String?
    /// <p>The Amazon Resource Names (ARN) of the resources.</p>
    public let resourceArns: [String]?
    /// <p>The type of owner.</p>
    public let resourceOwner: ResourceOwner?
    /// <p>The Amazon Resource Names (ARN) of the resource shares.</p>
    public let resourceShareArns: [String]?
    /// <p>The resource type.</p>
    ///    	     <p>Valid values: <code>acm-pca:CertificateAuthority</code> | <code>appmesh:Mesh</code> | <code>codebuild:Project</code> | <code>codebuild:ReportGroup</code> | <code>ec2:CapacityReservation</code> | <code>ec2:DedicatedHost</code> | <code>ec2:LocalGatewayRouteTable</code> | <code>ec2:PrefixList</code> | <code>ec2:Subnet</code> | <code>ec2:TrafficMirrorTarget</code> | <code>ec2:TransitGateway</code> | <code>imagebuilder:Component</code> | <code>imagebuilder:Image</code> | <code>imagebuilder:ImageRecipe</code> | <code>imagebuilder:ContainerRecipe</code> | <code>glue:Catalog</code> | <code>glue:Database</code> | <code>glue:Table</code> | <code>license-manager:LicenseConfiguration</code> I <code>network-firewall:FirewallPolicy</code> | <code>network-firewall:StatefulRuleGroup</code> | <code>network-firewall:StatelessRuleGroup</code> | <code>outposts:Outpost</code> | <code>resource-groups:Group</code> | <code>rds:Cluster</code> | <code>route53resolver:FirewallRuleGroup</code> |<code>route53resolver:ResolverQueryLogConfig</code> | <code>route53resolver:ResolverRule</code>
    ///          </p>
    public let resourceType: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        principal: String? = nil,
        resourceArns: [String]? = nil,
        resourceOwner: ResourceOwner? = nil,
        resourceShareArns: [String]? = nil,
        resourceType: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.principal = principal
        self.resourceArns = resourceArns
        self.resourceOwner = resourceOwner
        self.resourceShareArns = resourceShareArns
        self.resourceType = resourceType
    }
}

struct ListResourcesInputBody: Equatable {
    public let resourceOwner: ResourceOwner?
    public let principal: String?
    public let resourceType: String?
    public let resourceArns: [String]?
    public let resourceShareArns: [String]?
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListResourcesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case nextToken
        case principal
        case resourceArns
        case resourceOwner
        case resourceShareArns
        case resourceType
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceOwnerDecoded = try containerValues.decodeIfPresent(ResourceOwner.self, forKey: .resourceOwner)
        resourceOwner = resourceOwnerDecoded
        let principalDecoded = try containerValues.decodeIfPresent(String.self, forKey: .principal)
        principal = principalDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceArnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .resourceArns)
        var resourceArnsDecoded0:[String]? = nil
        if let resourceArnsContainer = resourceArnsContainer {
            resourceArnsDecoded0 = [String]()
            for string0 in resourceArnsContainer {
                if let string0 = string0 {
                    resourceArnsDecoded0?.append(string0)
                }
            }
        }
        resourceArns = resourceArnsDecoded0
        let resourceShareArnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .resourceShareArns)
        var resourceShareArnsDecoded0:[String]? = nil
        if let resourceShareArnsContainer = resourceShareArnsContainer {
            resourceShareArnsDecoded0 = [String]()
            for string0 in resourceShareArnsContainer {
                if let string0 = string0 {
                    resourceShareArnsDecoded0?.append(string0)
                }
            }
        }
        resourceShareArns = resourceShareArnsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListResourcesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListResourcesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceTypeException" : self = .invalidResourceTypeException(try InvalidResourceTypeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MalformedArnException" : self = .malformedArnException(try MalformedArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalException" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnknownResourceException" : self = .unknownResourceException(try UnknownResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListResourcesOutputError: Swift.Error, Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterException(InvalidParameterException)
    case invalidResourceTypeException(InvalidResourceTypeException)
    case malformedArnException(MalformedArnException)
    case serverInternalException(ServerInternalException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknownResourceException(UnknownResourceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListResourcesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListResourcesOutputResponse(nextToken: \(String(describing: nextToken)), resources: \(String(describing: resources)))"}
}

extension ListResourcesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListResourcesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.resources = output.resources
        } else {
            self.nextToken = nil
            self.resources = nil
        }
    }
}

public struct ListResourcesOutputResponse: Equatable {
    /// <p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>
    public let nextToken: String?
    /// <p>Information about the resources.</p>
    public let resources: [Resource]?

    public init (
        nextToken: String? = nil,
        resources: [Resource]? = nil
    )
    {
        self.nextToken = nextToken
        self.resources = resources
    }
}

struct ListResourcesOutputResponseBody: Equatable {
    public let resources: [Resource]?
    public let nextToken: String?
}

extension ListResourcesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case resources
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourcesContainer = try containerValues.decodeIfPresent([Resource?].self, forKey: .resources)
        var resourcesDecoded0:[Resource]? = nil
        if let resourcesContainer = resourcesContainer {
            resourcesDecoded0 = [Resource]()
            for structure0 in resourcesContainer {
                if let structure0 = structure0 {
                    resourcesDecoded0?.append(structure0)
                }
            }
        }
        resources = resourcesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension MalformedArnException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MalformedArnException(message: \(String(describing: message)))"}
}

extension MalformedArnException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: MalformedArnExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The format of an Amazon Resource Name (ARN) is not valid.</p>
public struct MalformedArnException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct MalformedArnExceptionBody: Equatable {
    public let message: String?
}

extension MalformedArnExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MissingRequiredParameterException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MissingRequiredParameterException(message: \(String(describing: message)))"}
}

extension MissingRequiredParameterException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: MissingRequiredParameterExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A required input parameter is missing.</p>
public struct MissingRequiredParameterException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct MissingRequiredParameterExceptionBody: Equatable {
    public let message: String?
}

extension MissingRequiredParameterExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OperationNotPermittedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OperationNotPermittedException(message: \(String(describing: message)))"}
}

extension OperationNotPermittedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: OperationNotPermittedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The requested operation is not permitted.</p>
public struct OperationNotPermittedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct OperationNotPermittedExceptionBody: Equatable {
    public let message: String?
}

extension OperationNotPermittedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Principal: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case creationTime
        case external
        case id
        case lastUpdatedTime
        case resourceShareArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let external = external {
            try encodeContainer.encode(external, forKey: .external)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUpdatedTime = lastUpdatedTime {
            try encodeContainer.encode(lastUpdatedTime.timeIntervalSince1970, forKey: .lastUpdatedTime)
        }
        if let resourceShareArn = resourceShareArn {
            try encodeContainer.encode(resourceShareArn, forKey: .resourceShareArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let resourceShareArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceShareArn)
        resourceShareArn = resourceShareArnDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let externalDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .external)
        external = externalDecoded
    }
}

extension Principal: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Principal(creationTime: \(String(describing: creationTime)), external: \(String(describing: external)), id: \(String(describing: id)), lastUpdatedTime: \(String(describing: lastUpdatedTime)), resourceShareArn: \(String(describing: resourceShareArn)))"}
}

/// <p>Describes a principal for use with AWS Resource Access Manager.</p>
public struct Principal: Equatable {
    /// <p>The time when the principal was associated with the resource share.</p>
    public let creationTime: Date?
    /// <p>Indicates whether the principal belongs to the same AWS organization as the AWS account that owns the resource share.</p>
    public let external: Bool?
    /// <p>The ID of the principal.</p>
    public let id: String?
    /// <p>The time when the association was last updated.</p>
    public let lastUpdatedTime: Date?
    /// <p>The Amazon Resource Name (ARN) of the resource share.</p>
    public let resourceShareArn: String?

    public init (
        creationTime: Date? = nil,
        external: Bool? = nil,
        id: String? = nil,
        lastUpdatedTime: Date? = nil,
        resourceShareArn: String? = nil
    )
    {
        self.creationTime = creationTime
        self.external = external
        self.id = id
        self.lastUpdatedTime = lastUpdatedTime
        self.resourceShareArn = resourceShareArn
    }
}

extension PromoteResourceShareCreatedFromPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PromoteResourceShareCreatedFromPolicyInput(resourceShareArn: \(String(describing: resourceShareArn)))"}
}

extension PromoteResourceShareCreatedFromPolicyInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct PromoteResourceShareCreatedFromPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "PromoteResourceShareCreatedFromPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PromoteResourceShareCreatedFromPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<PromoteResourceShareCreatedFromPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PromoteResourceShareCreatedFromPolicyInput>
    public typealias MOutput = OperationOutput<PromoteResourceShareCreatedFromPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PromoteResourceShareCreatedFromPolicyOutputError>
}

public struct PromoteResourceShareCreatedFromPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "PromoteResourceShareCreatedFromPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PromoteResourceShareCreatedFromPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<PromoteResourceShareCreatedFromPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let resourceShareArn = input.operationInput.resourceShareArn {
            let resourceShareArnQueryItem = URLQueryItem(name: "resourceShareArn".urlPercentEncoding(), value: String(resourceShareArn).urlPercentEncoding())
            input.builder.withQueryItem(resourceShareArnQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PromoteResourceShareCreatedFromPolicyInput>
    public typealias MOutput = OperationOutput<PromoteResourceShareCreatedFromPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PromoteResourceShareCreatedFromPolicyOutputError>
}

public struct PromoteResourceShareCreatedFromPolicyInput: Equatable {
    /// <p>The ARN of the resource share to promote.</p>
    public let resourceShareArn: String?

    public init (
        resourceShareArn: String? = nil
    )
    {
        self.resourceShareArn = resourceShareArn
    }
}

struct PromoteResourceShareCreatedFromPolicyInputBody: Equatable {
}

extension PromoteResourceShareCreatedFromPolicyInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension PromoteResourceShareCreatedFromPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PromoteResourceShareCreatedFromPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MalformedArnException" : self = .malformedArnException(try MalformedArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingRequiredParameterException" : self = .missingRequiredParameterException(try MissingRequiredParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalException" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnknownResourceException" : self = .unknownResourceException(try UnknownResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PromoteResourceShareCreatedFromPolicyOutputError: Swift.Error, Equatable {
    case invalidParameterException(InvalidParameterException)
    case malformedArnException(MalformedArnException)
    case missingRequiredParameterException(MissingRequiredParameterException)
    case operationNotPermittedException(OperationNotPermittedException)
    case serverInternalException(ServerInternalException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknownResourceException(UnknownResourceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PromoteResourceShareCreatedFromPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PromoteResourceShareCreatedFromPolicyOutputResponse(returnValue: \(String(describing: returnValue)))"}
}

extension PromoteResourceShareCreatedFromPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PromoteResourceShareCreatedFromPolicyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.returnValue = output.returnValue
        } else {
            self.returnValue = nil
        }
    }
}

public struct PromoteResourceShareCreatedFromPolicyOutputResponse: Equatable {
    /// <p>Indicates whether the request succeeded.</p>
    public let returnValue: Bool?

    public init (
        returnValue: Bool? = nil
    )
    {
        self.returnValue = returnValue
    }
}

struct PromoteResourceShareCreatedFromPolicyOutputResponseBody: Equatable {
    public let returnValue: Bool?
}

extension PromoteResourceShareCreatedFromPolicyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case returnValue
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let returnValueDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .returnValue)
        returnValue = returnValueDecoded
    }
}

public struct RejectResourceShareInvitationInputBodyMiddleware: Middleware {
    public let id: String = "RejectResourceShareInvitationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RejectResourceShareInvitationInput>,
                  next: H) -> Swift.Result<OperationOutput<RejectResourceShareInvitationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RejectResourceShareInvitationInput>
    public typealias MOutput = OperationOutput<RejectResourceShareInvitationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RejectResourceShareInvitationOutputError>
}

extension RejectResourceShareInvitationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RejectResourceShareInvitationInput(clientToken: \(String(describing: clientToken)), resourceShareInvitationArn: \(String(describing: resourceShareInvitationArn)))"}
}

extension RejectResourceShareInvitationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientToken
        case resourceShareInvitationArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let resourceShareInvitationArn = resourceShareInvitationArn {
            try encodeContainer.encode(resourceShareInvitationArn, forKey: .resourceShareInvitationArn)
        }
    }
}

public struct RejectResourceShareInvitationInputHeadersMiddleware: Middleware {
    public let id: String = "RejectResourceShareInvitationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RejectResourceShareInvitationInput>,
                  next: H) -> Swift.Result<OperationOutput<RejectResourceShareInvitationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RejectResourceShareInvitationInput>
    public typealias MOutput = OperationOutput<RejectResourceShareInvitationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RejectResourceShareInvitationOutputError>
}

public struct RejectResourceShareInvitationInputQueryItemMiddleware: Middleware {
    public let id: String = "RejectResourceShareInvitationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RejectResourceShareInvitationInput>,
                  next: H) -> Swift.Result<OperationOutput<RejectResourceShareInvitationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RejectResourceShareInvitationInput>
    public typealias MOutput = OperationOutput<RejectResourceShareInvitationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RejectResourceShareInvitationOutputError>
}

public struct RejectResourceShareInvitationInput: Equatable {
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.</p>
    public let clientToken: String?
    /// <p>The Amazon Resource Name (ARN) of the invitation.</p>
    public let resourceShareInvitationArn: String?

    public init (
        clientToken: String? = nil,
        resourceShareInvitationArn: String? = nil
    )
    {
        self.clientToken = clientToken
        self.resourceShareInvitationArn = resourceShareInvitationArn
    }
}

struct RejectResourceShareInvitationInputBody: Equatable {
    public let resourceShareInvitationArn: String?
    public let clientToken: String?
}

extension RejectResourceShareInvitationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientToken
        case resourceShareInvitationArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceShareInvitationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceShareInvitationArn)
        resourceShareInvitationArn = resourceShareInvitationArnDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension RejectResourceShareInvitationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RejectResourceShareInvitationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "IdempotentParameterMismatchException" : self = .idempotentParameterMismatchException(try IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClientTokenException" : self = .invalidClientTokenException(try InvalidClientTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MalformedArnException" : self = .malformedArnException(try MalformedArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceShareInvitationAlreadyAcceptedException" : self = .resourceShareInvitationAlreadyAcceptedException(try ResourceShareInvitationAlreadyAcceptedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceShareInvitationAlreadyRejectedException" : self = .resourceShareInvitationAlreadyRejectedException(try ResourceShareInvitationAlreadyRejectedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceShareInvitationArnNotFoundException" : self = .resourceShareInvitationArnNotFoundException(try ResourceShareInvitationArnNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceShareInvitationExpiredException" : self = .resourceShareInvitationExpiredException(try ResourceShareInvitationExpiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalException" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RejectResourceShareInvitationOutputError: Swift.Error, Equatable {
    case idempotentParameterMismatchException(IdempotentParameterMismatchException)
    case invalidClientTokenException(InvalidClientTokenException)
    case malformedArnException(MalformedArnException)
    case operationNotPermittedException(OperationNotPermittedException)
    case resourceShareInvitationAlreadyAcceptedException(ResourceShareInvitationAlreadyAcceptedException)
    case resourceShareInvitationAlreadyRejectedException(ResourceShareInvitationAlreadyRejectedException)
    case resourceShareInvitationArnNotFoundException(ResourceShareInvitationArnNotFoundException)
    case resourceShareInvitationExpiredException(ResourceShareInvitationExpiredException)
    case serverInternalException(ServerInternalException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RejectResourceShareInvitationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RejectResourceShareInvitationOutputResponse(clientToken: \(String(describing: clientToken)), resourceShareInvitation: \(String(describing: resourceShareInvitation)))"}
}

extension RejectResourceShareInvitationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RejectResourceShareInvitationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.clientToken = output.clientToken
            self.resourceShareInvitation = output.resourceShareInvitation
        } else {
            self.clientToken = nil
            self.resourceShareInvitation = nil
        }
    }
}

public struct RejectResourceShareInvitationOutputResponse: Equatable {
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.</p>
    public let clientToken: String?
    /// <p>Information about the invitation.</p>
    public let resourceShareInvitation: ResourceShareInvitation?

    public init (
        clientToken: String? = nil,
        resourceShareInvitation: ResourceShareInvitation? = nil
    )
    {
        self.clientToken = clientToken
        self.resourceShareInvitation = resourceShareInvitation
    }
}

struct RejectResourceShareInvitationOutputResponseBody: Equatable {
    public let resourceShareInvitation: ResourceShareInvitation?
    public let clientToken: String?
}

extension RejectResourceShareInvitationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientToken
        case resourceShareInvitation
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceShareInvitationDecoded = try containerValues.decodeIfPresent(ResourceShareInvitation.self, forKey: .resourceShareInvitation)
        resourceShareInvitation = resourceShareInvitationDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension Resource: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case creationTime
        case lastUpdatedTime
        case resourceGroupArn
        case resourceShareArn
        case status
        case statusMessage
        case type
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let lastUpdatedTime = lastUpdatedTime {
            try encodeContainer.encode(lastUpdatedTime.timeIntervalSince1970, forKey: .lastUpdatedTime)
        }
        if let resourceGroupArn = resourceGroupArn {
            try encodeContainer.encode(resourceGroupArn, forKey: .resourceGroupArn)
        }
        if let resourceShareArn = resourceShareArn {
            try encodeContainer.encode(resourceShareArn, forKey: .resourceShareArn)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
        let resourceShareArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceShareArn)
        resourceShareArn = resourceShareArnDecoded
        let resourceGroupArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceGroupArn)
        resourceGroupArn = resourceGroupArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ResourceStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
    }
}

extension Resource: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Resource(arn: \(String(describing: arn)), creationTime: \(String(describing: creationTime)), lastUpdatedTime: \(String(describing: lastUpdatedTime)), resourceGroupArn: \(String(describing: resourceGroupArn)), resourceShareArn: \(String(describing: resourceShareArn)), status: \(String(describing: status)), statusMessage: \(String(describing: statusMessage)), type: \(String(describing: type)))"}
}

/// <p>Describes a resource associated with a resource share.</p>
public struct Resource: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the resource.</p>
    public let arn: String?
    /// <p>The time when the resource was associated with the resource share.</p>
    public let creationTime: Date?
    /// <p>The time when the association was last updated.</p>
    public let lastUpdatedTime: Date?
    /// <p>The ARN of the resource group. This value is returned only if the resource is a resource
    /// 			group.</p>
    public let resourceGroupArn: String?
    /// <p>The Amazon Resource Name (ARN) of the resource share.</p>
    public let resourceShareArn: String?
    /// <p>The status of the resource.</p>
    public let status: ResourceStatus?
    /// <p>A message about the status of the resource.</p>
    public let statusMessage: String?
    /// <p>The resource type.</p>
    public let type: String?

    public init (
        arn: String? = nil,
        creationTime: Date? = nil,
        lastUpdatedTime: Date? = nil,
        resourceGroupArn: String? = nil,
        resourceShareArn: String? = nil,
        status: ResourceStatus? = nil,
        statusMessage: String? = nil,
        type: String? = nil
    )
    {
        self.arn = arn
        self.creationTime = creationTime
        self.lastUpdatedTime = lastUpdatedTime
        self.resourceGroupArn = resourceGroupArn
        self.resourceShareArn = resourceShareArn
        self.status = status
        self.statusMessage = statusMessage
        self.type = type
    }
}

extension ResourceArnNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceArnNotFoundException(message: \(String(describing: message)))"}
}

extension ResourceArnNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceArnNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An Amazon Resource Name (ARN) was not found.</p>
public struct ResourceArnNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceArnNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension ResourceArnNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum ResourceOwner {
    case otherAccounts
    case `self`
    case sdkUnknown(String)
}

extension ResourceOwner : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ResourceOwner] {
        return [
            .otherAccounts,
            .self,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .otherAccounts: return "OTHER-ACCOUNTS"
        case .self: return "SELF"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ResourceOwner(rawValue: rawValue) ?? ResourceOwner.sdkUnknown(rawValue)
    }
}

extension ResourceShare: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case allowExternalPrincipals
        case creationTime
        case featureSet
        case lastUpdatedTime
        case name
        case owningAccountId
        case resourceShareArn
        case status
        case statusMessage
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowExternalPrincipals = allowExternalPrincipals {
            try encodeContainer.encode(allowExternalPrincipals, forKey: .allowExternalPrincipals)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let featureSet = featureSet {
            try encodeContainer.encode(featureSet.rawValue, forKey: .featureSet)
        }
        if let lastUpdatedTime = lastUpdatedTime {
            try encodeContainer.encode(lastUpdatedTime.timeIntervalSince1970, forKey: .lastUpdatedTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let owningAccountId = owningAccountId {
            try encodeContainer.encode(owningAccountId, forKey: .owningAccountId)
        }
        if let resourceShareArn = resourceShareArn {
            try encodeContainer.encode(resourceShareArn, forKey: .resourceShareArn)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceShareArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceShareArn)
        resourceShareArn = resourceShareArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let owningAccountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .owningAccountId)
        owningAccountId = owningAccountIdDecoded
        let allowExternalPrincipalsDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .allowExternalPrincipals)
        allowExternalPrincipals = allowExternalPrincipalsDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ResourceShareStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let featureSetDecoded = try containerValues.decodeIfPresent(ResourceShareFeatureSet.self, forKey: .featureSet)
        featureSet = featureSetDecoded
    }
}

extension ResourceShare: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceShare(allowExternalPrincipals: \(String(describing: allowExternalPrincipals)), creationTime: \(String(describing: creationTime)), featureSet: \(String(describing: featureSet)), lastUpdatedTime: \(String(describing: lastUpdatedTime)), name: \(String(describing: name)), owningAccountId: \(String(describing: owningAccountId)), resourceShareArn: \(String(describing: resourceShareArn)), status: \(String(describing: status)), statusMessage: \(String(describing: statusMessage)), tags: \(String(describing: tags)))"}
}

/// <p>Describes a resource share.</p>
public struct ResourceShare: Equatable {
    /// <p>Indicates whether principals outside your AWS organization can be associated with a resource share.</p>
    public let allowExternalPrincipals: Bool?
    /// <p>The time when the resource share was created.</p>
    public let creationTime: Date?
    /// <p>Indicates how the resource share was created. Possible values include:</p>
    /// 	        <ul>
    ///             <li>
    /// 			            <p>
    ///                   <code>CREATED_FROM_POLICY</code> - Indicates that the resource share was created from an AWS Identity
    /// 					and Access Management (AWS IAM) policy attached to a resource. These resource shares are
    /// 					visible only to the AWS account that created it. They cannot be modified in
    /// 					AWS RAM.</p>
    /// 		          </li>
    ///             <li>
    /// 			            <p>
    ///                   <code>PROMOTING_TO_STANDARD</code> - The resource share is in the process
    /// 				of being promoted. For more information, see
    /// 				<a>PromoteResourceShareCreatedFromPolicy</a>.</p>
    /// 		          </li>
    ///             <li>
    /// 			            <p>
    ///                   <code>STANDARD</code> - Indicates that the resource share was created in AWS RAM using the console or
    /// 					APIs. These resource shares are visible to all principals. They can be modified
    /// 					in AWS RAM.</p>
    /// 		          </li>
    ///          </ul>
    public let featureSet: ResourceShareFeatureSet?
    /// <p>The time when the resource share was last updated.</p>
    public let lastUpdatedTime: Date?
    /// <p>The name of the resource share.</p>
    public let name: String?
    /// <p>The ID of the AWS account that owns the resource share.</p>
    public let owningAccountId: String?
    /// <p>The Amazon Resource Name (ARN) of the resource share.</p>
    public let resourceShareArn: String?
    /// <p>The status of the resource share.</p>
    public let status: ResourceShareStatus?
    /// <p>A message about the status of the resource share.</p>
    public let statusMessage: String?
    /// <p>The tags for the resource share.</p>
    public let tags: [Tag]?

    public init (
        allowExternalPrincipals: Bool? = nil,
        creationTime: Date? = nil,
        featureSet: ResourceShareFeatureSet? = nil,
        lastUpdatedTime: Date? = nil,
        name: String? = nil,
        owningAccountId: String? = nil,
        resourceShareArn: String? = nil,
        status: ResourceShareStatus? = nil,
        statusMessage: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.allowExternalPrincipals = allowExternalPrincipals
        self.creationTime = creationTime
        self.featureSet = featureSet
        self.lastUpdatedTime = lastUpdatedTime
        self.name = name
        self.owningAccountId = owningAccountId
        self.resourceShareArn = resourceShareArn
        self.status = status
        self.statusMessage = statusMessage
        self.tags = tags
    }
}

extension ResourceShareAssociation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case associatedEntity
        case associationType
        case creationTime
        case external
        case lastUpdatedTime
        case resourceShareArn
        case resourceShareName
        case status
        case statusMessage
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associatedEntity = associatedEntity {
            try encodeContainer.encode(associatedEntity, forKey: .associatedEntity)
        }
        if let associationType = associationType {
            try encodeContainer.encode(associationType.rawValue, forKey: .associationType)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let external = external {
            try encodeContainer.encode(external, forKey: .external)
        }
        if let lastUpdatedTime = lastUpdatedTime {
            try encodeContainer.encode(lastUpdatedTime.timeIntervalSince1970, forKey: .lastUpdatedTime)
        }
        if let resourceShareArn = resourceShareArn {
            try encodeContainer.encode(resourceShareArn, forKey: .resourceShareArn)
        }
        if let resourceShareName = resourceShareName {
            try encodeContainer.encode(resourceShareName, forKey: .resourceShareName)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceShareArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceShareArn)
        resourceShareArn = resourceShareArnDecoded
        let resourceShareNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceShareName)
        resourceShareName = resourceShareNameDecoded
        let associatedEntityDecoded = try containerValues.decodeIfPresent(String.self, forKey: .associatedEntity)
        associatedEntity = associatedEntityDecoded
        let associationTypeDecoded = try containerValues.decodeIfPresent(ResourceShareAssociationType.self, forKey: .associationType)
        associationType = associationTypeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ResourceShareAssociationStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let externalDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .external)
        external = externalDecoded
    }
}

extension ResourceShareAssociation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceShareAssociation(associatedEntity: \(String(describing: associatedEntity)), associationType: \(String(describing: associationType)), creationTime: \(String(describing: creationTime)), external: \(String(describing: external)), lastUpdatedTime: \(String(describing: lastUpdatedTime)), resourceShareArn: \(String(describing: resourceShareArn)), resourceShareName: \(String(describing: resourceShareName)), status: \(String(describing: status)), statusMessage: \(String(describing: statusMessage)))"}
}

/// <p>Describes an association with a resource share.</p>
public struct ResourceShareAssociation: Equatable {
    /// <p>The associated entity. For resource associations, this is the ARN of the resource.
    ///        For principal associations, this is the ID of an AWS account or the ARN of an OU or
    ///        organization from AWS Organizations.</p>
    public let associatedEntity: String?
    /// <p>The association type.</p>
    public let associationType: ResourceShareAssociationType?
    /// <p>The time when the association was created.</p>
    public let creationTime: Date?
    /// <p>Indicates whether the principal belongs to the same AWS organization as the AWS account that owns the resource share.</p>
    public let external: Bool?
    /// <p>The time when the association was last updated.</p>
    public let lastUpdatedTime: Date?
    /// <p>The Amazon Resource Name (ARN) of the resource share.</p>
    public let resourceShareArn: String?
    /// <p>The name of the resource share.</p>
    public let resourceShareName: String?
    /// <p>The status of the association.</p>
    public let status: ResourceShareAssociationStatus?
    /// <p>A message about the status of the association.</p>
    public let statusMessage: String?

    public init (
        associatedEntity: String? = nil,
        associationType: ResourceShareAssociationType? = nil,
        creationTime: Date? = nil,
        external: Bool? = nil,
        lastUpdatedTime: Date? = nil,
        resourceShareArn: String? = nil,
        resourceShareName: String? = nil,
        status: ResourceShareAssociationStatus? = nil,
        statusMessage: String? = nil
    )
    {
        self.associatedEntity = associatedEntity
        self.associationType = associationType
        self.creationTime = creationTime
        self.external = external
        self.lastUpdatedTime = lastUpdatedTime
        self.resourceShareArn = resourceShareArn
        self.resourceShareName = resourceShareName
        self.status = status
        self.statusMessage = statusMessage
    }
}

public enum ResourceShareAssociationStatus {
    case associated
    case associating
    case disassociated
    case disassociating
    case failed
    case sdkUnknown(String)
}

extension ResourceShareAssociationStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ResourceShareAssociationStatus] {
        return [
            .associated,
            .associating,
            .disassociated,
            .disassociating,
            .failed,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .associated: return "ASSOCIATED"
        case .associating: return "ASSOCIATING"
        case .disassociated: return "DISASSOCIATED"
        case .disassociating: return "DISASSOCIATING"
        case .failed: return "FAILED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ResourceShareAssociationStatus(rawValue: rawValue) ?? ResourceShareAssociationStatus.sdkUnknown(rawValue)
    }
}

public enum ResourceShareAssociationType {
    case principal
    case resource
    case sdkUnknown(String)
}

extension ResourceShareAssociationType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ResourceShareAssociationType] {
        return [
            .principal,
            .resource,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .principal: return "PRINCIPAL"
        case .resource: return "RESOURCE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ResourceShareAssociationType(rawValue: rawValue) ?? ResourceShareAssociationType.sdkUnknown(rawValue)
    }
}

public enum ResourceShareFeatureSet {
    case createdFromPolicy
    case promotingToStandard
    case standard
    case sdkUnknown(String)
}

extension ResourceShareFeatureSet : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ResourceShareFeatureSet] {
        return [
            .createdFromPolicy,
            .promotingToStandard,
            .standard,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .createdFromPolicy: return "CREATED_FROM_POLICY"
        case .promotingToStandard: return "PROMOTING_TO_STANDARD"
        case .standard: return "STANDARD"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ResourceShareFeatureSet(rawValue: rawValue) ?? ResourceShareFeatureSet.sdkUnknown(rawValue)
    }
}

extension ResourceShareInvitation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case invitationTimestamp
        case receiverAccountId
        case resourceShareArn
        case resourceShareAssociations
        case resourceShareInvitationArn
        case resourceShareName
        case senderAccountId
        case status
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let invitationTimestamp = invitationTimestamp {
            try encodeContainer.encode(invitationTimestamp.timeIntervalSince1970, forKey: .invitationTimestamp)
        }
        if let receiverAccountId = receiverAccountId {
            try encodeContainer.encode(receiverAccountId, forKey: .receiverAccountId)
        }
        if let resourceShareArn = resourceShareArn {
            try encodeContainer.encode(resourceShareArn, forKey: .resourceShareArn)
        }
        if let resourceShareAssociations = resourceShareAssociations {
            var resourceShareAssociationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceShareAssociations)
            for resourceshareassociationlist0 in resourceShareAssociations {
                try resourceShareAssociationsContainer.encode(resourceshareassociationlist0)
            }
        }
        if let resourceShareInvitationArn = resourceShareInvitationArn {
            try encodeContainer.encode(resourceShareInvitationArn, forKey: .resourceShareInvitationArn)
        }
        if let resourceShareName = resourceShareName {
            try encodeContainer.encode(resourceShareName, forKey: .resourceShareName)
        }
        if let senderAccountId = senderAccountId {
            try encodeContainer.encode(senderAccountId, forKey: .senderAccountId)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceShareInvitationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceShareInvitationArn)
        resourceShareInvitationArn = resourceShareInvitationArnDecoded
        let resourceShareNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceShareName)
        resourceShareName = resourceShareNameDecoded
        let resourceShareArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceShareArn)
        resourceShareArn = resourceShareArnDecoded
        let senderAccountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .senderAccountId)
        senderAccountId = senderAccountIdDecoded
        let receiverAccountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .receiverAccountId)
        receiverAccountId = receiverAccountIdDecoded
        let invitationTimestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .invitationTimestamp)
        invitationTimestamp = invitationTimestampDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ResourceShareInvitationStatus.self, forKey: .status)
        status = statusDecoded
        let resourceShareAssociationsContainer = try containerValues.decodeIfPresent([ResourceShareAssociation?].self, forKey: .resourceShareAssociations)
        var resourceShareAssociationsDecoded0:[ResourceShareAssociation]? = nil
        if let resourceShareAssociationsContainer = resourceShareAssociationsContainer {
            resourceShareAssociationsDecoded0 = [ResourceShareAssociation]()
            for structure0 in resourceShareAssociationsContainer {
                if let structure0 = structure0 {
                    resourceShareAssociationsDecoded0?.append(structure0)
                }
            }
        }
        resourceShareAssociations = resourceShareAssociationsDecoded0
    }
}

extension ResourceShareInvitation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceShareInvitation(invitationTimestamp: \(String(describing: invitationTimestamp)), receiverAccountId: \(String(describing: receiverAccountId)), resourceShareArn: \(String(describing: resourceShareArn)), resourceShareAssociations: \(String(describing: resourceShareAssociations)), resourceShareInvitationArn: \(String(describing: resourceShareInvitationArn)), resourceShareName: \(String(describing: resourceShareName)), senderAccountId: \(String(describing: senderAccountId)), status: \(String(describing: status)))"}
}

/// <p>Describes an invitation to join a resource share.</p>
public struct ResourceShareInvitation: Equatable {
    /// <p>The date and time when the invitation was sent.</p>
    public let invitationTimestamp: Date?
    /// <p>The ID of the AWS account that received the invitation.</p>
    public let receiverAccountId: String?
    /// <p>The Amazon Resource Name (ARN) of the resource share.</p>
    public let resourceShareArn: String?
    /// <p>To view the resources associated with a pending resource share invitation, use
    ///       	<a href="https://docs.aws.amazon.com/ram/latest/APIReference/API_ListPendingInvitationResources.html">
    ///       		ListPendingInvitationResources</a>.</p>
    @available(*, deprecated, message: "This member has been deprecated. Use ListPendingInvitationResources.")
    public let resourceShareAssociations: [ResourceShareAssociation]?
    /// <p>The Amazon Resource Name (ARN) of the invitation.</p>
    public let resourceShareInvitationArn: String?
    /// <p>The name of the resource share.</p>
    public let resourceShareName: String?
    /// <p>The ID of the AWS account that sent the invitation.</p>
    public let senderAccountId: String?
    /// <p>The status of the invitation.</p>
    public let status: ResourceShareInvitationStatus?

    public init (
        invitationTimestamp: Date? = nil,
        receiverAccountId: String? = nil,
        resourceShareArn: String? = nil,
        resourceShareAssociations: [ResourceShareAssociation]? = nil,
        resourceShareInvitationArn: String? = nil,
        resourceShareName: String? = nil,
        senderAccountId: String? = nil,
        status: ResourceShareInvitationStatus? = nil
    )
    {
        self.invitationTimestamp = invitationTimestamp
        self.receiverAccountId = receiverAccountId
        self.resourceShareArn = resourceShareArn
        self.resourceShareAssociations = resourceShareAssociations
        self.resourceShareInvitationArn = resourceShareInvitationArn
        self.resourceShareName = resourceShareName
        self.senderAccountId = senderAccountId
        self.status = status
    }
}

extension ResourceShareInvitationAlreadyAcceptedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceShareInvitationAlreadyAcceptedException(message: \(String(describing: message)))"}
}

extension ResourceShareInvitationAlreadyAcceptedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceShareInvitationAlreadyAcceptedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The invitation was already accepted.</p>
public struct ResourceShareInvitationAlreadyAcceptedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceShareInvitationAlreadyAcceptedExceptionBody: Equatable {
    public let message: String?
}

extension ResourceShareInvitationAlreadyAcceptedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceShareInvitationAlreadyRejectedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceShareInvitationAlreadyRejectedException(message: \(String(describing: message)))"}
}

extension ResourceShareInvitationAlreadyRejectedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceShareInvitationAlreadyRejectedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The invitation was already rejected.</p>
public struct ResourceShareInvitationAlreadyRejectedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceShareInvitationAlreadyRejectedExceptionBody: Equatable {
    public let message: String?
}

extension ResourceShareInvitationAlreadyRejectedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceShareInvitationArnNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceShareInvitationArnNotFoundException(message: \(String(describing: message)))"}
}

extension ResourceShareInvitationArnNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceShareInvitationArnNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The Amazon Resource Name (ARN) for an invitation was not found.</p>
public struct ResourceShareInvitationArnNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceShareInvitationArnNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension ResourceShareInvitationArnNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceShareInvitationExpiredException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceShareInvitationExpiredException(message: \(String(describing: message)))"}
}

extension ResourceShareInvitationExpiredException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceShareInvitationExpiredExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The invitation is expired.</p>
public struct ResourceShareInvitationExpiredException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceShareInvitationExpiredExceptionBody: Equatable {
    public let message: String?
}

extension ResourceShareInvitationExpiredExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum ResourceShareInvitationStatus {
    case accepted
    case expired
    case pending
    case rejected
    case sdkUnknown(String)
}

extension ResourceShareInvitationStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ResourceShareInvitationStatus] {
        return [
            .accepted,
            .expired,
            .pending,
            .rejected,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .accepted: return "ACCEPTED"
        case .expired: return "EXPIRED"
        case .pending: return "PENDING"
        case .rejected: return "REJECTED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ResourceShareInvitationStatus(rawValue: rawValue) ?? ResourceShareInvitationStatus.sdkUnknown(rawValue)
    }
}

extension ResourceShareLimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceShareLimitExceededException(message: \(String(describing: message)))"}
}

extension ResourceShareLimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceShareLimitExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The requested resource share exceeds the limit for your account.</p>
public struct ResourceShareLimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceShareLimitExceededExceptionBody: Equatable {
    public let message: String?
}

extension ResourceShareLimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceSharePermissionDetail: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case creationTime
        case defaultVersion
        case lastUpdatedTime
        case name
        case permission
        case resourceType
        case version
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let defaultVersion = defaultVersion {
            try encodeContainer.encode(defaultVersion, forKey: .defaultVersion)
        }
        if let lastUpdatedTime = lastUpdatedTime {
            try encodeContainer.encode(lastUpdatedTime.timeIntervalSince1970, forKey: .lastUpdatedTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let permission = permission {
            try encodeContainer.encode(permission, forKey: .permission)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
        let defaultVersionDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .defaultVersion)
        defaultVersion = defaultVersionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let permissionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .permission)
        permission = permissionDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
    }
}

extension ResourceSharePermissionDetail: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceSharePermissionDetail(arn: \(String(describing: arn)), creationTime: \(String(describing: creationTime)), defaultVersion: \(String(describing: defaultVersion)), lastUpdatedTime: \(String(describing: lastUpdatedTime)), name: \(String(describing: name)), permission: \(String(describing: permission)), resourceType: \(String(describing: resourceType)), version: \(String(describing: version)))"}
}

/// <p>Information about an AWS RAM permission.</p>
public struct ResourceSharePermissionDetail: Equatable {
    /// <p>The ARN of the permission.</p>
    public let arn: String?
    /// <p>The date and time when the permission was created.</p>
    public let creationTime: Date?
    /// <p>The identifier for the version of the permission that is set as the
    ///     		default version.</p>
    public let defaultVersion: Bool?
    /// <p>The date and time when the permission was last updated.</p>
    public let lastUpdatedTime: Date?
    /// <p>The name of the permission.</p>
    public let name: String?
    /// <p>The permission's effect and actions in JSON format. The <code>effect</code> indicates whether
    /// 			the actions are allowed or denied. The <code>actions</code> list the API actions to
    /// 			which the principal is granted or denied access.</p>
    public let permission: String?
    /// <p>The resource type to which the permission applies.</p>
    public let resourceType: String?
    /// <p>The identifier for the version of the permission.</p>
    public let version: String?

    public init (
        arn: String? = nil,
        creationTime: Date? = nil,
        defaultVersion: Bool? = nil,
        lastUpdatedTime: Date? = nil,
        name: String? = nil,
        permission: String? = nil,
        resourceType: String? = nil,
        version: String? = nil
    )
    {
        self.arn = arn
        self.creationTime = creationTime
        self.defaultVersion = defaultVersion
        self.lastUpdatedTime = lastUpdatedTime
        self.name = name
        self.permission = permission
        self.resourceType = resourceType
        self.version = version
    }
}

extension ResourceSharePermissionSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case creationTime
        case defaultVersion
        case lastUpdatedTime
        case name
        case resourceType
        case status
        case version
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let defaultVersion = defaultVersion {
            try encodeContainer.encode(defaultVersion, forKey: .defaultVersion)
        }
        if let lastUpdatedTime = lastUpdatedTime {
            try encodeContainer.encode(lastUpdatedTime.timeIntervalSince1970, forKey: .lastUpdatedTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
        let defaultVersionDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .defaultVersion)
        defaultVersion = defaultVersionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
    }
}

extension ResourceSharePermissionSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceSharePermissionSummary(arn: \(String(describing: arn)), creationTime: \(String(describing: creationTime)), defaultVersion: \(String(describing: defaultVersion)), lastUpdatedTime: \(String(describing: lastUpdatedTime)), name: \(String(describing: name)), resourceType: \(String(describing: resourceType)), status: \(String(describing: status)), version: \(String(describing: version)))"}
}

/// <p>Information about a permission that is associated with a resource share.</p>
public struct ResourceSharePermissionSummary: Equatable {
    /// <p>The ARN of the permission.</p>
    public let arn: String?
    /// <p>The date and time when the permission was created.</p>
    public let creationTime: Date?
    /// <p>The identifier for the version of the permission that is set as the default version.</p>
    public let defaultVersion: Bool?
    /// <p>The date and time when the permission was last updated.</p>
    public let lastUpdatedTime: Date?
    /// <p>The name of the permission.</p>
    public let name: String?
    /// <p>The type of resource to which the permission applies.</p>
    public let resourceType: String?
    /// <p>The current status of the permission.</p>
    public let status: String?
    /// <p>The identifier for the version of the permission.</p>
    public let version: String?

    public init (
        arn: String? = nil,
        creationTime: Date? = nil,
        defaultVersion: Bool? = nil,
        lastUpdatedTime: Date? = nil,
        name: String? = nil,
        resourceType: String? = nil,
        status: String? = nil,
        version: String? = nil
    )
    {
        self.arn = arn
        self.creationTime = creationTime
        self.defaultVersion = defaultVersion
        self.lastUpdatedTime = lastUpdatedTime
        self.name = name
        self.resourceType = resourceType
        self.status = status
        self.version = version
    }
}

public enum ResourceShareStatus {
    case active
    case deleted
    case deleting
    case failed
    case pending
    case sdkUnknown(String)
}

extension ResourceShareStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ResourceShareStatus] {
        return [
            .active,
            .deleted,
            .deleting,
            .failed,
            .pending,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .active: return "ACTIVE"
        case .deleted: return "DELETED"
        case .deleting: return "DELETING"
        case .failed: return "FAILED"
        case .pending: return "PENDING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ResourceShareStatus(rawValue: rawValue) ?? ResourceShareStatus.sdkUnknown(rawValue)
    }
}

public enum ResourceStatus {
    case available
    case limitExceeded
    case pending
    case unavailable
    case zonalResourceInaccessible
    case sdkUnknown(String)
}

extension ResourceStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ResourceStatus] {
        return [
            .available,
            .limitExceeded,
            .pending,
            .unavailable,
            .zonalResourceInaccessible,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .available: return "AVAILABLE"
        case .limitExceeded: return "LIMIT_EXCEEDED"
        case .pending: return "PENDING"
        case .unavailable: return "UNAVAILABLE"
        case .zonalResourceInaccessible: return "ZONAL_RESOURCE_INACCESSIBLE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ResourceStatus(rawValue: rawValue) ?? ResourceStatus.sdkUnknown(rawValue)
    }
}

extension ServerInternalException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServerInternalException(message: \(String(describing: message)))"}
}

extension ServerInternalException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ServerInternalExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The service could not respond to the request due to an internal problem.</p>
public struct ServerInternalException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ServerInternalExceptionBody: Equatable {
    public let message: String?
}

extension ServerInternalExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceNameAndResourceType: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceType
        case serviceName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
        if let serviceName = serviceName {
            try encodeContainer.encode(serviceName, forKey: .serviceName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let serviceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
    }
}

extension ServiceNameAndResourceType: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceNameAndResourceType(resourceType: \(String(describing: resourceType)), serviceName: \(String(describing: serviceName)))"}
}

/// <p>Information about the shareable resource types and the AWS services to which they belong.</p>
public struct ServiceNameAndResourceType: Equatable {
    /// <p>The shareable resource types.</p>
    public let resourceType: String?
    /// <p>The name of the AWS services to which the resources belong.</p>
    public let serviceName: String?

    public init (
        resourceType: String? = nil,
        serviceName: String? = nil
    )
    {
        self.resourceType = resourceType
        self.serviceName = serviceName
    }
}

extension ServiceUnavailableException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceUnavailableException(message: \(String(describing: message)))"}
}

extension ServiceUnavailableException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ServiceUnavailableExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The service is not available.</p>
public struct ServiceUnavailableException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceUnavailableExceptionBody: Equatable {
    public let message: String?
}

extension ServiceUnavailableExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Tag: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key
        case value
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Tag: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Tag(key: \(String(describing: key)), value: \(String(describing: value)))"}
}

/// <p>Information about a tag.</p>
public struct Tag: Equatable {
    /// <p>The key of the tag.</p>
    public let key: String?
    /// <p>The value of the tag.</p>
    public let value: String?

    public init (
        key: String? = nil,
        value: String? = nil
    )
    {
        self.key = key
        self.value = value
    }
}

extension TagFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case tagKey
        case tagValues
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tagKey = tagKey {
            try encodeContainer.encode(tagKey, forKey: .tagKey)
        }
        if let tagValues = tagValues {
            var tagValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagValues)
            for tagvaluelist0 in tagValues {
                try tagValuesContainer.encode(tagvaluelist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tagKey)
        tagKey = tagKeyDecoded
        let tagValuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .tagValues)
        var tagValuesDecoded0:[String]? = nil
        if let tagValuesContainer = tagValuesContainer {
            tagValuesDecoded0 = [String]()
            for string0 in tagValuesContainer {
                if let string0 = string0 {
                    tagValuesDecoded0?.append(string0)
                }
            }
        }
        tagValues = tagValuesDecoded0
    }
}

extension TagFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagFilter(tagKey: \(String(describing: tagKey)), tagValues: \(String(describing: tagValues)))"}
}

/// <p>Used to filter information based on tags.</p>
public struct TagFilter: Equatable {
    /// <p>The tag key.</p>
    public let tagKey: String?
    /// <p>The tag values.</p>
    public let tagValues: [String]?

    public init (
        tagKey: String? = nil,
        tagValues: [String]? = nil
    )
    {
        self.tagKey = tagKey
        self.tagValues = tagValues
    }
}

extension TagLimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagLimitExceededException(message: \(String(describing: message)))"}
}

extension TagLimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: TagLimitExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The requested tags exceed the limit for your account.</p>
public struct TagLimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TagLimitExceededExceptionBody: Equatable {
    public let message: String?
}

extension TagLimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TagPolicyViolationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagPolicyViolationException(message: \(String(describing: message)))"}
}

extension TagPolicyViolationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: TagPolicyViolationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified tag is a reserved word and cannot be used.</p>
public struct TagPolicyViolationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TagPolicyViolationExceptionBody: Equatable {
    public let message: String?
}

extension TagPolicyViolationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct TagResourceInputBodyMiddleware: Middleware {
    public let id: String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

extension TagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceInput(resourceShareArn: \(String(describing: resourceShareArn)), tags: \(String(describing: tags)))"}
}

extension TagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceShareArn
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceShareArn = resourceShareArn {
            try encodeContainer.encode(resourceShareArn, forKey: .resourceShareArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the resource share.</p>
    public let resourceShareArn: String?
    /// <p>One or more tags.</p>
    public let tags: [Tag]?

    public init (
        resourceShareArn: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.resourceShareArn = resourceShareArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Equatable {
    public let resourceShareArn: String?
    public let tags: [Tag]?
}

extension TagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceShareArn
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceShareArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceShareArn)
        resourceShareArn = resourceShareArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MalformedArnException" : self = .malformedArnException(try MalformedArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceArnNotFoundException" : self = .resourceArnNotFoundException(try ResourceArnNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalException" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagLimitExceededException" : self = .tagLimitExceededException(try TagLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagPolicyViolationException" : self = .tagPolicyViolationException(try TagPolicyViolationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Equatable {
    case invalidParameterException(InvalidParameterException)
    case malformedArnException(MalformedArnException)
    case resourceArnNotFoundException(ResourceArnNotFoundException)
    case serverInternalException(ServerInternalException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tagLimitExceededException(TagLimitExceededException)
    case tagPolicyViolationException(TagPolicyViolationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Equatable {
}

extension TagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension UnknownResourceException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UnknownResourceException(message: \(String(describing: message)))"}
}

extension UnknownResourceException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UnknownResourceExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A specified resource was not found.</p>
public struct UnknownResourceException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct UnknownResourceExceptionBody: Equatable {
    public let message: String?
}

extension UnknownResourceExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct UntagResourceInputBodyMiddleware: Middleware {
    public let id: String = "UntagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

extension UntagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceInput(resourceShareArn: \(String(describing: resourceShareArn)), tagKeys: \(String(describing: tagKeys)))"}
}

extension UntagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceShareArn
        case tagKeys
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceShareArn = resourceShareArn {
            try encodeContainer.encode(resourceShareArn, forKey: .resourceShareArn)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkeylist0 in tagKeys {
                try tagKeysContainer.encode(tagkeylist0)
            }
        }
    }
}

public struct UntagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the resource share.</p>
    public let resourceShareArn: String?
    /// <p>The tag keys of the tags to remove.</p>
    public let tagKeys: [String]?

    public init (
        resourceShareArn: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.resourceShareArn = resourceShareArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Equatable {
    public let resourceShareArn: String?
    public let tagKeys: [String]?
}

extension UntagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceShareArn
        case tagKeys
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceShareArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceShareArn)
        resourceShareArn = resourceShareArnDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalException" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Equatable {
    case invalidParameterException(InvalidParameterException)
    case serverInternalException(ServerInternalException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Equatable {
}

extension UntagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateResourceShareInputBodyMiddleware: Middleware {
    public let id: String = "UpdateResourceShareInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateResourceShareInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateResourceShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateResourceShareInput>
    public typealias MOutput = OperationOutput<UpdateResourceShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateResourceShareOutputError>
}

extension UpdateResourceShareInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateResourceShareInput(allowExternalPrincipals: \(String(describing: allowExternalPrincipals)), clientToken: \(String(describing: clientToken)), name: \(String(describing: name)), resourceShareArn: \(String(describing: resourceShareArn)))"}
}

extension UpdateResourceShareInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case allowExternalPrincipals
        case clientToken
        case name
        case resourceShareArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowExternalPrincipals = allowExternalPrincipals {
            try encodeContainer.encode(allowExternalPrincipals, forKey: .allowExternalPrincipals)
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let resourceShareArn = resourceShareArn {
            try encodeContainer.encode(resourceShareArn, forKey: .resourceShareArn)
        }
    }
}

public struct UpdateResourceShareInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateResourceShareInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateResourceShareInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateResourceShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateResourceShareInput>
    public typealias MOutput = OperationOutput<UpdateResourceShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateResourceShareOutputError>
}

public struct UpdateResourceShareInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateResourceShareInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateResourceShareInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateResourceShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateResourceShareInput>
    public typealias MOutput = OperationOutput<UpdateResourceShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateResourceShareOutputError>
}

public struct UpdateResourceShareInput: Equatable {
    /// <p>Indicates whether principals outside your AWS organization can be associated with a resource share.</p>
    public let allowExternalPrincipals: Bool?
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.</p>
    public let clientToken: String?
    /// <p>The name of the resource share.</p>
    public let name: String?
    /// <p>The Amazon Resource Name (ARN) of the resource share.</p>
    public let resourceShareArn: String?

    public init (
        allowExternalPrincipals: Bool? = nil,
        clientToken: String? = nil,
        name: String? = nil,
        resourceShareArn: String? = nil
    )
    {
        self.allowExternalPrincipals = allowExternalPrincipals
        self.clientToken = clientToken
        self.name = name
        self.resourceShareArn = resourceShareArn
    }
}

struct UpdateResourceShareInputBody: Equatable {
    public let resourceShareArn: String?
    public let name: String?
    public let allowExternalPrincipals: Bool?
    public let clientToken: String?
}

extension UpdateResourceShareInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case allowExternalPrincipals
        case clientToken
        case name
        case resourceShareArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceShareArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceShareArn)
        resourceShareArn = resourceShareArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let allowExternalPrincipalsDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .allowExternalPrincipals)
        allowExternalPrincipals = allowExternalPrincipalsDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension UpdateResourceShareOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateResourceShareOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "IdempotentParameterMismatchException" : self = .idempotentParameterMismatchException(try IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClientTokenException" : self = .invalidClientTokenException(try InvalidClientTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MalformedArnException" : self = .malformedArnException(try MalformedArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingRequiredParameterException" : self = .missingRequiredParameterException(try MissingRequiredParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalException" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnknownResourceException" : self = .unknownResourceException(try UnknownResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateResourceShareOutputError: Swift.Error, Equatable {
    case idempotentParameterMismatchException(IdempotentParameterMismatchException)
    case invalidClientTokenException(InvalidClientTokenException)
    case invalidParameterException(InvalidParameterException)
    case malformedArnException(MalformedArnException)
    case missingRequiredParameterException(MissingRequiredParameterException)
    case operationNotPermittedException(OperationNotPermittedException)
    case serverInternalException(ServerInternalException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknownResourceException(UnknownResourceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateResourceShareOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateResourceShareOutputResponse(clientToken: \(String(describing: clientToken)), resourceShare: \(String(describing: resourceShare)))"}
}

extension UpdateResourceShareOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateResourceShareOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.clientToken = output.clientToken
            self.resourceShare = output.resourceShare
        } else {
            self.clientToken = nil
            self.resourceShare = nil
        }
    }
}

public struct UpdateResourceShareOutputResponse: Equatable {
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.</p>
    public let clientToken: String?
    /// <p>Information about the resource share.</p>
    public let resourceShare: ResourceShare?

    public init (
        clientToken: String? = nil,
        resourceShare: ResourceShare? = nil
    )
    {
        self.clientToken = clientToken
        self.resourceShare = resourceShare
    }
}

struct UpdateResourceShareOutputResponseBody: Equatable {
    public let resourceShare: ResourceShare?
    public let clientToken: String?
}

extension UpdateResourceShareOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientToken
        case resourceShare
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceShareDecoded = try containerValues.decodeIfPresent(ResourceShare.self, forKey: .resourceShare)
        resourceShare = resourceShareDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}
