// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccountActionRequiredException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccountActionRequiredException(message: \(String(describing: message)))"}
}

extension AccountActionRequiredException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AccountActionRequiredExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>
///             Account Action is required in order to continue the request.
///         </p>
public struct AccountActionRequiredException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>
    ///             The Exception Error Message.
    ///         </p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct AccountActionRequiredExceptionBody: Equatable {
    public let message: String?
}

extension AccountActionRequiredExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BadRequestException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BadRequestException(message: \(String(describing: message)))"}
}

extension BadRequestException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BadRequestExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>
///             The request cannot be processed because some parameter is not valid or the project
///             state prevents the operation from being performed.
///         </p>
public struct BadRequestException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>
    ///             The Exception Error Message.
    ///         </p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct BadRequestExceptionBody: Equatable {
    public let message: String?
}

extension BadRequestExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BundleDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case availablePlatforms
        case bundleId
        case description
        case iconUrl
        case title
        case version
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availablePlatforms = availablePlatforms {
            var availablePlatformsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .availablePlatforms)
            for platforms0 in availablePlatforms {
                try availablePlatformsContainer.encode(platforms0.rawValue)
            }
        }
        if let bundleId = bundleId {
            try encodeContainer.encode(bundleId, forKey: .bundleId)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let iconUrl = iconUrl {
            try encodeContainer.encode(iconUrl, forKey: .iconUrl)
        }
        if let title = title {
            try encodeContainer.encode(title, forKey: .title)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bundleIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bundleId)
        bundleId = bundleIdDecoded
        let titleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .title)
        title = titleDecoded
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let iconUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .iconUrl)
        iconUrl = iconUrlDecoded
        let availablePlatformsContainer = try containerValues.decodeIfPresent([Platform?].self, forKey: .availablePlatforms)
        var availablePlatformsDecoded0:[Platform]? = nil
        if let availablePlatformsContainer = availablePlatformsContainer {
            availablePlatformsDecoded0 = [Platform]()
            for string0 in availablePlatformsContainer {
                if let string0 = string0 {
                    availablePlatformsDecoded0?.append(string0)
                }
            }
        }
        availablePlatforms = availablePlatformsDecoded0
    }
}

extension BundleDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BundleDetails(availablePlatforms: \(String(describing: availablePlatforms)), bundleId: \(String(describing: bundleId)), description: \(String(describing: description)), iconUrl: \(String(describing: iconUrl)), title: \(String(describing: title)), version: \(String(describing: version)))"}
}

/// <p>
///             The details of the bundle.
///         </p>
public struct BundleDetails: Equatable {
    /// <p>
    ///             Developer desktop or mobile app or website platforms.
    ///         </p>
    public let availablePlatforms: [Platform]?
    /// <p>
    ///             Unique bundle identifier.
    ///         </p>
    public let bundleId: String?
    /// <p>
    ///             Description of the download bundle.
    ///         </p>
    public let description: String?
    /// <p>
    ///             Icon for the download bundle.
    ///         </p>
    public let iconUrl: String?
    /// <p>
    ///             Title of the download bundle.
    ///         </p>
    public let title: String?
    /// <p>
    ///             Version of the download bundle.
    ///         </p>
    public let version: String?

    public init (
        availablePlatforms: [Platform]? = nil,
        bundleId: String? = nil,
        description: String? = nil,
        iconUrl: String? = nil,
        title: String? = nil,
        version: String? = nil
    )
    {
        self.availablePlatforms = availablePlatforms
        self.bundleId = bundleId
        self.description = description
        self.iconUrl = iconUrl
        self.title = title
        self.version = version
    }
}

public struct CreateProjectInputBodyMiddleware: Middleware {
    public let id: String = "CreateProjectInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateProjectInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let contents = input.operationInput.contents {
            let data = contents
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateProjectInput>
    public typealias MOutput = OperationOutput<CreateProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateProjectOutputError>
}

extension CreateProjectInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateProjectInput(contents: \(String(describing: contents)), name: \(String(describing: name)), region: \(String(describing: region)), snapshotId: \(String(describing: snapshotId)))"}
}

extension CreateProjectInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case contents
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contents = contents {
            try encodeContainer.encode(contents.base64EncodedString(), forKey: .contents)
        }
    }
}

public struct CreateProjectInputHeadersMiddleware: Middleware {
    public let id: String = "CreateProjectInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateProjectInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateProjectInput>
    public typealias MOutput = OperationOutput<CreateProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateProjectOutputError>
}

public struct CreateProjectInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateProjectInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateProjectInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let snapshotId = input.operationInput.snapshotId {
            let snapshotIdQueryItem = URLQueryItem(name: "snapshotId".urlPercentEncoding(), value: String(snapshotId).urlPercentEncoding())
            input.builder.withQueryItem(snapshotIdQueryItem)
        }
        if let name = input.operationInput.name {
            let nameQueryItem = URLQueryItem(name: "name".urlPercentEncoding(), value: String(name).urlPercentEncoding())
            input.builder.withQueryItem(nameQueryItem)
        }
        if let region = input.operationInput.region {
            let regionQueryItem = URLQueryItem(name: "region".urlPercentEncoding(), value: String(region).urlPercentEncoding())
            input.builder.withQueryItem(regionQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateProjectInput>
    public typealias MOutput = OperationOutput<CreateProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateProjectOutputError>
}

/// <p>
///             Request structure used to request a project be created.
///         </p>
public struct CreateProjectInput: Equatable {
    /// <p>
    ///             ZIP or YAML file which contains configuration settings to be used when creating
    ///             the project. This may be the contents of the file downloaded from the URL provided
    ///             in an export project operation.
    ///         </p>
    public let contents: Data?
    /// <p>
    ///             Name of the project.
    ///         </p>
    public let name: String?
    /// <p>
    ///             Default region where project resources should be created.
    ///         </p>
    public let region: String?
    /// <p>
    ///             Unique identifier for an exported snapshot of project configuration. This
    ///             snapshot identifier is included in the share URL when a project is exported.
    ///         </p>
    public let snapshotId: String?

    public init (
        contents: Data? = nil,
        name: String? = nil,
        region: String? = nil,
        snapshotId: String? = nil
    )
    {
        self.contents = contents
        self.name = name
        self.region = region
        self.snapshotId = snapshotId
    }
}

struct CreateProjectInputBody: Equatable {
    public let contents: Data?
}

extension CreateProjectInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case contents
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentsDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .contents)
        contents = contentsDecoded
    }
}

extension CreateProjectOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateProjectOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateProjectOutputError: Equatable {
    case badRequestException(BadRequestException)
    case internalFailureException(InternalFailureException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateProjectOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateProjectOutputResponse(details: \(String(describing: details)))"}
}

extension CreateProjectOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateProjectOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.details = output.details
        } else {
            self.details = nil
        }
    }
}

/// <p>
///             Result structure used in response to a request to create a project.
///         </p>
public struct CreateProjectOutputResponse: Equatable {
    /// <p>
    ///             Detailed information about the created AWS Mobile Hub project.
    ///         </p>
    public let details: ProjectDetails?

    public init (
        details: ProjectDetails? = nil
    )
    {
        self.details = details
    }
}

struct CreateProjectOutputResponseBody: Equatable {
    public let details: ProjectDetails?
}

extension CreateProjectOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case details
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detailsDecoded = try containerValues.decodeIfPresent(ProjectDetails.self, forKey: .details)
        details = detailsDecoded
    }
}

extension DeleteProjectInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteProjectInput(projectId: \(String(describing: projectId)))"}
}

extension DeleteProjectInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteProjectInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteProjectInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteProjectInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteProjectInput>
    public typealias MOutput = OperationOutput<DeleteProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteProjectOutputError>
}

public struct DeleteProjectInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteProjectInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteProjectInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteProjectInput>
    public typealias MOutput = OperationOutput<DeleteProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteProjectOutputError>
}

/// <p>
///             Request structure used to request a project be deleted.
///         </p>
public struct DeleteProjectInput: Equatable {
    /// <p>
    ///             Unique project identifier.
    ///         </p>
    public let projectId: String?

    public init (
        projectId: String? = nil
    )
    {
        self.projectId = projectId
    }
}

struct DeleteProjectInputBody: Equatable {
}

extension DeleteProjectInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteProjectOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteProjectOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteProjectOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteProjectOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteProjectOutputResponse(deletedResources: \(String(describing: deletedResources)), orphanedResources: \(String(describing: orphanedResources)))"}
}

extension DeleteProjectOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteProjectOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.deletedResources = output.deletedResources
            self.orphanedResources = output.orphanedResources
        } else {
            self.deletedResources = nil
            self.orphanedResources = nil
        }
    }
}

/// <p>
///             Result structure used in response to request to delete a project.
///         </p>
public struct DeleteProjectOutputResponse: Equatable {
    /// <p>
    ///             Resources which were deleted.
    ///         </p>
    public let deletedResources: [Resource]?
    /// <p>
    ///             Resources which were not deleted, due to a risk of losing potentially
    ///             important data or files.
    ///         </p>
    public let orphanedResources: [Resource]?

    public init (
        deletedResources: [Resource]? = nil,
        orphanedResources: [Resource]? = nil
    )
    {
        self.deletedResources = deletedResources
        self.orphanedResources = orphanedResources
    }
}

struct DeleteProjectOutputResponseBody: Equatable {
    public let deletedResources: [Resource]?
    public let orphanedResources: [Resource]?
}

extension DeleteProjectOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case deletedResources
        case orphanedResources
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deletedResourcesContainer = try containerValues.decodeIfPresent([Resource?].self, forKey: .deletedResources)
        var deletedResourcesDecoded0:[Resource]? = nil
        if let deletedResourcesContainer = deletedResourcesContainer {
            deletedResourcesDecoded0 = [Resource]()
            for structure0 in deletedResourcesContainer {
                if let structure0 = structure0 {
                    deletedResourcesDecoded0?.append(structure0)
                }
            }
        }
        deletedResources = deletedResourcesDecoded0
        let orphanedResourcesContainer = try containerValues.decodeIfPresent([Resource?].self, forKey: .orphanedResources)
        var orphanedResourcesDecoded0:[Resource]? = nil
        if let orphanedResourcesContainer = orphanedResourcesContainer {
            orphanedResourcesDecoded0 = [Resource]()
            for structure0 in orphanedResourcesContainer {
                if let structure0 = structure0 {
                    orphanedResourcesDecoded0?.append(structure0)
                }
            }
        }
        orphanedResources = orphanedResourcesDecoded0
    }
}

extension DescribeBundleInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeBundleInput(bundleId: \(String(describing: bundleId)))"}
}

extension DescribeBundleInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeBundleInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeBundleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeBundleInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeBundleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeBundleInput>
    public typealias MOutput = OperationOutput<DescribeBundleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeBundleOutputError>
}

public struct DescribeBundleInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeBundleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeBundleInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeBundleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeBundleInput>
    public typealias MOutput = OperationOutput<DescribeBundleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeBundleOutputError>
}

/// <p>
///             Request structure to request the details of a specific bundle.
///         </p>
public struct DescribeBundleInput: Equatable {
    /// <p>
    ///             Unique bundle identifier.
    ///         </p>
    public let bundleId: String?

    public init (
        bundleId: String? = nil
    )
    {
        self.bundleId = bundleId
    }
}

struct DescribeBundleInputBody: Equatable {
}

extension DescribeBundleInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeBundleOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeBundleOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeBundleOutputError: Equatable {
    case badRequestException(BadRequestException)
    case internalFailureException(InternalFailureException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeBundleOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeBundleOutputResponse(details: \(String(describing: details)))"}
}

extension DescribeBundleOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeBundleOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.details = output.details
        } else {
            self.details = nil
        }
    }
}

/// <p>
///             Result structure contains the details of the bundle.
///         </p>
public struct DescribeBundleOutputResponse: Equatable {
    /// <p>
    ///             The details of the bundle.
    ///         </p>
    public let details: BundleDetails?

    public init (
        details: BundleDetails? = nil
    )
    {
        self.details = details
    }
}

struct DescribeBundleOutputResponseBody: Equatable {
    public let details: BundleDetails?
}

extension DescribeBundleOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case details
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detailsDecoded = try containerValues.decodeIfPresent(BundleDetails.self, forKey: .details)
        details = detailsDecoded
    }
}

extension DescribeProjectInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeProjectInput(projectId: \(String(describing: projectId)), syncFromResources: \(String(describing: syncFromResources)))"}
}

extension DescribeProjectInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeProjectInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeProjectInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeProjectInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeProjectInput>
    public typealias MOutput = OperationOutput<DescribeProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeProjectOutputError>
}

public struct DescribeProjectInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeProjectInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeProjectInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let syncFromResourcesQueryItem = URLQueryItem(name: "syncFromResources".urlPercentEncoding(), value: String(input.operationInput.syncFromResources).urlPercentEncoding())
        input.builder.withQueryItem(syncFromResourcesQueryItem)
        if let projectId = input.operationInput.projectId {
            let projectIdQueryItem = URLQueryItem(name: "projectId".urlPercentEncoding(), value: String(projectId).urlPercentEncoding())
            input.builder.withQueryItem(projectIdQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeProjectInput>
    public typealias MOutput = OperationOutput<DescribeProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeProjectOutputError>
}

/// <p>
///             Request structure used to request details about a project.
///         </p>
public struct DescribeProjectInput: Equatable {
    /// <p>
    ///             Unique project identifier.
    ///         </p>
    public let projectId: String?
    /// <p>
    ///             If set to true, causes AWS Mobile Hub to synchronize information from other services, e.g., update state of AWS CloudFormation stacks in the AWS Mobile Hub project.
    ///         </p>
    public let syncFromResources: Bool

    public init (
        projectId: String? = nil,
        syncFromResources: Bool = false
    )
    {
        self.projectId = projectId
        self.syncFromResources = syncFromResources
    }
}

struct DescribeProjectInputBody: Equatable {
}

extension DescribeProjectInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeProjectOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeProjectOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeProjectOutputError: Equatable {
    case badRequestException(BadRequestException)
    case internalFailureException(InternalFailureException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeProjectOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeProjectOutputResponse(details: \(String(describing: details)))"}
}

extension DescribeProjectOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeProjectOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.details = output.details
        } else {
            self.details = nil
        }
    }
}

/// <p>
///             Result structure used for requests of project details.
///         </p>
public struct DescribeProjectOutputResponse: Equatable {
    /// <p>
    ///             Detailed information about an AWS Mobile Hub project.
    ///         </p>
    public let details: ProjectDetails?

    public init (
        details: ProjectDetails? = nil
    )
    {
        self.details = details
    }
}

struct DescribeProjectOutputResponseBody: Equatable {
    public let details: ProjectDetails?
}

extension DescribeProjectOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case details
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detailsDecoded = try containerValues.decodeIfPresent(ProjectDetails.self, forKey: .details)
        details = detailsDecoded
    }
}

extension ExportBundleInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ExportBundleInput(bundleId: \(String(describing: bundleId)), platform: \(String(describing: platform)), projectId: \(String(describing: projectId)))"}
}

extension ExportBundleInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ExportBundleInputHeadersMiddleware: Middleware {
    public let id: String = "ExportBundleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ExportBundleInput>,
                  next: H) -> Swift.Result<OperationOutput<ExportBundleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ExportBundleInput>
    public typealias MOutput = OperationOutput<ExportBundleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ExportBundleOutputError>
}

public struct ExportBundleInputQueryItemMiddleware: Middleware {
    public let id: String = "ExportBundleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ExportBundleInput>,
                  next: H) -> Swift.Result<OperationOutput<ExportBundleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let projectId = input.operationInput.projectId {
            let projectIdQueryItem = URLQueryItem(name: "projectId".urlPercentEncoding(), value: String(projectId).urlPercentEncoding())
            input.builder.withQueryItem(projectIdQueryItem)
        }
        if let platform = input.operationInput.platform {
            let platformQueryItem = URLQueryItem(name: "platform".urlPercentEncoding(), value: String(platform.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(platformQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ExportBundleInput>
    public typealias MOutput = OperationOutput<ExportBundleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ExportBundleOutputError>
}

/// <p>
///             Request structure used to request generation of custom SDK and tool packages
///             required to integrate mobile web or app clients with backed AWS resources.
///         </p>
public struct ExportBundleInput: Equatable {
    /// <p>
    ///             Unique bundle identifier.
    ///         </p>
    public let bundleId: String?
    /// <p>
    ///             Developer desktop or target application platform.
    ///         </p>
    public let platform: Platform?
    /// <p>
    ///             Unique project identifier.
    ///         </p>
    public let projectId: String?

    public init (
        bundleId: String? = nil,
        platform: Platform? = nil,
        projectId: String? = nil
    )
    {
        self.bundleId = bundleId
        self.platform = platform
        self.projectId = projectId
    }
}

struct ExportBundleInputBody: Equatable {
}

extension ExportBundleInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ExportBundleOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ExportBundleOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ExportBundleOutputError: Equatable {
    case badRequestException(BadRequestException)
    case internalFailureException(InternalFailureException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ExportBundleOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ExportBundleOutputResponse(downloadUrl: \(String(describing: downloadUrl)))"}
}

extension ExportBundleOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ExportBundleOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.downloadUrl = output.downloadUrl
        } else {
            self.downloadUrl = nil
        }
    }
}

/// <p>
///             Result structure which contains link to download custom-generated SDK and
///             tool packages used to integrate mobile web or app clients with backed
///             AWS resources.
///         </p>
public struct ExportBundleOutputResponse: Equatable {
    /// <p>
    ///             URL which contains the custom-generated SDK and tool packages used
    ///             to integrate the client mobile app or web app with the AWS resources
    ///             created by the AWS Mobile Hub project.
    ///         </p>
    public let downloadUrl: String?

    public init (
        downloadUrl: String? = nil
    )
    {
        self.downloadUrl = downloadUrl
    }
}

struct ExportBundleOutputResponseBody: Equatable {
    public let downloadUrl: String?
}

extension ExportBundleOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case downloadUrl
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let downloadUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .downloadUrl)
        downloadUrl = downloadUrlDecoded
    }
}

extension ExportProjectInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ExportProjectInput(projectId: \(String(describing: projectId)))"}
}

extension ExportProjectInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ExportProjectInputHeadersMiddleware: Middleware {
    public let id: String = "ExportProjectInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ExportProjectInput>,
                  next: H) -> Swift.Result<OperationOutput<ExportProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ExportProjectInput>
    public typealias MOutput = OperationOutput<ExportProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ExportProjectOutputError>
}

public struct ExportProjectInputQueryItemMiddleware: Middleware {
    public let id: String = "ExportProjectInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ExportProjectInput>,
                  next: H) -> Swift.Result<OperationOutput<ExportProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ExportProjectInput>
    public typealias MOutput = OperationOutput<ExportProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ExportProjectOutputError>
}

/// <p>
///             Request structure used in requests to export project configuration details.
///         </p>
public struct ExportProjectInput: Equatable {
    /// <p>
    ///             Unique project identifier.
    ///         </p>
    public let projectId: String?

    public init (
        projectId: String? = nil
    )
    {
        self.projectId = projectId
    }
}

struct ExportProjectInputBody: Equatable {
}

extension ExportProjectInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ExportProjectOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ExportProjectOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ExportProjectOutputError: Equatable {
    case badRequestException(BadRequestException)
    case internalFailureException(InternalFailureException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ExportProjectOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ExportProjectOutputResponse(downloadUrl: \(String(describing: downloadUrl)), shareUrl: \(String(describing: shareUrl)), snapshotId: \(String(describing: snapshotId)))"}
}

extension ExportProjectOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ExportProjectOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.downloadUrl = output.downloadUrl
            self.shareUrl = output.shareUrl
            self.snapshotId = output.snapshotId
        } else {
            self.downloadUrl = nil
            self.shareUrl = nil
            self.snapshotId = nil
        }
    }
}

/// <p>
///             Result structure used for requests to export project configuration details.
///         </p>
public struct ExportProjectOutputResponse: Equatable {
    /// <p>
    ///             URL which can be used to download the exported project configuation file(s).
    ///         </p>
    public let downloadUrl: String?
    /// <p>
    ///             URL which can be shared to allow other AWS users to create their own project
    ///             in AWS Mobile Hub with the same configuration as the specified project. This
    ///             URL pertains to a snapshot in time of the project configuration that is created
    ///             when this API is called. If you want to share additional changes to your project
    ///             configuration, then you will need to create and share a new snapshot by calling
    ///             this method again.
    ///         </p>
    public let shareUrl: String?
    /// <p>
    ///             Unique identifier for the exported snapshot of the project configuration. This
    ///             snapshot identifier is included in the share URL.
    ///         </p>
    public let snapshotId: String?

    public init (
        downloadUrl: String? = nil,
        shareUrl: String? = nil,
        snapshotId: String? = nil
    )
    {
        self.downloadUrl = downloadUrl
        self.shareUrl = shareUrl
        self.snapshotId = snapshotId
    }
}

struct ExportProjectOutputResponseBody: Equatable {
    public let downloadUrl: String?
    public let shareUrl: String?
    public let snapshotId: String?
}

extension ExportProjectOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case downloadUrl
        case shareUrl
        case snapshotId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let downloadUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .downloadUrl)
        downloadUrl = downloadUrlDecoded
        let shareUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .shareUrl)
        shareUrl = shareUrlDecoded
        let snapshotIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .snapshotId)
        snapshotId = snapshotIdDecoded
    }
}

extension InternalFailureException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalFailureException(message: \(String(describing: message)))"}
}

extension InternalFailureException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InternalFailureExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>
///             The service has encountered an unexpected error condition which prevents it from
///             servicing the request.
///         </p>
public struct InternalFailureException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    /// <p>
    ///             The Exception Error Message.
    ///         </p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InternalFailureExceptionBody: Equatable {
    public let message: String?
}

extension InternalFailureExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LimitExceededException(message: \(String(describing: message)), retryAfterSeconds: \(String(describing: retryAfterSeconds)))"}
}

extension LimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.retryAfterSeconds = retryAfterSecondsHeaderValue
        } else {
            self.retryAfterSeconds = nil
        }
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>
///             There are too many AWS Mobile Hub projects in the account or the account has
///             exceeded the maximum number of resources in some AWS service. You should create
///             another sub-account using AWS Organizations or remove some resources and retry
///             your request.
///         </p>
public struct LimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>
    ///             The Exception Error Message.
    ///         </p>
    public var message: String?
    /// <p>
    ///             The Exception Error Message.
    ///         </p>
    public var retryAfterSeconds: String?

    public init (
        message: String? = nil,
        retryAfterSeconds: String? = nil
    )
    {
        self.message = message
        self.retryAfterSeconds = retryAfterSeconds
    }
}

struct LimitExceededExceptionBody: Equatable {
    public let message: String?
}

extension LimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListBundlesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListBundlesInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListBundlesInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListBundlesInputHeadersMiddleware: Middleware {
    public let id: String = "ListBundlesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListBundlesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListBundlesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListBundlesInput>
    public typealias MOutput = OperationOutput<ListBundlesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListBundlesOutputError>
}

public struct ListBundlesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListBundlesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListBundlesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListBundlesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
        input.builder.withQueryItem(maxResultsQueryItem)
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListBundlesInput>
    public typealias MOutput = OperationOutput<ListBundlesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListBundlesOutputError>
}

/// <p>
///             Request structure to request all available bundles.
///         </p>
public struct ListBundlesInput: Equatable {
    /// <p>
    ///             Maximum number of records to list in a single response.
    ///         </p>
    public let maxResults: Int
    /// <p>
    ///             Pagination token. Set to null to start listing bundles from start.
    ///             If non-null pagination token is returned in a result, then pass its
    ///             value in here in another request to list more bundles.
    ///         </p>
    public let nextToken: String?

    public init (
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListBundlesInputBody: Equatable {
}

extension ListBundlesInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListBundlesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListBundlesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListBundlesOutputError: Equatable {
    case badRequestException(BadRequestException)
    case internalFailureException(InternalFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListBundlesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListBundlesOutputResponse(bundleList: \(String(describing: bundleList)), nextToken: \(String(describing: nextToken)))"}
}

extension ListBundlesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListBundlesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.bundleList = output.bundleList
            self.nextToken = output.nextToken
        } else {
            self.bundleList = nil
            self.nextToken = nil
        }
    }
}

/// <p>
///             Result structure contains a list of all available bundles with details.
///         </p>
public struct ListBundlesOutputResponse: Equatable {
    /// <p>
    ///             A list of bundles.
    ///         </p>
    public let bundleList: [BundleDetails]?
    /// <p>
    ///             Pagination token. If non-null pagination token is returned in a result,
    ///             then pass its value in another request to fetch more entries.
    ///         </p>
    public let nextToken: String?

    public init (
        bundleList: [BundleDetails]? = nil,
        nextToken: String? = nil
    )
    {
        self.bundleList = bundleList
        self.nextToken = nextToken
    }
}

struct ListBundlesOutputResponseBody: Equatable {
    public let bundleList: [BundleDetails]?
    public let nextToken: String?
}

extension ListBundlesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case bundleList
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bundleListContainer = try containerValues.decodeIfPresent([BundleDetails?].self, forKey: .bundleList)
        var bundleListDecoded0:[BundleDetails]? = nil
        if let bundleListContainer = bundleListContainer {
            bundleListDecoded0 = [BundleDetails]()
            for structure0 in bundleListContainer {
                if let structure0 = structure0 {
                    bundleListDecoded0?.append(structure0)
                }
            }
        }
        bundleList = bundleListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListProjectsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListProjectsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListProjectsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListProjectsInputHeadersMiddleware: Middleware {
    public let id: String = "ListProjectsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListProjectsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListProjectsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListProjectsInput>
    public typealias MOutput = OperationOutput<ListProjectsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListProjectsOutputError>
}

public struct ListProjectsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListProjectsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListProjectsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListProjectsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
        input.builder.withQueryItem(maxResultsQueryItem)
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListProjectsInput>
    public typealias MOutput = OperationOutput<ListProjectsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListProjectsOutputError>
}

/// <p>
///             Request structure used to request projects list in AWS Mobile Hub.
///         </p>
public struct ListProjectsInput: Equatable {
    /// <p>
    ///             Maximum number of records to list in a single response.
    ///         </p>
    public let maxResults: Int
    /// <p>
    ///             Pagination token. Set to null to start listing projects from start.
    ///             If non-null pagination token is returned in a result, then pass its
    ///             value in here in another request to list more projects.
    ///         </p>
    public let nextToken: String?

    public init (
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListProjectsInputBody: Equatable {
}

extension ListProjectsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListProjectsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListProjectsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListProjectsOutputError: Equatable {
    case badRequestException(BadRequestException)
    case internalFailureException(InternalFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListProjectsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListProjectsOutputResponse(nextToken: \(String(describing: nextToken)), projects: \(String(describing: projects)))"}
}

extension ListProjectsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListProjectsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.projects = output.projects
        } else {
            self.nextToken = nil
            self.projects = nil
        }
    }
}

/// <p>
///             Result structure used for requests to list projects in AWS Mobile Hub.
///         </p>
public struct ListProjectsOutputResponse: Equatable {
    /// <p>
    ///             Pagination token. Set to null to start listing records from start.
    ///             If non-null pagination token is returned in a result, then pass its
    ///             value in here in another request to list more entries.
    ///         </p>
    public let nextToken: String?
    /// <p>
    ///             List of projects.
    ///         </p>
    public let projects: [ProjectSummary]?

    public init (
        nextToken: String? = nil,
        projects: [ProjectSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.projects = projects
    }
}

struct ListProjectsOutputResponseBody: Equatable {
    public let projects: [ProjectSummary]?
    public let nextToken: String?
}

extension ListProjectsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case projects
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectsContainer = try containerValues.decodeIfPresent([ProjectSummary?].self, forKey: .projects)
        var projectsDecoded0:[ProjectSummary]? = nil
        if let projectsContainer = projectsContainer {
            projectsDecoded0 = [ProjectSummary]()
            for structure0 in projectsContainer {
                if let structure0 = structure0 {
                    projectsDecoded0?.append(structure0)
                }
            }
        }
        projects = projectsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension NotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NotFoundException(message: \(String(describing: message)))"}
}

extension NotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: NotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>
///             No entity can be found with the specified identifier.
///         </p>
public struct NotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>
    ///             The Exception Error Message.
    ///         </p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct NotFoundExceptionBody: Equatable {
    public let message: String?
}

extension NotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

/// <p>
///             Developer desktop or target mobile app or website platform.
///         </p>
public enum Platform {
    case android
    case javascript
    case linux
    case objc
    case osx
    case swift
    case windows
    case sdkUnknown(String)
}

extension Platform : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Platform] {
        return [
            .android,
            .javascript,
            .linux,
            .objc,
            .osx,
            .swift,
            .windows,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .android: return "ANDROID"
        case .javascript: return "JAVASCRIPT"
        case .linux: return "LINUX"
        case .objc: return "OBJC"
        case .osx: return "OSX"
        case .swift: return "SWIFT"
        case .windows: return "WINDOWS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Platform(rawValue: rawValue) ?? Platform.sdkUnknown(rawValue)
    }
}

extension ProjectDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case consoleUrl
        case createdDate
        case lastUpdatedDate
        case name
        case projectId
        case region
        case resources
        case state
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let consoleUrl = consoleUrl {
            try encodeContainer.encode(consoleUrl, forKey: .consoleUrl)
        }
        if let createdDate = createdDate {
            try encodeContainer.encode(createdDate.timeIntervalSince1970, forKey: .createdDate)
        }
        if let lastUpdatedDate = lastUpdatedDate {
            try encodeContainer.encode(lastUpdatedDate.timeIntervalSince1970, forKey: .lastUpdatedDate)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let projectId = projectId {
            try encodeContainer.encode(projectId, forKey: .projectId)
        }
        if let region = region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let resources = resources {
            var resourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resources)
            for resources0 in resources {
                try resourcesContainer.encode(resources0)
            }
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let projectIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .projectId)
        projectId = projectIdDecoded
        let regionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .region)
        region = regionDecoded
        let stateDecoded = try containerValues.decodeIfPresent(ProjectState.self, forKey: .state)
        state = stateDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let lastUpdatedDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedDate)
        lastUpdatedDate = lastUpdatedDateDecoded
        let consoleUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .consoleUrl)
        consoleUrl = consoleUrlDecoded
        let resourcesContainer = try containerValues.decodeIfPresent([Resource?].self, forKey: .resources)
        var resourcesDecoded0:[Resource]? = nil
        if let resourcesContainer = resourcesContainer {
            resourcesDecoded0 = [Resource]()
            for structure0 in resourcesContainer {
                if let structure0 = structure0 {
                    resourcesDecoded0?.append(structure0)
                }
            }
        }
        resources = resourcesDecoded0
    }
}

extension ProjectDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ProjectDetails(consoleUrl: \(String(describing: consoleUrl)), createdDate: \(String(describing: createdDate)), lastUpdatedDate: \(String(describing: lastUpdatedDate)), name: \(String(describing: name)), projectId: \(String(describing: projectId)), region: \(String(describing: region)), resources: \(String(describing: resources)), state: \(String(describing: state)))"}
}

/// <p>
///             Detailed information about an AWS Mobile Hub project.
///         </p>
public struct ProjectDetails: Equatable {
    /// <p>
    ///             Website URL for this project in the AWS Mobile Hub console.
    ///         </p>
    public let consoleUrl: String?
    /// <p>
    ///             Date the project was created.
    ///         </p>
    public let createdDate: Date?
    /// <p>
    ///             Date of the last modification of the project.
    ///         </p>
    public let lastUpdatedDate: Date?
    /// <p>
    ///             Name of the project.
    ///         </p>
    public let name: String?
    /// <p>
    ///             Unique project identifier.
    ///         </p>
    public let projectId: String?
    /// <p>
    ///             Default region to use for AWS resource creation in the AWS Mobile Hub project.
    ///         </p>
    public let region: String?
    /// <p>
    ///             List of AWS resources associated with a project.
    ///         </p>
    public let resources: [Resource]?
    /// <p>
    ///             Synchronization state for a project.
    ///         </p>
    public let state: ProjectState?

    public init (
        consoleUrl: String? = nil,
        createdDate: Date? = nil,
        lastUpdatedDate: Date? = nil,
        name: String? = nil,
        projectId: String? = nil,
        region: String? = nil,
        resources: [Resource]? = nil,
        state: ProjectState? = nil
    )
    {
        self.consoleUrl = consoleUrl
        self.createdDate = createdDate
        self.lastUpdatedDate = lastUpdatedDate
        self.name = name
        self.projectId = projectId
        self.region = region
        self.resources = resources
        self.state = state
    }
}

/// <p>
///             Synchronization state for a project.
///         </p>
public enum ProjectState {
    case importing
    case normal
    case syncing
    case sdkUnknown(String)
}

extension ProjectState : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ProjectState] {
        return [
            .importing,
            .normal,
            .syncing,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .importing: return "IMPORTING"
        case .normal: return "NORMAL"
        case .syncing: return "SYNCING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ProjectState(rawValue: rawValue) ?? ProjectState.sdkUnknown(rawValue)
    }
}

extension ProjectSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name
        case projectId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let projectId = projectId {
            try encodeContainer.encode(projectId, forKey: .projectId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let projectIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .projectId)
        projectId = projectIdDecoded
    }
}

extension ProjectSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ProjectSummary(name: \(String(describing: name)), projectId: \(String(describing: projectId)))"}
}

/// <p>
///             Summary information about an AWS Mobile Hub project.
///         </p>
public struct ProjectSummary: Equatable {
    /// <p>
    ///             Name of the project.
    ///         </p>
    public let name: String?
    /// <p>
    ///             Unique project identifier.
    ///         </p>
    public let projectId: String?

    public init (
        name: String? = nil,
        projectId: String? = nil
    )
    {
        self.name = name
        self.projectId = projectId
    }
}

extension Resource: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case attributes
        case feature
        case name
        case type
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .attributes)
            for (dictKey0, attributes0) in attributes {
                try attributesContainer.encode(attributes0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let feature = feature {
            try encodeContainer.encode(feature, forKey: .feature)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let featureDecoded = try containerValues.decodeIfPresent(String.self, forKey: .feature)
        feature = featureDecoded
        let attributesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .attributes)
        var attributesDecoded0: [String:String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [String:String]()
            for (key0, attributevalue0) in attributesContainer {
                if let attributevalue0 = attributevalue0 {
                    attributesDecoded0?[key0] = attributevalue0
                }
            }
        }
        attributes = attributesDecoded0
    }
}

extension Resource: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Resource(arn: \(String(describing: arn)), attributes: \(String(describing: attributes)), feature: \(String(describing: feature)), name: \(String(describing: name)), type: \(String(describing: type)))"}
}

/// <p>
///             Information about an instance of an AWS resource associated with a project.
///         </p>
public struct Resource: Equatable {
    /// <p>
    ///             AWS resource name which uniquely identifies the resource in AWS systems.
    ///         </p>
    public let arn: String?
    /// <p>
    ///             Key-value attribute pairs.
    ///         </p>
    public let attributes: [String:String]?
    /// <p>
    ///             Identifies which feature in AWS Mobile Hub is associated with this AWS resource.
    ///         </p>
    public let feature: String?
    /// <p>
    ///             Name of the AWS resource (e.g., for an Amazon S3 bucket this is the name of the bucket).
    ///         </p>
    public let name: String?
    /// <p>
    ///             Simplified name for type of AWS resource (e.g., bucket is an Amazon S3 bucket).
    ///         </p>
    public let type: String?

    public init (
        arn: String? = nil,
        attributes: [String:String]? = nil,
        feature: String? = nil,
        name: String? = nil,
        type: String? = nil
    )
    {
        self.arn = arn
        self.attributes = attributes
        self.feature = feature
        self.name = name
        self.type = type
    }
}

extension ServiceUnavailableException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceUnavailableException(message: \(String(describing: message)), retryAfterSeconds: \(String(describing: retryAfterSeconds)))"}
}

extension ServiceUnavailableException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.retryAfterSeconds = retryAfterSecondsHeaderValue
        } else {
            self.retryAfterSeconds = nil
        }
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ServiceUnavailableExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>
///             The service is temporarily unavailable. The request should be retried after some
///             time delay.
///         </p>
public struct ServiceUnavailableException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    /// <p>
    ///             The Exception Error Message.
    ///         </p>
    public var message: String?
    /// <p>
    ///             The Exception Error Message.
    ///         </p>
    public var retryAfterSeconds: String?

    public init (
        message: String? = nil,
        retryAfterSeconds: String? = nil
    )
    {
        self.message = message
        self.retryAfterSeconds = retryAfterSeconds
    }
}

struct ServiceUnavailableExceptionBody: Equatable {
    public let message: String?
}

extension ServiceUnavailableExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyRequestsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TooManyRequestsException(message: \(String(describing: message)), retryAfterSeconds: \(String(describing: retryAfterSeconds)))"}
}

extension TooManyRequestsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.retryAfterSeconds = retryAfterSecondsHeaderValue
        } else {
            self.retryAfterSeconds = nil
        }
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: TooManyRequestsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>
///             Too many requests have been received for this AWS account in too short a time. The
///             request should be retried after some time delay.
///         </p>
public struct TooManyRequestsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>
    ///             The Exception Error Message.
    ///         </p>
    public var message: String?
    /// <p>
    ///             The Exception Error Message.
    ///         </p>
    public var retryAfterSeconds: String?

    public init (
        message: String? = nil,
        retryAfterSeconds: String? = nil
    )
    {
        self.message = message
        self.retryAfterSeconds = retryAfterSeconds
    }
}

struct TooManyRequestsExceptionBody: Equatable {
    public let message: String?
}

extension TooManyRequestsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UnauthorizedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UnauthorizedException(message: \(String(describing: message)))"}
}

extension UnauthorizedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UnauthorizedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>
///             Credentials of the caller are insufficient to authorize the request.
///         </p>
public struct UnauthorizedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>
    ///             The Exception Error Message.
    ///         </p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct UnauthorizedExceptionBody: Equatable {
    public let message: String?
}

extension UnauthorizedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct UpdateProjectInputBodyMiddleware: Middleware {
    public let id: String = "UpdateProjectInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateProjectInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let contents = input.operationInput.contents {
            let data = contents
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateProjectInput>
    public typealias MOutput = OperationOutput<UpdateProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateProjectOutputError>
}

extension UpdateProjectInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateProjectInput(contents: \(String(describing: contents)), projectId: \(String(describing: projectId)))"}
}

extension UpdateProjectInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case contents
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contents = contents {
            try encodeContainer.encode(contents.base64EncodedString(), forKey: .contents)
        }
    }
}

public struct UpdateProjectInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateProjectInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateProjectInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateProjectInput>
    public typealias MOutput = OperationOutput<UpdateProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateProjectOutputError>
}

public struct UpdateProjectInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateProjectInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateProjectInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let projectId = input.operationInput.projectId {
            let projectIdQueryItem = URLQueryItem(name: "projectId".urlPercentEncoding(), value: String(projectId).urlPercentEncoding())
            input.builder.withQueryItem(projectIdQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateProjectInput>
    public typealias MOutput = OperationOutput<UpdateProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateProjectOutputError>
}

/// <p>
///             Request structure used for requests to update project configuration.
///         </p>
public struct UpdateProjectInput: Equatable {
    /// <p>
    ///             ZIP or YAML file which contains project configuration to be updated. This should
    ///             be the contents of the file downloaded from the URL provided in an export project
    ///             operation.
    ///         </p>
    public let contents: Data?
    /// <p>
    ///             Unique project identifier.
    ///         </p>
    public let projectId: String?

    public init (
        contents: Data? = nil,
        projectId: String? = nil
    )
    {
        self.contents = contents
        self.projectId = projectId
    }
}

struct UpdateProjectInputBody: Equatable {
    public let contents: Data?
}

extension UpdateProjectInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case contents
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentsDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .contents)
        contents = contentsDecoded
    }
}

extension UpdateProjectOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateProjectOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccountActionRequiredException" : self = .accountActionRequiredException(try AccountActionRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateProjectOutputError: Equatable {
    case accountActionRequiredException(AccountActionRequiredException)
    case badRequestException(BadRequestException)
    case internalFailureException(InternalFailureException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateProjectOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateProjectOutputResponse(details: \(String(describing: details)))"}
}

extension UpdateProjectOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateProjectOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.details = output.details
        } else {
            self.details = nil
        }
    }
}

/// <p>
///             Result structure used for requests to updated project configuration.
///         </p>
public struct UpdateProjectOutputResponse: Equatable {
    /// <p>
    ///             Detailed information about the updated AWS Mobile Hub project.
    ///         </p>
    public let details: ProjectDetails?

    public init (
        details: ProjectDetails? = nil
    )
    {
        self.details = details
    }
}

struct UpdateProjectOutputResponseBody: Equatable {
    public let details: ProjectDetails?
}

extension UpdateProjectOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case details
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detailsDecoded = try containerValues.decodeIfPresent(ProjectDetails.self, forKey: .details)
        details = detailsDecoded
    }
}
