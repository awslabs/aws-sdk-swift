// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You are not authorized to perform this action.
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CancelQueryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case queryId = "QueryId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let queryId = self.queryId {
            try encodeContainer.encode(queryId, forKey: .queryId)
        }
    }
}

extension CancelQueryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CancelQueryInput: Swift.Equatable {
    /// The ID of the query that needs to be cancelled. QueryID is returned as part of the query result.
    /// This member is required.
    public var queryId: Swift.String?

    public init (
        queryId: Swift.String? = nil
    )
    {
        self.queryId = queryId
    }
}

struct CancelQueryInputBody: Swift.Equatable {
    let queryId: Swift.String?
}

extension CancelQueryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case queryId = "QueryId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryId)
        queryId = queryIdDecoded
    }
}

extension CancelQueryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CancelQueryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidEndpointException" : self = .invalidEndpointException(try InvalidEndpointException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CancelQueryOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case invalidEndpointException(InvalidEndpointException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CancelQueryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CancelQueryOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.cancellationMessage = output.cancellationMessage
        } else {
            self.cancellationMessage = nil
        }
    }
}

public struct CancelQueryOutputResponse: Swift.Equatable {
    /// A CancellationMessage is returned when a CancelQuery request for the query specified by QueryId has already been issued.
    public var cancellationMessage: Swift.String?

    public init (
        cancellationMessage: Swift.String? = nil
    )
    {
        self.cancellationMessage = cancellationMessage
    }
}

struct CancelQueryOutputResponseBody: Swift.Equatable {
    let cancellationMessage: Swift.String?
}

extension CancelQueryOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cancellationMessage = "CancellationMessage"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cancellationMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cancellationMessage)
        cancellationMessage = cancellationMessageDecoded
    }
}

extension TimestreamQueryClientTypes.ColumnInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = self.type {
            try encodeContainer.encode(type.value, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Box<TimestreamQueryClientTypes.ModelType>.self, forKey: .type)
        type = typeDecoded
    }
}

extension TimestreamQueryClientTypes {
    /// Contains the metadata for query results such as the column names, data types, and other attributes.
    public struct ColumnInfo: Swift.Equatable {
        /// The name of the result set column. The name of the result set is available for columns of all data types except for arrays.
        public var name: Swift.String?
        /// The data type of the result set column. The data type can be a scalar or complex. Scalar data types are integers, strings, doubles, Booleans, and others. Complex data types are types such as arrays, rows, and others.
        /// This member is required.
        public var type: Box<TimestreamQueryClientTypes.ModelType>?

        public init (
            name: Swift.String? = nil,
            type: Box<TimestreamQueryClientTypes.ModelType>? = nil
        )
        {
            self.name = name
            self.type = type
        }
    }

}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Unable to poll results for a cancelled query.
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CreateScheduledQueryInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateScheduledQueryInput(errorReportConfiguration: \(Swift.String(describing: errorReportConfiguration)), kmsKeyId: \(Swift.String(describing: kmsKeyId)), name: \(Swift.String(describing: name)), notificationConfiguration: \(Swift.String(describing: notificationConfiguration)), scheduleConfiguration: \(Swift.String(describing: scheduleConfiguration)), scheduledQueryExecutionRoleArn: \(Swift.String(describing: scheduledQueryExecutionRoleArn)), tags: \(Swift.String(describing: tags)), targetConfiguration: \(Swift.String(describing: targetConfiguration)), clientToken: \"CONTENT_REDACTED\", queryString: \"CONTENT_REDACTED\")"}
}

extension CreateScheduledQueryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case errorReportConfiguration = "ErrorReportConfiguration"
        case kmsKeyId = "KmsKeyId"
        case name = "Name"
        case notificationConfiguration = "NotificationConfiguration"
        case queryString = "QueryString"
        case scheduleConfiguration = "ScheduleConfiguration"
        case scheduledQueryExecutionRoleArn = "ScheduledQueryExecutionRoleArn"
        case tags = "Tags"
        case targetConfiguration = "TargetConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let errorReportConfiguration = self.errorReportConfiguration {
            try encodeContainer.encode(errorReportConfiguration, forKey: .errorReportConfiguration)
        }
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let notificationConfiguration = self.notificationConfiguration {
            try encodeContainer.encode(notificationConfiguration, forKey: .notificationConfiguration)
        }
        if let queryString = self.queryString {
            try encodeContainer.encode(queryString, forKey: .queryString)
        }
        if let scheduleConfiguration = self.scheduleConfiguration {
            try encodeContainer.encode(scheduleConfiguration, forKey: .scheduleConfiguration)
        }
        if let scheduledQueryExecutionRoleArn = self.scheduledQueryExecutionRoleArn {
            try encodeContainer.encode(scheduledQueryExecutionRoleArn, forKey: .scheduledQueryExecutionRoleArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let targetConfiguration = self.targetConfiguration {
            try encodeContainer.encode(targetConfiguration, forKey: .targetConfiguration)
        }
    }
}

extension CreateScheduledQueryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateScheduledQueryInput: Swift.Equatable {
    /// Using a ClientToken makes the call to CreateScheduledQuery idempotent, in other words, making the same request repeatedly will produce the same result. Making multiple identical CreateScheduledQuery requests has the same effect as making a single request.
    ///
    /// * If CreateScheduledQuery is called without a ClientToken, the Query SDK generates a ClientToken on your behalf.
    ///
    /// * After 8 hours, any request with the same ClientToken is treated as a new request.
    public var clientToken: Swift.String?
    /// Configuration for error reporting. Error reports will be generated when a problem is encountered when writing the query results.
    /// This member is required.
    public var errorReportConfiguration: TimestreamQueryClientTypes.ErrorReportConfiguration?
    /// The Amazon KMS key used to encrypt the scheduled query resource, at-rest. If the Amazon KMS key is not specified, the scheduled query resource will be encrypted with a Timestream owned Amazon KMS key. To specify a KMS key, use the key ID, key ARN, alias name, or alias ARN. When using an alias name, prefix the name with alias/ If ErrorReportConfiguration uses SSE_KMS as encryption type, the same KmsKeyId is used to encrypt the error report at rest.
    public var kmsKeyId: Swift.String?
    /// Name of the scheduled query.
    /// This member is required.
    public var name: Swift.String?
    /// Notification configuration for the scheduled query. A notification is sent by Timestream when a query run finishes, when the state is updated or when you delete it.
    /// This member is required.
    public var notificationConfiguration: TimestreamQueryClientTypes.NotificationConfiguration?
    /// The query string to run. Parameter names can be specified in the query string @ character followed by an identifier. The named Parameter @scheduled_runtime is reserved and can be used in the query to get the time at which the query is scheduled to run. The timestamp calculated according to the ScheduleConfiguration parameter, will be the value of @scheduled_runtime paramater for each query run. For example, consider an instance of a scheduled query executing on 2021-12-01 00:00:00. For this instance, the @scheduled_runtime parameter is initialized to the timestamp 2021-12-01 00:00:00 when invoking the query.
    /// This member is required.
    public var queryString: Swift.String?
    /// The schedule configuration for the query.
    /// This member is required.
    public var scheduleConfiguration: TimestreamQueryClientTypes.ScheduleConfiguration?
    /// The ARN for the IAM role that Timestream will assume when running the scheduled query.
    /// This member is required.
    public var scheduledQueryExecutionRoleArn: Swift.String?
    /// A list of key-value pairs to label the scheduled query.
    public var tags: [TimestreamQueryClientTypes.Tag]?
    /// Configuration used for writing the result of a query.
    public var targetConfiguration: TimestreamQueryClientTypes.TargetConfiguration?

    public init (
        clientToken: Swift.String? = nil,
        errorReportConfiguration: TimestreamQueryClientTypes.ErrorReportConfiguration? = nil,
        kmsKeyId: Swift.String? = nil,
        name: Swift.String? = nil,
        notificationConfiguration: TimestreamQueryClientTypes.NotificationConfiguration? = nil,
        queryString: Swift.String? = nil,
        scheduleConfiguration: TimestreamQueryClientTypes.ScheduleConfiguration? = nil,
        scheduledQueryExecutionRoleArn: Swift.String? = nil,
        tags: [TimestreamQueryClientTypes.Tag]? = nil,
        targetConfiguration: TimestreamQueryClientTypes.TargetConfiguration? = nil
    )
    {
        self.clientToken = clientToken
        self.errorReportConfiguration = errorReportConfiguration
        self.kmsKeyId = kmsKeyId
        self.name = name
        self.notificationConfiguration = notificationConfiguration
        self.queryString = queryString
        self.scheduleConfiguration = scheduleConfiguration
        self.scheduledQueryExecutionRoleArn = scheduledQueryExecutionRoleArn
        self.tags = tags
        self.targetConfiguration = targetConfiguration
    }
}

struct CreateScheduledQueryInputBody: Swift.Equatable {
    let name: Swift.String?
    let queryString: Swift.String?
    let scheduleConfiguration: TimestreamQueryClientTypes.ScheduleConfiguration?
    let notificationConfiguration: TimestreamQueryClientTypes.NotificationConfiguration?
    let targetConfiguration: TimestreamQueryClientTypes.TargetConfiguration?
    let clientToken: Swift.String?
    let scheduledQueryExecutionRoleArn: Swift.String?
    let tags: [TimestreamQueryClientTypes.Tag]?
    let kmsKeyId: Swift.String?
    let errorReportConfiguration: TimestreamQueryClientTypes.ErrorReportConfiguration?
}

extension CreateScheduledQueryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case errorReportConfiguration = "ErrorReportConfiguration"
        case kmsKeyId = "KmsKeyId"
        case name = "Name"
        case notificationConfiguration = "NotificationConfiguration"
        case queryString = "QueryString"
        case scheduleConfiguration = "ScheduleConfiguration"
        case scheduledQueryExecutionRoleArn = "ScheduledQueryExecutionRoleArn"
        case tags = "Tags"
        case targetConfiguration = "TargetConfiguration"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let queryStringDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryString)
        queryString = queryStringDecoded
        let scheduleConfigurationDecoded = try containerValues.decodeIfPresent(TimestreamQueryClientTypes.ScheduleConfiguration.self, forKey: .scheduleConfiguration)
        scheduleConfiguration = scheduleConfigurationDecoded
        let notificationConfigurationDecoded = try containerValues.decodeIfPresent(TimestreamQueryClientTypes.NotificationConfiguration.self, forKey: .notificationConfiguration)
        notificationConfiguration = notificationConfigurationDecoded
        let targetConfigurationDecoded = try containerValues.decodeIfPresent(TimestreamQueryClientTypes.TargetConfiguration.self, forKey: .targetConfiguration)
        targetConfiguration = targetConfigurationDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let scheduledQueryExecutionRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scheduledQueryExecutionRoleArn)
        scheduledQueryExecutionRoleArn = scheduledQueryExecutionRoleArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([TimestreamQueryClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[TimestreamQueryClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [TimestreamQueryClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let errorReportConfigurationDecoded = try containerValues.decodeIfPresent(TimestreamQueryClientTypes.ErrorReportConfiguration.self, forKey: .errorReportConfiguration)
        errorReportConfiguration = errorReportConfigurationDecoded
    }
}

extension CreateScheduledQueryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateScheduledQueryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidEndpointException" : self = .invalidEndpointException(try InvalidEndpointException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateScheduledQueryOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case invalidEndpointException(InvalidEndpointException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateScheduledQueryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateScheduledQueryOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
        } else {
            self.arn = nil
        }
    }
}

public struct CreateScheduledQueryOutputResponse: Swift.Equatable {
    /// ARN for the created scheduled query.
    /// This member is required.
    public var arn: Swift.String?

    public init (
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct CreateScheduledQueryOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
}

extension CreateScheduledQueryOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension TimestreamQueryClientTypes.Datum: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arrayValue = "ArrayValue"
        case nullValue = "NullValue"
        case rowValue = "RowValue"
        case scalarValue = "ScalarValue"
        case timeSeriesValue = "TimeSeriesValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arrayValue = arrayValue {
            var arrayValueContainer = encodeContainer.nestedUnkeyedContainer(forKey: .arrayValue)
            for datum0 in arrayValue {
                try arrayValueContainer.encode(datum0)
            }
        }
        if let nullValue = self.nullValue {
            try encodeContainer.encode(nullValue, forKey: .nullValue)
        }
        if let rowValue = self.rowValue {
            try encodeContainer.encode(rowValue, forKey: .rowValue)
        }
        if let scalarValue = self.scalarValue {
            try encodeContainer.encode(scalarValue, forKey: .scalarValue)
        }
        if let timeSeriesValue = timeSeriesValue {
            var timeSeriesValueContainer = encodeContainer.nestedUnkeyedContainer(forKey: .timeSeriesValue)
            for timeseriesdatapoint0 in timeSeriesValue {
                try timeSeriesValueContainer.encode(timeseriesdatapoint0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scalarValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scalarValue)
        scalarValue = scalarValueDecoded
        let timeSeriesValueContainer = try containerValues.decodeIfPresent([TimestreamQueryClientTypes.TimeSeriesDataPoint?].self, forKey: .timeSeriesValue)
        var timeSeriesValueDecoded0:[TimestreamQueryClientTypes.TimeSeriesDataPoint]? = nil
        if let timeSeriesValueContainer = timeSeriesValueContainer {
            timeSeriesValueDecoded0 = [TimestreamQueryClientTypes.TimeSeriesDataPoint]()
            for structure0 in timeSeriesValueContainer {
                if let structure0 = structure0 {
                    timeSeriesValueDecoded0?.append(structure0)
                }
            }
        }
        timeSeriesValue = timeSeriesValueDecoded0
        let arrayValueContainer = try containerValues.decodeIfPresent([TimestreamQueryClientTypes.Datum?].self, forKey: .arrayValue)
        var arrayValueDecoded0:[TimestreamQueryClientTypes.Datum]? = nil
        if let arrayValueContainer = arrayValueContainer {
            arrayValueDecoded0 = [TimestreamQueryClientTypes.Datum]()
            for structure0 in arrayValueContainer {
                if let structure0 = structure0 {
                    arrayValueDecoded0?.append(structure0)
                }
            }
        }
        arrayValue = arrayValueDecoded0
        let rowValueDecoded = try containerValues.decodeIfPresent(TimestreamQueryClientTypes.Row.self, forKey: .rowValue)
        rowValue = rowValueDecoded
        let nullValueDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .nullValue)
        nullValue = nullValueDecoded
    }
}

extension TimestreamQueryClientTypes {
    /// Datum represents a single data point in a query result.
    public struct Datum: Swift.Equatable {
        /// Indicates if the data point is an array.
        public var arrayValue: [TimestreamQueryClientTypes.Datum]?
        /// Indicates if the data point is null.
        public var nullValue: Swift.Bool?
        /// Indicates if the data point is a row.
        public var rowValue: TimestreamQueryClientTypes.Row?
        /// Indicates if the data point is a scalar value such as integer, string, double, or Boolean.
        public var scalarValue: Swift.String?
        /// Indicates if the data point is a timeseries data type.
        public var timeSeriesValue: [TimestreamQueryClientTypes.TimeSeriesDataPoint]?

        public init (
            arrayValue: [TimestreamQueryClientTypes.Datum]? = nil,
            nullValue: Swift.Bool? = nil,
            rowValue: TimestreamQueryClientTypes.Row? = nil,
            scalarValue: Swift.String? = nil,
            timeSeriesValue: [TimestreamQueryClientTypes.TimeSeriesDataPoint]? = nil
        )
        {
            self.arrayValue = arrayValue
            self.nullValue = nullValue
            self.rowValue = rowValue
            self.scalarValue = scalarValue
            self.timeSeriesValue = timeSeriesValue
        }
    }

}

extension DeleteScheduledQueryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case scheduledQueryArn = "ScheduledQueryArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let scheduledQueryArn = self.scheduledQueryArn {
            try encodeContainer.encode(scheduledQueryArn, forKey: .scheduledQueryArn)
        }
    }
}

extension DeleteScheduledQueryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteScheduledQueryInput: Swift.Equatable {
    /// The ARN of the scheduled query.
    /// This member is required.
    public var scheduledQueryArn: Swift.String?

    public init (
        scheduledQueryArn: Swift.String? = nil
    )
    {
        self.scheduledQueryArn = scheduledQueryArn
    }
}

struct DeleteScheduledQueryInputBody: Swift.Equatable {
    let scheduledQueryArn: Swift.String?
}

extension DeleteScheduledQueryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case scheduledQueryArn = "ScheduledQueryArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scheduledQueryArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scheduledQueryArn)
        scheduledQueryArn = scheduledQueryArnDecoded
    }
}

extension DeleteScheduledQueryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteScheduledQueryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidEndpointException" : self = .invalidEndpointException(try InvalidEndpointException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteScheduledQueryOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case invalidEndpointException(InvalidEndpointException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteScheduledQueryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteScheduledQueryOutputResponse: Swift.Equatable {

    public init () { }
}

extension DescribeEndpointsInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension DescribeEndpointsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeEndpointsInput: Swift.Equatable {

    public init () { }
}

struct DescribeEndpointsInputBody: Swift.Equatable {
}

extension DescribeEndpointsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeEndpointsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeEndpointsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeEndpointsOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeEndpointsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeEndpointsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.endpoints = output.endpoints
        } else {
            self.endpoints = nil
        }
    }
}

public struct DescribeEndpointsOutputResponse: Swift.Equatable {
    /// An Endpoints object is returned when a DescribeEndpoints request is made.
    /// This member is required.
    public var endpoints: [TimestreamQueryClientTypes.Endpoint]?

    public init (
        endpoints: [TimestreamQueryClientTypes.Endpoint]? = nil
    )
    {
        self.endpoints = endpoints
    }
}

struct DescribeEndpointsOutputResponseBody: Swift.Equatable {
    let endpoints: [TimestreamQueryClientTypes.Endpoint]?
}

extension DescribeEndpointsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpoints = "Endpoints"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointsContainer = try containerValues.decodeIfPresent([TimestreamQueryClientTypes.Endpoint?].self, forKey: .endpoints)
        var endpointsDecoded0:[TimestreamQueryClientTypes.Endpoint]? = nil
        if let endpointsContainer = endpointsContainer {
            endpointsDecoded0 = [TimestreamQueryClientTypes.Endpoint]()
            for structure0 in endpointsContainer {
                if let structure0 = structure0 {
                    endpointsDecoded0?.append(structure0)
                }
            }
        }
        endpoints = endpointsDecoded0
    }
}

extension DescribeScheduledQueryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case scheduledQueryArn = "ScheduledQueryArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let scheduledQueryArn = self.scheduledQueryArn {
            try encodeContainer.encode(scheduledQueryArn, forKey: .scheduledQueryArn)
        }
    }
}

extension DescribeScheduledQueryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeScheduledQueryInput: Swift.Equatable {
    /// The ARN of the scheduled query.
    /// This member is required.
    public var scheduledQueryArn: Swift.String?

    public init (
        scheduledQueryArn: Swift.String? = nil
    )
    {
        self.scheduledQueryArn = scheduledQueryArn
    }
}

struct DescribeScheduledQueryInputBody: Swift.Equatable {
    let scheduledQueryArn: Swift.String?
}

extension DescribeScheduledQueryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case scheduledQueryArn = "ScheduledQueryArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scheduledQueryArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scheduledQueryArn)
        scheduledQueryArn = scheduledQueryArnDecoded
    }
}

extension DescribeScheduledQueryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeScheduledQueryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidEndpointException" : self = .invalidEndpointException(try InvalidEndpointException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeScheduledQueryOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case invalidEndpointException(InvalidEndpointException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeScheduledQueryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeScheduledQueryOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.scheduledQuery = output.scheduledQuery
        } else {
            self.scheduledQuery = nil
        }
    }
}

public struct DescribeScheduledQueryOutputResponse: Swift.Equatable {
    /// The scheduled query.
    /// This member is required.
    public var scheduledQuery: TimestreamQueryClientTypes.ScheduledQueryDescription?

    public init (
        scheduledQuery: TimestreamQueryClientTypes.ScheduledQueryDescription? = nil
    )
    {
        self.scheduledQuery = scheduledQuery
    }
}

struct DescribeScheduledQueryOutputResponseBody: Swift.Equatable {
    let scheduledQuery: TimestreamQueryClientTypes.ScheduledQueryDescription?
}

extension DescribeScheduledQueryOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case scheduledQuery = "ScheduledQuery"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scheduledQueryDecoded = try containerValues.decodeIfPresent(TimestreamQueryClientTypes.ScheduledQueryDescription.self, forKey: .scheduledQuery)
        scheduledQuery = scheduledQueryDecoded
    }
}

extension TimestreamQueryClientTypes.DimensionMapping: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dimensionValueType = "DimensionValueType"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dimensionValueType = self.dimensionValueType {
            try encodeContainer.encode(dimensionValueType.rawValue, forKey: .dimensionValueType)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let dimensionValueTypeDecoded = try containerValues.decodeIfPresent(TimestreamQueryClientTypes.DimensionValueType.self, forKey: .dimensionValueType)
        dimensionValueType = dimensionValueTypeDecoded
    }
}

extension TimestreamQueryClientTypes {
    /// This type is used to map column(s) from the query result to a dimension in the destination table.
    public struct DimensionMapping: Swift.Equatable {
        /// Type for the dimension.
        /// This member is required.
        public var dimensionValueType: TimestreamQueryClientTypes.DimensionValueType?
        /// Column name from query result.
        /// This member is required.
        public var name: Swift.String?

        public init (
            dimensionValueType: TimestreamQueryClientTypes.DimensionValueType? = nil,
            name: Swift.String? = nil
        )
        {
            self.dimensionValueType = dimensionValueType
            self.name = name
        }
    }

}

extension TimestreamQueryClientTypes {
    public enum DimensionValueType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case varchar
        case sdkUnknown(Swift.String)

        public static var allCases: [DimensionValueType] {
            return [
                .varchar,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .varchar: return "VARCHAR"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DimensionValueType(rawValue: rawValue) ?? DimensionValueType.sdkUnknown(rawValue)
        }
    }
}

extension TimestreamQueryClientTypes.Endpoint: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case address = "Address"
        case cachePeriodInMinutes = "CachePeriodInMinutes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let address = self.address {
            try encodeContainer.encode(address, forKey: .address)
        }
        if cachePeriodInMinutes != 0 {
            try encodeContainer.encode(cachePeriodInMinutes, forKey: .cachePeriodInMinutes)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .address)
        address = addressDecoded
        let cachePeriodInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .cachePeriodInMinutes) ?? 0
        cachePeriodInMinutes = cachePeriodInMinutesDecoded
    }
}

extension TimestreamQueryClientTypes {
    /// Represents an available endpoint against which to make API calls against, as well as the TTL for that endpoint.
    public struct Endpoint: Swift.Equatable {
        /// An endpoint address.
        /// This member is required.
        public var address: Swift.String?
        /// The TTL for the endpoint, in minutes.
        /// This member is required.
        public var cachePeriodInMinutes: Swift.Int

        public init (
            address: Swift.String? = nil,
            cachePeriodInMinutes: Swift.Int = 0
        )
        {
            self.address = address
            self.cachePeriodInMinutes = cachePeriodInMinutes
        }
    }

}

extension TimestreamQueryClientTypes.ErrorReportConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3Configuration = "S3Configuration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3Configuration = self.s3Configuration {
            try encodeContainer.encode(s3Configuration, forKey: .s3Configuration)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3ConfigurationDecoded = try containerValues.decodeIfPresent(TimestreamQueryClientTypes.S3Configuration.self, forKey: .s3Configuration)
        s3Configuration = s3ConfigurationDecoded
    }
}

extension TimestreamQueryClientTypes {
    /// Configuration required for error reporting.
    public struct ErrorReportConfiguration: Swift.Equatable {
        /// The S3 configuration for the error reports.
        /// This member is required.
        public var s3Configuration: TimestreamQueryClientTypes.S3Configuration?

        public init (
            s3Configuration: TimestreamQueryClientTypes.S3Configuration? = nil
        )
        {
            self.s3Configuration = s3Configuration
        }
    }

}

extension TimestreamQueryClientTypes.ErrorReportLocation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3ReportLocation = "S3ReportLocation"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3ReportLocation = self.s3ReportLocation {
            try encodeContainer.encode(s3ReportLocation, forKey: .s3ReportLocation)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3ReportLocationDecoded = try containerValues.decodeIfPresent(TimestreamQueryClientTypes.S3ReportLocation.self, forKey: .s3ReportLocation)
        s3ReportLocation = s3ReportLocationDecoded
    }
}

extension TimestreamQueryClientTypes {
    /// This contains the location of the error report for a single scheduled query call.
    public struct ErrorReportLocation: Swift.Equatable {
        /// The S3 location where error reports are written.
        public var s3ReportLocation: TimestreamQueryClientTypes.S3ReportLocation?

        public init (
            s3ReportLocation: TimestreamQueryClientTypes.S3ReportLocation? = nil
        )
        {
            self.s3ReportLocation = s3ReportLocation
        }
    }

}

extension ExecuteScheduledQueryInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ExecuteScheduledQueryInput(invocationTime: \(Swift.String(describing: invocationTime)), scheduledQueryArn: \(Swift.String(describing: scheduledQueryArn)), clientToken: \"CONTENT_REDACTED\")"}
}

extension ExecuteScheduledQueryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case invocationTime = "InvocationTime"
        case scheduledQueryArn = "ScheduledQueryArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let invocationTime = self.invocationTime {
            try encodeContainer.encodeTimestamp(invocationTime, format: .epochSeconds, forKey: .invocationTime)
        }
        if let scheduledQueryArn = self.scheduledQueryArn {
            try encodeContainer.encode(scheduledQueryArn, forKey: .scheduledQueryArn)
        }
    }
}

extension ExecuteScheduledQueryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ExecuteScheduledQueryInput: Swift.Equatable {
    /// Not used.
    public var clientToken: Swift.String?
    /// The timestamp in UTC. Query will be run as if it was invoked at this timestamp.
    /// This member is required.
    public var invocationTime: ClientRuntime.Date?
    /// ARN of the scheduled query.
    /// This member is required.
    public var scheduledQueryArn: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        invocationTime: ClientRuntime.Date? = nil,
        scheduledQueryArn: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.invocationTime = invocationTime
        self.scheduledQueryArn = scheduledQueryArn
    }
}

struct ExecuteScheduledQueryInputBody: Swift.Equatable {
    let scheduledQueryArn: Swift.String?
    let invocationTime: ClientRuntime.Date?
    let clientToken: Swift.String?
}

extension ExecuteScheduledQueryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case invocationTime = "InvocationTime"
        case scheduledQueryArn = "ScheduledQueryArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scheduledQueryArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scheduledQueryArn)
        scheduledQueryArn = scheduledQueryArnDecoded
        let invocationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .invocationTime)
        invocationTime = invocationTimeDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension ExecuteScheduledQueryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ExecuteScheduledQueryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidEndpointException" : self = .invalidEndpointException(try InvalidEndpointException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ExecuteScheduledQueryOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case invalidEndpointException(InvalidEndpointException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ExecuteScheduledQueryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct ExecuteScheduledQueryOutputResponse: Swift.Equatable {

    public init () { }
}

extension TimestreamQueryClientTypes.ExecutionStats: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bytesMetered = "BytesMetered"
        case dataWrites = "DataWrites"
        case executionTimeInMillis = "ExecutionTimeInMillis"
        case queryResultRows = "QueryResultRows"
        case recordsIngested = "RecordsIngested"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if bytesMetered != 0 {
            try encodeContainer.encode(bytesMetered, forKey: .bytesMetered)
        }
        if dataWrites != 0 {
            try encodeContainer.encode(dataWrites, forKey: .dataWrites)
        }
        if executionTimeInMillis != 0 {
            try encodeContainer.encode(executionTimeInMillis, forKey: .executionTimeInMillis)
        }
        if queryResultRows != 0 {
            try encodeContainer.encode(queryResultRows, forKey: .queryResultRows)
        }
        if recordsIngested != 0 {
            try encodeContainer.encode(recordsIngested, forKey: .recordsIngested)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let executionTimeInMillisDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .executionTimeInMillis) ?? 0
        executionTimeInMillis = executionTimeInMillisDecoded
        let dataWritesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .dataWrites) ?? 0
        dataWrites = dataWritesDecoded
        let bytesMeteredDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .bytesMetered) ?? 0
        bytesMetered = bytesMeteredDecoded
        let recordsIngestedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .recordsIngested) ?? 0
        recordsIngested = recordsIngestedDecoded
        let queryResultRowsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .queryResultRows) ?? 0
        queryResultRows = queryResultRowsDecoded
    }
}

extension TimestreamQueryClientTypes {
    /// Statistics for a single scheduled query run.
    public struct ExecutionStats: Swift.Equatable {
        /// Bytes metered for a single scheduled query run.
        public var bytesMetered: Swift.Int
        /// Data writes metered for records ingested in a single scheduled query run.
        public var dataWrites: Swift.Int
        /// Total time, measured in milliseconds, that was needed for the scheduled query run to complete.
        public var executionTimeInMillis: Swift.Int
        /// Number of rows present in the output from running a query before ingestion to destination data source.
        public var queryResultRows: Swift.Int
        /// The number of records ingested for a single scheduled query run.
        public var recordsIngested: Swift.Int

        public init (
            bytesMetered: Swift.Int = 0,
            dataWrites: Swift.Int = 0,
            executionTimeInMillis: Swift.Int = 0,
            queryResultRows: Swift.Int = 0,
            recordsIngested: Swift.Int = 0
        )
        {
            self.bytesMetered = bytesMetered
            self.dataWrites = dataWrites
            self.executionTimeInMillis = executionTimeInMillis
            self.queryResultRows = queryResultRows
            self.recordsIngested = recordsIngested
        }
    }

}

extension InternalServerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Timestream was unable to fully process this request because of an internal server error.
public struct InternalServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidEndpointException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidEndpointExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The requested endpoint was not valid.
public struct InvalidEndpointException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidEndpointExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidEndpointExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListScheduledQueriesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListScheduledQueriesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListScheduledQueriesInput: Swift.Equatable {
    /// The maximum number of items to return in the output. If the total number of items available is more than the value specified, a NextToken is provided in the output. To resume pagination, provide the NextToken value as the argument to the subsequent call to ListScheduledQueriesRequest.
    public var maxResults: Swift.Int?
    /// A pagination token to resume pagination.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListScheduledQueriesInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListScheduledQueriesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListScheduledQueriesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListScheduledQueriesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidEndpointException" : self = .invalidEndpointException(try InvalidEndpointException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListScheduledQueriesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case invalidEndpointException(InvalidEndpointException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListScheduledQueriesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListScheduledQueriesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.scheduledQueries = output.scheduledQueries
        } else {
            self.nextToken = nil
            self.scheduledQueries = nil
        }
    }
}

public struct ListScheduledQueriesOutputResponse: Swift.Equatable {
    /// A token to specify where to start paginating. This is the NextToken from a previously truncated response.
    public var nextToken: Swift.String?
    /// A list of scheduled queries.
    /// This member is required.
    public var scheduledQueries: [TimestreamQueryClientTypes.ScheduledQuery]?

    public init (
        nextToken: Swift.String? = nil,
        scheduledQueries: [TimestreamQueryClientTypes.ScheduledQuery]? = nil
    )
    {
        self.nextToken = nextToken
        self.scheduledQueries = scheduledQueries
    }
}

struct ListScheduledQueriesOutputResponseBody: Swift.Equatable {
    let scheduledQueries: [TimestreamQueryClientTypes.ScheduledQuery]?
    let nextToken: Swift.String?
}

extension ListScheduledQueriesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case scheduledQueries = "ScheduledQueries"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scheduledQueriesContainer = try containerValues.decodeIfPresent([TimestreamQueryClientTypes.ScheduledQuery?].self, forKey: .scheduledQueries)
        var scheduledQueriesDecoded0:[TimestreamQueryClientTypes.ScheduledQuery]? = nil
        if let scheduledQueriesContainer = scheduledQueriesContainer {
            scheduledQueriesDecoded0 = [TimestreamQueryClientTypes.ScheduledQuery]()
            for structure0 in scheduledQueriesContainer {
                if let structure0 = structure0 {
                    scheduledQueriesDecoded0?.append(structure0)
                }
            }
        }
        scheduledQueries = scheduledQueriesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceARN = "ResourceARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The maximum number of tags to return.
    public var maxResults: Swift.Int?
    /// A pagination token to resume pagination.
    public var nextToken: Swift.String?
    /// The Timestream resource with tags to be listed. This value is an Amazon Resource Name (ARN).
    /// This member is required.
    public var resourceARN: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceARN: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceARN = resourceARN
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
    let resourceARN: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListTagsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceARN = "ResourceARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidEndpointException" : self = .invalidEndpointException(try InvalidEndpointException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case invalidEndpointException(InvalidEndpointException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.tags = output.tags
        } else {
            self.nextToken = nil
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// A pagination token to resume pagination with a subsequent call to ListTagsForResourceResponse.
    public var nextToken: Swift.String?
    /// The tags currently associated with the Timestream resource.
    /// This member is required.
    public var tags: [TimestreamQueryClientTypes.Tag]?

    public init (
        nextToken: Swift.String? = nil,
        tags: [TimestreamQueryClientTypes.Tag]? = nil
    )
    {
        self.nextToken = nextToken
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let tags: [TimestreamQueryClientTypes.Tag]?
    let nextToken: Swift.String?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([TimestreamQueryClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[TimestreamQueryClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [TimestreamQueryClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension TimestreamQueryClientTypes {
    public enum MeasureValueType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case bigint
        case boolean
        case double
        case multi
        case varchar
        case sdkUnknown(Swift.String)

        public static var allCases: [MeasureValueType] {
            return [
                .bigint,
                .boolean,
                .double,
                .multi,
                .varchar,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .bigint: return "BIGINT"
            case .boolean: return "BOOLEAN"
            case .double: return "DOUBLE"
            case .multi: return "MULTI"
            case .varchar: return "VARCHAR"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MeasureValueType(rawValue: rawValue) ?? MeasureValueType.sdkUnknown(rawValue)
        }
    }
}

extension TimestreamQueryClientTypes.MixedMeasureMapping: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case measureName = "MeasureName"
        case measureValueType = "MeasureValueType"
        case multiMeasureAttributeMappings = "MultiMeasureAttributeMappings"
        case sourceColumn = "SourceColumn"
        case targetMeasureName = "TargetMeasureName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let measureName = self.measureName {
            try encodeContainer.encode(measureName, forKey: .measureName)
        }
        if let measureValueType = self.measureValueType {
            try encodeContainer.encode(measureValueType.rawValue, forKey: .measureValueType)
        }
        if let multiMeasureAttributeMappings = multiMeasureAttributeMappings {
            var multiMeasureAttributeMappingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .multiMeasureAttributeMappings)
            for multimeasureattributemapping0 in multiMeasureAttributeMappings {
                try multiMeasureAttributeMappingsContainer.encode(multimeasureattributemapping0)
            }
        }
        if let sourceColumn = self.sourceColumn {
            try encodeContainer.encode(sourceColumn, forKey: .sourceColumn)
        }
        if let targetMeasureName = self.targetMeasureName {
            try encodeContainer.encode(targetMeasureName, forKey: .targetMeasureName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let measureNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .measureName)
        measureName = measureNameDecoded
        let sourceColumnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceColumn)
        sourceColumn = sourceColumnDecoded
        let targetMeasureNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetMeasureName)
        targetMeasureName = targetMeasureNameDecoded
        let measureValueTypeDecoded = try containerValues.decodeIfPresent(TimestreamQueryClientTypes.MeasureValueType.self, forKey: .measureValueType)
        measureValueType = measureValueTypeDecoded
        let multiMeasureAttributeMappingsContainer = try containerValues.decodeIfPresent([TimestreamQueryClientTypes.MultiMeasureAttributeMapping?].self, forKey: .multiMeasureAttributeMappings)
        var multiMeasureAttributeMappingsDecoded0:[TimestreamQueryClientTypes.MultiMeasureAttributeMapping]? = nil
        if let multiMeasureAttributeMappingsContainer = multiMeasureAttributeMappingsContainer {
            multiMeasureAttributeMappingsDecoded0 = [TimestreamQueryClientTypes.MultiMeasureAttributeMapping]()
            for structure0 in multiMeasureAttributeMappingsContainer {
                if let structure0 = structure0 {
                    multiMeasureAttributeMappingsDecoded0?.append(structure0)
                }
            }
        }
        multiMeasureAttributeMappings = multiMeasureAttributeMappingsDecoded0
    }
}

extension TimestreamQueryClientTypes {
    /// MixedMeasureMappings are mappings that can be used to ingest data into a mixture of narrow and multi measures in the derived table.
    public struct MixedMeasureMapping: Swift.Equatable {
        /// Refers to the value of measure_name in a result row. This field is required if MeasureNameColumn is provided.
        public var measureName: Swift.String?
        /// Type of the value that is to be read from sourceColumn. If the mapping is for MULTI, use MeasureValueType.MULTI.
        /// This member is required.
        public var measureValueType: TimestreamQueryClientTypes.MeasureValueType?
        /// Required when measureValueType is MULTI. Attribute mappings for MULTI value measures.
        public var multiMeasureAttributeMappings: [TimestreamQueryClientTypes.MultiMeasureAttributeMapping]?
        /// This field refers to the source column from which measure-value is to be read for result materialization.
        public var sourceColumn: Swift.String?
        /// Target measure name to be used. If not provided, the target measure name by default would be measure-name if provided, or sourceColumn otherwise.
        public var targetMeasureName: Swift.String?

        public init (
            measureName: Swift.String? = nil,
            measureValueType: TimestreamQueryClientTypes.MeasureValueType? = nil,
            multiMeasureAttributeMappings: [TimestreamQueryClientTypes.MultiMeasureAttributeMapping]? = nil,
            sourceColumn: Swift.String? = nil,
            targetMeasureName: Swift.String? = nil
        )
        {
            self.measureName = measureName
            self.measureValueType = measureValueType
            self.multiMeasureAttributeMappings = multiMeasureAttributeMappings
            self.sourceColumn = sourceColumn
            self.targetMeasureName = targetMeasureName
        }
    }

}

extension TimestreamQueryClientTypes.ModelType: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arrayColumnInfo = "ArrayColumnInfo"
        case rowColumnInfo = "RowColumnInfo"
        case scalarType = "ScalarType"
        case timeSeriesMeasureValueColumnInfo = "TimeSeriesMeasureValueColumnInfo"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arrayColumnInfo = self.arrayColumnInfo {
            try encodeContainer.encode(arrayColumnInfo, forKey: .arrayColumnInfo)
        }
        if let rowColumnInfo = rowColumnInfo {
            var rowColumnInfoContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rowColumnInfo)
            for columninfo0 in rowColumnInfo {
                try rowColumnInfoContainer.encode(columninfo0)
            }
        }
        if let scalarType = self.scalarType {
            try encodeContainer.encode(scalarType.rawValue, forKey: .scalarType)
        }
        if let timeSeriesMeasureValueColumnInfo = self.timeSeriesMeasureValueColumnInfo {
            try encodeContainer.encode(timeSeriesMeasureValueColumnInfo, forKey: .timeSeriesMeasureValueColumnInfo)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scalarTypeDecoded = try containerValues.decodeIfPresent(TimestreamQueryClientTypes.ScalarType.self, forKey: .scalarType)
        scalarType = scalarTypeDecoded
        let arrayColumnInfoDecoded = try containerValues.decodeIfPresent(TimestreamQueryClientTypes.ColumnInfo.self, forKey: .arrayColumnInfo)
        arrayColumnInfo = arrayColumnInfoDecoded
        let timeSeriesMeasureValueColumnInfoDecoded = try containerValues.decodeIfPresent(TimestreamQueryClientTypes.ColumnInfo.self, forKey: .timeSeriesMeasureValueColumnInfo)
        timeSeriesMeasureValueColumnInfo = timeSeriesMeasureValueColumnInfoDecoded
        let rowColumnInfoContainer = try containerValues.decodeIfPresent([TimestreamQueryClientTypes.ColumnInfo?].self, forKey: .rowColumnInfo)
        var rowColumnInfoDecoded0:[TimestreamQueryClientTypes.ColumnInfo]? = nil
        if let rowColumnInfoContainer = rowColumnInfoContainer {
            rowColumnInfoDecoded0 = [TimestreamQueryClientTypes.ColumnInfo]()
            for structure0 in rowColumnInfoContainer {
                if let structure0 = structure0 {
                    rowColumnInfoDecoded0?.append(structure0)
                }
            }
        }
        rowColumnInfo = rowColumnInfoDecoded0
    }
}

extension TimestreamQueryClientTypes.MultiMeasureAttributeMapping: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case measureValueType = "MeasureValueType"
        case sourceColumn = "SourceColumn"
        case targetMultiMeasureAttributeName = "TargetMultiMeasureAttributeName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let measureValueType = self.measureValueType {
            try encodeContainer.encode(measureValueType.rawValue, forKey: .measureValueType)
        }
        if let sourceColumn = self.sourceColumn {
            try encodeContainer.encode(sourceColumn, forKey: .sourceColumn)
        }
        if let targetMultiMeasureAttributeName = self.targetMultiMeasureAttributeName {
            try encodeContainer.encode(targetMultiMeasureAttributeName, forKey: .targetMultiMeasureAttributeName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceColumnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceColumn)
        sourceColumn = sourceColumnDecoded
        let targetMultiMeasureAttributeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetMultiMeasureAttributeName)
        targetMultiMeasureAttributeName = targetMultiMeasureAttributeNameDecoded
        let measureValueTypeDecoded = try containerValues.decodeIfPresent(TimestreamQueryClientTypes.ScalarMeasureValueType.self, forKey: .measureValueType)
        measureValueType = measureValueTypeDecoded
    }
}

extension TimestreamQueryClientTypes {
    /// Attribute mapping for MULTI value measures.
    public struct MultiMeasureAttributeMapping: Swift.Equatable {
        /// Type of the attribute to be read from the source column.
        /// This member is required.
        public var measureValueType: TimestreamQueryClientTypes.ScalarMeasureValueType?
        /// Source column from where the attribute value is to be read.
        /// This member is required.
        public var sourceColumn: Swift.String?
        /// Custom name to be used for attribute name in derived table. If not provided, source column name would be used.
        public var targetMultiMeasureAttributeName: Swift.String?

        public init (
            measureValueType: TimestreamQueryClientTypes.ScalarMeasureValueType? = nil,
            sourceColumn: Swift.String? = nil,
            targetMultiMeasureAttributeName: Swift.String? = nil
        )
        {
            self.measureValueType = measureValueType
            self.sourceColumn = sourceColumn
            self.targetMultiMeasureAttributeName = targetMultiMeasureAttributeName
        }
    }

}

extension TimestreamQueryClientTypes.MultiMeasureMappings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case multiMeasureAttributeMappings = "MultiMeasureAttributeMappings"
        case targetMultiMeasureName = "TargetMultiMeasureName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let multiMeasureAttributeMappings = multiMeasureAttributeMappings {
            var multiMeasureAttributeMappingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .multiMeasureAttributeMappings)
            for multimeasureattributemapping0 in multiMeasureAttributeMappings {
                try multiMeasureAttributeMappingsContainer.encode(multimeasureattributemapping0)
            }
        }
        if let targetMultiMeasureName = self.targetMultiMeasureName {
            try encodeContainer.encode(targetMultiMeasureName, forKey: .targetMultiMeasureName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetMultiMeasureNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetMultiMeasureName)
        targetMultiMeasureName = targetMultiMeasureNameDecoded
        let multiMeasureAttributeMappingsContainer = try containerValues.decodeIfPresent([TimestreamQueryClientTypes.MultiMeasureAttributeMapping?].self, forKey: .multiMeasureAttributeMappings)
        var multiMeasureAttributeMappingsDecoded0:[TimestreamQueryClientTypes.MultiMeasureAttributeMapping]? = nil
        if let multiMeasureAttributeMappingsContainer = multiMeasureAttributeMappingsContainer {
            multiMeasureAttributeMappingsDecoded0 = [TimestreamQueryClientTypes.MultiMeasureAttributeMapping]()
            for structure0 in multiMeasureAttributeMappingsContainer {
                if let structure0 = structure0 {
                    multiMeasureAttributeMappingsDecoded0?.append(structure0)
                }
            }
        }
        multiMeasureAttributeMappings = multiMeasureAttributeMappingsDecoded0
    }
}

extension TimestreamQueryClientTypes {
    /// Only one of MixedMeasureMappings or MultiMeasureMappings is to be provided. MultiMeasureMappings can be used to ingest data as multi measures in the derived table.
    public struct MultiMeasureMappings: Swift.Equatable {
        /// Required. Attribute mappings to be used for mapping query results to ingest data for multi-measure attributes.
        /// This member is required.
        public var multiMeasureAttributeMappings: [TimestreamQueryClientTypes.MultiMeasureAttributeMapping]?
        /// The name of the target multi-measure name in the derived table. This input is required when measureNameColumn is not provided. If MeasureNameColumn is provided, then value from that column will be used as multi-measure name.
        public var targetMultiMeasureName: Swift.String?

        public init (
            multiMeasureAttributeMappings: [TimestreamQueryClientTypes.MultiMeasureAttributeMapping]? = nil,
            targetMultiMeasureName: Swift.String? = nil
        )
        {
            self.multiMeasureAttributeMappings = multiMeasureAttributeMappings
            self.targetMultiMeasureName = targetMultiMeasureName
        }
    }

}

extension TimestreamQueryClientTypes.NotificationConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case snsConfiguration = "SnsConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let snsConfiguration = self.snsConfiguration {
            try encodeContainer.encode(snsConfiguration, forKey: .snsConfiguration)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snsConfigurationDecoded = try containerValues.decodeIfPresent(TimestreamQueryClientTypes.SnsConfiguration.self, forKey: .snsConfiguration)
        snsConfiguration = snsConfigurationDecoded
    }
}

extension TimestreamQueryClientTypes {
    /// Notification configuration for a scheduled query. A notification is sent by Timestream when a scheduled query is created, its state is updated or when it is deleted.
    public struct NotificationConfiguration: Swift.Equatable {
        /// Details on SNS configuration.
        /// This member is required.
        public var snsConfiguration: TimestreamQueryClientTypes.SnsConfiguration?

        public init (
            snsConfiguration: TimestreamQueryClientTypes.SnsConfiguration? = nil
        )
        {
            self.snsConfiguration = snsConfiguration
        }
    }

}

extension TimestreamQueryClientTypes.ParameterMapping: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(TimestreamQueryClientTypes.ModelType.self, forKey: .type)
        type = typeDecoded
    }
}

extension TimestreamQueryClientTypes {
    /// Mapping for named parameters.
    public struct ParameterMapping: Swift.Equatable {
        /// Parameter name.
        /// This member is required.
        public var name: Swift.String?
        /// Contains the data type of a column in a query result set. The data type can be scalar or complex. The supported scalar data types are integers, Boolean, string, double, timestamp, date, time, and intervals. The supported complex data types are arrays, rows, and timeseries.
        /// This member is required.
        public var type: TimestreamQueryClientTypes.ModelType?

        public init (
            name: Swift.String? = nil,
            type: TimestreamQueryClientTypes.ModelType? = nil
        )
        {
            self.name = name
            self.type = type
        }
    }

}

extension PrepareQueryInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PrepareQueryInput(validateOnly: \(Swift.String(describing: validateOnly)), queryString: \"CONTENT_REDACTED\")"}
}

extension PrepareQueryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case queryString = "QueryString"
        case validateOnly = "ValidateOnly"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let queryString = self.queryString {
            try encodeContainer.encode(queryString, forKey: .queryString)
        }
        if let validateOnly = self.validateOnly {
            try encodeContainer.encode(validateOnly, forKey: .validateOnly)
        }
    }
}

extension PrepareQueryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PrepareQueryInput: Swift.Equatable {
    /// The Timestream query string that you want to use as a prepared statement. Parameter names can be specified in the query string @ character followed by an identifier.
    /// This member is required.
    public var queryString: Swift.String?
    /// By setting this value to true, Timestream will only validate that the query string is a valid Timestream query, and not store the prepared query for later use.
    public var validateOnly: Swift.Bool?

    public init (
        queryString: Swift.String? = nil,
        validateOnly: Swift.Bool? = nil
    )
    {
        self.queryString = queryString
        self.validateOnly = validateOnly
    }
}

struct PrepareQueryInputBody: Swift.Equatable {
    let queryString: Swift.String?
    let validateOnly: Swift.Bool?
}

extension PrepareQueryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case queryString = "QueryString"
        case validateOnly = "ValidateOnly"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryStringDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryString)
        queryString = queryStringDecoded
        let validateOnlyDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .validateOnly)
        validateOnly = validateOnlyDecoded
    }
}

extension PrepareQueryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PrepareQueryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidEndpointException" : self = .invalidEndpointException(try InvalidEndpointException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum PrepareQueryOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case invalidEndpointException(InvalidEndpointException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PrepareQueryOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PrepareQueryOutputResponse(columns: \(Swift.String(describing: columns)), parameters: \(Swift.String(describing: parameters)), queryString: \"CONTENT_REDACTED\")"}
}

extension PrepareQueryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: PrepareQueryOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.columns = output.columns
            self.parameters = output.parameters
            self.queryString = output.queryString
        } else {
            self.columns = nil
            self.parameters = nil
            self.queryString = nil
        }
    }
}

public struct PrepareQueryOutputResponse: Swift.Equatable {
    /// A list of SELECT clause columns of the submitted query string.
    /// This member is required.
    public var columns: [TimestreamQueryClientTypes.SelectColumn]?
    /// A list of parameters used in the submitted query string.
    /// This member is required.
    public var parameters: [TimestreamQueryClientTypes.ParameterMapping]?
    /// The query string that you want prepare.
    /// This member is required.
    public var queryString: Swift.String?

    public init (
        columns: [TimestreamQueryClientTypes.SelectColumn]? = nil,
        parameters: [TimestreamQueryClientTypes.ParameterMapping]? = nil,
        queryString: Swift.String? = nil
    )
    {
        self.columns = columns
        self.parameters = parameters
        self.queryString = queryString
    }
}

struct PrepareQueryOutputResponseBody: Swift.Equatable {
    let queryString: Swift.String?
    let columns: [TimestreamQueryClientTypes.SelectColumn]?
    let parameters: [TimestreamQueryClientTypes.ParameterMapping]?
}

extension PrepareQueryOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case columns = "Columns"
        case parameters = "Parameters"
        case queryString = "QueryString"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryStringDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryString)
        queryString = queryStringDecoded
        let columnsContainer = try containerValues.decodeIfPresent([TimestreamQueryClientTypes.SelectColumn?].self, forKey: .columns)
        var columnsDecoded0:[TimestreamQueryClientTypes.SelectColumn]? = nil
        if let columnsContainer = columnsContainer {
            columnsDecoded0 = [TimestreamQueryClientTypes.SelectColumn]()
            for structure0 in columnsContainer {
                if let structure0 = structure0 {
                    columnsDecoded0?.append(structure0)
                }
            }
        }
        columns = columnsDecoded0
        let parametersContainer = try containerValues.decodeIfPresent([TimestreamQueryClientTypes.ParameterMapping?].self, forKey: .parameters)
        var parametersDecoded0:[TimestreamQueryClientTypes.ParameterMapping]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [TimestreamQueryClientTypes.ParameterMapping]()
            for structure0 in parametersContainer {
                if let structure0 = structure0 {
                    parametersDecoded0?.append(structure0)
                }
            }
        }
        parameters = parametersDecoded0
    }
}

extension QueryExecutionException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: QueryExecutionExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Timestream was unable to run the query successfully.
public struct QueryExecutionException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct QueryExecutionExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension QueryExecutionExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension QueryInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "QueryInput(maxRows: \(Swift.String(describing: maxRows)), nextToken: \(Swift.String(describing: nextToken)), clientToken: \"CONTENT_REDACTED\", queryString: \"CONTENT_REDACTED\")"}
}

extension QueryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case maxRows = "MaxRows"
        case nextToken = "NextToken"
        case queryString = "QueryString"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let maxRows = self.maxRows {
            try encodeContainer.encode(maxRows, forKey: .maxRows)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let queryString = self.queryString {
            try encodeContainer.encode(queryString, forKey: .queryString)
        }
    }
}

extension QueryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct QueryInput: Swift.Equatable {
    /// Unique, case-sensitive string of up to 64 ASCII characters specified when a Query request is made. Providing a ClientToken makes the call to Query idempotent. This means that running the same query repeatedly will produce the same result. In other words, making multiple identical Query requests has the same effect as making a single request. When using ClientToken in a query, note the following:
    ///
    /// * If the Query API is instantiated without a ClientToken, the Query SDK generates a ClientToken on your behalf.
    ///
    /// * If the Query invocation only contains the ClientToken but does not include a NextToken, that invocation of Query is assumed to be a new query run.
    ///
    /// * If the invocation contains NextToken, that particular invocation is assumed to be a subsequent invocation of a prior call to the Query API, and a result set is returned.
    ///
    /// * After 4 hours, any request with the same ClientToken is treated as a new request.
    public var clientToken: Swift.String?
    /// The total number of rows to be returned in the Query output. The initial run of Query with a MaxRows value specified will return the result set of the query in two cases:
    ///
    /// * The size of the result is less than 1MB.
    ///
    /// * The number of rows in the result set is less than the value of maxRows.
    ///
    ///
    /// Otherwise, the initial invocation of Query only returns a NextToken, which can then be used in subsequent calls to fetch the result set. To resume pagination, provide the NextToken value in the subsequent command. If the row size is large (e.g. a row has many columns), Timestream may return fewer rows to keep the response size from exceeding the 1 MB limit. If MaxRows is not provided, Timestream will send the necessary number of rows to meet the 1 MB limit.
    public var maxRows: Swift.Int?
    /// A pagination token used to return a set of results. When the Query API is invoked using NextToken, that particular invocation is assumed to be a subsequent invocation of a prior call to Query, and a result set is returned. However, if the Query invocation only contains the ClientToken, that invocation of Query is assumed to be a new query run. Note the following when using NextToken in a query:
    ///
    /// * A pagination token can be used for up to five Query invocations, OR for a duration of up to 1 hour – whichever comes first.
    ///
    /// * Using the same NextToken will return the same set of records. To keep paginating through the result set, you must to use the most recent nextToken.
    ///
    /// * Suppose a Query invocation returns two NextToken values, TokenA and TokenB. If TokenB is used in a subsequent Query invocation, then TokenA is invalidated and cannot be reused.
    ///
    /// * To request a previous result set from a query after pagination has begun, you must re-invoke the Query API.
    ///
    /// * The latest NextToken should be used to paginate until null is returned, at which point a new NextToken should be used.
    ///
    /// * If the IAM principal of the query initiator and the result reader are not the same and/or the query initiator and the result reader do not have the same query string in the query requests, the query will fail with an Invalid pagination token error.
    public var nextToken: Swift.String?
    /// The query to be run by Timestream.
    /// This member is required.
    public var queryString: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        maxRows: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        queryString: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.maxRows = maxRows
        self.nextToken = nextToken
        self.queryString = queryString
    }
}

struct QueryInputBody: Swift.Equatable {
    let queryString: Swift.String?
    let clientToken: Swift.String?
    let nextToken: Swift.String?
    let maxRows: Swift.Int?
}

extension QueryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case maxRows = "MaxRows"
        case nextToken = "NextToken"
        case queryString = "QueryString"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryStringDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryString)
        queryString = queryStringDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxRowsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRows)
        maxRows = maxRowsDecoded
    }
}

extension QueryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension QueryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidEndpointException" : self = .invalidEndpointException(try InvalidEndpointException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "QueryExecutionException" : self = .queryExecutionException(try QueryExecutionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum QueryOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case invalidEndpointException(InvalidEndpointException)
    case queryExecutionException(QueryExecutionException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension QueryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: QueryOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.columnInfo = output.columnInfo
            self.nextToken = output.nextToken
            self.queryId = output.queryId
            self.queryStatus = output.queryStatus
            self.rows = output.rows
        } else {
            self.columnInfo = nil
            self.nextToken = nil
            self.queryId = nil
            self.queryStatus = nil
            self.rows = nil
        }
    }
}

public struct QueryOutputResponse: Swift.Equatable {
    /// The column data types of the returned result set.
    /// This member is required.
    public var columnInfo: [TimestreamQueryClientTypes.ColumnInfo]?
    /// A pagination token that can be used again on a Query call to get the next set of results.
    public var nextToken: Swift.String?
    /// A unique ID for the given query.
    /// This member is required.
    public var queryId: Swift.String?
    /// Information about the status of the query, including progress and bytes scanned.
    public var queryStatus: TimestreamQueryClientTypes.QueryStatus?
    /// The result set rows returned by the query.
    /// This member is required.
    public var rows: [TimestreamQueryClientTypes.Row]?

    public init (
        columnInfo: [TimestreamQueryClientTypes.ColumnInfo]? = nil,
        nextToken: Swift.String? = nil,
        queryId: Swift.String? = nil,
        queryStatus: TimestreamQueryClientTypes.QueryStatus? = nil,
        rows: [TimestreamQueryClientTypes.Row]? = nil
    )
    {
        self.columnInfo = columnInfo
        self.nextToken = nextToken
        self.queryId = queryId
        self.queryStatus = queryStatus
        self.rows = rows
    }
}

struct QueryOutputResponseBody: Swift.Equatable {
    let queryId: Swift.String?
    let nextToken: Swift.String?
    let rows: [TimestreamQueryClientTypes.Row]?
    let columnInfo: [TimestreamQueryClientTypes.ColumnInfo]?
    let queryStatus: TimestreamQueryClientTypes.QueryStatus?
}

extension QueryOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case columnInfo = "ColumnInfo"
        case nextToken = "NextToken"
        case queryId = "QueryId"
        case queryStatus = "QueryStatus"
        case rows = "Rows"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryId)
        queryId = queryIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let rowsContainer = try containerValues.decodeIfPresent([TimestreamQueryClientTypes.Row?].self, forKey: .rows)
        var rowsDecoded0:[TimestreamQueryClientTypes.Row]? = nil
        if let rowsContainer = rowsContainer {
            rowsDecoded0 = [TimestreamQueryClientTypes.Row]()
            for structure0 in rowsContainer {
                if let structure0 = structure0 {
                    rowsDecoded0?.append(structure0)
                }
            }
        }
        rows = rowsDecoded0
        let columnInfoContainer = try containerValues.decodeIfPresent([TimestreamQueryClientTypes.ColumnInfo?].self, forKey: .columnInfo)
        var columnInfoDecoded0:[TimestreamQueryClientTypes.ColumnInfo]? = nil
        if let columnInfoContainer = columnInfoContainer {
            columnInfoDecoded0 = [TimestreamQueryClientTypes.ColumnInfo]()
            for structure0 in columnInfoContainer {
                if let structure0 = structure0 {
                    columnInfoDecoded0?.append(structure0)
                }
            }
        }
        columnInfo = columnInfoDecoded0
        let queryStatusDecoded = try containerValues.decodeIfPresent(TimestreamQueryClientTypes.QueryStatus.self, forKey: .queryStatus)
        queryStatus = queryStatusDecoded
    }
}

extension TimestreamQueryClientTypes.QueryStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cumulativeBytesMetered = "CumulativeBytesMetered"
        case cumulativeBytesScanned = "CumulativeBytesScanned"
        case progressPercentage = "ProgressPercentage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if cumulativeBytesMetered != 0 {
            try encodeContainer.encode(cumulativeBytesMetered, forKey: .cumulativeBytesMetered)
        }
        if cumulativeBytesScanned != 0 {
            try encodeContainer.encode(cumulativeBytesScanned, forKey: .cumulativeBytesScanned)
        }
        if progressPercentage != 0.0 {
            try encodeContainer.encode(progressPercentage, forKey: .progressPercentage)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let progressPercentageDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .progressPercentage) ?? 0.0
        progressPercentage = progressPercentageDecoded
        let cumulativeBytesScannedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .cumulativeBytesScanned) ?? 0
        cumulativeBytesScanned = cumulativeBytesScannedDecoded
        let cumulativeBytesMeteredDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .cumulativeBytesMetered) ?? 0
        cumulativeBytesMetered = cumulativeBytesMeteredDecoded
    }
}

extension TimestreamQueryClientTypes {
    /// Information about the status of the query, including progress and bytes scanned.
    public struct QueryStatus: Swift.Equatable {
        /// The amount of data scanned by the query in bytes that you will be charged for. This is a cumulative sum and represents the total amount of data that you will be charged for since the query was started. The charge is applied only once and is either applied when the query completes running or when the query is cancelled.
        public var cumulativeBytesMetered: Swift.Int
        /// The amount of data scanned by the query in bytes. This is a cumulative sum and represents the total amount of bytes scanned since the query was started.
        public var cumulativeBytesScanned: Swift.Int
        /// The progress of the query, expressed as a percentage.
        public var progressPercentage: Swift.Double

        public init (
            cumulativeBytesMetered: Swift.Int = 0,
            cumulativeBytesScanned: Swift.Int = 0,
            progressPercentage: Swift.Double = 0.0
        )
        {
            self.cumulativeBytesMetered = cumulativeBytesMetered
            self.cumulativeBytesScanned = cumulativeBytesScanned
            self.progressPercentage = progressPercentage
        }
    }

}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.scheduledQueryArn = output.scheduledQueryArn
        } else {
            self.message = nil
            self.scheduledQueryArn = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The requested resource could not be found.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    /// The ARN of the scheduled query.
    public var scheduledQueryArn: Swift.String?

    public init (
        message: Swift.String? = nil,
        scheduledQueryArn: Swift.String? = nil
    )
    {
        self.message = message
        self.scheduledQueryArn = scheduledQueryArn
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let scheduledQueryArn: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case scheduledQueryArn = "ScheduledQueryArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let scheduledQueryArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scheduledQueryArn)
        scheduledQueryArn = scheduledQueryArnDecoded
    }
}

extension TimestreamQueryClientTypes.Row: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case data = "Data"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let data = data {
            var dataContainer = encodeContainer.nestedUnkeyedContainer(forKey: .data)
            for datum0 in data {
                try dataContainer.encode(datum0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataContainer = try containerValues.decodeIfPresent([TimestreamQueryClientTypes.Datum?].self, forKey: .data)
        var dataDecoded0:[TimestreamQueryClientTypes.Datum]? = nil
        if let dataContainer = dataContainer {
            dataDecoded0 = [TimestreamQueryClientTypes.Datum]()
            for structure0 in dataContainer {
                if let structure0 = structure0 {
                    dataDecoded0?.append(structure0)
                }
            }
        }
        data = dataDecoded0
    }
}

extension TimestreamQueryClientTypes {
    /// Represents a single row in the query results.
    public struct Row: Swift.Equatable {
        /// List of data points in a single row of the result set.
        /// This member is required.
        public var data: [TimestreamQueryClientTypes.Datum]?

        public init (
            data: [TimestreamQueryClientTypes.Datum]? = nil
        )
        {
            self.data = data
        }
    }

}

extension TimestreamQueryClientTypes.S3Configuration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketName = "BucketName"
        case encryptionOption = "EncryptionOption"
        case objectKeyPrefix = "ObjectKeyPrefix"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketName = self.bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
        if let encryptionOption = self.encryptionOption {
            try encodeContainer.encode(encryptionOption.rawValue, forKey: .encryptionOption)
        }
        if let objectKeyPrefix = self.objectKeyPrefix {
            try encodeContainer.encode(objectKeyPrefix, forKey: .objectKeyPrefix)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
        let objectKeyPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .objectKeyPrefix)
        objectKeyPrefix = objectKeyPrefixDecoded
        let encryptionOptionDecoded = try containerValues.decodeIfPresent(TimestreamQueryClientTypes.S3EncryptionOption.self, forKey: .encryptionOption)
        encryptionOption = encryptionOptionDecoded
    }
}

extension TimestreamQueryClientTypes {
    /// Details on S3 location for error reports that result from running a query.
    public struct S3Configuration: Swift.Equatable {
        /// Name of the S3 bucket under which error reports will be created.
        /// This member is required.
        public var bucketName: Swift.String?
        /// Encryption at rest options for the error reports. If no encryption option is specified, Timestream will choose SSE_S3 as default.
        public var encryptionOption: TimestreamQueryClientTypes.S3EncryptionOption?
        /// Prefix for the error report key. Timestream by default adds the following prefix to the error report path.
        public var objectKeyPrefix: Swift.String?

        public init (
            bucketName: Swift.String? = nil,
            encryptionOption: TimestreamQueryClientTypes.S3EncryptionOption? = nil,
            objectKeyPrefix: Swift.String? = nil
        )
        {
            self.bucketName = bucketName
            self.encryptionOption = encryptionOption
            self.objectKeyPrefix = objectKeyPrefix
        }
    }

}

extension TimestreamQueryClientTypes {
    public enum S3EncryptionOption: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case sseKms
        case sseS3
        case sdkUnknown(Swift.String)

        public static var allCases: [S3EncryptionOption] {
            return [
                .sseKms,
                .sseS3,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .sseKms: return "SSE_KMS"
            case .sseS3: return "SSE_S3"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = S3EncryptionOption(rawValue: rawValue) ?? S3EncryptionOption.sdkUnknown(rawValue)
        }
    }
}

extension TimestreamQueryClientTypes.S3ReportLocation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketName = "BucketName"
        case objectKey = "ObjectKey"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketName = self.bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
        if let objectKey = self.objectKey {
            try encodeContainer.encode(objectKey, forKey: .objectKey)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
        let objectKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .objectKey)
        objectKey = objectKeyDecoded
    }
}

extension TimestreamQueryClientTypes {
    /// S3 report location for the scheduled query run.
    public struct S3ReportLocation: Swift.Equatable {
        /// S3 bucket name.
        public var bucketName: Swift.String?
        /// S3 key.
        public var objectKey: Swift.String?

        public init (
            bucketName: Swift.String? = nil,
            objectKey: Swift.String? = nil
        )
        {
            self.bucketName = bucketName
            self.objectKey = objectKey
        }
    }

}

extension TimestreamQueryClientTypes {
    public enum ScalarMeasureValueType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case bigint
        case boolean
        case double
        case timestamp
        case varchar
        case sdkUnknown(Swift.String)

        public static var allCases: [ScalarMeasureValueType] {
            return [
                .bigint,
                .boolean,
                .double,
                .timestamp,
                .varchar,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .bigint: return "BIGINT"
            case .boolean: return "BOOLEAN"
            case .double: return "DOUBLE"
            case .timestamp: return "TIMESTAMP"
            case .varchar: return "VARCHAR"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ScalarMeasureValueType(rawValue: rawValue) ?? ScalarMeasureValueType.sdkUnknown(rawValue)
        }
    }
}

extension TimestreamQueryClientTypes {
    public enum ScalarType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case bigint
        case boolean
        case date
        case double
        case integer
        case intervalDayToSecond
        case intervalYearToMonth
        case time
        case timestamp
        case unknown
        case varchar
        case sdkUnknown(Swift.String)

        public static var allCases: [ScalarType] {
            return [
                .bigint,
                .boolean,
                .date,
                .double,
                .integer,
                .intervalDayToSecond,
                .intervalYearToMonth,
                .time,
                .timestamp,
                .unknown,
                .varchar,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .bigint: return "BIGINT"
            case .boolean: return "BOOLEAN"
            case .date: return "DATE"
            case .double: return "DOUBLE"
            case .integer: return "INTEGER"
            case .intervalDayToSecond: return "INTERVAL_DAY_TO_SECOND"
            case .intervalYearToMonth: return "INTERVAL_YEAR_TO_MONTH"
            case .time: return "TIME"
            case .timestamp: return "TIMESTAMP"
            case .unknown: return "UNKNOWN"
            case .varchar: return "VARCHAR"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ScalarType(rawValue: rawValue) ?? ScalarType.sdkUnknown(rawValue)
        }
    }
}

extension TimestreamQueryClientTypes.ScheduleConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case scheduleExpression = "ScheduleExpression"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let scheduleExpression = self.scheduleExpression {
            try encodeContainer.encode(scheduleExpression, forKey: .scheduleExpression)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scheduleExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scheduleExpression)
        scheduleExpression = scheduleExpressionDecoded
    }
}

extension TimestreamQueryClientTypes {
    /// Configuration of the schedule of the query.
    public struct ScheduleConfiguration: Swift.Equatable {
        /// An expression that denotes when to trigger the scheduled query run. This can be a cron expression or a rate expression.
        /// This member is required.
        public var scheduleExpression: Swift.String?

        public init (
            scheduleExpression: Swift.String? = nil
        )
        {
            self.scheduleExpression = scheduleExpression
        }
    }

}

extension TimestreamQueryClientTypes.ScheduledQuery: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationTime = "CreationTime"
        case errorReportConfiguration = "ErrorReportConfiguration"
        case lastRunStatus = "LastRunStatus"
        case name = "Name"
        case nextInvocationTime = "NextInvocationTime"
        case previousInvocationTime = "PreviousInvocationTime"
        case state = "State"
        case targetDestination = "TargetDestination"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let errorReportConfiguration = self.errorReportConfiguration {
            try encodeContainer.encode(errorReportConfiguration, forKey: .errorReportConfiguration)
        }
        if let lastRunStatus = self.lastRunStatus {
            try encodeContainer.encode(lastRunStatus.rawValue, forKey: .lastRunStatus)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let nextInvocationTime = self.nextInvocationTime {
            try encodeContainer.encodeTimestamp(nextInvocationTime, format: .epochSeconds, forKey: .nextInvocationTime)
        }
        if let previousInvocationTime = self.previousInvocationTime {
            try encodeContainer.encodeTimestamp(previousInvocationTime, format: .epochSeconds, forKey: .previousInvocationTime)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let targetDestination = self.targetDestination {
            try encodeContainer.encode(targetDestination, forKey: .targetDestination)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let stateDecoded = try containerValues.decodeIfPresent(TimestreamQueryClientTypes.ScheduledQueryState.self, forKey: .state)
        state = stateDecoded
        let previousInvocationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .previousInvocationTime)
        previousInvocationTime = previousInvocationTimeDecoded
        let nextInvocationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .nextInvocationTime)
        nextInvocationTime = nextInvocationTimeDecoded
        let errorReportConfigurationDecoded = try containerValues.decodeIfPresent(TimestreamQueryClientTypes.ErrorReportConfiguration.self, forKey: .errorReportConfiguration)
        errorReportConfiguration = errorReportConfigurationDecoded
        let targetDestinationDecoded = try containerValues.decodeIfPresent(TimestreamQueryClientTypes.TargetDestination.self, forKey: .targetDestination)
        targetDestination = targetDestinationDecoded
        let lastRunStatusDecoded = try containerValues.decodeIfPresent(TimestreamQueryClientTypes.ScheduledQueryRunStatus.self, forKey: .lastRunStatus)
        lastRunStatus = lastRunStatusDecoded
    }
}

extension TimestreamQueryClientTypes {
    /// Scheduled Query
    public struct ScheduledQuery: Swift.Equatable {
        /// The Amazon Resource Name.
        /// This member is required.
        public var arn: Swift.String?
        /// The creation time of the scheduled query.
        public var creationTime: ClientRuntime.Date?
        /// Configuration for scheduled query error reporting.
        public var errorReportConfiguration: TimestreamQueryClientTypes.ErrorReportConfiguration?
        /// Status of the last scheduled query run.
        public var lastRunStatus: TimestreamQueryClientTypes.ScheduledQueryRunStatus?
        /// The name of the scheduled query.
        /// This member is required.
        public var name: Swift.String?
        /// The next time the scheduled query is to be run.
        public var nextInvocationTime: ClientRuntime.Date?
        /// The last time the scheduled query was run.
        public var previousInvocationTime: ClientRuntime.Date?
        /// State of scheduled query.
        /// This member is required.
        public var state: TimestreamQueryClientTypes.ScheduledQueryState?
        /// Target data source where final scheduled query result will be written.
        public var targetDestination: TimestreamQueryClientTypes.TargetDestination?

        public init (
            arn: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            errorReportConfiguration: TimestreamQueryClientTypes.ErrorReportConfiguration? = nil,
            lastRunStatus: TimestreamQueryClientTypes.ScheduledQueryRunStatus? = nil,
            name: Swift.String? = nil,
            nextInvocationTime: ClientRuntime.Date? = nil,
            previousInvocationTime: ClientRuntime.Date? = nil,
            state: TimestreamQueryClientTypes.ScheduledQueryState? = nil,
            targetDestination: TimestreamQueryClientTypes.TargetDestination? = nil
        )
        {
            self.arn = arn
            self.creationTime = creationTime
            self.errorReportConfiguration = errorReportConfiguration
            self.lastRunStatus = lastRunStatus
            self.name = name
            self.nextInvocationTime = nextInvocationTime
            self.previousInvocationTime = previousInvocationTime
            self.state = state
            self.targetDestination = targetDestination
        }
    }

}

extension TimestreamQueryClientTypes.ScheduledQueryDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationTime = "CreationTime"
        case errorReportConfiguration = "ErrorReportConfiguration"
        case kmsKeyId = "KmsKeyId"
        case lastRunSummary = "LastRunSummary"
        case name = "Name"
        case nextInvocationTime = "NextInvocationTime"
        case notificationConfiguration = "NotificationConfiguration"
        case previousInvocationTime = "PreviousInvocationTime"
        case queryString = "QueryString"
        case recentlyFailedRuns = "RecentlyFailedRuns"
        case scheduleConfiguration = "ScheduleConfiguration"
        case scheduledQueryExecutionRoleArn = "ScheduledQueryExecutionRoleArn"
        case state = "State"
        case targetConfiguration = "TargetConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let errorReportConfiguration = self.errorReportConfiguration {
            try encodeContainer.encode(errorReportConfiguration, forKey: .errorReportConfiguration)
        }
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let lastRunSummary = self.lastRunSummary {
            try encodeContainer.encode(lastRunSummary, forKey: .lastRunSummary)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let nextInvocationTime = self.nextInvocationTime {
            try encodeContainer.encodeTimestamp(nextInvocationTime, format: .epochSeconds, forKey: .nextInvocationTime)
        }
        if let notificationConfiguration = self.notificationConfiguration {
            try encodeContainer.encode(notificationConfiguration, forKey: .notificationConfiguration)
        }
        if let previousInvocationTime = self.previousInvocationTime {
            try encodeContainer.encodeTimestamp(previousInvocationTime, format: .epochSeconds, forKey: .previousInvocationTime)
        }
        if let queryString = self.queryString {
            try encodeContainer.encode(queryString, forKey: .queryString)
        }
        if let recentlyFailedRuns = recentlyFailedRuns {
            var recentlyFailedRunsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .recentlyFailedRuns)
            for scheduledqueryrunsummary0 in recentlyFailedRuns {
                try recentlyFailedRunsContainer.encode(scheduledqueryrunsummary0)
            }
        }
        if let scheduleConfiguration = self.scheduleConfiguration {
            try encodeContainer.encode(scheduleConfiguration, forKey: .scheduleConfiguration)
        }
        if let scheduledQueryExecutionRoleArn = self.scheduledQueryExecutionRoleArn {
            try encodeContainer.encode(scheduledQueryExecutionRoleArn, forKey: .scheduledQueryExecutionRoleArn)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let targetConfiguration = self.targetConfiguration {
            try encodeContainer.encode(targetConfiguration, forKey: .targetConfiguration)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let queryStringDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryString)
        queryString = queryStringDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let stateDecoded = try containerValues.decodeIfPresent(TimestreamQueryClientTypes.ScheduledQueryState.self, forKey: .state)
        state = stateDecoded
        let previousInvocationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .previousInvocationTime)
        previousInvocationTime = previousInvocationTimeDecoded
        let nextInvocationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .nextInvocationTime)
        nextInvocationTime = nextInvocationTimeDecoded
        let scheduleConfigurationDecoded = try containerValues.decodeIfPresent(TimestreamQueryClientTypes.ScheduleConfiguration.self, forKey: .scheduleConfiguration)
        scheduleConfiguration = scheduleConfigurationDecoded
        let notificationConfigurationDecoded = try containerValues.decodeIfPresent(TimestreamQueryClientTypes.NotificationConfiguration.self, forKey: .notificationConfiguration)
        notificationConfiguration = notificationConfigurationDecoded
        let targetConfigurationDecoded = try containerValues.decodeIfPresent(TimestreamQueryClientTypes.TargetConfiguration.self, forKey: .targetConfiguration)
        targetConfiguration = targetConfigurationDecoded
        let scheduledQueryExecutionRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scheduledQueryExecutionRoleArn)
        scheduledQueryExecutionRoleArn = scheduledQueryExecutionRoleArnDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let errorReportConfigurationDecoded = try containerValues.decodeIfPresent(TimestreamQueryClientTypes.ErrorReportConfiguration.self, forKey: .errorReportConfiguration)
        errorReportConfiguration = errorReportConfigurationDecoded
        let lastRunSummaryDecoded = try containerValues.decodeIfPresent(TimestreamQueryClientTypes.ScheduledQueryRunSummary.self, forKey: .lastRunSummary)
        lastRunSummary = lastRunSummaryDecoded
        let recentlyFailedRunsContainer = try containerValues.decodeIfPresent([TimestreamQueryClientTypes.ScheduledQueryRunSummary?].self, forKey: .recentlyFailedRuns)
        var recentlyFailedRunsDecoded0:[TimestreamQueryClientTypes.ScheduledQueryRunSummary]? = nil
        if let recentlyFailedRunsContainer = recentlyFailedRunsContainer {
            recentlyFailedRunsDecoded0 = [TimestreamQueryClientTypes.ScheduledQueryRunSummary]()
            for structure0 in recentlyFailedRunsContainer {
                if let structure0 = structure0 {
                    recentlyFailedRunsDecoded0?.append(structure0)
                }
            }
        }
        recentlyFailedRuns = recentlyFailedRunsDecoded0
    }
}

extension TimestreamQueryClientTypes.ScheduledQueryDescription: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ScheduledQueryDescription(arn: \(Swift.String(describing: arn)), creationTime: \(Swift.String(describing: creationTime)), errorReportConfiguration: \(Swift.String(describing: errorReportConfiguration)), kmsKeyId: \(Swift.String(describing: kmsKeyId)), lastRunSummary: \(Swift.String(describing: lastRunSummary)), name: \(Swift.String(describing: name)), nextInvocationTime: \(Swift.String(describing: nextInvocationTime)), notificationConfiguration: \(Swift.String(describing: notificationConfiguration)), previousInvocationTime: \(Swift.String(describing: previousInvocationTime)), recentlyFailedRuns: \(Swift.String(describing: recentlyFailedRuns)), scheduleConfiguration: \(Swift.String(describing: scheduleConfiguration)), scheduledQueryExecutionRoleArn: \(Swift.String(describing: scheduledQueryExecutionRoleArn)), state: \(Swift.String(describing: state)), targetConfiguration: \(Swift.String(describing: targetConfiguration)), queryString: \"CONTENT_REDACTED\")"}
}

extension TimestreamQueryClientTypes {
    /// Structure that describes scheduled query.
    public struct ScheduledQueryDescription: Swift.Equatable {
        /// Scheduled query ARN.
        /// This member is required.
        public var arn: Swift.String?
        /// Creation time of the scheduled query.
        public var creationTime: ClientRuntime.Date?
        /// Error-reporting configuration for the scheduled query.
        public var errorReportConfiguration: TimestreamQueryClientTypes.ErrorReportConfiguration?
        /// A customer provided KMS key used to encrypt the scheduled query resource.
        public var kmsKeyId: Swift.String?
        /// Runtime summary for the last scheduled query run.
        public var lastRunSummary: TimestreamQueryClientTypes.ScheduledQueryRunSummary?
        /// Name of the scheduled query.
        /// This member is required.
        public var name: Swift.String?
        /// The next time the scheduled query is scheduled to run.
        public var nextInvocationTime: ClientRuntime.Date?
        /// Notification configuration.
        /// This member is required.
        public var notificationConfiguration: TimestreamQueryClientTypes.NotificationConfiguration?
        /// Last time the query was run.
        public var previousInvocationTime: ClientRuntime.Date?
        /// The query to be run.
        /// This member is required.
        public var queryString: Swift.String?
        /// Runtime summary for the last five failed scheduled query runs.
        public var recentlyFailedRuns: [TimestreamQueryClientTypes.ScheduledQueryRunSummary]?
        /// Schedule configuration.
        /// This member is required.
        public var scheduleConfiguration: TimestreamQueryClientTypes.ScheduleConfiguration?
        /// IAM role that Timestream uses to run the schedule query.
        public var scheduledQueryExecutionRoleArn: Swift.String?
        /// State of the scheduled query.
        /// This member is required.
        public var state: TimestreamQueryClientTypes.ScheduledQueryState?
        /// Scheduled query target store configuration.
        public var targetConfiguration: TimestreamQueryClientTypes.TargetConfiguration?

        public init (
            arn: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            errorReportConfiguration: TimestreamQueryClientTypes.ErrorReportConfiguration? = nil,
            kmsKeyId: Swift.String? = nil,
            lastRunSummary: TimestreamQueryClientTypes.ScheduledQueryRunSummary? = nil,
            name: Swift.String? = nil,
            nextInvocationTime: ClientRuntime.Date? = nil,
            notificationConfiguration: TimestreamQueryClientTypes.NotificationConfiguration? = nil,
            previousInvocationTime: ClientRuntime.Date? = nil,
            queryString: Swift.String? = nil,
            recentlyFailedRuns: [TimestreamQueryClientTypes.ScheduledQueryRunSummary]? = nil,
            scheduleConfiguration: TimestreamQueryClientTypes.ScheduleConfiguration? = nil,
            scheduledQueryExecutionRoleArn: Swift.String? = nil,
            state: TimestreamQueryClientTypes.ScheduledQueryState? = nil,
            targetConfiguration: TimestreamQueryClientTypes.TargetConfiguration? = nil
        )
        {
            self.arn = arn
            self.creationTime = creationTime
            self.errorReportConfiguration = errorReportConfiguration
            self.kmsKeyId = kmsKeyId
            self.lastRunSummary = lastRunSummary
            self.name = name
            self.nextInvocationTime = nextInvocationTime
            self.notificationConfiguration = notificationConfiguration
            self.previousInvocationTime = previousInvocationTime
            self.queryString = queryString
            self.recentlyFailedRuns = recentlyFailedRuns
            self.scheduleConfiguration = scheduleConfiguration
            self.scheduledQueryExecutionRoleArn = scheduledQueryExecutionRoleArn
            self.state = state
            self.targetConfiguration = targetConfiguration
        }
    }

}

extension TimestreamQueryClientTypes {
    public enum ScheduledQueryRunStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case autoTriggerFailure
        case autoTriggerSuccess
        case manualTriggerFailure
        case manualTriggerSuccess
        case sdkUnknown(Swift.String)

        public static var allCases: [ScheduledQueryRunStatus] {
            return [
                .autoTriggerFailure,
                .autoTriggerSuccess,
                .manualTriggerFailure,
                .manualTriggerSuccess,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .autoTriggerFailure: return "AUTO_TRIGGER_FAILURE"
            case .autoTriggerSuccess: return "AUTO_TRIGGER_SUCCESS"
            case .manualTriggerFailure: return "MANUAL_TRIGGER_FAILURE"
            case .manualTriggerSuccess: return "MANUAL_TRIGGER_SUCCESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ScheduledQueryRunStatus(rawValue: rawValue) ?? ScheduledQueryRunStatus.sdkUnknown(rawValue)
        }
    }
}

extension TimestreamQueryClientTypes.ScheduledQueryRunSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorReportLocation = "ErrorReportLocation"
        case executionStats = "ExecutionStats"
        case failureReason = "FailureReason"
        case invocationTime = "InvocationTime"
        case runStatus = "RunStatus"
        case triggerTime = "TriggerTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorReportLocation = self.errorReportLocation {
            try encodeContainer.encode(errorReportLocation, forKey: .errorReportLocation)
        }
        if let executionStats = self.executionStats {
            try encodeContainer.encode(executionStats, forKey: .executionStats)
        }
        if let failureReason = self.failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let invocationTime = self.invocationTime {
            try encodeContainer.encodeTimestamp(invocationTime, format: .epochSeconds, forKey: .invocationTime)
        }
        if let runStatus = self.runStatus {
            try encodeContainer.encode(runStatus.rawValue, forKey: .runStatus)
        }
        if let triggerTime = self.triggerTime {
            try encodeContainer.encodeTimestamp(triggerTime, format: .epochSeconds, forKey: .triggerTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let invocationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .invocationTime)
        invocationTime = invocationTimeDecoded
        let triggerTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .triggerTime)
        triggerTime = triggerTimeDecoded
        let runStatusDecoded = try containerValues.decodeIfPresent(TimestreamQueryClientTypes.ScheduledQueryRunStatus.self, forKey: .runStatus)
        runStatus = runStatusDecoded
        let executionStatsDecoded = try containerValues.decodeIfPresent(TimestreamQueryClientTypes.ExecutionStats.self, forKey: .executionStats)
        executionStats = executionStatsDecoded
        let errorReportLocationDecoded = try containerValues.decodeIfPresent(TimestreamQueryClientTypes.ErrorReportLocation.self, forKey: .errorReportLocation)
        errorReportLocation = errorReportLocationDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
    }
}

extension TimestreamQueryClientTypes {
    /// Run summary for the scheduled query
    public struct ScheduledQueryRunSummary: Swift.Equatable {
        /// S3 location for error report.
        public var errorReportLocation: TimestreamQueryClientTypes.ErrorReportLocation?
        /// Runtime statistics for a scheduled run.
        public var executionStats: TimestreamQueryClientTypes.ExecutionStats?
        /// Error message for the scheduled query in case of failure. You might have to look at the error report to get more detailed error reasons.
        public var failureReason: Swift.String?
        /// InvocationTime for this run. This is the time at which the query is scheduled to run. Parameter @scheduled_runtime can be used in the query to get the value.
        public var invocationTime: ClientRuntime.Date?
        /// The status of a scheduled query run.
        public var runStatus: TimestreamQueryClientTypes.ScheduledQueryRunStatus?
        /// The actual time when the query was run.
        public var triggerTime: ClientRuntime.Date?

        public init (
            errorReportLocation: TimestreamQueryClientTypes.ErrorReportLocation? = nil,
            executionStats: TimestreamQueryClientTypes.ExecutionStats? = nil,
            failureReason: Swift.String? = nil,
            invocationTime: ClientRuntime.Date? = nil,
            runStatus: TimestreamQueryClientTypes.ScheduledQueryRunStatus? = nil,
            triggerTime: ClientRuntime.Date? = nil
        )
        {
            self.errorReportLocation = errorReportLocation
            self.executionStats = executionStats
            self.failureReason = failureReason
            self.invocationTime = invocationTime
            self.runStatus = runStatus
            self.triggerTime = triggerTime
        }
    }

}

extension TimestreamQueryClientTypes {
    public enum ScheduledQueryState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [ScheduledQueryState] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ScheduledQueryState(rawValue: rawValue) ?? ScheduledQueryState.sdkUnknown(rawValue)
        }
    }
}

extension TimestreamQueryClientTypes.SelectColumn: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aliased = "Aliased"
        case databaseName = "DatabaseName"
        case name = "Name"
        case tableName = "TableName"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aliased = self.aliased {
            try encodeContainer.encode(aliased, forKey: .aliased)
        }
        if let databaseName = self.databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tableName = self.tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(TimestreamQueryClientTypes.ModelType.self, forKey: .type)
        type = typeDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let tableNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tableName)
        tableName = tableNameDecoded
        let aliasedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .aliased)
        aliased = aliasedDecoded
    }
}

extension TimestreamQueryClientTypes {
    /// Details of the column that is returned by the query.
    public struct SelectColumn: Swift.Equatable {
        /// True, if the column name was aliased by the query. False otherwise.
        public var aliased: Swift.Bool?
        /// Database that has this column.
        public var databaseName: Swift.String?
        /// Name of the column.
        public var name: Swift.String?
        /// Table within the database that has this column.
        public var tableName: Swift.String?
        /// Contains the data type of a column in a query result set. The data type can be scalar or complex. The supported scalar data types are integers, Boolean, string, double, timestamp, date, time, and intervals. The supported complex data types are arrays, rows, and timeseries.
        public var type: TimestreamQueryClientTypes.ModelType?

        public init (
            aliased: Swift.Bool? = nil,
            databaseName: Swift.String? = nil,
            name: Swift.String? = nil,
            tableName: Swift.String? = nil,
            type: TimestreamQueryClientTypes.ModelType? = nil
        )
        {
            self.aliased = aliased
            self.databaseName = databaseName
            self.name = name
            self.tableName = tableName
            self.type = type
        }
    }

}

extension ServiceQuotaExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You have exceeded the service quota.
public struct ServiceQuotaExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TimestreamQueryClientTypes.SnsConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case topicArn = "TopicArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let topicArn = self.topicArn {
            try encodeContainer.encode(topicArn, forKey: .topicArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let topicArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .topicArn)
        topicArn = topicArnDecoded
    }
}

extension TimestreamQueryClientTypes {
    /// Details on SNS that are required to send the notification.
    public struct SnsConfiguration: Swift.Equatable {
        /// SNS topic ARN that the scheduled query status notifications will be sent to.
        /// This member is required.
        public var topicArn: Swift.String?

        public init (
            topicArn: Swift.String? = nil
        )
        {
            self.topicArn = topicArn
        }
    }

}

extension TimestreamQueryClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension TimestreamQueryClientTypes {
    /// A tag is a label that you assign to a Timestream database and/or table. Each tag consists of a key and an optional value, both of which you define. Tags enable you to categorize databases and/or tables, for example, by purpose, owner, or environment.
    public struct Tag: Swift.Equatable {
        /// The key of the tag. Tag keys are case sensitive.
        /// This member is required.
        public var key: Swift.String?
        /// The value of the tag. Tag values are case sensitive and can be null.
        /// This member is required.
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// Identifies the Timestream resource to which tags should be added. This value is an Amazon Resource Name (ARN).
    /// This member is required.
    public var resourceARN: Swift.String?
    /// The tags to be assigned to the Timestream resource.
    /// This member is required.
    public var tags: [TimestreamQueryClientTypes.Tag]?

    public init (
        resourceARN: Swift.String? = nil,
        tags: [TimestreamQueryClientTypes.Tag]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let resourceARN: Swift.String?
    let tags: [TimestreamQueryClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagsContainer = try containerValues.decodeIfPresent([TimestreamQueryClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[TimestreamQueryClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [TimestreamQueryClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidEndpointException" : self = .invalidEndpointException(try InvalidEndpointException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case invalidEndpointException(InvalidEndpointException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension TimestreamQueryClientTypes.TargetConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case timestreamConfiguration = "TimestreamConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let timestreamConfiguration = self.timestreamConfiguration {
            try encodeContainer.encode(timestreamConfiguration, forKey: .timestreamConfiguration)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timestreamConfigurationDecoded = try containerValues.decodeIfPresent(TimestreamQueryClientTypes.TimestreamConfiguration.self, forKey: .timestreamConfiguration)
        timestreamConfiguration = timestreamConfigurationDecoded
    }
}

extension TimestreamQueryClientTypes {
    /// Configuration used for writing the output of a query.
    public struct TargetConfiguration: Swift.Equatable {
        /// Configuration needed to write data into the Timestream database and table.
        /// This member is required.
        public var timestreamConfiguration: TimestreamQueryClientTypes.TimestreamConfiguration?

        public init (
            timestreamConfiguration: TimestreamQueryClientTypes.TimestreamConfiguration? = nil
        )
        {
            self.timestreamConfiguration = timestreamConfiguration
        }
    }

}

extension TimestreamQueryClientTypes.TargetDestination: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case timestreamDestination = "TimestreamDestination"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let timestreamDestination = self.timestreamDestination {
            try encodeContainer.encode(timestreamDestination, forKey: .timestreamDestination)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timestreamDestinationDecoded = try containerValues.decodeIfPresent(TimestreamQueryClientTypes.TimestreamDestination.self, forKey: .timestreamDestination)
        timestreamDestination = timestreamDestinationDecoded
    }
}

extension TimestreamQueryClientTypes {
    /// Destination details to write data for a target data source. Current supported data source is Timestream.
    public struct TargetDestination: Swift.Equatable {
        /// Query result destination details for Timestream data source.
        public var timestreamDestination: TimestreamQueryClientTypes.TimestreamDestination?

        public init (
            timestreamDestination: TimestreamQueryClientTypes.TimestreamDestination? = nil
        )
        {
            self.timestreamDestination = timestreamDestination
        }
    }

}

extension ThrottlingException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request was denied due to request throttling.
public struct ThrottlingException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TimestreamQueryClientTypes.TimeSeriesDataPoint: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case time = "Time"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let time = self.time {
            try encodeContainer.encode(time, forKey: .time)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .time)
        time = timeDecoded
        let valueDecoded = try containerValues.decodeIfPresent(TimestreamQueryClientTypes.Datum.self, forKey: .value)
        value = valueDecoded
    }
}

extension TimestreamQueryClientTypes {
    /// The timeseries data type represents the values of a measure over time. A time series is an array of rows of timestamps and measure values, with rows sorted in ascending order of time. A TimeSeriesDataPoint is a single data point in the time series. It represents a tuple of (time, measure value) in a time series.
    public struct TimeSeriesDataPoint: Swift.Equatable {
        /// The timestamp when the measure value was collected.
        /// This member is required.
        public var time: Swift.String?
        /// The measure value for the data point.
        /// This member is required.
        public var value: TimestreamQueryClientTypes.Datum?

        public init (
            time: Swift.String? = nil,
            value: TimestreamQueryClientTypes.Datum? = nil
        )
        {
            self.time = time
            self.value = value
        }
    }

}

extension TimestreamQueryClientTypes.TimestreamConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case databaseName = "DatabaseName"
        case dimensionMappings = "DimensionMappings"
        case measureNameColumn = "MeasureNameColumn"
        case mixedMeasureMappings = "MixedMeasureMappings"
        case multiMeasureMappings = "MultiMeasureMappings"
        case tableName = "TableName"
        case timeColumn = "TimeColumn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let databaseName = self.databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let dimensionMappings = dimensionMappings {
            var dimensionMappingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dimensionMappings)
            for dimensionmapping0 in dimensionMappings {
                try dimensionMappingsContainer.encode(dimensionmapping0)
            }
        }
        if let measureNameColumn = self.measureNameColumn {
            try encodeContainer.encode(measureNameColumn, forKey: .measureNameColumn)
        }
        if let mixedMeasureMappings = mixedMeasureMappings {
            var mixedMeasureMappingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .mixedMeasureMappings)
            for mixedmeasuremapping0 in mixedMeasureMappings {
                try mixedMeasureMappingsContainer.encode(mixedmeasuremapping0)
            }
        }
        if let multiMeasureMappings = self.multiMeasureMappings {
            try encodeContainer.encode(multiMeasureMappings, forKey: .multiMeasureMappings)
        }
        if let tableName = self.tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
        if let timeColumn = self.timeColumn {
            try encodeContainer.encode(timeColumn, forKey: .timeColumn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let tableNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tableName)
        tableName = tableNameDecoded
        let timeColumnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timeColumn)
        timeColumn = timeColumnDecoded
        let dimensionMappingsContainer = try containerValues.decodeIfPresent([TimestreamQueryClientTypes.DimensionMapping?].self, forKey: .dimensionMappings)
        var dimensionMappingsDecoded0:[TimestreamQueryClientTypes.DimensionMapping]? = nil
        if let dimensionMappingsContainer = dimensionMappingsContainer {
            dimensionMappingsDecoded0 = [TimestreamQueryClientTypes.DimensionMapping]()
            for structure0 in dimensionMappingsContainer {
                if let structure0 = structure0 {
                    dimensionMappingsDecoded0?.append(structure0)
                }
            }
        }
        dimensionMappings = dimensionMappingsDecoded0
        let multiMeasureMappingsDecoded = try containerValues.decodeIfPresent(TimestreamQueryClientTypes.MultiMeasureMappings.self, forKey: .multiMeasureMappings)
        multiMeasureMappings = multiMeasureMappingsDecoded
        let mixedMeasureMappingsContainer = try containerValues.decodeIfPresent([TimestreamQueryClientTypes.MixedMeasureMapping?].self, forKey: .mixedMeasureMappings)
        var mixedMeasureMappingsDecoded0:[TimestreamQueryClientTypes.MixedMeasureMapping]? = nil
        if let mixedMeasureMappingsContainer = mixedMeasureMappingsContainer {
            mixedMeasureMappingsDecoded0 = [TimestreamQueryClientTypes.MixedMeasureMapping]()
            for structure0 in mixedMeasureMappingsContainer {
                if let structure0 = structure0 {
                    mixedMeasureMappingsDecoded0?.append(structure0)
                }
            }
        }
        mixedMeasureMappings = mixedMeasureMappingsDecoded0
        let measureNameColumnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .measureNameColumn)
        measureNameColumn = measureNameColumnDecoded
    }
}

extension TimestreamQueryClientTypes {
    /// Configuration to write data into Timestream database and table. This configuration allows the user to map the query result select columns into the destination table columns.
    public struct TimestreamConfiguration: Swift.Equatable {
        /// Name of Timestream database to which the query result will be written.
        /// This member is required.
        public var databaseName: Swift.String?
        /// This is to allow mapping column(s) from the query result to the dimension in the destination table.
        /// This member is required.
        public var dimensionMappings: [TimestreamQueryClientTypes.DimensionMapping]?
        /// Name of the measure column.
        public var measureNameColumn: Swift.String?
        /// Specifies how to map measures to multi-measure records.
        public var mixedMeasureMappings: [TimestreamQueryClientTypes.MixedMeasureMapping]?
        /// Multi-measure mappings.
        public var multiMeasureMappings: TimestreamQueryClientTypes.MultiMeasureMappings?
        /// Name of Timestream table that the query result will be written to. The table should be within the same database that is provided in Timestream configuration.
        /// This member is required.
        public var tableName: Swift.String?
        /// Column from query result that should be used as the time column in destination table. Column type for this should be TIMESTAMP.
        /// This member is required.
        public var timeColumn: Swift.String?

        public init (
            databaseName: Swift.String? = nil,
            dimensionMappings: [TimestreamQueryClientTypes.DimensionMapping]? = nil,
            measureNameColumn: Swift.String? = nil,
            mixedMeasureMappings: [TimestreamQueryClientTypes.MixedMeasureMapping]? = nil,
            multiMeasureMappings: TimestreamQueryClientTypes.MultiMeasureMappings? = nil,
            tableName: Swift.String? = nil,
            timeColumn: Swift.String? = nil
        )
        {
            self.databaseName = databaseName
            self.dimensionMappings = dimensionMappings
            self.measureNameColumn = measureNameColumn
            self.mixedMeasureMappings = mixedMeasureMappings
            self.multiMeasureMappings = multiMeasureMappings
            self.tableName = tableName
            self.timeColumn = timeColumn
        }
    }

}

extension TimestreamQueryClientTypes.TimestreamDestination: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case databaseName = "DatabaseName"
        case tableName = "TableName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let databaseName = self.databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let tableName = self.tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let tableNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tableName)
        tableName = tableNameDecoded
    }
}

extension TimestreamQueryClientTypes {
    /// Destination for scheduled query.
    public struct TimestreamDestination: Swift.Equatable {
        /// Timestream database name.
        public var databaseName: Swift.String?
        /// Timestream table name.
        public var tableName: Swift.String?

        public init (
            databaseName: Swift.String? = nil,
            tableName: Swift.String? = nil
        )
        {
            self.databaseName = databaseName
            self.tableName = tableName
        }
    }

}

extension TimestreamQueryClientTypes {
    /// Contains the data type of a column in a query result set. The data type can be scalar or complex. The supported scalar data types are integers, Boolean, string, double, timestamp, date, time, and intervals. The supported complex data types are arrays, rows, and timeseries.
    public struct ModelType: Swift.Equatable {
        /// Indicates if the column is an array.
        public var arrayColumnInfo: TimestreamQueryClientTypes.ColumnInfo?
        /// Indicates if the column is a row.
        public var rowColumnInfo: [TimestreamQueryClientTypes.ColumnInfo]?
        /// Indicates if the column is of type string, integer, Boolean, double, timestamp, date, time.
        public var scalarType: TimestreamQueryClientTypes.ScalarType?
        /// Indicates if the column is a timeseries data type.
        public var timeSeriesMeasureValueColumnInfo: TimestreamQueryClientTypes.ColumnInfo?

        public init (
            arrayColumnInfo: TimestreamQueryClientTypes.ColumnInfo? = nil,
            rowColumnInfo: [TimestreamQueryClientTypes.ColumnInfo]? = nil,
            scalarType: TimestreamQueryClientTypes.ScalarType? = nil,
            timeSeriesMeasureValueColumnInfo: TimestreamQueryClientTypes.ColumnInfo? = nil
        )
        {
            self.arrayColumnInfo = arrayColumnInfo
            self.rowColumnInfo = rowColumnInfo
            self.scalarType = scalarType
            self.timeSeriesMeasureValueColumnInfo = timeSeriesMeasureValueColumnInfo
        }
    }

}

extension UntagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkey0 in tagKeys {
                try tagKeysContainer.encode(tagkey0)
            }
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Timestream resource that the tags will be removed from. This value is an Amazon Resource Name (ARN).
    /// This member is required.
    public var resourceARN: Swift.String?
    /// A list of tags keys. Existing tags of the resource whose keys are members of this list will be removed from the Timestream resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceARN: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    let resourceARN: Swift.String?
    let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidEndpointException" : self = .invalidEndpointException(try InvalidEndpointException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case invalidEndpointException(InvalidEndpointException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateScheduledQueryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case scheduledQueryArn = "ScheduledQueryArn"
        case state = "State"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let scheduledQueryArn = self.scheduledQueryArn {
            try encodeContainer.encode(scheduledQueryArn, forKey: .scheduledQueryArn)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }
}

extension UpdateScheduledQueryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateScheduledQueryInput: Swift.Equatable {
    /// ARN of the scheuled query.
    /// This member is required.
    public var scheduledQueryArn: Swift.String?
    /// State of the scheduled query.
    /// This member is required.
    public var state: TimestreamQueryClientTypes.ScheduledQueryState?

    public init (
        scheduledQueryArn: Swift.String? = nil,
        state: TimestreamQueryClientTypes.ScheduledQueryState? = nil
    )
    {
        self.scheduledQueryArn = scheduledQueryArn
        self.state = state
    }
}

struct UpdateScheduledQueryInputBody: Swift.Equatable {
    let scheduledQueryArn: Swift.String?
    let state: TimestreamQueryClientTypes.ScheduledQueryState?
}

extension UpdateScheduledQueryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case scheduledQueryArn = "ScheduledQueryArn"
        case state = "State"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scheduledQueryArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scheduledQueryArn)
        scheduledQueryArn = scheduledQueryArnDecoded
        let stateDecoded = try containerValues.decodeIfPresent(TimestreamQueryClientTypes.ScheduledQueryState.self, forKey: .state)
        state = stateDecoded
    }
}

extension UpdateScheduledQueryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateScheduledQueryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidEndpointException" : self = .invalidEndpointException(try InvalidEndpointException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateScheduledQueryOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case invalidEndpointException(InvalidEndpointException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateScheduledQueryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateScheduledQueryOutputResponse: Swift.Equatable {

    public init () { }
}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Invalid or malformed request.
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
