// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccessDeniedException(message: \(String(describing: message)))"}
}

extension AccessDeniedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You do not have sufficient access to perform this action.</p>
public struct AccessDeniedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Equatable {
    public let message: String?
}

extension AccessDeniedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct CreateHomeRegionControlInputBodyMiddleware: Middleware {
    public let id: String = "CreateHomeRegionControlInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateHomeRegionControlInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateHomeRegionControlOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateHomeRegionControlInput>
    public typealias MOutput = OperationOutput<CreateHomeRegionControlOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateHomeRegionControlOutputError>
}

extension CreateHomeRegionControlInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateHomeRegionControlInput(dryRun: \(String(describing: dryRun)), homeRegion: \(String(describing: homeRegion)), target: \(String(describing: target)))"}
}

extension CreateHomeRegionControlInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case homeRegion = "HomeRegion"
        case target = "Target"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if dryRun != false {
            try encodeContainer.encode(dryRun, forKey: .dryRun)
        }
        if let homeRegion = homeRegion {
            try encodeContainer.encode(homeRegion, forKey: .homeRegion)
        }
        if let target = target {
            try encodeContainer.encode(target, forKey: .target)
        }
    }
}

public struct CreateHomeRegionControlInputHeadersMiddleware: Middleware {
    public let id: String = "CreateHomeRegionControlInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateHomeRegionControlInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateHomeRegionControlOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateHomeRegionControlInput>
    public typealias MOutput = OperationOutput<CreateHomeRegionControlOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateHomeRegionControlOutputError>
}

public struct CreateHomeRegionControlInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateHomeRegionControlInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateHomeRegionControlInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateHomeRegionControlOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateHomeRegionControlInput>
    public typealias MOutput = OperationOutput<CreateHomeRegionControlOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateHomeRegionControlOutputError>
}

public struct CreateHomeRegionControlInput: Equatable {
    /// <p>Optional Boolean flag to indicate whether any effect should take place. It tests whether
    ///       the caller has permission to make the call.</p>
    public let dryRun: Bool
    /// <p>The name of the home region of the calling account.</p>
    public let homeRegion: String?
    /// <p>The account for which this command sets up a home region control. The <code>Target</code>
    ///       is always of type <code>ACCOUNT</code>.</p>
    public let target: Target?

    public init (
        dryRun: Bool = false,
        homeRegion: String? = nil,
        target: Target? = nil
    )
    {
        self.dryRun = dryRun
        self.homeRegion = homeRegion
        self.target = target
    }
}

struct CreateHomeRegionControlInputBody: Equatable {
    public let homeRegion: String?
    public let target: Target?
    public let dryRun: Bool
}

extension CreateHomeRegionControlInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case homeRegion = "HomeRegion"
        case target = "Target"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let homeRegionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .homeRegion)
        homeRegion = homeRegionDecoded
        let targetDecoded = try containerValues.decodeIfPresent(Target.self, forKey: .target)
        target = targetDecoded
        let dryRunDecoded = try containerValues.decode(Bool.self, forKey: .dryRun)
        dryRun = dryRunDecoded
    }
}

extension CreateHomeRegionControlOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateHomeRegionControlOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DryRunOperation" : self = .dryRunOperation(try DryRunOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateHomeRegionControlOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case dryRunOperation(DryRunOperation)
    case internalServerError(InternalServerError)
    case invalidInputException(InvalidInputException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateHomeRegionControlOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateHomeRegionControlOutputResponse(homeRegionControl: \(String(describing: homeRegionControl)))"}
}

extension CreateHomeRegionControlOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateHomeRegionControlOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.homeRegionControl = output.homeRegionControl
        } else {
            self.homeRegionControl = nil
        }
    }
}

public struct CreateHomeRegionControlOutputResponse: Equatable {
    /// <p>This object is the <code>HomeRegionControl</code> object that's returned by a successful
    ///       call to <code>CreateHomeRegionControl</code>.</p>
    public let homeRegionControl: HomeRegionControl?

    public init (
        homeRegionControl: HomeRegionControl? = nil
    )
    {
        self.homeRegionControl = homeRegionControl
    }
}

struct CreateHomeRegionControlOutputResponseBody: Equatable {
    public let homeRegionControl: HomeRegionControl?
}

extension CreateHomeRegionControlOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case homeRegionControl = "HomeRegionControl"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let homeRegionControlDecoded = try containerValues.decodeIfPresent(HomeRegionControl.self, forKey: .homeRegionControl)
        homeRegionControl = homeRegionControlDecoded
    }
}

public struct DescribeHomeRegionControlsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeHomeRegionControlsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeHomeRegionControlsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeHomeRegionControlsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeHomeRegionControlsInput>
    public typealias MOutput = OperationOutput<DescribeHomeRegionControlsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeHomeRegionControlsOutputError>
}

extension DescribeHomeRegionControlsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeHomeRegionControlsInput(controlId: \(String(describing: controlId)), homeRegion: \(String(describing: homeRegion)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), target: \(String(describing: target)))"}
}

extension DescribeHomeRegionControlsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case controlId = "ControlId"
        case homeRegion = "HomeRegion"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case target = "Target"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let controlId = controlId {
            try encodeContainer.encode(controlId, forKey: .controlId)
        }
        if let homeRegion = homeRegion {
            try encodeContainer.encode(homeRegion, forKey: .homeRegion)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let target = target {
            try encodeContainer.encode(target, forKey: .target)
        }
    }
}

public struct DescribeHomeRegionControlsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeHomeRegionControlsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeHomeRegionControlsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeHomeRegionControlsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeHomeRegionControlsInput>
    public typealias MOutput = OperationOutput<DescribeHomeRegionControlsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeHomeRegionControlsOutputError>
}

public struct DescribeHomeRegionControlsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeHomeRegionControlsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeHomeRegionControlsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeHomeRegionControlsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeHomeRegionControlsInput>
    public typealias MOutput = OperationOutput<DescribeHomeRegionControlsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeHomeRegionControlsOutputError>
}

public struct DescribeHomeRegionControlsInput: Equatable {
    /// <p>The <code>ControlID</code> is a unique identifier string of your
    ///         <code>HomeRegionControl</code> object.</p>
    public let controlId: String?
    /// <p>The name of the home region you'd like to view.</p>
    public let homeRegion: String?
    /// <p>The maximum number of filtering results to display per page. </p>
    public let maxResults: Int?
    /// <p>If a <code>NextToken</code> was returned by a previous call, more results are available.
    ///       To retrieve the next page of results, make the call again using the returned token in
    ///         <code>NextToken</code>.</p>
    public let nextToken: String?
    /// <p>The target parameter specifies the identifier to which the home region is applied, which
    ///       is always of type <code>ACCOUNT</code>. It applies the home region to the current
    ///         <code>ACCOUNT</code>.</p>
    public let target: Target?

    public init (
        controlId: String? = nil,
        homeRegion: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        target: Target? = nil
    )
    {
        self.controlId = controlId
        self.homeRegion = homeRegion
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.target = target
    }
}

struct DescribeHomeRegionControlsInputBody: Equatable {
    public let controlId: String?
    public let homeRegion: String?
    public let target: Target?
    public let maxResults: Int?
    public let nextToken: String?
}

extension DescribeHomeRegionControlsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case controlId = "ControlId"
        case homeRegion = "HomeRegion"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case target = "Target"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let controlIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .controlId)
        controlId = controlIdDecoded
        let homeRegionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .homeRegion)
        homeRegion = homeRegionDecoded
        let targetDecoded = try containerValues.decodeIfPresent(Target.self, forKey: .target)
        target = targetDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeHomeRegionControlsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeHomeRegionControlsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeHomeRegionControlsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerError(InternalServerError)
    case invalidInputException(InvalidInputException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeHomeRegionControlsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeHomeRegionControlsOutputResponse(homeRegionControls: \(String(describing: homeRegionControls)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeHomeRegionControlsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeHomeRegionControlsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.homeRegionControls = output.homeRegionControls
            self.nextToken = output.nextToken
        } else {
            self.homeRegionControls = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeHomeRegionControlsOutputResponse: Equatable {
    /// <p>An array that contains your <code>HomeRegionControl</code> objects.</p>
    public let homeRegionControls: [HomeRegionControl]?
    /// <p>If a <code>NextToken</code> was returned by a previous call, more results are available.
    ///       To retrieve the next page of results, make the call again using the returned token in
    ///         <code>NextToken</code>.</p>
    public let nextToken: String?

    public init (
        homeRegionControls: [HomeRegionControl]? = nil,
        nextToken: String? = nil
    )
    {
        self.homeRegionControls = homeRegionControls
        self.nextToken = nextToken
    }
}

struct DescribeHomeRegionControlsOutputResponseBody: Equatable {
    public let homeRegionControls: [HomeRegionControl]?
    public let nextToken: String?
}

extension DescribeHomeRegionControlsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case homeRegionControls = "HomeRegionControls"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let homeRegionControlsContainer = try containerValues.decodeIfPresent([HomeRegionControl?].self, forKey: .homeRegionControls)
        var homeRegionControlsDecoded0:[HomeRegionControl]? = nil
        if let homeRegionControlsContainer = homeRegionControlsContainer {
            homeRegionControlsDecoded0 = [HomeRegionControl]()
            for structure0 in homeRegionControlsContainer {
                if let structure0 = structure0 {
                    homeRegionControlsDecoded0?.append(structure0)
                }
            }
        }
        homeRegionControls = homeRegionControlsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DryRunOperation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DryRunOperation(message: \(String(describing: message)))"}
}

extension DryRunOperation: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DryRunOperationBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Exception raised to indicate that authorization of an action was successful, when the
///         <code>DryRun</code> flag is set to true.</p>
public struct DryRunOperation: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DryRunOperationBody: Equatable {
    public let message: String?
}

extension DryRunOperationBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension GetHomeRegionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetHomeRegionInput()"}
}

extension GetHomeRegionInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetHomeRegionInputHeadersMiddleware: Middleware {
    public let id: String = "GetHomeRegionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetHomeRegionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetHomeRegionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetHomeRegionInput>
    public typealias MOutput = OperationOutput<GetHomeRegionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetHomeRegionOutputError>
}

public struct GetHomeRegionInputQueryItemMiddleware: Middleware {
    public let id: String = "GetHomeRegionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetHomeRegionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetHomeRegionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetHomeRegionInput>
    public typealias MOutput = OperationOutput<GetHomeRegionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetHomeRegionOutputError>
}

public struct GetHomeRegionInput: Equatable {

    public init() {}
}

struct GetHomeRegionInputBody: Equatable {
}

extension GetHomeRegionInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetHomeRegionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetHomeRegionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetHomeRegionOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerError(InternalServerError)
    case invalidInputException(InvalidInputException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetHomeRegionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetHomeRegionOutputResponse(homeRegion: \(String(describing: homeRegion)))"}
}

extension GetHomeRegionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetHomeRegionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.homeRegion = output.homeRegion
        } else {
            self.homeRegion = nil
        }
    }
}

public struct GetHomeRegionOutputResponse: Equatable {
    /// <p>The name of the home region of the calling account.</p>
    public let homeRegion: String?

    public init (
        homeRegion: String? = nil
    )
    {
        self.homeRegion = homeRegion
    }
}

struct GetHomeRegionOutputResponseBody: Equatable {
    public let homeRegion: String?
}

extension GetHomeRegionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case homeRegion = "HomeRegion"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let homeRegionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .homeRegion)
        homeRegion = homeRegionDecoded
    }
}

extension HomeRegionControl: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case controlId = "ControlId"
        case homeRegion = "HomeRegion"
        case requestedTime = "RequestedTime"
        case target = "Target"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let controlId = controlId {
            try encodeContainer.encode(controlId, forKey: .controlId)
        }
        if let homeRegion = homeRegion {
            try encodeContainer.encode(homeRegion, forKey: .homeRegion)
        }
        if let requestedTime = requestedTime {
            try encodeContainer.encode(requestedTime.timeIntervalSince1970, forKey: .requestedTime)
        }
        if let target = target {
            try encodeContainer.encode(target, forKey: .target)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let controlIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .controlId)
        controlId = controlIdDecoded
        let homeRegionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .homeRegion)
        homeRegion = homeRegionDecoded
        let targetDecoded = try containerValues.decodeIfPresent(Target.self, forKey: .target)
        target = targetDecoded
        let requestedTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .requestedTime)
        requestedTime = requestedTimeDecoded
    }
}

extension HomeRegionControl: CustomDebugStringConvertible {
    public var debugDescription: String {
        "HomeRegionControl(controlId: \(String(describing: controlId)), homeRegion: \(String(describing: homeRegion)), requestedTime: \(String(describing: requestedTime)), target: \(String(describing: target)))"}
}

/// <p>A home region control is an object that specifies the home region for an account, with
///       some additional information. It contains a target (always of type <code>ACCOUNT</code>), an
///       ID, and a time at which the home region was set.</p>
public struct HomeRegionControl: Equatable {
    /// <p>A unique identifier that's generated for each home region control. It's always a string
    ///       that begins with "hrc-" followed by 12 lowercase letters and numbers.</p>
    public let controlId: String?
    /// <p>The AWS Region that's been set as home region. For example, "us-west-2" or "eu-central-1"
    ///       are valid home regions.</p>
    public let homeRegion: String?
    /// <p>A timestamp representing the time when the customer called
    ///         <code>CreateHomeregionControl</code> and set the home region for the account.</p>
    public let requestedTime: Date?
    /// <p>The target parameter specifies the identifier to which the home region is applied, which
    ///       is always an <code>ACCOUNT</code>. It applies the home region to the current
    ///         <code>ACCOUNT</code>.</p>
    public let target: Target?

    public init (
        controlId: String? = nil,
        homeRegion: String? = nil,
        requestedTime: Date? = nil,
        target: Target? = nil
    )
    {
        self.controlId = controlId
        self.homeRegion = homeRegion
        self.requestedTime = requestedTime
        self.target = target
    }
}

extension InternalServerError: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalServerError(message: \(String(describing: message)))"}
}

extension InternalServerError: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InternalServerErrorBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Exception raised when an internal, configuration, or dependency error is
///       encountered.</p>
public struct InternalServerError: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerErrorBody: Equatable {
    public let message: String?
}

extension InternalServerErrorBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidInputException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidInputException(message: \(String(describing: message)))"}
}

extension InvalidInputException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidInputExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Exception raised when the provided input violates a policy constraint or is entered in the
///       wrong format or data type.</p>
public struct InvalidInputException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidInputExceptionBody: Equatable {
    public let message: String?
}

extension InvalidInputExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceUnavailableException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceUnavailableException(message: \(String(describing: message)))"}
}

extension ServiceUnavailableException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ServiceUnavailableExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Exception raised when a request fails due to temporary unavailability of the
///       service.</p>
public struct ServiceUnavailableException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceUnavailableExceptionBody: Equatable {
    public let message: String?
}

extension ServiceUnavailableExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Target: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case id = "Id"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(TargetType.self, forKey: .type)
        type = typeDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
    }
}

extension Target: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Target(id: \(String(describing: id)), type: \(String(describing: type)))"}
}

/// <p>The target parameter specifies the identifier to which the home region is applied, which
///       is always an <code>ACCOUNT</code>. It applies the home region to the current
///         <code>ACCOUNT</code>.</p>
public struct Target: Equatable {
    /// <p>The <code>TargetID</code> is a 12-character identifier of the <code>ACCOUNT</code> for
    ///       which the control was created. (This must be the current account.) </p>
    public let id: String?
    /// <p>The target type is always an <code>ACCOUNT</code>.</p>
    public let type: TargetType?

    public init (
        id: String? = nil,
        type: TargetType? = nil
    )
    {
        self.id = id
        self.type = type
    }
}

public enum TargetType {
    case account
    case sdkUnknown(String)
}

extension TargetType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [TargetType] {
        return [
            .account,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .account: return "ACCOUNT"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = TargetType(rawValue: rawValue) ?? TargetType.sdkUnknown(rawValue)
    }
}

extension ThrottlingException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ThrottlingException(message: \(String(describing: message)), retryAfterSeconds: \(String(describing: retryAfterSeconds)))"}
}

extension ThrottlingException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.retryAfterSeconds = Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.retryAfterSeconds = 0
        }
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request was denied due to request throttling.</p>
public struct ThrottlingException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    /// <p>The number of seconds the caller should wait before retrying.</p>
    public var retryAfterSeconds: Int

    public init (
        message: String? = nil,
        retryAfterSeconds: Int = 0
    )
    {
        self.message = message
        self.retryAfterSeconds = retryAfterSeconds
    }
}

struct ThrottlingExceptionBody: Equatable {
    public let message: String?
}

extension ThrottlingExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}
