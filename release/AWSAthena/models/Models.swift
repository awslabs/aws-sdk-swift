// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AthenaClientTypes.AclConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3AclOption = "S3AclOption"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3AclOption = self.s3AclOption {
            try encodeContainer.encode(s3AclOption.rawValue, forKey: .s3AclOption)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3AclOptionDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.S3AclOption.self, forKey: .s3AclOption)
        s3AclOption = s3AclOptionDecoded
    }
}

extension AthenaClientTypes {
    /// Indicates that an Amazon S3 canned ACL should be set to control ownership of stored query results. When Athena stores query results in Amazon S3, the canned ACL is set with the x-amz-acl request header. For more information about S3 Object Ownership, see [Object Ownership settings](https://docs.aws.amazon.com/AmazonS3/latest/userguide/about-object-ownership.html#object-ownership-overview) in the Amazon S3 User Guide.
    public struct AclConfiguration: Swift.Equatable {
        /// The Amazon S3 canned ACL that Athena should specify when storing query results. Currently the only supported canned ACL is BUCKET_OWNER_FULL_CONTROL. If a query runs in a workgroup and the workgroup overrides client-side settings, then the Amazon S3 canned ACL specified in the workgroup's settings is used for all queries that run in the workgroup. For more information about Amazon S3 canned ACLs, see [Canned ACL](https://docs.aws.amazon.com/AmazonS3/latest/userguide/acl-overview.html#canned-acl) in the Amazon S3 User Guide.
        /// This member is required.
        public var s3AclOption: AthenaClientTypes.S3AclOption?

        public init (
            s3AclOption: AthenaClientTypes.S3AclOption? = nil
        )
        {
            self.s3AclOption = s3AclOption
        }
    }

}

extension AthenaClientTypes.ApplicationDPUSizes: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationRuntimeId = "ApplicationRuntimeId"
        case supportedDPUSizes = "SupportedDPUSizes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationRuntimeId = self.applicationRuntimeId {
            try encodeContainer.encode(applicationRuntimeId, forKey: .applicationRuntimeId)
        }
        if let supportedDPUSizes = supportedDPUSizes {
            var supportedDPUSizesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .supportedDPUSizes)
            for integer0 in supportedDPUSizes {
                try supportedDPUSizesContainer.encode(integer0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationRuntimeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationRuntimeId)
        applicationRuntimeId = applicationRuntimeIdDecoded
        let supportedDPUSizesContainer = try containerValues.decodeIfPresent([Swift.Int?].self, forKey: .supportedDPUSizes)
        var supportedDPUSizesDecoded0:[Swift.Int]? = nil
        if let supportedDPUSizesContainer = supportedDPUSizesContainer {
            supportedDPUSizesDecoded0 = [Swift.Int]()
            for integer0 in supportedDPUSizesContainer {
                if let integer0 = integer0 {
                    supportedDPUSizesDecoded0?.append(integer0)
                }
            }
        }
        supportedDPUSizes = supportedDPUSizesDecoded0
    }
}

extension AthenaClientTypes {
    /// Contains the application runtime IDs and their supported DPU sizes.
    public struct ApplicationDPUSizes: Swift.Equatable {
        /// The name of the supported application runtime (for example, Jupyter 1.0).
        public var applicationRuntimeId: Swift.String?
        /// A list of the supported DPU sizes that the application runtime supports.
        public var supportedDPUSizes: [Swift.Int]?

        public init (
            applicationRuntimeId: Swift.String? = nil,
            supportedDPUSizes: [Swift.Int]? = nil
        )
        {
            self.applicationRuntimeId = applicationRuntimeId
            self.supportedDPUSizes = supportedDPUSizes
        }
    }

}

extension AthenaClientTypes.AthenaError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCategory = "ErrorCategory"
        case errorMessage = "ErrorMessage"
        case errorType = "ErrorType"
        case retryable = "Retryable"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCategory = self.errorCategory {
            try encodeContainer.encode(errorCategory, forKey: .errorCategory)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let errorType = self.errorType {
            try encodeContainer.encode(errorType, forKey: .errorType)
        }
        if retryable != false {
            try encodeContainer.encode(retryable, forKey: .retryable)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCategoryDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .errorCategory)
        errorCategory = errorCategoryDecoded
        let errorTypeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .errorType)
        errorType = errorTypeDecoded
        let retryableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .retryable) ?? false
        retryable = retryableDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension AthenaClientTypes {
    /// Provides information about an Athena query error. The AthenaError feature provides standardized error information to help you understand failed queries and take steps after a query failure occurs. AthenaError includes an ErrorCategory field that specifies whether the cause of the failed query is due to system error, user error, or other error.
    public struct AthenaError: Swift.Equatable {
        /// An integer value that specifies the category of a query failure error. The following list shows the category for each integer value. 1 - System 2 - User 3 - Other
        public var errorCategory: Swift.Int?
        /// Contains a short description of the error that occurred.
        public var errorMessage: Swift.String?
        /// An integer value that provides specific information about an Athena query error. For the meaning of specific values, see the [Error Type Reference](https://docs.aws.amazon.com/athena/latest/ug/error-reference.html#error-reference-error-type-reference) in the Amazon Athena User Guide.
        public var errorType: Swift.Int?
        /// True if the query might succeed if resubmitted.
        public var retryable: Swift.Bool

        public init (
            errorCategory: Swift.Int? = nil,
            errorMessage: Swift.String? = nil,
            errorType: Swift.Int? = nil,
            retryable: Swift.Bool = false
        )
        {
            self.errorCategory = errorCategory
            self.errorMessage = errorMessage
            self.errorType = errorType
            self.retryable = retryable
        }
    }

}

extension BatchGetNamedQueryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case namedQueryIds = "NamedQueryIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let namedQueryIds = namedQueryIds {
            var namedQueryIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .namedQueryIds)
            for namedqueryid0 in namedQueryIds {
                try namedQueryIdsContainer.encode(namedqueryid0)
            }
        }
    }
}

extension BatchGetNamedQueryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Contains an array of named query IDs.
public struct BatchGetNamedQueryInput: Swift.Equatable {
    /// An array of query IDs.
    /// This member is required.
    public var namedQueryIds: [Swift.String]?

    public init (
        namedQueryIds: [Swift.String]? = nil
    )
    {
        self.namedQueryIds = namedQueryIds
    }
}

struct BatchGetNamedQueryInputBody: Swift.Equatable {
    let namedQueryIds: [Swift.String]?
}

extension BatchGetNamedQueryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case namedQueryIds = "NamedQueryIds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namedQueryIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .namedQueryIds)
        var namedQueryIdsDecoded0:[Swift.String]? = nil
        if let namedQueryIdsContainer = namedQueryIdsContainer {
            namedQueryIdsDecoded0 = [Swift.String]()
            for string0 in namedQueryIdsContainer {
                if let string0 = string0 {
                    namedQueryIdsDecoded0?.append(string0)
                }
            }
        }
        namedQueryIds = namedQueryIdsDecoded0
    }
}

extension BatchGetNamedQueryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchGetNamedQueryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum BatchGetNamedQueryOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchGetNamedQueryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: BatchGetNamedQueryOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.namedQueries = output.namedQueries
            self.unprocessedNamedQueryIds = output.unprocessedNamedQueryIds
        } else {
            self.namedQueries = nil
            self.unprocessedNamedQueryIds = nil
        }
    }
}

public struct BatchGetNamedQueryOutputResponse: Swift.Equatable {
    /// Information about the named query IDs submitted.
    public var namedQueries: [AthenaClientTypes.NamedQuery]?
    /// Information about provided query IDs.
    public var unprocessedNamedQueryIds: [AthenaClientTypes.UnprocessedNamedQueryId]?

    public init (
        namedQueries: [AthenaClientTypes.NamedQuery]? = nil,
        unprocessedNamedQueryIds: [AthenaClientTypes.UnprocessedNamedQueryId]? = nil
    )
    {
        self.namedQueries = namedQueries
        self.unprocessedNamedQueryIds = unprocessedNamedQueryIds
    }
}

struct BatchGetNamedQueryOutputResponseBody: Swift.Equatable {
    let namedQueries: [AthenaClientTypes.NamedQuery]?
    let unprocessedNamedQueryIds: [AthenaClientTypes.UnprocessedNamedQueryId]?
}

extension BatchGetNamedQueryOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case namedQueries = "NamedQueries"
        case unprocessedNamedQueryIds = "UnprocessedNamedQueryIds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namedQueriesContainer = try containerValues.decodeIfPresent([AthenaClientTypes.NamedQuery?].self, forKey: .namedQueries)
        var namedQueriesDecoded0:[AthenaClientTypes.NamedQuery]? = nil
        if let namedQueriesContainer = namedQueriesContainer {
            namedQueriesDecoded0 = [AthenaClientTypes.NamedQuery]()
            for structure0 in namedQueriesContainer {
                if let structure0 = structure0 {
                    namedQueriesDecoded0?.append(structure0)
                }
            }
        }
        namedQueries = namedQueriesDecoded0
        let unprocessedNamedQueryIdsContainer = try containerValues.decodeIfPresent([AthenaClientTypes.UnprocessedNamedQueryId?].self, forKey: .unprocessedNamedQueryIds)
        var unprocessedNamedQueryIdsDecoded0:[AthenaClientTypes.UnprocessedNamedQueryId]? = nil
        if let unprocessedNamedQueryIdsContainer = unprocessedNamedQueryIdsContainer {
            unprocessedNamedQueryIdsDecoded0 = [AthenaClientTypes.UnprocessedNamedQueryId]()
            for structure0 in unprocessedNamedQueryIdsContainer {
                if let structure0 = structure0 {
                    unprocessedNamedQueryIdsDecoded0?.append(structure0)
                }
            }
        }
        unprocessedNamedQueryIds = unprocessedNamedQueryIdsDecoded0
    }
}

extension BatchGetPreparedStatementInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case preparedStatementNames = "PreparedStatementNames"
        case workGroup = "WorkGroup"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let preparedStatementNames = preparedStatementNames {
            var preparedStatementNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .preparedStatementNames)
            for statementname0 in preparedStatementNames {
                try preparedStatementNamesContainer.encode(statementname0)
            }
        }
        if let workGroup = self.workGroup {
            try encodeContainer.encode(workGroup, forKey: .workGroup)
        }
    }
}

extension BatchGetPreparedStatementInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct BatchGetPreparedStatementInput: Swift.Equatable {
    /// A list of prepared statement names to return.
    /// This member is required.
    public var preparedStatementNames: [Swift.String]?
    /// The name of the workgroup to which the prepared statements belong.
    /// This member is required.
    public var workGroup: Swift.String?

    public init (
        preparedStatementNames: [Swift.String]? = nil,
        workGroup: Swift.String? = nil
    )
    {
        self.preparedStatementNames = preparedStatementNames
        self.workGroup = workGroup
    }
}

struct BatchGetPreparedStatementInputBody: Swift.Equatable {
    let preparedStatementNames: [Swift.String]?
    let workGroup: Swift.String?
}

extension BatchGetPreparedStatementInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case preparedStatementNames = "PreparedStatementNames"
        case workGroup = "WorkGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let preparedStatementNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .preparedStatementNames)
        var preparedStatementNamesDecoded0:[Swift.String]? = nil
        if let preparedStatementNamesContainer = preparedStatementNamesContainer {
            preparedStatementNamesDecoded0 = [Swift.String]()
            for string0 in preparedStatementNamesContainer {
                if let string0 = string0 {
                    preparedStatementNamesDecoded0?.append(string0)
                }
            }
        }
        preparedStatementNames = preparedStatementNamesDecoded0
        let workGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workGroup)
        workGroup = workGroupDecoded
    }
}

extension BatchGetPreparedStatementOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchGetPreparedStatementOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum BatchGetPreparedStatementOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchGetPreparedStatementOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: BatchGetPreparedStatementOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.preparedStatements = output.preparedStatements
            self.unprocessedPreparedStatementNames = output.unprocessedPreparedStatementNames
        } else {
            self.preparedStatements = nil
            self.unprocessedPreparedStatementNames = nil
        }
    }
}

public struct BatchGetPreparedStatementOutputResponse: Swift.Equatable {
    /// The list of prepared statements returned.
    public var preparedStatements: [AthenaClientTypes.PreparedStatement]?
    /// A list of one or more prepared statements that were requested but could not be returned.
    public var unprocessedPreparedStatementNames: [AthenaClientTypes.UnprocessedPreparedStatementName]?

    public init (
        preparedStatements: [AthenaClientTypes.PreparedStatement]? = nil,
        unprocessedPreparedStatementNames: [AthenaClientTypes.UnprocessedPreparedStatementName]? = nil
    )
    {
        self.preparedStatements = preparedStatements
        self.unprocessedPreparedStatementNames = unprocessedPreparedStatementNames
    }
}

struct BatchGetPreparedStatementOutputResponseBody: Swift.Equatable {
    let preparedStatements: [AthenaClientTypes.PreparedStatement]?
    let unprocessedPreparedStatementNames: [AthenaClientTypes.UnprocessedPreparedStatementName]?
}

extension BatchGetPreparedStatementOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case preparedStatements = "PreparedStatements"
        case unprocessedPreparedStatementNames = "UnprocessedPreparedStatementNames"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let preparedStatementsContainer = try containerValues.decodeIfPresent([AthenaClientTypes.PreparedStatement?].self, forKey: .preparedStatements)
        var preparedStatementsDecoded0:[AthenaClientTypes.PreparedStatement]? = nil
        if let preparedStatementsContainer = preparedStatementsContainer {
            preparedStatementsDecoded0 = [AthenaClientTypes.PreparedStatement]()
            for structure0 in preparedStatementsContainer {
                if let structure0 = structure0 {
                    preparedStatementsDecoded0?.append(structure0)
                }
            }
        }
        preparedStatements = preparedStatementsDecoded0
        let unprocessedPreparedStatementNamesContainer = try containerValues.decodeIfPresent([AthenaClientTypes.UnprocessedPreparedStatementName?].self, forKey: .unprocessedPreparedStatementNames)
        var unprocessedPreparedStatementNamesDecoded0:[AthenaClientTypes.UnprocessedPreparedStatementName]? = nil
        if let unprocessedPreparedStatementNamesContainer = unprocessedPreparedStatementNamesContainer {
            unprocessedPreparedStatementNamesDecoded0 = [AthenaClientTypes.UnprocessedPreparedStatementName]()
            for structure0 in unprocessedPreparedStatementNamesContainer {
                if let structure0 = structure0 {
                    unprocessedPreparedStatementNamesDecoded0?.append(structure0)
                }
            }
        }
        unprocessedPreparedStatementNames = unprocessedPreparedStatementNamesDecoded0
    }
}

extension BatchGetQueryExecutionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case queryExecutionIds = "QueryExecutionIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let queryExecutionIds = queryExecutionIds {
            var queryExecutionIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .queryExecutionIds)
            for queryexecutionid0 in queryExecutionIds {
                try queryExecutionIdsContainer.encode(queryexecutionid0)
            }
        }
    }
}

extension BatchGetQueryExecutionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Contains an array of query execution IDs.
public struct BatchGetQueryExecutionInput: Swift.Equatable {
    /// An array of query execution IDs.
    /// This member is required.
    public var queryExecutionIds: [Swift.String]?

    public init (
        queryExecutionIds: [Swift.String]? = nil
    )
    {
        self.queryExecutionIds = queryExecutionIds
    }
}

struct BatchGetQueryExecutionInputBody: Swift.Equatable {
    let queryExecutionIds: [Swift.String]?
}

extension BatchGetQueryExecutionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case queryExecutionIds = "QueryExecutionIds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryExecutionIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .queryExecutionIds)
        var queryExecutionIdsDecoded0:[Swift.String]? = nil
        if let queryExecutionIdsContainer = queryExecutionIdsContainer {
            queryExecutionIdsDecoded0 = [Swift.String]()
            for string0 in queryExecutionIdsContainer {
                if let string0 = string0 {
                    queryExecutionIdsDecoded0?.append(string0)
                }
            }
        }
        queryExecutionIds = queryExecutionIdsDecoded0
    }
}

extension BatchGetQueryExecutionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchGetQueryExecutionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum BatchGetQueryExecutionOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchGetQueryExecutionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: BatchGetQueryExecutionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.queryExecutions = output.queryExecutions
            self.unprocessedQueryExecutionIds = output.unprocessedQueryExecutionIds
        } else {
            self.queryExecutions = nil
            self.unprocessedQueryExecutionIds = nil
        }
    }
}

public struct BatchGetQueryExecutionOutputResponse: Swift.Equatable {
    /// Information about a query execution.
    public var queryExecutions: [AthenaClientTypes.QueryExecution]?
    /// Information about the query executions that failed to run.
    public var unprocessedQueryExecutionIds: [AthenaClientTypes.UnprocessedQueryExecutionId]?

    public init (
        queryExecutions: [AthenaClientTypes.QueryExecution]? = nil,
        unprocessedQueryExecutionIds: [AthenaClientTypes.UnprocessedQueryExecutionId]? = nil
    )
    {
        self.queryExecutions = queryExecutions
        self.unprocessedQueryExecutionIds = unprocessedQueryExecutionIds
    }
}

struct BatchGetQueryExecutionOutputResponseBody: Swift.Equatable {
    let queryExecutions: [AthenaClientTypes.QueryExecution]?
    let unprocessedQueryExecutionIds: [AthenaClientTypes.UnprocessedQueryExecutionId]?
}

extension BatchGetQueryExecutionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case queryExecutions = "QueryExecutions"
        case unprocessedQueryExecutionIds = "UnprocessedQueryExecutionIds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryExecutionsContainer = try containerValues.decodeIfPresent([AthenaClientTypes.QueryExecution?].self, forKey: .queryExecutions)
        var queryExecutionsDecoded0:[AthenaClientTypes.QueryExecution]? = nil
        if let queryExecutionsContainer = queryExecutionsContainer {
            queryExecutionsDecoded0 = [AthenaClientTypes.QueryExecution]()
            for structure0 in queryExecutionsContainer {
                if let structure0 = structure0 {
                    queryExecutionsDecoded0?.append(structure0)
                }
            }
        }
        queryExecutions = queryExecutionsDecoded0
        let unprocessedQueryExecutionIdsContainer = try containerValues.decodeIfPresent([AthenaClientTypes.UnprocessedQueryExecutionId?].self, forKey: .unprocessedQueryExecutionIds)
        var unprocessedQueryExecutionIdsDecoded0:[AthenaClientTypes.UnprocessedQueryExecutionId]? = nil
        if let unprocessedQueryExecutionIdsContainer = unprocessedQueryExecutionIdsContainer {
            unprocessedQueryExecutionIdsDecoded0 = [AthenaClientTypes.UnprocessedQueryExecutionId]()
            for structure0 in unprocessedQueryExecutionIdsContainer {
                if let structure0 = structure0 {
                    unprocessedQueryExecutionIdsDecoded0?.append(structure0)
                }
            }
        }
        unprocessedQueryExecutionIds = unprocessedQueryExecutionIdsDecoded0
    }
}

extension AthenaClientTypes.CalculationConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case codeBlock = "CodeBlock"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let codeBlock = self.codeBlock {
            try encodeContainer.encode(codeBlock, forKey: .codeBlock)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeBlockDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .codeBlock)
        codeBlock = codeBlockDecoded
    }
}

extension AthenaClientTypes {
    /// Contains configuration information for the calculation.
    public struct CalculationConfiguration: Swift.Equatable {
        /// A string that contains the code for the calculation.
        public var codeBlock: Swift.String?

        public init (
            codeBlock: Swift.String? = nil
        )
        {
            self.codeBlock = codeBlock
        }
    }

}

extension AthenaClientTypes {
    public enum CalculationExecutionState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case canceled
        case canceling
        case completed
        case created
        case creating
        case failed
        case queued
        case running
        case sdkUnknown(Swift.String)

        public static var allCases: [CalculationExecutionState] {
            return [
                .canceled,
                .canceling,
                .completed,
                .created,
                .creating,
                .failed,
                .queued,
                .running,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .canceled: return "CANCELED"
            case .canceling: return "CANCELING"
            case .completed: return "COMPLETED"
            case .created: return "CREATED"
            case .creating: return "CREATING"
            case .failed: return "FAILED"
            case .queued: return "QUEUED"
            case .running: return "RUNNING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CalculationExecutionState(rawValue: rawValue) ?? CalculationExecutionState.sdkUnknown(rawValue)
        }
    }
}

extension AthenaClientTypes.CalculationResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resultS3Uri = "ResultS3Uri"
        case resultType = "ResultType"
        case stdErrorS3Uri = "StdErrorS3Uri"
        case stdOutS3Uri = "StdOutS3Uri"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resultS3Uri = self.resultS3Uri {
            try encodeContainer.encode(resultS3Uri, forKey: .resultS3Uri)
        }
        if let resultType = self.resultType {
            try encodeContainer.encode(resultType, forKey: .resultType)
        }
        if let stdErrorS3Uri = self.stdErrorS3Uri {
            try encodeContainer.encode(stdErrorS3Uri, forKey: .stdErrorS3Uri)
        }
        if let stdOutS3Uri = self.stdOutS3Uri {
            try encodeContainer.encode(stdOutS3Uri, forKey: .stdOutS3Uri)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stdOutS3UriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stdOutS3Uri)
        stdOutS3Uri = stdOutS3UriDecoded
        let stdErrorS3UriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stdErrorS3Uri)
        stdErrorS3Uri = stdErrorS3UriDecoded
        let resultS3UriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resultS3Uri)
        resultS3Uri = resultS3UriDecoded
        let resultTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resultType)
        resultType = resultTypeDecoded
    }
}

extension AthenaClientTypes {
    /// Contains information about an application-specific calculation result.
    public struct CalculationResult: Swift.Equatable {
        /// The Amazon S3 location of the folder for the calculation results.
        public var resultS3Uri: Swift.String?
        /// The data format of the calculation result.
        public var resultType: Swift.String?
        /// The Amazon S3 location of the stderr error messages file for the calculation.
        public var stdErrorS3Uri: Swift.String?
        /// The Amazon S3 location of the stdout file for the calculation.
        public var stdOutS3Uri: Swift.String?

        public init (
            resultS3Uri: Swift.String? = nil,
            resultType: Swift.String? = nil,
            stdErrorS3Uri: Swift.String? = nil,
            stdOutS3Uri: Swift.String? = nil
        )
        {
            self.resultS3Uri = resultS3Uri
            self.resultType = resultType
            self.stdErrorS3Uri = stdErrorS3Uri
            self.stdOutS3Uri = stdOutS3Uri
        }
    }

}

extension AthenaClientTypes.CalculationStatistics: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dpuExecutionInMillis = "DpuExecutionInMillis"
        case progress = "Progress"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dpuExecutionInMillis = self.dpuExecutionInMillis {
            try encodeContainer.encode(dpuExecutionInMillis, forKey: .dpuExecutionInMillis)
        }
        if let progress = self.progress {
            try encodeContainer.encode(progress, forKey: .progress)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dpuExecutionInMillisDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .dpuExecutionInMillis)
        dpuExecutionInMillis = dpuExecutionInMillisDecoded
        let progressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .progress)
        progress = progressDecoded
    }
}

extension AthenaClientTypes {
    /// Contains statistics for a notebook calculation.
    public struct CalculationStatistics: Swift.Equatable {
        /// The data processing unit execution time in milliseconds for the calculation.
        public var dpuExecutionInMillis: Swift.Int?
        /// The progress of the calculation.
        public var progress: Swift.String?

        public init (
            dpuExecutionInMillis: Swift.Int? = nil,
            progress: Swift.String? = nil
        )
        {
            self.dpuExecutionInMillis = dpuExecutionInMillis
            self.progress = progress
        }
    }

}

extension AthenaClientTypes.CalculationStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case completionDateTime = "CompletionDateTime"
        case state = "State"
        case stateChangeReason = "StateChangeReason"
        case submissionDateTime = "SubmissionDateTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let completionDateTime = self.completionDateTime {
            try encodeContainer.encodeTimestamp(completionDateTime, format: .epochSeconds, forKey: .completionDateTime)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let stateChangeReason = self.stateChangeReason {
            try encodeContainer.encode(stateChangeReason, forKey: .stateChangeReason)
        }
        if let submissionDateTime = self.submissionDateTime {
            try encodeContainer.encodeTimestamp(submissionDateTime, format: .epochSeconds, forKey: .submissionDateTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let submissionDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .submissionDateTime)
        submissionDateTime = submissionDateTimeDecoded
        let completionDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .completionDateTime)
        completionDateTime = completionDateTimeDecoded
        let stateDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.CalculationExecutionState.self, forKey: .state)
        state = stateDecoded
        let stateChangeReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stateChangeReason)
        stateChangeReason = stateChangeReasonDecoded
    }
}

extension AthenaClientTypes {
    /// Contains information about the status of a notebook calculation.
    public struct CalculationStatus: Swift.Equatable {
        /// The date and time the calculation completed processing.
        public var completionDateTime: ClientRuntime.Date?
        /// The state of the calculation execution. A description of each state follows. CREATING - The calculation is in the process of being created. CREATED - The calculation has been created and is ready to run. QUEUED - The calculation has been queued for processing. RUNNING - The calculation is running. CANCELING - A request to cancel the calculation has been received and the system is working to stop it. CANCELED - The calculation is no longer running as the result of a cancel request. COMPLETED - The calculation has completed without error. FAILED - The calculation failed and is no longer running.
        public var state: AthenaClientTypes.CalculationExecutionState?
        /// The reason for the calculation state change (for example, the calculation was canceled because the session was terminated).
        public var stateChangeReason: Swift.String?
        /// The date and time the calculation was submitted for processing.
        public var submissionDateTime: ClientRuntime.Date?

        public init (
            completionDateTime: ClientRuntime.Date? = nil,
            state: AthenaClientTypes.CalculationExecutionState? = nil,
            stateChangeReason: Swift.String? = nil,
            submissionDateTime: ClientRuntime.Date? = nil
        )
        {
            self.completionDateTime = completionDateTime
            self.state = state
            self.stateChangeReason = stateChangeReason
            self.submissionDateTime = submissionDateTime
        }
    }

}

extension AthenaClientTypes.CalculationSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case calculationExecutionId = "CalculationExecutionId"
        case description = "Description"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let calculationExecutionId = self.calculationExecutionId {
            try encodeContainer.encode(calculationExecutionId, forKey: .calculationExecutionId)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let calculationExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .calculationExecutionId)
        calculationExecutionId = calculationExecutionIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.CalculationStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension AthenaClientTypes {
    /// Summary information for a notebook calculation.
    public struct CalculationSummary: Swift.Equatable {
        /// The calculation execution UUID.
        public var calculationExecutionId: Swift.String?
        /// A description of the calculation.
        public var description: Swift.String?
        /// Contains information about the status of the calculation.
        public var status: AthenaClientTypes.CalculationStatus?

        public init (
            calculationExecutionId: Swift.String? = nil,
            description: Swift.String? = nil,
            status: AthenaClientTypes.CalculationStatus? = nil
        )
        {
            self.calculationExecutionId = calculationExecutionId
            self.description = description
            self.status = status
        }
    }

}

extension AthenaClientTypes.Column: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comment = "Comment"
        case name = "Name"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let comment = self.comment {
            try encodeContainer.encode(comment, forKey: .comment)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
    }
}

extension AthenaClientTypes {
    /// Contains metadata for a column in a table.
    public struct Column: Swift.Equatable {
        /// Optional information about the column.
        public var comment: Swift.String?
        /// The name of the column.
        /// This member is required.
        public var name: Swift.String?
        /// The data type of the column.
        public var type: Swift.String?

        public init (
            comment: Swift.String? = nil,
            name: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.comment = comment
            self.name = name
            self.type = type
        }
    }

}

extension AthenaClientTypes.ColumnInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case caseSensitive = "CaseSensitive"
        case catalogName = "CatalogName"
        case label = "Label"
        case name = "Name"
        case nullable = "Nullable"
        case precision = "Precision"
        case scale = "Scale"
        case schemaName = "SchemaName"
        case tableName = "TableName"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if caseSensitive != false {
            try encodeContainer.encode(caseSensitive, forKey: .caseSensitive)
        }
        if let catalogName = self.catalogName {
            try encodeContainer.encode(catalogName, forKey: .catalogName)
        }
        if let label = self.label {
            try encodeContainer.encode(label, forKey: .label)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let nullable = self.nullable {
            try encodeContainer.encode(nullable.rawValue, forKey: .nullable)
        }
        if precision != 0 {
            try encodeContainer.encode(precision, forKey: .precision)
        }
        if scale != 0 {
            try encodeContainer.encode(scale, forKey: .scale)
        }
        if let schemaName = self.schemaName {
            try encodeContainer.encode(schemaName, forKey: .schemaName)
        }
        if let tableName = self.tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .catalogName)
        catalogName = catalogNameDecoded
        let schemaNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaName)
        schemaName = schemaNameDecoded
        let tableNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tableName)
        tableName = tableNameDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let labelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .label)
        label = labelDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let precisionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .precision) ?? 0
        precision = precisionDecoded
        let scaleDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .scale) ?? 0
        scale = scaleDecoded
        let nullableDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.ColumnNullable.self, forKey: .nullable)
        nullable = nullableDecoded
        let caseSensitiveDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .caseSensitive) ?? false
        caseSensitive = caseSensitiveDecoded
    }
}

extension AthenaClientTypes {
    /// Information about the columns in a query execution result.
    public struct ColumnInfo: Swift.Equatable {
        /// Indicates whether values in the column are case-sensitive.
        public var caseSensitive: Swift.Bool
        /// The catalog to which the query results belong.
        public var catalogName: Swift.String?
        /// A column label.
        public var label: Swift.String?
        /// The name of the column.
        /// This member is required.
        public var name: Swift.String?
        /// Indicates the column's nullable status.
        public var nullable: AthenaClientTypes.ColumnNullable?
        /// For DECIMAL data types, specifies the total number of digits, up to 38. For performance reasons, we recommend up to 18 digits.
        public var precision: Swift.Int
        /// For DECIMAL data types, specifies the total number of digits in the fractional part of the value. Defaults to 0.
        public var scale: Swift.Int
        /// The schema name (database name) to which the query results belong.
        public var schemaName: Swift.String?
        /// The table name for the query results.
        public var tableName: Swift.String?
        /// The data type of the column.
        /// This member is required.
        public var type: Swift.String?

        public init (
            caseSensitive: Swift.Bool = false,
            catalogName: Swift.String? = nil,
            label: Swift.String? = nil,
            name: Swift.String? = nil,
            nullable: AthenaClientTypes.ColumnNullable? = nil,
            precision: Swift.Int = 0,
            scale: Swift.Int = 0,
            schemaName: Swift.String? = nil,
            tableName: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.caseSensitive = caseSensitive
            self.catalogName = catalogName
            self.label = label
            self.name = name
            self.nullable = nullable
            self.precision = precision
            self.scale = scale
            self.schemaName = schemaName
            self.tableName = tableName
            self.type = type
        }
    }

}

extension AthenaClientTypes {
    public enum ColumnNullable: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case notNull
        case nullable
        case unknown
        case sdkUnknown(Swift.String)

        public static var allCases: [ColumnNullable] {
            return [
                .notNull,
                .nullable,
                .unknown,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .notNull: return "NOT_NULL"
            case .nullable: return "NULLABLE"
            case .unknown: return "UNKNOWN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ColumnNullable(rawValue: rawValue) ?? ColumnNullable.sdkUnknown(rawValue)
        }
    }
}

extension CreateDataCatalogInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
        case parameters = "Parameters"
        case tags = "Tags"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .parameters)
            for (dictKey0, parametersMap0) in parameters {
                try parametersContainer.encode(parametersMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension CreateDataCatalogInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateDataCatalogInput: Swift.Equatable {
    /// A description of the data catalog to be created.
    public var description: Swift.String?
    /// The name of the data catalog to create. The catalog name must be unique for the Amazon Web Services account and can use a maximum of 127 alphanumeric, underscore, at sign, or hyphen characters. The remainder of the length constraint of 256 is reserved for use by Athena.
    /// This member is required.
    public var name: Swift.String?
    /// Specifies the Lambda function or functions to use for creating the data catalog. This is a mapping whose values depend on the catalog type.
    ///
    /// * For the HIVE data catalog type, use the following syntax. The metadata-function parameter is required. The sdk-version parameter is optional and defaults to the currently supported version. metadata-function=lambda_arn, sdk-version=version_number
    ///
    /// * For the LAMBDA data catalog type, use one of the following sets of required parameters, but not both.
    ///
    /// * If you have one Lambda function that processes metadata and another for reading the actual data, use the following syntax. Both parameters are required. metadata-function=lambda_arn, record-function=lambda_arn
    ///
    /// * If you have a composite Lambda function that processes both metadata and data, use the following syntax to specify your Lambda function. function=lambda_arn
    ///
    ///
    ///
    ///
    /// * The GLUE type takes a catalog ID parameter and is required. The  catalog_id  is the account ID of the Amazon Web Services account to which the Glue Data Catalog belongs. catalog-id=catalog_id
    ///
    /// * The GLUE data catalog type also applies to the default AwsDataCatalog that already exists in your account, of which you can have only one and cannot modify.
    ///
    /// * Queries that specify a Glue Data Catalog other than the default AwsDataCatalog must be run on Athena engine version 2.
    ///
    /// * In Regions where Athena engine version 2 is not available, creating new Glue data catalogs results in an INVALID_INPUT error.
    public var parameters: [Swift.String:Swift.String]?
    /// A list of comma separated tags to add to the data catalog that is created.
    public var tags: [AthenaClientTypes.Tag]?
    /// The type of data catalog to create: LAMBDA for a federated catalog, HIVE for an external hive metastore, or GLUE for an Glue Data Catalog.
    /// This member is required.
    public var type: AthenaClientTypes.DataCatalogType?

    public init (
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        parameters: [Swift.String:Swift.String]? = nil,
        tags: [AthenaClientTypes.Tag]? = nil,
        type: AthenaClientTypes.DataCatalogType? = nil
    )
    {
        self.description = description
        self.name = name
        self.parameters = parameters
        self.tags = tags
        self.type = type
    }
}

struct CreateDataCatalogInputBody: Swift.Equatable {
    let name: Swift.String?
    let type: AthenaClientTypes.DataCatalogType?
    let description: Swift.String?
    let parameters: [Swift.String:Swift.String]?
    let tags: [AthenaClientTypes.Tag]?
}

extension CreateDataCatalogInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
        case parameters = "Parameters"
        case tags = "Tags"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.DataCatalogType.self, forKey: .type)
        type = typeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let parametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .parameters)
        var parametersDecoded0: [Swift.String:Swift.String]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, parametersmapvalue0) in parametersContainer {
                if let parametersmapvalue0 = parametersmapvalue0 {
                    parametersDecoded0?[key0] = parametersmapvalue0
                }
            }
        }
        parameters = parametersDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([AthenaClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[AthenaClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [AthenaClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateDataCatalogOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDataCatalogOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateDataCatalogOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDataCatalogOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct CreateDataCatalogOutputResponse: Swift.Equatable {

    public init () { }
}

extension CreateNamedQueryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case database = "Database"
        case description = "Description"
        case name = "Name"
        case queryString = "QueryString"
        case workGroup = "WorkGroup"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let database = self.database {
            try encodeContainer.encode(database, forKey: .database)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let queryString = self.queryString {
            try encodeContainer.encode(queryString, forKey: .queryString)
        }
        if let workGroup = self.workGroup {
            try encodeContainer.encode(workGroup, forKey: .workGroup)
        }
    }
}

extension CreateNamedQueryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateNamedQueryInput: Swift.Equatable {
    /// A unique case-sensitive string used to ensure the request to create the query is idempotent (executes only once). If another CreateNamedQuery request is received, the same response is returned and another query is not created. If a parameter has changed, for example, the QueryString, an error is returned. This token is listed as not required because Amazon Web Services SDKs (for example the Amazon Web Services SDK for Java) auto-generate the token for users. If you are not using the Amazon Web Services SDK or the Amazon Web Services CLI, you must provide this token or the action will fail.
    public var clientRequestToken: Swift.String?
    /// The database to which the query belongs.
    /// This member is required.
    public var database: Swift.String?
    /// The query description.
    public var description: Swift.String?
    /// The query name.
    /// This member is required.
    public var name: Swift.String?
    /// The contents of the query with all query statements.
    /// This member is required.
    public var queryString: Swift.String?
    /// The name of the workgroup in which the named query is being created.
    public var workGroup: Swift.String?

    public init (
        clientRequestToken: Swift.String? = nil,
        database: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        queryString: Swift.String? = nil,
        workGroup: Swift.String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.database = database
        self.description = description
        self.name = name
        self.queryString = queryString
        self.workGroup = workGroup
    }
}

struct CreateNamedQueryInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let database: Swift.String?
    let queryString: Swift.String?
    let clientRequestToken: Swift.String?
    let workGroup: Swift.String?
}

extension CreateNamedQueryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case database = "Database"
        case description = "Description"
        case name = "Name"
        case queryString = "QueryString"
        case workGroup = "WorkGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let databaseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .database)
        database = databaseDecoded
        let queryStringDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryString)
        queryString = queryStringDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let workGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workGroup)
        workGroup = workGroupDecoded
    }
}

extension CreateNamedQueryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateNamedQueryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateNamedQueryOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateNamedQueryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateNamedQueryOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.namedQueryId = output.namedQueryId
        } else {
            self.namedQueryId = nil
        }
    }
}

public struct CreateNamedQueryOutputResponse: Swift.Equatable {
    /// The unique ID of the query.
    public var namedQueryId: Swift.String?

    public init (
        namedQueryId: Swift.String? = nil
    )
    {
        self.namedQueryId = namedQueryId
    }
}

struct CreateNamedQueryOutputResponseBody: Swift.Equatable {
    let namedQueryId: Swift.String?
}

extension CreateNamedQueryOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case namedQueryId = "NamedQueryId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namedQueryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namedQueryId)
        namedQueryId = namedQueryIdDecoded
    }
}

extension CreateNotebookInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case name = "Name"
        case workGroup = "WorkGroup"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let workGroup = self.workGroup {
            try encodeContainer.encode(workGroup, forKey: .workGroup)
        }
    }
}

extension CreateNotebookInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateNotebookInput: Swift.Equatable {
    /// A unique case-sensitive string used to ensure the request to create the notebook is idempotent (executes only once). This token is listed as not required because Amazon Web Services SDKs (for example the Amazon Web Services SDK for Java) auto-generate the token for you. If you are not using the Amazon Web Services SDK or the Amazon Web Services CLI, you must provide this token or the action will fail.
    public var clientRequestToken: Swift.String?
    /// The name of the ipynb file to be created in the Spark workgroup, without the .ipynb extension.
    /// This member is required.
    public var name: Swift.String?
    /// The name of the Spark enabled workgroup in which the notebook will be created.
    /// This member is required.
    public var workGroup: Swift.String?

    public init (
        clientRequestToken: Swift.String? = nil,
        name: Swift.String? = nil,
        workGroup: Swift.String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.name = name
        self.workGroup = workGroup
    }
}

struct CreateNotebookInputBody: Swift.Equatable {
    let workGroup: Swift.String?
    let name: Swift.String?
    let clientRequestToken: Swift.String?
}

extension CreateNotebookInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case name = "Name"
        case workGroup = "WorkGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workGroup)
        workGroup = workGroupDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
    }
}

extension CreateNotebookOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateNotebookOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateNotebookOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateNotebookOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateNotebookOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.notebookId = output.notebookId
        } else {
            self.notebookId = nil
        }
    }
}

public struct CreateNotebookOutputResponse: Swift.Equatable {
    /// A unique identifier for the notebook.
    public var notebookId: Swift.String?

    public init (
        notebookId: Swift.String? = nil
    )
    {
        self.notebookId = notebookId
    }
}

struct CreateNotebookOutputResponseBody: Swift.Equatable {
    let notebookId: Swift.String?
}

extension CreateNotebookOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case notebookId = "NotebookId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let notebookIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .notebookId)
        notebookId = notebookIdDecoded
    }
}

extension CreatePreparedStatementInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case queryStatement = "QueryStatement"
        case statementName = "StatementName"
        case workGroup = "WorkGroup"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let queryStatement = self.queryStatement {
            try encodeContainer.encode(queryStatement, forKey: .queryStatement)
        }
        if let statementName = self.statementName {
            try encodeContainer.encode(statementName, forKey: .statementName)
        }
        if let workGroup = self.workGroup {
            try encodeContainer.encode(workGroup, forKey: .workGroup)
        }
    }
}

extension CreatePreparedStatementInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreatePreparedStatementInput: Swift.Equatable {
    /// The description of the prepared statement.
    public var description: Swift.String?
    /// The query string for the prepared statement.
    /// This member is required.
    public var queryStatement: Swift.String?
    /// The name of the prepared statement.
    /// This member is required.
    public var statementName: Swift.String?
    /// The name of the workgroup to which the prepared statement belongs.
    /// This member is required.
    public var workGroup: Swift.String?

    public init (
        description: Swift.String? = nil,
        queryStatement: Swift.String? = nil,
        statementName: Swift.String? = nil,
        workGroup: Swift.String? = nil
    )
    {
        self.description = description
        self.queryStatement = queryStatement
        self.statementName = statementName
        self.workGroup = workGroup
    }
}

struct CreatePreparedStatementInputBody: Swift.Equatable {
    let statementName: Swift.String?
    let workGroup: Swift.String?
    let queryStatement: Swift.String?
    let description: Swift.String?
}

extension CreatePreparedStatementInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case queryStatement = "QueryStatement"
        case statementName = "StatementName"
        case workGroup = "WorkGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statementNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statementName)
        statementName = statementNameDecoded
        let workGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workGroup)
        workGroup = workGroupDecoded
        let queryStatementDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryStatement)
        queryStatement = queryStatementDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension CreatePreparedStatementOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreatePreparedStatementOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreatePreparedStatementOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreatePreparedStatementOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct CreatePreparedStatementOutputResponse: Swift.Equatable {

    public init () { }
}

extension CreatePresignedNotebookUrlInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sessionId = "SessionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sessionId = self.sessionId {
            try encodeContainer.encode(sessionId, forKey: .sessionId)
        }
    }
}

extension CreatePresignedNotebookUrlInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreatePresignedNotebookUrlInput: Swift.Equatable {
    /// The session ID.
    /// This member is required.
    public var sessionId: Swift.String?

    public init (
        sessionId: Swift.String? = nil
    )
    {
        self.sessionId = sessionId
    }
}

struct CreatePresignedNotebookUrlInputBody: Swift.Equatable {
    let sessionId: Swift.String?
}

extension CreatePresignedNotebookUrlInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sessionId = "SessionId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionId)
        sessionId = sessionIdDecoded
    }
}

extension CreatePresignedNotebookUrlOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreatePresignedNotebookUrlOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreatePresignedNotebookUrlOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreatePresignedNotebookUrlOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreatePresignedNotebookUrlOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.authToken = output.authToken
            self.authTokenExpirationTime = output.authTokenExpirationTime
            self.notebookUrl = output.notebookUrl
        } else {
            self.authToken = nil
            self.authTokenExpirationTime = nil
            self.notebookUrl = nil
        }
    }
}

public struct CreatePresignedNotebookUrlOutputResponse: Swift.Equatable {
    /// The authentication token for the notebook.
    /// This member is required.
    public var authToken: Swift.String?
    /// The UTC epoch time when the authentication token expires.
    /// This member is required.
    public var authTokenExpirationTime: Swift.Int?
    /// The URL of the notebook. The URL includes the authentication token and notebook file name and points directly to the opened notebook.
    /// This member is required.
    public var notebookUrl: Swift.String?

    public init (
        authToken: Swift.String? = nil,
        authTokenExpirationTime: Swift.Int? = nil,
        notebookUrl: Swift.String? = nil
    )
    {
        self.authToken = authToken
        self.authTokenExpirationTime = authTokenExpirationTime
        self.notebookUrl = notebookUrl
    }
}

struct CreatePresignedNotebookUrlOutputResponseBody: Swift.Equatable {
    let notebookUrl: Swift.String?
    let authToken: Swift.String?
    let authTokenExpirationTime: Swift.Int?
}

extension CreatePresignedNotebookUrlOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authToken = "AuthToken"
        case authTokenExpirationTime = "AuthTokenExpirationTime"
        case notebookUrl = "NotebookUrl"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let notebookUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .notebookUrl)
        notebookUrl = notebookUrlDecoded
        let authTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authToken)
        authToken = authTokenDecoded
        let authTokenExpirationTimeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .authTokenExpirationTime)
        authTokenExpirationTime = authTokenExpirationTimeDecoded
    }
}

extension CreateWorkGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration = "Configuration"
        case description = "Description"
        case name = "Name"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configuration = self.configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateWorkGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateWorkGroupInput: Swift.Equatable {
    /// Contains configuration information for creating an Athena SQL workgroup, which includes the location in Amazon S3 where query results are stored, the encryption configuration, if any, used for encrypting query results, whether the Amazon CloudWatch Metrics are enabled for the workgroup, the limit for the amount of bytes scanned (cutoff) per query, if it is specified, and whether workgroup's settings (specified with EnforceWorkGroupConfiguration) in the WorkGroupConfiguration override client-side settings. See [WorkGroupConfiguration$EnforceWorkGroupConfiguration].
    public var configuration: AthenaClientTypes.WorkGroupConfiguration?
    /// The workgroup description.
    public var description: Swift.String?
    /// The workgroup name.
    /// This member is required.
    public var name: Swift.String?
    /// A list of comma separated tags to add to the workgroup that is created.
    public var tags: [AthenaClientTypes.Tag]?

    public init (
        configuration: AthenaClientTypes.WorkGroupConfiguration? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [AthenaClientTypes.Tag]? = nil
    )
    {
        self.configuration = configuration
        self.description = description
        self.name = name
        self.tags = tags
    }
}

struct CreateWorkGroupInputBody: Swift.Equatable {
    let name: Swift.String?
    let configuration: AthenaClientTypes.WorkGroupConfiguration?
    let description: Swift.String?
    let tags: [AthenaClientTypes.Tag]?
}

extension CreateWorkGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration = "Configuration"
        case description = "Description"
        case name = "Name"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let configurationDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.WorkGroupConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([AthenaClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[AthenaClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [AthenaClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateWorkGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateWorkGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateWorkGroupOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateWorkGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct CreateWorkGroupOutputResponse: Swift.Equatable {

    public init () { }
}

extension AthenaClientTypes.CustomerContentEncryptionConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kmsKey = "KmsKey"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kmsKey = self.kmsKey {
            try encodeContainer.encode(kmsKey, forKey: .kmsKey)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let kmsKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKey)
        kmsKey = kmsKeyDecoded
    }
}

extension AthenaClientTypes {
    /// Specifies the KMS key that is used to encrypt the user's data stores in Athena.
    public struct CustomerContentEncryptionConfiguration: Swift.Equatable {
        /// The KMS key that is used to encrypt the user's data stores in Athena.
        /// This member is required.
        public var kmsKey: Swift.String?

        public init (
            kmsKey: Swift.String? = nil
        )
        {
            self.kmsKey = kmsKey
        }
    }

}

extension AthenaClientTypes.DataCatalog: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
        case parameters = "Parameters"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .parameters)
            for (dictKey0, parametersMap0) in parameters {
                try parametersContainer.encode(parametersMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.DataCatalogType.self, forKey: .type)
        type = typeDecoded
        let parametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .parameters)
        var parametersDecoded0: [Swift.String:Swift.String]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, parametersmapvalue0) in parametersContainer {
                if let parametersmapvalue0 = parametersmapvalue0 {
                    parametersDecoded0?[key0] = parametersmapvalue0
                }
            }
        }
        parameters = parametersDecoded0
    }
}

extension AthenaClientTypes {
    /// Contains information about a data catalog in an Amazon Web Services account.
    public struct DataCatalog: Swift.Equatable {
        /// An optional description of the data catalog.
        public var description: Swift.String?
        /// The name of the data catalog. The catalog name must be unique for the Amazon Web Services account and can use a maximum of 127 alphanumeric, underscore, at sign, or hyphen characters. The remainder of the length constraint of 256 is reserved for use by Athena.
        /// This member is required.
        public var name: Swift.String?
        /// Specifies the Lambda function or functions to use for the data catalog. This is a mapping whose values depend on the catalog type.
        ///
        /// * For the HIVE data catalog type, use the following syntax. The metadata-function parameter is required. The sdk-version parameter is optional and defaults to the currently supported version. metadata-function=lambda_arn, sdk-version=version_number
        ///
        /// * For the LAMBDA data catalog type, use one of the following sets of required parameters, but not both.
        ///
        /// * If you have one Lambda function that processes metadata and another for reading the actual data, use the following syntax. Both parameters are required. metadata-function=lambda_arn, record-function=lambda_arn
        ///
        /// * If you have a composite Lambda function that processes both metadata and data, use the following syntax to specify your Lambda function. function=lambda_arn
        ///
        ///
        ///
        ///
        /// * The GLUE type takes a catalog ID parameter and is required. The  catalog_id  is the account ID of the Amazon Web Services account to which the Glue catalog belongs. catalog-id=catalog_id
        ///
        /// * The GLUE data catalog type also applies to the default AwsDataCatalog that already exists in your account, of which you can have only one and cannot modify.
        ///
        /// * Queries that specify a Glue Data Catalog other than the default AwsDataCatalog must be run on Athena engine version 2.
        public var parameters: [Swift.String:Swift.String]?
        /// The type of data catalog to create: LAMBDA for a federated catalog, HIVE for an external hive metastore, or GLUE for an Glue Data Catalog.
        /// This member is required.
        public var type: AthenaClientTypes.DataCatalogType?

        public init (
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            parameters: [Swift.String:Swift.String]? = nil,
            type: AthenaClientTypes.DataCatalogType? = nil
        )
        {
            self.description = description
            self.name = name
            self.parameters = parameters
            self.type = type
        }
    }

}

extension AthenaClientTypes.DataCatalogSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalogName = "CatalogName"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogName = self.catalogName {
            try encodeContainer.encode(catalogName, forKey: .catalogName)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .catalogName)
        catalogName = catalogNameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.DataCatalogType.self, forKey: .type)
        type = typeDecoded
    }
}

extension AthenaClientTypes {
    /// The summary information for the data catalog, which includes its name and type.
    public struct DataCatalogSummary: Swift.Equatable {
        /// The name of the data catalog. The catalog name is unique for the Amazon Web Services account and can use a maximum of 127 alphanumeric, underscore, at sign, or hyphen characters. The remainder of the length constraint of 256 is reserved for use by Athena.
        public var catalogName: Swift.String?
        /// The data catalog type.
        public var type: AthenaClientTypes.DataCatalogType?

        public init (
            catalogName: Swift.String? = nil,
            type: AthenaClientTypes.DataCatalogType? = nil
        )
        {
            self.catalogName = catalogName
            self.type = type
        }
    }

}

extension AthenaClientTypes {
    public enum DataCatalogType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case glue
        case hive
        case lambda
        case sdkUnknown(Swift.String)

        public static var allCases: [DataCatalogType] {
            return [
                .glue,
                .hive,
                .lambda,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .glue: return "GLUE"
            case .hive: return "HIVE"
            case .lambda: return "LAMBDA"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DataCatalogType(rawValue: rawValue) ?? DataCatalogType.sdkUnknown(rawValue)
        }
    }
}

extension AthenaClientTypes.Database: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
        case parameters = "Parameters"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .parameters)
            for (dictKey0, parametersMap0) in parameters {
                try parametersContainer.encode(parametersMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let parametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .parameters)
        var parametersDecoded0: [Swift.String:Swift.String]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, parametersmapvalue0) in parametersContainer {
                if let parametersmapvalue0 = parametersmapvalue0 {
                    parametersDecoded0?[key0] = parametersmapvalue0
                }
            }
        }
        parameters = parametersDecoded0
    }
}

extension AthenaClientTypes {
    /// Contains metadata information for a database in a data catalog.
    public struct Database: Swift.Equatable {
        /// An optional description of the database.
        public var description: Swift.String?
        /// The name of the database.
        /// This member is required.
        public var name: Swift.String?
        /// A set of custom key/value pairs.
        public var parameters: [Swift.String:Swift.String]?

        public init (
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            parameters: [Swift.String:Swift.String]? = nil
        )
        {
            self.description = description
            self.name = name
            self.parameters = parameters
        }
    }

}

extension AthenaClientTypes.Datum: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case varCharValue = "VarCharValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let varCharValue = self.varCharValue {
            try encodeContainer.encode(varCharValue, forKey: .varCharValue)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let varCharValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .varCharValue)
        varCharValue = varCharValueDecoded
    }
}

extension AthenaClientTypes {
    /// A piece of data (a field in the table).
    public struct Datum: Swift.Equatable {
        /// The value of the datum.
        public var varCharValue: Swift.String?

        public init (
            varCharValue: Swift.String? = nil
        )
        {
            self.varCharValue = varCharValue
        }
    }

}

extension DeleteDataCatalogInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension DeleteDataCatalogInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteDataCatalogInput: Swift.Equatable {
    /// The name of the data catalog to delete.
    /// This member is required.
    public var name: Swift.String?

    public init (
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct DeleteDataCatalogInputBody: Swift.Equatable {
    let name: Swift.String?
}

extension DeleteDataCatalogInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DeleteDataCatalogOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDataCatalogOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteDataCatalogOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDataCatalogOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDataCatalogOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteNamedQueryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case namedQueryId = "NamedQueryId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let namedQueryId = self.namedQueryId {
            try encodeContainer.encode(namedQueryId, forKey: .namedQueryId)
        }
    }
}

extension DeleteNamedQueryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteNamedQueryInput: Swift.Equatable {
    /// The unique ID of the query to delete.
    /// This member is required.
    public var namedQueryId: Swift.String?

    public init (
        namedQueryId: Swift.String? = nil
    )
    {
        self.namedQueryId = namedQueryId
    }
}

struct DeleteNamedQueryInputBody: Swift.Equatable {
    let namedQueryId: Swift.String?
}

extension DeleteNamedQueryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case namedQueryId = "NamedQueryId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namedQueryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namedQueryId)
        namedQueryId = namedQueryIdDecoded
    }
}

extension DeleteNamedQueryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteNamedQueryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteNamedQueryOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteNamedQueryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteNamedQueryOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteNotebookInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case notebookId = "NotebookId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let notebookId = self.notebookId {
            try encodeContainer.encode(notebookId, forKey: .notebookId)
        }
    }
}

extension DeleteNotebookInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteNotebookInput: Swift.Equatable {
    /// The ID of the notebook to delete.
    /// This member is required.
    public var notebookId: Swift.String?

    public init (
        notebookId: Swift.String? = nil
    )
    {
        self.notebookId = notebookId
    }
}

struct DeleteNotebookInputBody: Swift.Equatable {
    let notebookId: Swift.String?
}

extension DeleteNotebookInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case notebookId = "NotebookId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let notebookIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .notebookId)
        notebookId = notebookIdDecoded
    }
}

extension DeleteNotebookOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteNotebookOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteNotebookOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteNotebookOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteNotebookOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeletePreparedStatementInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case statementName = "StatementName"
        case workGroup = "WorkGroup"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let statementName = self.statementName {
            try encodeContainer.encode(statementName, forKey: .statementName)
        }
        if let workGroup = self.workGroup {
            try encodeContainer.encode(workGroup, forKey: .workGroup)
        }
    }
}

extension DeletePreparedStatementInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeletePreparedStatementInput: Swift.Equatable {
    /// The name of the prepared statement to delete.
    /// This member is required.
    public var statementName: Swift.String?
    /// The workgroup to which the statement to be deleted belongs.
    /// This member is required.
    public var workGroup: Swift.String?

    public init (
        statementName: Swift.String? = nil,
        workGroup: Swift.String? = nil
    )
    {
        self.statementName = statementName
        self.workGroup = workGroup
    }
}

struct DeletePreparedStatementInputBody: Swift.Equatable {
    let statementName: Swift.String?
    let workGroup: Swift.String?
}

extension DeletePreparedStatementInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case statementName = "StatementName"
        case workGroup = "WorkGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statementNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statementName)
        statementName = statementNameDecoded
        let workGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workGroup)
        workGroup = workGroupDecoded
    }
}

extension DeletePreparedStatementOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeletePreparedStatementOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeletePreparedStatementOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeletePreparedStatementOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeletePreparedStatementOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteWorkGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recursiveDeleteOption = "RecursiveDeleteOption"
        case workGroup = "WorkGroup"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let recursiveDeleteOption = self.recursiveDeleteOption {
            try encodeContainer.encode(recursiveDeleteOption, forKey: .recursiveDeleteOption)
        }
        if let workGroup = self.workGroup {
            try encodeContainer.encode(workGroup, forKey: .workGroup)
        }
    }
}

extension DeleteWorkGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteWorkGroupInput: Swift.Equatable {
    /// The option to delete the workgroup and its contents even if the workgroup contains any named queries or query executions.
    public var recursiveDeleteOption: Swift.Bool?
    /// The unique name of the workgroup to delete.
    /// This member is required.
    public var workGroup: Swift.String?

    public init (
        recursiveDeleteOption: Swift.Bool? = nil,
        workGroup: Swift.String? = nil
    )
    {
        self.recursiveDeleteOption = recursiveDeleteOption
        self.workGroup = workGroup
    }
}

struct DeleteWorkGroupInputBody: Swift.Equatable {
    let workGroup: Swift.String?
    let recursiveDeleteOption: Swift.Bool?
}

extension DeleteWorkGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recursiveDeleteOption = "RecursiveDeleteOption"
        case workGroup = "WorkGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workGroup)
        workGroup = workGroupDecoded
        let recursiveDeleteOptionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .recursiveDeleteOption)
        recursiveDeleteOption = recursiveDeleteOptionDecoded
    }
}

extension DeleteWorkGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteWorkGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteWorkGroupOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteWorkGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteWorkGroupOutputResponse: Swift.Equatable {

    public init () { }
}

extension AthenaClientTypes.EncryptionConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case encryptionOption = "EncryptionOption"
        case kmsKey = "KmsKey"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encryptionOption = self.encryptionOption {
            try encodeContainer.encode(encryptionOption.rawValue, forKey: .encryptionOption)
        }
        if let kmsKey = self.kmsKey {
            try encodeContainer.encode(kmsKey, forKey: .kmsKey)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let encryptionOptionDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.EncryptionOption.self, forKey: .encryptionOption)
        encryptionOption = encryptionOptionDecoded
        let kmsKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKey)
        kmsKey = kmsKeyDecoded
    }
}

extension AthenaClientTypes {
    /// If query results are encrypted in Amazon S3, indicates the encryption option used (for example, SSE_KMS or CSE_KMS) and key information.
    public struct EncryptionConfiguration: Swift.Equatable {
        /// Indicates whether Amazon S3 server-side encryption with Amazon S3-managed keys (SSE_S3), server-side encryption with KMS-managed keys (SSE_KMS), or client-side encryption with KMS-managed keys (CSE_KMS) is used. If a query runs in a workgroup and the workgroup overrides client-side settings, then the workgroup's setting for encryption is used. It specifies whether query results must be encrypted, for all queries that run in this workgroup.
        /// This member is required.
        public var encryptionOption: AthenaClientTypes.EncryptionOption?
        /// For SSE_KMS and CSE_KMS, this is the KMS key ARN or ID.
        public var kmsKey: Swift.String?

        public init (
            encryptionOption: AthenaClientTypes.EncryptionOption? = nil,
            kmsKey: Swift.String? = nil
        )
        {
            self.encryptionOption = encryptionOption
            self.kmsKey = kmsKey
        }
    }

}

extension AthenaClientTypes {
    public enum EncryptionOption: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cseKms
        case sseKms
        case sseS3
        case sdkUnknown(Swift.String)

        public static var allCases: [EncryptionOption] {
            return [
                .cseKms,
                .sseKms,
                .sseS3,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cseKms: return "CSE_KMS"
            case .sseKms: return "SSE_KMS"
            case .sseS3: return "SSE_S3"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EncryptionOption(rawValue: rawValue) ?? EncryptionOption.sdkUnknown(rawValue)
        }
    }
}

extension AthenaClientTypes.EngineConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalConfigs = "AdditionalConfigs"
        case coordinatorDpuSize = "CoordinatorDpuSize"
        case defaultExecutorDpuSize = "DefaultExecutorDpuSize"
        case maxConcurrentDpus = "MaxConcurrentDpus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalConfigs = additionalConfigs {
            var additionalConfigsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .additionalConfigs)
            for (dictKey0, parametersMap0) in additionalConfigs {
                try additionalConfigsContainer.encode(parametersMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if coordinatorDpuSize != 0 {
            try encodeContainer.encode(coordinatorDpuSize, forKey: .coordinatorDpuSize)
        }
        if defaultExecutorDpuSize != 0 {
            try encodeContainer.encode(defaultExecutorDpuSize, forKey: .defaultExecutorDpuSize)
        }
        if maxConcurrentDpus != 0 {
            try encodeContainer.encode(maxConcurrentDpus, forKey: .maxConcurrentDpus)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let coordinatorDpuSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .coordinatorDpuSize) ?? 0
        coordinatorDpuSize = coordinatorDpuSizeDecoded
        let maxConcurrentDpusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxConcurrentDpus) ?? 0
        maxConcurrentDpus = maxConcurrentDpusDecoded
        let defaultExecutorDpuSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .defaultExecutorDpuSize) ?? 0
        defaultExecutorDpuSize = defaultExecutorDpuSizeDecoded
        let additionalConfigsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .additionalConfigs)
        var additionalConfigsDecoded0: [Swift.String:Swift.String]? = nil
        if let additionalConfigsContainer = additionalConfigsContainer {
            additionalConfigsDecoded0 = [Swift.String:Swift.String]()
            for (key0, parametersmapvalue0) in additionalConfigsContainer {
                if let parametersmapvalue0 = parametersmapvalue0 {
                    additionalConfigsDecoded0?[key0] = parametersmapvalue0
                }
            }
        }
        additionalConfigs = additionalConfigsDecoded0
    }
}

extension AthenaClientTypes {
    /// Contains data processing unit (DPU) configuration settings and parameter mappings for a notebook engine.
    public struct EngineConfiguration: Swift.Equatable {
        /// Contains additional notebook engine MAP parameter mappings in the form of key-value pairs. To specify an Amazon S3 URI that the Jupyter server will download and serve, specify a value for the [StartSessionRequest$NotebookVersion] field, and then add a key named NotebookFileURI to AdditionalConfigs that has value of the Amazon S3 URI.
        public var additionalConfigs: [Swift.String:Swift.String]?
        /// The number of DPUs to use for the coordinator. A coordinator is a special executor that orchestrates processing work and manages other executors in a notebook session.
        public var coordinatorDpuSize: Swift.Int
        /// The default number of DPUs to use for executors. An executor is the smallest unit of compute that a notebook session can request from Athena.
        public var defaultExecutorDpuSize: Swift.Int
        /// The maximum number of DPUs that can run concurrently.
        /// This member is required.
        public var maxConcurrentDpus: Swift.Int

        public init (
            additionalConfigs: [Swift.String:Swift.String]? = nil,
            coordinatorDpuSize: Swift.Int = 0,
            defaultExecutorDpuSize: Swift.Int = 0,
            maxConcurrentDpus: Swift.Int = 0
        )
        {
            self.additionalConfigs = additionalConfigs
            self.coordinatorDpuSize = coordinatorDpuSize
            self.defaultExecutorDpuSize = defaultExecutorDpuSize
            self.maxConcurrentDpus = maxConcurrentDpus
        }
    }

}

extension AthenaClientTypes.EngineVersion: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case effectiveEngineVersion = "EffectiveEngineVersion"
        case selectedEngineVersion = "SelectedEngineVersion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let effectiveEngineVersion = self.effectiveEngineVersion {
            try encodeContainer.encode(effectiveEngineVersion, forKey: .effectiveEngineVersion)
        }
        if let selectedEngineVersion = self.selectedEngineVersion {
            try encodeContainer.encode(selectedEngineVersion, forKey: .selectedEngineVersion)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let selectedEngineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .selectedEngineVersion)
        selectedEngineVersion = selectedEngineVersionDecoded
        let effectiveEngineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .effectiveEngineVersion)
        effectiveEngineVersion = effectiveEngineVersionDecoded
    }
}

extension AthenaClientTypes {
    /// The Athena engine version for running queries, or the PySpark engine version for running sessions.
    public struct EngineVersion: Swift.Equatable {
        /// Read only. The engine version on which the query runs. If the user requests a valid engine version other than Auto, the effective engine version is the same as the engine version that the user requested. If the user requests Auto, the effective engine version is chosen by Athena. When a request to update the engine version is made by a CreateWorkGroup or UpdateWorkGroup operation, the EffectiveEngineVersion field is ignored.
        public var effectiveEngineVersion: Swift.String?
        /// The engine version requested by the user. Possible values are determined by the output of ListEngineVersions, including Auto. The default is Auto.
        public var selectedEngineVersion: Swift.String?

        public init (
            effectiveEngineVersion: Swift.String? = nil,
            selectedEngineVersion: Swift.String? = nil
        )
        {
            self.effectiveEngineVersion = effectiveEngineVersion
            self.selectedEngineVersion = selectedEngineVersion
        }
    }

}

extension AthenaClientTypes {
    public enum ExecutorState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case created
        case creating
        case failed
        case registered
        case terminated
        case terminating
        case sdkUnknown(Swift.String)

        public static var allCases: [ExecutorState] {
            return [
                .created,
                .creating,
                .failed,
                .registered,
                .terminated,
                .terminating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .created: return "CREATED"
            case .creating: return "CREATING"
            case .failed: return "FAILED"
            case .registered: return "REGISTERED"
            case .terminated: return "TERMINATED"
            case .terminating: return "TERMINATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ExecutorState(rawValue: rawValue) ?? ExecutorState.sdkUnknown(rawValue)
        }
    }
}

extension AthenaClientTypes {
    public enum ExecutorType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case coordinator
        case gateway
        case worker
        case sdkUnknown(Swift.String)

        public static var allCases: [ExecutorType] {
            return [
                .coordinator,
                .gateway,
                .worker,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .coordinator: return "COORDINATOR"
            case .gateway: return "GATEWAY"
            case .worker: return "WORKER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ExecutorType(rawValue: rawValue) ?? ExecutorType.sdkUnknown(rawValue)
        }
    }
}

extension AthenaClientTypes.ExecutorsSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case executorId = "ExecutorId"
        case executorSize = "ExecutorSize"
        case executorState = "ExecutorState"
        case executorType = "ExecutorType"
        case startDateTime = "StartDateTime"
        case terminationDateTime = "TerminationDateTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let executorId = self.executorId {
            try encodeContainer.encode(executorId, forKey: .executorId)
        }
        if let executorSize = self.executorSize {
            try encodeContainer.encode(executorSize, forKey: .executorSize)
        }
        if let executorState = self.executorState {
            try encodeContainer.encode(executorState.rawValue, forKey: .executorState)
        }
        if let executorType = self.executorType {
            try encodeContainer.encode(executorType.rawValue, forKey: .executorType)
        }
        if let startDateTime = self.startDateTime {
            try encodeContainer.encode(startDateTime, forKey: .startDateTime)
        }
        if let terminationDateTime = self.terminationDateTime {
            try encodeContainer.encode(terminationDateTime, forKey: .terminationDateTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let executorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executorId)
        executorId = executorIdDecoded
        let executorTypeDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.ExecutorType.self, forKey: .executorType)
        executorType = executorTypeDecoded
        let startDateTimeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .startDateTime)
        startDateTime = startDateTimeDecoded
        let terminationDateTimeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .terminationDateTime)
        terminationDateTime = terminationDateTimeDecoded
        let executorStateDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.ExecutorState.self, forKey: .executorState)
        executorState = executorStateDecoded
        let executorSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .executorSize)
        executorSize = executorSizeDecoded
    }
}

extension AthenaClientTypes {
    /// Contains summary information about an executor.
    public struct ExecutorsSummary: Swift.Equatable {
        /// The UUID of the executor.
        /// This member is required.
        public var executorId: Swift.String?
        /// The smallest unit of compute that a session can request from Athena. Size is measured in data processing unit (DPU) values, a relative measure of processing power.
        public var executorSize: Swift.Int?
        /// The processing state of the executor. A description of each state follows. CREATING - The executor is being started, including acquiring resources. CREATED - The executor has been started. REGISTERED - The executor has been registered. TERMINATING - The executor is in the process of shutting down. TERMINATED - The executor is no longer running. FAILED - Due to a failure, the executor is no longer running.
        public var executorState: AthenaClientTypes.ExecutorState?
        /// The type of executor used for the application (COORDINATOR, GATEWAY, or WORKER).
        public var executorType: AthenaClientTypes.ExecutorType?
        /// The date and time that the executor started.
        public var startDateTime: Swift.Int?
        /// The date and time that the executor was terminated.
        public var terminationDateTime: Swift.Int?

        public init (
            executorId: Swift.String? = nil,
            executorSize: Swift.Int? = nil,
            executorState: AthenaClientTypes.ExecutorState? = nil,
            executorType: AthenaClientTypes.ExecutorType? = nil,
            startDateTime: Swift.Int? = nil,
            terminationDateTime: Swift.Int? = nil
        )
        {
            self.executorId = executorId
            self.executorSize = executorSize
            self.executorState = executorState
            self.executorType = executorType
            self.startDateTime = startDateTime
            self.terminationDateTime = terminationDateTime
        }
    }

}

extension ExportNotebookInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case notebookId = "NotebookId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let notebookId = self.notebookId {
            try encodeContainer.encode(notebookId, forKey: .notebookId)
        }
    }
}

extension ExportNotebookInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ExportNotebookInput: Swift.Equatable {
    /// The ID of the notebook to export.
    /// This member is required.
    public var notebookId: Swift.String?

    public init (
        notebookId: Swift.String? = nil
    )
    {
        self.notebookId = notebookId
    }
}

struct ExportNotebookInputBody: Swift.Equatable {
    let notebookId: Swift.String?
}

extension ExportNotebookInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case notebookId = "NotebookId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let notebookIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .notebookId)
        notebookId = notebookIdDecoded
    }
}

extension ExportNotebookOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ExportNotebookOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ExportNotebookOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ExportNotebookOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ExportNotebookOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.notebookMetadata = output.notebookMetadata
            self.payload = output.payload
        } else {
            self.notebookMetadata = nil
            self.payload = nil
        }
    }
}

public struct ExportNotebookOutputResponse: Swift.Equatable {
    /// The notebook metadata, including notebook ID, notebook name, and workgroup name.
    public var notebookMetadata: AthenaClientTypes.NotebookMetadata?
    /// The content of the exported notebook.
    public var payload: Swift.String?

    public init (
        notebookMetadata: AthenaClientTypes.NotebookMetadata? = nil,
        payload: Swift.String? = nil
    )
    {
        self.notebookMetadata = notebookMetadata
        self.payload = payload
    }
}

struct ExportNotebookOutputResponseBody: Swift.Equatable {
    let notebookMetadata: AthenaClientTypes.NotebookMetadata?
    let payload: Swift.String?
}

extension ExportNotebookOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case notebookMetadata = "NotebookMetadata"
        case payload = "Payload"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let notebookMetadataDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.NotebookMetadata.self, forKey: .notebookMetadata)
        notebookMetadata = notebookMetadataDecoded
        let payloadDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .payload)
        payload = payloadDecoded
    }
}

extension AthenaClientTypes.FilterDefinition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension AthenaClientTypes {
    /// A string for searching notebook names.
    public struct FilterDefinition: Swift.Equatable {
        /// The name of the notebook to search for.
        public var name: Swift.String?

        public init (
            name: Swift.String? = nil
        )
        {
            self.name = name
        }
    }

}

extension GetCalculationExecutionCodeInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case calculationExecutionId = "CalculationExecutionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let calculationExecutionId = self.calculationExecutionId {
            try encodeContainer.encode(calculationExecutionId, forKey: .calculationExecutionId)
        }
    }
}

extension GetCalculationExecutionCodeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetCalculationExecutionCodeInput: Swift.Equatable {
    /// The calculation execution UUID.
    /// This member is required.
    public var calculationExecutionId: Swift.String?

    public init (
        calculationExecutionId: Swift.String? = nil
    )
    {
        self.calculationExecutionId = calculationExecutionId
    }
}

struct GetCalculationExecutionCodeInputBody: Swift.Equatable {
    let calculationExecutionId: Swift.String?
}

extension GetCalculationExecutionCodeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case calculationExecutionId = "CalculationExecutionId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let calculationExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .calculationExecutionId)
        calculationExecutionId = calculationExecutionIdDecoded
    }
}

extension GetCalculationExecutionCodeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetCalculationExecutionCodeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetCalculationExecutionCodeOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetCalculationExecutionCodeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetCalculationExecutionCodeOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.codeBlock = output.codeBlock
        } else {
            self.codeBlock = nil
        }
    }
}

public struct GetCalculationExecutionCodeOutputResponse: Swift.Equatable {
    /// A pre-signed URL to the code that executed the calculation.
    public var codeBlock: Swift.String?

    public init (
        codeBlock: Swift.String? = nil
    )
    {
        self.codeBlock = codeBlock
    }
}

struct GetCalculationExecutionCodeOutputResponseBody: Swift.Equatable {
    let codeBlock: Swift.String?
}

extension GetCalculationExecutionCodeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case codeBlock = "CodeBlock"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeBlockDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .codeBlock)
        codeBlock = codeBlockDecoded
    }
}

extension GetCalculationExecutionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case calculationExecutionId = "CalculationExecutionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let calculationExecutionId = self.calculationExecutionId {
            try encodeContainer.encode(calculationExecutionId, forKey: .calculationExecutionId)
        }
    }
}

extension GetCalculationExecutionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetCalculationExecutionInput: Swift.Equatable {
    /// The calculation execution UUID.
    /// This member is required.
    public var calculationExecutionId: Swift.String?

    public init (
        calculationExecutionId: Swift.String? = nil
    )
    {
        self.calculationExecutionId = calculationExecutionId
    }
}

struct GetCalculationExecutionInputBody: Swift.Equatable {
    let calculationExecutionId: Swift.String?
}

extension GetCalculationExecutionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case calculationExecutionId = "CalculationExecutionId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let calculationExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .calculationExecutionId)
        calculationExecutionId = calculationExecutionIdDecoded
    }
}

extension GetCalculationExecutionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetCalculationExecutionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetCalculationExecutionOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetCalculationExecutionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetCalculationExecutionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.calculationExecutionId = output.calculationExecutionId
            self.description = output.description
            self.result = output.result
            self.sessionId = output.sessionId
            self.statistics = output.statistics
            self.status = output.status
            self.workingDirectory = output.workingDirectory
        } else {
            self.calculationExecutionId = nil
            self.description = nil
            self.result = nil
            self.sessionId = nil
            self.statistics = nil
            self.status = nil
            self.workingDirectory = nil
        }
    }
}

public struct GetCalculationExecutionOutputResponse: Swift.Equatable {
    /// The calculation execution UUID.
    public var calculationExecutionId: Swift.String?
    /// The description of the calculation execution.
    public var description: Swift.String?
    /// Contains result information. This field is populated only if the calculation is completed.
    public var result: AthenaClientTypes.CalculationResult?
    /// The session ID that the calculation ran in.
    public var sessionId: Swift.String?
    /// Contains information about the data processing unit (DPU) execution time and progress. This field is populated only when statistics are available.
    public var statistics: AthenaClientTypes.CalculationStatistics?
    /// Contains information about the status of the calculation.
    public var status: AthenaClientTypes.CalculationStatus?
    /// The Amazon S3 location in which calculation results are stored.
    public var workingDirectory: Swift.String?

    public init (
        calculationExecutionId: Swift.String? = nil,
        description: Swift.String? = nil,
        result: AthenaClientTypes.CalculationResult? = nil,
        sessionId: Swift.String? = nil,
        statistics: AthenaClientTypes.CalculationStatistics? = nil,
        status: AthenaClientTypes.CalculationStatus? = nil,
        workingDirectory: Swift.String? = nil
    )
    {
        self.calculationExecutionId = calculationExecutionId
        self.description = description
        self.result = result
        self.sessionId = sessionId
        self.statistics = statistics
        self.status = status
        self.workingDirectory = workingDirectory
    }
}

struct GetCalculationExecutionOutputResponseBody: Swift.Equatable {
    let calculationExecutionId: Swift.String?
    let sessionId: Swift.String?
    let description: Swift.String?
    let workingDirectory: Swift.String?
    let status: AthenaClientTypes.CalculationStatus?
    let statistics: AthenaClientTypes.CalculationStatistics?
    let result: AthenaClientTypes.CalculationResult?
}

extension GetCalculationExecutionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case calculationExecutionId = "CalculationExecutionId"
        case description = "Description"
        case result = "Result"
        case sessionId = "SessionId"
        case statistics = "Statistics"
        case status = "Status"
        case workingDirectory = "WorkingDirectory"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let calculationExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .calculationExecutionId)
        calculationExecutionId = calculationExecutionIdDecoded
        let sessionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionId)
        sessionId = sessionIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let workingDirectoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workingDirectory)
        workingDirectory = workingDirectoryDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.CalculationStatus.self, forKey: .status)
        status = statusDecoded
        let statisticsDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.CalculationStatistics.self, forKey: .statistics)
        statistics = statisticsDecoded
        let resultDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.CalculationResult.self, forKey: .result)
        result = resultDecoded
    }
}

extension GetCalculationExecutionStatusInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case calculationExecutionId = "CalculationExecutionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let calculationExecutionId = self.calculationExecutionId {
            try encodeContainer.encode(calculationExecutionId, forKey: .calculationExecutionId)
        }
    }
}

extension GetCalculationExecutionStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetCalculationExecutionStatusInput: Swift.Equatable {
    /// The calculation execution UUID.
    /// This member is required.
    public var calculationExecutionId: Swift.String?

    public init (
        calculationExecutionId: Swift.String? = nil
    )
    {
        self.calculationExecutionId = calculationExecutionId
    }
}

struct GetCalculationExecutionStatusInputBody: Swift.Equatable {
    let calculationExecutionId: Swift.String?
}

extension GetCalculationExecutionStatusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case calculationExecutionId = "CalculationExecutionId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let calculationExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .calculationExecutionId)
        calculationExecutionId = calculationExecutionIdDecoded
    }
}

extension GetCalculationExecutionStatusOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetCalculationExecutionStatusOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetCalculationExecutionStatusOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetCalculationExecutionStatusOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetCalculationExecutionStatusOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.statistics = output.statistics
            self.status = output.status
        } else {
            self.statistics = nil
            self.status = nil
        }
    }
}

public struct GetCalculationExecutionStatusOutputResponse: Swift.Equatable {
    /// Contains information about the DPU execution time and progress.
    public var statistics: AthenaClientTypes.CalculationStatistics?
    /// Contains information about the calculation execution status.
    public var status: AthenaClientTypes.CalculationStatus?

    public init (
        statistics: AthenaClientTypes.CalculationStatistics? = nil,
        status: AthenaClientTypes.CalculationStatus? = nil
    )
    {
        self.statistics = statistics
        self.status = status
    }
}

struct GetCalculationExecutionStatusOutputResponseBody: Swift.Equatable {
    let status: AthenaClientTypes.CalculationStatus?
    let statistics: AthenaClientTypes.CalculationStatistics?
}

extension GetCalculationExecutionStatusOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case statistics = "Statistics"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.CalculationStatus.self, forKey: .status)
        status = statusDecoded
        let statisticsDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.CalculationStatistics.self, forKey: .statistics)
        statistics = statisticsDecoded
    }
}

extension GetDataCatalogInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension GetDataCatalogInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetDataCatalogInput: Swift.Equatable {
    /// The name of the data catalog to return.
    /// This member is required.
    public var name: Swift.String?

    public init (
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct GetDataCatalogInputBody: Swift.Equatable {
    let name: Swift.String?
}

extension GetDataCatalogInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension GetDataCatalogOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDataCatalogOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetDataCatalogOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDataCatalogOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetDataCatalogOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dataCatalog = output.dataCatalog
        } else {
            self.dataCatalog = nil
        }
    }
}

public struct GetDataCatalogOutputResponse: Swift.Equatable {
    /// The data catalog returned.
    public var dataCatalog: AthenaClientTypes.DataCatalog?

    public init (
        dataCatalog: AthenaClientTypes.DataCatalog? = nil
    )
    {
        self.dataCatalog = dataCatalog
    }
}

struct GetDataCatalogOutputResponseBody: Swift.Equatable {
    let dataCatalog: AthenaClientTypes.DataCatalog?
}

extension GetDataCatalogOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataCatalog = "DataCatalog"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataCatalogDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.DataCatalog.self, forKey: .dataCatalog)
        dataCatalog = dataCatalogDecoded
    }
}

extension GetDatabaseInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalogName = "CatalogName"
        case databaseName = "DatabaseName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogName = self.catalogName {
            try encodeContainer.encode(catalogName, forKey: .catalogName)
        }
        if let databaseName = self.databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
    }
}

extension GetDatabaseInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetDatabaseInput: Swift.Equatable {
    /// The name of the data catalog that contains the database to return.
    /// This member is required.
    public var catalogName: Swift.String?
    /// The name of the database to return.
    /// This member is required.
    public var databaseName: Swift.String?

    public init (
        catalogName: Swift.String? = nil,
        databaseName: Swift.String? = nil
    )
    {
        self.catalogName = catalogName
        self.databaseName = databaseName
    }
}

struct GetDatabaseInputBody: Swift.Equatable {
    let catalogName: Swift.String?
    let databaseName: Swift.String?
}

extension GetDatabaseInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalogName = "CatalogName"
        case databaseName = "DatabaseName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .catalogName)
        catalogName = catalogNameDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
    }
}

extension GetDatabaseOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDatabaseOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MetadataException" : self = .metadataException(try MetadataException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetDatabaseOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case metadataException(MetadataException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDatabaseOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetDatabaseOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.database = output.database
        } else {
            self.database = nil
        }
    }
}

public struct GetDatabaseOutputResponse: Swift.Equatable {
    /// The database returned.
    public var database: AthenaClientTypes.Database?

    public init (
        database: AthenaClientTypes.Database? = nil
    )
    {
        self.database = database
    }
}

struct GetDatabaseOutputResponseBody: Swift.Equatable {
    let database: AthenaClientTypes.Database?
}

extension GetDatabaseOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case database = "Database"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let databaseDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.Database.self, forKey: .database)
        database = databaseDecoded
    }
}

extension GetNamedQueryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case namedQueryId = "NamedQueryId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let namedQueryId = self.namedQueryId {
            try encodeContainer.encode(namedQueryId, forKey: .namedQueryId)
        }
    }
}

extension GetNamedQueryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetNamedQueryInput: Swift.Equatable {
    /// The unique ID of the query. Use [ListNamedQueries] to get query IDs.
    /// This member is required.
    public var namedQueryId: Swift.String?

    public init (
        namedQueryId: Swift.String? = nil
    )
    {
        self.namedQueryId = namedQueryId
    }
}

struct GetNamedQueryInputBody: Swift.Equatable {
    let namedQueryId: Swift.String?
}

extension GetNamedQueryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case namedQueryId = "NamedQueryId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namedQueryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namedQueryId)
        namedQueryId = namedQueryIdDecoded
    }
}

extension GetNamedQueryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetNamedQueryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetNamedQueryOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetNamedQueryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetNamedQueryOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.namedQuery = output.namedQuery
        } else {
            self.namedQuery = nil
        }
    }
}

public struct GetNamedQueryOutputResponse: Swift.Equatable {
    /// Information about the query.
    public var namedQuery: AthenaClientTypes.NamedQuery?

    public init (
        namedQuery: AthenaClientTypes.NamedQuery? = nil
    )
    {
        self.namedQuery = namedQuery
    }
}

struct GetNamedQueryOutputResponseBody: Swift.Equatable {
    let namedQuery: AthenaClientTypes.NamedQuery?
}

extension GetNamedQueryOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case namedQuery = "NamedQuery"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namedQueryDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.NamedQuery.self, forKey: .namedQuery)
        namedQuery = namedQueryDecoded
    }
}

extension GetNotebookMetadataInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case notebookId = "NotebookId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let notebookId = self.notebookId {
            try encodeContainer.encode(notebookId, forKey: .notebookId)
        }
    }
}

extension GetNotebookMetadataInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetNotebookMetadataInput: Swift.Equatable {
    /// The ID of the notebook whose metadata is to be retrieved.
    /// This member is required.
    public var notebookId: Swift.String?

    public init (
        notebookId: Swift.String? = nil
    )
    {
        self.notebookId = notebookId
    }
}

struct GetNotebookMetadataInputBody: Swift.Equatable {
    let notebookId: Swift.String?
}

extension GetNotebookMetadataInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case notebookId = "NotebookId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let notebookIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .notebookId)
        notebookId = notebookIdDecoded
    }
}

extension GetNotebookMetadataOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetNotebookMetadataOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetNotebookMetadataOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetNotebookMetadataOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetNotebookMetadataOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.notebookMetadata = output.notebookMetadata
        } else {
            self.notebookMetadata = nil
        }
    }
}

public struct GetNotebookMetadataOutputResponse: Swift.Equatable {
    /// The metadata that is returned for the specified notebook ID.
    public var notebookMetadata: AthenaClientTypes.NotebookMetadata?

    public init (
        notebookMetadata: AthenaClientTypes.NotebookMetadata? = nil
    )
    {
        self.notebookMetadata = notebookMetadata
    }
}

struct GetNotebookMetadataOutputResponseBody: Swift.Equatable {
    let notebookMetadata: AthenaClientTypes.NotebookMetadata?
}

extension GetNotebookMetadataOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case notebookMetadata = "NotebookMetadata"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let notebookMetadataDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.NotebookMetadata.self, forKey: .notebookMetadata)
        notebookMetadata = notebookMetadataDecoded
    }
}

extension GetPreparedStatementInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case statementName = "StatementName"
        case workGroup = "WorkGroup"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let statementName = self.statementName {
            try encodeContainer.encode(statementName, forKey: .statementName)
        }
        if let workGroup = self.workGroup {
            try encodeContainer.encode(workGroup, forKey: .workGroup)
        }
    }
}

extension GetPreparedStatementInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetPreparedStatementInput: Swift.Equatable {
    /// The name of the prepared statement to retrieve.
    /// This member is required.
    public var statementName: Swift.String?
    /// The workgroup to which the statement to be retrieved belongs.
    /// This member is required.
    public var workGroup: Swift.String?

    public init (
        statementName: Swift.String? = nil,
        workGroup: Swift.String? = nil
    )
    {
        self.statementName = statementName
        self.workGroup = workGroup
    }
}

struct GetPreparedStatementInputBody: Swift.Equatable {
    let statementName: Swift.String?
    let workGroup: Swift.String?
}

extension GetPreparedStatementInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case statementName = "StatementName"
        case workGroup = "WorkGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statementNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statementName)
        statementName = statementNameDecoded
        let workGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workGroup)
        workGroup = workGroupDecoded
    }
}

extension GetPreparedStatementOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetPreparedStatementOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetPreparedStatementOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetPreparedStatementOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetPreparedStatementOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.preparedStatement = output.preparedStatement
        } else {
            self.preparedStatement = nil
        }
    }
}

public struct GetPreparedStatementOutputResponse: Swift.Equatable {
    /// The name of the prepared statement that was retrieved.
    public var preparedStatement: AthenaClientTypes.PreparedStatement?

    public init (
        preparedStatement: AthenaClientTypes.PreparedStatement? = nil
    )
    {
        self.preparedStatement = preparedStatement
    }
}

struct GetPreparedStatementOutputResponseBody: Swift.Equatable {
    let preparedStatement: AthenaClientTypes.PreparedStatement?
}

extension GetPreparedStatementOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case preparedStatement = "PreparedStatement"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let preparedStatementDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.PreparedStatement.self, forKey: .preparedStatement)
        preparedStatement = preparedStatementDecoded
    }
}

extension GetQueryExecutionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case queryExecutionId = "QueryExecutionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let queryExecutionId = self.queryExecutionId {
            try encodeContainer.encode(queryExecutionId, forKey: .queryExecutionId)
        }
    }
}

extension GetQueryExecutionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetQueryExecutionInput: Swift.Equatable {
    /// The unique ID of the query execution.
    /// This member is required.
    public var queryExecutionId: Swift.String?

    public init (
        queryExecutionId: Swift.String? = nil
    )
    {
        self.queryExecutionId = queryExecutionId
    }
}

struct GetQueryExecutionInputBody: Swift.Equatable {
    let queryExecutionId: Swift.String?
}

extension GetQueryExecutionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case queryExecutionId = "QueryExecutionId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryExecutionId)
        queryExecutionId = queryExecutionIdDecoded
    }
}

extension GetQueryExecutionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetQueryExecutionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetQueryExecutionOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetQueryExecutionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetQueryExecutionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.queryExecution = output.queryExecution
        } else {
            self.queryExecution = nil
        }
    }
}

public struct GetQueryExecutionOutputResponse: Swift.Equatable {
    /// Information about the query execution.
    public var queryExecution: AthenaClientTypes.QueryExecution?

    public init (
        queryExecution: AthenaClientTypes.QueryExecution? = nil
    )
    {
        self.queryExecution = queryExecution
    }
}

struct GetQueryExecutionOutputResponseBody: Swift.Equatable {
    let queryExecution: AthenaClientTypes.QueryExecution?
}

extension GetQueryExecutionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case queryExecution = "QueryExecution"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryExecutionDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.QueryExecution.self, forKey: .queryExecution)
        queryExecution = queryExecutionDecoded
    }
}

extension GetQueryResultsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case queryExecutionId = "QueryExecutionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let queryExecutionId = self.queryExecutionId {
            try encodeContainer.encode(queryExecutionId, forKey: .queryExecutionId)
        }
    }
}

extension GetQueryResultsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetQueryResultsInput: Swift.Equatable {
    /// The maximum number of results (rows) to return in this request.
    public var maxResults: Swift.Int?
    /// A token generated by the Athena service that specifies where to continue pagination if a previous request was truncated. To obtain the next set of pages, pass in the NextToken from the response object of the previous page call.
    public var nextToken: Swift.String?
    /// The unique ID of the query execution.
    /// This member is required.
    public var queryExecutionId: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        queryExecutionId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.queryExecutionId = queryExecutionId
    }
}

struct GetQueryResultsInputBody: Swift.Equatable {
    let queryExecutionId: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension GetQueryResultsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case queryExecutionId = "QueryExecutionId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryExecutionId)
        queryExecutionId = queryExecutionIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension GetQueryResultsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetQueryResultsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetQueryResultsOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetQueryResultsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetQueryResultsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.resultSet = output.resultSet
            self.updateCount = output.updateCount
        } else {
            self.nextToken = nil
            self.resultSet = nil
            self.updateCount = nil
        }
    }
}

public struct GetQueryResultsOutputResponse: Swift.Equatable {
    /// A token generated by the Athena service that specifies where to continue pagination if a previous request was truncated. To obtain the next set of pages, pass in the NextToken from the response object of the previous page call.
    public var nextToken: Swift.String?
    /// The results of the query execution.
    public var resultSet: AthenaClientTypes.ResultSet?
    /// The number of rows inserted with a CREATE TABLE AS SELECT statement.
    public var updateCount: Swift.Int?

    public init (
        nextToken: Swift.String? = nil,
        resultSet: AthenaClientTypes.ResultSet? = nil,
        updateCount: Swift.Int? = nil
    )
    {
        self.nextToken = nextToken
        self.resultSet = resultSet
        self.updateCount = updateCount
    }
}

struct GetQueryResultsOutputResponseBody: Swift.Equatable {
    let updateCount: Swift.Int?
    let resultSet: AthenaClientTypes.ResultSet?
    let nextToken: Swift.String?
}

extension GetQueryResultsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case resultSet = "ResultSet"
        case updateCount = "UpdateCount"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let updateCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .updateCount)
        updateCount = updateCountDecoded
        let resultSetDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.ResultSet.self, forKey: .resultSet)
        resultSet = resultSetDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetQueryRuntimeStatisticsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case queryExecutionId = "QueryExecutionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let queryExecutionId = self.queryExecutionId {
            try encodeContainer.encode(queryExecutionId, forKey: .queryExecutionId)
        }
    }
}

extension GetQueryRuntimeStatisticsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetQueryRuntimeStatisticsInput: Swift.Equatable {
    /// The unique ID of the query execution.
    /// This member is required.
    public var queryExecutionId: Swift.String?

    public init (
        queryExecutionId: Swift.String? = nil
    )
    {
        self.queryExecutionId = queryExecutionId
    }
}

struct GetQueryRuntimeStatisticsInputBody: Swift.Equatable {
    let queryExecutionId: Swift.String?
}

extension GetQueryRuntimeStatisticsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case queryExecutionId = "QueryExecutionId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryExecutionId)
        queryExecutionId = queryExecutionIdDecoded
    }
}

extension GetQueryRuntimeStatisticsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetQueryRuntimeStatisticsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetQueryRuntimeStatisticsOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetQueryRuntimeStatisticsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetQueryRuntimeStatisticsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.queryRuntimeStatistics = output.queryRuntimeStatistics
        } else {
            self.queryRuntimeStatistics = nil
        }
    }
}

public struct GetQueryRuntimeStatisticsOutputResponse: Swift.Equatable {
    /// Runtime statistics about the query execution.
    public var queryRuntimeStatistics: AthenaClientTypes.QueryRuntimeStatistics?

    public init (
        queryRuntimeStatistics: AthenaClientTypes.QueryRuntimeStatistics? = nil
    )
    {
        self.queryRuntimeStatistics = queryRuntimeStatistics
    }
}

struct GetQueryRuntimeStatisticsOutputResponseBody: Swift.Equatable {
    let queryRuntimeStatistics: AthenaClientTypes.QueryRuntimeStatistics?
}

extension GetQueryRuntimeStatisticsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case queryRuntimeStatistics = "QueryRuntimeStatistics"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryRuntimeStatisticsDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.QueryRuntimeStatistics.self, forKey: .queryRuntimeStatistics)
        queryRuntimeStatistics = queryRuntimeStatisticsDecoded
    }
}

extension GetSessionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sessionId = "SessionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sessionId = self.sessionId {
            try encodeContainer.encode(sessionId, forKey: .sessionId)
        }
    }
}

extension GetSessionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetSessionInput: Swift.Equatable {
    /// The session ID.
    /// This member is required.
    public var sessionId: Swift.String?

    public init (
        sessionId: Swift.String? = nil
    )
    {
        self.sessionId = sessionId
    }
}

struct GetSessionInputBody: Swift.Equatable {
    let sessionId: Swift.String?
}

extension GetSessionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sessionId = "SessionId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionId)
        sessionId = sessionIdDecoded
    }
}

extension GetSessionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSessionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetSessionOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSessionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetSessionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.description = output.description
            self.engineConfiguration = output.engineConfiguration
            self.engineVersion = output.engineVersion
            self.notebookVersion = output.notebookVersion
            self.sessionConfiguration = output.sessionConfiguration
            self.sessionId = output.sessionId
            self.statistics = output.statistics
            self.status = output.status
            self.workGroup = output.workGroup
        } else {
            self.description = nil
            self.engineConfiguration = nil
            self.engineVersion = nil
            self.notebookVersion = nil
            self.sessionConfiguration = nil
            self.sessionId = nil
            self.statistics = nil
            self.status = nil
            self.workGroup = nil
        }
    }
}

public struct GetSessionOutputResponse: Swift.Equatable {
    /// The session description.
    public var description: Swift.String?
    /// Contains engine configuration information like DPU usage.
    public var engineConfiguration: AthenaClientTypes.EngineConfiguration?
    /// The engine version used by the session (for example, PySpark engine version 3). You can get a list of engine versions by calling [ListEngineVersions].
    public var engineVersion: Swift.String?
    /// The notebook version.
    public var notebookVersion: Swift.String?
    /// Contains the workgroup configuration information used by the session.
    public var sessionConfiguration: AthenaClientTypes.SessionConfiguration?
    /// The session ID.
    public var sessionId: Swift.String?
    /// Contains the DPU execution time.
    public var statistics: AthenaClientTypes.SessionStatistics?
    /// Contains information about the status of the session.
    public var status: AthenaClientTypes.SessionStatus?
    /// The workgroup to which the session belongs.
    public var workGroup: Swift.String?

    public init (
        description: Swift.String? = nil,
        engineConfiguration: AthenaClientTypes.EngineConfiguration? = nil,
        engineVersion: Swift.String? = nil,
        notebookVersion: Swift.String? = nil,
        sessionConfiguration: AthenaClientTypes.SessionConfiguration? = nil,
        sessionId: Swift.String? = nil,
        statistics: AthenaClientTypes.SessionStatistics? = nil,
        status: AthenaClientTypes.SessionStatus? = nil,
        workGroup: Swift.String? = nil
    )
    {
        self.description = description
        self.engineConfiguration = engineConfiguration
        self.engineVersion = engineVersion
        self.notebookVersion = notebookVersion
        self.sessionConfiguration = sessionConfiguration
        self.sessionId = sessionId
        self.statistics = statistics
        self.status = status
        self.workGroup = workGroup
    }
}

struct GetSessionOutputResponseBody: Swift.Equatable {
    let sessionId: Swift.String?
    let description: Swift.String?
    let workGroup: Swift.String?
    let engineVersion: Swift.String?
    let engineConfiguration: AthenaClientTypes.EngineConfiguration?
    let notebookVersion: Swift.String?
    let sessionConfiguration: AthenaClientTypes.SessionConfiguration?
    let status: AthenaClientTypes.SessionStatus?
    let statistics: AthenaClientTypes.SessionStatistics?
}

extension GetSessionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case engineConfiguration = "EngineConfiguration"
        case engineVersion = "EngineVersion"
        case notebookVersion = "NotebookVersion"
        case sessionConfiguration = "SessionConfiguration"
        case sessionId = "SessionId"
        case statistics = "Statistics"
        case status = "Status"
        case workGroup = "WorkGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionId)
        sessionId = sessionIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let workGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workGroup)
        workGroup = workGroupDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let engineConfigurationDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.EngineConfiguration.self, forKey: .engineConfiguration)
        engineConfiguration = engineConfigurationDecoded
        let notebookVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .notebookVersion)
        notebookVersion = notebookVersionDecoded
        let sessionConfigurationDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.SessionConfiguration.self, forKey: .sessionConfiguration)
        sessionConfiguration = sessionConfigurationDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.SessionStatus.self, forKey: .status)
        status = statusDecoded
        let statisticsDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.SessionStatistics.self, forKey: .statistics)
        statistics = statisticsDecoded
    }
}

extension GetSessionStatusInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sessionId = "SessionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sessionId = self.sessionId {
            try encodeContainer.encode(sessionId, forKey: .sessionId)
        }
    }
}

extension GetSessionStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetSessionStatusInput: Swift.Equatable {
    /// The session ID.
    /// This member is required.
    public var sessionId: Swift.String?

    public init (
        sessionId: Swift.String? = nil
    )
    {
        self.sessionId = sessionId
    }
}

struct GetSessionStatusInputBody: Swift.Equatable {
    let sessionId: Swift.String?
}

extension GetSessionStatusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sessionId = "SessionId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionId)
        sessionId = sessionIdDecoded
    }
}

extension GetSessionStatusOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSessionStatusOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetSessionStatusOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSessionStatusOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetSessionStatusOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.sessionId = output.sessionId
            self.status = output.status
        } else {
            self.sessionId = nil
            self.status = nil
        }
    }
}

public struct GetSessionStatusOutputResponse: Swift.Equatable {
    /// The session ID.
    public var sessionId: Swift.String?
    /// Contains information about the status of the session.
    public var status: AthenaClientTypes.SessionStatus?

    public init (
        sessionId: Swift.String? = nil,
        status: AthenaClientTypes.SessionStatus? = nil
    )
    {
        self.sessionId = sessionId
        self.status = status
    }
}

struct GetSessionStatusOutputResponseBody: Swift.Equatable {
    let sessionId: Swift.String?
    let status: AthenaClientTypes.SessionStatus?
}

extension GetSessionStatusOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sessionId = "SessionId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionId)
        sessionId = sessionIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.SessionStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension GetTableMetadataInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalogName = "CatalogName"
        case databaseName = "DatabaseName"
        case tableName = "TableName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogName = self.catalogName {
            try encodeContainer.encode(catalogName, forKey: .catalogName)
        }
        if let databaseName = self.databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let tableName = self.tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
    }
}

extension GetTableMetadataInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetTableMetadataInput: Swift.Equatable {
    /// The name of the data catalog that contains the database and table metadata to return.
    /// This member is required.
    public var catalogName: Swift.String?
    /// The name of the database that contains the table metadata to return.
    /// This member is required.
    public var databaseName: Swift.String?
    /// The name of the table for which metadata is returned.
    /// This member is required.
    public var tableName: Swift.String?

    public init (
        catalogName: Swift.String? = nil,
        databaseName: Swift.String? = nil,
        tableName: Swift.String? = nil
    )
    {
        self.catalogName = catalogName
        self.databaseName = databaseName
        self.tableName = tableName
    }
}

struct GetTableMetadataInputBody: Swift.Equatable {
    let catalogName: Swift.String?
    let databaseName: Swift.String?
    let tableName: Swift.String?
}

extension GetTableMetadataInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalogName = "CatalogName"
        case databaseName = "DatabaseName"
        case tableName = "TableName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .catalogName)
        catalogName = catalogNameDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let tableNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tableName)
        tableName = tableNameDecoded
    }
}

extension GetTableMetadataOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetTableMetadataOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MetadataException" : self = .metadataException(try MetadataException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetTableMetadataOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case metadataException(MetadataException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetTableMetadataOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetTableMetadataOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tableMetadata = output.tableMetadata
        } else {
            self.tableMetadata = nil
        }
    }
}

public struct GetTableMetadataOutputResponse: Swift.Equatable {
    /// An object that contains table metadata.
    public var tableMetadata: AthenaClientTypes.TableMetadata?

    public init (
        tableMetadata: AthenaClientTypes.TableMetadata? = nil
    )
    {
        self.tableMetadata = tableMetadata
    }
}

struct GetTableMetadataOutputResponseBody: Swift.Equatable {
    let tableMetadata: AthenaClientTypes.TableMetadata?
}

extension GetTableMetadataOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tableMetadata = "TableMetadata"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tableMetadataDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.TableMetadata.self, forKey: .tableMetadata)
        tableMetadata = tableMetadataDecoded
    }
}

extension GetWorkGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workGroup = "WorkGroup"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let workGroup = self.workGroup {
            try encodeContainer.encode(workGroup, forKey: .workGroup)
        }
    }
}

extension GetWorkGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetWorkGroupInput: Swift.Equatable {
    /// The name of the workgroup.
    /// This member is required.
    public var workGroup: Swift.String?

    public init (
        workGroup: Swift.String? = nil
    )
    {
        self.workGroup = workGroup
    }
}

struct GetWorkGroupInputBody: Swift.Equatable {
    let workGroup: Swift.String?
}

extension GetWorkGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workGroup = "WorkGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workGroup)
        workGroup = workGroupDecoded
    }
}

extension GetWorkGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetWorkGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetWorkGroupOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetWorkGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetWorkGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.workGroup = output.workGroup
        } else {
            self.workGroup = nil
        }
    }
}

public struct GetWorkGroupOutputResponse: Swift.Equatable {
    /// Information about the workgroup.
    public var workGroup: AthenaClientTypes.WorkGroup?

    public init (
        workGroup: AthenaClientTypes.WorkGroup? = nil
    )
    {
        self.workGroup = workGroup
    }
}

struct GetWorkGroupOutputResponseBody: Swift.Equatable {
    let workGroup: AthenaClientTypes.WorkGroup?
}

extension GetWorkGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workGroup = "WorkGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workGroupDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.WorkGroup.self, forKey: .workGroup)
        workGroup = workGroupDecoded
    }
}

extension ImportNotebookInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case name = "Name"
        case payload = "Payload"
        case type = "Type"
        case workGroup = "WorkGroup"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let payload = self.payload {
            try encodeContainer.encode(payload, forKey: .payload)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let workGroup = self.workGroup {
            try encodeContainer.encode(workGroup, forKey: .workGroup)
        }
    }
}

extension ImportNotebookInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ImportNotebookInput: Swift.Equatable {
    /// A unique case-sensitive string used to ensure the request to import the notebook is idempotent (executes only once). This token is listed as not required because Amazon Web Services SDKs (for example the Amazon Web Services SDK for Java) auto-generate the token for you. If you are not using the Amazon Web Services SDK or the Amazon Web Services CLI, you must provide this token or the action will fail.
    public var clientRequestToken: Swift.String?
    /// The name of the notebook to import.
    /// This member is required.
    public var name: Swift.String?
    /// The notebook content to be imported.
    /// This member is required.
    public var payload: Swift.String?
    /// The notebook content type. Currently, the only valid type is IPYNB.
    /// This member is required.
    public var type: AthenaClientTypes.NotebookType?
    /// The name of the Spark enabled workgroup to import the notebook to.
    /// This member is required.
    public var workGroup: Swift.String?

    public init (
        clientRequestToken: Swift.String? = nil,
        name: Swift.String? = nil,
        payload: Swift.String? = nil,
        type: AthenaClientTypes.NotebookType? = nil,
        workGroup: Swift.String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.name = name
        self.payload = payload
        self.type = type
        self.workGroup = workGroup
    }
}

struct ImportNotebookInputBody: Swift.Equatable {
    let workGroup: Swift.String?
    let name: Swift.String?
    let payload: Swift.String?
    let type: AthenaClientTypes.NotebookType?
    let clientRequestToken: Swift.String?
}

extension ImportNotebookInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case name = "Name"
        case payload = "Payload"
        case type = "Type"
        case workGroup = "WorkGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workGroup)
        workGroup = workGroupDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let payloadDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .payload)
        payload = payloadDecoded
        let typeDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.NotebookType.self, forKey: .type)
        type = typeDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
    }
}

extension ImportNotebookOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ImportNotebookOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ImportNotebookOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ImportNotebookOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ImportNotebookOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.notebookId = output.notebookId
        } else {
            self.notebookId = nil
        }
    }
}

public struct ImportNotebookOutputResponse: Swift.Equatable {
    /// The ID of the notebook to import.
    public var notebookId: Swift.String?

    public init (
        notebookId: Swift.String? = nil
    )
    {
        self.notebookId = notebookId
    }
}

struct ImportNotebookOutputResponseBody: Swift.Equatable {
    let notebookId: Swift.String?
}

extension ImportNotebookOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case notebookId = "NotebookId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let notebookIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .notebookId)
        notebookId = notebookIdDecoded
    }
}

extension InternalServerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Indicates a platform issue, which may be due to a transient condition or outage.
public struct InternalServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRequestException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.athenaErrorCode = output.athenaErrorCode
            self.message = output.message
        } else {
            self.athenaErrorCode = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Indicates that something is wrong with the input to the request. For example, a required parameter may be missing or out of range.
public struct InvalidRequestException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The error code returned when the query execution failed to process, or when the processing request for the named query failed.
    public var athenaErrorCode: Swift.String?
    public var message: Swift.String?

    public init (
        athenaErrorCode: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.athenaErrorCode = athenaErrorCode
        self.message = message
    }
}

struct InvalidRequestExceptionBody: Swift.Equatable {
    let athenaErrorCode: Swift.String?
    let message: Swift.String?
}

extension InvalidRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case athenaErrorCode = "AthenaErrorCode"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let athenaErrorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .athenaErrorCode)
        athenaErrorCode = athenaErrorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListApplicationDPUSizesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListApplicationDPUSizesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListApplicationDPUSizesInput: Swift.Equatable {
    /// Specifies the maximum number of results to return.
    public var maxResults: Swift.Int?
    /// A token generated by the Athena service that specifies where to continue pagination if a previous request was truncated.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListApplicationDPUSizesInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListApplicationDPUSizesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListApplicationDPUSizesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListApplicationDPUSizesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListApplicationDPUSizesOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListApplicationDPUSizesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListApplicationDPUSizesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.applicationDPUSizes = output.applicationDPUSizes
            self.nextToken = output.nextToken
        } else {
            self.applicationDPUSizes = nil
            self.nextToken = nil
        }
    }
}

public struct ListApplicationDPUSizesOutputResponse: Swift.Equatable {
    /// A list of the supported DPU sizes that the application runtime supports.
    public var applicationDPUSizes: [AthenaClientTypes.ApplicationDPUSizes]?
    /// A token generated by the Athena service that specifies where to continue pagination if a previous request was truncated. To obtain the next set of pages, pass in the NextToken from the response object of the previous page call.
    public var nextToken: Swift.String?

    public init (
        applicationDPUSizes: [AthenaClientTypes.ApplicationDPUSizes]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.applicationDPUSizes = applicationDPUSizes
        self.nextToken = nextToken
    }
}

struct ListApplicationDPUSizesOutputResponseBody: Swift.Equatable {
    let applicationDPUSizes: [AthenaClientTypes.ApplicationDPUSizes]?
    let nextToken: Swift.String?
}

extension ListApplicationDPUSizesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationDPUSizes = "ApplicationDPUSizes"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationDPUSizesContainer = try containerValues.decodeIfPresent([AthenaClientTypes.ApplicationDPUSizes?].self, forKey: .applicationDPUSizes)
        var applicationDPUSizesDecoded0:[AthenaClientTypes.ApplicationDPUSizes]? = nil
        if let applicationDPUSizesContainer = applicationDPUSizesContainer {
            applicationDPUSizesDecoded0 = [AthenaClientTypes.ApplicationDPUSizes]()
            for structure0 in applicationDPUSizesContainer {
                if let structure0 = structure0 {
                    applicationDPUSizesDecoded0?.append(structure0)
                }
            }
        }
        applicationDPUSizes = applicationDPUSizesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListCalculationExecutionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sessionId = "SessionId"
        case stateFilter = "StateFilter"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sessionId = self.sessionId {
            try encodeContainer.encode(sessionId, forKey: .sessionId)
        }
        if let stateFilter = self.stateFilter {
            try encodeContainer.encode(stateFilter.rawValue, forKey: .stateFilter)
        }
    }
}

extension ListCalculationExecutionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListCalculationExecutionsInput: Swift.Equatable {
    /// The maximum number of calculation executions to return.
    public var maxResults: Swift.Int?
    /// A token generated by the Athena service that specifies where to continue pagination if a previous request was truncated. To obtain the next set of pages, pass in the NextToken from the response object of the previous page call.
    public var nextToken: Swift.String?
    /// The session ID.
    /// This member is required.
    public var sessionId: Swift.String?
    /// A filter for a specific calculation execution state. A description of each state follows. CREATING - The calculation is in the process of being created. CREATED - The calculation has been created and is ready to run. QUEUED - The calculation has been queued for processing. RUNNING - The calculation is running. CANCELING - A request to cancel the calculation has been received and the system is working to stop it. CANCELED - The calculation is no longer running as the result of a cancel request. COMPLETED - The calculation has completed without error. FAILED - The calculation failed and is no longer running.
    public var stateFilter: AthenaClientTypes.CalculationExecutionState?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sessionId: Swift.String? = nil,
        stateFilter: AthenaClientTypes.CalculationExecutionState? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sessionId = sessionId
        self.stateFilter = stateFilter
    }
}

struct ListCalculationExecutionsInputBody: Swift.Equatable {
    let sessionId: Swift.String?
    let stateFilter: AthenaClientTypes.CalculationExecutionState?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListCalculationExecutionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sessionId = "SessionId"
        case stateFilter = "StateFilter"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionId)
        sessionId = sessionIdDecoded
        let stateFilterDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.CalculationExecutionState.self, forKey: .stateFilter)
        stateFilter = stateFilterDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListCalculationExecutionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListCalculationExecutionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListCalculationExecutionsOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListCalculationExecutionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListCalculationExecutionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.calculations = output.calculations
            self.nextToken = output.nextToken
        } else {
            self.calculations = nil
            self.nextToken = nil
        }
    }
}

public struct ListCalculationExecutionsOutputResponse: Swift.Equatable {
    /// A list of [CalculationSummary] objects.
    public var calculations: [AthenaClientTypes.CalculationSummary]?
    /// A token generated by the Athena service that specifies where to continue pagination if a previous request was truncated. To obtain the next set of pages, pass in the NextToken from the response object of the previous page call.
    public var nextToken: Swift.String?

    public init (
        calculations: [AthenaClientTypes.CalculationSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.calculations = calculations
        self.nextToken = nextToken
    }
}

struct ListCalculationExecutionsOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let calculations: [AthenaClientTypes.CalculationSummary]?
}

extension ListCalculationExecutionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case calculations = "Calculations"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let calculationsContainer = try containerValues.decodeIfPresent([AthenaClientTypes.CalculationSummary?].self, forKey: .calculations)
        var calculationsDecoded0:[AthenaClientTypes.CalculationSummary]? = nil
        if let calculationsContainer = calculationsContainer {
            calculationsDecoded0 = [AthenaClientTypes.CalculationSummary]()
            for structure0 in calculationsContainer {
                if let structure0 = structure0 {
                    calculationsDecoded0?.append(structure0)
                }
            }
        }
        calculations = calculationsDecoded0
    }
}

extension ListDataCatalogsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListDataCatalogsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListDataCatalogsInput: Swift.Equatable {
    /// Specifies the maximum number of data catalogs to return.
    public var maxResults: Swift.Int?
    /// A token generated by the Athena service that specifies where to continue pagination if a previous request was truncated. To obtain the next set of pages, pass in the NextToken from the response object of the previous page call.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDataCatalogsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListDataCatalogsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListDataCatalogsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDataCatalogsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListDataCatalogsOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDataCatalogsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListDataCatalogsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dataCatalogsSummary = output.dataCatalogsSummary
            self.nextToken = output.nextToken
        } else {
            self.dataCatalogsSummary = nil
            self.nextToken = nil
        }
    }
}

public struct ListDataCatalogsOutputResponse: Swift.Equatable {
    /// A summary list of data catalogs.
    public var dataCatalogsSummary: [AthenaClientTypes.DataCatalogSummary]?
    /// A token generated by the Athena service that specifies where to continue pagination if a previous request was truncated. To obtain the next set of pages, pass in the NextToken from the response object of the previous page call.
    public var nextToken: Swift.String?

    public init (
        dataCatalogsSummary: [AthenaClientTypes.DataCatalogSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.dataCatalogsSummary = dataCatalogsSummary
        self.nextToken = nextToken
    }
}

struct ListDataCatalogsOutputResponseBody: Swift.Equatable {
    let dataCatalogsSummary: [AthenaClientTypes.DataCatalogSummary]?
    let nextToken: Swift.String?
}

extension ListDataCatalogsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataCatalogsSummary = "DataCatalogsSummary"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataCatalogsSummaryContainer = try containerValues.decodeIfPresent([AthenaClientTypes.DataCatalogSummary?].self, forKey: .dataCatalogsSummary)
        var dataCatalogsSummaryDecoded0:[AthenaClientTypes.DataCatalogSummary]? = nil
        if let dataCatalogsSummaryContainer = dataCatalogsSummaryContainer {
            dataCatalogsSummaryDecoded0 = [AthenaClientTypes.DataCatalogSummary]()
            for structure0 in dataCatalogsSummaryContainer {
                if let structure0 = structure0 {
                    dataCatalogsSummaryDecoded0?.append(structure0)
                }
            }
        }
        dataCatalogsSummary = dataCatalogsSummaryDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListDatabasesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalogName = "CatalogName"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogName = self.catalogName {
            try encodeContainer.encode(catalogName, forKey: .catalogName)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListDatabasesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListDatabasesInput: Swift.Equatable {
    /// The name of the data catalog that contains the databases to return.
    /// This member is required.
    public var catalogName: Swift.String?
    /// Specifies the maximum number of results to return.
    public var maxResults: Swift.Int?
    /// A token generated by the Athena service that specifies where to continue pagination if a previous request was truncated. To obtain the next set of pages, pass in the NextToken from the response object of the previous page call.
    public var nextToken: Swift.String?

    public init (
        catalogName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.catalogName = catalogName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDatabasesInputBody: Swift.Equatable {
    let catalogName: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListDatabasesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalogName = "CatalogName"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .catalogName)
        catalogName = catalogNameDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListDatabasesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDatabasesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MetadataException" : self = .metadataException(try MetadataException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListDatabasesOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case metadataException(MetadataException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDatabasesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListDatabasesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.databaseList = output.databaseList
            self.nextToken = output.nextToken
        } else {
            self.databaseList = nil
            self.nextToken = nil
        }
    }
}

public struct ListDatabasesOutputResponse: Swift.Equatable {
    /// A list of databases from a data catalog.
    public var databaseList: [AthenaClientTypes.Database]?
    /// A token generated by the Athena service that specifies where to continue pagination if a previous request was truncated. To obtain the next set of pages, pass in the NextToken from the response object of the previous page call.
    public var nextToken: Swift.String?

    public init (
        databaseList: [AthenaClientTypes.Database]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.databaseList = databaseList
        self.nextToken = nextToken
    }
}

struct ListDatabasesOutputResponseBody: Swift.Equatable {
    let databaseList: [AthenaClientTypes.Database]?
    let nextToken: Swift.String?
}

extension ListDatabasesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case databaseList = "DatabaseList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let databaseListContainer = try containerValues.decodeIfPresent([AthenaClientTypes.Database?].self, forKey: .databaseList)
        var databaseListDecoded0:[AthenaClientTypes.Database]? = nil
        if let databaseListContainer = databaseListContainer {
            databaseListDecoded0 = [AthenaClientTypes.Database]()
            for structure0 in databaseListContainer {
                if let structure0 = structure0 {
                    databaseListDecoded0?.append(structure0)
                }
            }
        }
        databaseList = databaseListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListEngineVersionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListEngineVersionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListEngineVersionsInput: Swift.Equatable {
    /// The maximum number of engine versions to return in this request.
    public var maxResults: Swift.Int?
    /// A token generated by the Athena service that specifies where to continue pagination if a previous request was truncated. To obtain the next set of pages, pass in the NextToken from the response object of the previous page call.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListEngineVersionsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListEngineVersionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListEngineVersionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListEngineVersionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListEngineVersionsOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListEngineVersionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListEngineVersionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.engineVersions = output.engineVersions
            self.nextToken = output.nextToken
        } else {
            self.engineVersions = nil
            self.nextToken = nil
        }
    }
}

public struct ListEngineVersionsOutputResponse: Swift.Equatable {
    /// A list of engine versions that are available to choose from.
    public var engineVersions: [AthenaClientTypes.EngineVersion]?
    /// A token generated by the Athena service that specifies where to continue pagination if a previous request was truncated. To obtain the next set of pages, pass in the NextToken from the response object of the previous page call.
    public var nextToken: Swift.String?

    public init (
        engineVersions: [AthenaClientTypes.EngineVersion]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.engineVersions = engineVersions
        self.nextToken = nextToken
    }
}

struct ListEngineVersionsOutputResponseBody: Swift.Equatable {
    let engineVersions: [AthenaClientTypes.EngineVersion]?
    let nextToken: Swift.String?
}

extension ListEngineVersionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case engineVersions = "EngineVersions"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let engineVersionsContainer = try containerValues.decodeIfPresent([AthenaClientTypes.EngineVersion?].self, forKey: .engineVersions)
        var engineVersionsDecoded0:[AthenaClientTypes.EngineVersion]? = nil
        if let engineVersionsContainer = engineVersionsContainer {
            engineVersionsDecoded0 = [AthenaClientTypes.EngineVersion]()
            for structure0 in engineVersionsContainer {
                if let structure0 = structure0 {
                    engineVersionsDecoded0?.append(structure0)
                }
            }
        }
        engineVersions = engineVersionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListExecutorsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case executorStateFilter = "ExecutorStateFilter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sessionId = "SessionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let executorStateFilter = self.executorStateFilter {
            try encodeContainer.encode(executorStateFilter.rawValue, forKey: .executorStateFilter)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sessionId = self.sessionId {
            try encodeContainer.encode(sessionId, forKey: .sessionId)
        }
    }
}

extension ListExecutorsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListExecutorsInput: Swift.Equatable {
    /// A filter for a specific executor state. A description of each state follows. CREATING - The executor is being started, including acquiring resources. CREATED - The executor has been started. REGISTERED - The executor has been registered. TERMINATING - The executor is in the process of shutting down. TERMINATED - The executor is no longer running. FAILED - Due to a failure, the executor is no longer running.
    public var executorStateFilter: AthenaClientTypes.ExecutorState?
    /// The maximum number of executors to return.
    public var maxResults: Swift.Int?
    /// A token generated by the Athena service that specifies where to continue pagination if a previous request was truncated. To obtain the next set of pages, pass in the NextToken from the response object of the previous page call.
    public var nextToken: Swift.String?
    /// The session ID.
    /// This member is required.
    public var sessionId: Swift.String?

    public init (
        executorStateFilter: AthenaClientTypes.ExecutorState? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sessionId: Swift.String? = nil
    )
    {
        self.executorStateFilter = executorStateFilter
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sessionId = sessionId
    }
}

struct ListExecutorsInputBody: Swift.Equatable {
    let sessionId: Swift.String?
    let executorStateFilter: AthenaClientTypes.ExecutorState?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListExecutorsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case executorStateFilter = "ExecutorStateFilter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sessionId = "SessionId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionId)
        sessionId = sessionIdDecoded
        let executorStateFilterDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.ExecutorState.self, forKey: .executorStateFilter)
        executorStateFilter = executorStateFilterDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListExecutorsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListExecutorsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListExecutorsOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListExecutorsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListExecutorsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.executorsSummary = output.executorsSummary
            self.nextToken = output.nextToken
            self.sessionId = output.sessionId
        } else {
            self.executorsSummary = nil
            self.nextToken = nil
            self.sessionId = nil
        }
    }
}

public struct ListExecutorsOutputResponse: Swift.Equatable {
    /// Contains summary information about the executor.
    public var executorsSummary: [AthenaClientTypes.ExecutorsSummary]?
    /// A token generated by the Athena service that specifies where to continue pagination if a previous request was truncated. To obtain the next set of pages, pass in the NextToken from the response object of the previous page call.
    public var nextToken: Swift.String?
    /// The session ID.
    /// This member is required.
    public var sessionId: Swift.String?

    public init (
        executorsSummary: [AthenaClientTypes.ExecutorsSummary]? = nil,
        nextToken: Swift.String? = nil,
        sessionId: Swift.String? = nil
    )
    {
        self.executorsSummary = executorsSummary
        self.nextToken = nextToken
        self.sessionId = sessionId
    }
}

struct ListExecutorsOutputResponseBody: Swift.Equatable {
    let sessionId: Swift.String?
    let nextToken: Swift.String?
    let executorsSummary: [AthenaClientTypes.ExecutorsSummary]?
}

extension ListExecutorsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case executorsSummary = "ExecutorsSummary"
        case nextToken = "NextToken"
        case sessionId = "SessionId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionId)
        sessionId = sessionIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let executorsSummaryContainer = try containerValues.decodeIfPresent([AthenaClientTypes.ExecutorsSummary?].self, forKey: .executorsSummary)
        var executorsSummaryDecoded0:[AthenaClientTypes.ExecutorsSummary]? = nil
        if let executorsSummaryContainer = executorsSummaryContainer {
            executorsSummaryDecoded0 = [AthenaClientTypes.ExecutorsSummary]()
            for structure0 in executorsSummaryContainer {
                if let structure0 = structure0 {
                    executorsSummaryDecoded0?.append(structure0)
                }
            }
        }
        executorsSummary = executorsSummaryDecoded0
    }
}

extension ListNamedQueriesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case workGroup = "WorkGroup"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let workGroup = self.workGroup {
            try encodeContainer.encode(workGroup, forKey: .workGroup)
        }
    }
}

extension ListNamedQueriesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListNamedQueriesInput: Swift.Equatable {
    /// The maximum number of queries to return in this request.
    public var maxResults: Swift.Int?
    /// A token generated by the Athena service that specifies where to continue pagination if a previous request was truncated. To obtain the next set of pages, pass in the NextToken from the response object of the previous page call.
    public var nextToken: Swift.String?
    /// The name of the workgroup from which the named queries are being returned. If a workgroup is not specified, the saved queries for the primary workgroup are returned.
    public var workGroup: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        workGroup: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.workGroup = workGroup
    }
}

struct ListNamedQueriesInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let workGroup: Swift.String?
}

extension ListNamedQueriesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case workGroup = "WorkGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let workGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workGroup)
        workGroup = workGroupDecoded
    }
}

extension ListNamedQueriesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListNamedQueriesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListNamedQueriesOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListNamedQueriesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListNamedQueriesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.namedQueryIds = output.namedQueryIds
            self.nextToken = output.nextToken
        } else {
            self.namedQueryIds = nil
            self.nextToken = nil
        }
    }
}

public struct ListNamedQueriesOutputResponse: Swift.Equatable {
    /// The list of unique query IDs.
    public var namedQueryIds: [Swift.String]?
    /// A token generated by the Athena service that specifies where to continue pagination if a previous request was truncated. To obtain the next set of pages, pass in the NextToken from the response object of the previous page call.
    public var nextToken: Swift.String?

    public init (
        namedQueryIds: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.namedQueryIds = namedQueryIds
        self.nextToken = nextToken
    }
}

struct ListNamedQueriesOutputResponseBody: Swift.Equatable {
    let namedQueryIds: [Swift.String]?
    let nextToken: Swift.String?
}

extension ListNamedQueriesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case namedQueryIds = "NamedQueryIds"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namedQueryIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .namedQueryIds)
        var namedQueryIdsDecoded0:[Swift.String]? = nil
        if let namedQueryIdsContainer = namedQueryIdsContainer {
            namedQueryIdsDecoded0 = [Swift.String]()
            for string0 in namedQueryIdsContainer {
                if let string0 = string0 {
                    namedQueryIdsDecoded0?.append(string0)
                }
            }
        }
        namedQueryIds = namedQueryIdsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListNotebookMetadataInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case workGroup = "WorkGroup"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = self.filters {
            try encodeContainer.encode(filters, forKey: .filters)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let workGroup = self.workGroup {
            try encodeContainer.encode(workGroup, forKey: .workGroup)
        }
    }
}

extension ListNotebookMetadataInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListNotebookMetadataInput: Swift.Equatable {
    /// Search filter string.
    public var filters: AthenaClientTypes.FilterDefinition?
    /// Specifies the maximum number of results to return.
    public var maxResults: Swift.Int?
    /// A token generated by the Athena service that specifies where to continue pagination if a previous request was truncated.
    public var nextToken: Swift.String?
    /// The name of the Spark enabled workgroup to retrieve notebook metadata for.
    /// This member is required.
    public var workGroup: Swift.String?

    public init (
        filters: AthenaClientTypes.FilterDefinition? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        workGroup: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.workGroup = workGroup
    }
}

struct ListNotebookMetadataInputBody: Swift.Equatable {
    let filters: AthenaClientTypes.FilterDefinition?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let workGroup: Swift.String?
}

extension ListNotebookMetadataInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case workGroup = "WorkGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.FilterDefinition.self, forKey: .filters)
        filters = filtersDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let workGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workGroup)
        workGroup = workGroupDecoded
    }
}

extension ListNotebookMetadataOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListNotebookMetadataOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListNotebookMetadataOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListNotebookMetadataOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListNotebookMetadataOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.notebookMetadataList = output.notebookMetadataList
        } else {
            self.nextToken = nil
            self.notebookMetadataList = nil
        }
    }
}

public struct ListNotebookMetadataOutputResponse: Swift.Equatable {
    /// A token generated by the Athena service that specifies where to continue pagination if a previous request was truncated. To obtain the next set of pages, pass in the NextToken from the response object of the previous page call.
    public var nextToken: Swift.String?
    /// The list of notebook metadata for the specified workgroup.
    public var notebookMetadataList: [AthenaClientTypes.NotebookMetadata]?

    public init (
        nextToken: Swift.String? = nil,
        notebookMetadataList: [AthenaClientTypes.NotebookMetadata]? = nil
    )
    {
        self.nextToken = nextToken
        self.notebookMetadataList = notebookMetadataList
    }
}

struct ListNotebookMetadataOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let notebookMetadataList: [AthenaClientTypes.NotebookMetadata]?
}

extension ListNotebookMetadataOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case notebookMetadataList = "NotebookMetadataList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let notebookMetadataListContainer = try containerValues.decodeIfPresent([AthenaClientTypes.NotebookMetadata?].self, forKey: .notebookMetadataList)
        var notebookMetadataListDecoded0:[AthenaClientTypes.NotebookMetadata]? = nil
        if let notebookMetadataListContainer = notebookMetadataListContainer {
            notebookMetadataListDecoded0 = [AthenaClientTypes.NotebookMetadata]()
            for structure0 in notebookMetadataListContainer {
                if let structure0 = structure0 {
                    notebookMetadataListDecoded0?.append(structure0)
                }
            }
        }
        notebookMetadataList = notebookMetadataListDecoded0
    }
}

extension ListNotebookSessionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case notebookId = "NotebookId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let notebookId = self.notebookId {
            try encodeContainer.encode(notebookId, forKey: .notebookId)
        }
    }
}

extension ListNotebookSessionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListNotebookSessionsInput: Swift.Equatable {
    /// The maximum number of notebook sessions to return.
    public var maxResults: Swift.Int?
    /// A token generated by the Athena service that specifies where to continue pagination if a previous request was truncated. To obtain the next set of pages, pass in the NextToken from the response object of the previous page call.
    public var nextToken: Swift.String?
    /// The ID of the notebook to list sessions for.
    /// This member is required.
    public var notebookId: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        notebookId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.notebookId = notebookId
    }
}

struct ListNotebookSessionsInputBody: Swift.Equatable {
    let notebookId: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListNotebookSessionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case notebookId = "NotebookId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let notebookIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .notebookId)
        notebookId = notebookIdDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListNotebookSessionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListNotebookSessionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListNotebookSessionsOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListNotebookSessionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListNotebookSessionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.notebookSessionsList = output.notebookSessionsList
        } else {
            self.nextToken = nil
            self.notebookSessionsList = nil
        }
    }
}

public struct ListNotebookSessionsOutputResponse: Swift.Equatable {
    /// A token generated by the Athena service that specifies where to continue pagination if a previous request was truncated. To obtain the next set of pages, pass in the NextToken from the response object of the previous page call.
    public var nextToken: Swift.String?
    /// A list of the sessions belonging to the notebook.
    /// This member is required.
    public var notebookSessionsList: [AthenaClientTypes.NotebookSessionSummary]?

    public init (
        nextToken: Swift.String? = nil,
        notebookSessionsList: [AthenaClientTypes.NotebookSessionSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.notebookSessionsList = notebookSessionsList
    }
}

struct ListNotebookSessionsOutputResponseBody: Swift.Equatable {
    let notebookSessionsList: [AthenaClientTypes.NotebookSessionSummary]?
    let nextToken: Swift.String?
}

extension ListNotebookSessionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case notebookSessionsList = "NotebookSessionsList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let notebookSessionsListContainer = try containerValues.decodeIfPresent([AthenaClientTypes.NotebookSessionSummary?].self, forKey: .notebookSessionsList)
        var notebookSessionsListDecoded0:[AthenaClientTypes.NotebookSessionSummary]? = nil
        if let notebookSessionsListContainer = notebookSessionsListContainer {
            notebookSessionsListDecoded0 = [AthenaClientTypes.NotebookSessionSummary]()
            for structure0 in notebookSessionsListContainer {
                if let structure0 = structure0 {
                    notebookSessionsListDecoded0?.append(structure0)
                }
            }
        }
        notebookSessionsList = notebookSessionsListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListPreparedStatementsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case workGroup = "WorkGroup"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let workGroup = self.workGroup {
            try encodeContainer.encode(workGroup, forKey: .workGroup)
        }
    }
}

extension ListPreparedStatementsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListPreparedStatementsInput: Swift.Equatable {
    /// The maximum number of results to return in this request.
    public var maxResults: Swift.Int?
    /// A token generated by the Athena service that specifies where to continue pagination if a previous request was truncated. To obtain the next set of pages, pass in the NextToken from the response object of the previous page call.
    public var nextToken: Swift.String?
    /// The workgroup to list the prepared statements for.
    /// This member is required.
    public var workGroup: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        workGroup: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.workGroup = workGroup
    }
}

struct ListPreparedStatementsInputBody: Swift.Equatable {
    let workGroup: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListPreparedStatementsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case workGroup = "WorkGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workGroup)
        workGroup = workGroupDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListPreparedStatementsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPreparedStatementsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListPreparedStatementsOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPreparedStatementsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListPreparedStatementsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.preparedStatements = output.preparedStatements
        } else {
            self.nextToken = nil
            self.preparedStatements = nil
        }
    }
}

public struct ListPreparedStatementsOutputResponse: Swift.Equatable {
    /// A token generated by the Athena service that specifies where to continue pagination if a previous request was truncated. To obtain the next set of pages, pass in the NextToken from the response object of the previous page call.
    public var nextToken: Swift.String?
    /// The list of prepared statements for the workgroup.
    public var preparedStatements: [AthenaClientTypes.PreparedStatementSummary]?

    public init (
        nextToken: Swift.String? = nil,
        preparedStatements: [AthenaClientTypes.PreparedStatementSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.preparedStatements = preparedStatements
    }
}

struct ListPreparedStatementsOutputResponseBody: Swift.Equatable {
    let preparedStatements: [AthenaClientTypes.PreparedStatementSummary]?
    let nextToken: Swift.String?
}

extension ListPreparedStatementsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case preparedStatements = "PreparedStatements"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let preparedStatementsContainer = try containerValues.decodeIfPresent([AthenaClientTypes.PreparedStatementSummary?].self, forKey: .preparedStatements)
        var preparedStatementsDecoded0:[AthenaClientTypes.PreparedStatementSummary]? = nil
        if let preparedStatementsContainer = preparedStatementsContainer {
            preparedStatementsDecoded0 = [AthenaClientTypes.PreparedStatementSummary]()
            for structure0 in preparedStatementsContainer {
                if let structure0 = structure0 {
                    preparedStatementsDecoded0?.append(structure0)
                }
            }
        }
        preparedStatements = preparedStatementsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListQueryExecutionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case workGroup = "WorkGroup"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let workGroup = self.workGroup {
            try encodeContainer.encode(workGroup, forKey: .workGroup)
        }
    }
}

extension ListQueryExecutionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListQueryExecutionsInput: Swift.Equatable {
    /// The maximum number of query executions to return in this request.
    public var maxResults: Swift.Int?
    /// A token generated by the Athena service that specifies where to continue pagination if a previous request was truncated. To obtain the next set of pages, pass in the NextToken from the response object of the previous page call.
    public var nextToken: Swift.String?
    /// The name of the workgroup from which queries are being returned. If a workgroup is not specified, a list of available query execution IDs for the queries in the primary workgroup is returned.
    public var workGroup: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        workGroup: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.workGroup = workGroup
    }
}

struct ListQueryExecutionsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let workGroup: Swift.String?
}

extension ListQueryExecutionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case workGroup = "WorkGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let workGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workGroup)
        workGroup = workGroupDecoded
    }
}

extension ListQueryExecutionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListQueryExecutionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListQueryExecutionsOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListQueryExecutionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListQueryExecutionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.queryExecutionIds = output.queryExecutionIds
        } else {
            self.nextToken = nil
            self.queryExecutionIds = nil
        }
    }
}

public struct ListQueryExecutionsOutputResponse: Swift.Equatable {
    /// A token to be used by the next request if this request is truncated.
    public var nextToken: Swift.String?
    /// The unique IDs of each query execution as an array of strings.
    public var queryExecutionIds: [Swift.String]?

    public init (
        nextToken: Swift.String? = nil,
        queryExecutionIds: [Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.queryExecutionIds = queryExecutionIds
    }
}

struct ListQueryExecutionsOutputResponseBody: Swift.Equatable {
    let queryExecutionIds: [Swift.String]?
    let nextToken: Swift.String?
}

extension ListQueryExecutionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case queryExecutionIds = "QueryExecutionIds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryExecutionIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .queryExecutionIds)
        var queryExecutionIdsDecoded0:[Swift.String]? = nil
        if let queryExecutionIdsContainer = queryExecutionIdsContainer {
            queryExecutionIdsDecoded0 = [Swift.String]()
            for string0 in queryExecutionIdsContainer {
                if let string0 = string0 {
                    queryExecutionIdsDecoded0?.append(string0)
                }
            }
        }
        queryExecutionIds = queryExecutionIdsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListSessionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case stateFilter = "StateFilter"
        case workGroup = "WorkGroup"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let stateFilter = self.stateFilter {
            try encodeContainer.encode(stateFilter.rawValue, forKey: .stateFilter)
        }
        if let workGroup = self.workGroup {
            try encodeContainer.encode(workGroup, forKey: .workGroup)
        }
    }
}

extension ListSessionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListSessionsInput: Swift.Equatable {
    /// The maximum number of sessions to return.
    public var maxResults: Swift.Int?
    /// A token generated by the Athena service that specifies where to continue pagination if a previous request was truncated. To obtain the next set of pages, pass in the NextToken from the response object of the previous page call.
    public var nextToken: Swift.String?
    /// A filter for a specific session state. A description of each state follows. CREATING - The session is being started, including acquiring resources. CREATED - The session has been started. IDLE - The session is able to accept a calculation. BUSY - The session is processing another task and is unable to accept a calculation. TERMINATING - The session is in the process of shutting down. TERMINATED - The session and its resources are no longer running. DEGRADED - The session has no healthy coordinators. FAILED - Due to a failure, the session and its resources are no longer running.
    public var stateFilter: AthenaClientTypes.SessionState?
    /// The workgroup to which the session belongs.
    /// This member is required.
    public var workGroup: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        stateFilter: AthenaClientTypes.SessionState? = nil,
        workGroup: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.stateFilter = stateFilter
        self.workGroup = workGroup
    }
}

struct ListSessionsInputBody: Swift.Equatable {
    let workGroup: Swift.String?
    let stateFilter: AthenaClientTypes.SessionState?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListSessionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case stateFilter = "StateFilter"
        case workGroup = "WorkGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workGroup)
        workGroup = workGroupDecoded
        let stateFilterDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.SessionState.self, forKey: .stateFilter)
        stateFilter = stateFilterDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListSessionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSessionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListSessionsOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSessionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListSessionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.sessions = output.sessions
        } else {
            self.nextToken = nil
            self.sessions = nil
        }
    }
}

public struct ListSessionsOutputResponse: Swift.Equatable {
    /// A token generated by the Athena service that specifies where to continue pagination if a previous request was truncated. To obtain the next set of pages, pass in the NextToken from the response object of the previous page call.
    public var nextToken: Swift.String?
    /// A list of sessions.
    public var sessions: [AthenaClientTypes.SessionSummary]?

    public init (
        nextToken: Swift.String? = nil,
        sessions: [AthenaClientTypes.SessionSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.sessions = sessions
    }
}

struct ListSessionsOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let sessions: [AthenaClientTypes.SessionSummary]?
}

extension ListSessionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case sessions = "Sessions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let sessionsContainer = try containerValues.decodeIfPresent([AthenaClientTypes.SessionSummary?].self, forKey: .sessions)
        var sessionsDecoded0:[AthenaClientTypes.SessionSummary]? = nil
        if let sessionsContainer = sessionsContainer {
            sessionsDecoded0 = [AthenaClientTypes.SessionSummary]()
            for structure0 in sessionsContainer {
                if let structure0 = structure0 {
                    sessionsDecoded0?.append(structure0)
                }
            }
        }
        sessions = sessionsDecoded0
    }
}

extension ListTableMetadataInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalogName = "CatalogName"
        case databaseName = "DatabaseName"
        case expression = "Expression"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogName = self.catalogName {
            try encodeContainer.encode(catalogName, forKey: .catalogName)
        }
        if let databaseName = self.databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let expression = self.expression {
            try encodeContainer.encode(expression, forKey: .expression)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListTableMetadataInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListTableMetadataInput: Swift.Equatable {
    /// The name of the data catalog for which table metadata should be returned.
    /// This member is required.
    public var catalogName: Swift.String?
    /// The name of the database for which table metadata should be returned.
    /// This member is required.
    public var databaseName: Swift.String?
    /// A regex filter that pattern-matches table names. If no expression is supplied, metadata for all tables are listed.
    public var expression: Swift.String?
    /// Specifies the maximum number of results to return.
    public var maxResults: Swift.Int?
    /// A token generated by the Athena service that specifies where to continue pagination if a previous request was truncated. To obtain the next set of pages, pass in the NextToken from the response object of the previous page call.
    public var nextToken: Swift.String?

    public init (
        catalogName: Swift.String? = nil,
        databaseName: Swift.String? = nil,
        expression: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.catalogName = catalogName
        self.databaseName = databaseName
        self.expression = expression
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListTableMetadataInputBody: Swift.Equatable {
    let catalogName: Swift.String?
    let databaseName: Swift.String?
    let expression: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListTableMetadataInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalogName = "CatalogName"
        case databaseName = "DatabaseName"
        case expression = "Expression"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .catalogName)
        catalogName = catalogNameDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let expressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expression)
        expression = expressionDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListTableMetadataOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTableMetadataOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MetadataException" : self = .metadataException(try MetadataException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListTableMetadataOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case metadataException(MetadataException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTableMetadataOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListTableMetadataOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.tableMetadataList = output.tableMetadataList
        } else {
            self.nextToken = nil
            self.tableMetadataList = nil
        }
    }
}

public struct ListTableMetadataOutputResponse: Swift.Equatable {
    /// A token generated by the Athena service that specifies where to continue pagination if a previous request was truncated. To obtain the next set of pages, pass in the NextToken from the response object of the previous page call.
    public var nextToken: Swift.String?
    /// A list of table metadata.
    public var tableMetadataList: [AthenaClientTypes.TableMetadata]?

    public init (
        nextToken: Swift.String? = nil,
        tableMetadataList: [AthenaClientTypes.TableMetadata]? = nil
    )
    {
        self.nextToken = nextToken
        self.tableMetadataList = tableMetadataList
    }
}

struct ListTableMetadataOutputResponseBody: Swift.Equatable {
    let tableMetadataList: [AthenaClientTypes.TableMetadata]?
    let nextToken: Swift.String?
}

extension ListTableMetadataOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case tableMetadataList = "TableMetadataList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tableMetadataListContainer = try containerValues.decodeIfPresent([AthenaClientTypes.TableMetadata?].self, forKey: .tableMetadataList)
        var tableMetadataListDecoded0:[AthenaClientTypes.TableMetadata]? = nil
        if let tableMetadataListContainer = tableMetadataListContainer {
            tableMetadataListDecoded0 = [AthenaClientTypes.TableMetadata]()
            for structure0 in tableMetadataListContainer {
                if let structure0 = structure0 {
                    tableMetadataListDecoded0?.append(structure0)
                }
            }
        }
        tableMetadataList = tableMetadataListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceARN = "ResourceARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The maximum number of results to be returned per request that lists the tags for the resource.
    public var maxResults: Swift.Int?
    /// The token for the next set of results, or null if there are no additional results for this request, where the request lists the tags for the resource with the specified ARN.
    public var nextToken: Swift.String?
    /// Lists the tags for the resource with the specified ARN.
    /// This member is required.
    public var resourceARN: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceARN: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceARN = resourceARN
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
    let resourceARN: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListTagsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceARN = "ResourceARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.tags = output.tags
        } else {
            self.nextToken = nil
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// A token to be used by the next request if this request is truncated.
    public var nextToken: Swift.String?
    /// The list of tags associated with the specified resource.
    public var tags: [AthenaClientTypes.Tag]?

    public init (
        nextToken: Swift.String? = nil,
        tags: [AthenaClientTypes.Tag]? = nil
    )
    {
        self.nextToken = nextToken
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let tags: [AthenaClientTypes.Tag]?
    let nextToken: Swift.String?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([AthenaClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[AthenaClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [AthenaClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListWorkGroupsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListWorkGroupsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListWorkGroupsInput: Swift.Equatable {
    /// The maximum number of workgroups to return in this request.
    public var maxResults: Swift.Int?
    /// A token generated by the Athena service that specifies where to continue pagination if a previous request was truncated. To obtain the next set of pages, pass in the NextToken from the response object of the previous page call.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListWorkGroupsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListWorkGroupsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListWorkGroupsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListWorkGroupsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListWorkGroupsOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListWorkGroupsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListWorkGroupsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.workGroups = output.workGroups
        } else {
            self.nextToken = nil
            self.workGroups = nil
        }
    }
}

public struct ListWorkGroupsOutputResponse: Swift.Equatable {
    /// A token generated by the Athena service that specifies where to continue pagination if a previous request was truncated. To obtain the next set of pages, pass in the NextToken from the response object of the previous page call.
    public var nextToken: Swift.String?
    /// A list of [WorkGroupSummary] objects that include the names, descriptions, creation times, and states for each workgroup.
    public var workGroups: [AthenaClientTypes.WorkGroupSummary]?

    public init (
        nextToken: Swift.String? = nil,
        workGroups: [AthenaClientTypes.WorkGroupSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.workGroups = workGroups
    }
}

struct ListWorkGroupsOutputResponseBody: Swift.Equatable {
    let workGroups: [AthenaClientTypes.WorkGroupSummary]?
    let nextToken: Swift.String?
}

extension ListWorkGroupsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case workGroups = "WorkGroups"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workGroupsContainer = try containerValues.decodeIfPresent([AthenaClientTypes.WorkGroupSummary?].self, forKey: .workGroups)
        var workGroupsDecoded0:[AthenaClientTypes.WorkGroupSummary]? = nil
        if let workGroupsContainer = workGroupsContainer {
            workGroupsDecoded0 = [AthenaClientTypes.WorkGroupSummary]()
            for structure0 in workGroupsContainer {
                if let structure0 = structure0 {
                    workGroupsDecoded0?.append(structure0)
                }
            }
        }
        workGroups = workGroupsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension MetadataException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: MetadataExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An exception that Athena received when it called a custom metastore. Occurs if the error is not caused by user input (InvalidRequestException) or from the Athena platform (InternalServerException). For example, if a user-created Lambda function is missing permissions, the Lambda 4XX exception is returned in a MetadataException.
public struct MetadataException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct MetadataExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension MetadataExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AthenaClientTypes.NamedQuery: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case database = "Database"
        case description = "Description"
        case name = "Name"
        case namedQueryId = "NamedQueryId"
        case queryString = "QueryString"
        case workGroup = "WorkGroup"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let database = self.database {
            try encodeContainer.encode(database, forKey: .database)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let namedQueryId = self.namedQueryId {
            try encodeContainer.encode(namedQueryId, forKey: .namedQueryId)
        }
        if let queryString = self.queryString {
            try encodeContainer.encode(queryString, forKey: .queryString)
        }
        if let workGroup = self.workGroup {
            try encodeContainer.encode(workGroup, forKey: .workGroup)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let databaseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .database)
        database = databaseDecoded
        let queryStringDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryString)
        queryString = queryStringDecoded
        let namedQueryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namedQueryId)
        namedQueryId = namedQueryIdDecoded
        let workGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workGroup)
        workGroup = workGroupDecoded
    }
}

extension AthenaClientTypes {
    /// A query, where QueryString contains the SQL statements that make up the query.
    public struct NamedQuery: Swift.Equatable {
        /// The database to which the query belongs.
        /// This member is required.
        public var database: Swift.String?
        /// The query description.
        public var description: Swift.String?
        /// The query name.
        /// This member is required.
        public var name: Swift.String?
        /// The unique identifier of the query.
        public var namedQueryId: Swift.String?
        /// The SQL statements that make up the query.
        /// This member is required.
        public var queryString: Swift.String?
        /// The name of the workgroup that contains the named query.
        public var workGroup: Swift.String?

        public init (
            database: Swift.String? = nil,
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            namedQueryId: Swift.String? = nil,
            queryString: Swift.String? = nil,
            workGroup: Swift.String? = nil
        )
        {
            self.database = database
            self.description = description
            self.name = name
            self.namedQueryId = namedQueryId
            self.queryString = queryString
            self.workGroup = workGroup
        }
    }

}

extension AthenaClientTypes.NotebookMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case lastModifiedTime = "LastModifiedTime"
        case name = "Name"
        case notebookId = "NotebookId"
        case type = "Type"
        case workGroup = "WorkGroup"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let lastModifiedTime = self.lastModifiedTime {
            try encodeContainer.encodeTimestamp(lastModifiedTime, format: .epochSeconds, forKey: .lastModifiedTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let notebookId = self.notebookId {
            try encodeContainer.encode(notebookId, forKey: .notebookId)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let workGroup = self.workGroup {
            try encodeContainer.encode(workGroup, forKey: .workGroup)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let notebookIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .notebookId)
        notebookId = notebookIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let workGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workGroup)
        workGroup = workGroupDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let typeDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.NotebookType.self, forKey: .type)
        type = typeDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
    }
}

extension AthenaClientTypes {
    /// Contains metadata for notebook, including the notebook name, ID, workgroup, and time created.
    public struct NotebookMetadata: Swift.Equatable {
        /// The time when the notebook was created.
        public var creationTime: ClientRuntime.Date?
        /// The time when the notebook was last modified.
        public var lastModifiedTime: ClientRuntime.Date?
        /// The name of the notebook.
        public var name: Swift.String?
        /// The notebook ID.
        public var notebookId: Swift.String?
        /// The type of notebook. Currently, the only valid type is IPYNB.
        public var type: AthenaClientTypes.NotebookType?
        /// The name of the Spark enabled workgroup to which the notebook belongs.
        public var workGroup: Swift.String?

        public init (
            creationTime: ClientRuntime.Date? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            notebookId: Swift.String? = nil,
            type: AthenaClientTypes.NotebookType? = nil,
            workGroup: Swift.String? = nil
        )
        {
            self.creationTime = creationTime
            self.lastModifiedTime = lastModifiedTime
            self.name = name
            self.notebookId = notebookId
            self.type = type
            self.workGroup = workGroup
        }
    }

}

extension AthenaClientTypes.NotebookSessionSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case sessionId = "SessionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let sessionId = self.sessionId {
            try encodeContainer.encode(sessionId, forKey: .sessionId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionId)
        sessionId = sessionIdDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
    }
}

extension AthenaClientTypes {
    /// Contains the notebook session ID and notebook session creation time.
    public struct NotebookSessionSummary: Swift.Equatable {
        /// The time when the notebook session was created.
        public var creationTime: ClientRuntime.Date?
        /// The notebook session ID.
        public var sessionId: Swift.String?

        public init (
            creationTime: ClientRuntime.Date? = nil,
            sessionId: Swift.String? = nil
        )
        {
            self.creationTime = creationTime
            self.sessionId = sessionId
        }
    }

}

extension AthenaClientTypes {
    public enum NotebookType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ipynb
        case sdkUnknown(Swift.String)

        public static var allCases: [NotebookType] {
            return [
                .ipynb,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ipynb: return "IPYNB"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NotebookType(rawValue: rawValue) ?? NotebookType.sdkUnknown(rawValue)
        }
    }
}

extension AthenaClientTypes.PreparedStatement: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case lastModifiedTime = "LastModifiedTime"
        case queryStatement = "QueryStatement"
        case statementName = "StatementName"
        case workGroupName = "WorkGroupName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let lastModifiedTime = self.lastModifiedTime {
            try encodeContainer.encodeTimestamp(lastModifiedTime, format: .epochSeconds, forKey: .lastModifiedTime)
        }
        if let queryStatement = self.queryStatement {
            try encodeContainer.encode(queryStatement, forKey: .queryStatement)
        }
        if let statementName = self.statementName {
            try encodeContainer.encode(statementName, forKey: .statementName)
        }
        if let workGroupName = self.workGroupName {
            try encodeContainer.encode(workGroupName, forKey: .workGroupName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statementNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statementName)
        statementName = statementNameDecoded
        let queryStatementDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryStatement)
        queryStatement = queryStatementDecoded
        let workGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workGroupName)
        workGroupName = workGroupNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
    }
}

extension AthenaClientTypes {
    /// A prepared SQL statement for use with Athena.
    public struct PreparedStatement: Swift.Equatable {
        /// The description of the prepared statement.
        public var description: Swift.String?
        /// The last modified time of the prepared statement.
        public var lastModifiedTime: ClientRuntime.Date?
        /// The query string for the prepared statement.
        public var queryStatement: Swift.String?
        /// The name of the prepared statement.
        public var statementName: Swift.String?
        /// The name of the workgroup to which the prepared statement belongs.
        public var workGroupName: Swift.String?

        public init (
            description: Swift.String? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil,
            queryStatement: Swift.String? = nil,
            statementName: Swift.String? = nil,
            workGroupName: Swift.String? = nil
        )
        {
            self.description = description
            self.lastModifiedTime = lastModifiedTime
            self.queryStatement = queryStatement
            self.statementName = statementName
            self.workGroupName = workGroupName
        }
    }

}

extension AthenaClientTypes.PreparedStatementSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lastModifiedTime = "LastModifiedTime"
        case statementName = "StatementName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lastModifiedTime = self.lastModifiedTime {
            try encodeContainer.encodeTimestamp(lastModifiedTime, format: .epochSeconds, forKey: .lastModifiedTime)
        }
        if let statementName = self.statementName {
            try encodeContainer.encode(statementName, forKey: .statementName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statementNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statementName)
        statementName = statementNameDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
    }
}

extension AthenaClientTypes {
    /// The name and last modified time of the prepared statement.
    public struct PreparedStatementSummary: Swift.Equatable {
        /// The last modified time of the prepared statement.
        public var lastModifiedTime: ClientRuntime.Date?
        /// The name of the prepared statement.
        public var statementName: Swift.String?

        public init (
            lastModifiedTime: ClientRuntime.Date? = nil,
            statementName: Swift.String? = nil
        )
        {
            self.lastModifiedTime = lastModifiedTime
            self.statementName = statementName
        }
    }

}

extension AthenaClientTypes.QueryExecution: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case engineVersion = "EngineVersion"
        case executionParameters = "ExecutionParameters"
        case query = "Query"
        case queryExecutionContext = "QueryExecutionContext"
        case queryExecutionId = "QueryExecutionId"
        case resultConfiguration = "ResultConfiguration"
        case resultReuseConfiguration = "ResultReuseConfiguration"
        case statementType = "StatementType"
        case statistics = "Statistics"
        case status = "Status"
        case workGroup = "WorkGroup"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let engineVersion = self.engineVersion {
            try encodeContainer.encode(engineVersion, forKey: .engineVersion)
        }
        if let executionParameters = executionParameters {
            var executionParametersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .executionParameters)
            for executionparameter0 in executionParameters {
                try executionParametersContainer.encode(executionparameter0)
            }
        }
        if let query = self.query {
            try encodeContainer.encode(query, forKey: .query)
        }
        if let queryExecutionContext = self.queryExecutionContext {
            try encodeContainer.encode(queryExecutionContext, forKey: .queryExecutionContext)
        }
        if let queryExecutionId = self.queryExecutionId {
            try encodeContainer.encode(queryExecutionId, forKey: .queryExecutionId)
        }
        if let resultConfiguration = self.resultConfiguration {
            try encodeContainer.encode(resultConfiguration, forKey: .resultConfiguration)
        }
        if let resultReuseConfiguration = self.resultReuseConfiguration {
            try encodeContainer.encode(resultReuseConfiguration, forKey: .resultReuseConfiguration)
        }
        if let statementType = self.statementType {
            try encodeContainer.encode(statementType.rawValue, forKey: .statementType)
        }
        if let statistics = self.statistics {
            try encodeContainer.encode(statistics, forKey: .statistics)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let workGroup = self.workGroup {
            try encodeContainer.encode(workGroup, forKey: .workGroup)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryExecutionId)
        queryExecutionId = queryExecutionIdDecoded
        let queryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .query)
        query = queryDecoded
        let statementTypeDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.StatementType.self, forKey: .statementType)
        statementType = statementTypeDecoded
        let resultConfigurationDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.ResultConfiguration.self, forKey: .resultConfiguration)
        resultConfiguration = resultConfigurationDecoded
        let resultReuseConfigurationDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.ResultReuseConfiguration.self, forKey: .resultReuseConfiguration)
        resultReuseConfiguration = resultReuseConfigurationDecoded
        let queryExecutionContextDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.QueryExecutionContext.self, forKey: .queryExecutionContext)
        queryExecutionContext = queryExecutionContextDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.QueryExecutionStatus.self, forKey: .status)
        status = statusDecoded
        let statisticsDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.QueryExecutionStatistics.self, forKey: .statistics)
        statistics = statisticsDecoded
        let workGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workGroup)
        workGroup = workGroupDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.EngineVersion.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let executionParametersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .executionParameters)
        var executionParametersDecoded0:[Swift.String]? = nil
        if let executionParametersContainer = executionParametersContainer {
            executionParametersDecoded0 = [Swift.String]()
            for string0 in executionParametersContainer {
                if let string0 = string0 {
                    executionParametersDecoded0?.append(string0)
                }
            }
        }
        executionParameters = executionParametersDecoded0
    }
}

extension AthenaClientTypes {
    /// Information about a single instance of a query execution.
    public struct QueryExecution: Swift.Equatable {
        /// The engine version that executed the query.
        public var engineVersion: AthenaClientTypes.EngineVersion?
        /// A list of values for the parameters in a query. The values are applied sequentially to the parameters in the query in the order in which the parameters occur.
        public var executionParameters: [Swift.String]?
        /// The SQL query statements which the query execution ran.
        public var query: Swift.String?
        /// The database in which the query execution occurred.
        public var queryExecutionContext: AthenaClientTypes.QueryExecutionContext?
        /// The unique identifier for each query execution.
        public var queryExecutionId: Swift.String?
        /// The location in Amazon S3 where query results were stored and the encryption option, if any, used for query results. These are known as "client-side settings". If workgroup settings override client-side settings, then the query uses the location for the query results and the encryption configuration that are specified for the workgroup.
        public var resultConfiguration: AthenaClientTypes.ResultConfiguration?
        /// Specifies the query result reuse behavior that was used for the query.
        public var resultReuseConfiguration: AthenaClientTypes.ResultReuseConfiguration?
        /// The type of query statement that was run. DDL indicates DDL query statements. DML indicates DML (Data Manipulation Language) query statements, such as CREATE TABLE AS SELECT. UTILITY indicates query statements other than DDL and DML, such as SHOW CREATE TABLE, or DESCRIBE TABLE.
        public var statementType: AthenaClientTypes.StatementType?
        /// Query execution statistics, such as the amount of data scanned, the amount of time that the query took to process, and the type of statement that was run.
        public var statistics: AthenaClientTypes.QueryExecutionStatistics?
        /// The completion date, current state, submission time, and state change reason (if applicable) for the query execution.
        public var status: AthenaClientTypes.QueryExecutionStatus?
        /// The name of the workgroup in which the query ran.
        public var workGroup: Swift.String?

        public init (
            engineVersion: AthenaClientTypes.EngineVersion? = nil,
            executionParameters: [Swift.String]? = nil,
            query: Swift.String? = nil,
            queryExecutionContext: AthenaClientTypes.QueryExecutionContext? = nil,
            queryExecutionId: Swift.String? = nil,
            resultConfiguration: AthenaClientTypes.ResultConfiguration? = nil,
            resultReuseConfiguration: AthenaClientTypes.ResultReuseConfiguration? = nil,
            statementType: AthenaClientTypes.StatementType? = nil,
            statistics: AthenaClientTypes.QueryExecutionStatistics? = nil,
            status: AthenaClientTypes.QueryExecutionStatus? = nil,
            workGroup: Swift.String? = nil
        )
        {
            self.engineVersion = engineVersion
            self.executionParameters = executionParameters
            self.query = query
            self.queryExecutionContext = queryExecutionContext
            self.queryExecutionId = queryExecutionId
            self.resultConfiguration = resultConfiguration
            self.resultReuseConfiguration = resultReuseConfiguration
            self.statementType = statementType
            self.statistics = statistics
            self.status = status
            self.workGroup = workGroup
        }
    }

}

extension AthenaClientTypes.QueryExecutionContext: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalog = "Catalog"
        case database = "Database"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalog = self.catalog {
            try encodeContainer.encode(catalog, forKey: .catalog)
        }
        if let database = self.database {
            try encodeContainer.encode(database, forKey: .database)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let databaseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .database)
        database = databaseDecoded
        let catalogDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .catalog)
        catalog = catalogDecoded
    }
}

extension AthenaClientTypes {
    /// The database and data catalog context in which the query execution occurs.
    public struct QueryExecutionContext: Swift.Equatable {
        /// The name of the data catalog used in the query execution.
        public var catalog: Swift.String?
        /// The name of the database used in the query execution. The database must exist in the catalog.
        public var database: Swift.String?

        public init (
            catalog: Swift.String? = nil,
            database: Swift.String? = nil
        )
        {
            self.catalog = catalog
            self.database = database
        }
    }

}

extension AthenaClientTypes {
    public enum QueryExecutionState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cancelled
        case failed
        case queued
        case running
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [QueryExecutionState] {
            return [
                .cancelled,
                .failed,
                .queued,
                .running,
                .succeeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "CANCELLED"
            case .failed: return "FAILED"
            case .queued: return "QUEUED"
            case .running: return "RUNNING"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = QueryExecutionState(rawValue: rawValue) ?? QueryExecutionState.sdkUnknown(rawValue)
        }
    }
}

extension AthenaClientTypes.QueryExecutionStatistics: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataManifestLocation = "DataManifestLocation"
        case dataScannedInBytes = "DataScannedInBytes"
        case engineExecutionTimeInMillis = "EngineExecutionTimeInMillis"
        case queryPlanningTimeInMillis = "QueryPlanningTimeInMillis"
        case queryQueueTimeInMillis = "QueryQueueTimeInMillis"
        case resultReuseInformation = "ResultReuseInformation"
        case serviceProcessingTimeInMillis = "ServiceProcessingTimeInMillis"
        case totalExecutionTimeInMillis = "TotalExecutionTimeInMillis"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataManifestLocation = self.dataManifestLocation {
            try encodeContainer.encode(dataManifestLocation, forKey: .dataManifestLocation)
        }
        if let dataScannedInBytes = self.dataScannedInBytes {
            try encodeContainer.encode(dataScannedInBytes, forKey: .dataScannedInBytes)
        }
        if let engineExecutionTimeInMillis = self.engineExecutionTimeInMillis {
            try encodeContainer.encode(engineExecutionTimeInMillis, forKey: .engineExecutionTimeInMillis)
        }
        if let queryPlanningTimeInMillis = self.queryPlanningTimeInMillis {
            try encodeContainer.encode(queryPlanningTimeInMillis, forKey: .queryPlanningTimeInMillis)
        }
        if let queryQueueTimeInMillis = self.queryQueueTimeInMillis {
            try encodeContainer.encode(queryQueueTimeInMillis, forKey: .queryQueueTimeInMillis)
        }
        if let resultReuseInformation = self.resultReuseInformation {
            try encodeContainer.encode(resultReuseInformation, forKey: .resultReuseInformation)
        }
        if let serviceProcessingTimeInMillis = self.serviceProcessingTimeInMillis {
            try encodeContainer.encode(serviceProcessingTimeInMillis, forKey: .serviceProcessingTimeInMillis)
        }
        if let totalExecutionTimeInMillis = self.totalExecutionTimeInMillis {
            try encodeContainer.encode(totalExecutionTimeInMillis, forKey: .totalExecutionTimeInMillis)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let engineExecutionTimeInMillisDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .engineExecutionTimeInMillis)
        engineExecutionTimeInMillis = engineExecutionTimeInMillisDecoded
        let dataScannedInBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .dataScannedInBytes)
        dataScannedInBytes = dataScannedInBytesDecoded
        let dataManifestLocationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataManifestLocation)
        dataManifestLocation = dataManifestLocationDecoded
        let totalExecutionTimeInMillisDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalExecutionTimeInMillis)
        totalExecutionTimeInMillis = totalExecutionTimeInMillisDecoded
        let queryQueueTimeInMillisDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .queryQueueTimeInMillis)
        queryQueueTimeInMillis = queryQueueTimeInMillisDecoded
        let queryPlanningTimeInMillisDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .queryPlanningTimeInMillis)
        queryPlanningTimeInMillis = queryPlanningTimeInMillisDecoded
        let serviceProcessingTimeInMillisDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .serviceProcessingTimeInMillis)
        serviceProcessingTimeInMillis = serviceProcessingTimeInMillisDecoded
        let resultReuseInformationDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.ResultReuseInformation.self, forKey: .resultReuseInformation)
        resultReuseInformation = resultReuseInformationDecoded
    }
}

extension AthenaClientTypes {
    /// The amount of data scanned during the query execution and the amount of time that it took to execute, and the type of statement that was run.
    public struct QueryExecutionStatistics: Swift.Equatable {
        /// The location and file name of a data manifest file. The manifest file is saved to the Athena query results location in Amazon S3. The manifest file tracks files that the query wrote to Amazon S3. If the query fails, the manifest file also tracks files that the query intended to write. The manifest is useful for identifying orphaned files resulting from a failed query. For more information, see [Working with Query Results, Output Files, and Query History](https://docs.aws.amazon.com/athena/latest/ug/querying.html) in the Amazon Athena User Guide.
        public var dataManifestLocation: Swift.String?
        /// The number of bytes in the data that was queried.
        public var dataScannedInBytes: Swift.Int?
        /// The number of milliseconds that the query took to execute.
        public var engineExecutionTimeInMillis: Swift.Int?
        /// The number of milliseconds that Athena took to plan the query processing flow. This includes the time spent retrieving table partitions from the data source. Note that because the query engine performs the query planning, query planning time is a subset of engine processing time.
        public var queryPlanningTimeInMillis: Swift.Int?
        /// The number of milliseconds that the query was in your query queue waiting for resources. Note that if transient errors occur, Athena might automatically add the query back to the queue.
        public var queryQueueTimeInMillis: Swift.Int?
        /// Contains information about whether previous query results were reused for the query.
        public var resultReuseInformation: AthenaClientTypes.ResultReuseInformation?
        /// The number of milliseconds that Athena took to finalize and publish the query results after the query engine finished running the query.
        public var serviceProcessingTimeInMillis: Swift.Int?
        /// The number of milliseconds that Athena took to run the query.
        public var totalExecutionTimeInMillis: Swift.Int?

        public init (
            dataManifestLocation: Swift.String? = nil,
            dataScannedInBytes: Swift.Int? = nil,
            engineExecutionTimeInMillis: Swift.Int? = nil,
            queryPlanningTimeInMillis: Swift.Int? = nil,
            queryQueueTimeInMillis: Swift.Int? = nil,
            resultReuseInformation: AthenaClientTypes.ResultReuseInformation? = nil,
            serviceProcessingTimeInMillis: Swift.Int? = nil,
            totalExecutionTimeInMillis: Swift.Int? = nil
        )
        {
            self.dataManifestLocation = dataManifestLocation
            self.dataScannedInBytes = dataScannedInBytes
            self.engineExecutionTimeInMillis = engineExecutionTimeInMillis
            self.queryPlanningTimeInMillis = queryPlanningTimeInMillis
            self.queryQueueTimeInMillis = queryQueueTimeInMillis
            self.resultReuseInformation = resultReuseInformation
            self.serviceProcessingTimeInMillis = serviceProcessingTimeInMillis
            self.totalExecutionTimeInMillis = totalExecutionTimeInMillis
        }
    }

}

extension AthenaClientTypes.QueryExecutionStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case athenaError = "AthenaError"
        case completionDateTime = "CompletionDateTime"
        case state = "State"
        case stateChangeReason = "StateChangeReason"
        case submissionDateTime = "SubmissionDateTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let athenaError = self.athenaError {
            try encodeContainer.encode(athenaError, forKey: .athenaError)
        }
        if let completionDateTime = self.completionDateTime {
            try encodeContainer.encodeTimestamp(completionDateTime, format: .epochSeconds, forKey: .completionDateTime)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let stateChangeReason = self.stateChangeReason {
            try encodeContainer.encode(stateChangeReason, forKey: .stateChangeReason)
        }
        if let submissionDateTime = self.submissionDateTime {
            try encodeContainer.encodeTimestamp(submissionDateTime, format: .epochSeconds, forKey: .submissionDateTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.QueryExecutionState.self, forKey: .state)
        state = stateDecoded
        let stateChangeReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stateChangeReason)
        stateChangeReason = stateChangeReasonDecoded
        let submissionDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .submissionDateTime)
        submissionDateTime = submissionDateTimeDecoded
        let completionDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .completionDateTime)
        completionDateTime = completionDateTimeDecoded
        let athenaErrorDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.AthenaError.self, forKey: .athenaError)
        athenaError = athenaErrorDecoded
    }
}

extension AthenaClientTypes {
    /// The completion date, current state, submission time, and state change reason (if applicable) for the query execution.
    public struct QueryExecutionStatus: Swift.Equatable {
        /// Provides information about an Athena query error.
        public var athenaError: AthenaClientTypes.AthenaError?
        /// The date and time that the query completed.
        public var completionDateTime: ClientRuntime.Date?
        /// The state of query execution. QUEUED indicates that the query has been submitted to the service, and Athena will execute the query as soon as resources are available. RUNNING indicates that the query is in execution phase. SUCCEEDED indicates that the query completed without errors. FAILED indicates that the query experienced an error and did not complete processing. CANCELLED indicates that a user input interrupted query execution. Athena automatically retries your queries in cases of certain transient errors. As a result, you may see the query state transition from RUNNING or FAILED to QUEUED.
        public var state: AthenaClientTypes.QueryExecutionState?
        /// Further detail about the status of the query.
        public var stateChangeReason: Swift.String?
        /// The date and time that the query was submitted.
        public var submissionDateTime: ClientRuntime.Date?

        public init (
            athenaError: AthenaClientTypes.AthenaError? = nil,
            completionDateTime: ClientRuntime.Date? = nil,
            state: AthenaClientTypes.QueryExecutionState? = nil,
            stateChangeReason: Swift.String? = nil,
            submissionDateTime: ClientRuntime.Date? = nil
        )
        {
            self.athenaError = athenaError
            self.completionDateTime = completionDateTime
            self.state = state
            self.stateChangeReason = stateChangeReason
            self.submissionDateTime = submissionDateTime
        }
    }

}

extension AthenaClientTypes.QueryRuntimeStatistics: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case outputStage = "OutputStage"
        case rows = "Rows"
        case timeline = "Timeline"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let outputStage = self.outputStage {
            try encodeContainer.encode(outputStage, forKey: .outputStage)
        }
        if let rows = self.rows {
            try encodeContainer.encode(rows, forKey: .rows)
        }
        if let timeline = self.timeline {
            try encodeContainer.encode(timeline, forKey: .timeline)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timelineDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.QueryRuntimeStatisticsTimeline.self, forKey: .timeline)
        timeline = timelineDecoded
        let rowsDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.QueryRuntimeStatisticsRows.self, forKey: .rows)
        rows = rowsDecoded
        let outputStageDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.QueryStage.self, forKey: .outputStage)
        outputStage = outputStageDecoded
    }
}

extension AthenaClientTypes {
    /// The query execution timeline, statistics on input and output rows and bytes, and the different query stages that form the query execution plan.
    public struct QueryRuntimeStatistics: Swift.Equatable {
        /// Stage statistics such as input and output rows and bytes, execution time, and stage state. This information also includes substages and the query stage plan.
        public var outputStage: AthenaClientTypes.QueryStage?
        /// Statistics such as input rows and bytes read by the query, rows and bytes output by the query, and the number of rows written by the query.
        public var rows: AthenaClientTypes.QueryRuntimeStatisticsRows?
        /// Timeline statistics such as query queue time, planning time, execution time, service processing time, and total execution time.
        public var timeline: AthenaClientTypes.QueryRuntimeStatisticsTimeline?

        public init (
            outputStage: AthenaClientTypes.QueryStage? = nil,
            rows: AthenaClientTypes.QueryRuntimeStatisticsRows? = nil,
            timeline: AthenaClientTypes.QueryRuntimeStatisticsTimeline? = nil
        )
        {
            self.outputStage = outputStage
            self.rows = rows
            self.timeline = timeline
        }
    }

}

extension AthenaClientTypes.QueryRuntimeStatisticsRows: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inputBytes = "InputBytes"
        case inputRows = "InputRows"
        case outputBytes = "OutputBytes"
        case outputRows = "OutputRows"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inputBytes = self.inputBytes {
            try encodeContainer.encode(inputBytes, forKey: .inputBytes)
        }
        if let inputRows = self.inputRows {
            try encodeContainer.encode(inputRows, forKey: .inputRows)
        }
        if let outputBytes = self.outputBytes {
            try encodeContainer.encode(outputBytes, forKey: .outputBytes)
        }
        if let outputRows = self.outputRows {
            try encodeContainer.encode(outputRows, forKey: .outputRows)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputRowsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .inputRows)
        inputRows = inputRowsDecoded
        let inputBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .inputBytes)
        inputBytes = inputBytesDecoded
        let outputBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .outputBytes)
        outputBytes = outputBytesDecoded
        let outputRowsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .outputRows)
        outputRows = outputRowsDecoded
    }
}

extension AthenaClientTypes {
    /// Statistics such as input rows and bytes read by the query, rows and bytes output by the query, and the number of rows written by the query.
    public struct QueryRuntimeStatisticsRows: Swift.Equatable {
        /// The number of bytes read to execute the query.
        public var inputBytes: Swift.Int?
        /// The number of rows read to execute the query.
        public var inputRows: Swift.Int?
        /// The number of bytes returned by the query.
        public var outputBytes: Swift.Int?
        /// The number of rows returned by the query.
        public var outputRows: Swift.Int?

        public init (
            inputBytes: Swift.Int? = nil,
            inputRows: Swift.Int? = nil,
            outputBytes: Swift.Int? = nil,
            outputRows: Swift.Int? = nil
        )
        {
            self.inputBytes = inputBytes
            self.inputRows = inputRows
            self.outputBytes = outputBytes
            self.outputRows = outputRows
        }
    }

}

extension AthenaClientTypes.QueryRuntimeStatisticsTimeline: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case engineExecutionTimeInMillis = "EngineExecutionTimeInMillis"
        case queryPlanningTimeInMillis = "QueryPlanningTimeInMillis"
        case queryQueueTimeInMillis = "QueryQueueTimeInMillis"
        case serviceProcessingTimeInMillis = "ServiceProcessingTimeInMillis"
        case totalExecutionTimeInMillis = "TotalExecutionTimeInMillis"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let engineExecutionTimeInMillis = self.engineExecutionTimeInMillis {
            try encodeContainer.encode(engineExecutionTimeInMillis, forKey: .engineExecutionTimeInMillis)
        }
        if let queryPlanningTimeInMillis = self.queryPlanningTimeInMillis {
            try encodeContainer.encode(queryPlanningTimeInMillis, forKey: .queryPlanningTimeInMillis)
        }
        if let queryQueueTimeInMillis = self.queryQueueTimeInMillis {
            try encodeContainer.encode(queryQueueTimeInMillis, forKey: .queryQueueTimeInMillis)
        }
        if let serviceProcessingTimeInMillis = self.serviceProcessingTimeInMillis {
            try encodeContainer.encode(serviceProcessingTimeInMillis, forKey: .serviceProcessingTimeInMillis)
        }
        if let totalExecutionTimeInMillis = self.totalExecutionTimeInMillis {
            try encodeContainer.encode(totalExecutionTimeInMillis, forKey: .totalExecutionTimeInMillis)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryQueueTimeInMillisDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .queryQueueTimeInMillis)
        queryQueueTimeInMillis = queryQueueTimeInMillisDecoded
        let queryPlanningTimeInMillisDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .queryPlanningTimeInMillis)
        queryPlanningTimeInMillis = queryPlanningTimeInMillisDecoded
        let engineExecutionTimeInMillisDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .engineExecutionTimeInMillis)
        engineExecutionTimeInMillis = engineExecutionTimeInMillisDecoded
        let serviceProcessingTimeInMillisDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .serviceProcessingTimeInMillis)
        serviceProcessingTimeInMillis = serviceProcessingTimeInMillisDecoded
        let totalExecutionTimeInMillisDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalExecutionTimeInMillis)
        totalExecutionTimeInMillis = totalExecutionTimeInMillisDecoded
    }
}

extension AthenaClientTypes {
    /// Timeline statistics such as query queue time, planning time, execution time, service processing time, and total execution time.
    public struct QueryRuntimeStatisticsTimeline: Swift.Equatable {
        /// The number of milliseconds that the query took to execute.
        public var engineExecutionTimeInMillis: Swift.Int?
        /// The number of milliseconds that Athena took to plan the query processing flow. This includes the time spent retrieving table partitions from the data source. Note that because the query engine performs the query planning, query planning time is a subset of engine processing time.
        public var queryPlanningTimeInMillis: Swift.Int?
        /// The number of milliseconds that the query was in your query queue waiting for resources. Note that if transient errors occur, Athena might automatically add the query back to the queue.
        public var queryQueueTimeInMillis: Swift.Int?
        /// The number of milliseconds that Athena took to finalize and publish the query results after the query engine finished running the query.
        public var serviceProcessingTimeInMillis: Swift.Int?
        /// The number of milliseconds that Athena took to run the query.
        public var totalExecutionTimeInMillis: Swift.Int?

        public init (
            engineExecutionTimeInMillis: Swift.Int? = nil,
            queryPlanningTimeInMillis: Swift.Int? = nil,
            queryQueueTimeInMillis: Swift.Int? = nil,
            serviceProcessingTimeInMillis: Swift.Int? = nil,
            totalExecutionTimeInMillis: Swift.Int? = nil
        )
        {
            self.engineExecutionTimeInMillis = engineExecutionTimeInMillis
            self.queryPlanningTimeInMillis = queryPlanningTimeInMillis
            self.queryQueueTimeInMillis = queryQueueTimeInMillis
            self.serviceProcessingTimeInMillis = serviceProcessingTimeInMillis
            self.totalExecutionTimeInMillis = totalExecutionTimeInMillis
        }
    }

}

extension AthenaClientTypes.QueryStage: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case executionTime = "ExecutionTime"
        case inputBytes = "InputBytes"
        case inputRows = "InputRows"
        case outputBytes = "OutputBytes"
        case outputRows = "OutputRows"
        case queryStagePlan = "QueryStagePlan"
        case stageId = "StageId"
        case state = "State"
        case subStages = "SubStages"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let executionTime = self.executionTime {
            try encodeContainer.encode(executionTime, forKey: .executionTime)
        }
        if let inputBytes = self.inputBytes {
            try encodeContainer.encode(inputBytes, forKey: .inputBytes)
        }
        if let inputRows = self.inputRows {
            try encodeContainer.encode(inputRows, forKey: .inputRows)
        }
        if let outputBytes = self.outputBytes {
            try encodeContainer.encode(outputBytes, forKey: .outputBytes)
        }
        if let outputRows = self.outputRows {
            try encodeContainer.encode(outputRows, forKey: .outputRows)
        }
        if let queryStagePlan = self.queryStagePlan {
            try encodeContainer.encode(queryStagePlan, forKey: .queryStagePlan)
        }
        if let stageId = self.stageId {
            try encodeContainer.encode(stageId, forKey: .stageId)
        }
        if let state = self.state {
            try encodeContainer.encode(state, forKey: .state)
        }
        if let subStages = subStages {
            var subStagesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subStages)
            for querystage0 in subStages {
                try subStagesContainer.encode(querystage0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stageIdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .stageId)
        stageId = stageIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .state)
        state = stateDecoded
        let outputBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .outputBytes)
        outputBytes = outputBytesDecoded
        let outputRowsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .outputRows)
        outputRows = outputRowsDecoded
        let inputBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .inputBytes)
        inputBytes = inputBytesDecoded
        let inputRowsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .inputRows)
        inputRows = inputRowsDecoded
        let executionTimeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .executionTime)
        executionTime = executionTimeDecoded
        let queryStagePlanDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.QueryStagePlanNode.self, forKey: .queryStagePlan)
        queryStagePlan = queryStagePlanDecoded
        let subStagesContainer = try containerValues.decodeIfPresent([AthenaClientTypes.QueryStage?].self, forKey: .subStages)
        var subStagesDecoded0:[AthenaClientTypes.QueryStage]? = nil
        if let subStagesContainer = subStagesContainer {
            subStagesDecoded0 = [AthenaClientTypes.QueryStage]()
            for structure0 in subStagesContainer {
                if let structure0 = structure0 {
                    subStagesDecoded0?.append(structure0)
                }
            }
        }
        subStages = subStagesDecoded0
    }
}

extension AthenaClientTypes {
    /// Stage statistics such as input and output rows and bytes, execution time and stage state. This information also includes substages and the query stage plan.
    public struct QueryStage: Swift.Equatable {
        /// Time taken to execute this stage.
        public var executionTime: Swift.Int?
        /// The number of bytes input into the stage for execution.
        public var inputBytes: Swift.Int?
        /// The number of rows input into the stage for execution.
        public var inputRows: Swift.Int?
        /// The number of bytes output from the stage after execution.
        public var outputBytes: Swift.Int?
        /// The number of rows output from the stage after execution.
        public var outputRows: Swift.Int?
        /// Stage plan information such as name, identifier, sub plans, and source stages.
        public var queryStagePlan: AthenaClientTypes.QueryStagePlanNode?
        /// The identifier for a stage.
        public var stageId: Swift.Int?
        /// State of the stage after query execution.
        public var state: Swift.String?
        /// List of sub query stages that form this stage execution plan.
        public var subStages: [AthenaClientTypes.QueryStage]?

        public init (
            executionTime: Swift.Int? = nil,
            inputBytes: Swift.Int? = nil,
            inputRows: Swift.Int? = nil,
            outputBytes: Swift.Int? = nil,
            outputRows: Swift.Int? = nil,
            queryStagePlan: AthenaClientTypes.QueryStagePlanNode? = nil,
            stageId: Swift.Int? = nil,
            state: Swift.String? = nil,
            subStages: [AthenaClientTypes.QueryStage]? = nil
        )
        {
            self.executionTime = executionTime
            self.inputBytes = inputBytes
            self.inputRows = inputRows
            self.outputBytes = outputBytes
            self.outputRows = outputRows
            self.queryStagePlan = queryStagePlan
            self.stageId = stageId
            self.state = state
            self.subStages = subStages
        }
    }

}

extension AthenaClientTypes.QueryStagePlanNode: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case children = "Children"
        case identifier = "Identifier"
        case name = "Name"
        case remoteSources = "RemoteSources"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let children = children {
            var childrenContainer = encodeContainer.nestedUnkeyedContainer(forKey: .children)
            for querystageplannode0 in children {
                try childrenContainer.encode(querystageplannode0)
            }
        }
        if let identifier = self.identifier {
            try encodeContainer.encode(identifier, forKey: .identifier)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let remoteSources = remoteSources {
            var remoteSourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .remoteSources)
            for string0 in remoteSources {
                try remoteSourcesContainer.encode(string0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let identifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identifier)
        identifier = identifierDecoded
        let childrenContainer = try containerValues.decodeIfPresent([AthenaClientTypes.QueryStagePlanNode?].self, forKey: .children)
        var childrenDecoded0:[AthenaClientTypes.QueryStagePlanNode]? = nil
        if let childrenContainer = childrenContainer {
            childrenDecoded0 = [AthenaClientTypes.QueryStagePlanNode]()
            for structure0 in childrenContainer {
                if let structure0 = structure0 {
                    childrenDecoded0?.append(structure0)
                }
            }
        }
        children = childrenDecoded0
        let remoteSourcesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .remoteSources)
        var remoteSourcesDecoded0:[Swift.String]? = nil
        if let remoteSourcesContainer = remoteSourcesContainer {
            remoteSourcesDecoded0 = [Swift.String]()
            for string0 in remoteSourcesContainer {
                if let string0 = string0 {
                    remoteSourcesDecoded0?.append(string0)
                }
            }
        }
        remoteSources = remoteSourcesDecoded0
    }
}

extension AthenaClientTypes {
    /// Stage plan information such as name, identifier, sub plans, and remote sources.
    public struct QueryStagePlanNode: Swift.Equatable {
        /// Stage plan information such as name, identifier, sub plans, and remote sources of child plan nodes/
        public var children: [AthenaClientTypes.QueryStagePlanNode]?
        /// Information about the operation this query stage plan node is performing.
        public var identifier: Swift.String?
        /// Name of the query stage plan that describes the operation this stage is performing as part of query execution.
        public var name: Swift.String?
        /// Source plan node IDs.
        public var remoteSources: [Swift.String]?

        public init (
            children: [AthenaClientTypes.QueryStagePlanNode]? = nil,
            identifier: Swift.String? = nil,
            name: Swift.String? = nil,
            remoteSources: [Swift.String]? = nil
        )
        {
            self.children = children
            self.identifier = identifier
            self.name = name
            self.remoteSources = remoteSources
        }
    }

}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceName = output.resourceName
        } else {
            self.message = nil
            self.resourceName = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A resource, such as a workgroup, was not found.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    /// The name of the Amazon resource.
    public var resourceName: Swift.String?

    public init (
        message: Swift.String? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.message = message
        self.resourceName = resourceName
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceName: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case resourceName = "ResourceName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension AthenaClientTypes.ResultConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aclConfiguration = "AclConfiguration"
        case encryptionConfiguration = "EncryptionConfiguration"
        case expectedBucketOwner = "ExpectedBucketOwner"
        case outputLocation = "OutputLocation"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aclConfiguration = self.aclConfiguration {
            try encodeContainer.encode(aclConfiguration, forKey: .aclConfiguration)
        }
        if let encryptionConfiguration = self.encryptionConfiguration {
            try encodeContainer.encode(encryptionConfiguration, forKey: .encryptionConfiguration)
        }
        if let expectedBucketOwner = self.expectedBucketOwner {
            try encodeContainer.encode(expectedBucketOwner, forKey: .expectedBucketOwner)
        }
        if let outputLocation = self.outputLocation {
            try encodeContainer.encode(outputLocation, forKey: .outputLocation)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let outputLocationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputLocation)
        outputLocation = outputLocationDecoded
        let encryptionConfigurationDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.EncryptionConfiguration.self, forKey: .encryptionConfiguration)
        encryptionConfiguration = encryptionConfigurationDecoded
        let expectedBucketOwnerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expectedBucketOwner)
        expectedBucketOwner = expectedBucketOwnerDecoded
        let aclConfigurationDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.AclConfiguration.self, forKey: .aclConfiguration)
        aclConfiguration = aclConfigurationDecoded
    }
}

extension AthenaClientTypes {
    /// The location in Amazon S3 where query results are stored and the encryption option, if any, used for query results. These are known as "client-side settings". If workgroup settings override client-side settings, then the query uses the workgroup settings.
    public struct ResultConfiguration: Swift.Equatable {
        /// Indicates that an Amazon S3 canned ACL should be set to control ownership of stored query results. Currently the only supported canned ACL is BUCKET_OWNER_FULL_CONTROL. This is a client-side setting. If workgroup settings override client-side settings, then the query uses the ACL configuration that is specified for the workgroup, and also uses the location for storing query results specified in the workgroup. For more information, see [WorkGroupConfiguration$EnforceWorkGroupConfiguration] and [Workgroup Settings Override Client-Side Settings](https://docs.aws.amazon.com/athena/latest/ug/workgroups-settings-override.html).
        public var aclConfiguration: AthenaClientTypes.AclConfiguration?
        /// If query results are encrypted in Amazon S3, indicates the encryption option used (for example, SSE_KMS or CSE_KMS) and key information. This is a client-side setting. If workgroup settings override client-side settings, then the query uses the encryption configuration that is specified for the workgroup, and also uses the location for storing query results specified in the workgroup. See [WorkGroupConfiguration$EnforceWorkGroupConfiguration] and [Workgroup Settings Override Client-Side Settings](https://docs.aws.amazon.com/athena/latest/ug/workgroups-settings-override.html).
        public var encryptionConfiguration: AthenaClientTypes.EncryptionConfiguration?
        /// The Amazon Web Services account ID that you expect to be the owner of the Amazon S3 bucket specified by [ResultConfiguration$OutputLocation]. If set, Athena uses the value for ExpectedBucketOwner when it makes Amazon S3 calls to your specified output location. If the ExpectedBucketOwner Amazon Web Services account ID does not match the actual owner of the Amazon S3 bucket, the call fails with a permissions error. This is a client-side setting. If workgroup settings override client-side settings, then the query uses the ExpectedBucketOwner setting that is specified for the workgroup, and also uses the location for storing query results specified in the workgroup. See [WorkGroupConfiguration$EnforceWorkGroupConfiguration] and [Workgroup Settings Override Client-Side Settings](https://docs.aws.amazon.com/athena/latest/ug/workgroups-settings-override.html).
        public var expectedBucketOwner: Swift.String?
        /// The location in Amazon S3 where your query results are stored, such as s3://path/to/query/bucket/. To run the query, you must specify the query results location using one of the ways: either for individual queries using either this setting (client-side), or in the workgroup, using [WorkGroupConfiguration]. If none of them is set, Athena issues an error that no output location is provided. For more information, see [Query Results](https://docs.aws.amazon.com/athena/latest/ug/querying.html). If workgroup settings override client-side settings, then the query uses the settings specified for the workgroup. See [WorkGroupConfiguration$EnforceWorkGroupConfiguration].
        public var outputLocation: Swift.String?

        public init (
            aclConfiguration: AthenaClientTypes.AclConfiguration? = nil,
            encryptionConfiguration: AthenaClientTypes.EncryptionConfiguration? = nil,
            expectedBucketOwner: Swift.String? = nil,
            outputLocation: Swift.String? = nil
        )
        {
            self.aclConfiguration = aclConfiguration
            self.encryptionConfiguration = encryptionConfiguration
            self.expectedBucketOwner = expectedBucketOwner
            self.outputLocation = outputLocation
        }
    }

}

extension AthenaClientTypes.ResultConfigurationUpdates: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aclConfiguration = "AclConfiguration"
        case encryptionConfiguration = "EncryptionConfiguration"
        case expectedBucketOwner = "ExpectedBucketOwner"
        case outputLocation = "OutputLocation"
        case removeAclConfiguration = "RemoveAclConfiguration"
        case removeEncryptionConfiguration = "RemoveEncryptionConfiguration"
        case removeExpectedBucketOwner = "RemoveExpectedBucketOwner"
        case removeOutputLocation = "RemoveOutputLocation"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aclConfiguration = self.aclConfiguration {
            try encodeContainer.encode(aclConfiguration, forKey: .aclConfiguration)
        }
        if let encryptionConfiguration = self.encryptionConfiguration {
            try encodeContainer.encode(encryptionConfiguration, forKey: .encryptionConfiguration)
        }
        if let expectedBucketOwner = self.expectedBucketOwner {
            try encodeContainer.encode(expectedBucketOwner, forKey: .expectedBucketOwner)
        }
        if let outputLocation = self.outputLocation {
            try encodeContainer.encode(outputLocation, forKey: .outputLocation)
        }
        if let removeAclConfiguration = self.removeAclConfiguration {
            try encodeContainer.encode(removeAclConfiguration, forKey: .removeAclConfiguration)
        }
        if let removeEncryptionConfiguration = self.removeEncryptionConfiguration {
            try encodeContainer.encode(removeEncryptionConfiguration, forKey: .removeEncryptionConfiguration)
        }
        if let removeExpectedBucketOwner = self.removeExpectedBucketOwner {
            try encodeContainer.encode(removeExpectedBucketOwner, forKey: .removeExpectedBucketOwner)
        }
        if let removeOutputLocation = self.removeOutputLocation {
            try encodeContainer.encode(removeOutputLocation, forKey: .removeOutputLocation)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let outputLocationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputLocation)
        outputLocation = outputLocationDecoded
        let removeOutputLocationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .removeOutputLocation)
        removeOutputLocation = removeOutputLocationDecoded
        let encryptionConfigurationDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.EncryptionConfiguration.self, forKey: .encryptionConfiguration)
        encryptionConfiguration = encryptionConfigurationDecoded
        let removeEncryptionConfigurationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .removeEncryptionConfiguration)
        removeEncryptionConfiguration = removeEncryptionConfigurationDecoded
        let expectedBucketOwnerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expectedBucketOwner)
        expectedBucketOwner = expectedBucketOwnerDecoded
        let removeExpectedBucketOwnerDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .removeExpectedBucketOwner)
        removeExpectedBucketOwner = removeExpectedBucketOwnerDecoded
        let aclConfigurationDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.AclConfiguration.self, forKey: .aclConfiguration)
        aclConfiguration = aclConfigurationDecoded
        let removeAclConfigurationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .removeAclConfiguration)
        removeAclConfiguration = removeAclConfigurationDecoded
    }
}

extension AthenaClientTypes {
    /// The information about the updates in the query results, such as output location and encryption configuration for the query results.
    public struct ResultConfigurationUpdates: Swift.Equatable {
        /// The ACL configuration for the query results.
        public var aclConfiguration: AthenaClientTypes.AclConfiguration?
        /// The encryption configuration for the query results.
        public var encryptionConfiguration: AthenaClientTypes.EncryptionConfiguration?
        /// The Amazon Web Services account ID that you expect to be the owner of the Amazon S3 bucket specified by [ResultConfiguration$OutputLocation]. If set, Athena uses the value for ExpectedBucketOwner when it makes Amazon S3 calls to your specified output location. If the ExpectedBucketOwner Amazon Web Services account ID does not match the actual owner of the Amazon S3 bucket, the call fails with a permissions error. If workgroup settings override client-side settings, then the query uses the ExpectedBucketOwner setting that is specified for the workgroup, and also uses the location for storing query results specified in the workgroup. See [WorkGroupConfiguration$EnforceWorkGroupConfiguration] and [Workgroup Settings Override Client-Side Settings](https://docs.aws.amazon.com/athena/latest/ug/workgroups-settings-override.html).
        public var expectedBucketOwner: Swift.String?
        /// The location in Amazon S3 where your query results are stored, such as s3://path/to/query/bucket/. For more information, see [Query Results](https://docs.aws.amazon.com/athena/latest/ug/querying.html) If workgroup settings override client-side settings, then the query uses the location for the query results and the encryption configuration that are specified for the workgroup. The "workgroup settings override" is specified in EnforceWorkGroupConfiguration (true/false) in the WorkGroupConfiguration. See [WorkGroupConfiguration$EnforceWorkGroupConfiguration].
        public var outputLocation: Swift.String?
        /// If set to true, indicates that the previously-specified ACL configuration for queries in this workgroup should be ignored and set to null. If set to false or not set, and a value is present in the AclConfiguration of ResultConfigurationUpdates, the AclConfiguration in the workgroup's ResultConfiguration is updated with the new value. For more information, see [Workgroup Settings Override Client-Side Settings](https://docs.aws.amazon.com/athena/latest/ug/workgroups-settings-override.html).
        public var removeAclConfiguration: Swift.Bool?
        /// If set to "true", indicates that the previously-specified encryption configuration (also known as the client-side setting) for queries in this workgroup should be ignored and set to null. If set to "false" or not set, and a value is present in the EncryptionConfiguration in ResultConfigurationUpdates (the client-side setting), the EncryptionConfiguration in the workgroup's ResultConfiguration will be updated with the new value. For more information, see [Workgroup Settings Override Client-Side Settings](https://docs.aws.amazon.com/athena/latest/ug/workgroups-settings-override.html).
        public var removeEncryptionConfiguration: Swift.Bool?
        /// If set to "true", removes the Amazon Web Services account ID previously specified for [ResultConfiguration$ExpectedBucketOwner]. If set to "false" or not set, and a value is present in the ExpectedBucketOwner in ResultConfigurationUpdates (the client-side setting), the ExpectedBucketOwner in the workgroup's ResultConfiguration is updated with the new value. For more information, see [Workgroup Settings Override Client-Side Settings](https://docs.aws.amazon.com/athena/latest/ug/workgroups-settings-override.html).
        public var removeExpectedBucketOwner: Swift.Bool?
        /// If set to "true", indicates that the previously-specified query results location (also known as a client-side setting) for queries in this workgroup should be ignored and set to null. If set to "false" or not set, and a value is present in the OutputLocation in ResultConfigurationUpdates (the client-side setting), the OutputLocation in the workgroup's ResultConfiguration will be updated with the new value. For more information, see [Workgroup Settings Override Client-Side Settings](https://docs.aws.amazon.com/athena/latest/ug/workgroups-settings-override.html).
        public var removeOutputLocation: Swift.Bool?

        public init (
            aclConfiguration: AthenaClientTypes.AclConfiguration? = nil,
            encryptionConfiguration: AthenaClientTypes.EncryptionConfiguration? = nil,
            expectedBucketOwner: Swift.String? = nil,
            outputLocation: Swift.String? = nil,
            removeAclConfiguration: Swift.Bool? = nil,
            removeEncryptionConfiguration: Swift.Bool? = nil,
            removeExpectedBucketOwner: Swift.Bool? = nil,
            removeOutputLocation: Swift.Bool? = nil
        )
        {
            self.aclConfiguration = aclConfiguration
            self.encryptionConfiguration = encryptionConfiguration
            self.expectedBucketOwner = expectedBucketOwner
            self.outputLocation = outputLocation
            self.removeAclConfiguration = removeAclConfiguration
            self.removeEncryptionConfiguration = removeEncryptionConfiguration
            self.removeExpectedBucketOwner = removeExpectedBucketOwner
            self.removeOutputLocation = removeOutputLocation
        }
    }

}

extension AthenaClientTypes.ResultReuseByAgeConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled = "Enabled"
        case maxAgeInMinutes = "MaxAgeInMinutes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let maxAgeInMinutes = self.maxAgeInMinutes {
            try encodeContainer.encode(maxAgeInMinutes, forKey: .maxAgeInMinutes)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled) ?? false
        enabled = enabledDecoded
        let maxAgeInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxAgeInMinutes)
        maxAgeInMinutes = maxAgeInMinutesDecoded
    }
}

extension AthenaClientTypes {
    /// Specifies whether previous query results are reused, and if so, their maximum age.
    public struct ResultReuseByAgeConfiguration: Swift.Equatable {
        /// True if previous query results can be reused when the query is run; otherwise, false. The default is false.
        /// This member is required.
        public var enabled: Swift.Bool
        /// Specifies, in minutes, the maximum age of a previous query result that Athena should consider for reuse. The default is 60.
        public var maxAgeInMinutes: Swift.Int?

        public init (
            enabled: Swift.Bool = false,
            maxAgeInMinutes: Swift.Int? = nil
        )
        {
            self.enabled = enabled
            self.maxAgeInMinutes = maxAgeInMinutes
        }
    }

}

extension AthenaClientTypes.ResultReuseConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resultReuseByAgeConfiguration = "ResultReuseByAgeConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resultReuseByAgeConfiguration = self.resultReuseByAgeConfiguration {
            try encodeContainer.encode(resultReuseByAgeConfiguration, forKey: .resultReuseByAgeConfiguration)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resultReuseByAgeConfigurationDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.ResultReuseByAgeConfiguration.self, forKey: .resultReuseByAgeConfiguration)
        resultReuseByAgeConfiguration = resultReuseByAgeConfigurationDecoded
    }
}

extension AthenaClientTypes {
    /// Specifies the query result reuse behavior for the query.
    public struct ResultReuseConfiguration: Swift.Equatable {
        /// Specifies whether previous query results are reused, and if so, their maximum age.
        public var resultReuseByAgeConfiguration: AthenaClientTypes.ResultReuseByAgeConfiguration?

        public init (
            resultReuseByAgeConfiguration: AthenaClientTypes.ResultReuseByAgeConfiguration? = nil
        )
        {
            self.resultReuseByAgeConfiguration = resultReuseByAgeConfiguration
        }
    }

}

extension AthenaClientTypes.ResultReuseInformation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reusedPreviousResult = "ReusedPreviousResult"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if reusedPreviousResult != false {
            try encodeContainer.encode(reusedPreviousResult, forKey: .reusedPreviousResult)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reusedPreviousResultDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .reusedPreviousResult) ?? false
        reusedPreviousResult = reusedPreviousResultDecoded
    }
}

extension AthenaClientTypes {
    /// Contains information about whether the result of a previous query was reused.
    public struct ResultReuseInformation: Swift.Equatable {
        /// True if a previous query result was reused; false if the result was generated from a new run of the query.
        /// This member is required.
        public var reusedPreviousResult: Swift.Bool

        public init (
            reusedPreviousResult: Swift.Bool = false
        )
        {
            self.reusedPreviousResult = reusedPreviousResult
        }
    }

}

extension AthenaClientTypes.ResultSet: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resultSetMetadata = "ResultSetMetadata"
        case rows = "Rows"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resultSetMetadata = self.resultSetMetadata {
            try encodeContainer.encode(resultSetMetadata, forKey: .resultSetMetadata)
        }
        if let rows = rows {
            var rowsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rows)
            for row0 in rows {
                try rowsContainer.encode(row0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rowsContainer = try containerValues.decodeIfPresent([AthenaClientTypes.Row?].self, forKey: .rows)
        var rowsDecoded0:[AthenaClientTypes.Row]? = nil
        if let rowsContainer = rowsContainer {
            rowsDecoded0 = [AthenaClientTypes.Row]()
            for structure0 in rowsContainer {
                if let structure0 = structure0 {
                    rowsDecoded0?.append(structure0)
                }
            }
        }
        rows = rowsDecoded0
        let resultSetMetadataDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.ResultSetMetadata.self, forKey: .resultSetMetadata)
        resultSetMetadata = resultSetMetadataDecoded
    }
}

extension AthenaClientTypes {
    /// The metadata and rows that make up a query result set. The metadata describes the column structure and data types. To return a ResultSet object, use [GetQueryResults].
    public struct ResultSet: Swift.Equatable {
        /// The metadata that describes the column structure and data types of a table of query results.
        public var resultSetMetadata: AthenaClientTypes.ResultSetMetadata?
        /// The rows in the table.
        public var rows: [AthenaClientTypes.Row]?

        public init (
            resultSetMetadata: AthenaClientTypes.ResultSetMetadata? = nil,
            rows: [AthenaClientTypes.Row]? = nil
        )
        {
            self.resultSetMetadata = resultSetMetadata
            self.rows = rows
        }
    }

}

extension AthenaClientTypes.ResultSetMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case columnInfo = "ColumnInfo"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let columnInfo = columnInfo {
            var columnInfoContainer = encodeContainer.nestedUnkeyedContainer(forKey: .columnInfo)
            for columninfo0 in columnInfo {
                try columnInfoContainer.encode(columninfo0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let columnInfoContainer = try containerValues.decodeIfPresent([AthenaClientTypes.ColumnInfo?].self, forKey: .columnInfo)
        var columnInfoDecoded0:[AthenaClientTypes.ColumnInfo]? = nil
        if let columnInfoContainer = columnInfoContainer {
            columnInfoDecoded0 = [AthenaClientTypes.ColumnInfo]()
            for structure0 in columnInfoContainer {
                if let structure0 = structure0 {
                    columnInfoDecoded0?.append(structure0)
                }
            }
        }
        columnInfo = columnInfoDecoded0
    }
}

extension AthenaClientTypes {
    /// The metadata that describes the column structure and data types of a table of query results. To return a ResultSetMetadata object, use [GetQueryResults].
    public struct ResultSetMetadata: Swift.Equatable {
        /// Information about the columns returned in a query result metadata.
        public var columnInfo: [AthenaClientTypes.ColumnInfo]?

        public init (
            columnInfo: [AthenaClientTypes.ColumnInfo]? = nil
        )
        {
            self.columnInfo = columnInfo
        }
    }

}

extension AthenaClientTypes.Row: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case data = "Data"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let data = data {
            var dataContainer = encodeContainer.nestedUnkeyedContainer(forKey: .data)
            for datum0 in data {
                try dataContainer.encode(datum0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataContainer = try containerValues.decodeIfPresent([AthenaClientTypes.Datum?].self, forKey: .data)
        var dataDecoded0:[AthenaClientTypes.Datum]? = nil
        if let dataContainer = dataContainer {
            dataDecoded0 = [AthenaClientTypes.Datum]()
            for structure0 in dataContainer {
                if let structure0 = structure0 {
                    dataDecoded0?.append(structure0)
                }
            }
        }
        data = dataDecoded0
    }
}

extension AthenaClientTypes {
    /// The rows that make up a query result table.
    public struct Row: Swift.Equatable {
        /// The data that populates a row in a query result table.
        public var data: [AthenaClientTypes.Datum]?

        public init (
            data: [AthenaClientTypes.Datum]? = nil
        )
        {
            self.data = data
        }
    }

}

extension AthenaClientTypes {
    public enum S3AclOption: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case bucketOwnerFullControl
        case sdkUnknown(Swift.String)

        public static var allCases: [S3AclOption] {
            return [
                .bucketOwnerFullControl,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .bucketOwnerFullControl: return "BUCKET_OWNER_FULL_CONTROL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = S3AclOption(rawValue: rawValue) ?? S3AclOption.sdkUnknown(rawValue)
        }
    }
}

extension SessionAlreadyExistsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: SessionAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified session already exists.
public struct SessionAlreadyExistsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct SessionAlreadyExistsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension SessionAlreadyExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AthenaClientTypes.SessionConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case encryptionConfiguration = "EncryptionConfiguration"
        case executionRole = "ExecutionRole"
        case idleTimeoutSeconds = "IdleTimeoutSeconds"
        case workingDirectory = "WorkingDirectory"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encryptionConfiguration = self.encryptionConfiguration {
            try encodeContainer.encode(encryptionConfiguration, forKey: .encryptionConfiguration)
        }
        if let executionRole = self.executionRole {
            try encodeContainer.encode(executionRole, forKey: .executionRole)
        }
        if let idleTimeoutSeconds = self.idleTimeoutSeconds {
            try encodeContainer.encode(idleTimeoutSeconds, forKey: .idleTimeoutSeconds)
        }
        if let workingDirectory = self.workingDirectory {
            try encodeContainer.encode(workingDirectory, forKey: .workingDirectory)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let executionRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionRole)
        executionRole = executionRoleDecoded
        let workingDirectoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workingDirectory)
        workingDirectory = workingDirectoryDecoded
        let idleTimeoutSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .idleTimeoutSeconds)
        idleTimeoutSeconds = idleTimeoutSecondsDecoded
        let encryptionConfigurationDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.EncryptionConfiguration.self, forKey: .encryptionConfiguration)
        encryptionConfiguration = encryptionConfigurationDecoded
    }
}

extension AthenaClientTypes {
    /// Contains session configuration information.
    public struct SessionConfiguration: Swift.Equatable {
        /// If query results are encrypted in Amazon S3, indicates the encryption option used (for example, SSE_KMS or CSE_KMS) and key information.
        public var encryptionConfiguration: AthenaClientTypes.EncryptionConfiguration?
        /// The ARN of the execution role used for the session.
        public var executionRole: Swift.String?
        /// The idle timeout in seconds for the session.
        public var idleTimeoutSeconds: Swift.Int?
        /// The Amazon S3 location that stores information for the notebook.
        public var workingDirectory: Swift.String?

        public init (
            encryptionConfiguration: AthenaClientTypes.EncryptionConfiguration? = nil,
            executionRole: Swift.String? = nil,
            idleTimeoutSeconds: Swift.Int? = nil,
            workingDirectory: Swift.String? = nil
        )
        {
            self.encryptionConfiguration = encryptionConfiguration
            self.executionRole = executionRole
            self.idleTimeoutSeconds = idleTimeoutSeconds
            self.workingDirectory = workingDirectory
        }
    }

}

extension AthenaClientTypes {
    public enum SessionState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case busy
        case created
        case creating
        case degraded
        case failed
        case idle
        case terminated
        case terminating
        case sdkUnknown(Swift.String)

        public static var allCases: [SessionState] {
            return [
                .busy,
                .created,
                .creating,
                .degraded,
                .failed,
                .idle,
                .terminated,
                .terminating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .busy: return "BUSY"
            case .created: return "CREATED"
            case .creating: return "CREATING"
            case .degraded: return "DEGRADED"
            case .failed: return "FAILED"
            case .idle: return "IDLE"
            case .terminated: return "TERMINATED"
            case .terminating: return "TERMINATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SessionState(rawValue: rawValue) ?? SessionState.sdkUnknown(rawValue)
        }
    }
}

extension AthenaClientTypes.SessionStatistics: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dpuExecutionInMillis = "DpuExecutionInMillis"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dpuExecutionInMillis = self.dpuExecutionInMillis {
            try encodeContainer.encode(dpuExecutionInMillis, forKey: .dpuExecutionInMillis)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dpuExecutionInMillisDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .dpuExecutionInMillis)
        dpuExecutionInMillis = dpuExecutionInMillisDecoded
    }
}

extension AthenaClientTypes {
    /// Contains statistics for a notebook session.
    public struct SessionStatistics: Swift.Equatable {
        /// The data processing unit execution time for a session in milliseconds.
        public var dpuExecutionInMillis: Swift.Int?

        public init (
            dpuExecutionInMillis: Swift.Int? = nil
        )
        {
            self.dpuExecutionInMillis = dpuExecutionInMillis
        }
    }

}

extension AthenaClientTypes.SessionStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endDateTime = "EndDateTime"
        case idleSinceDateTime = "IdleSinceDateTime"
        case lastModifiedDateTime = "LastModifiedDateTime"
        case startDateTime = "StartDateTime"
        case state = "State"
        case stateChangeReason = "StateChangeReason"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endDateTime = self.endDateTime {
            try encodeContainer.encodeTimestamp(endDateTime, format: .epochSeconds, forKey: .endDateTime)
        }
        if let idleSinceDateTime = self.idleSinceDateTime {
            try encodeContainer.encodeTimestamp(idleSinceDateTime, format: .epochSeconds, forKey: .idleSinceDateTime)
        }
        if let lastModifiedDateTime = self.lastModifiedDateTime {
            try encodeContainer.encodeTimestamp(lastModifiedDateTime, format: .epochSeconds, forKey: .lastModifiedDateTime)
        }
        if let startDateTime = self.startDateTime {
            try encodeContainer.encodeTimestamp(startDateTime, format: .epochSeconds, forKey: .startDateTime)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let stateChangeReason = self.stateChangeReason {
            try encodeContainer.encode(stateChangeReason, forKey: .stateChangeReason)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startDateTime)
        startDateTime = startDateTimeDecoded
        let lastModifiedDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedDateTime)
        lastModifiedDateTime = lastModifiedDateTimeDecoded
        let endDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endDateTime)
        endDateTime = endDateTimeDecoded
        let idleSinceDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .idleSinceDateTime)
        idleSinceDateTime = idleSinceDateTimeDecoded
        let stateDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.SessionState.self, forKey: .state)
        state = stateDecoded
        let stateChangeReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stateChangeReason)
        stateChangeReason = stateChangeReasonDecoded
    }
}

extension AthenaClientTypes {
    /// Contains information about the status of a notebook session.
    public struct SessionStatus: Swift.Equatable {
        /// The date and time that the session ended.
        public var endDateTime: ClientRuntime.Date?
        /// The date and time starting at which the session became idle. Can be empty if the session is not currently idle.
        public var idleSinceDateTime: ClientRuntime.Date?
        /// The most recent date and time that the session was modified.
        public var lastModifiedDateTime: ClientRuntime.Date?
        /// The date and time that the session started.
        public var startDateTime: ClientRuntime.Date?
        /// The state of the session. A description of each state follows. CREATING - The session is being started, including acquiring resources. CREATED - The session has been started. IDLE - The session is able to accept a calculation. BUSY - The session is processing another task and is unable to accept a calculation. TERMINATING - The session is in the process of shutting down. TERMINATED - The session and its resources are no longer running. DEGRADED - The session has no healthy coordinators. FAILED - Due to a failure, the session and its resources are no longer running.
        public var state: AthenaClientTypes.SessionState?
        /// The reason for the session state change (for example, canceled because the session was terminated).
        public var stateChangeReason: Swift.String?

        public init (
            endDateTime: ClientRuntime.Date? = nil,
            idleSinceDateTime: ClientRuntime.Date? = nil,
            lastModifiedDateTime: ClientRuntime.Date? = nil,
            startDateTime: ClientRuntime.Date? = nil,
            state: AthenaClientTypes.SessionState? = nil,
            stateChangeReason: Swift.String? = nil
        )
        {
            self.endDateTime = endDateTime
            self.idleSinceDateTime = idleSinceDateTime
            self.lastModifiedDateTime = lastModifiedDateTime
            self.startDateTime = startDateTime
            self.state = state
            self.stateChangeReason = stateChangeReason
        }
    }

}

extension AthenaClientTypes.SessionSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case engineVersion = "EngineVersion"
        case notebookVersion = "NotebookVersion"
        case sessionId = "SessionId"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let engineVersion = self.engineVersion {
            try encodeContainer.encode(engineVersion, forKey: .engineVersion)
        }
        if let notebookVersion = self.notebookVersion {
            try encodeContainer.encode(notebookVersion, forKey: .notebookVersion)
        }
        if let sessionId = self.sessionId {
            try encodeContainer.encode(sessionId, forKey: .sessionId)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionId)
        sessionId = sessionIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.EngineVersion.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let notebookVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .notebookVersion)
        notebookVersion = notebookVersionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.SessionStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension AthenaClientTypes {
    /// Contains summary information about a notebook session.
    public struct SessionSummary: Swift.Equatable {
        /// The session description.
        public var description: Swift.String?
        /// The engine version used by the session (for example, PySpark engine version 3).
        public var engineVersion: AthenaClientTypes.EngineVersion?
        /// The notebook version.
        public var notebookVersion: Swift.String?
        /// The session ID.
        public var sessionId: Swift.String?
        /// Contains information about the session status.
        public var status: AthenaClientTypes.SessionStatus?

        public init (
            description: Swift.String? = nil,
            engineVersion: AthenaClientTypes.EngineVersion? = nil,
            notebookVersion: Swift.String? = nil,
            sessionId: Swift.String? = nil,
            status: AthenaClientTypes.SessionStatus? = nil
        )
        {
            self.description = description
            self.engineVersion = engineVersion
            self.notebookVersion = notebookVersion
            self.sessionId = sessionId
            self.status = status
        }
    }

}

extension StartCalculationExecutionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case calculationConfiguration = "CalculationConfiguration"
        case clientRequestToken = "ClientRequestToken"
        case codeBlock = "CodeBlock"
        case description = "Description"
        case sessionId = "SessionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let calculationConfiguration = self.calculationConfiguration {
            try encodeContainer.encode(calculationConfiguration, forKey: .calculationConfiguration)
        }
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let codeBlock = self.codeBlock {
            try encodeContainer.encode(codeBlock, forKey: .codeBlock)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let sessionId = self.sessionId {
            try encodeContainer.encode(sessionId, forKey: .sessionId)
        }
    }
}

extension StartCalculationExecutionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StartCalculationExecutionInput: Swift.Equatable {
    /// Contains configuration information for the calculation.
    @available(*, deprecated, message: "Kepler Post GA Tasks : https://sim.amazon.com/issues/ATHENA-39828")
    public var calculationConfiguration: AthenaClientTypes.CalculationConfiguration?
    /// A unique case-sensitive string used to ensure the request to create the calculation is idempotent (executes only once). If another StartCalculationExecutionRequest is received, the same response is returned and another calculation is not created. If a parameter has changed, an error is returned. This token is listed as not required because Amazon Web Services SDKs (for example the Amazon Web Services SDK for Java) auto-generate the token for users. If you are not using the Amazon Web Services SDK or the Amazon Web Services CLI, you must provide this token or the action will fail.
    public var clientRequestToken: Swift.String?
    /// A string that contains the code of the calculation.
    public var codeBlock: Swift.String?
    /// A description of the calculation.
    public var description: Swift.String?
    /// The session ID.
    /// This member is required.
    public var sessionId: Swift.String?

    public init (
        calculationConfiguration: AthenaClientTypes.CalculationConfiguration? = nil,
        clientRequestToken: Swift.String? = nil,
        codeBlock: Swift.String? = nil,
        description: Swift.String? = nil,
        sessionId: Swift.String? = nil
    )
    {
        self.calculationConfiguration = calculationConfiguration
        self.clientRequestToken = clientRequestToken
        self.codeBlock = codeBlock
        self.description = description
        self.sessionId = sessionId
    }
}

struct StartCalculationExecutionInputBody: Swift.Equatable {
    let sessionId: Swift.String?
    let description: Swift.String?
    let calculationConfiguration: AthenaClientTypes.CalculationConfiguration?
    let codeBlock: Swift.String?
    let clientRequestToken: Swift.String?
}

extension StartCalculationExecutionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case calculationConfiguration = "CalculationConfiguration"
        case clientRequestToken = "ClientRequestToken"
        case codeBlock = "CodeBlock"
        case description = "Description"
        case sessionId = "SessionId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionId)
        sessionId = sessionIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let calculationConfigurationDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.CalculationConfiguration.self, forKey: .calculationConfiguration)
        calculationConfiguration = calculationConfigurationDecoded
        let codeBlockDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .codeBlock)
        codeBlock = codeBlockDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
    }
}

extension StartCalculationExecutionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartCalculationExecutionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum StartCalculationExecutionOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartCalculationExecutionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: StartCalculationExecutionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.calculationExecutionId = output.calculationExecutionId
            self.state = output.state
        } else {
            self.calculationExecutionId = nil
            self.state = nil
        }
    }
}

public struct StartCalculationExecutionOutputResponse: Swift.Equatable {
    /// The calculation execution UUID.
    public var calculationExecutionId: Swift.String?
    /// CREATING - The calculation is in the process of being created. CREATED - The calculation has been created and is ready to run. QUEUED - The calculation has been queued for processing. RUNNING - The calculation is running. CANCELING - A request to cancel the calculation has been received and the system is working to stop it. CANCELED - The calculation is no longer running as the result of a cancel request. COMPLETED - The calculation has completed without error. FAILED - The calculation failed and is no longer running.
    public var state: AthenaClientTypes.CalculationExecutionState?

    public init (
        calculationExecutionId: Swift.String? = nil,
        state: AthenaClientTypes.CalculationExecutionState? = nil
    )
    {
        self.calculationExecutionId = calculationExecutionId
        self.state = state
    }
}

struct StartCalculationExecutionOutputResponseBody: Swift.Equatable {
    let calculationExecutionId: Swift.String?
    let state: AthenaClientTypes.CalculationExecutionState?
}

extension StartCalculationExecutionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case calculationExecutionId = "CalculationExecutionId"
        case state = "State"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let calculationExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .calculationExecutionId)
        calculationExecutionId = calculationExecutionIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.CalculationExecutionState.self, forKey: .state)
        state = stateDecoded
    }
}

extension StartQueryExecutionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case executionParameters = "ExecutionParameters"
        case queryExecutionContext = "QueryExecutionContext"
        case queryString = "QueryString"
        case resultConfiguration = "ResultConfiguration"
        case resultReuseConfiguration = "ResultReuseConfiguration"
        case workGroup = "WorkGroup"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let executionParameters = executionParameters {
            var executionParametersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .executionParameters)
            for executionparameter0 in executionParameters {
                try executionParametersContainer.encode(executionparameter0)
            }
        }
        if let queryExecutionContext = self.queryExecutionContext {
            try encodeContainer.encode(queryExecutionContext, forKey: .queryExecutionContext)
        }
        if let queryString = self.queryString {
            try encodeContainer.encode(queryString, forKey: .queryString)
        }
        if let resultConfiguration = self.resultConfiguration {
            try encodeContainer.encode(resultConfiguration, forKey: .resultConfiguration)
        }
        if let resultReuseConfiguration = self.resultReuseConfiguration {
            try encodeContainer.encode(resultReuseConfiguration, forKey: .resultReuseConfiguration)
        }
        if let workGroup = self.workGroup {
            try encodeContainer.encode(workGroup, forKey: .workGroup)
        }
    }
}

extension StartQueryExecutionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StartQueryExecutionInput: Swift.Equatable {
    /// A unique case-sensitive string used to ensure the request to create the query is idempotent (executes only once). If another StartQueryExecution request is received, the same response is returned and another query is not created. If a parameter has changed, for example, the QueryString, an error is returned. This token is listed as not required because Amazon Web Services SDKs (for example the Amazon Web Services SDK for Java) auto-generate the token for users. If you are not using the Amazon Web Services SDK or the Amazon Web Services CLI, you must provide this token or the action will fail.
    public var clientRequestToken: Swift.String?
    /// A list of values for the parameters in a query. The values are applied sequentially to the parameters in the query in the order in which the parameters occur.
    public var executionParameters: [Swift.String]?
    /// The database within which the query executes.
    public var queryExecutionContext: AthenaClientTypes.QueryExecutionContext?
    /// The SQL query statements to be executed.
    /// This member is required.
    public var queryString: Swift.String?
    /// Specifies information about where and how to save the results of the query execution. If the query runs in a workgroup, then workgroup's settings may override query settings. This affects the query results location. The workgroup settings override is specified in EnforceWorkGroupConfiguration (true/false) in the WorkGroupConfiguration. See [WorkGroupConfiguration$EnforceWorkGroupConfiguration].
    public var resultConfiguration: AthenaClientTypes.ResultConfiguration?
    /// Specifies the query result reuse behavior for the query.
    public var resultReuseConfiguration: AthenaClientTypes.ResultReuseConfiguration?
    /// The name of the workgroup in which the query is being started.
    public var workGroup: Swift.String?

    public init (
        clientRequestToken: Swift.String? = nil,
        executionParameters: [Swift.String]? = nil,
        queryExecutionContext: AthenaClientTypes.QueryExecutionContext? = nil,
        queryString: Swift.String? = nil,
        resultConfiguration: AthenaClientTypes.ResultConfiguration? = nil,
        resultReuseConfiguration: AthenaClientTypes.ResultReuseConfiguration? = nil,
        workGroup: Swift.String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.executionParameters = executionParameters
        self.queryExecutionContext = queryExecutionContext
        self.queryString = queryString
        self.resultConfiguration = resultConfiguration
        self.resultReuseConfiguration = resultReuseConfiguration
        self.workGroup = workGroup
    }
}

struct StartQueryExecutionInputBody: Swift.Equatable {
    let queryString: Swift.String?
    let clientRequestToken: Swift.String?
    let queryExecutionContext: AthenaClientTypes.QueryExecutionContext?
    let resultConfiguration: AthenaClientTypes.ResultConfiguration?
    let workGroup: Swift.String?
    let executionParameters: [Swift.String]?
    let resultReuseConfiguration: AthenaClientTypes.ResultReuseConfiguration?
}

extension StartQueryExecutionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case executionParameters = "ExecutionParameters"
        case queryExecutionContext = "QueryExecutionContext"
        case queryString = "QueryString"
        case resultConfiguration = "ResultConfiguration"
        case resultReuseConfiguration = "ResultReuseConfiguration"
        case workGroup = "WorkGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryStringDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryString)
        queryString = queryStringDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let queryExecutionContextDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.QueryExecutionContext.self, forKey: .queryExecutionContext)
        queryExecutionContext = queryExecutionContextDecoded
        let resultConfigurationDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.ResultConfiguration.self, forKey: .resultConfiguration)
        resultConfiguration = resultConfigurationDecoded
        let workGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workGroup)
        workGroup = workGroupDecoded
        let executionParametersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .executionParameters)
        var executionParametersDecoded0:[Swift.String]? = nil
        if let executionParametersContainer = executionParametersContainer {
            executionParametersDecoded0 = [Swift.String]()
            for string0 in executionParametersContainer {
                if let string0 = string0 {
                    executionParametersDecoded0?.append(string0)
                }
            }
        }
        executionParameters = executionParametersDecoded0
        let resultReuseConfigurationDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.ResultReuseConfiguration.self, forKey: .resultReuseConfiguration)
        resultReuseConfiguration = resultReuseConfigurationDecoded
    }
}

extension StartQueryExecutionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartQueryExecutionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum StartQueryExecutionOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartQueryExecutionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: StartQueryExecutionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.queryExecutionId = output.queryExecutionId
        } else {
            self.queryExecutionId = nil
        }
    }
}

public struct StartQueryExecutionOutputResponse: Swift.Equatable {
    /// The unique ID of the query that ran as a result of this request.
    public var queryExecutionId: Swift.String?

    public init (
        queryExecutionId: Swift.String? = nil
    )
    {
        self.queryExecutionId = queryExecutionId
    }
}

struct StartQueryExecutionOutputResponseBody: Swift.Equatable {
    let queryExecutionId: Swift.String?
}

extension StartQueryExecutionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case queryExecutionId = "QueryExecutionId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryExecutionId)
        queryExecutionId = queryExecutionIdDecoded
    }
}

extension StartSessionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case description = "Description"
        case engineConfiguration = "EngineConfiguration"
        case notebookVersion = "NotebookVersion"
        case sessionIdleTimeoutInMinutes = "SessionIdleTimeoutInMinutes"
        case workGroup = "WorkGroup"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let engineConfiguration = self.engineConfiguration {
            try encodeContainer.encode(engineConfiguration, forKey: .engineConfiguration)
        }
        if let notebookVersion = self.notebookVersion {
            try encodeContainer.encode(notebookVersion, forKey: .notebookVersion)
        }
        if let sessionIdleTimeoutInMinutes = self.sessionIdleTimeoutInMinutes {
            try encodeContainer.encode(sessionIdleTimeoutInMinutes, forKey: .sessionIdleTimeoutInMinutes)
        }
        if let workGroup = self.workGroup {
            try encodeContainer.encode(workGroup, forKey: .workGroup)
        }
    }
}

extension StartSessionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StartSessionInput: Swift.Equatable {
    /// A unique case-sensitive string used to ensure the request to create the session is idempotent (executes only once). If another StartSessionRequest is received, the same response is returned and another session is not created. If a parameter has changed, an error is returned. This token is listed as not required because Amazon Web Services SDKs (for example the Amazon Web Services SDK for Java) auto-generate the token for users. If you are not using the Amazon Web Services SDK or the Amazon Web Services CLI, you must provide this token or the action will fail.
    public var clientRequestToken: Swift.String?
    /// The session description.
    public var description: Swift.String?
    /// Contains engine data processing unit (DPU) configuration settings and parameter mappings.
    /// This member is required.
    public var engineConfiguration: AthenaClientTypes.EngineConfiguration?
    /// The notebook version. This value is required only when requesting that a notebook server be started for the session. The only valid notebook version is Jupyter1.0.
    public var notebookVersion: Swift.String?
    /// The idle timeout in minutes for the session.
    public var sessionIdleTimeoutInMinutes: Swift.Int?
    /// The workgroup to which the session belongs.
    /// This member is required.
    public var workGroup: Swift.String?

    public init (
        clientRequestToken: Swift.String? = nil,
        description: Swift.String? = nil,
        engineConfiguration: AthenaClientTypes.EngineConfiguration? = nil,
        notebookVersion: Swift.String? = nil,
        sessionIdleTimeoutInMinutes: Swift.Int? = nil,
        workGroup: Swift.String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.description = description
        self.engineConfiguration = engineConfiguration
        self.notebookVersion = notebookVersion
        self.sessionIdleTimeoutInMinutes = sessionIdleTimeoutInMinutes
        self.workGroup = workGroup
    }
}

struct StartSessionInputBody: Swift.Equatable {
    let description: Swift.String?
    let workGroup: Swift.String?
    let engineConfiguration: AthenaClientTypes.EngineConfiguration?
    let notebookVersion: Swift.String?
    let sessionIdleTimeoutInMinutes: Swift.Int?
    let clientRequestToken: Swift.String?
}

extension StartSessionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case description = "Description"
        case engineConfiguration = "EngineConfiguration"
        case notebookVersion = "NotebookVersion"
        case sessionIdleTimeoutInMinutes = "SessionIdleTimeoutInMinutes"
        case workGroup = "WorkGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let workGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workGroup)
        workGroup = workGroupDecoded
        let engineConfigurationDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.EngineConfiguration.self, forKey: .engineConfiguration)
        engineConfiguration = engineConfigurationDecoded
        let notebookVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .notebookVersion)
        notebookVersion = notebookVersionDecoded
        let sessionIdleTimeoutInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .sessionIdleTimeoutInMinutes)
        sessionIdleTimeoutInMinutes = sessionIdleTimeoutInMinutesDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
    }
}

extension StartSessionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartSessionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SessionAlreadyExistsException" : self = .sessionAlreadyExistsException(try SessionAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum StartSessionOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case sessionAlreadyExistsException(SessionAlreadyExistsException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartSessionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: StartSessionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.sessionId = output.sessionId
            self.state = output.state
        } else {
            self.sessionId = nil
            self.state = nil
        }
    }
}

public struct StartSessionOutputResponse: Swift.Equatable {
    /// The session ID.
    public var sessionId: Swift.String?
    /// The state of the session. A description of each state follows. CREATING - The session is being started, including acquiring resources. CREATED - The session has been started. IDLE - The session is able to accept a calculation. BUSY - The session is processing another task and is unable to accept a calculation. TERMINATING - The session is in the process of shutting down. TERMINATED - The session and its resources are no longer running. DEGRADED - The session has no healthy coordinators. FAILED - Due to a failure, the session and its resources are no longer running.
    public var state: AthenaClientTypes.SessionState?

    public init (
        sessionId: Swift.String? = nil,
        state: AthenaClientTypes.SessionState? = nil
    )
    {
        self.sessionId = sessionId
        self.state = state
    }
}

struct StartSessionOutputResponseBody: Swift.Equatable {
    let sessionId: Swift.String?
    let state: AthenaClientTypes.SessionState?
}

extension StartSessionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sessionId = "SessionId"
        case state = "State"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionId)
        sessionId = sessionIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.SessionState.self, forKey: .state)
        state = stateDecoded
    }
}

extension AthenaClientTypes {
    public enum StatementType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ddl
        case dml
        case utility
        case sdkUnknown(Swift.String)

        public static var allCases: [StatementType] {
            return [
                .ddl,
                .dml,
                .utility,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ddl: return "DDL"
            case .dml: return "DML"
            case .utility: return "UTILITY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StatementType(rawValue: rawValue) ?? StatementType.sdkUnknown(rawValue)
        }
    }
}

extension StopCalculationExecutionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case calculationExecutionId = "CalculationExecutionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let calculationExecutionId = self.calculationExecutionId {
            try encodeContainer.encode(calculationExecutionId, forKey: .calculationExecutionId)
        }
    }
}

extension StopCalculationExecutionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StopCalculationExecutionInput: Swift.Equatable {
    /// The calculation execution UUID.
    /// This member is required.
    public var calculationExecutionId: Swift.String?

    public init (
        calculationExecutionId: Swift.String? = nil
    )
    {
        self.calculationExecutionId = calculationExecutionId
    }
}

struct StopCalculationExecutionInputBody: Swift.Equatable {
    let calculationExecutionId: Swift.String?
}

extension StopCalculationExecutionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case calculationExecutionId = "CalculationExecutionId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let calculationExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .calculationExecutionId)
        calculationExecutionId = calculationExecutionIdDecoded
    }
}

extension StopCalculationExecutionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopCalculationExecutionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum StopCalculationExecutionOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopCalculationExecutionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: StopCalculationExecutionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.state = output.state
        } else {
            self.state = nil
        }
    }
}

public struct StopCalculationExecutionOutputResponse: Swift.Equatable {
    /// CREATING - The calculation is in the process of being created. CREATED - The calculation has been created and is ready to run. QUEUED - The calculation has been queued for processing. RUNNING - The calculation is running. CANCELING - A request to cancel the calculation has been received and the system is working to stop it. CANCELED - The calculation is no longer running as the result of a cancel request. COMPLETED - The calculation has completed without error. FAILED - The calculation failed and is no longer running.
    public var state: AthenaClientTypes.CalculationExecutionState?

    public init (
        state: AthenaClientTypes.CalculationExecutionState? = nil
    )
    {
        self.state = state
    }
}

struct StopCalculationExecutionOutputResponseBody: Swift.Equatable {
    let state: AthenaClientTypes.CalculationExecutionState?
}

extension StopCalculationExecutionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case state = "State"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.CalculationExecutionState.self, forKey: .state)
        state = stateDecoded
    }
}

extension StopQueryExecutionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case queryExecutionId = "QueryExecutionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let queryExecutionId = self.queryExecutionId {
            try encodeContainer.encode(queryExecutionId, forKey: .queryExecutionId)
        }
    }
}

extension StopQueryExecutionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StopQueryExecutionInput: Swift.Equatable {
    /// The unique ID of the query execution to stop.
    /// This member is required.
    public var queryExecutionId: Swift.String?

    public init (
        queryExecutionId: Swift.String? = nil
    )
    {
        self.queryExecutionId = queryExecutionId
    }
}

struct StopQueryExecutionInputBody: Swift.Equatable {
    let queryExecutionId: Swift.String?
}

extension StopQueryExecutionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case queryExecutionId = "QueryExecutionId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryExecutionId)
        queryExecutionId = queryExecutionIdDecoded
    }
}

extension StopQueryExecutionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopQueryExecutionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum StopQueryExecutionOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopQueryExecutionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct StopQueryExecutionOutputResponse: Swift.Equatable {

    public init () { }
}

extension AthenaClientTypes.TableMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case columns = "Columns"
        case createTime = "CreateTime"
        case lastAccessTime = "LastAccessTime"
        case name = "Name"
        case parameters = "Parameters"
        case partitionKeys = "PartitionKeys"
        case tableType = "TableType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let columns = columns {
            var columnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .columns)
            for column0 in columns {
                try columnsContainer.encode(column0)
            }
        }
        if let createTime = self.createTime {
            try encodeContainer.encodeTimestamp(createTime, format: .epochSeconds, forKey: .createTime)
        }
        if let lastAccessTime = self.lastAccessTime {
            try encodeContainer.encodeTimestamp(lastAccessTime, format: .epochSeconds, forKey: .lastAccessTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .parameters)
            for (dictKey0, parametersMap0) in parameters {
                try parametersContainer.encode(parametersMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let partitionKeys = partitionKeys {
            var partitionKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .partitionKeys)
            for column0 in partitionKeys {
                try partitionKeysContainer.encode(column0)
            }
        }
        if let tableType = self.tableType {
            try encodeContainer.encode(tableType, forKey: .tableType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createTime)
        createTime = createTimeDecoded
        let lastAccessTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastAccessTime)
        lastAccessTime = lastAccessTimeDecoded
        let tableTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tableType)
        tableType = tableTypeDecoded
        let columnsContainer = try containerValues.decodeIfPresent([AthenaClientTypes.Column?].self, forKey: .columns)
        var columnsDecoded0:[AthenaClientTypes.Column]? = nil
        if let columnsContainer = columnsContainer {
            columnsDecoded0 = [AthenaClientTypes.Column]()
            for structure0 in columnsContainer {
                if let structure0 = structure0 {
                    columnsDecoded0?.append(structure0)
                }
            }
        }
        columns = columnsDecoded0
        let partitionKeysContainer = try containerValues.decodeIfPresent([AthenaClientTypes.Column?].self, forKey: .partitionKeys)
        var partitionKeysDecoded0:[AthenaClientTypes.Column]? = nil
        if let partitionKeysContainer = partitionKeysContainer {
            partitionKeysDecoded0 = [AthenaClientTypes.Column]()
            for structure0 in partitionKeysContainer {
                if let structure0 = structure0 {
                    partitionKeysDecoded0?.append(structure0)
                }
            }
        }
        partitionKeys = partitionKeysDecoded0
        let parametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .parameters)
        var parametersDecoded0: [Swift.String:Swift.String]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, parametersmapvalue0) in parametersContainer {
                if let parametersmapvalue0 = parametersmapvalue0 {
                    parametersDecoded0?[key0] = parametersmapvalue0
                }
            }
        }
        parameters = parametersDecoded0
    }
}

extension AthenaClientTypes {
    /// Contains metadata for a table.
    public struct TableMetadata: Swift.Equatable {
        /// A list of the columns in the table.
        public var columns: [AthenaClientTypes.Column]?
        /// The time that the table was created.
        public var createTime: ClientRuntime.Date?
        /// The last time the table was accessed.
        public var lastAccessTime: ClientRuntime.Date?
        /// The name of the table.
        /// This member is required.
        public var name: Swift.String?
        /// A set of custom key/value pairs for table properties.
        public var parameters: [Swift.String:Swift.String]?
        /// A list of the partition keys in the table.
        public var partitionKeys: [AthenaClientTypes.Column]?
        /// The type of table. In Athena, only EXTERNAL_TABLE is supported.
        public var tableType: Swift.String?

        public init (
            columns: [AthenaClientTypes.Column]? = nil,
            createTime: ClientRuntime.Date? = nil,
            lastAccessTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            parameters: [Swift.String:Swift.String]? = nil,
            partitionKeys: [AthenaClientTypes.Column]? = nil,
            tableType: Swift.String? = nil
        )
        {
            self.columns = columns
            self.createTime = createTime
            self.lastAccessTime = lastAccessTime
            self.name = name
            self.parameters = parameters
            self.partitionKeys = partitionKeys
            self.tableType = tableType
        }
    }

}

extension AthenaClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension AthenaClientTypes {
    /// A label that you assign to a resource. In Athena, a resource can be a workgroup or data catalog. Each tag consists of a key and an optional value, both of which you define. For example, you can use tags to categorize Athena workgroups or data catalogs by purpose, owner, or environment. Use a consistent set of tag keys to make it easier to search and filter workgroups or data catalogs in your account. For best practices, see [Tagging Best Practices](https://aws.amazon.com/answers/account-management/aws-tagging-strategies/). Tag keys can be from 1 to 128 UTF-8 Unicode characters, and tag values can be from 0 to 256 UTF-8 Unicode characters. Tags can use letters and numbers representable in UTF-8, and the following characters: + - = . _ : / @. Tag keys and values are case-sensitive. Tag keys must be unique per resource. If you specify more than one tag, separate them by commas.
    public struct Tag: Swift.Equatable {
        /// A tag key. The tag key length is from 1 to 128 Unicode characters in UTF-8. You can use letters and numbers representable in UTF-8, and the following characters: + - = . _ : / @. Tag keys are case-sensitive and must be unique per resource.
        public var key: Swift.String?
        /// A tag value. The tag value length is from 0 to 256 Unicode characters in UTF-8. You can use letters and numbers representable in UTF-8, and the following characters: + - = . _ : / @. Tag values are case-sensitive.
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// Specifies the ARN of the Athena resource (workgroup or data catalog) to which tags are to be added.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// A collection of one or more tags, separated by commas, to be added to an Athena workgroup or data catalog resource.
    /// This member is required.
    public var tags: [AthenaClientTypes.Tag]?

    public init (
        resourceARN: Swift.String? = nil,
        tags: [AthenaClientTypes.Tag]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let resourceARN: Swift.String?
    let tags: [AthenaClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagsContainer = try containerValues.decodeIfPresent([AthenaClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[AthenaClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [AthenaClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension TerminateSessionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sessionId = "SessionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sessionId = self.sessionId {
            try encodeContainer.encode(sessionId, forKey: .sessionId)
        }
    }
}

extension TerminateSessionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct TerminateSessionInput: Swift.Equatable {
    /// The session ID.
    /// This member is required.
    public var sessionId: Swift.String?

    public init (
        sessionId: Swift.String? = nil
    )
    {
        self.sessionId = sessionId
    }
}

struct TerminateSessionInputBody: Swift.Equatable {
    let sessionId: Swift.String?
}

extension TerminateSessionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sessionId = "SessionId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionId)
        sessionId = sessionIdDecoded
    }
}

extension TerminateSessionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TerminateSessionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum TerminateSessionOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TerminateSessionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: TerminateSessionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.state = output.state
        } else {
            self.state = nil
        }
    }
}

public struct TerminateSessionOutputResponse: Swift.Equatable {
    /// The state of the session. A description of each state follows. CREATING - The session is being started, including acquiring resources. CREATED - The session has been started. IDLE - The session is able to accept a calculation. BUSY - The session is processing another task and is unable to accept a calculation. TERMINATING - The session is in the process of shutting down. TERMINATED - The session and its resources are no longer running. DEGRADED - The session has no healthy coordinators. FAILED - Due to a failure, the session and its resources are no longer running.
    public var state: AthenaClientTypes.SessionState?

    public init (
        state: AthenaClientTypes.SessionState? = nil
    )
    {
        self.state = state
    }
}

struct TerminateSessionOutputResponseBody: Swift.Equatable {
    let state: AthenaClientTypes.SessionState?
}

extension TerminateSessionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case state = "State"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.SessionState.self, forKey: .state)
        state = stateDecoded
    }
}

extension AthenaClientTypes {
    /// The reason for the query throttling, for example, when it exceeds the concurrent query limit.
    public enum ThrottleReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case concurrentQueryLimitExceeded
        case sdkUnknown(Swift.String)

        public static var allCases: [ThrottleReason] {
            return [
                .concurrentQueryLimitExceeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .concurrentQueryLimitExceeded: return "CONCURRENT_QUERY_LIMIT_EXCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ThrottleReason(rawValue: rawValue) ?? ThrottleReason.sdkUnknown(rawValue)
        }
    }
}

extension TooManyRequestsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: TooManyRequestsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.reason = output.reason
        } else {
            self.message = nil
            self.reason = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Indicates that the request was throttled.
public struct TooManyRequestsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    /// The reason for the query throttling, for example, when it exceeds the concurrent query limit.
    public var reason: AthenaClientTypes.ThrottleReason?

    public init (
        message: Swift.String? = nil,
        reason: AthenaClientTypes.ThrottleReason? = nil
    )
    {
        self.message = message
        self.reason = reason
    }
}

struct TooManyRequestsExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let reason: AthenaClientTypes.ThrottleReason?
}

extension TooManyRequestsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case reason = "Reason"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.ThrottleReason.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension AthenaClientTypes.UnprocessedNamedQueryId: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
        case namedQueryId = "NamedQueryId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let namedQueryId = self.namedQueryId {
            try encodeContainer.encode(namedQueryId, forKey: .namedQueryId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namedQueryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namedQueryId)
        namedQueryId = namedQueryIdDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension AthenaClientTypes {
    /// Information about a named query ID that could not be processed.
    public struct UnprocessedNamedQueryId: Swift.Equatable {
        /// The error code returned when the processing request for the named query failed, if applicable.
        public var errorCode: Swift.String?
        /// The error message returned when the processing request for the named query failed, if applicable.
        public var errorMessage: Swift.String?
        /// The unique identifier of the named query.
        public var namedQueryId: Swift.String?

        public init (
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil,
            namedQueryId: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.namedQueryId = namedQueryId
        }
    }

}

extension AthenaClientTypes.UnprocessedPreparedStatementName: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
        case statementName = "StatementName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let statementName = self.statementName {
            try encodeContainer.encode(statementName, forKey: .statementName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statementNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statementName)
        statementName = statementNameDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension AthenaClientTypes {
    /// The name of a prepared statement that could not be returned.
    public struct UnprocessedPreparedStatementName: Swift.Equatable {
        /// The error code returned when the request for the prepared statement failed.
        public var errorCode: Swift.String?
        /// The error message containing the reason why the prepared statement could not be returned. The following error messages are possible:
        ///
        /// * INVALID_INPUT - The name of the prepared statement that was provided is not valid (for example, the name is too long).
        ///
        /// * STATEMENT_NOT_FOUND - A prepared statement with the name provided could not be found.
        ///
        /// * UNAUTHORIZED - The requester does not have permission to access the workgroup that contains the prepared statement.
        public var errorMessage: Swift.String?
        /// The name of a prepared statement that could not be returned due to an error.
        public var statementName: Swift.String?

        public init (
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil,
            statementName: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.statementName = statementName
        }
    }

}

extension AthenaClientTypes.UnprocessedQueryExecutionId: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
        case queryExecutionId = "QueryExecutionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let queryExecutionId = self.queryExecutionId {
            try encodeContainer.encode(queryExecutionId, forKey: .queryExecutionId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryExecutionId)
        queryExecutionId = queryExecutionIdDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension AthenaClientTypes {
    /// Describes a query execution that failed to process.
    public struct UnprocessedQueryExecutionId: Swift.Equatable {
        /// The error code returned when the query execution failed to process, if applicable.
        public var errorCode: Swift.String?
        /// The error message returned when the query execution failed to process, if applicable.
        public var errorMessage: Swift.String?
        /// The unique identifier of the query execution.
        public var queryExecutionId: Swift.String?

        public init (
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil,
            queryExecutionId: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.queryExecutionId = queryExecutionId
        }
    }

}

extension UntagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkey0 in tagKeys {
                try tagKeysContainer.encode(tagkey0)
            }
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// Specifies the ARN of the resource from which tags are to be removed.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// A comma-separated list of one or more tag keys whose tags are to be removed from the specified resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceARN: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    let resourceARN: Swift.String?
    let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateDataCatalogInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
        case parameters = "Parameters"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .parameters)
            for (dictKey0, parametersMap0) in parameters {
                try parametersContainer.encode(parametersMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension UpdateDataCatalogInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateDataCatalogInput: Swift.Equatable {
    /// New or modified text that describes the data catalog.
    public var description: Swift.String?
    /// The name of the data catalog to update. The catalog name must be unique for the Amazon Web Services account and can use a maximum of 127 alphanumeric, underscore, at sign, or hyphen characters. The remainder of the length constraint of 256 is reserved for use by Athena.
    /// This member is required.
    public var name: Swift.String?
    /// Specifies the Lambda function or functions to use for updating the data catalog. This is a mapping whose values depend on the catalog type.
    ///
    /// * For the HIVE data catalog type, use the following syntax. The metadata-function parameter is required. The sdk-version parameter is optional and defaults to the currently supported version. metadata-function=lambda_arn, sdk-version=version_number
    ///
    /// * For the LAMBDA data catalog type, use one of the following sets of required parameters, but not both.
    ///
    /// * If you have one Lambda function that processes metadata and another for reading the actual data, use the following syntax. Both parameters are required. metadata-function=lambda_arn, record-function=lambda_arn
    ///
    /// * If you have a composite Lambda function that processes both metadata and data, use the following syntax to specify your Lambda function. function=lambda_arn
    public var parameters: [Swift.String:Swift.String]?
    /// Specifies the type of data catalog to update. Specify LAMBDA for a federated catalog, HIVE for an external hive metastore, or GLUE for an Glue Data Catalog.
    /// This member is required.
    public var type: AthenaClientTypes.DataCatalogType?

    public init (
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        parameters: [Swift.String:Swift.String]? = nil,
        type: AthenaClientTypes.DataCatalogType? = nil
    )
    {
        self.description = description
        self.name = name
        self.parameters = parameters
        self.type = type
    }
}

struct UpdateDataCatalogInputBody: Swift.Equatable {
    let name: Swift.String?
    let type: AthenaClientTypes.DataCatalogType?
    let description: Swift.String?
    let parameters: [Swift.String:Swift.String]?
}

extension UpdateDataCatalogInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
        case parameters = "Parameters"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.DataCatalogType.self, forKey: .type)
        type = typeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let parametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .parameters)
        var parametersDecoded0: [Swift.String:Swift.String]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, parametersmapvalue0) in parametersContainer {
                if let parametersmapvalue0 = parametersmapvalue0 {
                    parametersDecoded0?[key0] = parametersmapvalue0
                }
            }
        }
        parameters = parametersDecoded0
    }
}

extension UpdateDataCatalogOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDataCatalogOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateDataCatalogOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDataCatalogOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateDataCatalogOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateNamedQueryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
        case namedQueryId = "NamedQueryId"
        case queryString = "QueryString"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let namedQueryId = self.namedQueryId {
            try encodeContainer.encode(namedQueryId, forKey: .namedQueryId)
        }
        if let queryString = self.queryString {
            try encodeContainer.encode(queryString, forKey: .queryString)
        }
    }
}

extension UpdateNamedQueryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateNamedQueryInput: Swift.Equatable {
    /// The query description.
    public var description: Swift.String?
    /// The name of the query.
    /// This member is required.
    public var name: Swift.String?
    /// The unique identifier (UUID) of the query.
    /// This member is required.
    public var namedQueryId: Swift.String?
    /// The contents of the query with all query statements.
    /// This member is required.
    public var queryString: Swift.String?

    public init (
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        namedQueryId: Swift.String? = nil,
        queryString: Swift.String? = nil
    )
    {
        self.description = description
        self.name = name
        self.namedQueryId = namedQueryId
        self.queryString = queryString
    }
}

struct UpdateNamedQueryInputBody: Swift.Equatable {
    let namedQueryId: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let queryString: Swift.String?
}

extension UpdateNamedQueryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
        case namedQueryId = "NamedQueryId"
        case queryString = "QueryString"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namedQueryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namedQueryId)
        namedQueryId = namedQueryIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let queryStringDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryString)
        queryString = queryStringDecoded
    }
}

extension UpdateNamedQueryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateNamedQueryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateNamedQueryOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateNamedQueryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateNamedQueryOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateNotebookInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case notebookId = "NotebookId"
        case payload = "Payload"
        case sessionId = "SessionId"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let notebookId = self.notebookId {
            try encodeContainer.encode(notebookId, forKey: .notebookId)
        }
        if let payload = self.payload {
            try encodeContainer.encode(payload, forKey: .payload)
        }
        if let sessionId = self.sessionId {
            try encodeContainer.encode(sessionId, forKey: .sessionId)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension UpdateNotebookInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateNotebookInput: Swift.Equatable {
    /// A unique case-sensitive string used to ensure the request to create the notebook is idempotent (executes only once). This token is listed as not required because Amazon Web Services SDKs (for example the Amazon Web Services SDK for Java) auto-generate the token for you. If you are not using the Amazon Web Services SDK or the Amazon Web Services CLI, you must provide this token or the action will fail.
    public var clientRequestToken: Swift.String?
    /// The ID of the notebook to update.
    /// This member is required.
    public var notebookId: Swift.String?
    /// The updated content for the notebook.
    /// This member is required.
    public var payload: Swift.String?
    /// The ID of the session in which the notebook will be updated.
    public var sessionId: Swift.String?
    /// The notebook content type. Currently, the only valid type is IPYNB.
    /// This member is required.
    public var type: AthenaClientTypes.NotebookType?

    public init (
        clientRequestToken: Swift.String? = nil,
        notebookId: Swift.String? = nil,
        payload: Swift.String? = nil,
        sessionId: Swift.String? = nil,
        type: AthenaClientTypes.NotebookType? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.notebookId = notebookId
        self.payload = payload
        self.sessionId = sessionId
        self.type = type
    }
}

struct UpdateNotebookInputBody: Swift.Equatable {
    let notebookId: Swift.String?
    let payload: Swift.String?
    let type: AthenaClientTypes.NotebookType?
    let sessionId: Swift.String?
    let clientRequestToken: Swift.String?
}

extension UpdateNotebookInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case notebookId = "NotebookId"
        case payload = "Payload"
        case sessionId = "SessionId"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let notebookIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .notebookId)
        notebookId = notebookIdDecoded
        let payloadDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .payload)
        payload = payloadDecoded
        let typeDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.NotebookType.self, forKey: .type)
        type = typeDecoded
        let sessionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionId)
        sessionId = sessionIdDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
    }
}

extension UpdateNotebookMetadataInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case name = "Name"
        case notebookId = "NotebookId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let notebookId = self.notebookId {
            try encodeContainer.encode(notebookId, forKey: .notebookId)
        }
    }
}

extension UpdateNotebookMetadataInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateNotebookMetadataInput: Swift.Equatable {
    /// A unique case-sensitive string used to ensure the request to create the notebook is idempotent (executes only once). This token is listed as not required because Amazon Web Services SDKs (for example the Amazon Web Services SDK for Java) auto-generate the token for you. If you are not using the Amazon Web Services SDK or the Amazon Web Services CLI, you must provide this token or the action will fail.
    public var clientRequestToken: Swift.String?
    /// The name to update the notebook to.
    /// This member is required.
    public var name: Swift.String?
    /// The ID of the notebook to update the metadata for.
    /// This member is required.
    public var notebookId: Swift.String?

    public init (
        clientRequestToken: Swift.String? = nil,
        name: Swift.String? = nil,
        notebookId: Swift.String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.name = name
        self.notebookId = notebookId
    }
}

struct UpdateNotebookMetadataInputBody: Swift.Equatable {
    let notebookId: Swift.String?
    let clientRequestToken: Swift.String?
    let name: Swift.String?
}

extension UpdateNotebookMetadataInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case name = "Name"
        case notebookId = "NotebookId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let notebookIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .notebookId)
        notebookId = notebookIdDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension UpdateNotebookMetadataOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateNotebookMetadataOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateNotebookMetadataOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateNotebookMetadataOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateNotebookMetadataOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateNotebookOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateNotebookOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateNotebookOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateNotebookOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateNotebookOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdatePreparedStatementInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case queryStatement = "QueryStatement"
        case statementName = "StatementName"
        case workGroup = "WorkGroup"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let queryStatement = self.queryStatement {
            try encodeContainer.encode(queryStatement, forKey: .queryStatement)
        }
        if let statementName = self.statementName {
            try encodeContainer.encode(statementName, forKey: .statementName)
        }
        if let workGroup = self.workGroup {
            try encodeContainer.encode(workGroup, forKey: .workGroup)
        }
    }
}

extension UpdatePreparedStatementInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdatePreparedStatementInput: Swift.Equatable {
    /// The description of the prepared statement.
    public var description: Swift.String?
    /// The query string for the prepared statement.
    /// This member is required.
    public var queryStatement: Swift.String?
    /// The name of the prepared statement.
    /// This member is required.
    public var statementName: Swift.String?
    /// The workgroup for the prepared statement.
    /// This member is required.
    public var workGroup: Swift.String?

    public init (
        description: Swift.String? = nil,
        queryStatement: Swift.String? = nil,
        statementName: Swift.String? = nil,
        workGroup: Swift.String? = nil
    )
    {
        self.description = description
        self.queryStatement = queryStatement
        self.statementName = statementName
        self.workGroup = workGroup
    }
}

struct UpdatePreparedStatementInputBody: Swift.Equatable {
    let statementName: Swift.String?
    let workGroup: Swift.String?
    let queryStatement: Swift.String?
    let description: Swift.String?
}

extension UpdatePreparedStatementInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case queryStatement = "QueryStatement"
        case statementName = "StatementName"
        case workGroup = "WorkGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statementNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statementName)
        statementName = statementNameDecoded
        let workGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workGroup)
        workGroup = workGroupDecoded
        let queryStatementDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryStatement)
        queryStatement = queryStatementDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdatePreparedStatementOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdatePreparedStatementOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdatePreparedStatementOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdatePreparedStatementOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdatePreparedStatementOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateWorkGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationUpdates = "ConfigurationUpdates"
        case description = "Description"
        case state = "State"
        case workGroup = "WorkGroup"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationUpdates = self.configurationUpdates {
            try encodeContainer.encode(configurationUpdates, forKey: .configurationUpdates)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let workGroup = self.workGroup {
            try encodeContainer.encode(workGroup, forKey: .workGroup)
        }
    }
}

extension UpdateWorkGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateWorkGroupInput: Swift.Equatable {
    /// Contains configuration updates for an Athena SQL workgroup.
    public var configurationUpdates: AthenaClientTypes.WorkGroupConfigurationUpdates?
    /// The workgroup description.
    public var description: Swift.String?
    /// The workgroup state that will be updated for the given workgroup.
    public var state: AthenaClientTypes.WorkGroupState?
    /// The specified workgroup that will be updated.
    /// This member is required.
    public var workGroup: Swift.String?

    public init (
        configurationUpdates: AthenaClientTypes.WorkGroupConfigurationUpdates? = nil,
        description: Swift.String? = nil,
        state: AthenaClientTypes.WorkGroupState? = nil,
        workGroup: Swift.String? = nil
    )
    {
        self.configurationUpdates = configurationUpdates
        self.description = description
        self.state = state
        self.workGroup = workGroup
    }
}

struct UpdateWorkGroupInputBody: Swift.Equatable {
    let workGroup: Swift.String?
    let description: Swift.String?
    let configurationUpdates: AthenaClientTypes.WorkGroupConfigurationUpdates?
    let state: AthenaClientTypes.WorkGroupState?
}

extension UpdateWorkGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationUpdates = "ConfigurationUpdates"
        case description = "Description"
        case state = "State"
        case workGroup = "WorkGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workGroup)
        workGroup = workGroupDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let configurationUpdatesDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.WorkGroupConfigurationUpdates.self, forKey: .configurationUpdates)
        configurationUpdates = configurationUpdatesDecoded
        let stateDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.WorkGroupState.self, forKey: .state)
        state = stateDecoded
    }
}

extension UpdateWorkGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateWorkGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateWorkGroupOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateWorkGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateWorkGroupOutputResponse: Swift.Equatable {

    public init () { }
}

extension AthenaClientTypes.WorkGroup: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration = "Configuration"
        case creationTime = "CreationTime"
        case description = "Description"
        case name = "Name"
        case state = "State"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configuration = self.configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let stateDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.WorkGroupState.self, forKey: .state)
        state = stateDecoded
        let configurationDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.WorkGroupConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
    }
}

extension AthenaClientTypes {
    /// A workgroup, which contains a name, description, creation time, state, and other configuration, listed under [WorkGroup$Configuration]. Each workgroup enables you to isolate queries for you or your group of users from other queries in the same account, to configure the query results location and the encryption configuration (known as workgroup settings), to enable sending query metrics to Amazon CloudWatch, and to establish per-query data usage control limits for all queries in a workgroup. The workgroup settings override is specified in EnforceWorkGroupConfiguration (true/false) in the WorkGroupConfiguration. See [WorkGroupConfiguration$EnforceWorkGroupConfiguration].
    public struct WorkGroup: Swift.Equatable {
        /// The configuration of the workgroup, which includes the location in Amazon S3 where query results are stored, the encryption configuration, if any, used for query results; whether the Amazon CloudWatch Metrics are enabled for the workgroup; whether workgroup settings override client-side settings; and the data usage limits for the amount of data scanned per query or per workgroup. The workgroup settings override is specified in EnforceWorkGroupConfiguration (true/false) in the WorkGroupConfiguration. See [WorkGroupConfiguration$EnforceWorkGroupConfiguration].
        public var configuration: AthenaClientTypes.WorkGroupConfiguration?
        /// The date and time the workgroup was created.
        public var creationTime: ClientRuntime.Date?
        /// The workgroup description.
        public var description: Swift.String?
        /// The workgroup name.
        /// This member is required.
        public var name: Swift.String?
        /// The state of the workgroup: ENABLED or DISABLED.
        public var state: AthenaClientTypes.WorkGroupState?

        public init (
            configuration: AthenaClientTypes.WorkGroupConfiguration? = nil,
            creationTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            state: AthenaClientTypes.WorkGroupState? = nil
        )
        {
            self.configuration = configuration
            self.creationTime = creationTime
            self.description = description
            self.name = name
            self.state = state
        }
    }

}

extension AthenaClientTypes.WorkGroupConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalConfiguration = "AdditionalConfiguration"
        case bytesScannedCutoffPerQuery = "BytesScannedCutoffPerQuery"
        case customerContentEncryptionConfiguration = "CustomerContentEncryptionConfiguration"
        case enforceWorkGroupConfiguration = "EnforceWorkGroupConfiguration"
        case engineVersion = "EngineVersion"
        case executionRole = "ExecutionRole"
        case publishCloudWatchMetricsEnabled = "PublishCloudWatchMetricsEnabled"
        case requesterPaysEnabled = "RequesterPaysEnabled"
        case resultConfiguration = "ResultConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalConfiguration = self.additionalConfiguration {
            try encodeContainer.encode(additionalConfiguration, forKey: .additionalConfiguration)
        }
        if let bytesScannedCutoffPerQuery = self.bytesScannedCutoffPerQuery {
            try encodeContainer.encode(bytesScannedCutoffPerQuery, forKey: .bytesScannedCutoffPerQuery)
        }
        if let customerContentEncryptionConfiguration = self.customerContentEncryptionConfiguration {
            try encodeContainer.encode(customerContentEncryptionConfiguration, forKey: .customerContentEncryptionConfiguration)
        }
        if let enforceWorkGroupConfiguration = self.enforceWorkGroupConfiguration {
            try encodeContainer.encode(enforceWorkGroupConfiguration, forKey: .enforceWorkGroupConfiguration)
        }
        if let engineVersion = self.engineVersion {
            try encodeContainer.encode(engineVersion, forKey: .engineVersion)
        }
        if let executionRole = self.executionRole {
            try encodeContainer.encode(executionRole, forKey: .executionRole)
        }
        if let publishCloudWatchMetricsEnabled = self.publishCloudWatchMetricsEnabled {
            try encodeContainer.encode(publishCloudWatchMetricsEnabled, forKey: .publishCloudWatchMetricsEnabled)
        }
        if let requesterPaysEnabled = self.requesterPaysEnabled {
            try encodeContainer.encode(requesterPaysEnabled, forKey: .requesterPaysEnabled)
        }
        if let resultConfiguration = self.resultConfiguration {
            try encodeContainer.encode(resultConfiguration, forKey: .resultConfiguration)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resultConfigurationDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.ResultConfiguration.self, forKey: .resultConfiguration)
        resultConfiguration = resultConfigurationDecoded
        let enforceWorkGroupConfigurationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enforceWorkGroupConfiguration)
        enforceWorkGroupConfiguration = enforceWorkGroupConfigurationDecoded
        let publishCloudWatchMetricsEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .publishCloudWatchMetricsEnabled)
        publishCloudWatchMetricsEnabled = publishCloudWatchMetricsEnabledDecoded
        let bytesScannedCutoffPerQueryDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .bytesScannedCutoffPerQuery)
        bytesScannedCutoffPerQuery = bytesScannedCutoffPerQueryDecoded
        let requesterPaysEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .requesterPaysEnabled)
        requesterPaysEnabled = requesterPaysEnabledDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.EngineVersion.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let additionalConfigurationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .additionalConfiguration)
        additionalConfiguration = additionalConfigurationDecoded
        let executionRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionRole)
        executionRole = executionRoleDecoded
        let customerContentEncryptionConfigurationDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.CustomerContentEncryptionConfiguration.self, forKey: .customerContentEncryptionConfiguration)
        customerContentEncryptionConfiguration = customerContentEncryptionConfigurationDecoded
    }
}

extension AthenaClientTypes {
    /// The configuration of the workgroup, which includes the location in Amazon S3 where query results are stored, the encryption option, if any, used for query results, whether the Amazon CloudWatch Metrics are enabled for the workgroup and whether workgroup settings override query settings, and the data usage limits for the amount of data scanned per query or per workgroup. The workgroup settings override is specified in EnforceWorkGroupConfiguration (true/false) in the WorkGroupConfiguration. See [WorkGroupConfiguration$EnforceWorkGroupConfiguration].
    public struct WorkGroupConfiguration: Swift.Equatable {
        /// Specifies a user defined JSON string that is passed to the notebook engine.
        public var additionalConfiguration: Swift.String?
        /// The upper data usage limit (cutoff) for the amount of bytes a single query in a workgroup is allowed to scan.
        public var bytesScannedCutoffPerQuery: Swift.Int?
        /// Specifies the KMS key that is used to encrypt the user's data stores in Athena.
        public var customerContentEncryptionConfiguration: AthenaClientTypes.CustomerContentEncryptionConfiguration?
        /// If set to "true", the settings for the workgroup override client-side settings. If set to "false", client-side settings are used. For more information, see [Workgroup Settings Override Client-Side Settings](https://docs.aws.amazon.com/athena/latest/ug/workgroups-settings-override.html).
        public var enforceWorkGroupConfiguration: Swift.Bool?
        /// The engine version that all queries running on the workgroup use. Queries on the AmazonAthenaPreviewFunctionality workgroup run on the preview engine regardless of this setting.
        public var engineVersion: AthenaClientTypes.EngineVersion?
        /// Role used in a notebook session for accessing the user's resources.
        public var executionRole: Swift.String?
        /// Indicates that the Amazon CloudWatch metrics are enabled for the workgroup.
        public var publishCloudWatchMetricsEnabled: Swift.Bool?
        /// If set to true, allows members assigned to a workgroup to reference Amazon S3 Requester Pays buckets in queries. If set to false, workgroup members cannot query data from Requester Pays buckets, and queries that retrieve data from Requester Pays buckets cause an error. The default is false. For more information about Requester Pays buckets, see [Requester Pays Buckets](https://docs.aws.amazon.com/AmazonS3/latest/dev/RequesterPaysBuckets.html) in the Amazon Simple Storage Service Developer Guide.
        public var requesterPaysEnabled: Swift.Bool?
        /// The configuration for the workgroup, which includes the location in Amazon S3 where query results are stored and the encryption option, if any, used for query results. To run the query, you must specify the query results location using one of the ways: either in the workgroup using this setting, or for individual queries (client-side), using [ResultConfiguration$OutputLocation]. If none of them is set, Athena issues an error that no output location is provided. For more information, see [Query Results](https://docs.aws.amazon.com/athena/latest/ug/querying.html).
        public var resultConfiguration: AthenaClientTypes.ResultConfiguration?

        public init (
            additionalConfiguration: Swift.String? = nil,
            bytesScannedCutoffPerQuery: Swift.Int? = nil,
            customerContentEncryptionConfiguration: AthenaClientTypes.CustomerContentEncryptionConfiguration? = nil,
            enforceWorkGroupConfiguration: Swift.Bool? = nil,
            engineVersion: AthenaClientTypes.EngineVersion? = nil,
            executionRole: Swift.String? = nil,
            publishCloudWatchMetricsEnabled: Swift.Bool? = nil,
            requesterPaysEnabled: Swift.Bool? = nil,
            resultConfiguration: AthenaClientTypes.ResultConfiguration? = nil
        )
        {
            self.additionalConfiguration = additionalConfiguration
            self.bytesScannedCutoffPerQuery = bytesScannedCutoffPerQuery
            self.customerContentEncryptionConfiguration = customerContentEncryptionConfiguration
            self.enforceWorkGroupConfiguration = enforceWorkGroupConfiguration
            self.engineVersion = engineVersion
            self.executionRole = executionRole
            self.publishCloudWatchMetricsEnabled = publishCloudWatchMetricsEnabled
            self.requesterPaysEnabled = requesterPaysEnabled
            self.resultConfiguration = resultConfiguration
        }
    }

}

extension AthenaClientTypes.WorkGroupConfigurationUpdates: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalConfiguration = "AdditionalConfiguration"
        case bytesScannedCutoffPerQuery = "BytesScannedCutoffPerQuery"
        case customerContentEncryptionConfiguration = "CustomerContentEncryptionConfiguration"
        case enforceWorkGroupConfiguration = "EnforceWorkGroupConfiguration"
        case engineVersion = "EngineVersion"
        case executionRole = "ExecutionRole"
        case publishCloudWatchMetricsEnabled = "PublishCloudWatchMetricsEnabled"
        case removeBytesScannedCutoffPerQuery = "RemoveBytesScannedCutoffPerQuery"
        case removeCustomerContentEncryptionConfiguration = "RemoveCustomerContentEncryptionConfiguration"
        case requesterPaysEnabled = "RequesterPaysEnabled"
        case resultConfigurationUpdates = "ResultConfigurationUpdates"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalConfiguration = self.additionalConfiguration {
            try encodeContainer.encode(additionalConfiguration, forKey: .additionalConfiguration)
        }
        if let bytesScannedCutoffPerQuery = self.bytesScannedCutoffPerQuery {
            try encodeContainer.encode(bytesScannedCutoffPerQuery, forKey: .bytesScannedCutoffPerQuery)
        }
        if let customerContentEncryptionConfiguration = self.customerContentEncryptionConfiguration {
            try encodeContainer.encode(customerContentEncryptionConfiguration, forKey: .customerContentEncryptionConfiguration)
        }
        if let enforceWorkGroupConfiguration = self.enforceWorkGroupConfiguration {
            try encodeContainer.encode(enforceWorkGroupConfiguration, forKey: .enforceWorkGroupConfiguration)
        }
        if let engineVersion = self.engineVersion {
            try encodeContainer.encode(engineVersion, forKey: .engineVersion)
        }
        if let executionRole = self.executionRole {
            try encodeContainer.encode(executionRole, forKey: .executionRole)
        }
        if let publishCloudWatchMetricsEnabled = self.publishCloudWatchMetricsEnabled {
            try encodeContainer.encode(publishCloudWatchMetricsEnabled, forKey: .publishCloudWatchMetricsEnabled)
        }
        if let removeBytesScannedCutoffPerQuery = self.removeBytesScannedCutoffPerQuery {
            try encodeContainer.encode(removeBytesScannedCutoffPerQuery, forKey: .removeBytesScannedCutoffPerQuery)
        }
        if let removeCustomerContentEncryptionConfiguration = self.removeCustomerContentEncryptionConfiguration {
            try encodeContainer.encode(removeCustomerContentEncryptionConfiguration, forKey: .removeCustomerContentEncryptionConfiguration)
        }
        if let requesterPaysEnabled = self.requesterPaysEnabled {
            try encodeContainer.encode(requesterPaysEnabled, forKey: .requesterPaysEnabled)
        }
        if let resultConfigurationUpdates = self.resultConfigurationUpdates {
            try encodeContainer.encode(resultConfigurationUpdates, forKey: .resultConfigurationUpdates)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enforceWorkGroupConfigurationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enforceWorkGroupConfiguration)
        enforceWorkGroupConfiguration = enforceWorkGroupConfigurationDecoded
        let resultConfigurationUpdatesDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.ResultConfigurationUpdates.self, forKey: .resultConfigurationUpdates)
        resultConfigurationUpdates = resultConfigurationUpdatesDecoded
        let publishCloudWatchMetricsEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .publishCloudWatchMetricsEnabled)
        publishCloudWatchMetricsEnabled = publishCloudWatchMetricsEnabledDecoded
        let bytesScannedCutoffPerQueryDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .bytesScannedCutoffPerQuery)
        bytesScannedCutoffPerQuery = bytesScannedCutoffPerQueryDecoded
        let removeBytesScannedCutoffPerQueryDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .removeBytesScannedCutoffPerQuery)
        removeBytesScannedCutoffPerQuery = removeBytesScannedCutoffPerQueryDecoded
        let requesterPaysEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .requesterPaysEnabled)
        requesterPaysEnabled = requesterPaysEnabledDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.EngineVersion.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let removeCustomerContentEncryptionConfigurationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .removeCustomerContentEncryptionConfiguration)
        removeCustomerContentEncryptionConfiguration = removeCustomerContentEncryptionConfigurationDecoded
        let additionalConfigurationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .additionalConfiguration)
        additionalConfiguration = additionalConfigurationDecoded
        let executionRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionRole)
        executionRole = executionRoleDecoded
        let customerContentEncryptionConfigurationDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.CustomerContentEncryptionConfiguration.self, forKey: .customerContentEncryptionConfiguration)
        customerContentEncryptionConfiguration = customerContentEncryptionConfigurationDecoded
    }
}

extension AthenaClientTypes {
    /// The configuration information that will be updated for this workgroup, which includes the location in Amazon S3 where query results are stored, the encryption option, if any, used for query results, whether the Amazon CloudWatch Metrics are enabled for the workgroup, whether the workgroup settings override the client-side settings, and the data usage limit for the amount of bytes scanned per query, if it is specified.
    public struct WorkGroupConfigurationUpdates: Swift.Equatable {
        /// Contains a user defined string in JSON format for a Spark-enabled workgroup.
        public var additionalConfiguration: Swift.String?
        /// The upper limit (cutoff) for the amount of bytes a single query in a workgroup is allowed to scan.
        public var bytesScannedCutoffPerQuery: Swift.Int?
        /// Specifies the KMS key that is used to encrypt the user's data stores in Athena.
        public var customerContentEncryptionConfiguration: AthenaClientTypes.CustomerContentEncryptionConfiguration?
        /// If set to "true", the settings for the workgroup override client-side settings. If set to "false" client-side settings are used. For more information, see [Workgroup Settings Override Client-Side Settings](https://docs.aws.amazon.com/athena/latest/ug/workgroups-settings-override.html).
        public var enforceWorkGroupConfiguration: Swift.Bool?
        /// The engine version requested when a workgroup is updated. After the update, all queries on the workgroup run on the requested engine version. If no value was previously set, the default is Auto. Queries on the AmazonAthenaPreviewFunctionality workgroup run on the preview engine regardless of this setting.
        public var engineVersion: AthenaClientTypes.EngineVersion?
        /// Contains the ARN of the execution role for the workgroup
        public var executionRole: Swift.String?
        /// Indicates whether this workgroup enables publishing metrics to Amazon CloudWatch.
        public var publishCloudWatchMetricsEnabled: Swift.Bool?
        /// Indicates that the data usage control limit per query is removed. [WorkGroupConfiguration$BytesScannedCutoffPerQuery]
        public var removeBytesScannedCutoffPerQuery: Swift.Bool?
        /// Removes content encryption configuration for a workgroup.
        public var removeCustomerContentEncryptionConfiguration: Swift.Bool?
        /// If set to true, allows members assigned to a workgroup to specify Amazon S3 Requester Pays buckets in queries. If set to false, workgroup members cannot query data from Requester Pays buckets, and queries that retrieve data from Requester Pays buckets cause an error. The default is false. For more information about Requester Pays buckets, see [Requester Pays Buckets](https://docs.aws.amazon.com/AmazonS3/latest/dev/RequesterPaysBuckets.html) in the Amazon Simple Storage Service Developer Guide.
        public var requesterPaysEnabled: Swift.Bool?
        /// The result configuration information about the queries in this workgroup that will be updated. Includes the updated results location and an updated option for encrypting query results.
        public var resultConfigurationUpdates: AthenaClientTypes.ResultConfigurationUpdates?

        public init (
            additionalConfiguration: Swift.String? = nil,
            bytesScannedCutoffPerQuery: Swift.Int? = nil,
            customerContentEncryptionConfiguration: AthenaClientTypes.CustomerContentEncryptionConfiguration? = nil,
            enforceWorkGroupConfiguration: Swift.Bool? = nil,
            engineVersion: AthenaClientTypes.EngineVersion? = nil,
            executionRole: Swift.String? = nil,
            publishCloudWatchMetricsEnabled: Swift.Bool? = nil,
            removeBytesScannedCutoffPerQuery: Swift.Bool? = nil,
            removeCustomerContentEncryptionConfiguration: Swift.Bool? = nil,
            requesterPaysEnabled: Swift.Bool? = nil,
            resultConfigurationUpdates: AthenaClientTypes.ResultConfigurationUpdates? = nil
        )
        {
            self.additionalConfiguration = additionalConfiguration
            self.bytesScannedCutoffPerQuery = bytesScannedCutoffPerQuery
            self.customerContentEncryptionConfiguration = customerContentEncryptionConfiguration
            self.enforceWorkGroupConfiguration = enforceWorkGroupConfiguration
            self.engineVersion = engineVersion
            self.executionRole = executionRole
            self.publishCloudWatchMetricsEnabled = publishCloudWatchMetricsEnabled
            self.removeBytesScannedCutoffPerQuery = removeBytesScannedCutoffPerQuery
            self.removeCustomerContentEncryptionConfiguration = removeCustomerContentEncryptionConfiguration
            self.requesterPaysEnabled = requesterPaysEnabled
            self.resultConfigurationUpdates = resultConfigurationUpdates
        }
    }

}

extension AthenaClientTypes {
    public enum WorkGroupState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [WorkGroupState] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WorkGroupState(rawValue: rawValue) ?? WorkGroupState.sdkUnknown(rawValue)
        }
    }
}

extension AthenaClientTypes.WorkGroupSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case description = "Description"
        case engineVersion = "EngineVersion"
        case name = "Name"
        case state = "State"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let engineVersion = self.engineVersion {
            try encodeContainer.encode(engineVersion, forKey: .engineVersion)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let stateDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.WorkGroupState.self, forKey: .state)
        state = stateDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.EngineVersion.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
    }
}

extension AthenaClientTypes {
    /// The summary information for the workgroup, which includes its name, state, description, and the date and time it was created.
    public struct WorkGroupSummary: Swift.Equatable {
        /// The workgroup creation date and time.
        public var creationTime: ClientRuntime.Date?
        /// The workgroup description.
        public var description: Swift.String?
        /// The engine version setting for all queries on the workgroup. Queries on the AmazonAthenaPreviewFunctionality workgroup run on the preview engine regardless of this setting.
        public var engineVersion: AthenaClientTypes.EngineVersion?
        /// The name of the workgroup.
        public var name: Swift.String?
        /// The state of the workgroup.
        public var state: AthenaClientTypes.WorkGroupState?

        public init (
            creationTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            engineVersion: AthenaClientTypes.EngineVersion? = nil,
            name: Swift.String? = nil,
            state: AthenaClientTypes.WorkGroupState? = nil
        )
        {
            self.creationTime = creationTime
            self.description = description
            self.engineVersion = engineVersion
            self.name = name
            self.state = state
        }
    }

}
