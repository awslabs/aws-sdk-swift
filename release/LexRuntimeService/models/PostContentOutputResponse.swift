// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

public struct PostContentOutputResponse: Equatable {
    /// <p>A list of active contexts for the session. A context can be set when
    ///       an intent is fulfilled or by calling the <code>PostContent</code>,
    ///         <code>PostText</code>, or <code>PutSession</code> operation.</p>
    ///          <p>You can use a context to control the intents that can follow up an
    ///       intent, or to modify the operation of your application.</p>
    public let activeContexts: String?
    /// <p>One to four alternative intents that may be applicable to the user's
    ///       intent.</p>
    ///          <p>Each alternative includes a score that indicates how confident Amazon Lex
    ///       is that the intent matches the user's intent. The intents are sorted by
    ///       the confidence score.</p>
    public let alternativeIntents: String?
    /// <p>The prompt (or statement) to convey to the user. This is based on the
    ///       bot configuration and context. For example, if Amazon Lex did not understand
    ///       the user intent, it sends the <code>clarificationPrompt</code> configured
    ///       for the bot. If the intent requires confirmation before taking the
    ///       fulfillment action, it sends the <code>confirmationPrompt</code>. Another
    ///       example: Suppose that the Lambda function successfully fulfilled the
    ///       intent, and sent a message to convey to the user. Then Amazon Lex sends that
    ///       message in the response. </p>
    public let audioStream: Data?
    /// <p>The version of the bot that responded to the conversation. You can use
    ///       this information to help determine if one version of a bot is performing
    ///       better than another version.</p>
    public let botVersion: String?
    /// <p>Content type as specified in the <code>Accept</code> HTTP header in
    ///       the request.</p>
    public let contentType: String?
    /// <p>Identifies the current state of the user interaction. Amazon Lex returns
    ///       one of the following values as <code>dialogState</code>. The client can
    ///       optionally use this information to customize the user interface. </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>ElicitIntent</code> - Amazon Lex wants to elicit the user's intent.
    ///           Consider the following examples: </p>
    ///                <p> For example, a user might utter an intent ("I want to order a
    ///           pizza"). If Amazon Lex cannot infer the user intent from this utterance, it
    ///           will return this dialog state. </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>ConfirmIntent</code> - Amazon Lex is expecting a "yes" or "no"
    ///           response. </p>
    ///                <p>For example, Amazon Lex wants user confirmation before fulfilling an
    ///           intent. Instead of a simple "yes" or "no" response, a user might
    ///           respond with additional information. For example, "yes, but make it a
    ///           thick crust pizza" or "no, I want to order a drink." Amazon Lex can process
    ///           such additional information (in these examples, update the crust type
    ///           slot or change the intent from OrderPizza to OrderDrink). </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>ElicitSlot</code> - Amazon Lex is expecting the value of a slot for
    ///           the current intent. </p>
    ///                <p> For example, suppose that in the response Amazon Lex sends this
    ///           message: "What size pizza would you like?". A user might reply with
    ///           the slot value (e.g., "medium"). The user might also provide
    ///           additional information in the response (e.g., "medium thick crust
    ///           pizza"). Amazon Lex can process such additional information appropriately.
    ///         </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Fulfilled</code> - Conveys that the Lambda function has
    ///           successfully fulfilled the intent. </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>ReadyForFulfillment</code> - Conveys that the client has to
    ///           fulfill the request. </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Failed</code> - Conveys that the conversation with the user
    ///           failed. </p>
    ///                <p> This can happen for various reasons, including that the user does
    ///           not provide an appropriate response to prompts from the service (you
    ///           can configure how many times Amazon Lex can prompt a user for specific
    ///           information), or if the Lambda function fails to fulfill the intent.
    ///         </p>
    ///             </li>
    ///          </ul>
    public let dialogState: DialogState?
    /// <p>The text used to process the request.</p>
    ///          <p>If the input was an audio stream, the
    ///         <code>encodedInputTranscript</code> field contains the text extracted
    ///       from the audio stream. This is the text that is actually processed to
    ///       recognize intents and slot values. You can use this information to
    ///       determine if Amazon Lex is correctly processing the audio that you send.</p>
    ///          <p>The <code>encodedInputTranscript</code> field is base-64 encoded. You must
    ///       decode the field before you can use the value.</p>
    public let encodedInputTranscript: String?
    /// <p>The message to convey to the user. The message can come from the bot's
    ///       configuration or from a Lambda function.</p>
    ///          <p>If the intent is not configured with a Lambda function, or if the Lambda
    ///       function returned <code>Delegate</code> as the
    ///         <code>dialogAction.type</code> in its response, Amazon Lex decides on the
    ///       next course of action and selects an appropriate message from the bot's
    ///       configuration based on the current interaction context. For example, if
    ///       Amazon Lex isn't able to understand user input, it uses a clarification prompt
    ///       message.</p>
    ///          <p>When you create an intent you can assign messages to groups. When
    ///       messages are assigned to groups Amazon Lex returns one message from each group
    ///       in the response. The message field is an escaped JSON string containing
    ///       the messages. For more information about the structure of the JSON string
    ///       returned, see <a>msg-prompts-formats</a>.</p>
    ///          <p>If the Lambda function returns a message, Amazon Lex passes it to the client
    ///       in its response.</p>
    ///          <p>The <code>encodedMessage</code> field is base-64 encoded. You must
    ///       decode the field before you can use the value.</p>
    public let encodedMessage: String?
    /// <p>The text used to process the request.</p>
    ///          <p>You can use this field only in the de-DE, en-AU, en-GB, en-US, es-419,
    ///       es-ES, es-US, fr-CA, fr-FR, and it-IT locales. In all other locales, the
    ///         <code>inputTranscript</code> field is null. You should use the
    ///         <code>encodedInputTranscript</code> field instead.</p>
    ///          <p>If the input was an audio stream, the <code>inputTranscript</code>
    ///       field contains the text extracted from the audio stream. This is the text
    ///       that is actually processed to recognize intents and slot values. You can
    ///       use this information to determine if Amazon Lex is correctly processing the
    ///       audio that you send.</p>
    @available(*, deprecated, message: "The inputTranscript field is deprecated, use the encodedInputTranscript field instead. The inputTranscript field is available only in the de-DE, en-AU, en-GB, en-US, es-419, es-ES, es-US, fr-CA, fr-FR and it-IT locales.")
    public let inputTranscript: String?
    /// <p>Current user intent that Amazon Lex is aware of.</p>
    public let intentName: String?
    /// <p>You can only use this field in the de-DE, en-AU, en-GB, en-US, es-419,
    ///       es-ES, es-US, fr-CA, fr-FR, and it-IT locales. In all other locales, the
    ///         <code>message</code> field is null. You should use the
    ///         <code>encodedMessage</code> field instead.</p>
    ///          <p>The message to convey to the user. The message can come from the bot's
    ///       configuration or from a Lambda function.</p>
    ///          <p>If the intent is not configured with a Lambda function, or if the Lambda
    ///       function returned <code>Delegate</code> as the
    ///         <code>dialogAction.type</code> in its response, Amazon Lex decides on the
    ///       next course of action and selects an appropriate message from the bot's
    ///       configuration based on the current interaction context. For example, if
    ///       Amazon Lex isn't able to understand user input, it uses a clarification prompt
    ///       message.</p>
    ///          <p>When you create an intent you can assign messages to groups. When
    ///       messages are assigned to groups Amazon Lex returns one message from each group
    ///       in the response. The message field is an escaped JSON string containing
    ///       the messages. For more information about the structure of the JSON string
    ///       returned, see <a>msg-prompts-formats</a>.</p>
    ///          <p>If the Lambda function returns a message, Amazon Lex passes it to the client
    ///       in its response.</p>
    @available(*, deprecated, message: "The message field is deprecated, use the encodedMessage field instead. The message field is available only in the de-DE, en-AU, en-GB, en-US, es-419, es-ES, es-US, fr-CA, fr-FR and it-IT locales.")
    public let message: String?
    /// <p>The format of the response message. One of the following
    ///       values:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>PlainText</code> - The message contains plain UTF-8
    ///           text.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>CustomPayload</code> - The message is a custom format for
    ///           the client.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>SSML</code> - The message contains text formatted for voice
    ///           output.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Composite</code> - The message contains an escaped JSON
    ///           object containing one or more messages from the groups that messages
    ///           were assigned to when the intent was created.</p>
    ///             </li>
    ///          </ul>
    public let messageFormat: MessageFormatType?
    /// <p>Provides a score that indicates how confident Amazon Lex is that the
    ///       returned intent is the one that matches the user's intent. The score is
    ///       between 0.0 and 1.0.</p>
    ///          <p>The score is a relative score, not an absolute score. The score may
    ///       change based on improvements to Amazon Lex. </p>
    public let nluIntentConfidence: String?
    /// <p>The sentiment expressed in an utterance.</p>
    ///          <p>When the bot is configured to send utterances to Amazon Comprehend for
    ///       sentiment analysis, this field contains the result of the analysis.</p>
    public let sentimentResponse: String?
    /// <p> Map of key/value pairs representing the session-specific context
    ///       information. </p>
    public let sessionAttributes: String?
    /// <p>The unique identifier for the session.</p>
    public let sessionId: String?
    /// <p> If the <code>dialogState</code> value is <code>ElicitSlot</code>,
    ///       returns the name of the slot for which Amazon Lex is eliciting a value. </p>
    public let slotToElicit: String?
    /// <p>Map of zero or more intent slots (name/value pairs) Amazon Lex detected
    ///       from the user input during the conversation. The field is base-64
    ///       encoded.</p>
    ///          <p>Amazon Lex creates a resolution list containing likely values for a slot.
    ///       The value that it returns is determined by the
    ///         <code>valueSelectionStrategy</code> selected when the slot type was
    ///       created or updated. If <code>valueSelectionStrategy</code> is set to
    ///         <code>ORIGINAL_VALUE</code>, the value provided by the user is returned,
    ///       if the user value is similar to the slot values. If
    ///         <code>valueSelectionStrategy</code> is set to
    ///         <code>TOP_RESOLUTION</code> Amazon Lex returns the first value in the
    ///       resolution list or, if there is no resolution list, null. If you don't
    ///       specify a <code>valueSelectionStrategy</code>, the default is
    ///         <code>ORIGINAL_VALUE</code>.</p>
    public let slots: String?

    public init (
        activeContexts: String? = nil,
        alternativeIntents: String? = nil,
        audioStream: Data? = nil,
        botVersion: String? = nil,
        contentType: String? = nil,
        dialogState: DialogState? = nil,
        encodedInputTranscript: String? = nil,
        encodedMessage: String? = nil,
        inputTranscript: String? = nil,
        intentName: String? = nil,
        message: String? = nil,
        messageFormat: MessageFormatType? = nil,
        nluIntentConfidence: String? = nil,
        sentimentResponse: String? = nil,
        sessionAttributes: String? = nil,
        sessionId: String? = nil,
        slotToElicit: String? = nil,
        slots: String? = nil
    )
    {
        self.activeContexts = activeContexts
        self.alternativeIntents = alternativeIntents
        self.audioStream = audioStream
        self.botVersion = botVersion
        self.contentType = contentType
        self.dialogState = dialogState
        self.encodedInputTranscript = encodedInputTranscript
        self.encodedMessage = encodedMessage
        self.inputTranscript = inputTranscript
        self.intentName = intentName
        self.message = message
        self.messageFormat = messageFormat
        self.nluIntentConfidence = nluIntentConfidence
        self.sentimentResponse = sentimentResponse
        self.sessionAttributes = sessionAttributes
        self.sessionId = sessionId
        self.slotToElicit = slotToElicit
        self.slots = slots
    }
}

extension PostContentOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PostContentOutputResponse(activeContexts: \(String(describing: activeContexts)), alternativeIntents: \(String(describing: alternativeIntents)), audioStream: \(String(describing: audioStream)), botVersion: \(String(describing: botVersion)), contentType: \(String(describing: contentType)), dialogState: \(String(describing: dialogState)), encodedInputTranscript: \(String(describing: encodedInputTranscript)), encodedMessage: \(String(describing: encodedMessage)), inputTranscript: \(String(describing: inputTranscript)), intentName: \(String(describing: intentName)), message: \(String(describing: message)), messageFormat: \(String(describing: messageFormat)), nluIntentConfidence: \(String(describing: nluIntentConfidence)), sentimentResponse: \(String(describing: sentimentResponse)), sessionAttributes: \(String(describing: sessionAttributes)), sessionId: \(String(describing: sessionId)), slotToElicit: \(String(describing: slotToElicit)), slots: \(String(describing: slots)))"}
}
