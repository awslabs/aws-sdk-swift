// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension ActiveContext: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name
        case parameters
        case timeToLive
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .parameters)
            for (dictKey0, activecontextparametersmap0) in parameters {
                try parametersContainer.encode(activecontextparametersmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let timeToLive = timeToLive {
            try encodeContainer.encode(timeToLive, forKey: .timeToLive)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let timeToLiveDecoded = try containerValues.decodeIfPresent(ActiveContextTimeToLive.self, forKey: .timeToLive)
        timeToLive = timeToLiveDecoded
        let parametersContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .parameters)
        var parametersDecoded0: [String:String]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [String:String]()
            for (key0, text0) in parametersContainer {
                if let text0 = text0 {
                    parametersDecoded0?[key0] = text0
                }
            }
        }
        parameters = parametersDecoded0
    }
}

extension ActiveContext: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ActiveContext(name: \(String(describing: name)), parameters: \(String(describing: parameters)), timeToLive: \(String(describing: timeToLive)))"}
}

/// <p>A context is a variable that contains information about the current
///       state of the conversation between a user and Amazon Lex. Context can be set
///       automatically by Amazon Lex when an intent is fulfilled, or it can be set at
///       runtime using the <code>PutContent</code>, <code>PutText</code>, or
///         <code>PutSession</code> operation.</p>
public struct ActiveContext: Equatable {
    /// <p>The name of the context.</p>
    public let name: String?
    /// <p>State variables for the current context. You can use these values as
    ///       default values for slots in subsequent events.</p>
    public let parameters: [String:String]?
    /// <p>The length of time or number of turns that a context remains
    ///       active.</p>
    public let timeToLive: ActiveContextTimeToLive?

    public init (
        name: String? = nil,
        parameters: [String:String]? = nil,
        timeToLive: ActiveContextTimeToLive? = nil
    )
    {
        self.name = name
        self.parameters = parameters
        self.timeToLive = timeToLive
    }
}

extension ActiveContextTimeToLive: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case timeToLiveInSeconds
        case turnsToLive
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let timeToLiveInSeconds = timeToLiveInSeconds {
            try encodeContainer.encode(timeToLiveInSeconds, forKey: .timeToLiveInSeconds)
        }
        if let turnsToLive = turnsToLive {
            try encodeContainer.encode(turnsToLive, forKey: .turnsToLive)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timeToLiveInSecondsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .timeToLiveInSeconds)
        timeToLiveInSeconds = timeToLiveInSecondsDecoded
        let turnsToLiveDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .turnsToLive)
        turnsToLive = turnsToLiveDecoded
    }
}

extension ActiveContextTimeToLive: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ActiveContextTimeToLive(timeToLiveInSeconds: \(String(describing: timeToLiveInSeconds)), turnsToLive: \(String(describing: turnsToLive)))"}
}

/// <p>The length of time or number of turns that a context remains
///       active.</p>
public struct ActiveContextTimeToLive: Equatable {
    /// <p>The number of seconds that the context should be active after it is
    ///       first sent in a <code>PostContent</code> or <code>PostText</code>
    ///       response. You can set the value between 5 and 86,400 seconds (24
    ///       hours).</p>
    public let timeToLiveInSeconds: Int?
    /// <p>The number of conversation turns that the context should be active. A
    ///       conversation turn is one <code>PostContent</code> or <code>PostText</code>
    ///       request and the corresponding response from Amazon Lex.</p>
    public let turnsToLive: Int?

    public init (
        timeToLiveInSeconds: Int? = nil,
        turnsToLive: Int? = nil
    )
    {
        self.timeToLiveInSeconds = timeToLiveInSeconds
        self.turnsToLive = turnsToLive
    }
}

extension BadGatewayException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BadGatewayException(message: \(String(describing: message)))"}
}

extension BadGatewayException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BadGatewayExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Either the Amazon Lex bot is still building, or one of the dependent
///       services (Amazon Polly, AWS Lambda) failed with an internal service
///       error.</p>
public struct BadGatewayException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct BadGatewayExceptionBody: Equatable {
    public let message: String?
}

extension BadGatewayExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BadRequestException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BadRequestException(message: \(String(describing: message)))"}
}

extension BadRequestException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BadRequestExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p> Request validation failed, there is no usable message in the context,
///       or the bot build failed, is still in progress, or contains unbuilt
///       changes. </p>
public struct BadRequestException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct BadRequestExceptionBody: Equatable {
    public let message: String?
}

extension BadRequestExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Button: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case text
        case value
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let text = text {
            try encodeContainer.encode(text, forKey: .text)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textDecoded = try containerValues.decodeIfPresent(String.self, forKey: .text)
        text = textDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Button: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Button(text: \(String(describing: text)), value: \(String(describing: value)))"}
}

/// <p>Represents an option to be shown on the client platform (Facebook,
///       Slack, etc.)</p>
public struct Button: Equatable {
    /// <p>Text that is visible to the user on the button.</p>
    public let text: String?
    /// <p>The value sent to Amazon Lex when a user chooses the button. For
    ///       example, consider button text "NYC." When the user chooses the button, the
    ///       value sent can be "New York City."</p>
    public let value: String?

    public init (
        text: String? = nil,
        value: String? = nil
    )
    {
        self.text = text
        self.value = value
    }
}

public enum ConfirmationStatus {
    case confirmed
    case denied
    case `none`
    case sdkUnknown(String)
}

extension ConfirmationStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ConfirmationStatus] {
        return [
            .confirmed,
            .denied,
            .none,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .confirmed: return "Confirmed"
        case .denied: return "Denied"
        case .none: return "None"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ConfirmationStatus(rawValue: rawValue) ?? ConfirmationStatus.sdkUnknown(rawValue)
    }
}

extension ConflictException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConflictException(message: \(String(describing: message)))"}
}

extension ConflictException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p> Two clients are using the same AWS account, Amazon Lex bot, and user
///       ID. </p>
public struct ConflictException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ConflictExceptionBody: Equatable {
    public let message: String?
}

extension ConflictExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum ContentType {
    case generic
    case sdkUnknown(String)
}

extension ContentType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ContentType] {
        return [
            .generic,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .generic: return "application/vnd.amazonaws.card.generic"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ContentType(rawValue: rawValue) ?? ContentType.sdkUnknown(rawValue)
    }
}

extension DeleteSessionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteSessionInput(botAlias: \(String(describing: botAlias)), botName: \(String(describing: botName)), userId: \(String(describing: userId)))"}
}

extension DeleteSessionInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteSessionInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteSessionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteSessionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteSessionInput>
    public typealias MOutput = OperationOutput<DeleteSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteSessionOutputError>
}

public struct DeleteSessionInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteSessionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteSessionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteSessionInput>
    public typealias MOutput = OperationOutput<DeleteSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteSessionOutputError>
}

public struct DeleteSessionInput: Equatable {
    /// <p>The alias in use for the bot that contains the session data.</p>
    public let botAlias: String?
    /// <p>The name of the bot that contains the session data.</p>
    public let botName: String?
    /// <p>The identifier of the user associated with the session data.</p>
    public let userId: String?

    public init (
        botAlias: String? = nil,
        botName: String? = nil,
        userId: String? = nil
    )
    {
        self.botAlias = botAlias
        self.botName = botName
        self.userId = userId
    }
}

struct DeleteSessionInputBody: Equatable {
}

extension DeleteSessionInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteSessionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteSessionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteSessionOutputError: Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case internalFailureException(InternalFailureException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteSessionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteSessionOutputResponse(botAlias: \(String(describing: botAlias)), botName: \(String(describing: botName)), sessionId: \(String(describing: sessionId)), userId: \(String(describing: userId)))"}
}

extension DeleteSessionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteSessionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.botAlias = output.botAlias
            self.botName = output.botName
            self.sessionId = output.sessionId
            self.userId = output.userId
        } else {
            self.botAlias = nil
            self.botName = nil
            self.sessionId = nil
            self.userId = nil
        }
    }
}

public struct DeleteSessionOutputResponse: Equatable {
    /// <p>The alias in use for the bot associated with the session data.</p>
    public let botAlias: String?
    /// <p>The name of the bot associated with the session data.</p>
    public let botName: String?
    /// <p>The unique identifier for the session.</p>
    public let sessionId: String?
    /// <p>The ID of the client application user.</p>
    public let userId: String?

    public init (
        botAlias: String? = nil,
        botName: String? = nil,
        sessionId: String? = nil,
        userId: String? = nil
    )
    {
        self.botAlias = botAlias
        self.botName = botName
        self.sessionId = sessionId
        self.userId = userId
    }
}

struct DeleteSessionOutputResponseBody: Equatable {
    public let botName: String?
    public let botAlias: String?
    public let userId: String?
    public let sessionId: String?
}

extension DeleteSessionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case botAlias
        case botName
        case sessionId
        case userId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .botName)
        botName = botNameDecoded
        let botAliasDecoded = try containerValues.decodeIfPresent(String.self, forKey: .botAlias)
        botAlias = botAliasDecoded
        let userIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userId)
        userId = userIdDecoded
        let sessionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sessionId)
        sessionId = sessionIdDecoded
    }
}

extension DependencyFailedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DependencyFailedException(message: \(String(describing: message)))"}
}

extension DependencyFailedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DependencyFailedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p> One of the dependencies, such as AWS Lambda or Amazon Polly, threw an
///       exception. For example, </p>
///          <ul>
///             <li>
///                <p>If Amazon Lex does not have sufficient permissions to call a Lambda
///           function.</p>
///             </li>
///             <li>
///                <p>If a Lambda function takes longer than 30 seconds to
///           execute.</p>
///             </li>
///             <li>
///                <p>If a fulfillment Lambda function returns a <code>Delegate</code>
///           dialog action without removing any slot values.</p>
///             </li>
///          </ul>
public struct DependencyFailedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DependencyFailedExceptionBody: Equatable {
    public let message: String?
}

extension DependencyFailedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DialogAction: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case fulfillmentState
        case intentName
        case message
        case messageFormat
        case slotToElicit
        case slots
        case type
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fulfillmentState = fulfillmentState {
            try encodeContainer.encode(fulfillmentState.rawValue, forKey: .fulfillmentState)
        }
        if let intentName = intentName {
            try encodeContainer.encode(intentName, forKey: .intentName)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let messageFormat = messageFormat {
            try encodeContainer.encode(messageFormat.rawValue, forKey: .messageFormat)
        }
        if let slotToElicit = slotToElicit {
            try encodeContainer.encode(slotToElicit, forKey: .slotToElicit)
        }
        if let slots = slots {
            var slotsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .slots)
            for (dictKey0, stringmap0) in slots {
                try slotsContainer.encode(stringmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(DialogActionType.self, forKey: .type)
        type = typeDecoded
        let intentNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .intentName)
        intentName = intentNameDecoded
        let slotsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .slots)
        var slotsDecoded0: [String:String]? = nil
        if let slotsContainer = slotsContainer {
            slotsDecoded0 = [String:String]()
            for (key0, string0) in slotsContainer {
                if let string0 = string0 {
                    slotsDecoded0?[key0] = string0
                }
            }
        }
        slots = slotsDecoded0
        let slotToElicitDecoded = try containerValues.decodeIfPresent(String.self, forKey: .slotToElicit)
        slotToElicit = slotToElicitDecoded
        let fulfillmentStateDecoded = try containerValues.decodeIfPresent(FulfillmentState.self, forKey: .fulfillmentState)
        fulfillmentState = fulfillmentStateDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let messageFormatDecoded = try containerValues.decodeIfPresent(MessageFormatType.self, forKey: .messageFormat)
        messageFormat = messageFormatDecoded
    }
}

extension DialogAction: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DialogAction(fulfillmentState: \(String(describing: fulfillmentState)), intentName: \(String(describing: intentName)), message: \(String(describing: message)), messageFormat: \(String(describing: messageFormat)), slotToElicit: \(String(describing: slotToElicit)), slots: \(String(describing: slots)), type: \(String(describing: type)))"}
}

/// <p>Describes the next action that the bot should take in its interaction
///       with the user and provides information about the context in which the
///       action takes place. Use the <code>DialogAction</code> data type to set the
///       interaction to a specific state, or to return the interaction to a
///       previous state.</p>
public struct DialogAction: Equatable {
    /// <p>The fulfillment state of the intent. The possible values are:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>Failed</code> - The Lambda function associated with the
    ///           intent failed to fulfill the intent.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Fulfilled</code> - The intent has fulfilled by the Lambda
    ///           function associated with the intent. </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>ReadyForFulfillment</code> - All of the information
    ///           necessary for the intent is present and the intent ready to be
    ///           fulfilled by the client application.</p>
    ///             </li>
    ///          </ul>
    public let fulfillmentState: FulfillmentState?
    /// <p>The name of the intent.</p>
    public let intentName: String?
    /// <p>The message that should be shown to the user. If you don't specify a
    ///       message, Amazon Lex will use the message configured for the intent.</p>
    public let message: String?
    /// <ul>
    ///             <li>
    ///                <p>
    ///                   <code>PlainText</code> - The message contains plain UTF-8
    ///           text.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>CustomPayload</code> - The message is a custom format for
    ///           the client.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>SSML</code> - The message contains text formatted for voice
    ///           output.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Composite</code> - The message contains an escaped JSON
    ///           object containing one or more messages. For more information, see
    ///             <a href="https://docs.aws.amazon.com/lex/latest/dg/howitworks-manage-prompts.html">Message Groups</a>. </p>
    ///             </li>
    ///          </ul>
    public let messageFormat: MessageFormatType?
    /// <p>The name of the slot that should be elicited from the user.</p>
    public let slotToElicit: String?
    /// <p>Map of the slots that have been gathered and their values. </p>
    public let slots: [String:String]?
    /// <p>The next action that the bot should take in its interaction with the
    ///       user. The possible values are:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>ConfirmIntent</code> - The next action is asking the user if
    ///           the intent is complete and ready to be fulfilled. This is a yes/no
    ///           question such as "Place the order?"</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Close</code> - Indicates that the there will not be a
    ///           response from the user. For example, the statement "Your order has
    ///           been placed" does not require a response.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Delegate</code> - The next action is determined by
    ///           Amazon Lex.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>ElicitIntent</code> - The next action is to determine the
    ///           intent that the user wants to fulfill.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>ElicitSlot</code> - The next action is to elicit a slot
    ///           value from the user.</p>
    ///             </li>
    ///          </ul>
    public let type: DialogActionType?

    public init (
        fulfillmentState: FulfillmentState? = nil,
        intentName: String? = nil,
        message: String? = nil,
        messageFormat: MessageFormatType? = nil,
        slotToElicit: String? = nil,
        slots: [String:String]? = nil,
        type: DialogActionType? = nil
    )
    {
        self.fulfillmentState = fulfillmentState
        self.intentName = intentName
        self.message = message
        self.messageFormat = messageFormat
        self.slotToElicit = slotToElicit
        self.slots = slots
        self.type = type
    }
}

public enum DialogActionType {
    case close
    case confirmIntent
    case delegate
    case elicitIntent
    case elicitSlot
    case sdkUnknown(String)
}

extension DialogActionType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DialogActionType] {
        return [
            .close,
            .confirmIntent,
            .delegate,
            .elicitIntent,
            .elicitSlot,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .close: return "Close"
        case .confirmIntent: return "ConfirmIntent"
        case .delegate: return "Delegate"
        case .elicitIntent: return "ElicitIntent"
        case .elicitSlot: return "ElicitSlot"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DialogActionType(rawValue: rawValue) ?? DialogActionType.sdkUnknown(rawValue)
    }
}

public enum DialogState {
    case confirmIntent
    case elicitIntent
    case elicitSlot
    case failed
    case fulfilled
    case readyForFulfillment
    case sdkUnknown(String)
}

extension DialogState : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DialogState] {
        return [
            .confirmIntent,
            .elicitIntent,
            .elicitSlot,
            .failed,
            .fulfilled,
            .readyForFulfillment,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .confirmIntent: return "ConfirmIntent"
        case .elicitIntent: return "ElicitIntent"
        case .elicitSlot: return "ElicitSlot"
        case .failed: return "Failed"
        case .fulfilled: return "Fulfilled"
        case .readyForFulfillment: return "ReadyForFulfillment"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DialogState(rawValue: rawValue) ?? DialogState.sdkUnknown(rawValue)
    }
}

public enum FulfillmentState {
    case failed
    case fulfilled
    case readyForFulfillment
    case sdkUnknown(String)
}

extension FulfillmentState : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [FulfillmentState] {
        return [
            .failed,
            .fulfilled,
            .readyForFulfillment,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .failed: return "Failed"
        case .fulfilled: return "Fulfilled"
        case .readyForFulfillment: return "ReadyForFulfillment"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = FulfillmentState(rawValue: rawValue) ?? FulfillmentState.sdkUnknown(rawValue)
    }
}

extension GenericAttachment: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attachmentLinkUrl
        case buttons
        case imageUrl
        case subTitle
        case title
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attachmentLinkUrl = attachmentLinkUrl {
            try encodeContainer.encode(attachmentLinkUrl, forKey: .attachmentLinkUrl)
        }
        if let buttons = buttons {
            var buttonsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .buttons)
            for listofbuttons0 in buttons {
                try buttonsContainer.encode(listofbuttons0)
            }
        }
        if let imageUrl = imageUrl {
            try encodeContainer.encode(imageUrl, forKey: .imageUrl)
        }
        if let subTitle = subTitle {
            try encodeContainer.encode(subTitle, forKey: .subTitle)
        }
        if let title = title {
            try encodeContainer.encode(title, forKey: .title)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let titleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .title)
        title = titleDecoded
        let subTitleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subTitle)
        subTitle = subTitleDecoded
        let attachmentLinkUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .attachmentLinkUrl)
        attachmentLinkUrl = attachmentLinkUrlDecoded
        let imageUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .imageUrl)
        imageUrl = imageUrlDecoded
        let buttonsContainer = try containerValues.decodeIfPresent([Button?].self, forKey: .buttons)
        var buttonsDecoded0:[Button]? = nil
        if let buttonsContainer = buttonsContainer {
            buttonsDecoded0 = [Button]()
            for structure0 in buttonsContainer {
                if let structure0 = structure0 {
                    buttonsDecoded0?.append(structure0)
                }
            }
        }
        buttons = buttonsDecoded0
    }
}

extension GenericAttachment: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GenericAttachment(attachmentLinkUrl: \(String(describing: attachmentLinkUrl)), buttons: \(String(describing: buttons)), imageUrl: \(String(describing: imageUrl)), subTitle: \(String(describing: subTitle)), title: \(String(describing: title)))"}
}

/// <p>Represents an option rendered to the user when a prompt is shown. It
///       could be an image, a button, a link, or text. </p>
public struct GenericAttachment: Equatable {
    /// <p>The URL of an attachment to the response card.</p>
    public let attachmentLinkUrl: String?
    /// <p>The list of options to show to the user.</p>
    public let buttons: [Button]?
    /// <p>The URL of an image that is displayed to the user.</p>
    public let imageUrl: String?
    /// <p>The subtitle shown below the title.</p>
    public let subTitle: String?
    /// <p>The title of the option.</p>
    public let title: String?

    public init (
        attachmentLinkUrl: String? = nil,
        buttons: [Button]? = nil,
        imageUrl: String? = nil,
        subTitle: String? = nil,
        title: String? = nil
    )
    {
        self.attachmentLinkUrl = attachmentLinkUrl
        self.buttons = buttons
        self.imageUrl = imageUrl
        self.subTitle = subTitle
        self.title = title
    }
}

extension GetSessionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSessionInput(botAlias: \(String(describing: botAlias)), botName: \(String(describing: botName)), checkpointLabelFilter: \(String(describing: checkpointLabelFilter)), userId: \(String(describing: userId)))"}
}

extension GetSessionInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetSessionInputHeadersMiddleware: Middleware {
    public let id: String = "GetSessionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSessionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSessionInput>
    public typealias MOutput = OperationOutput<GetSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSessionOutputError>
}

public struct GetSessionInputQueryItemMiddleware: Middleware {
    public let id: String = "GetSessionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSessionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let checkpointLabelFilter = input.operationInput.checkpointLabelFilter {
            let checkpointLabelFilterQueryItem = URLQueryItem(name: "checkpointLabelFilter".urlPercentEncoding(), value: String(checkpointLabelFilter).urlPercentEncoding())
            input.builder.withQueryItem(checkpointLabelFilterQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSessionInput>
    public typealias MOutput = OperationOutput<GetSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSessionOutputError>
}

public struct GetSessionInput: Equatable {
    /// <p>The alias in use for the bot that contains the session data.</p>
    public let botAlias: String?
    /// <p>The name of the bot that contains the session data.</p>
    public let botName: String?
    /// <p>A string used to filter the intents returned in the
    ///         <code>recentIntentSummaryView</code> structure. </p>
    ///          <p>When you specify a filter, only intents with their
    ///         <code>checkpointLabel</code> field set to that string are
    ///       returned.</p>
    public let checkpointLabelFilter: String?
    /// <p>The ID of the client application user. Amazon Lex uses this to identify a
    ///       user's conversation with your bot. </p>
    public let userId: String?

    public init (
        botAlias: String? = nil,
        botName: String? = nil,
        checkpointLabelFilter: String? = nil,
        userId: String? = nil
    )
    {
        self.botAlias = botAlias
        self.botName = botName
        self.checkpointLabelFilter = checkpointLabelFilter
        self.userId = userId
    }
}

struct GetSessionInputBody: Equatable {
}

extension GetSessionInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetSessionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSessionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetSessionOutputError: Equatable {
    case badRequestException(BadRequestException)
    case internalFailureException(InternalFailureException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSessionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSessionOutputResponse(activeContexts: \(String(describing: activeContexts)), dialogAction: \(String(describing: dialogAction)), recentIntentSummaryView: \(String(describing: recentIntentSummaryView)), sessionAttributes: \(String(describing: sessionAttributes)), sessionId: \(String(describing: sessionId)))"}
}

extension GetSessionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetSessionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.activeContexts = output.activeContexts
            self.dialogAction = output.dialogAction
            self.recentIntentSummaryView = output.recentIntentSummaryView
            self.sessionAttributes = output.sessionAttributes
            self.sessionId = output.sessionId
        } else {
            self.activeContexts = nil
            self.dialogAction = nil
            self.recentIntentSummaryView = nil
            self.sessionAttributes = nil
            self.sessionId = nil
        }
    }
}

public struct GetSessionOutputResponse: Equatable {
    /// <p>A list of active contexts for the session. A context can be set when
    ///       an intent is fulfilled or by calling the <code>PostContent</code>,
    ///         <code>PostText</code>, or <code>PutSession</code> operation.</p>
    ///          <p>You can use a context to control the intents that can follow up an
    ///       intent, or to modify the operation of your application.</p>
    public let activeContexts: [ActiveContext]?
    /// <p>Describes the current state of the bot.</p>
    public let dialogAction: DialogAction?
    /// <p>An array of information about the intents used in the session. The
    ///       array can contain a maximum of three summaries. If more than three intents
    ///       are used in the session, the <code>recentIntentSummaryView</code>
    ///       operation contains information about the last three intents used.</p>
    ///          <p>If you set the <code>checkpointLabelFilter</code> parameter in the
    ///       request, the array contains only the intents with the specified
    ///       label.</p>
    public let recentIntentSummaryView: [IntentSummary]?
    /// <p>Map of key/value pairs representing the session-specific context
    ///       information. It contains application information passed between Amazon Lex and
    ///       a client application.</p>
    public let sessionAttributes: [String:String]?
    /// <p>A unique identifier for the session.</p>
    public let sessionId: String?

    public init (
        activeContexts: [ActiveContext]? = nil,
        dialogAction: DialogAction? = nil,
        recentIntentSummaryView: [IntentSummary]? = nil,
        sessionAttributes: [String:String]? = nil,
        sessionId: String? = nil
    )
    {
        self.activeContexts = activeContexts
        self.dialogAction = dialogAction
        self.recentIntentSummaryView = recentIntentSummaryView
        self.sessionAttributes = sessionAttributes
        self.sessionId = sessionId
    }
}

struct GetSessionOutputResponseBody: Equatable {
    public let recentIntentSummaryView: [IntentSummary]?
    public let sessionAttributes: [String:String]?
    public let sessionId: String?
    public let dialogAction: DialogAction?
    public let activeContexts: [ActiveContext]?
}

extension GetSessionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case activeContexts
        case dialogAction
        case recentIntentSummaryView
        case sessionAttributes
        case sessionId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recentIntentSummaryViewContainer = try containerValues.decodeIfPresent([IntentSummary?].self, forKey: .recentIntentSummaryView)
        var recentIntentSummaryViewDecoded0:[IntentSummary]? = nil
        if let recentIntentSummaryViewContainer = recentIntentSummaryViewContainer {
            recentIntentSummaryViewDecoded0 = [IntentSummary]()
            for structure0 in recentIntentSummaryViewContainer {
                if let structure0 = structure0 {
                    recentIntentSummaryViewDecoded0?.append(structure0)
                }
            }
        }
        recentIntentSummaryView = recentIntentSummaryViewDecoded0
        let sessionAttributesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .sessionAttributes)
        var sessionAttributesDecoded0: [String:String]? = nil
        if let sessionAttributesContainer = sessionAttributesContainer {
            sessionAttributesDecoded0 = [String:String]()
            for (key0, string0) in sessionAttributesContainer {
                if let string0 = string0 {
                    sessionAttributesDecoded0?[key0] = string0
                }
            }
        }
        sessionAttributes = sessionAttributesDecoded0
        let sessionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sessionId)
        sessionId = sessionIdDecoded
        let dialogActionDecoded = try containerValues.decodeIfPresent(DialogAction.self, forKey: .dialogAction)
        dialogAction = dialogActionDecoded
        let activeContextsContainer = try containerValues.decodeIfPresent([ActiveContext?].self, forKey: .activeContexts)
        var activeContextsDecoded0:[ActiveContext]? = nil
        if let activeContextsContainer = activeContextsContainer {
            activeContextsDecoded0 = [ActiveContext]()
            for structure0 in activeContextsContainer {
                if let structure0 = structure0 {
                    activeContextsDecoded0?.append(structure0)
                }
            }
        }
        activeContexts = activeContextsDecoded0
    }
}

extension IntentConfidence: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case score
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if score != 0.0 {
            try encodeContainer.encode(score, forKey: .score)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scoreDecoded = try containerValues.decode(Double.self, forKey: .score)
        score = scoreDecoded
    }
}

extension IntentConfidence: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IntentConfidence(score: \(String(describing: score)))"}
}

/// <p>Provides a score that indicates the confidence that Amazon Lex has that an
///       intent is the one that satisfies the user's intent.</p>
public struct IntentConfidence: Equatable {
    /// <p>A score that indicates how confident Amazon Lex is that an intent satisfies
    ///       the user's intent. Ranges between 0.00 and 1.00. Higher scores indicate
    ///       higher confidence.</p>
    public let score: Double

    public init (
        score: Double = 0.0
    )
    {
        self.score = score
    }
}

extension IntentSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case checkpointLabel
        case confirmationStatus
        case dialogActionType
        case fulfillmentState
        case intentName
        case slotToElicit
        case slots
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let checkpointLabel = checkpointLabel {
            try encodeContainer.encode(checkpointLabel, forKey: .checkpointLabel)
        }
        if let confirmationStatus = confirmationStatus {
            try encodeContainer.encode(confirmationStatus.rawValue, forKey: .confirmationStatus)
        }
        if let dialogActionType = dialogActionType {
            try encodeContainer.encode(dialogActionType.rawValue, forKey: .dialogActionType)
        }
        if let fulfillmentState = fulfillmentState {
            try encodeContainer.encode(fulfillmentState.rawValue, forKey: .fulfillmentState)
        }
        if let intentName = intentName {
            try encodeContainer.encode(intentName, forKey: .intentName)
        }
        if let slotToElicit = slotToElicit {
            try encodeContainer.encode(slotToElicit, forKey: .slotToElicit)
        }
        if let slots = slots {
            var slotsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .slots)
            for (dictKey0, stringmap0) in slots {
                try slotsContainer.encode(stringmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let intentNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .intentName)
        intentName = intentNameDecoded
        let checkpointLabelDecoded = try containerValues.decodeIfPresent(String.self, forKey: .checkpointLabel)
        checkpointLabel = checkpointLabelDecoded
        let slotsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .slots)
        var slotsDecoded0: [String:String]? = nil
        if let slotsContainer = slotsContainer {
            slotsDecoded0 = [String:String]()
            for (key0, string0) in slotsContainer {
                if let string0 = string0 {
                    slotsDecoded0?[key0] = string0
                }
            }
        }
        slots = slotsDecoded0
        let confirmationStatusDecoded = try containerValues.decodeIfPresent(ConfirmationStatus.self, forKey: .confirmationStatus)
        confirmationStatus = confirmationStatusDecoded
        let dialogActionTypeDecoded = try containerValues.decodeIfPresent(DialogActionType.self, forKey: .dialogActionType)
        dialogActionType = dialogActionTypeDecoded
        let fulfillmentStateDecoded = try containerValues.decodeIfPresent(FulfillmentState.self, forKey: .fulfillmentState)
        fulfillmentState = fulfillmentStateDecoded
        let slotToElicitDecoded = try containerValues.decodeIfPresent(String.self, forKey: .slotToElicit)
        slotToElicit = slotToElicitDecoded
    }
}

extension IntentSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IntentSummary(checkpointLabel: \(String(describing: checkpointLabel)), confirmationStatus: \(String(describing: confirmationStatus)), dialogActionType: \(String(describing: dialogActionType)), fulfillmentState: \(String(describing: fulfillmentState)), intentName: \(String(describing: intentName)), slotToElicit: \(String(describing: slotToElicit)), slots: \(String(describing: slots)))"}
}

/// <p>Provides information about the state of an intent. You can use this
///       information to get the current state of an intent so that you can process
///       the intent, or so that you can return the intent to its previous
///       state.</p>
public struct IntentSummary: Equatable {
    /// <p>A user-defined label that identifies a particular intent. You can use
    ///       this label to return to a previous intent. </p>
    ///          <p>Use the <code>checkpointLabelFilter</code> parameter of the
    ///         <code>GetSessionRequest</code> operation to filter the intents returned
    ///       by the operation to those with only the specified label.</p>
    public let checkpointLabel: String?
    /// <p>The status of the intent after the user responds to the confirmation
    ///       prompt. If the user confirms the intent, Amazon Lex sets this field to
    ///         <code>Confirmed</code>. If the user denies the intent, Amazon Lex sets this
    ///       value to <code>Denied</code>. The possible values are:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>Confirmed</code> - The user has responded "Yes" to the
    ///           confirmation prompt, confirming that the intent is complete and that
    ///           it is ready to be fulfilled.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Denied</code> - The user has responded "No" to the
    ///           confirmation prompt.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>None</code> - The user has never been prompted for
    ///           confirmation; or, the user was prompted but did not confirm or deny
    ///           the prompt.</p>
    ///             </li>
    ///          </ul>
    public let confirmationStatus: ConfirmationStatus?
    /// <p>The next action that the bot should take in its interaction with the
    ///       user. The possible values are:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>ConfirmIntent</code> - The next action is asking the user if
    ///           the intent is complete and ready to be fulfilled. This is a yes/no
    ///           question such as "Place the order?"</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Close</code> - Indicates that the there will not be a
    ///           response from the user. For example, the statement "Your order has
    ///           been placed" does not require a response.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>ElicitIntent</code> - The next action is to determine the
    ///           intent that the user wants to fulfill.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>ElicitSlot</code> - The next action is to elicit a slot
    ///           value from the user.</p>
    ///             </li>
    ///          </ul>
    public let dialogActionType: DialogActionType?
    /// <p>The fulfillment state of the intent. The possible values are:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>Failed</code> - The Lambda function associated with the
    ///           intent failed to fulfill the intent.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Fulfilled</code> - The intent has fulfilled by the Lambda
    ///           function associated with the intent. </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>ReadyForFulfillment</code> - All of the information
    ///           necessary for the intent is present and the intent ready to be
    ///           fulfilled by the client application.</p>
    ///             </li>
    ///          </ul>
    public let fulfillmentState: FulfillmentState?
    /// <p>The name of the intent.</p>
    public let intentName: String?
    /// <p>The next slot to elicit from the user. If there is not slot to elicit,
    ///       the field is blank.</p>
    public let slotToElicit: String?
    /// <p>Map of the slots that have been gathered and their values. </p>
    public let slots: [String:String]?

    public init (
        checkpointLabel: String? = nil,
        confirmationStatus: ConfirmationStatus? = nil,
        dialogActionType: DialogActionType? = nil,
        fulfillmentState: FulfillmentState? = nil,
        intentName: String? = nil,
        slotToElicit: String? = nil,
        slots: [String:String]? = nil
    )
    {
        self.checkpointLabel = checkpointLabel
        self.confirmationStatus = confirmationStatus
        self.dialogActionType = dialogActionType
        self.fulfillmentState = fulfillmentState
        self.intentName = intentName
        self.slotToElicit = slotToElicit
        self.slots = slots
    }
}

extension InternalFailureException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalFailureException(message: \(String(describing: message)))"}
}

extension InternalFailureException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InternalFailureExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Internal service error. Retry the call.</p>
public struct InternalFailureException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InternalFailureExceptionBody: Equatable {
    public let message: String?
}

extension InternalFailureExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LimitExceededException(message: \(String(describing: message)), retryAfterSeconds: \(String(describing: retryAfterSeconds)))"}
}

extension LimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.retryAfterSeconds = retryAfterSecondsHeaderValue
        } else {
            self.retryAfterSeconds = nil
        }
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Exceeded a limit.</p>
public struct LimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    public var retryAfterSeconds: String?

    public init (
        message: String? = nil,
        retryAfterSeconds: String? = nil
    )
    {
        self.message = message
        self.retryAfterSeconds = retryAfterSeconds
    }
}

struct LimitExceededExceptionBody: Equatable {
    public let message: String?
}

extension LimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LoopDetectedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LoopDetectedException(message: \(String(describing: message)))"}
}

extension LoopDetectedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: LoopDetectedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>This exception is not used.</p>
public struct LoopDetectedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct LoopDetectedExceptionBody: Equatable {
    public let message: String?
}

extension LoopDetectedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum MessageFormatType {
    case composite
    case customPayload
    case plainText
    case ssml
    case sdkUnknown(String)
}

extension MessageFormatType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [MessageFormatType] {
        return [
            .composite,
            .customPayload,
            .plainText,
            .ssml,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .composite: return "Composite"
        case .customPayload: return "CustomPayload"
        case .plainText: return "PlainText"
        case .ssml: return "SSML"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = MessageFormatType(rawValue: rawValue) ?? MessageFormatType.sdkUnknown(rawValue)
    }
}

extension NotAcceptableException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NotAcceptableException(message: \(String(describing: message)))"}
}

extension NotAcceptableException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: NotAcceptableExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The accept header in the request does not have a valid value.</p>
public struct NotAcceptableException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct NotAcceptableExceptionBody: Equatable {
    public let message: String?
}

extension NotAcceptableExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NotFoundException(message: \(String(describing: message)))"}
}

extension NotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: NotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The resource (such as the Amazon Lex bot or an alias) that is referred
///       to is not found.</p>
public struct NotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct NotFoundExceptionBody: Equatable {
    public let message: String?
}

extension NotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct PostContentInputBodyMiddleware: Middleware {
    public let id: String = "PostContentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PostContentInput>,
                  next: H) -> Swift.Result<OperationOutput<PostContentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let inputStream = input.operationInput.inputStream {
            let data = inputStream
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PostContentInput>
    public typealias MOutput = OperationOutput<PostContentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PostContentOutputError>
}

extension PostContentInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PostContentInput(accept: \(String(describing: accept)), activeContexts: \(String(describing: activeContexts)), botAlias: \(String(describing: botAlias)), botName: \(String(describing: botName)), contentType: \(String(describing: contentType)), inputStream: \(String(describing: inputStream)), requestAttributes: \(String(describing: requestAttributes)), sessionAttributes: \(String(describing: sessionAttributes)), userId: \(String(describing: userId)))"}
}

extension PostContentInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case inputStream
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inputStream = inputStream {
            try encodeContainer.encode(inputStream.base64EncodedString(), forKey: .inputStream)
        }
    }
}

public struct PostContentInputHeadersMiddleware: Middleware {
    public let id: String = "PostContentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PostContentInput>,
                  next: H) -> Swift.Result<OperationOutput<PostContentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let accept = input.operationInput.accept {
            input.builder.withHeader(name: "Accept", value: String(accept))
        }
        if let activeContexts = input.operationInput.activeContexts {
            do {
                let base64EncodedValue = try activeContexts.base64EncodedString()
                input.builder.withHeader(name: "x-amz-lex-active-contexts", value: String(base64EncodedValue))
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        if let contentType = input.operationInput.contentType {
            input.builder.withHeader(name: "Content-Type", value: String(contentType))
        }
        if let requestAttributes = input.operationInput.requestAttributes {
            do {
                let base64EncodedValue = try requestAttributes.base64EncodedString()
                input.builder.withHeader(name: "x-amz-lex-request-attributes", value: String(base64EncodedValue))
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        if let sessionAttributes = input.operationInput.sessionAttributes {
            do {
                let base64EncodedValue = try sessionAttributes.base64EncodedString()
                input.builder.withHeader(name: "x-amz-lex-session-attributes", value: String(base64EncodedValue))
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PostContentInput>
    public typealias MOutput = OperationOutput<PostContentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PostContentOutputError>
}

public struct PostContentInputQueryItemMiddleware: Middleware {
    public let id: String = "PostContentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PostContentInput>,
                  next: H) -> Swift.Result<OperationOutput<PostContentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PostContentInput>
    public typealias MOutput = OperationOutput<PostContentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PostContentOutputError>
}

public struct PostContentInput: Equatable {
    /// <p> You pass this value as the <code>Accept</code> HTTP header. </p>
    ///          <p> The message Amazon Lex returns in the response can be either text or
    ///       speech based on the <code>Accept</code> HTTP header value in the request. </p>
    ///          <ul>
    ///             <li>
    ///                <p> If the value is <code>text/plain; charset=utf-8</code>, Amazon Lex
    ///           returns text in the response. </p>
    ///             </li>
    ///             <li>
    ///                <p> If the value begins with <code>audio/</code>, Amazon Lex returns
    ///           speech in the response. Amazon Lex uses Amazon Polly to generate the speech
    ///           (using the configuration you specified in the <code>Accept</code>
    ///           header). For example, if you specify <code>audio/mpeg</code> as the
    ///           value, Amazon Lex returns speech in the MPEG format.</p>
    ///             </li>
    ///             <li>
    ///                <p>If the value is <code>audio/pcm</code>, the speech returned is
    ///             <code>audio/pcm</code> in 16-bit, little endian format.
    ///           </p>
    ///             </li>
    ///             <li>
    ///                <p>The following are the accepted values:</p>
    ///                <ul>
    ///                   <li>
    ///                      <p>audio/mpeg</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>audio/ogg</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>audio/pcm</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>text/plain; charset=utf-8</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>audio/* (defaults to mpeg)</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///          </ul>
    public let accept: String?
    /// <p>A list of contexts active for the request. A context can be activated
    ///       when a previous intent is fulfilled, or by including the context in the
    ///       request,</p>
    ///          <p>If you don't specify a list of contexts, Amazon Lex will use the current
    ///       list of contexts for the session. If you specify an empty list, all
    ///       contexts for the session are cleared.</p>
    public let activeContexts: String?
    /// <p>Alias of the Amazon Lex bot.</p>
    public let botAlias: String?
    /// <p>Name of the Amazon Lex bot.</p>
    public let botName: String?
    /// <p> You pass this value as the <code>Content-Type</code> HTTP header. </p>
    ///          <p> Indicates the audio format or text. The header value must start with
    ///       one of the following prefixes: </p>
    ///          <ul>
    ///             <li>
    ///                <p>PCM format, audio data must be in little-endian byte order.</p>
    ///                <ul>
    ///                   <li>
    ///                      <p>audio/l16; rate=16000; channels=1</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>audio/x-l16; sample-rate=16000; channel-count=1</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>audio/lpcm; sample-rate=8000; sample-size-bits=16;
    ///               channel-count=1; is-big-endian=false </p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <p>Opus format</p>
    ///                <ul>
    ///                   <li>
    ///                      <p>audio/x-cbr-opus-with-preamble; preamble-size=0;
    ///               bit-rate=256000; frame-size-milliseconds=4</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <p>Text format</p>
    ///                <ul>
    ///                   <li>
    ///                      <p>text/plain; charset=utf-8</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///          </ul>
    public let contentType: String?
    /// <p> User input in PCM or Opus audio format or text format as described in
    ///       the <code>Content-Type</code> HTTP header. </p>
    ///          <p>You can stream audio data to Amazon Lex or you can create a local buffer
    ///       that captures all of the audio data before sending. In general, you get
    ///       better performance if you stream audio data rather than buffering the data
    ///       locally.</p>
    public let inputStream: Data?
    /// <p>You pass this value as the <code>x-amz-lex-request-attributes</code>
    ///       HTTP header.</p>
    ///          <p>Request-specific information passed between Amazon Lex and a client
    ///       application. The value must be a JSON serialized and base64 encoded map
    ///       with string keys and values. The total size of the
    ///         <code>requestAttributes</code> and <code>sessionAttributes</code>
    ///       headers is limited to 12 KB.</p>
    ///          <p>The namespace <code>x-amz-lex:</code> is reserved for special
    ///       attributes. Don't create any request attributes with the prefix
    ///         <code>x-amz-lex:</code>.</p>
    ///          <p>For more information, see <a href="https://docs.aws.amazon.com/lex/latest/dg/context-mgmt.html#context-mgmt-request-attribs">Setting Request Attributes</a>.</p>
    public let requestAttributes: String?
    /// <p>You pass this value as the <code>x-amz-lex-session-attributes</code>
    ///       HTTP header.</p>
    ///          <p>Application-specific information passed between Amazon Lex and a client
    ///       application. The value must be a JSON serialized and base64 encoded map
    ///       with string keys and values. The total size of the
    ///         <code>sessionAttributes</code> and <code>requestAttributes</code>
    ///       headers is limited to 12 KB.</p>
    ///          <p>For more information, see <a href="https://docs.aws.amazon.com/lex/latest/dg/context-mgmt.html#context-mgmt-session-attribs">Setting Session Attributes</a>.</p>
    public let sessionAttributes: String?
    /// <p>The ID of the client application user. Amazon Lex uses this to identify a
    ///       user's conversation with your bot. At runtime, each request must contain
    ///       the <code>userID</code> field.</p>
    ///          <p>To decide the user ID to use for your application, consider the
    ///       following factors.</p>
    ///          <ul>
    ///             <li>
    ///                <p>The <code>userID</code> field must not contain any personally
    ///           identifiable information of the user, for example, name, personal
    ///           identification numbers, or other end user personal information.</p>
    ///             </li>
    ///             <li>
    ///                <p>If you want a user to start a conversation on one device and
    ///           continue on another device, use a user-specific identifier.</p>
    ///             </li>
    ///             <li>
    ///                <p>If you want the same user to be able to have two independent
    ///           conversations on two different devices, choose a device-specific
    ///           identifier.</p>
    ///             </li>
    ///             <li>
    ///                <p>A user can't have two independent conversations with two different
    ///           versions of the same bot. For example, a user can't have a
    ///           conversation with the PROD and BETA versions of the same bot. If you
    ///           anticipate that a user will need to have conversation with two
    ///           different versions, for example, while testing, include the bot alias
    ///           in the user ID to separate the two conversations.</p>
    ///             </li>
    ///          </ul>
    public let userId: String?

    public init (
        accept: String? = nil,
        activeContexts: String? = nil,
        botAlias: String? = nil,
        botName: String? = nil,
        contentType: String? = nil,
        inputStream: Data? = nil,
        requestAttributes: String? = nil,
        sessionAttributes: String? = nil,
        userId: String? = nil
    )
    {
        self.accept = accept
        self.activeContexts = activeContexts
        self.botAlias = botAlias
        self.botName = botName
        self.contentType = contentType
        self.inputStream = inputStream
        self.requestAttributes = requestAttributes
        self.sessionAttributes = sessionAttributes
        self.userId = userId
    }
}

struct PostContentInputBody: Equatable {
    public let inputStream: Data?
}

extension PostContentInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case inputStream
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputStreamDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .inputStream)
        inputStream = inputStreamDecoded
    }
}

extension PostContentOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PostContentOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadGatewayException" : self = .badGatewayException(try BadGatewayException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DependencyFailedException" : self = .dependencyFailedException(try DependencyFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LoopDetectedException" : self = .loopDetectedException(try LoopDetectedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAcceptableException" : self = .notAcceptableException(try NotAcceptableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestTimeoutException" : self = .requestTimeoutException(try RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedMediaTypeException" : self = .unsupportedMediaTypeException(try UnsupportedMediaTypeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PostContentOutputError: Equatable {
    case badGatewayException(BadGatewayException)
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case dependencyFailedException(DependencyFailedException)
    case internalFailureException(InternalFailureException)
    case limitExceededException(LimitExceededException)
    case loopDetectedException(LoopDetectedException)
    case notAcceptableException(NotAcceptableException)
    case notFoundException(NotFoundException)
    case requestTimeoutException(RequestTimeoutException)
    case unsupportedMediaTypeException(UnsupportedMediaTypeException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PostContentOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PostContentOutputResponse(activeContexts: \(String(describing: activeContexts)), alternativeIntents: \(String(describing: alternativeIntents)), audioStream: \(String(describing: audioStream)), botVersion: \(String(describing: botVersion)), contentType: \(String(describing: contentType)), dialogState: \(String(describing: dialogState)), encodedInputTranscript: \(String(describing: encodedInputTranscript)), encodedMessage: \(String(describing: encodedMessage)), inputTranscript: \(String(describing: inputTranscript)), intentName: \(String(describing: intentName)), message: \(String(describing: message)), messageFormat: \(String(describing: messageFormat)), nluIntentConfidence: \(String(describing: nluIntentConfidence)), sentimentResponse: \(String(describing: sentimentResponse)), sessionAttributes: \(String(describing: sessionAttributes)), sessionId: \(String(describing: sessionId)), slotToElicit: \(String(describing: slotToElicit)), slots: \(String(describing: slots)))"}
}

extension PostContentOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if let activeContextsHeaderValue = httpResponse.headers.value(for: "x-amz-lex-active-contexts") {
            self.activeContexts = try activeContextsHeaderValue.base64DecodedString()
        } else {
            self.activeContexts = nil
        }
        if let alternativeIntentsHeaderValue = httpResponse.headers.value(for: "x-amz-lex-alternative-intents") {
            self.alternativeIntents = try alternativeIntentsHeaderValue.base64DecodedString()
        } else {
            self.alternativeIntents = nil
        }
        if let botVersionHeaderValue = httpResponse.headers.value(for: "x-amz-lex-bot-version") {
            self.botVersion = botVersionHeaderValue
        } else {
            self.botVersion = nil
        }
        if let contentTypeHeaderValue = httpResponse.headers.value(for: "Content-Type") {
            self.contentType = contentTypeHeaderValue
        } else {
            self.contentType = nil
        }
        if let dialogStateHeaderValue = httpResponse.headers.value(for: "x-amz-lex-dialog-state") {
            self.dialogState = DialogState(rawValue: dialogStateHeaderValue)
        } else {
            self.dialogState = nil
        }
        if let encodedInputTranscriptHeaderValue = httpResponse.headers.value(for: "x-amz-lex-encoded-input-transcript") {
            self.encodedInputTranscript = encodedInputTranscriptHeaderValue
        } else {
            self.encodedInputTranscript = nil
        }
        if let encodedMessageHeaderValue = httpResponse.headers.value(for: "x-amz-lex-encoded-message") {
            self.encodedMessage = encodedMessageHeaderValue
        } else {
            self.encodedMessage = nil
        }
        if let inputTranscriptHeaderValue = httpResponse.headers.value(for: "x-amz-lex-input-transcript") {
            self.inputTranscript = inputTranscriptHeaderValue
        } else {
            self.inputTranscript = nil
        }
        if let intentNameHeaderValue = httpResponse.headers.value(for: "x-amz-lex-intent-name") {
            self.intentName = intentNameHeaderValue
        } else {
            self.intentName = nil
        }
        if let messageHeaderValue = httpResponse.headers.value(for: "x-amz-lex-message") {
            self.message = messageHeaderValue
        } else {
            self.message = nil
        }
        if let messageFormatHeaderValue = httpResponse.headers.value(for: "x-amz-lex-message-format") {
            self.messageFormat = MessageFormatType(rawValue: messageFormatHeaderValue)
        } else {
            self.messageFormat = nil
        }
        if let nluIntentConfidenceHeaderValue = httpResponse.headers.value(for: "x-amz-lex-nlu-intent-confidence") {
            self.nluIntentConfidence = try nluIntentConfidenceHeaderValue.base64DecodedString()
        } else {
            self.nluIntentConfidence = nil
        }
        if let sentimentResponseHeaderValue = httpResponse.headers.value(for: "x-amz-lex-sentiment") {
            self.sentimentResponse = sentimentResponseHeaderValue
        } else {
            self.sentimentResponse = nil
        }
        if let sessionAttributesHeaderValue = httpResponse.headers.value(for: "x-amz-lex-session-attributes") {
            self.sessionAttributes = try sessionAttributesHeaderValue.base64DecodedString()
        } else {
            self.sessionAttributes = nil
        }
        if let sessionIdHeaderValue = httpResponse.headers.value(for: "x-amz-lex-session-id") {
            self.sessionId = sessionIdHeaderValue
        } else {
            self.sessionId = nil
        }
        if let slotToElicitHeaderValue = httpResponse.headers.value(for: "x-amz-lex-slot-to-elicit") {
            self.slotToElicit = slotToElicitHeaderValue
        } else {
            self.slotToElicit = nil
        }
        if let slotsHeaderValue = httpResponse.headers.value(for: "x-amz-lex-slots") {
            self.slots = try slotsHeaderValue.base64DecodedString()
        } else {
            self.slots = nil
        }
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            self.audioStream = unwrappedData
        } else {
            self.audioStream = nil
        }
    }
}

public struct PostContentOutputResponse: Equatable {
    /// <p>A list of active contexts for the session. A context can be set when
    ///       an intent is fulfilled or by calling the <code>PostContent</code>,
    ///         <code>PostText</code>, or <code>PutSession</code> operation.</p>
    ///          <p>You can use a context to control the intents that can follow up an
    ///       intent, or to modify the operation of your application.</p>
    public let activeContexts: String?
    /// <p>One to four alternative intents that may be applicable to the user's
    ///       intent.</p>
    ///          <p>Each alternative includes a score that indicates how confident Amazon Lex
    ///       is that the intent matches the user's intent. The intents are sorted by
    ///       the confidence score.</p>
    public let alternativeIntents: String?
    /// <p>The prompt (or statement) to convey to the user. This is based on the
    ///       bot configuration and context. For example, if Amazon Lex did not understand
    ///       the user intent, it sends the <code>clarificationPrompt</code> configured
    ///       for the bot. If the intent requires confirmation before taking the
    ///       fulfillment action, it sends the <code>confirmationPrompt</code>. Another
    ///       example: Suppose that the Lambda function successfully fulfilled the
    ///       intent, and sent a message to convey to the user. Then Amazon Lex sends that
    ///       message in the response. </p>
    public let audioStream: Data?
    /// <p>The version of the bot that responded to the conversation. You can use
    ///       this information to help determine if one version of a bot is performing
    ///       better than another version.</p>
    public let botVersion: String?
    /// <p>Content type as specified in the <code>Accept</code> HTTP header in
    ///       the request.</p>
    public let contentType: String?
    /// <p>Identifies the current state of the user interaction. Amazon Lex returns
    ///       one of the following values as <code>dialogState</code>. The client can
    ///       optionally use this information to customize the user interface. </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>ElicitIntent</code> - Amazon Lex wants to elicit the user's intent.
    ///           Consider the following examples: </p>
    ///                <p> For example, a user might utter an intent ("I want to order a
    ///           pizza"). If Amazon Lex cannot infer the user intent from this utterance, it
    ///           will return this dialog state. </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>ConfirmIntent</code> - Amazon Lex is expecting a "yes" or "no"
    ///           response. </p>
    ///                <p>For example, Amazon Lex wants user confirmation before fulfilling an
    ///           intent. Instead of a simple "yes" or "no" response, a user might
    ///           respond with additional information. For example, "yes, but make it a
    ///           thick crust pizza" or "no, I want to order a drink." Amazon Lex can process
    ///           such additional information (in these examples, update the crust type
    ///           slot or change the intent from OrderPizza to OrderDrink). </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>ElicitSlot</code> - Amazon Lex is expecting the value of a slot for
    ///           the current intent. </p>
    ///                <p> For example, suppose that in the response Amazon Lex sends this
    ///           message: "What size pizza would you like?". A user might reply with
    ///           the slot value (e.g., "medium"). The user might also provide
    ///           additional information in the response (e.g., "medium thick crust
    ///           pizza"). Amazon Lex can process such additional information appropriately.
    ///         </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Fulfilled</code> - Conveys that the Lambda function has
    ///           successfully fulfilled the intent. </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>ReadyForFulfillment</code> - Conveys that the client has to
    ///           fulfill the request. </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Failed</code> - Conveys that the conversation with the user
    ///           failed. </p>
    ///                <p> This can happen for various reasons, including that the user does
    ///           not provide an appropriate response to prompts from the service (you
    ///           can configure how many times Amazon Lex can prompt a user for specific
    ///           information), or if the Lambda function fails to fulfill the intent.
    ///         </p>
    ///             </li>
    ///          </ul>
    public let dialogState: DialogState?
    /// <p>The text used to process the request.</p>
    ///          <p>If the input was an audio stream, the
    ///         <code>encodedInputTranscript</code> field contains the text extracted
    ///       from the audio stream. This is the text that is actually processed to
    ///       recognize intents and slot values. You can use this information to
    ///       determine if Amazon Lex is correctly processing the audio that you send.</p>
    ///          <p>The <code>encodedInputTranscript</code> field is base-64 encoded. You must
    ///       decode the field before you can use the value.</p>
    public let encodedInputTranscript: String?
    /// <p>The message to convey to the user. The message can come from the bot's
    ///       configuration or from a Lambda function.</p>
    ///          <p>If the intent is not configured with a Lambda function, or if the Lambda
    ///       function returned <code>Delegate</code> as the
    ///         <code>dialogAction.type</code> in its response, Amazon Lex decides on the
    ///       next course of action and selects an appropriate message from the bot's
    ///       configuration based on the current interaction context. For example, if
    ///       Amazon Lex isn't able to understand user input, it uses a clarification prompt
    ///       message.</p>
    ///          <p>When you create an intent you can assign messages to groups. When
    ///       messages are assigned to groups Amazon Lex returns one message from each group
    ///       in the response. The message field is an escaped JSON string containing
    ///       the messages. For more information about the structure of the JSON string
    ///       returned, see <a>msg-prompts-formats</a>.</p>
    ///          <p>If the Lambda function returns a message, Amazon Lex passes it to the client
    ///       in its response.</p>
    ///          <p>The <code>encodedMessage</code> field is base-64 encoded. You must
    ///       decode the field before you can use the value.</p>
    public let encodedMessage: String?
    /// <p>The text used to process the request.</p>
    ///          <p>You can use this field only in the de-DE, en-AU, en-GB, en-US, es-419,
    ///       es-ES, es-US, fr-CA, fr-FR, and it-IT locales. In all other locales, the
    ///         <code>inputTranscript</code> field is null. You should use the
    ///         <code>encodedInputTranscript</code> field instead.</p>
    ///          <p>If the input was an audio stream, the <code>inputTranscript</code>
    ///       field contains the text extracted from the audio stream. This is the text
    ///       that is actually processed to recognize intents and slot values. You can
    ///       use this information to determine if Amazon Lex is correctly processing the
    ///       audio that you send.</p>
    @available(*, deprecated, message: "The inputTranscript field is deprecated, use the encodedInputTranscript field instead. The inputTranscript field is available only in the de-DE, en-AU, en-GB, en-US, es-419, es-ES, es-US, fr-CA, fr-FR and it-IT locales.")
    public let inputTranscript: String?
    /// <p>Current user intent that Amazon Lex is aware of.</p>
    public let intentName: String?
    /// <p>You can only use this field in the de-DE, en-AU, en-GB, en-US, es-419,
    ///       es-ES, es-US, fr-CA, fr-FR, and it-IT locales. In all other locales, the
    ///         <code>message</code> field is null. You should use the
    ///         <code>encodedMessage</code> field instead.</p>
    ///          <p>The message to convey to the user. The message can come from the bot's
    ///       configuration or from a Lambda function.</p>
    ///          <p>If the intent is not configured with a Lambda function, or if the Lambda
    ///       function returned <code>Delegate</code> as the
    ///         <code>dialogAction.type</code> in its response, Amazon Lex decides on the
    ///       next course of action and selects an appropriate message from the bot's
    ///       configuration based on the current interaction context. For example, if
    ///       Amazon Lex isn't able to understand user input, it uses a clarification prompt
    ///       message.</p>
    ///          <p>When you create an intent you can assign messages to groups. When
    ///       messages are assigned to groups Amazon Lex returns one message from each group
    ///       in the response. The message field is an escaped JSON string containing
    ///       the messages. For more information about the structure of the JSON string
    ///       returned, see <a>msg-prompts-formats</a>.</p>
    ///          <p>If the Lambda function returns a message, Amazon Lex passes it to the client
    ///       in its response.</p>
    @available(*, deprecated, message: "The message field is deprecated, use the encodedMessage field instead. The message field is available only in the de-DE, en-AU, en-GB, en-US, es-419, es-ES, es-US, fr-CA, fr-FR and it-IT locales.")
    public let message: String?
    /// <p>The format of the response message. One of the following
    ///       values:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>PlainText</code> - The message contains plain UTF-8
    ///           text.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>CustomPayload</code> - The message is a custom format for
    ///           the client.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>SSML</code> - The message contains text formatted for voice
    ///           output.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Composite</code> - The message contains an escaped JSON
    ///           object containing one or more messages from the groups that messages
    ///           were assigned to when the intent was created.</p>
    ///             </li>
    ///          </ul>
    public let messageFormat: MessageFormatType?
    /// <p>Provides a score that indicates how confident Amazon Lex is that the
    ///       returned intent is the one that matches the user's intent. The score is
    ///       between 0.0 and 1.0.</p>
    ///          <p>The score is a relative score, not an absolute score. The score may
    ///       change based on improvements to Amazon Lex. </p>
    public let nluIntentConfidence: String?
    /// <p>The sentiment expressed in an utterance.</p>
    ///          <p>When the bot is configured to send utterances to Amazon Comprehend for
    ///       sentiment analysis, this field contains the result of the analysis.</p>
    public let sentimentResponse: String?
    /// <p> Map of key/value pairs representing the session-specific context
    ///       information. </p>
    public let sessionAttributes: String?
    /// <p>The unique identifier for the session.</p>
    public let sessionId: String?
    /// <p> If the <code>dialogState</code> value is <code>ElicitSlot</code>,
    ///       returns the name of the slot for which Amazon Lex is eliciting a value. </p>
    public let slotToElicit: String?
    /// <p>Map of zero or more intent slots (name/value pairs) Amazon Lex detected
    ///       from the user input during the conversation. The field is base-64
    ///       encoded.</p>
    ///          <p>Amazon Lex creates a resolution list containing likely values for a slot.
    ///       The value that it returns is determined by the
    ///         <code>valueSelectionStrategy</code> selected when the slot type was
    ///       created or updated. If <code>valueSelectionStrategy</code> is set to
    ///         <code>ORIGINAL_VALUE</code>, the value provided by the user is returned,
    ///       if the user value is similar to the slot values. If
    ///         <code>valueSelectionStrategy</code> is set to
    ///         <code>TOP_RESOLUTION</code> Amazon Lex returns the first value in the
    ///       resolution list or, if there is no resolution list, null. If you don't
    ///       specify a <code>valueSelectionStrategy</code>, the default is
    ///         <code>ORIGINAL_VALUE</code>.</p>
    public let slots: String?

    public init (
        activeContexts: String? = nil,
        alternativeIntents: String? = nil,
        audioStream: Data? = nil,
        botVersion: String? = nil,
        contentType: String? = nil,
        dialogState: DialogState? = nil,
        encodedInputTranscript: String? = nil,
        encodedMessage: String? = nil,
        inputTranscript: String? = nil,
        intentName: String? = nil,
        message: String? = nil,
        messageFormat: MessageFormatType? = nil,
        nluIntentConfidence: String? = nil,
        sentimentResponse: String? = nil,
        sessionAttributes: String? = nil,
        sessionId: String? = nil,
        slotToElicit: String? = nil,
        slots: String? = nil
    )
    {
        self.activeContexts = activeContexts
        self.alternativeIntents = alternativeIntents
        self.audioStream = audioStream
        self.botVersion = botVersion
        self.contentType = contentType
        self.dialogState = dialogState
        self.encodedInputTranscript = encodedInputTranscript
        self.encodedMessage = encodedMessage
        self.inputTranscript = inputTranscript
        self.intentName = intentName
        self.message = message
        self.messageFormat = messageFormat
        self.nluIntentConfidence = nluIntentConfidence
        self.sentimentResponse = sentimentResponse
        self.sessionAttributes = sessionAttributes
        self.sessionId = sessionId
        self.slotToElicit = slotToElicit
        self.slots = slots
    }
}

struct PostContentOutputResponseBody: Equatable {
    public let audioStream: Data?
}

extension PostContentOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case audioStream
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let audioStreamDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .audioStream)
        audioStream = audioStreamDecoded
    }
}

public struct PostTextInputBodyMiddleware: Middleware {
    public let id: String = "PostTextInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PostTextInput>,
                  next: H) -> Swift.Result<OperationOutput<PostTextOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PostTextInput>
    public typealias MOutput = OperationOutput<PostTextOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PostTextOutputError>
}

extension PostTextInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PostTextInput(activeContexts: \(String(describing: activeContexts)), botAlias: \(String(describing: botAlias)), botName: \(String(describing: botName)), inputText: \(String(describing: inputText)), requestAttributes: \(String(describing: requestAttributes)), sessionAttributes: \(String(describing: sessionAttributes)), userId: \(String(describing: userId)))"}
}

extension PostTextInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case activeContexts
        case inputText
        case requestAttributes
        case sessionAttributes
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activeContexts = activeContexts {
            var activeContextsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .activeContexts)
            for activecontextslist0 in activeContexts {
                try activeContextsContainer.encode(activecontextslist0)
            }
        }
        if let inputText = inputText {
            try encodeContainer.encode(inputText, forKey: .inputText)
        }
        if let requestAttributes = requestAttributes {
            var requestAttributesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .requestAttributes)
            for (dictKey0, stringmap0) in requestAttributes {
                try requestAttributesContainer.encode(stringmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let sessionAttributes = sessionAttributes {
            var sessionAttributesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .sessionAttributes)
            for (dictKey0, stringmap0) in sessionAttributes {
                try sessionAttributesContainer.encode(stringmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct PostTextInputHeadersMiddleware: Middleware {
    public let id: String = "PostTextInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PostTextInput>,
                  next: H) -> Swift.Result<OperationOutput<PostTextOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PostTextInput>
    public typealias MOutput = OperationOutput<PostTextOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PostTextOutputError>
}

public struct PostTextInputQueryItemMiddleware: Middleware {
    public let id: String = "PostTextInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PostTextInput>,
                  next: H) -> Swift.Result<OperationOutput<PostTextOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PostTextInput>
    public typealias MOutput = OperationOutput<PostTextOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PostTextOutputError>
}

public struct PostTextInput: Equatable {
    /// <p>A list of contexts active for the request. A context can be activated
    ///       when a previous intent is fulfilled, or by including the context in the
    ///       request,</p>
    ///          <p>If you don't specify a list of contexts, Amazon Lex will use the current
    ///       list of contexts for the session. If you specify an empty list, all
    ///       contexts for the session are cleared.</p>
    public let activeContexts: [ActiveContext]?
    /// <p>The alias of the Amazon Lex bot.</p>
    public let botAlias: String?
    /// <p>The name of the Amazon Lex bot.</p>
    public let botName: String?
    /// <p>The text that the user entered (Amazon Lex interprets this text).</p>
    public let inputText: String?
    /// <p>Request-specific information passed between Amazon Lex and a client
    ///       application.</p>
    ///          <p>The namespace <code>x-amz-lex:</code> is reserved for special
    ///       attributes. Don't create any request attributes with the prefix
    ///         <code>x-amz-lex:</code>.</p>
    ///          <p>For more information, see <a href="https://docs.aws.amazon.com/lex/latest/dg/context-mgmt.html#context-mgmt-request-attribs">Setting Request Attributes</a>.</p>
    public let requestAttributes: [String:String]?
    /// <p>Application-specific information passed between Amazon Lex and a client
    ///       application.</p>
    ///          <p>For more information, see <a href="https://docs.aws.amazon.com/lex/latest/dg/context-mgmt.html#context-mgmt-session-attribs">Setting Session Attributes</a>.</p>
    public let sessionAttributes: [String:String]?
    /// <p>The ID of the client application user. Amazon Lex uses this to identify a
    ///       user's conversation with your bot. At runtime, each request must contain
    ///       the <code>userID</code> field.</p>
    ///          <p>To decide the user ID to use for your application, consider the
    ///       following factors.</p>
    ///          <ul>
    ///             <li>
    ///                <p>The <code>userID</code> field must not contain any personally
    ///           identifiable information of the user, for example, name, personal
    ///           identification numbers, or other end user personal information.</p>
    ///             </li>
    ///             <li>
    ///                <p>If you want a user to start a conversation on one device and
    ///           continue on another device, use a user-specific identifier.</p>
    ///             </li>
    ///             <li>
    ///                <p>If you want the same user to be able to have two independent
    ///           conversations on two different devices, choose a device-specific
    ///           identifier.</p>
    ///             </li>
    ///             <li>
    ///                <p>A user can't have two independent conversations with two different
    ///           versions of the same bot. For example, a user can't have a
    ///           conversation with the PROD and BETA versions of the same bot. If you
    ///           anticipate that a user will need to have conversation with two
    ///           different versions, for example, while testing, include the bot alias
    ///           in the user ID to separate the two conversations.</p>
    ///             </li>
    ///          </ul>
    public let userId: String?

    public init (
        activeContexts: [ActiveContext]? = nil,
        botAlias: String? = nil,
        botName: String? = nil,
        inputText: String? = nil,
        requestAttributes: [String:String]? = nil,
        sessionAttributes: [String:String]? = nil,
        userId: String? = nil
    )
    {
        self.activeContexts = activeContexts
        self.botAlias = botAlias
        self.botName = botName
        self.inputText = inputText
        self.requestAttributes = requestAttributes
        self.sessionAttributes = sessionAttributes
        self.userId = userId
    }
}

struct PostTextInputBody: Equatable {
    public let sessionAttributes: [String:String]?
    public let requestAttributes: [String:String]?
    public let inputText: String?
    public let activeContexts: [ActiveContext]?
}

extension PostTextInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case activeContexts
        case inputText
        case requestAttributes
        case sessionAttributes
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionAttributesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .sessionAttributes)
        var sessionAttributesDecoded0: [String:String]? = nil
        if let sessionAttributesContainer = sessionAttributesContainer {
            sessionAttributesDecoded0 = [String:String]()
            for (key0, string0) in sessionAttributesContainer {
                if let string0 = string0 {
                    sessionAttributesDecoded0?[key0] = string0
                }
            }
        }
        sessionAttributes = sessionAttributesDecoded0
        let requestAttributesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .requestAttributes)
        var requestAttributesDecoded0: [String:String]? = nil
        if let requestAttributesContainer = requestAttributesContainer {
            requestAttributesDecoded0 = [String:String]()
            for (key0, string0) in requestAttributesContainer {
                if let string0 = string0 {
                    requestAttributesDecoded0?[key0] = string0
                }
            }
        }
        requestAttributes = requestAttributesDecoded0
        let inputTextDecoded = try containerValues.decodeIfPresent(String.self, forKey: .inputText)
        inputText = inputTextDecoded
        let activeContextsContainer = try containerValues.decodeIfPresent([ActiveContext?].self, forKey: .activeContexts)
        var activeContextsDecoded0:[ActiveContext]? = nil
        if let activeContextsContainer = activeContextsContainer {
            activeContextsDecoded0 = [ActiveContext]()
            for structure0 in activeContextsContainer {
                if let structure0 = structure0 {
                    activeContextsDecoded0?.append(structure0)
                }
            }
        }
        activeContexts = activeContextsDecoded0
    }
}

extension PostTextOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PostTextOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadGatewayException" : self = .badGatewayException(try BadGatewayException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DependencyFailedException" : self = .dependencyFailedException(try DependencyFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LoopDetectedException" : self = .loopDetectedException(try LoopDetectedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PostTextOutputError: Equatable {
    case badGatewayException(BadGatewayException)
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case dependencyFailedException(DependencyFailedException)
    case internalFailureException(InternalFailureException)
    case limitExceededException(LimitExceededException)
    case loopDetectedException(LoopDetectedException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PostTextOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PostTextOutputResponse(activeContexts: \(String(describing: activeContexts)), alternativeIntents: \(String(describing: alternativeIntents)), botVersion: \(String(describing: botVersion)), dialogState: \(String(describing: dialogState)), intentName: \(String(describing: intentName)), message: \(String(describing: message)), messageFormat: \(String(describing: messageFormat)), nluIntentConfidence: \(String(describing: nluIntentConfidence)), responseCard: \(String(describing: responseCard)), sentimentResponse: \(String(describing: sentimentResponse)), sessionAttributes: \(String(describing: sessionAttributes)), sessionId: \(String(describing: sessionId)), slotToElicit: \(String(describing: slotToElicit)), slots: \(String(describing: slots)))"}
}

extension PostTextOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PostTextOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.activeContexts = output.activeContexts
            self.alternativeIntents = output.alternativeIntents
            self.botVersion = output.botVersion
            self.dialogState = output.dialogState
            self.intentName = output.intentName
            self.message = output.message
            self.messageFormat = output.messageFormat
            self.nluIntentConfidence = output.nluIntentConfidence
            self.responseCard = output.responseCard
            self.sentimentResponse = output.sentimentResponse
            self.sessionAttributes = output.sessionAttributes
            self.sessionId = output.sessionId
            self.slotToElicit = output.slotToElicit
            self.slots = output.slots
        } else {
            self.activeContexts = nil
            self.alternativeIntents = nil
            self.botVersion = nil
            self.dialogState = nil
            self.intentName = nil
            self.message = nil
            self.messageFormat = nil
            self.nluIntentConfidence = nil
            self.responseCard = nil
            self.sentimentResponse = nil
            self.sessionAttributes = nil
            self.sessionId = nil
            self.slotToElicit = nil
            self.slots = nil
        }
    }
}

public struct PostTextOutputResponse: Equatable {
    /// <p>A list of active contexts for the session. A context can be set when
    ///       an intent is fulfilled or by calling the <code>PostContent</code>,
    ///         <code>PostText</code>, or <code>PutSession</code> operation.</p>
    ///          <p>You can use a context to control the intents that can follow up an
    ///       intent, or to modify the operation of your application.</p>
    public let activeContexts: [ActiveContext]?
    /// <p>One to four alternative intents that may be applicable to the user's
    ///       intent.</p>
    ///          <p>Each alternative includes a score that indicates how confident Amazon Lex
    ///       is that the intent matches the user's intent. The intents are sorted by
    ///       the confidence score.</p>
    public let alternativeIntents: [PredictedIntent]?
    /// <p>The version of the bot that responded to the conversation. You can use
    ///       this information to help determine if one version of a bot is performing
    ///       better than another version.</p>
    public let botVersion: String?
    /// <p> Identifies the current state of the user interaction. Amazon Lex returns
    ///       one of the following values as <code>dialogState</code>. The client can
    ///       optionally use this information to customize the user interface. </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>ElicitIntent</code> - Amazon Lex wants to elicit user intent. </p>
    ///                <p>For example, a user might utter an intent ("I want to order a
    ///           pizza"). If Amazon Lex cannot infer the user intent from this utterance, it
    ///           will return this dialogState.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>ConfirmIntent</code> - Amazon Lex is expecting a "yes" or "no"
    ///           response. </p>
    ///                <p> For example, Amazon Lex wants user confirmation before fulfilling an
    ///           intent. </p>
    ///                <p>Instead of a simple "yes" or "no," a user might respond with
    ///           additional information. For example, "yes, but make it thick crust
    ///           pizza" or "no, I want to order a drink". Amazon Lex can process such
    ///           additional information (in these examples, update the crust type slot
    ///           value, or change intent from OrderPizza to OrderDrink).</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>ElicitSlot</code> - Amazon Lex is expecting a slot value for the
    ///           current intent. </p>
    ///                <p>For example, suppose that in the response Amazon Lex sends this
    ///           message: "What size pizza would you like?". A user might reply with
    ///           the slot value (e.g., "medium"). The user might also provide
    ///           additional information in the response (e.g., "medium thick crust
    ///           pizza"). Amazon Lex can process such additional information appropriately.
    ///         </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Fulfilled</code> - Conveys that the Lambda function configured
    ///           for the intent has successfully fulfilled the intent. </p>
    ///
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>ReadyForFulfillment</code> - Conveys that the client has to
    ///           fulfill the intent. </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Failed</code> - Conveys that the conversation with the user
    ///           failed. </p>
    ///                <p> This can happen for various reasons including that the user did
    ///           not provide an appropriate response to prompts from the service (you
    ///           can configure how many times Amazon Lex can prompt a user for specific
    ///           information), or the Lambda function failed to fulfill the intent.
    ///         </p>
    ///             </li>
    ///          </ul>
    public let dialogState: DialogState?
    /// <p>The current user intent that Amazon Lex is aware of.</p>
    public let intentName: String?
    /// <p>The message to convey to the user. The message can come from the bot's
    ///       configuration or from a Lambda function.</p>
    ///          <p>If the intent is not configured with a Lambda function, or if the Lambda
    ///       function returned <code>Delegate</code> as the
    ///         <code>dialogAction.type</code> its response, Amazon Lex decides on the next
    ///       course of action and selects an appropriate message from the bot's
    ///       configuration based on the current interaction context. For example, if
    ///       Amazon Lex isn't able to understand user input, it uses a clarification prompt
    ///       message.</p>
    ///          <p>When you create an intent you can assign messages to groups. When
    ///       messages are assigned to groups Amazon Lex returns one message from each group
    ///       in the response. The message field is an escaped JSON string containing
    ///       the messages. For more information about the structure of the JSON string
    ///       returned, see <a>msg-prompts-formats</a>.</p>
    ///          <p>If the Lambda function returns a message, Amazon Lex passes it to the client
    ///       in its response.</p>
    public let message: String?
    /// <p>The format of the response message. One of the following
    ///       values:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>PlainText</code> - The message contains plain UTF-8
    ///           text.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>CustomPayload</code> - The message is a custom format
    ///           defined by the Lambda function.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>SSML</code> - The message contains text formatted for voice
    ///           output.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Composite</code> - The message contains an escaped JSON
    ///           object containing one or more messages from the groups that messages
    ///           were assigned to when the intent was created.</p>
    ///             </li>
    ///          </ul>
    public let messageFormat: MessageFormatType?
    /// <p>Provides a score that indicates how confident Amazon Lex is that the
    ///       returned intent is the one that matches the user's intent. The score is
    ///       between 0.0 and 1.0. For more information, see <a href="https://docs.aws.amazon.com/lex/latest/dg/confidence-scores.html">Confidence Scores</a>.</p>
    ///          <p>The score is a relative score, not an absolute score. The score may
    ///       change based on improvements to Amazon Lex.</p>
    public let nluIntentConfidence: IntentConfidence?
    /// <p>Represents the options that the user has to respond to the current
    ///       prompt. Response Card can come from the bot configuration (in the
    ///       Amazon Lex console, choose the settings button next to a slot) or from a
    ///       code hook (Lambda function). </p>
    public let responseCard: ResponseCard?
    /// <p>The sentiment expressed in and utterance.</p>
    ///          <p>When the bot is configured to send utterances to Amazon Comprehend for
    ///       sentiment analysis, this field contains the result of the analysis.</p>
    public let sentimentResponse: SentimentResponse?
    /// <p>A map of key-value pairs representing the session-specific context
    ///       information.</p>
    public let sessionAttributes: [String:String]?
    /// <p>A unique identifier for the session.</p>
    public let sessionId: String?
    /// <p>If the <code>dialogState</code> value is <code>ElicitSlot</code>,
    ///       returns the name of the slot for which Amazon Lex is eliciting a value. </p>
    public let slotToElicit: String?
    /// <p> The intent slots that Amazon Lex detected from the user input in the
    ///       conversation. </p>
    ///          <p>Amazon Lex creates a resolution list containing likely values for a slot.
    ///       The value that it returns is determined by the
    ///         <code>valueSelectionStrategy</code> selected when the slot type was
    ///       created or updated. If <code>valueSelectionStrategy</code> is set to
    ///         <code>ORIGINAL_VALUE</code>, the value provided by the user is returned,
    ///       if the user value is similar to the slot values. If
    ///         <code>valueSelectionStrategy</code> is set to
    ///         <code>TOP_RESOLUTION</code> Amazon Lex returns the first value in the
    ///       resolution list or, if there is no resolution list, null. If you don't
    ///       specify a <code>valueSelectionStrategy</code>, the default is
    ///         <code>ORIGINAL_VALUE</code>.</p>
    public let slots: [String:String]?

    public init (
        activeContexts: [ActiveContext]? = nil,
        alternativeIntents: [PredictedIntent]? = nil,
        botVersion: String? = nil,
        dialogState: DialogState? = nil,
        intentName: String? = nil,
        message: String? = nil,
        messageFormat: MessageFormatType? = nil,
        nluIntentConfidence: IntentConfidence? = nil,
        responseCard: ResponseCard? = nil,
        sentimentResponse: SentimentResponse? = nil,
        sessionAttributes: [String:String]? = nil,
        sessionId: String? = nil,
        slotToElicit: String? = nil,
        slots: [String:String]? = nil
    )
    {
        self.activeContexts = activeContexts
        self.alternativeIntents = alternativeIntents
        self.botVersion = botVersion
        self.dialogState = dialogState
        self.intentName = intentName
        self.message = message
        self.messageFormat = messageFormat
        self.nluIntentConfidence = nluIntentConfidence
        self.responseCard = responseCard
        self.sentimentResponse = sentimentResponse
        self.sessionAttributes = sessionAttributes
        self.sessionId = sessionId
        self.slotToElicit = slotToElicit
        self.slots = slots
    }
}

struct PostTextOutputResponseBody: Equatable {
    public let intentName: String?
    public let nluIntentConfidence: IntentConfidence?
    public let alternativeIntents: [PredictedIntent]?
    public let slots: [String:String]?
    public let sessionAttributes: [String:String]?
    public let message: String?
    public let sentimentResponse: SentimentResponse?
    public let messageFormat: MessageFormatType?
    public let dialogState: DialogState?
    public let slotToElicit: String?
    public let responseCard: ResponseCard?
    public let sessionId: String?
    public let botVersion: String?
    public let activeContexts: [ActiveContext]?
}

extension PostTextOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case activeContexts
        case alternativeIntents
        case botVersion
        case dialogState
        case intentName
        case message
        case messageFormat
        case nluIntentConfidence
        case responseCard
        case sentimentResponse
        case sessionAttributes
        case sessionId
        case slotToElicit
        case slots
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let intentNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .intentName)
        intentName = intentNameDecoded
        let nluIntentConfidenceDecoded = try containerValues.decodeIfPresent(IntentConfidence.self, forKey: .nluIntentConfidence)
        nluIntentConfidence = nluIntentConfidenceDecoded
        let alternativeIntentsContainer = try containerValues.decodeIfPresent([PredictedIntent?].self, forKey: .alternativeIntents)
        var alternativeIntentsDecoded0:[PredictedIntent]? = nil
        if let alternativeIntentsContainer = alternativeIntentsContainer {
            alternativeIntentsDecoded0 = [PredictedIntent]()
            for structure0 in alternativeIntentsContainer {
                if let structure0 = structure0 {
                    alternativeIntentsDecoded0?.append(structure0)
                }
            }
        }
        alternativeIntents = alternativeIntentsDecoded0
        let slotsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .slots)
        var slotsDecoded0: [String:String]? = nil
        if let slotsContainer = slotsContainer {
            slotsDecoded0 = [String:String]()
            for (key0, string0) in slotsContainer {
                if let string0 = string0 {
                    slotsDecoded0?[key0] = string0
                }
            }
        }
        slots = slotsDecoded0
        let sessionAttributesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .sessionAttributes)
        var sessionAttributesDecoded0: [String:String]? = nil
        if let sessionAttributesContainer = sessionAttributesContainer {
            sessionAttributesDecoded0 = [String:String]()
            for (key0, string0) in sessionAttributesContainer {
                if let string0 = string0 {
                    sessionAttributesDecoded0?[key0] = string0
                }
            }
        }
        sessionAttributes = sessionAttributesDecoded0
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let sentimentResponseDecoded = try containerValues.decodeIfPresent(SentimentResponse.self, forKey: .sentimentResponse)
        sentimentResponse = sentimentResponseDecoded
        let messageFormatDecoded = try containerValues.decodeIfPresent(MessageFormatType.self, forKey: .messageFormat)
        messageFormat = messageFormatDecoded
        let dialogStateDecoded = try containerValues.decodeIfPresent(DialogState.self, forKey: .dialogState)
        dialogState = dialogStateDecoded
        let slotToElicitDecoded = try containerValues.decodeIfPresent(String.self, forKey: .slotToElicit)
        slotToElicit = slotToElicitDecoded
        let responseCardDecoded = try containerValues.decodeIfPresent(ResponseCard.self, forKey: .responseCard)
        responseCard = responseCardDecoded
        let sessionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sessionId)
        sessionId = sessionIdDecoded
        let botVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .botVersion)
        botVersion = botVersionDecoded
        let activeContextsContainer = try containerValues.decodeIfPresent([ActiveContext?].self, forKey: .activeContexts)
        var activeContextsDecoded0:[ActiveContext]? = nil
        if let activeContextsContainer = activeContextsContainer {
            activeContextsDecoded0 = [ActiveContext]()
            for structure0 in activeContextsContainer {
                if let structure0 = structure0 {
                    activeContextsDecoded0?.append(structure0)
                }
            }
        }
        activeContexts = activeContextsDecoded0
    }
}

extension PredictedIntent: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case intentName
        case nluIntentConfidence
        case slots
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let intentName = intentName {
            try encodeContainer.encode(intentName, forKey: .intentName)
        }
        if let nluIntentConfidence = nluIntentConfidence {
            try encodeContainer.encode(nluIntentConfidence, forKey: .nluIntentConfidence)
        }
        if let slots = slots {
            var slotsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .slots)
            for (dictKey0, stringmap0) in slots {
                try slotsContainer.encode(stringmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let intentNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .intentName)
        intentName = intentNameDecoded
        let nluIntentConfidenceDecoded = try containerValues.decodeIfPresent(IntentConfidence.self, forKey: .nluIntentConfidence)
        nluIntentConfidence = nluIntentConfidenceDecoded
        let slotsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .slots)
        var slotsDecoded0: [String:String]? = nil
        if let slotsContainer = slotsContainer {
            slotsDecoded0 = [String:String]()
            for (key0, string0) in slotsContainer {
                if let string0 = string0 {
                    slotsDecoded0?[key0] = string0
                }
            }
        }
        slots = slotsDecoded0
    }
}

extension PredictedIntent: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PredictedIntent(intentName: \(String(describing: intentName)), nluIntentConfidence: \(String(describing: nluIntentConfidence)), slots: \(String(describing: slots)))"}
}

/// <p>An intent that Amazon Lex suggests satisfies the user's intent. Includes
///       the name of the intent, the confidence that Amazon Lex has that the user's
///       intent is satisfied, and the slots defined for the intent.</p>
public struct PredictedIntent: Equatable {
    /// <p>The name of the intent that Amazon Lex suggests satisfies the user's
    ///       intent.</p>
    public let intentName: String?
    /// <p>Indicates how confident Amazon Lex is that an intent satisfies the user's
    ///       intent.</p>
    public let nluIntentConfidence: IntentConfidence?
    /// <p>The slot and slot values associated with the predicted intent.</p>
    public let slots: [String:String]?

    public init (
        intentName: String? = nil,
        nluIntentConfidence: IntentConfidence? = nil,
        slots: [String:String]? = nil
    )
    {
        self.intentName = intentName
        self.nluIntentConfidence = nluIntentConfidence
        self.slots = slots
    }
}

public struct PutSessionInputBodyMiddleware: Middleware {
    public let id: String = "PutSessionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutSessionInput>,
                  next: H) -> Swift.Result<OperationOutput<PutSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutSessionInput>
    public typealias MOutput = OperationOutput<PutSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutSessionOutputError>
}

extension PutSessionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutSessionInput(accept: \(String(describing: accept)), activeContexts: \(String(describing: activeContexts)), botAlias: \(String(describing: botAlias)), botName: \(String(describing: botName)), dialogAction: \(String(describing: dialogAction)), recentIntentSummaryView: \(String(describing: recentIntentSummaryView)), sessionAttributes: \(String(describing: sessionAttributes)), userId: \(String(describing: userId)))"}
}

extension PutSessionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case activeContexts
        case dialogAction
        case recentIntentSummaryView
        case sessionAttributes
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activeContexts = activeContexts {
            var activeContextsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .activeContexts)
            for activecontextslist0 in activeContexts {
                try activeContextsContainer.encode(activecontextslist0)
            }
        }
        if let dialogAction = dialogAction {
            try encodeContainer.encode(dialogAction, forKey: .dialogAction)
        }
        if let recentIntentSummaryView = recentIntentSummaryView {
            var recentIntentSummaryViewContainer = encodeContainer.nestedUnkeyedContainer(forKey: .recentIntentSummaryView)
            for intentsummarylist0 in recentIntentSummaryView {
                try recentIntentSummaryViewContainer.encode(intentsummarylist0)
            }
        }
        if let sessionAttributes = sessionAttributes {
            var sessionAttributesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .sessionAttributes)
            for (dictKey0, stringmap0) in sessionAttributes {
                try sessionAttributesContainer.encode(stringmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct PutSessionInputHeadersMiddleware: Middleware {
    public let id: String = "PutSessionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutSessionInput>,
                  next: H) -> Swift.Result<OperationOutput<PutSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let accept = input.operationInput.accept {
            input.builder.withHeader(name: "Accept", value: String(accept))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutSessionInput>
    public typealias MOutput = OperationOutput<PutSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutSessionOutputError>
}

public struct PutSessionInputQueryItemMiddleware: Middleware {
    public let id: String = "PutSessionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutSessionInput>,
                  next: H) -> Swift.Result<OperationOutput<PutSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutSessionInput>
    public typealias MOutput = OperationOutput<PutSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutSessionOutputError>
}

public struct PutSessionInput: Equatable {
    /// <p>The message that Amazon Lex returns in the response can be either text or
    ///       speech based depending on the value of this field.</p>
    ///          <ul>
    ///             <li>
    ///                <p>If the value is <code>text/plain; charset=utf-8</code>, Amazon Lex
    ///           returns text in the response.</p>
    ///             </li>
    ///             <li>
    ///                <p>If the value begins with <code>audio/</code>, Amazon Lex returns speech
    ///           in the response. Amazon Lex uses Amazon Polly to generate the speech in the
    ///           configuration that you specify. For example, if you specify
    ///             <code>audio/mpeg</code> as the value, Amazon Lex returns speech in the
    ///           MPEG format.</p>
    ///             </li>
    ///             <li>
    ///                <p>If the value is <code>audio/pcm</code>, the speech is returned as
    ///             <code>audio/pcm</code> in 16-bit, little endian format.</p>
    ///             </li>
    ///             <li>
    ///                <p>The following are the accepted values:</p>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                         <code>audio/mpeg</code>
    ///                      </p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <code>audio/ogg</code>
    ///                      </p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <code>audio/pcm</code>
    ///                      </p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <code>audio/*</code> (defaults to mpeg)</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <code>text/plain; charset=utf-8</code>
    ///                      </p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///          </ul>
    public let accept: String?
    /// <p>A list of contexts active for the request. A context can be activated
    ///       when a previous intent is fulfilled, or by including the context in the
    ///       request,</p>
    ///          <p>If you don't specify a list of contexts, Amazon Lex will use the current
    ///       list of contexts for the session. If you specify an empty list, all
    ///       contexts for the session are cleared.</p>
    public let activeContexts: [ActiveContext]?
    /// <p>The alias in use for the bot that contains the session data.</p>
    public let botAlias: String?
    /// <p>The name of the bot that contains the session data.</p>
    public let botName: String?
    /// <p>Sets the next action that the bot should take to fulfill the
    ///       conversation.</p>
    public let dialogAction: DialogAction?
    /// <p>A summary of the recent intents for the bot. You can use the intent
    ///       summary view to set a checkpoint label on an intent and modify attributes
    ///       of intents. You can also use it to remove or add intent summary objects to
    ///       the list.</p>
    ///          <p>An intent that you modify or add to the list must make sense for the
    ///       bot. For example, the intent name must be valid for the bot. You must
    ///       provide valid values for:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>intentName</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>slot names</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>slotToElict</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    ///          <p>If you send the <code>recentIntentSummaryView</code> parameter in a
    ///         <code>PutSession</code> request, the contents of the new summary view
    ///       replaces the old summary view. For example, if a <code>GetSession</code>
    ///       request returns three intents in the summary view and you call
    ///         <code>PutSession</code> with one intent in the summary view, the next
    ///       call to <code>GetSession</code> will only return one intent.</p>
    public let recentIntentSummaryView: [IntentSummary]?
    /// <p>Map of key/value pairs representing the session-specific context
    ///       information. It contains application information passed between Amazon Lex and
    ///       a client application.</p>
    public let sessionAttributes: [String:String]?
    /// <p>The ID of the client application user. Amazon Lex uses this to identify a
    ///       user's conversation with your bot. </p>
    public let userId: String?

    public init (
        accept: String? = nil,
        activeContexts: [ActiveContext]? = nil,
        botAlias: String? = nil,
        botName: String? = nil,
        dialogAction: DialogAction? = nil,
        recentIntentSummaryView: [IntentSummary]? = nil,
        sessionAttributes: [String:String]? = nil,
        userId: String? = nil
    )
    {
        self.accept = accept
        self.activeContexts = activeContexts
        self.botAlias = botAlias
        self.botName = botName
        self.dialogAction = dialogAction
        self.recentIntentSummaryView = recentIntentSummaryView
        self.sessionAttributes = sessionAttributes
        self.userId = userId
    }
}

struct PutSessionInputBody: Equatable {
    public let sessionAttributes: [String:String]?
    public let dialogAction: DialogAction?
    public let recentIntentSummaryView: [IntentSummary]?
    public let activeContexts: [ActiveContext]?
}

extension PutSessionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case activeContexts
        case dialogAction
        case recentIntentSummaryView
        case sessionAttributes
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionAttributesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .sessionAttributes)
        var sessionAttributesDecoded0: [String:String]? = nil
        if let sessionAttributesContainer = sessionAttributesContainer {
            sessionAttributesDecoded0 = [String:String]()
            for (key0, string0) in sessionAttributesContainer {
                if let string0 = string0 {
                    sessionAttributesDecoded0?[key0] = string0
                }
            }
        }
        sessionAttributes = sessionAttributesDecoded0
        let dialogActionDecoded = try containerValues.decodeIfPresent(DialogAction.self, forKey: .dialogAction)
        dialogAction = dialogActionDecoded
        let recentIntentSummaryViewContainer = try containerValues.decodeIfPresent([IntentSummary?].self, forKey: .recentIntentSummaryView)
        var recentIntentSummaryViewDecoded0:[IntentSummary]? = nil
        if let recentIntentSummaryViewContainer = recentIntentSummaryViewContainer {
            recentIntentSummaryViewDecoded0 = [IntentSummary]()
            for structure0 in recentIntentSummaryViewContainer {
                if let structure0 = structure0 {
                    recentIntentSummaryViewDecoded0?.append(structure0)
                }
            }
        }
        recentIntentSummaryView = recentIntentSummaryViewDecoded0
        let activeContextsContainer = try containerValues.decodeIfPresent([ActiveContext?].self, forKey: .activeContexts)
        var activeContextsDecoded0:[ActiveContext]? = nil
        if let activeContextsContainer = activeContextsContainer {
            activeContextsDecoded0 = [ActiveContext]()
            for structure0 in activeContextsContainer {
                if let structure0 = structure0 {
                    activeContextsDecoded0?.append(structure0)
                }
            }
        }
        activeContexts = activeContextsDecoded0
    }
}

extension PutSessionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutSessionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadGatewayException" : self = .badGatewayException(try BadGatewayException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DependencyFailedException" : self = .dependencyFailedException(try DependencyFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAcceptableException" : self = .notAcceptableException(try NotAcceptableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutSessionOutputError: Equatable {
    case badGatewayException(BadGatewayException)
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case dependencyFailedException(DependencyFailedException)
    case internalFailureException(InternalFailureException)
    case limitExceededException(LimitExceededException)
    case notAcceptableException(NotAcceptableException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutSessionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutSessionOutputResponse(activeContexts: \(String(describing: activeContexts)), audioStream: \(String(describing: audioStream)), contentType: \(String(describing: contentType)), dialogState: \(String(describing: dialogState)), encodedMessage: \(String(describing: encodedMessage)), intentName: \(String(describing: intentName)), message: \(String(describing: message)), messageFormat: \(String(describing: messageFormat)), sessionAttributes: \(String(describing: sessionAttributes)), sessionId: \(String(describing: sessionId)), slotToElicit: \(String(describing: slotToElicit)), slots: \(String(describing: slots)))"}
}

extension PutSessionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if let activeContextsHeaderValue = httpResponse.headers.value(for: "x-amz-lex-active-contexts") {
            self.activeContexts = try activeContextsHeaderValue.base64DecodedString()
        } else {
            self.activeContexts = nil
        }
        if let contentTypeHeaderValue = httpResponse.headers.value(for: "Content-Type") {
            self.contentType = contentTypeHeaderValue
        } else {
            self.contentType = nil
        }
        if let dialogStateHeaderValue = httpResponse.headers.value(for: "x-amz-lex-dialog-state") {
            self.dialogState = DialogState(rawValue: dialogStateHeaderValue)
        } else {
            self.dialogState = nil
        }
        if let encodedMessageHeaderValue = httpResponse.headers.value(for: "x-amz-lex-encoded-message") {
            self.encodedMessage = encodedMessageHeaderValue
        } else {
            self.encodedMessage = nil
        }
        if let intentNameHeaderValue = httpResponse.headers.value(for: "x-amz-lex-intent-name") {
            self.intentName = intentNameHeaderValue
        } else {
            self.intentName = nil
        }
        if let messageHeaderValue = httpResponse.headers.value(for: "x-amz-lex-message") {
            self.message = messageHeaderValue
        } else {
            self.message = nil
        }
        if let messageFormatHeaderValue = httpResponse.headers.value(for: "x-amz-lex-message-format") {
            self.messageFormat = MessageFormatType(rawValue: messageFormatHeaderValue)
        } else {
            self.messageFormat = nil
        }
        if let sessionAttributesHeaderValue = httpResponse.headers.value(for: "x-amz-lex-session-attributes") {
            self.sessionAttributes = try sessionAttributesHeaderValue.base64DecodedString()
        } else {
            self.sessionAttributes = nil
        }
        if let sessionIdHeaderValue = httpResponse.headers.value(for: "x-amz-lex-session-id") {
            self.sessionId = sessionIdHeaderValue
        } else {
            self.sessionId = nil
        }
        if let slotToElicitHeaderValue = httpResponse.headers.value(for: "x-amz-lex-slot-to-elicit") {
            self.slotToElicit = slotToElicitHeaderValue
        } else {
            self.slotToElicit = nil
        }
        if let slotsHeaderValue = httpResponse.headers.value(for: "x-amz-lex-slots") {
            self.slots = try slotsHeaderValue.base64DecodedString()
        } else {
            self.slots = nil
        }
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            self.audioStream = unwrappedData
        } else {
            self.audioStream = nil
        }
    }
}

public struct PutSessionOutputResponse: Equatable {
    /// <p>A list of active contexts for the session.</p>
    public let activeContexts: String?
    /// <p>The audio version of the message to convey to the user.</p>
    public let audioStream: Data?
    /// <p>Content type as specified in the <code>Accept</code> HTTP header in
    ///       the request.</p>
    public let contentType: String?
    /// <p></p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>ConfirmIntent</code> - Amazon Lex is expecting a "yes" or "no"
    ///           response to confirm the intent before fulfilling an intent.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>ElicitIntent</code> - Amazon Lex wants to elicit the user's
    ///           intent.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>ElicitSlot</code> - Amazon Lex is expecting the value of a slot
    ///           for the current intent.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Failed</code> - Conveys that the conversation with the user
    ///           has failed. This can happen for various reasons, including the user
    ///           does not provide an appropriate response to prompts from the service,
    ///           or if the Lambda function fails to fulfill the intent.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Fulfilled</code> - Conveys that the Lambda function has
    ///           sucessfully fulfilled the intent.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>ReadyForFulfillment</code> - Conveys that the client has to
    ///           fulfill the intent.</p>
    ///             </li>
    ///          </ul>
    public let dialogState: DialogState?
    /// <p>The next message that should be presented to the user.</p>
    ///          <p>The <code>encodedMessage</code> field is base-64 encoded. You must
    ///       decode the field before you can use the value.</p>
    public let encodedMessage: String?
    /// <p>The name of the current intent.</p>
    public let intentName: String?
    /// <p>The next message that should be presented to the user.</p>
    ///          <p>You can only use this field in the de-DE, en-AU, en-GB, en-US, es-419,
    ///       es-ES, es-US, fr-CA, fr-FR, and it-IT locales. In all other locales, the
    ///         <code>message</code> field is null. You should use the
    ///         <code>encodedMessage</code> field instead.</p>
    @available(*, deprecated, message: "The message field is deprecated, use the encodedMessage field instead. The message field is available only in the de-DE, en-AU, en-GB, en-US, es-419, es-ES, es-US, fr-CA, fr-FR and it-IT locales.")
    public let message: String?
    /// <p>The format of the response message. One of the following
    ///       values:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>PlainText</code> - The message contains plain UTF-8
    ///           text.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>CustomPayload</code> - The message is a custom format for
    ///           the client.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>SSML</code> - The message contains text formatted for voice
    ///           output.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Composite</code> - The message contains an escaped JSON
    ///           object containing one or more messages from the groups that messages
    ///           were assigned to when the intent was created.</p>
    ///             </li>
    ///          </ul>
    public let messageFormat: MessageFormatType?
    /// <p>Map of key/value pairs representing session-specific context
    ///       information.</p>
    public let sessionAttributes: String?
    /// <p>A unique identifier for the session.</p>
    public let sessionId: String?
    /// <p>If the <code>dialogState</code> is <code>ElicitSlot</code>, returns
    ///       the name of the slot for which Amazon Lex is eliciting a value.</p>
    public let slotToElicit: String?
    /// <p>Map of zero or more intent slots Amazon Lex detected from the user input
    ///       during the conversation.</p>
    ///          <p>Amazon Lex creates a resolution list containing likely values for a slot.
    ///       The value that it returns is determined by the
    ///         <code>valueSelectionStrategy</code> selected when the slot type was
    ///       created or updated. If <code>valueSelectionStrategy</code> is set to
    ///         <code>ORIGINAL_VALUE</code>, the value provided by the user is returned,
    ///       if the user value is similar to the slot values. If
    ///         <code>valueSelectionStrategy</code> is set to
    ///         <code>TOP_RESOLUTION</code> Amazon Lex returns the first value in the
    ///       resolution list or, if there is no resolution list, null. If you don't
    ///       specify a <code>valueSelectionStrategy</code> the default is
    ///         <code>ORIGINAL_VALUE</code>. </p>
    public let slots: String?

    public init (
        activeContexts: String? = nil,
        audioStream: Data? = nil,
        contentType: String? = nil,
        dialogState: DialogState? = nil,
        encodedMessage: String? = nil,
        intentName: String? = nil,
        message: String? = nil,
        messageFormat: MessageFormatType? = nil,
        sessionAttributes: String? = nil,
        sessionId: String? = nil,
        slotToElicit: String? = nil,
        slots: String? = nil
    )
    {
        self.activeContexts = activeContexts
        self.audioStream = audioStream
        self.contentType = contentType
        self.dialogState = dialogState
        self.encodedMessage = encodedMessage
        self.intentName = intentName
        self.message = message
        self.messageFormat = messageFormat
        self.sessionAttributes = sessionAttributes
        self.sessionId = sessionId
        self.slotToElicit = slotToElicit
        self.slots = slots
    }
}

struct PutSessionOutputResponseBody: Equatable {
    public let audioStream: Data?
}

extension PutSessionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case audioStream
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let audioStreamDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .audioStream)
        audioStream = audioStreamDecoded
    }
}

extension RequestTimeoutException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RequestTimeoutException(message: \(String(describing: message)))"}
}

extension RequestTimeoutException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RequestTimeoutExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The input speech is too long.</p>
public struct RequestTimeoutException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct RequestTimeoutExceptionBody: Equatable {
    public let message: String?
}

extension RequestTimeoutExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResponseCard: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case contentType
        case genericAttachments
        case version
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contentType = contentType {
            try encodeContainer.encode(contentType.rawValue, forKey: .contentType)
        }
        if let genericAttachments = genericAttachments {
            var genericAttachmentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .genericAttachments)
            for genericattachmentlist0 in genericAttachments {
                try genericAttachmentsContainer.encode(genericattachmentlist0)
            }
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
        let contentTypeDecoded = try containerValues.decodeIfPresent(ContentType.self, forKey: .contentType)
        contentType = contentTypeDecoded
        let genericAttachmentsContainer = try containerValues.decodeIfPresent([GenericAttachment?].self, forKey: .genericAttachments)
        var genericAttachmentsDecoded0:[GenericAttachment]? = nil
        if let genericAttachmentsContainer = genericAttachmentsContainer {
            genericAttachmentsDecoded0 = [GenericAttachment]()
            for structure0 in genericAttachmentsContainer {
                if let structure0 = structure0 {
                    genericAttachmentsDecoded0?.append(structure0)
                }
            }
        }
        genericAttachments = genericAttachmentsDecoded0
    }
}

extension ResponseCard: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResponseCard(contentType: \(String(describing: contentType)), genericAttachments: \(String(describing: genericAttachments)), version: \(String(describing: version)))"}
}

/// <p>If you configure a response card when creating your bots, Amazon Lex
///       substitutes the session attributes and slot values that are available, and
///       then returns it. The response card can also come from a Lambda function (
///         <code>dialogCodeHook</code> and <code>fulfillmentActivity</code> on an
///       intent).</p>
public struct ResponseCard: Equatable {
    /// <p>The content type of the response.</p>
    public let contentType: ContentType?
    /// <p>An array of attachment objects representing options.</p>
    public let genericAttachments: [GenericAttachment]?
    /// <p>The version of the response card format.</p>
    public let version: String?

    public init (
        contentType: ContentType? = nil,
        genericAttachments: [GenericAttachment]? = nil,
        version: String? = nil
    )
    {
        self.contentType = contentType
        self.genericAttachments = genericAttachments
        self.version = version
    }
}

extension SentimentResponse: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case sentimentLabel
        case sentimentScore
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sentimentLabel = sentimentLabel {
            try encodeContainer.encode(sentimentLabel, forKey: .sentimentLabel)
        }
        if let sentimentScore = sentimentScore {
            try encodeContainer.encode(sentimentScore, forKey: .sentimentScore)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sentimentLabelDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sentimentLabel)
        sentimentLabel = sentimentLabelDecoded
        let sentimentScoreDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sentimentScore)
        sentimentScore = sentimentScoreDecoded
    }
}

extension SentimentResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SentimentResponse(sentimentLabel: \(String(describing: sentimentLabel)), sentimentScore: \(String(describing: sentimentScore)))"}
}

/// <p>The sentiment expressed in an utterance.</p>
///          <p>When the bot is configured to send utterances to Amazon Comprehend for
///       sentiment analysis, this field structure contains the result of the
///       analysis.</p>
public struct SentimentResponse: Equatable {
    /// <p>The inferred sentiment that Amazon Comprehend has the highest
    ///       confidence in.</p>
    public let sentimentLabel: String?
    /// <p>The likelihood that the sentiment was correctly inferred.</p>
    public let sentimentScore: String?

    public init (
        sentimentLabel: String? = nil,
        sentimentScore: String? = nil
    )
    {
        self.sentimentLabel = sentimentLabel
        self.sentimentScore = sentimentScore
    }
}

extension UnsupportedMediaTypeException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UnsupportedMediaTypeException(message: \(String(describing: message)))"}
}

extension UnsupportedMediaTypeException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UnsupportedMediaTypeExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The Content-Type header (<code>PostContent</code> API) has an invalid
///       value. </p>
public struct UnsupportedMediaTypeException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct UnsupportedMediaTypeExceptionBody: Equatable {
    public let message: String?
}

extension UnsupportedMediaTypeExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}
