// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccessDeniedException(error: \(String(describing: error)), error_description: \(String(describing: error_description)))"}
}

extension AccessDeniedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.error = output.error
            self.error_description = output.error_description
        } else {
            self.error = nil
            self.error_description = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You do not have sufficient access to perform this action.</p>
public struct AccessDeniedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var error: String?
    public var error_description: String?

    public init (
        error: String? = nil,
        error_description: String? = nil
    )
    {
        self.error = error
        self.error_description = error_description
    }
}

struct AccessDeniedExceptionBody: Equatable {
    public let error: String?
    public let error_description: String?
}

extension AccessDeniedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case error
        case error_description
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorDecoded = try containerValues.decodeIfPresent(String.self, forKey: .error)
        error = errorDecoded
        let error_descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .error_description)
        error_description = error_descriptionDecoded
    }
}

extension AuthorizationPendingException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AuthorizationPendingException(error: \(String(describing: error)), error_description: \(String(describing: error_description)))"}
}

extension AuthorizationPendingException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AuthorizationPendingExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.error = output.error
            self.error_description = output.error_description
        } else {
            self.error = nil
            self.error_description = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Indicates that a request to authorize a client with an access user session token is pending.</p>
public struct AuthorizationPendingException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var error: String?
    public var error_description: String?

    public init (
        error: String? = nil,
        error_description: String? = nil
    )
    {
        self.error = error
        self.error_description = error_description
    }
}

struct AuthorizationPendingExceptionBody: Equatable {
    public let error: String?
    public let error_description: String?
}

extension AuthorizationPendingExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case error
        case error_description
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorDecoded = try containerValues.decodeIfPresent(String.self, forKey: .error)
        error = errorDecoded
        let error_descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .error_description)
        error_description = error_descriptionDecoded
    }
}

public struct CreateTokenInputBodyMiddleware: Middleware {
    public let id: String = "CreateTokenInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateTokenInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateTokenOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateTokenInput>
    public typealias MOutput = OperationOutput<CreateTokenOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateTokenOutputError>
}

extension CreateTokenInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateTokenInput(clientId: \(String(describing: clientId)), clientSecret: \(String(describing: clientSecret)), code: \(String(describing: code)), deviceCode: \(String(describing: deviceCode)), grantType: \(String(describing: grantType)), redirectUri: \(String(describing: redirectUri)), refreshToken: \(String(describing: refreshToken)), scope: \(String(describing: scope)))"}
}

extension CreateTokenInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientId
        case clientSecret
        case code
        case deviceCode
        case grantType
        case redirectUri
        case refreshToken
        case scope
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientId = clientId {
            try encodeContainer.encode(clientId, forKey: .clientId)
        }
        if let clientSecret = clientSecret {
            try encodeContainer.encode(clientSecret, forKey: .clientSecret)
        }
        if let code = code {
            try encodeContainer.encode(code, forKey: .code)
        }
        if let deviceCode = deviceCode {
            try encodeContainer.encode(deviceCode, forKey: .deviceCode)
        }
        if let grantType = grantType {
            try encodeContainer.encode(grantType, forKey: .grantType)
        }
        if let redirectUri = redirectUri {
            try encodeContainer.encode(redirectUri, forKey: .redirectUri)
        }
        if let refreshToken = refreshToken {
            try encodeContainer.encode(refreshToken, forKey: .refreshToken)
        }
        if let scope = scope {
            var scopeContainer = encodeContainer.nestedUnkeyedContainer(forKey: .scope)
            for scopes0 in scope {
                try scopeContainer.encode(scopes0)
            }
        }
    }
}

public struct CreateTokenInputHeadersMiddleware: Middleware {
    public let id: String = "CreateTokenInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateTokenInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateTokenOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateTokenInput>
    public typealias MOutput = OperationOutput<CreateTokenOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateTokenOutputError>
}

public struct CreateTokenInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateTokenInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateTokenInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateTokenOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateTokenInput>
    public typealias MOutput = OperationOutput<CreateTokenOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateTokenOutputError>
}

public struct CreateTokenInput: Equatable {
    /// <p>The unique identifier string for each client. This value should come from the persisted result of the <a>RegisterClient</a> API.</p>
    public let clientId: String?
    /// <p>A secret string generated for the client. This value should come from the persisted result of the <a>RegisterClient</a> API.</p>
    public let clientSecret: String?
    /// <p>The authorization code received from the authorization service. This parameter is required to perform an authorization grant request to get access to a token.</p>
    public let code: String?
    /// <p>Used only when calling this API for the device code grant type. This short-term code is
    ///       used to identify this authentication attempt. This should come from an in-memory reference to
    ///       the result of the <a>StartDeviceAuthorization</a> API.</p>
    public let deviceCode: String?
    /// <p>Supports grant types for authorization code, refresh token, and device code request.</p>
    public let grantType: String?
    /// <p>The location of the application that will receive the authorization code. Users authorize
    ///       the service to send the request to this location.</p>
    public let redirectUri: String?
    /// <p>The token used to obtain an access token in the event that the access token is invalid or expired. This token is not issued by the service.</p>
    public let refreshToken: String?
    /// <p>The list of scopes that is defined by the client. Upon authorization, this list is used to
    ///       restrict permissions when granting an access token.</p>
    public let scope: [String]?

    public init (
        clientId: String? = nil,
        clientSecret: String? = nil,
        code: String? = nil,
        deviceCode: String? = nil,
        grantType: String? = nil,
        redirectUri: String? = nil,
        refreshToken: String? = nil,
        scope: [String]? = nil
    )
    {
        self.clientId = clientId
        self.clientSecret = clientSecret
        self.code = code
        self.deviceCode = deviceCode
        self.grantType = grantType
        self.redirectUri = redirectUri
        self.refreshToken = refreshToken
        self.scope = scope
    }
}

struct CreateTokenInputBody: Equatable {
    public let clientId: String?
    public let clientSecret: String?
    public let grantType: String?
    public let deviceCode: String?
    public let code: String?
    public let refreshToken: String?
    public let scope: [String]?
    public let redirectUri: String?
}

extension CreateTokenInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientId
        case clientSecret
        case code
        case deviceCode
        case grantType
        case redirectUri
        case refreshToken
        case scope
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientId)
        clientId = clientIdDecoded
        let clientSecretDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientSecret)
        clientSecret = clientSecretDecoded
        let grantTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .grantType)
        grantType = grantTypeDecoded
        let deviceCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deviceCode)
        deviceCode = deviceCodeDecoded
        let codeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .code)
        code = codeDecoded
        let refreshTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .refreshToken)
        refreshToken = refreshTokenDecoded
        let scopeContainer = try containerValues.decodeIfPresent([String?].self, forKey: .scope)
        var scopeDecoded0:[String]? = nil
        if let scopeContainer = scopeContainer {
            scopeDecoded0 = [String]()
            for string0 in scopeContainer {
                if let string0 = string0 {
                    scopeDecoded0?.append(string0)
                }
            }
        }
        scope = scopeDecoded0
        let redirectUriDecoded = try containerValues.decodeIfPresent(String.self, forKey: .redirectUri)
        redirectUri = redirectUriDecoded
    }
}

extension CreateTokenOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateTokenOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AuthorizationPendingException" : self = .authorizationPendingException(try AuthorizationPendingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ExpiredTokenException" : self = .expiredTokenException(try ExpiredTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClientException" : self = .invalidClientException(try InvalidClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGrantException" : self = .invalidGrantException(try InvalidGrantException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidScopeException" : self = .invalidScopeException(try InvalidScopeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SlowDownException" : self = .slowDownException(try SlowDownException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedGrantTypeException" : self = .unsupportedGrantTypeException(try UnsupportedGrantTypeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateTokenOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case authorizationPendingException(AuthorizationPendingException)
    case expiredTokenException(ExpiredTokenException)
    case internalServerException(InternalServerException)
    case invalidClientException(InvalidClientException)
    case invalidGrantException(InvalidGrantException)
    case invalidRequestException(InvalidRequestException)
    case invalidScopeException(InvalidScopeException)
    case slowDownException(SlowDownException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unsupportedGrantTypeException(UnsupportedGrantTypeException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateTokenOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateTokenOutputResponse(accessToken: \(String(describing: accessToken)), expiresIn: \(String(describing: expiresIn)), idToken: \(String(describing: idToken)), refreshToken: \(String(describing: refreshToken)), tokenType: \(String(describing: tokenType)))"}
}

extension CreateTokenOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateTokenOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.accessToken = output.accessToken
            self.expiresIn = output.expiresIn
            self.idToken = output.idToken
            self.refreshToken = output.refreshToken
            self.tokenType = output.tokenType
        } else {
            self.accessToken = nil
            self.expiresIn = 0
            self.idToken = nil
            self.refreshToken = nil
            self.tokenType = nil
        }
    }
}

public struct CreateTokenOutputResponse: Equatable {
    /// <p>An opaque token to access AWS SSO resources assigned to a user.</p>
    public let accessToken: String?
    /// <p>Indicates the time in seconds when an access token will expire.</p>
    public let expiresIn: Int
    /// <p>The identifier of the user that associated with the access token, if present.</p>
    public let idToken: String?
    /// <p>A token that, if present, can be used to refresh a previously issued access token that
    ///       might have expired.</p>
    public let refreshToken: String?
    /// <p>Used to notify the client that the returned token is an access token. The supported type
    ///       is <code>BearerToken</code>.</p>
    public let tokenType: String?

    public init (
        accessToken: String? = nil,
        expiresIn: Int = 0,
        idToken: String? = nil,
        refreshToken: String? = nil,
        tokenType: String? = nil
    )
    {
        self.accessToken = accessToken
        self.expiresIn = expiresIn
        self.idToken = idToken
        self.refreshToken = refreshToken
        self.tokenType = tokenType
    }
}

struct CreateTokenOutputResponseBody: Equatable {
    public let accessToken: String?
    public let tokenType: String?
    public let expiresIn: Int
    public let refreshToken: String?
    public let idToken: String?
}

extension CreateTokenOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accessToken
        case expiresIn
        case idToken
        case refreshToken
        case tokenType
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accessToken)
        accessToken = accessTokenDecoded
        let tokenTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tokenType)
        tokenType = tokenTypeDecoded
        let expiresInDecoded = try containerValues.decode(Int.self, forKey: .expiresIn)
        expiresIn = expiresInDecoded
        let refreshTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .refreshToken)
        refreshToken = refreshTokenDecoded
        let idTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .idToken)
        idToken = idTokenDecoded
    }
}

extension ExpiredTokenException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ExpiredTokenException(error: \(String(describing: error)), error_description: \(String(describing: error_description)))"}
}

extension ExpiredTokenException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ExpiredTokenExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.error = output.error
            self.error_description = output.error_description
        } else {
            self.error = nil
            self.error_description = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Indicates that the token issued by the service is expired and is no longer valid.</p>
public struct ExpiredTokenException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var error: String?
    public var error_description: String?

    public init (
        error: String? = nil,
        error_description: String? = nil
    )
    {
        self.error = error
        self.error_description = error_description
    }
}

struct ExpiredTokenExceptionBody: Equatable {
    public let error: String?
    public let error_description: String?
}

extension ExpiredTokenExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case error
        case error_description
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorDecoded = try containerValues.decodeIfPresent(String.self, forKey: .error)
        error = errorDecoded
        let error_descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .error_description)
        error_description = error_descriptionDecoded
    }
}

extension InternalServerException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalServerException(error: \(String(describing: error)), error_description: \(String(describing: error_description)))"}
}

extension InternalServerException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.error = output.error
            self.error_description = output.error_description
        } else {
            self.error = nil
            self.error_description = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Indicates that an error from the service occurred while trying to process a request.</p>
public struct InternalServerException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var error: String?
    public var error_description: String?

    public init (
        error: String? = nil,
        error_description: String? = nil
    )
    {
        self.error = error
        self.error_description = error_description
    }
}

struct InternalServerExceptionBody: Equatable {
    public let error: String?
    public let error_description: String?
}

extension InternalServerExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case error
        case error_description
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorDecoded = try containerValues.decodeIfPresent(String.self, forKey: .error)
        error = errorDecoded
        let error_descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .error_description)
        error_description = error_descriptionDecoded
    }
}

extension InvalidClientException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidClientException(error: \(String(describing: error)), error_description: \(String(describing: error_description)))"}
}

extension InvalidClientException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidClientExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.error = output.error
            self.error_description = output.error_description
        } else {
            self.error = nil
            self.error_description = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Indicates that the <code>clientId</code> or <code>clientSecret</code> in the request is
///       invalid. For example, this can occur when a client sends an incorrect <code>clientId</code> or
///       an expired <code>clientSecret</code>.</p>
public struct InvalidClientException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var error: String?
    public var error_description: String?

    public init (
        error: String? = nil,
        error_description: String? = nil
    )
    {
        self.error = error
        self.error_description = error_description
    }
}

struct InvalidClientExceptionBody: Equatable {
    public let error: String?
    public let error_description: String?
}

extension InvalidClientExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case error
        case error_description
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorDecoded = try containerValues.decodeIfPresent(String.self, forKey: .error)
        error = errorDecoded
        let error_descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .error_description)
        error_description = error_descriptionDecoded
    }
}

extension InvalidClientMetadataException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidClientMetadataException(error: \(String(describing: error)), error_description: \(String(describing: error_description)))"}
}

extension InvalidClientMetadataException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidClientMetadataExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.error = output.error
            self.error_description = output.error_description
        } else {
            self.error = nil
            self.error_description = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Indicates that the client information sent in the request during registration is invalid.</p>
public struct InvalidClientMetadataException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var error: String?
    public var error_description: String?

    public init (
        error: String? = nil,
        error_description: String? = nil
    )
    {
        self.error = error
        self.error_description = error_description
    }
}

struct InvalidClientMetadataExceptionBody: Equatable {
    public let error: String?
    public let error_description: String?
}

extension InvalidClientMetadataExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case error
        case error_description
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorDecoded = try containerValues.decodeIfPresent(String.self, forKey: .error)
        error = errorDecoded
        let error_descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .error_description)
        error_description = error_descriptionDecoded
    }
}

extension InvalidGrantException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidGrantException(error: \(String(describing: error)), error_description: \(String(describing: error_description)))"}
}

extension InvalidGrantException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidGrantExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.error = output.error
            self.error_description = output.error_description
        } else {
            self.error = nil
            self.error_description = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Indicates that a request contains an invalid grant. This can occur if a client makes a <a>CreateToken</a> request with an invalid grant type.</p>
public struct InvalidGrantException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var error: String?
    public var error_description: String?

    public init (
        error: String? = nil,
        error_description: String? = nil
    )
    {
        self.error = error
        self.error_description = error_description
    }
}

struct InvalidGrantExceptionBody: Equatable {
    public let error: String?
    public let error_description: String?
}

extension InvalidGrantExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case error
        case error_description
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorDecoded = try containerValues.decodeIfPresent(String.self, forKey: .error)
        error = errorDecoded
        let error_descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .error_description)
        error_description = error_descriptionDecoded
    }
}

extension InvalidRequestException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidRequestException(error: \(String(describing: error)), error_description: \(String(describing: error_description)))"}
}

extension InvalidRequestException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidRequestExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.error = output.error
            self.error_description = output.error_description
        } else {
            self.error = nil
            self.error_description = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Indicates that something is wrong with the input to the request. For example, a required
///       parameter might be missing or out of range.</p>
public struct InvalidRequestException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var error: String?
    public var error_description: String?

    public init (
        error: String? = nil,
        error_description: String? = nil
    )
    {
        self.error = error
        self.error_description = error_description
    }
}

struct InvalidRequestExceptionBody: Equatable {
    public let error: String?
    public let error_description: String?
}

extension InvalidRequestExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case error
        case error_description
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorDecoded = try containerValues.decodeIfPresent(String.self, forKey: .error)
        error = errorDecoded
        let error_descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .error_description)
        error_description = error_descriptionDecoded
    }
}

extension InvalidScopeException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidScopeException(error: \(String(describing: error)), error_description: \(String(describing: error_description)))"}
}

extension InvalidScopeException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidScopeExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.error = output.error
            self.error_description = output.error_description
        } else {
            self.error = nil
            self.error_description = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Indicates that the scope provided in the request is invalid.</p>
public struct InvalidScopeException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var error: String?
    public var error_description: String?

    public init (
        error: String? = nil,
        error_description: String? = nil
    )
    {
        self.error = error
        self.error_description = error_description
    }
}

struct InvalidScopeExceptionBody: Equatable {
    public let error: String?
    public let error_description: String?
}

extension InvalidScopeExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case error
        case error_description
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorDecoded = try containerValues.decodeIfPresent(String.self, forKey: .error)
        error = errorDecoded
        let error_descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .error_description)
        error_description = error_descriptionDecoded
    }
}

public struct RegisterClientInputBodyMiddleware: Middleware {
    public let id: String = "RegisterClientInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RegisterClientInput>,
                  next: H) -> Swift.Result<OperationOutput<RegisterClientOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RegisterClientInput>
    public typealias MOutput = OperationOutput<RegisterClientOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RegisterClientOutputError>
}

extension RegisterClientInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RegisterClientInput(clientName: \(String(describing: clientName)), clientType: \(String(describing: clientType)), scopes: \(String(describing: scopes)))"}
}

extension RegisterClientInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientName
        case clientType
        case scopes
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientName = clientName {
            try encodeContainer.encode(clientName, forKey: .clientName)
        }
        if let clientType = clientType {
            try encodeContainer.encode(clientType, forKey: .clientType)
        }
        if let scopes = scopes {
            var scopesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .scopes)
            for scopes0 in scopes {
                try scopesContainer.encode(scopes0)
            }
        }
    }
}

public struct RegisterClientInputHeadersMiddleware: Middleware {
    public let id: String = "RegisterClientInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RegisterClientInput>,
                  next: H) -> Swift.Result<OperationOutput<RegisterClientOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RegisterClientInput>
    public typealias MOutput = OperationOutput<RegisterClientOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RegisterClientOutputError>
}

public struct RegisterClientInputQueryItemMiddleware: Middleware {
    public let id: String = "RegisterClientInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RegisterClientInput>,
                  next: H) -> Swift.Result<OperationOutput<RegisterClientOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RegisterClientInput>
    public typealias MOutput = OperationOutput<RegisterClientOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RegisterClientOutputError>
}

public struct RegisterClientInput: Equatable {
    /// <p>The friendly name of the client.</p>
    public let clientName: String?
    /// <p>The type of client. The service supports only <code>public</code> as a client type. Anything other than public will be rejected by the service.</p>
    public let clientType: String?
    /// <p>The list of scopes that are defined by the client. Upon authorization, this list is used
    ///       to restrict permissions when granting an access token.</p>
    public let scopes: [String]?

    public init (
        clientName: String? = nil,
        clientType: String? = nil,
        scopes: [String]? = nil
    )
    {
        self.clientName = clientName
        self.clientType = clientType
        self.scopes = scopes
    }
}

struct RegisterClientInputBody: Equatable {
    public let clientName: String?
    public let clientType: String?
    public let scopes: [String]?
}

extension RegisterClientInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientName
        case clientType
        case scopes
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientName)
        clientName = clientNameDecoded
        let clientTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientType)
        clientType = clientTypeDecoded
        let scopesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .scopes)
        var scopesDecoded0:[String]? = nil
        if let scopesContainer = scopesContainer {
            scopesDecoded0 = [String]()
            for string0 in scopesContainer {
                if let string0 = string0 {
                    scopesDecoded0?.append(string0)
                }
            }
        }
        scopes = scopesDecoded0
    }
}

extension RegisterClientOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RegisterClientOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClientMetadataException" : self = .invalidClientMetadataException(try InvalidClientMetadataException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidScopeException" : self = .invalidScopeException(try InvalidScopeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RegisterClientOutputError: Equatable {
    case internalServerException(InternalServerException)
    case invalidClientMetadataException(InvalidClientMetadataException)
    case invalidRequestException(InvalidRequestException)
    case invalidScopeException(InvalidScopeException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RegisterClientOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RegisterClientOutputResponse(authorizationEndpoint: \(String(describing: authorizationEndpoint)), clientId: \(String(describing: clientId)), clientIdIssuedAt: \(String(describing: clientIdIssuedAt)), clientSecret: \(String(describing: clientSecret)), clientSecretExpiresAt: \(String(describing: clientSecretExpiresAt)), tokenEndpoint: \(String(describing: tokenEndpoint)))"}
}

extension RegisterClientOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RegisterClientOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.authorizationEndpoint = output.authorizationEndpoint
            self.clientId = output.clientId
            self.clientIdIssuedAt = output.clientIdIssuedAt
            self.clientSecret = output.clientSecret
            self.clientSecretExpiresAt = output.clientSecretExpiresAt
            self.tokenEndpoint = output.tokenEndpoint
        } else {
            self.authorizationEndpoint = nil
            self.clientId = nil
            self.clientIdIssuedAt = 0
            self.clientSecret = nil
            self.clientSecretExpiresAt = 0
            self.tokenEndpoint = nil
        }
    }
}

public struct RegisterClientOutputResponse: Equatable {
    /// <p>The endpoint where the client can request authorization.</p>
    public let authorizationEndpoint: String?
    /// <p>The unique identifier string for each client. This client uses this identifier to get
    ///       authenticated by the service in subsequent calls.</p>
    public let clientId: String?
    /// <p>Indicates the time at which the <code>clientId</code> and <code>clientSecret</code> were issued.</p>
    public let clientIdIssuedAt: Int
    /// <p>A secret string generated for the client. The client will use this string to get
    ///       authenticated by the service in subsequent calls.</p>
    public let clientSecret: String?
    /// <p>Indicates the time at which the <code>clientId</code> and <code>clientSecret</code> will become invalid.</p>
    public let clientSecretExpiresAt: Int
    /// <p>The endpoint where the client can get an access token.</p>
    public let tokenEndpoint: String?

    public init (
        authorizationEndpoint: String? = nil,
        clientId: String? = nil,
        clientIdIssuedAt: Int = 0,
        clientSecret: String? = nil,
        clientSecretExpiresAt: Int = 0,
        tokenEndpoint: String? = nil
    )
    {
        self.authorizationEndpoint = authorizationEndpoint
        self.clientId = clientId
        self.clientIdIssuedAt = clientIdIssuedAt
        self.clientSecret = clientSecret
        self.clientSecretExpiresAt = clientSecretExpiresAt
        self.tokenEndpoint = tokenEndpoint
    }
}

struct RegisterClientOutputResponseBody: Equatable {
    public let clientId: String?
    public let clientSecret: String?
    public let clientIdIssuedAt: Int
    public let clientSecretExpiresAt: Int
    public let authorizationEndpoint: String?
    public let tokenEndpoint: String?
}

extension RegisterClientOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case authorizationEndpoint
        case clientId
        case clientIdIssuedAt
        case clientSecret
        case clientSecretExpiresAt
        case tokenEndpoint
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientId)
        clientId = clientIdDecoded
        let clientSecretDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientSecret)
        clientSecret = clientSecretDecoded
        let clientIdIssuedAtDecoded = try containerValues.decode(Int.self, forKey: .clientIdIssuedAt)
        clientIdIssuedAt = clientIdIssuedAtDecoded
        let clientSecretExpiresAtDecoded = try containerValues.decode(Int.self, forKey: .clientSecretExpiresAt)
        clientSecretExpiresAt = clientSecretExpiresAtDecoded
        let authorizationEndpointDecoded = try containerValues.decodeIfPresent(String.self, forKey: .authorizationEndpoint)
        authorizationEndpoint = authorizationEndpointDecoded
        let tokenEndpointDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tokenEndpoint)
        tokenEndpoint = tokenEndpointDecoded
    }
}

extension SlowDownException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SlowDownException(error: \(String(describing: error)), error_description: \(String(describing: error_description)))"}
}

extension SlowDownException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: SlowDownExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.error = output.error
            self.error_description = output.error_description
        } else {
            self.error = nil
            self.error_description = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Indicates that the client is making the request too frequently and is more than the service can handle. </p>
public struct SlowDownException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var error: String?
    public var error_description: String?

    public init (
        error: String? = nil,
        error_description: String? = nil
    )
    {
        self.error = error
        self.error_description = error_description
    }
}

struct SlowDownExceptionBody: Equatable {
    public let error: String?
    public let error_description: String?
}

extension SlowDownExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case error
        case error_description
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorDecoded = try containerValues.decodeIfPresent(String.self, forKey: .error)
        error = errorDecoded
        let error_descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .error_description)
        error_description = error_descriptionDecoded
    }
}

public struct StartDeviceAuthorizationInputBodyMiddleware: Middleware {
    public let id: String = "StartDeviceAuthorizationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartDeviceAuthorizationInput>,
                  next: H) -> Swift.Result<OperationOutput<StartDeviceAuthorizationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartDeviceAuthorizationInput>
    public typealias MOutput = OperationOutput<StartDeviceAuthorizationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartDeviceAuthorizationOutputError>
}

extension StartDeviceAuthorizationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartDeviceAuthorizationInput(clientId: \(String(describing: clientId)), clientSecret: \(String(describing: clientSecret)), startUrl: \(String(describing: startUrl)))"}
}

extension StartDeviceAuthorizationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientId
        case clientSecret
        case startUrl
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientId = clientId {
            try encodeContainer.encode(clientId, forKey: .clientId)
        }
        if let clientSecret = clientSecret {
            try encodeContainer.encode(clientSecret, forKey: .clientSecret)
        }
        if let startUrl = startUrl {
            try encodeContainer.encode(startUrl, forKey: .startUrl)
        }
    }
}

public struct StartDeviceAuthorizationInputHeadersMiddleware: Middleware {
    public let id: String = "StartDeviceAuthorizationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartDeviceAuthorizationInput>,
                  next: H) -> Swift.Result<OperationOutput<StartDeviceAuthorizationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartDeviceAuthorizationInput>
    public typealias MOutput = OperationOutput<StartDeviceAuthorizationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartDeviceAuthorizationOutputError>
}

public struct StartDeviceAuthorizationInputQueryItemMiddleware: Middleware {
    public let id: String = "StartDeviceAuthorizationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartDeviceAuthorizationInput>,
                  next: H) -> Swift.Result<OperationOutput<StartDeviceAuthorizationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartDeviceAuthorizationInput>
    public typealias MOutput = OperationOutput<StartDeviceAuthorizationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartDeviceAuthorizationOutputError>
}

public struct StartDeviceAuthorizationInput: Equatable {
    /// <p>The unique identifier string for the client that is registered with AWS SSO. This value
    ///       should come from the persisted result of the <a>RegisterClient</a> API
    ///       operation.</p>
    public let clientId: String?
    /// <p>A secret string that is generated for the client. This value should come from the
    ///       persisted result of the <a>RegisterClient</a> API operation.</p>
    public let clientSecret: String?
    /// <p>The URL for the AWS SSO user portal. For more information, see <a href="https://docs.aws.amazon.com/singlesignon/latest/userguide/using-the-portal.html">Using
    ///         the User Portal</a> in the <i>AWS Single Sign-On User Guide</i>.</p>
    public let startUrl: String?

    public init (
        clientId: String? = nil,
        clientSecret: String? = nil,
        startUrl: String? = nil
    )
    {
        self.clientId = clientId
        self.clientSecret = clientSecret
        self.startUrl = startUrl
    }
}

struct StartDeviceAuthorizationInputBody: Equatable {
    public let clientId: String?
    public let clientSecret: String?
    public let startUrl: String?
}

extension StartDeviceAuthorizationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientId
        case clientSecret
        case startUrl
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientId)
        clientId = clientIdDecoded
        let clientSecretDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientSecret)
        clientSecret = clientSecretDecoded
        let startUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .startUrl)
        startUrl = startUrlDecoded
    }
}

extension StartDeviceAuthorizationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartDeviceAuthorizationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClientException" : self = .invalidClientException(try InvalidClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SlowDownException" : self = .slowDownException(try SlowDownException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartDeviceAuthorizationOutputError: Equatable {
    case internalServerException(InternalServerException)
    case invalidClientException(InvalidClientException)
    case invalidRequestException(InvalidRequestException)
    case slowDownException(SlowDownException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartDeviceAuthorizationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartDeviceAuthorizationOutputResponse(deviceCode: \(String(describing: deviceCode)), expiresIn: \(String(describing: expiresIn)), interval: \(String(describing: interval)), userCode: \(String(describing: userCode)), verificationUri: \(String(describing: verificationUri)), verificationUriComplete: \(String(describing: verificationUriComplete)))"}
}

extension StartDeviceAuthorizationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StartDeviceAuthorizationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.deviceCode = output.deviceCode
            self.expiresIn = output.expiresIn
            self.interval = output.interval
            self.userCode = output.userCode
            self.verificationUri = output.verificationUri
            self.verificationUriComplete = output.verificationUriComplete
        } else {
            self.deviceCode = nil
            self.expiresIn = 0
            self.interval = 0
            self.userCode = nil
            self.verificationUri = nil
            self.verificationUriComplete = nil
        }
    }
}

public struct StartDeviceAuthorizationOutputResponse: Equatable {
    /// <p>The short-lived code that is used by the device when polling for a session token.</p>
    public let deviceCode: String?
    /// <p>Indicates the number of seconds in which the verification code will become invalid.</p>
    public let expiresIn: Int
    /// <p>Indicates the number of seconds the client must wait between attempts when polling for a session.</p>
    public let interval: Int
    /// <p>A one-time user verification code. This is needed to authorize an in-use device.</p>
    public let userCode: String?
    /// <p>The URI of the verification page that takes the <code>userCode</code> to authorize the device.</p>
    public let verificationUri: String?
    /// <p>An alternate URL that the client can use to automatically launch a browser. This process
    ///       skips the manual step in which the user visits the verification page and enters their
    ///       code.</p>
    public let verificationUriComplete: String?

    public init (
        deviceCode: String? = nil,
        expiresIn: Int = 0,
        interval: Int = 0,
        userCode: String? = nil,
        verificationUri: String? = nil,
        verificationUriComplete: String? = nil
    )
    {
        self.deviceCode = deviceCode
        self.expiresIn = expiresIn
        self.interval = interval
        self.userCode = userCode
        self.verificationUri = verificationUri
        self.verificationUriComplete = verificationUriComplete
    }
}

struct StartDeviceAuthorizationOutputResponseBody: Equatable {
    public let deviceCode: String?
    public let userCode: String?
    public let verificationUri: String?
    public let verificationUriComplete: String?
    public let expiresIn: Int
    public let interval: Int
}

extension StartDeviceAuthorizationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case deviceCode
        case expiresIn
        case interval
        case userCode
        case verificationUri
        case verificationUriComplete
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deviceCode)
        deviceCode = deviceCodeDecoded
        let userCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userCode)
        userCode = userCodeDecoded
        let verificationUriDecoded = try containerValues.decodeIfPresent(String.self, forKey: .verificationUri)
        verificationUri = verificationUriDecoded
        let verificationUriCompleteDecoded = try containerValues.decodeIfPresent(String.self, forKey: .verificationUriComplete)
        verificationUriComplete = verificationUriCompleteDecoded
        let expiresInDecoded = try containerValues.decode(Int.self, forKey: .expiresIn)
        expiresIn = expiresInDecoded
        let intervalDecoded = try containerValues.decode(Int.self, forKey: .interval)
        interval = intervalDecoded
    }
}

extension UnauthorizedClientException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UnauthorizedClientException(error: \(String(describing: error)), error_description: \(String(describing: error_description)))"}
}

extension UnauthorizedClientException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UnauthorizedClientExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.error = output.error
            self.error_description = output.error_description
        } else {
            self.error = nil
            self.error_description = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Indicates that the client is not currently authorized to make the request. This can happen
///       when a <code>clientId</code> is not issued for a public client.</p>
public struct UnauthorizedClientException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var error: String?
    public var error_description: String?

    public init (
        error: String? = nil,
        error_description: String? = nil
    )
    {
        self.error = error
        self.error_description = error_description
    }
}

struct UnauthorizedClientExceptionBody: Equatable {
    public let error: String?
    public let error_description: String?
}

extension UnauthorizedClientExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case error
        case error_description
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorDecoded = try containerValues.decodeIfPresent(String.self, forKey: .error)
        error = errorDecoded
        let error_descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .error_description)
        error_description = error_descriptionDecoded
    }
}

extension UnsupportedGrantTypeException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UnsupportedGrantTypeException(error: \(String(describing: error)), error_description: \(String(describing: error_description)))"}
}

extension UnsupportedGrantTypeException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UnsupportedGrantTypeExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.error = output.error
            self.error_description = output.error_description
        } else {
            self.error = nil
            self.error_description = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Indicates that the grant type in the request is not supported by the service.</p>
public struct UnsupportedGrantTypeException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var error: String?
    public var error_description: String?

    public init (
        error: String? = nil,
        error_description: String? = nil
    )
    {
        self.error = error
        self.error_description = error_description
    }
}

struct UnsupportedGrantTypeExceptionBody: Equatable {
    public let error: String?
    public let error_description: String?
}

extension UnsupportedGrantTypeExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case error
        case error_description
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorDecoded = try containerValues.decodeIfPresent(String.self, forKey: .error)
        error = errorDecoded
        let error_descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .error_description)
        error_description = error_descriptionDecoded
    }
}
