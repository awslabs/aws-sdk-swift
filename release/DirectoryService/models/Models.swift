// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

public struct AcceptSharedDirectoryInputBodyMiddleware: Middleware {
    public let id: String = "AcceptSharedDirectoryInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AcceptSharedDirectoryInput>,
                  next: H) -> Swift.Result<OperationOutput<AcceptSharedDirectoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AcceptSharedDirectoryInput>
    public typealias MOutput = OperationOutput<AcceptSharedDirectoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AcceptSharedDirectoryOutputError>
}

extension AcceptSharedDirectoryInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AcceptSharedDirectoryInput(sharedDirectoryId: \(String(describing: sharedDirectoryId)))"}
}

extension AcceptSharedDirectoryInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case sharedDirectoryId = "SharedDirectoryId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sharedDirectoryId = sharedDirectoryId {
            try encodeContainer.encode(sharedDirectoryId, forKey: .sharedDirectoryId)
        }
    }
}

public struct AcceptSharedDirectoryInputHeadersMiddleware: Middleware {
    public let id: String = "AcceptSharedDirectoryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AcceptSharedDirectoryInput>,
                  next: H) -> Swift.Result<OperationOutput<AcceptSharedDirectoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AcceptSharedDirectoryInput>
    public typealias MOutput = OperationOutput<AcceptSharedDirectoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AcceptSharedDirectoryOutputError>
}

public struct AcceptSharedDirectoryInputQueryItemMiddleware: Middleware {
    public let id: String = "AcceptSharedDirectoryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AcceptSharedDirectoryInput>,
                  next: H) -> Swift.Result<OperationOutput<AcceptSharedDirectoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AcceptSharedDirectoryInput>
    public typealias MOutput = OperationOutput<AcceptSharedDirectoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AcceptSharedDirectoryOutputError>
}

public struct AcceptSharedDirectoryInput: Equatable {
    /// <p>Identifier of the shared directory in the directory consumer account. This identifier is
    ///       different for each directory owner account. </p>
    public let sharedDirectoryId: String?

    public init (
        sharedDirectoryId: String? = nil
    )
    {
        self.sharedDirectoryId = sharedDirectoryId
    }
}

struct AcceptSharedDirectoryInputBody: Equatable {
    public let sharedDirectoryId: String?
}

extension AcceptSharedDirectoryInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case sharedDirectoryId = "SharedDirectoryId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sharedDirectoryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sharedDirectoryId)
        sharedDirectoryId = sharedDirectoryIdDecoded
    }
}

extension AcceptSharedDirectoryOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AcceptSharedDirectoryOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryAlreadySharedException" : self = .directoryAlreadySharedException(try DirectoryAlreadySharedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityDoesNotExistException" : self = .entityDoesNotExistException(try EntityDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AcceptSharedDirectoryOutputError: Equatable {
    case clientException(ClientException)
    case directoryAlreadySharedException(DirectoryAlreadySharedException)
    case entityDoesNotExistException(EntityDoesNotExistException)
    case invalidParameterException(InvalidParameterException)
    case serviceException(ServiceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AcceptSharedDirectoryOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AcceptSharedDirectoryOutputResponse(sharedDirectory: \(String(describing: sharedDirectory)))"}
}

extension AcceptSharedDirectoryOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AcceptSharedDirectoryOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.sharedDirectory = output.sharedDirectory
        } else {
            self.sharedDirectory = nil
        }
    }
}

public struct AcceptSharedDirectoryOutputResponse: Equatable {
    /// <p>The shared directory in the directory consumer account.</p>
    public let sharedDirectory: SharedDirectory?

    public init (
        sharedDirectory: SharedDirectory? = nil
    )
    {
        self.sharedDirectory = sharedDirectory
    }
}

struct AcceptSharedDirectoryOutputResponseBody: Equatable {
    public let sharedDirectory: SharedDirectory?
}

extension AcceptSharedDirectoryOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case sharedDirectory = "SharedDirectory"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sharedDirectoryDecoded = try containerValues.decodeIfPresent(SharedDirectory.self, forKey: .sharedDirectory)
        sharedDirectory = sharedDirectoryDecoded
    }
}

extension AccessDeniedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccessDeniedException(message: \(String(describing: message)), requestId: \(String(describing: requestId)))"}
}

extension AccessDeniedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.requestId = output.requestId
        } else {
            self.message = nil
            self.requestId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Client authentication is not available in this region at this time.</p>
public struct AccessDeniedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The descriptive message for the exception.</p>
    public var message: String?
    /// <p>The AWS request identifier.</p>
    public var requestId: String?

    public init (
        message: String? = nil,
        requestId: String? = nil
    )
    {
        self.message = message
        self.requestId = requestId
    }
}

struct AccessDeniedExceptionBody: Equatable {
    public let message: String?
    public let requestId: String?
}

extension AccessDeniedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case requestId = "RequestId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

public struct AddIpRoutesInputBodyMiddleware: Middleware {
    public let id: String = "AddIpRoutesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddIpRoutesInput>,
                  next: H) -> Swift.Result<OperationOutput<AddIpRoutesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddIpRoutesInput>
    public typealias MOutput = OperationOutput<AddIpRoutesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddIpRoutesOutputError>
}

extension AddIpRoutesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AddIpRoutesInput(directoryId: \(String(describing: directoryId)), ipRoutes: \(String(describing: ipRoutes)), updateSecurityGroupForDirectoryControllers: \(String(describing: updateSecurityGroupForDirectoryControllers)))"}
}

extension AddIpRoutesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case directoryId = "DirectoryId"
        case ipRoutes = "IpRoutes"
        case updateSecurityGroupForDirectoryControllers = "UpdateSecurityGroupForDirectoryControllers"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryId = directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let ipRoutes = ipRoutes {
            var ipRoutesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ipRoutes)
            for iproutes0 in ipRoutes {
                try ipRoutesContainer.encode(iproutes0)
            }
        }
        if updateSecurityGroupForDirectoryControllers != false {
            try encodeContainer.encode(updateSecurityGroupForDirectoryControllers, forKey: .updateSecurityGroupForDirectoryControllers)
        }
    }
}

public struct AddIpRoutesInputHeadersMiddleware: Middleware {
    public let id: String = "AddIpRoutesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddIpRoutesInput>,
                  next: H) -> Swift.Result<OperationOutput<AddIpRoutesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddIpRoutesInput>
    public typealias MOutput = OperationOutput<AddIpRoutesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddIpRoutesOutputError>
}

public struct AddIpRoutesInputQueryItemMiddleware: Middleware {
    public let id: String = "AddIpRoutesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddIpRoutesInput>,
                  next: H) -> Swift.Result<OperationOutput<AddIpRoutesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddIpRoutesInput>
    public typealias MOutput = OperationOutput<AddIpRoutesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddIpRoutesOutputError>
}

public struct AddIpRoutesInput: Equatable {
    /// <p>Identifier (ID) of the directory to which to add the address block.</p>
    public let directoryId: String?
    /// <p>IP address blocks, using CIDR format, of the traffic to route. This is often the IP address block of the DNS server used for your on-premises domain.</p>
    public let ipRoutes: [IpRoute]?
    /// <p>If set to true, updates the inbound and outbound rules of the security group that has the description: "AWS created security group for <i>directory ID</i> directory controllers."
    ///          Following are the new rules:
    ///       </p>
    ///          <p>Inbound:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Type: Custom UDP Rule, Protocol: UDP, Range: 88, Source: 0.0.0.0/0</p>
    ///             </li>
    ///             <li>
    ///                <p>Type: Custom UDP Rule, Protocol: UDP, Range: 123, Source: 0.0.0.0/0</p>
    ///             </li>
    ///             <li>
    ///                <p>Type: Custom UDP Rule, Protocol: UDP, Range: 138, Source: 0.0.0.0/0</p>
    ///             </li>
    ///             <li>
    ///                <p>Type: Custom UDP Rule, Protocol: UDP, Range: 389, Source: 0.0.0.0/0</p>
    ///             </li>
    ///             <li>
    ///                <p>Type: Custom UDP Rule, Protocol: UDP, Range: 464, Source: 0.0.0.0/0</p>
    ///             </li>
    ///             <li>
    ///                <p>Type: Custom UDP Rule, Protocol: UDP, Range: 445, Source: 0.0.0.0/0</p>
    ///             </li>
    ///             <li>
    ///                <p>Type: Custom TCP Rule, Protocol: TCP, Range: 88, Source: 0.0.0.0/0</p>
    ///             </li>
    ///             <li>
    ///                <p>Type: Custom TCP Rule, Protocol: TCP, Range: 135, Source: 0.0.0.0/0</p>
    ///             </li>
    ///             <li>
    ///                <p>Type: Custom TCP Rule, Protocol: TCP, Range: 445, Source: 0.0.0.0/0</p>
    ///             </li>
    ///             <li>
    ///                <p>Type: Custom TCP Rule, Protocol: TCP, Range: 464, Source: 0.0.0.0/0</p>
    ///             </li>
    ///             <li>
    ///                <p>Type: Custom TCP Rule, Protocol: TCP, Range: 636, Source: 0.0.0.0/0</p>
    ///             </li>
    ///             <li>
    ///                <p>Type: Custom TCP Rule, Protocol: TCP, Range: 1024-65535, Source: 0.0.0.0/0</p>
    ///             </li>
    ///             <li>
    ///                <p>Type: Custom TCP Rule, Protocol: TCP, Range: 3268-33269, Source: 0.0.0.0/0</p>
    ///             </li>
    ///             <li>
    ///                <p>Type: DNS (UDP), Protocol: UDP, Range: 53, Source: 0.0.0.0/0</p>
    ///             </li>
    ///             <li>
    ///                <p>Type: DNS (TCP), Protocol: TCP, Range: 53, Source: 0.0.0.0/0</p>
    ///             </li>
    ///             <li>
    ///                <p>Type: LDAP, Protocol: TCP, Range: 389, Source: 0.0.0.0/0</p>
    ///             </li>
    ///             <li>
    ///                <p>Type: All ICMP, Protocol: All, Range: N/A, Source: 0.0.0.0/0</p>
    ///             </li>
    ///          </ul>
    ///
    ///          <p></p>
    ///          <p>Outbound:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Type: All traffic, Protocol: All, Range: All, Destination: 0.0.0.0/0</p>
    ///             </li>
    ///          </ul>
    ///          <p>These security rules impact an internal network interface that is not exposed publicly.</p>
    public let updateSecurityGroupForDirectoryControllers: Bool

    public init (
        directoryId: String? = nil,
        ipRoutes: [IpRoute]? = nil,
        updateSecurityGroupForDirectoryControllers: Bool = false
    )
    {
        self.directoryId = directoryId
        self.ipRoutes = ipRoutes
        self.updateSecurityGroupForDirectoryControllers = updateSecurityGroupForDirectoryControllers
    }
}

struct AddIpRoutesInputBody: Equatable {
    public let directoryId: String?
    public let ipRoutes: [IpRoute]?
    public let updateSecurityGroupForDirectoryControllers: Bool
}

extension AddIpRoutesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case directoryId = "DirectoryId"
        case ipRoutes = "IpRoutes"
        case updateSecurityGroupForDirectoryControllers = "UpdateSecurityGroupForDirectoryControllers"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let ipRoutesContainer = try containerValues.decodeIfPresent([IpRoute?].self, forKey: .ipRoutes)
        var ipRoutesDecoded0:[IpRoute]? = nil
        if let ipRoutesContainer = ipRoutesContainer {
            ipRoutesDecoded0 = [IpRoute]()
            for structure0 in ipRoutesContainer {
                if let structure0 = structure0 {
                    ipRoutesDecoded0?.append(structure0)
                }
            }
        }
        ipRoutes = ipRoutesDecoded0
        let updateSecurityGroupForDirectoryControllersDecoded = try containerValues.decode(Bool.self, forKey: .updateSecurityGroupForDirectoryControllers)
        updateSecurityGroupForDirectoryControllers = updateSecurityGroupForDirectoryControllersDecoded
    }
}

extension AddIpRoutesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AddIpRoutesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryUnavailableException" : self = .directoryUnavailableException(try DirectoryUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityAlreadyExistsException" : self = .entityAlreadyExistsException(try EntityAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityDoesNotExistException" : self = .entityDoesNotExistException(try EntityDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IpRouteLimitExceededException" : self = .ipRouteLimitExceededException(try IpRouteLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AddIpRoutesOutputError: Equatable {
    case clientException(ClientException)
    case directoryUnavailableException(DirectoryUnavailableException)
    case entityAlreadyExistsException(EntityAlreadyExistsException)
    case entityDoesNotExistException(EntityDoesNotExistException)
    case invalidParameterException(InvalidParameterException)
    case ipRouteLimitExceededException(IpRouteLimitExceededException)
    case serviceException(ServiceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddIpRoutesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AddIpRoutesOutputResponse()"}
}

extension AddIpRoutesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct AddIpRoutesOutputResponse: Equatable {

    public init() {}
}

struct AddIpRoutesOutputResponseBody: Equatable {
}

extension AddIpRoutesOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct AddRegionInputBodyMiddleware: Middleware {
    public let id: String = "AddRegionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddRegionInput>,
                  next: H) -> Swift.Result<OperationOutput<AddRegionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddRegionInput>
    public typealias MOutput = OperationOutput<AddRegionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddRegionOutputError>
}

extension AddRegionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AddRegionInput(directoryId: \(String(describing: directoryId)), regionName: \(String(describing: regionName)), vPCSettings: \(String(describing: vPCSettings)))"}
}

extension AddRegionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case directoryId = "DirectoryId"
        case regionName = "RegionName"
        case vPCSettings = "VPCSettings"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryId = directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let regionName = regionName {
            try encodeContainer.encode(regionName, forKey: .regionName)
        }
        if let vPCSettings = vPCSettings {
            try encodeContainer.encode(vPCSettings, forKey: .vPCSettings)
        }
    }
}

public struct AddRegionInputHeadersMiddleware: Middleware {
    public let id: String = "AddRegionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddRegionInput>,
                  next: H) -> Swift.Result<OperationOutput<AddRegionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddRegionInput>
    public typealias MOutput = OperationOutput<AddRegionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddRegionOutputError>
}

public struct AddRegionInputQueryItemMiddleware: Middleware {
    public let id: String = "AddRegionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddRegionInput>,
                  next: H) -> Swift.Result<OperationOutput<AddRegionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddRegionInput>
    public typealias MOutput = OperationOutput<AddRegionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddRegionOutputError>
}

public struct AddRegionInput: Equatable {
    /// <p>The identifier of the directory to which you want to add Region replication.</p>
    public let directoryId: String?
    /// <p>The name of the Region where you want to add domain controllers for replication. For
    ///       example, <code>us-east-1</code>.</p>
    public let regionName: String?
    /// <p>Contains VPC information for the <a>CreateDirectory</a> or <a>CreateMicrosoftAD</a> operation.</p>
    public let vPCSettings: DirectoryVpcSettings?

    public init (
        directoryId: String? = nil,
        regionName: String? = nil,
        vPCSettings: DirectoryVpcSettings? = nil
    )
    {
        self.directoryId = directoryId
        self.regionName = regionName
        self.vPCSettings = vPCSettings
    }
}

struct AddRegionInputBody: Equatable {
    public let directoryId: String?
    public let regionName: String?
    public let vPCSettings: DirectoryVpcSettings?
}

extension AddRegionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case directoryId = "DirectoryId"
        case regionName = "RegionName"
        case vPCSettings = "VPCSettings"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let regionNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .regionName)
        regionName = regionNameDecoded
        let vPCSettingsDecoded = try containerValues.decodeIfPresent(DirectoryVpcSettings.self, forKey: .vPCSettings)
        vPCSettings = vPCSettingsDecoded
    }
}

extension AddRegionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AddRegionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryAlreadyInRegionException" : self = .directoryAlreadyInRegionException(try DirectoryAlreadyInRegionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryDoesNotExistException" : self = .directoryDoesNotExistException(try DirectoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryUnavailableException" : self = .directoryUnavailableException(try DirectoryUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityDoesNotExistException" : self = .entityDoesNotExistException(try EntityDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RegionLimitExceededException" : self = .regionLimitExceededException(try RegionLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AddRegionOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case clientException(ClientException)
    case directoryAlreadyInRegionException(DirectoryAlreadyInRegionException)
    case directoryDoesNotExistException(DirectoryDoesNotExistException)
    case directoryUnavailableException(DirectoryUnavailableException)
    case entityDoesNotExistException(EntityDoesNotExistException)
    case invalidParameterException(InvalidParameterException)
    case regionLimitExceededException(RegionLimitExceededException)
    case serviceException(ServiceException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddRegionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AddRegionOutputResponse()"}
}

extension AddRegionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct AddRegionOutputResponse: Equatable {

    public init() {}
}

struct AddRegionOutputResponseBody: Equatable {
}

extension AddRegionOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct AddTagsToResourceInputBodyMiddleware: Middleware {
    public let id: String = "AddTagsToResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddTagsToResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<AddTagsToResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddTagsToResourceInput>
    public typealias MOutput = OperationOutput<AddTagsToResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddTagsToResourceOutputError>
}

extension AddTagsToResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AddTagsToResourceInput(resourceId: \(String(describing: resourceId)), tags: \(String(describing: tags)))"}
}

extension AddTagsToResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceId = "ResourceId"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
    }
}

public struct AddTagsToResourceInputHeadersMiddleware: Middleware {
    public let id: String = "AddTagsToResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddTagsToResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<AddTagsToResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddTagsToResourceInput>
    public typealias MOutput = OperationOutput<AddTagsToResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddTagsToResourceOutputError>
}

public struct AddTagsToResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "AddTagsToResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddTagsToResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<AddTagsToResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddTagsToResourceInput>
    public typealias MOutput = OperationOutput<AddTagsToResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddTagsToResourceOutputError>
}

public struct AddTagsToResourceInput: Equatable {
    /// <p>Identifier (ID) for the directory to which to add the tag.</p>
    public let resourceId: String?
    /// <p>The tags to be assigned to the directory.</p>
    public let tags: [Tag]?

    public init (
        resourceId: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.resourceId = resourceId
        self.tags = tags
    }
}

struct AddTagsToResourceInputBody: Equatable {
    public let resourceId: String?
    public let tags: [Tag]?
}

extension AddTagsToResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceId = "ResourceId"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension AddTagsToResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AddTagsToResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityDoesNotExistException" : self = .entityDoesNotExistException(try EntityDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagLimitExceededException" : self = .tagLimitExceededException(try TagLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AddTagsToResourceOutputError: Equatable {
    case clientException(ClientException)
    case entityDoesNotExistException(EntityDoesNotExistException)
    case invalidParameterException(InvalidParameterException)
    case serviceException(ServiceException)
    case tagLimitExceededException(TagLimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddTagsToResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AddTagsToResourceOutputResponse()"}
}

extension AddTagsToResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct AddTagsToResourceOutputResponse: Equatable {

    public init() {}
}

struct AddTagsToResourceOutputResponseBody: Equatable {
}

extension AddTagsToResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension Attribute: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Attribute: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Attribute(name: \(String(describing: name)), value: \(String(describing: value)))"}
}

/// <p>Represents a named directory attribute.</p>
public struct Attribute: Equatable {
    /// <p>The name of the attribute.</p>
    public let name: String?
    /// <p>The value of the attribute.</p>
    public let value: String?

    public init (
        name: String? = nil,
        value: String? = nil
    )
    {
        self.name = name
        self.value = value
    }
}

extension AuthenticationFailedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AuthenticationFailedException(message: \(String(describing: message)), requestId: \(String(describing: requestId)))"}
}

extension AuthenticationFailedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AuthenticationFailedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.requestId = output.requestId
        } else {
            self.message = nil
            self.requestId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An authentication error occurred.</p>
public struct AuthenticationFailedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The textual message for the exception.</p>
    public var message: String?
    /// <p>The identifier of the request that caused the exception.</p>
    public var requestId: String?

    public init (
        message: String? = nil,
        requestId: String? = nil
    )
    {
        self.message = message
        self.requestId = requestId
    }
}

struct AuthenticationFailedExceptionBody: Equatable {
    public let message: String?
    public let requestId: String?
}

extension AuthenticationFailedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case requestId = "RequestId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

public struct CancelSchemaExtensionInputBodyMiddleware: Middleware {
    public let id: String = "CancelSchemaExtensionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CancelSchemaExtensionInput>,
                  next: H) -> Swift.Result<OperationOutput<CancelSchemaExtensionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CancelSchemaExtensionInput>
    public typealias MOutput = OperationOutput<CancelSchemaExtensionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CancelSchemaExtensionOutputError>
}

extension CancelSchemaExtensionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CancelSchemaExtensionInput(directoryId: \(String(describing: directoryId)), schemaExtensionId: \(String(describing: schemaExtensionId)))"}
}

extension CancelSchemaExtensionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case directoryId = "DirectoryId"
        case schemaExtensionId = "SchemaExtensionId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryId = directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let schemaExtensionId = schemaExtensionId {
            try encodeContainer.encode(schemaExtensionId, forKey: .schemaExtensionId)
        }
    }
}

public struct CancelSchemaExtensionInputHeadersMiddleware: Middleware {
    public let id: String = "CancelSchemaExtensionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CancelSchemaExtensionInput>,
                  next: H) -> Swift.Result<OperationOutput<CancelSchemaExtensionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CancelSchemaExtensionInput>
    public typealias MOutput = OperationOutput<CancelSchemaExtensionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CancelSchemaExtensionOutputError>
}

public struct CancelSchemaExtensionInputQueryItemMiddleware: Middleware {
    public let id: String = "CancelSchemaExtensionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CancelSchemaExtensionInput>,
                  next: H) -> Swift.Result<OperationOutput<CancelSchemaExtensionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CancelSchemaExtensionInput>
    public typealias MOutput = OperationOutput<CancelSchemaExtensionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CancelSchemaExtensionOutputError>
}

public struct CancelSchemaExtensionInput: Equatable {
    /// <p>The identifier of the directory whose schema extension will be canceled.</p>
    public let directoryId: String?
    /// <p>The identifier of the schema extension that will be canceled.</p>
    public let schemaExtensionId: String?

    public init (
        directoryId: String? = nil,
        schemaExtensionId: String? = nil
    )
    {
        self.directoryId = directoryId
        self.schemaExtensionId = schemaExtensionId
    }
}

struct CancelSchemaExtensionInputBody: Equatable {
    public let directoryId: String?
    public let schemaExtensionId: String?
}

extension CancelSchemaExtensionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case directoryId = "DirectoryId"
        case schemaExtensionId = "SchemaExtensionId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let schemaExtensionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schemaExtensionId)
        schemaExtensionId = schemaExtensionIdDecoded
    }
}

extension CancelSchemaExtensionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CancelSchemaExtensionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityDoesNotExistException" : self = .entityDoesNotExistException(try EntityDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CancelSchemaExtensionOutputError: Equatable {
    case clientException(ClientException)
    case entityDoesNotExistException(EntityDoesNotExistException)
    case serviceException(ServiceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CancelSchemaExtensionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CancelSchemaExtensionOutputResponse()"}
}

extension CancelSchemaExtensionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct CancelSchemaExtensionOutputResponse: Equatable {

    public init() {}
}

struct CancelSchemaExtensionOutputResponseBody: Equatable {
}

extension CancelSchemaExtensionOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension Certificate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case certificateId = "CertificateId"
        case clientCertAuthSettings = "ClientCertAuthSettings"
        case commonName = "CommonName"
        case expiryDateTime = "ExpiryDateTime"
        case registeredDateTime = "RegisteredDateTime"
        case state = "State"
        case stateReason = "StateReason"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateId = certificateId {
            try encodeContainer.encode(certificateId, forKey: .certificateId)
        }
        if let clientCertAuthSettings = clientCertAuthSettings {
            try encodeContainer.encode(clientCertAuthSettings, forKey: .clientCertAuthSettings)
        }
        if let commonName = commonName {
            try encodeContainer.encode(commonName, forKey: .commonName)
        }
        if let expiryDateTime = expiryDateTime {
            try encodeContainer.encode(expiryDateTime.timeIntervalSince1970, forKey: .expiryDateTime)
        }
        if let registeredDateTime = registeredDateTime {
            try encodeContainer.encode(registeredDateTime.timeIntervalSince1970, forKey: .registeredDateTime)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let stateReason = stateReason {
            try encodeContainer.encode(stateReason, forKey: .stateReason)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificateId)
        certificateId = certificateIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(CertificateState.self, forKey: .state)
        state = stateDecoded
        let stateReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stateReason)
        stateReason = stateReasonDecoded
        let commonNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .commonName)
        commonName = commonNameDecoded
        let registeredDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .registeredDateTime)
        registeredDateTime = registeredDateTimeDecoded
        let expiryDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .expiryDateTime)
        expiryDateTime = expiryDateTimeDecoded
        let typeDecoded = try containerValues.decodeIfPresent(CertificateType.self, forKey: .type)
        type = typeDecoded
        let clientCertAuthSettingsDecoded = try containerValues.decodeIfPresent(ClientCertAuthSettings.self, forKey: .clientCertAuthSettings)
        clientCertAuthSettings = clientCertAuthSettingsDecoded
    }
}

extension Certificate: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Certificate(certificateId: \(String(describing: certificateId)), clientCertAuthSettings: \(String(describing: clientCertAuthSettings)), commonName: \(String(describing: commonName)), expiryDateTime: \(String(describing: expiryDateTime)), registeredDateTime: \(String(describing: registeredDateTime)), state: \(String(describing: state)), stateReason: \(String(describing: stateReason)), type: \(String(describing: type)))"}
}

/// <p>Information about the certificate.</p>
public struct Certificate: Equatable {
    /// <p>The identifier of the certificate.</p>
    public let certificateId: String?
    /// <p>A <code>ClientCertAuthSettings</code> object that contains client certificate authentication settings.</p>
    public let clientCertAuthSettings: ClientCertAuthSettings?
    /// <p>The common name for the certificate.</p>
    public let commonName: String?
    /// <p>The date and time when the certificate will expire.</p>
    public let expiryDateTime: Date?
    /// <p>The date and time that the certificate was registered.</p>
    public let registeredDateTime: Date?
    /// <p>The state of the certificate.</p>
    public let state: CertificateState?
    /// <p>Describes a state change for the certificate.</p>
    public let stateReason: String?
    /// <p>The function that the registered certificate performs. Valid values include <code>ClientLDAPS</code> or <code>ClientCertAuth</code>. The default value is <code>ClientLDAPS</code>.</p>
    public let type: CertificateType?

    public init (
        certificateId: String? = nil,
        clientCertAuthSettings: ClientCertAuthSettings? = nil,
        commonName: String? = nil,
        expiryDateTime: Date? = nil,
        registeredDateTime: Date? = nil,
        state: CertificateState? = nil,
        stateReason: String? = nil,
        type: CertificateType? = nil
    )
    {
        self.certificateId = certificateId
        self.clientCertAuthSettings = clientCertAuthSettings
        self.commonName = commonName
        self.expiryDateTime = expiryDateTime
        self.registeredDateTime = registeredDateTime
        self.state = state
        self.stateReason = stateReason
        self.type = type
    }
}

extension CertificateAlreadyExistsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CertificateAlreadyExistsException(message: \(String(describing: message)), requestId: \(String(describing: requestId)))"}
}

extension CertificateAlreadyExistsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CertificateAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.requestId = output.requestId
        } else {
            self.message = nil
            self.requestId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The certificate has already been registered into the system.</p>
public struct CertificateAlreadyExistsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The descriptive message for the exception.</p>
    public var message: String?
    /// <p>The AWS request identifier.</p>
    public var requestId: String?

    public init (
        message: String? = nil,
        requestId: String? = nil
    )
    {
        self.message = message
        self.requestId = requestId
    }
}

struct CertificateAlreadyExistsExceptionBody: Equatable {
    public let message: String?
    public let requestId: String?
}

extension CertificateAlreadyExistsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case requestId = "RequestId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension CertificateDoesNotExistException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CertificateDoesNotExistException(message: \(String(describing: message)), requestId: \(String(describing: requestId)))"}
}

extension CertificateDoesNotExistException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CertificateDoesNotExistExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.requestId = output.requestId
        } else {
            self.message = nil
            self.requestId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The certificate is not present in the system for describe or deregister activities.</p>
public struct CertificateDoesNotExistException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The descriptive message for the exception.</p>
    public var message: String?
    /// <p>The AWS request identifier.</p>
    public var requestId: String?

    public init (
        message: String? = nil,
        requestId: String? = nil
    )
    {
        self.message = message
        self.requestId = requestId
    }
}

struct CertificateDoesNotExistExceptionBody: Equatable {
    public let message: String?
    public let requestId: String?
}

extension CertificateDoesNotExistExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case requestId = "RequestId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension CertificateInUseException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CertificateInUseException(message: \(String(describing: message)), requestId: \(String(describing: requestId)))"}
}

extension CertificateInUseException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CertificateInUseExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.requestId = output.requestId
        } else {
            self.message = nil
            self.requestId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The certificate is being used for the LDAP security connection and cannot be removed
///       without disabling LDAP security.</p>
public struct CertificateInUseException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The descriptive message for the exception.</p>
    public var message: String?
    /// <p>The AWS request identifier.</p>
    public var requestId: String?

    public init (
        message: String? = nil,
        requestId: String? = nil
    )
    {
        self.message = message
        self.requestId = requestId
    }
}

struct CertificateInUseExceptionBody: Equatable {
    public let message: String?
    public let requestId: String?
}

extension CertificateInUseExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case requestId = "RequestId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension CertificateInfo: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case certificateId = "CertificateId"
        case commonName = "CommonName"
        case expiryDateTime = "ExpiryDateTime"
        case state = "State"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateId = certificateId {
            try encodeContainer.encode(certificateId, forKey: .certificateId)
        }
        if let commonName = commonName {
            try encodeContainer.encode(commonName, forKey: .commonName)
        }
        if let expiryDateTime = expiryDateTime {
            try encodeContainer.encode(expiryDateTime.timeIntervalSince1970, forKey: .expiryDateTime)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificateId)
        certificateId = certificateIdDecoded
        let commonNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .commonName)
        commonName = commonNameDecoded
        let stateDecoded = try containerValues.decodeIfPresent(CertificateState.self, forKey: .state)
        state = stateDecoded
        let expiryDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .expiryDateTime)
        expiryDateTime = expiryDateTimeDecoded
        let typeDecoded = try containerValues.decodeIfPresent(CertificateType.self, forKey: .type)
        type = typeDecoded
    }
}

extension CertificateInfo: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CertificateInfo(certificateId: \(String(describing: certificateId)), commonName: \(String(describing: commonName)), expiryDateTime: \(String(describing: expiryDateTime)), state: \(String(describing: state)), type: \(String(describing: type)))"}
}

/// <p>Contains general information about a certificate.</p>
public struct CertificateInfo: Equatable {
    /// <p>The identifier of the certificate.</p>
    public let certificateId: String?
    /// <p>The common name for the certificate.</p>
    public let commonName: String?
    /// <p>The date and time when the certificate will expire.</p>
    public let expiryDateTime: Date?
    /// <p>The state of the certificate.</p>
    public let state: CertificateState?
    /// <p>The function that the registered certificate performs. Valid values include <code>ClientLDAPS</code> or <code>ClientCertAuth</code>. The default value is <code>ClientLDAPS</code>.</p>
    public let type: CertificateType?

    public init (
        certificateId: String? = nil,
        commonName: String? = nil,
        expiryDateTime: Date? = nil,
        state: CertificateState? = nil,
        type: CertificateType? = nil
    )
    {
        self.certificateId = certificateId
        self.commonName = commonName
        self.expiryDateTime = expiryDateTime
        self.state = state
        self.type = type
    }
}

extension CertificateLimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CertificateLimitExceededException(message: \(String(describing: message)), requestId: \(String(describing: requestId)))"}
}

extension CertificateLimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CertificateLimitExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.requestId = output.requestId
        } else {
            self.message = nil
            self.requestId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The certificate could not be added because the certificate limit has been reached.</p>
public struct CertificateLimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The descriptive message for the exception.</p>
    public var message: String?
    /// <p>The AWS request identifier.</p>
    public var requestId: String?

    public init (
        message: String? = nil,
        requestId: String? = nil
    )
    {
        self.message = message
        self.requestId = requestId
    }
}

struct CertificateLimitExceededExceptionBody: Equatable {
    public let message: String?
    public let requestId: String?
}

extension CertificateLimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case requestId = "RequestId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

public enum CertificateState {
    case deregistered
    case deregistering
    case deregisterFailed
    case registered
    case registering
    case registerFailed
    case sdkUnknown(String)
}

extension CertificateState : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [CertificateState] {
        return [
            .deregistered,
            .deregistering,
            .deregisterFailed,
            .registered,
            .registering,
            .registerFailed,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .deregistered: return "Deregistered"
        case .deregistering: return "Deregistering"
        case .deregisterFailed: return "DeregisterFailed"
        case .registered: return "Registered"
        case .registering: return "Registering"
        case .registerFailed: return "RegisterFailed"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = CertificateState(rawValue: rawValue) ?? CertificateState.sdkUnknown(rawValue)
    }
}

public enum CertificateType {
    case clientCertAuth
    case clientLdaps
    case sdkUnknown(String)
}

extension CertificateType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [CertificateType] {
        return [
            .clientCertAuth,
            .clientLdaps,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .clientCertAuth: return "ClientCertAuth"
        case .clientLdaps: return "ClientLDAPS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = CertificateType(rawValue: rawValue) ?? CertificateType.sdkUnknown(rawValue)
    }
}

public enum ClientAuthenticationType {
    case smartCard
    case sdkUnknown(String)
}

extension ClientAuthenticationType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ClientAuthenticationType] {
        return [
            .smartCard,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .smartCard: return "SmartCard"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ClientAuthenticationType(rawValue: rawValue) ?? ClientAuthenticationType.sdkUnknown(rawValue)
    }
}

extension ClientCertAuthSettings: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case oCSPUrl = "OCSPUrl"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let oCSPUrl = oCSPUrl {
            try encodeContainer.encode(oCSPUrl, forKey: .oCSPUrl)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let oCSPUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .oCSPUrl)
        oCSPUrl = oCSPUrlDecoded
    }
}

extension ClientCertAuthSettings: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ClientCertAuthSettings(oCSPUrl: \(String(describing: oCSPUrl)))"}
}

/// <p>Contains information about the client certificate authentication settings for the <code>RegisterCertificate</code> and <code>DescribeCertificate</code> operations. </p>
public struct ClientCertAuthSettings: Equatable {
    /// <p>Specifies the URL of the default OCSP server used to check for revocation status. A secondary value to any OCSP address found in the AIA extension of the user certificate.</p>
    public let oCSPUrl: String?

    public init (
        oCSPUrl: String? = nil
    )
    {
        self.oCSPUrl = oCSPUrl
    }
}

extension ClientException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ClientException(message: \(String(describing: message)), requestId: \(String(describing: requestId)))"}
}

extension ClientException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ClientExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.requestId = output.requestId
        } else {
            self.message = nil
            self.requestId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A client exception has occurred.</p>
public struct ClientException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The descriptive message for the exception.</p>
    public var message: String?
    /// <p>The AWS request identifier.</p>
    public var requestId: String?

    public init (
        message: String? = nil,
        requestId: String? = nil
    )
    {
        self.message = message
        self.requestId = requestId
    }
}

struct ClientExceptionBody: Equatable {
    public let message: String?
    public let requestId: String?
}

extension ClientExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case requestId = "RequestId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension Computer: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case computerAttributes = "ComputerAttributes"
        case computerId = "ComputerId"
        case computerName = "ComputerName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let computerAttributes = computerAttributes {
            var computerAttributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .computerAttributes)
            for attributes0 in computerAttributes {
                try computerAttributesContainer.encode(attributes0)
            }
        }
        if let computerId = computerId {
            try encodeContainer.encode(computerId, forKey: .computerId)
        }
        if let computerName = computerName {
            try encodeContainer.encode(computerName, forKey: .computerName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let computerIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .computerId)
        computerId = computerIdDecoded
        let computerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .computerName)
        computerName = computerNameDecoded
        let computerAttributesContainer = try containerValues.decodeIfPresent([Attribute?].self, forKey: .computerAttributes)
        var computerAttributesDecoded0:[Attribute]? = nil
        if let computerAttributesContainer = computerAttributesContainer {
            computerAttributesDecoded0 = [Attribute]()
            for structure0 in computerAttributesContainer {
                if let structure0 = structure0 {
                    computerAttributesDecoded0?.append(structure0)
                }
            }
        }
        computerAttributes = computerAttributesDecoded0
    }
}

extension Computer: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Computer(computerAttributes: \(String(describing: computerAttributes)), computerId: \(String(describing: computerId)), computerName: \(String(describing: computerName)))"}
}

/// <p>Contains information about a computer account in a directory.</p>
public struct Computer: Equatable {
    /// <p>An array of <a>Attribute</a> objects containing the LDAP attributes that belong to the
    ///             computer account.</p>
    public let computerAttributes: [Attribute]?
    /// <p>The identifier of the computer.</p>
    public let computerId: String?
    /// <p>The computer name.</p>
    public let computerName: String?

    public init (
        computerAttributes: [Attribute]? = nil,
        computerId: String? = nil,
        computerName: String? = nil
    )
    {
        self.computerAttributes = computerAttributes
        self.computerId = computerId
        self.computerName = computerName
    }
}

extension ConditionalForwarder: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dnsIpAddrs = "DnsIpAddrs"
        case remoteDomainName = "RemoteDomainName"
        case replicationScope = "ReplicationScope"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dnsIpAddrs = dnsIpAddrs {
            var dnsIpAddrsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dnsIpAddrs)
            for dnsipaddrs0 in dnsIpAddrs {
                try dnsIpAddrsContainer.encode(dnsipaddrs0)
            }
        }
        if let remoteDomainName = remoteDomainName {
            try encodeContainer.encode(remoteDomainName, forKey: .remoteDomainName)
        }
        if let replicationScope = replicationScope {
            try encodeContainer.encode(replicationScope.rawValue, forKey: .replicationScope)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let remoteDomainNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .remoteDomainName)
        remoteDomainName = remoteDomainNameDecoded
        let dnsIpAddrsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .dnsIpAddrs)
        var dnsIpAddrsDecoded0:[String]? = nil
        if let dnsIpAddrsContainer = dnsIpAddrsContainer {
            dnsIpAddrsDecoded0 = [String]()
            for string0 in dnsIpAddrsContainer {
                if let string0 = string0 {
                    dnsIpAddrsDecoded0?.append(string0)
                }
            }
        }
        dnsIpAddrs = dnsIpAddrsDecoded0
        let replicationScopeDecoded = try containerValues.decodeIfPresent(ReplicationScope.self, forKey: .replicationScope)
        replicationScope = replicationScopeDecoded
    }
}

extension ConditionalForwarder: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConditionalForwarder(dnsIpAddrs: \(String(describing: dnsIpAddrs)), remoteDomainName: \(String(describing: remoteDomainName)), replicationScope: \(String(describing: replicationScope)))"}
}

/// <p>Points to a remote domain with which you are setting up a trust relationship. Conditional forwarders are required in order to set up a trust relationship with another domain.</p>
public struct ConditionalForwarder: Equatable {
    /// <p>The IP addresses of the remote DNS server associated with RemoteDomainName. This is the IP address of the DNS server that your conditional forwarder points to.</p>
    public let dnsIpAddrs: [String]?
    /// <p>The fully qualified domain name (FQDN) of the remote domains pointed to by the conditional forwarder.</p>
    public let remoteDomainName: String?
    /// <p>The replication scope of the conditional forwarder. The only allowed value is
    ///                   <code>Domain</code>, which will replicate the conditional forwarder to all of the
    ///                   domain controllers for your AWS directory.</p>
    public let replicationScope: ReplicationScope?

    public init (
        dnsIpAddrs: [String]? = nil,
        remoteDomainName: String? = nil,
        replicationScope: ReplicationScope? = nil
    )
    {
        self.dnsIpAddrs = dnsIpAddrs
        self.remoteDomainName = remoteDomainName
        self.replicationScope = replicationScope
    }
}

public struct ConnectDirectoryInputBodyMiddleware: Middleware {
    public let id: String = "ConnectDirectoryInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ConnectDirectoryInput>,
                  next: H) -> Swift.Result<OperationOutput<ConnectDirectoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ConnectDirectoryInput>
    public typealias MOutput = OperationOutput<ConnectDirectoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ConnectDirectoryOutputError>
}

extension ConnectDirectoryInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConnectDirectoryInput(connectSettings: \(String(describing: connectSettings)), description: \(String(describing: description)), name: \(String(describing: name)), password: \(String(describing: password)), shortName: \(String(describing: shortName)), size: \(String(describing: size)), tags: \(String(describing: tags)))"}
}

extension ConnectDirectoryInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case connectSettings = "ConnectSettings"
        case description = "Description"
        case name = "Name"
        case password = "Password"
        case shortName = "ShortName"
        case size = "Size"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectSettings = connectSettings {
            try encodeContainer.encode(connectSettings, forKey: .connectSettings)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let password = password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let shortName = shortName {
            try encodeContainer.encode(shortName, forKey: .shortName)
        }
        if let size = size {
            try encodeContainer.encode(size.rawValue, forKey: .size)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
    }
}

public struct ConnectDirectoryInputHeadersMiddleware: Middleware {
    public let id: String = "ConnectDirectoryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ConnectDirectoryInput>,
                  next: H) -> Swift.Result<OperationOutput<ConnectDirectoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ConnectDirectoryInput>
    public typealias MOutput = OperationOutput<ConnectDirectoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ConnectDirectoryOutputError>
}

public struct ConnectDirectoryInputQueryItemMiddleware: Middleware {
    public let id: String = "ConnectDirectoryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ConnectDirectoryInput>,
                  next: H) -> Swift.Result<OperationOutput<ConnectDirectoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ConnectDirectoryInput>
    public typealias MOutput = OperationOutput<ConnectDirectoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ConnectDirectoryOutputError>
}

/// <p>Contains the inputs for the <a>ConnectDirectory</a> operation.</p>
public struct ConnectDirectoryInput: Equatable {
    /// <p>A <a>DirectoryConnectSettings</a> object that contains additional information
    ///       for the operation.</p>
    public let connectSettings: DirectoryConnectSettings?
    /// <p>A description for the directory.</p>
    public let description: String?
    /// <p>The fully qualified name of the on-premises directory, such as
    ///         <code>corp.example.com</code>.</p>
    public let name: String?
    /// <p>The password for the on-premises user account.</p>
    public let password: String?
    /// <p>The NetBIOS name of the on-premises directory, such as <code>CORP</code>.</p>
    public let shortName: String?
    /// <p>The size of the directory.</p>
    public let size: DirectorySize?
    /// <p>The tags to be assigned to AD Connector.</p>
    public let tags: [Tag]?

    public init (
        connectSettings: DirectoryConnectSettings? = nil,
        description: String? = nil,
        name: String? = nil,
        password: String? = nil,
        shortName: String? = nil,
        size: DirectorySize? = nil,
        tags: [Tag]? = nil
    )
    {
        self.connectSettings = connectSettings
        self.description = description
        self.name = name
        self.password = password
        self.shortName = shortName
        self.size = size
        self.tags = tags
    }
}

struct ConnectDirectoryInputBody: Equatable {
    public let name: String?
    public let shortName: String?
    public let password: String?
    public let description: String?
    public let size: DirectorySize?
    public let connectSettings: DirectoryConnectSettings?
    public let tags: [Tag]?
}

extension ConnectDirectoryInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case connectSettings = "ConnectSettings"
        case description = "Description"
        case name = "Name"
        case password = "Password"
        case shortName = "ShortName"
        case size = "Size"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let shortNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .shortName)
        shortName = shortNameDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(String.self, forKey: .password)
        password = passwordDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let sizeDecoded = try containerValues.decodeIfPresent(DirectorySize.self, forKey: .size)
        size = sizeDecoded
        let connectSettingsDecoded = try containerValues.decodeIfPresent(DirectoryConnectSettings.self, forKey: .connectSettings)
        connectSettings = connectSettingsDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ConnectDirectoryOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ConnectDirectoryOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryLimitExceededException" : self = .directoryLimitExceededException(try DirectoryLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ConnectDirectoryOutputError: Equatable {
    case clientException(ClientException)
    case directoryLimitExceededException(DirectoryLimitExceededException)
    case invalidParameterException(InvalidParameterException)
    case serviceException(ServiceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ConnectDirectoryOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConnectDirectoryOutputResponse(directoryId: \(String(describing: directoryId)))"}
}

extension ConnectDirectoryOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ConnectDirectoryOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.directoryId = output.directoryId
        } else {
            self.directoryId = nil
        }
    }
}

/// <p>Contains the results of the <a>ConnectDirectory</a> operation.</p>
public struct ConnectDirectoryOutputResponse: Equatable {
    /// <p>The identifier of the new directory.</p>
    public let directoryId: String?

    public init (
        directoryId: String? = nil
    )
    {
        self.directoryId = directoryId
    }
}

struct ConnectDirectoryOutputResponseBody: Equatable {
    public let directoryId: String?
}

extension ConnectDirectoryOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case directoryId = "DirectoryId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
    }
}

public struct CreateAliasInputBodyMiddleware: Middleware {
    public let id: String = "CreateAliasInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAliasInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAliasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAliasInput>
    public typealias MOutput = OperationOutput<CreateAliasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAliasOutputError>
}

extension CreateAliasInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateAliasInput(alias: \(String(describing: alias)), directoryId: \(String(describing: directoryId)))"}
}

extension CreateAliasInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case alias = "Alias"
        case directoryId = "DirectoryId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alias = alias {
            try encodeContainer.encode(alias, forKey: .alias)
        }
        if let directoryId = directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
    }
}

public struct CreateAliasInputHeadersMiddleware: Middleware {
    public let id: String = "CreateAliasInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAliasInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAliasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAliasInput>
    public typealias MOutput = OperationOutput<CreateAliasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAliasOutputError>
}

public struct CreateAliasInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateAliasInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAliasInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAliasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAliasInput>
    public typealias MOutput = OperationOutput<CreateAliasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAliasOutputError>
}

/// <p>Contains the inputs for the <a>CreateAlias</a> operation.</p>
public struct CreateAliasInput: Equatable {
    /// <p>The requested alias.</p>
    ///          <p>The alias must be unique amongst all aliases in AWS. This operation throws an
    ///             <code>EntityAlreadyExistsException</code> error if the alias already exists.</p>
    public let alias: String?
    /// <p>The identifier of the directory for which to create the alias.</p>
    public let directoryId: String?

    public init (
        alias: String? = nil,
        directoryId: String? = nil
    )
    {
        self.alias = alias
        self.directoryId = directoryId
    }
}

struct CreateAliasInputBody: Equatable {
    public let directoryId: String?
    public let alias: String?
}

extension CreateAliasInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case alias = "Alias"
        case directoryId = "DirectoryId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let aliasDecoded = try containerValues.decodeIfPresent(String.self, forKey: .alias)
        alias = aliasDecoded
    }
}

extension CreateAliasOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateAliasOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityAlreadyExistsException" : self = .entityAlreadyExistsException(try EntityAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityDoesNotExistException" : self = .entityDoesNotExistException(try EntityDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateAliasOutputError: Equatable {
    case clientException(ClientException)
    case entityAlreadyExistsException(EntityAlreadyExistsException)
    case entityDoesNotExistException(EntityDoesNotExistException)
    case invalidParameterException(InvalidParameterException)
    case serviceException(ServiceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAliasOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateAliasOutputResponse(alias: \(String(describing: alias)), directoryId: \(String(describing: directoryId)))"}
}

extension CreateAliasOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateAliasOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.alias = output.alias
            self.directoryId = output.directoryId
        } else {
            self.alias = nil
            self.directoryId = nil
        }
    }
}

/// <p>Contains the results of the <a>CreateAlias</a> operation.</p>
public struct CreateAliasOutputResponse: Equatable {
    /// <p>The alias for the directory.</p>
    public let alias: String?
    /// <p>The identifier of the directory.</p>
    public let directoryId: String?

    public init (
        alias: String? = nil,
        directoryId: String? = nil
    )
    {
        self.alias = alias
        self.directoryId = directoryId
    }
}

struct CreateAliasOutputResponseBody: Equatable {
    public let directoryId: String?
    public let alias: String?
}

extension CreateAliasOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case alias = "Alias"
        case directoryId = "DirectoryId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let aliasDecoded = try containerValues.decodeIfPresent(String.self, forKey: .alias)
        alias = aliasDecoded
    }
}

public struct CreateComputerInputBodyMiddleware: Middleware {
    public let id: String = "CreateComputerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateComputerInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateComputerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateComputerInput>
    public typealias MOutput = OperationOutput<CreateComputerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateComputerOutputError>
}

extension CreateComputerInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateComputerInput(computerAttributes: \(String(describing: computerAttributes)), computerName: \(String(describing: computerName)), directoryId: \(String(describing: directoryId)), organizationalUnitDistinguishedName: \(String(describing: organizationalUnitDistinguishedName)), password: \(String(describing: password)))"}
}

extension CreateComputerInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case computerAttributes = "ComputerAttributes"
        case computerName = "ComputerName"
        case directoryId = "DirectoryId"
        case organizationalUnitDistinguishedName = "OrganizationalUnitDistinguishedName"
        case password = "Password"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let computerAttributes = computerAttributes {
            var computerAttributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .computerAttributes)
            for attributes0 in computerAttributes {
                try computerAttributesContainer.encode(attributes0)
            }
        }
        if let computerName = computerName {
            try encodeContainer.encode(computerName, forKey: .computerName)
        }
        if let directoryId = directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let organizationalUnitDistinguishedName = organizationalUnitDistinguishedName {
            try encodeContainer.encode(organizationalUnitDistinguishedName, forKey: .organizationalUnitDistinguishedName)
        }
        if let password = password {
            try encodeContainer.encode(password, forKey: .password)
        }
    }
}

public struct CreateComputerInputHeadersMiddleware: Middleware {
    public let id: String = "CreateComputerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateComputerInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateComputerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateComputerInput>
    public typealias MOutput = OperationOutput<CreateComputerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateComputerOutputError>
}

public struct CreateComputerInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateComputerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateComputerInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateComputerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateComputerInput>
    public typealias MOutput = OperationOutput<CreateComputerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateComputerOutputError>
}

/// <p>Contains the inputs for the <a>CreateComputer</a> operation.</p>
public struct CreateComputerInput: Equatable {
    /// <p>An array of <a>Attribute</a> objects that contain any LDAP attributes to apply to the
    ///             computer account.</p>
    public let computerAttributes: [Attribute]?
    /// <p>The name of the computer account.</p>
    public let computerName: String?
    /// <p>The identifier of the directory in which to create the computer account.</p>
    public let directoryId: String?
    /// <p>The fully-qualified distinguished name of the organizational unit to place the computer account in.</p>
    public let organizationalUnitDistinguishedName: String?
    /// <p>A one-time password that is used to join the computer to the directory. You should generate a random, strong password to use for this parameter.</p>
    public let password: String?

    public init (
        computerAttributes: [Attribute]? = nil,
        computerName: String? = nil,
        directoryId: String? = nil,
        organizationalUnitDistinguishedName: String? = nil,
        password: String? = nil
    )
    {
        self.computerAttributes = computerAttributes
        self.computerName = computerName
        self.directoryId = directoryId
        self.organizationalUnitDistinguishedName = organizationalUnitDistinguishedName
        self.password = password
    }
}

struct CreateComputerInputBody: Equatable {
    public let directoryId: String?
    public let computerName: String?
    public let password: String?
    public let organizationalUnitDistinguishedName: String?
    public let computerAttributes: [Attribute]?
}

extension CreateComputerInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case computerAttributes = "ComputerAttributes"
        case computerName = "ComputerName"
        case directoryId = "DirectoryId"
        case organizationalUnitDistinguishedName = "OrganizationalUnitDistinguishedName"
        case password = "Password"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let computerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .computerName)
        computerName = computerNameDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(String.self, forKey: .password)
        password = passwordDecoded
        let organizationalUnitDistinguishedNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .organizationalUnitDistinguishedName)
        organizationalUnitDistinguishedName = organizationalUnitDistinguishedNameDecoded
        let computerAttributesContainer = try containerValues.decodeIfPresent([Attribute?].self, forKey: .computerAttributes)
        var computerAttributesDecoded0:[Attribute]? = nil
        if let computerAttributesContainer = computerAttributesContainer {
            computerAttributesDecoded0 = [Attribute]()
            for structure0 in computerAttributesContainer {
                if let structure0 = structure0 {
                    computerAttributesDecoded0?.append(structure0)
                }
            }
        }
        computerAttributes = computerAttributesDecoded0
    }
}

extension CreateComputerOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateComputerOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AuthenticationFailedException" : self = .authenticationFailedException(try AuthenticationFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryUnavailableException" : self = .directoryUnavailableException(try DirectoryUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityAlreadyExistsException" : self = .entityAlreadyExistsException(try EntityAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityDoesNotExistException" : self = .entityDoesNotExistException(try EntityDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateComputerOutputError: Equatable {
    case authenticationFailedException(AuthenticationFailedException)
    case clientException(ClientException)
    case directoryUnavailableException(DirectoryUnavailableException)
    case entityAlreadyExistsException(EntityAlreadyExistsException)
    case entityDoesNotExistException(EntityDoesNotExistException)
    case invalidParameterException(InvalidParameterException)
    case serviceException(ServiceException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateComputerOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateComputerOutputResponse(computer: \(String(describing: computer)))"}
}

extension CreateComputerOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateComputerOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.computer = output.computer
        } else {
            self.computer = nil
        }
    }
}

/// <p>Contains the results for the <a>CreateComputer</a> operation.</p>
public struct CreateComputerOutputResponse: Equatable {
    /// <p>A <a>Computer</a> object that represents the computer account.</p>
    public let computer: Computer?

    public init (
        computer: Computer? = nil
    )
    {
        self.computer = computer
    }
}

struct CreateComputerOutputResponseBody: Equatable {
    public let computer: Computer?
}

extension CreateComputerOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case computer = "Computer"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let computerDecoded = try containerValues.decodeIfPresent(Computer.self, forKey: .computer)
        computer = computerDecoded
    }
}

public struct CreateConditionalForwarderInputBodyMiddleware: Middleware {
    public let id: String = "CreateConditionalForwarderInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateConditionalForwarderInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateConditionalForwarderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateConditionalForwarderInput>
    public typealias MOutput = OperationOutput<CreateConditionalForwarderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateConditionalForwarderOutputError>
}

extension CreateConditionalForwarderInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateConditionalForwarderInput(directoryId: \(String(describing: directoryId)), dnsIpAddrs: \(String(describing: dnsIpAddrs)), remoteDomainName: \(String(describing: remoteDomainName)))"}
}

extension CreateConditionalForwarderInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case directoryId = "DirectoryId"
        case dnsIpAddrs = "DnsIpAddrs"
        case remoteDomainName = "RemoteDomainName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryId = directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let dnsIpAddrs = dnsIpAddrs {
            var dnsIpAddrsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dnsIpAddrs)
            for dnsipaddrs0 in dnsIpAddrs {
                try dnsIpAddrsContainer.encode(dnsipaddrs0)
            }
        }
        if let remoteDomainName = remoteDomainName {
            try encodeContainer.encode(remoteDomainName, forKey: .remoteDomainName)
        }
    }
}

public struct CreateConditionalForwarderInputHeadersMiddleware: Middleware {
    public let id: String = "CreateConditionalForwarderInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateConditionalForwarderInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateConditionalForwarderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateConditionalForwarderInput>
    public typealias MOutput = OperationOutput<CreateConditionalForwarderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateConditionalForwarderOutputError>
}

public struct CreateConditionalForwarderInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateConditionalForwarderInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateConditionalForwarderInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateConditionalForwarderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateConditionalForwarderInput>
    public typealias MOutput = OperationOutput<CreateConditionalForwarderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateConditionalForwarderOutputError>
}

/// <p>Initiates the creation of a conditional forwarder for your AWS Directory Service for Microsoft Active Directory. Conditional forwarders are required in order to set up a trust relationship with another domain.</p>
public struct CreateConditionalForwarderInput: Equatable {
    /// <p>The directory ID of the AWS directory for which you are creating the conditional forwarder.</p>
    public let directoryId: String?
    /// <p>The IP addresses of the remote DNS server associated with RemoteDomainName.</p>
    public let dnsIpAddrs: [String]?
    /// <p>The fully qualified domain name (FQDN) of the remote domain with which you will set up a trust relationship.</p>
    public let remoteDomainName: String?

    public init (
        directoryId: String? = nil,
        dnsIpAddrs: [String]? = nil,
        remoteDomainName: String? = nil
    )
    {
        self.directoryId = directoryId
        self.dnsIpAddrs = dnsIpAddrs
        self.remoteDomainName = remoteDomainName
    }
}

struct CreateConditionalForwarderInputBody: Equatable {
    public let directoryId: String?
    public let remoteDomainName: String?
    public let dnsIpAddrs: [String]?
}

extension CreateConditionalForwarderInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case directoryId = "DirectoryId"
        case dnsIpAddrs = "DnsIpAddrs"
        case remoteDomainName = "RemoteDomainName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let remoteDomainNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .remoteDomainName)
        remoteDomainName = remoteDomainNameDecoded
        let dnsIpAddrsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .dnsIpAddrs)
        var dnsIpAddrsDecoded0:[String]? = nil
        if let dnsIpAddrsContainer = dnsIpAddrsContainer {
            dnsIpAddrsDecoded0 = [String]()
            for string0 in dnsIpAddrsContainer {
                if let string0 = string0 {
                    dnsIpAddrsDecoded0?.append(string0)
                }
            }
        }
        dnsIpAddrs = dnsIpAddrsDecoded0
    }
}

extension CreateConditionalForwarderOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateConditionalForwarderOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryUnavailableException" : self = .directoryUnavailableException(try DirectoryUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityAlreadyExistsException" : self = .entityAlreadyExistsException(try EntityAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityDoesNotExistException" : self = .entityDoesNotExistException(try EntityDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateConditionalForwarderOutputError: Equatable {
    case clientException(ClientException)
    case directoryUnavailableException(DirectoryUnavailableException)
    case entityAlreadyExistsException(EntityAlreadyExistsException)
    case entityDoesNotExistException(EntityDoesNotExistException)
    case invalidParameterException(InvalidParameterException)
    case serviceException(ServiceException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateConditionalForwarderOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateConditionalForwarderOutputResponse()"}
}

extension CreateConditionalForwarderOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>The result of a CreateConditinalForwarder request.</p>
public struct CreateConditionalForwarderOutputResponse: Equatable {

    public init() {}
}

struct CreateConditionalForwarderOutputResponseBody: Equatable {
}

extension CreateConditionalForwarderOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct CreateDirectoryInputBodyMiddleware: Middleware {
    public let id: String = "CreateDirectoryInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDirectoryInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDirectoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDirectoryInput>
    public typealias MOutput = OperationOutput<CreateDirectoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDirectoryOutputError>
}

extension CreateDirectoryInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDirectoryInput(description: \(String(describing: description)), name: \(String(describing: name)), password: \(String(describing: password)), shortName: \(String(describing: shortName)), size: \(String(describing: size)), tags: \(String(describing: tags)), vpcSettings: \(String(describing: vpcSettings)))"}
}

extension CreateDirectoryInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case name = "Name"
        case password = "Password"
        case shortName = "ShortName"
        case size = "Size"
        case tags = "Tags"
        case vpcSettings = "VpcSettings"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let password = password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let shortName = shortName {
            try encodeContainer.encode(shortName, forKey: .shortName)
        }
        if let size = size {
            try encodeContainer.encode(size.rawValue, forKey: .size)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
        if let vpcSettings = vpcSettings {
            try encodeContainer.encode(vpcSettings, forKey: .vpcSettings)
        }
    }
}

public struct CreateDirectoryInputHeadersMiddleware: Middleware {
    public let id: String = "CreateDirectoryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDirectoryInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDirectoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDirectoryInput>
    public typealias MOutput = OperationOutput<CreateDirectoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDirectoryOutputError>
}

public struct CreateDirectoryInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateDirectoryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDirectoryInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDirectoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDirectoryInput>
    public typealias MOutput = OperationOutput<CreateDirectoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDirectoryOutputError>
}

/// <p>Contains the inputs for the <a>CreateDirectory</a> operation. </p>
public struct CreateDirectoryInput: Equatable {
    /// <p>A description for the directory.</p>
    public let description: String?
    /// <p>The fully qualified name for the directory, such as <code>corp.example.com</code>.</p>
    public let name: String?
    /// <p>The password for the directory administrator. The directory creation process creates a
    ///       directory administrator account with the user name <code>Administrator</code> and this
    ///       password.</p>
    ///          <p>If you need to change the password for the administrator account, you can use the <a>ResetUserPassword</a> API call.</p>
    ///          <p>The regex pattern for this string is made up of the following conditions:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Length (?=^.{8,64}$) – Must be between 8 and 64 characters</p>
    ///             </li>
    ///          </ul>
    ///          <p>AND any 3 of the following password complexity rules required by Active Directory:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Numbers and upper case and lowercase (?=.*\d)(?=.*[A-Z])(?=.*[a-z])</p>
    ///             </li>
    ///             <li>
    ///                <p>Numbers and special characters and lower case
    ///           (?=.*\d)(?=.*[^A-Za-z0-9\s])(?=.*[a-z])</p>
    ///             </li>
    ///             <li>
    ///                <p>Special characters and upper case and lower case
    ///           (?=.*[^A-Za-z0-9\s])(?=.*[A-Z])(?=.*[a-z])</p>
    ///             </li>
    ///             <li>
    ///                <p>Numbers and upper case and special characters
    ///           (?=.*\d)(?=.*[A-Z])(?=.*[^A-Za-z0-9\s])</p>
    ///             </li>
    ///          </ul>
    ///          <p>For additional information about how Active Directory passwords are enforced, see <a href="https://docs.microsoft.com/en-us/windows/security/threat-protection/security-policy-settings/password-must-meet-complexity-requirements">Password must meet complexity requirements</a> on the Microsoft website.</p>
    public let password: String?
    /// <p>The NetBIOS name of the directory, such as <code>CORP</code>.</p>
    public let shortName: String?
    /// <p>The size of the directory.</p>
    public let size: DirectorySize?
    /// <p>The tags to be assigned to the Simple AD directory.</p>
    public let tags: [Tag]?
    /// <p>A <a>DirectoryVpcSettings</a> object that contains additional information for
    ///       the operation.</p>
    public let vpcSettings: DirectoryVpcSettings?

    public init (
        description: String? = nil,
        name: String? = nil,
        password: String? = nil,
        shortName: String? = nil,
        size: DirectorySize? = nil,
        tags: [Tag]? = nil,
        vpcSettings: DirectoryVpcSettings? = nil
    )
    {
        self.description = description
        self.name = name
        self.password = password
        self.shortName = shortName
        self.size = size
        self.tags = tags
        self.vpcSettings = vpcSettings
    }
}

struct CreateDirectoryInputBody: Equatable {
    public let name: String?
    public let shortName: String?
    public let password: String?
    public let description: String?
    public let size: DirectorySize?
    public let vpcSettings: DirectoryVpcSettings?
    public let tags: [Tag]?
}

extension CreateDirectoryInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case name = "Name"
        case password = "Password"
        case shortName = "ShortName"
        case size = "Size"
        case tags = "Tags"
        case vpcSettings = "VpcSettings"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let shortNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .shortName)
        shortName = shortNameDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(String.self, forKey: .password)
        password = passwordDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let sizeDecoded = try containerValues.decodeIfPresent(DirectorySize.self, forKey: .size)
        size = sizeDecoded
        let vpcSettingsDecoded = try containerValues.decodeIfPresent(DirectoryVpcSettings.self, forKey: .vpcSettings)
        vpcSettings = vpcSettingsDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateDirectoryOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDirectoryOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryLimitExceededException" : self = .directoryLimitExceededException(try DirectoryLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDirectoryOutputError: Equatable {
    case clientException(ClientException)
    case directoryLimitExceededException(DirectoryLimitExceededException)
    case invalidParameterException(InvalidParameterException)
    case serviceException(ServiceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDirectoryOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDirectoryOutputResponse(directoryId: \(String(describing: directoryId)))"}
}

extension CreateDirectoryOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateDirectoryOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.directoryId = output.directoryId
        } else {
            self.directoryId = nil
        }
    }
}

/// <p>Contains the results of the <a>CreateDirectory</a> operation.</p>
public struct CreateDirectoryOutputResponse: Equatable {
    /// <p>The identifier of the directory that was created.</p>
    public let directoryId: String?

    public init (
        directoryId: String? = nil
    )
    {
        self.directoryId = directoryId
    }
}

struct CreateDirectoryOutputResponseBody: Equatable {
    public let directoryId: String?
}

extension CreateDirectoryOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case directoryId = "DirectoryId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
    }
}

public struct CreateLogSubscriptionInputBodyMiddleware: Middleware {
    public let id: String = "CreateLogSubscriptionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateLogSubscriptionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateLogSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateLogSubscriptionInput>
    public typealias MOutput = OperationOutput<CreateLogSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateLogSubscriptionOutputError>
}

extension CreateLogSubscriptionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateLogSubscriptionInput(directoryId: \(String(describing: directoryId)), logGroupName: \(String(describing: logGroupName)))"}
}

extension CreateLogSubscriptionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case directoryId = "DirectoryId"
        case logGroupName = "LogGroupName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryId = directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let logGroupName = logGroupName {
            try encodeContainer.encode(logGroupName, forKey: .logGroupName)
        }
    }
}

public struct CreateLogSubscriptionInputHeadersMiddleware: Middleware {
    public let id: String = "CreateLogSubscriptionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateLogSubscriptionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateLogSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateLogSubscriptionInput>
    public typealias MOutput = OperationOutput<CreateLogSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateLogSubscriptionOutputError>
}

public struct CreateLogSubscriptionInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateLogSubscriptionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateLogSubscriptionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateLogSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateLogSubscriptionInput>
    public typealias MOutput = OperationOutput<CreateLogSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateLogSubscriptionOutputError>
}

public struct CreateLogSubscriptionInput: Equatable {
    /// <p>Identifier of the directory to which you want to subscribe and receive real-time logs to
    ///       your specified CloudWatch log group.</p>
    public let directoryId: String?
    /// <p>The name of the CloudWatch log group where the real-time domain controller logs are
    ///       forwarded.</p>
    public let logGroupName: String?

    public init (
        directoryId: String? = nil,
        logGroupName: String? = nil
    )
    {
        self.directoryId = directoryId
        self.logGroupName = logGroupName
    }
}

struct CreateLogSubscriptionInputBody: Equatable {
    public let directoryId: String?
    public let logGroupName: String?
}

extension CreateLogSubscriptionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case directoryId = "DirectoryId"
        case logGroupName = "LogGroupName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let logGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .logGroupName)
        logGroupName = logGroupNameDecoded
    }
}

extension CreateLogSubscriptionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateLogSubscriptionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityAlreadyExistsException" : self = .entityAlreadyExistsException(try EntityAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityDoesNotExistException" : self = .entityDoesNotExistException(try EntityDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientPermissionsException" : self = .insufficientPermissionsException(try InsufficientPermissionsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateLogSubscriptionOutputError: Equatable {
    case clientException(ClientException)
    case entityAlreadyExistsException(EntityAlreadyExistsException)
    case entityDoesNotExistException(EntityDoesNotExistException)
    case insufficientPermissionsException(InsufficientPermissionsException)
    case serviceException(ServiceException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateLogSubscriptionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateLogSubscriptionOutputResponse()"}
}

extension CreateLogSubscriptionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct CreateLogSubscriptionOutputResponse: Equatable {

    public init() {}
}

struct CreateLogSubscriptionOutputResponseBody: Equatable {
}

extension CreateLogSubscriptionOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct CreateMicrosoftADInputBodyMiddleware: Middleware {
    public let id: String = "CreateMicrosoftADInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateMicrosoftADInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateMicrosoftADOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateMicrosoftADInput>
    public typealias MOutput = OperationOutput<CreateMicrosoftADOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateMicrosoftADOutputError>
}

extension CreateMicrosoftADInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateMicrosoftADInput(description: \(String(describing: description)), edition: \(String(describing: edition)), name: \(String(describing: name)), password: \(String(describing: password)), shortName: \(String(describing: shortName)), tags: \(String(describing: tags)), vpcSettings: \(String(describing: vpcSettings)))"}
}

extension CreateMicrosoftADInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case edition = "Edition"
        case name = "Name"
        case password = "Password"
        case shortName = "ShortName"
        case tags = "Tags"
        case vpcSettings = "VpcSettings"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let edition = edition {
            try encodeContainer.encode(edition.rawValue, forKey: .edition)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let password = password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let shortName = shortName {
            try encodeContainer.encode(shortName, forKey: .shortName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
        if let vpcSettings = vpcSettings {
            try encodeContainer.encode(vpcSettings, forKey: .vpcSettings)
        }
    }
}

public struct CreateMicrosoftADInputHeadersMiddleware: Middleware {
    public let id: String = "CreateMicrosoftADInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateMicrosoftADInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateMicrosoftADOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateMicrosoftADInput>
    public typealias MOutput = OperationOutput<CreateMicrosoftADOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateMicrosoftADOutputError>
}

public struct CreateMicrosoftADInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateMicrosoftADInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateMicrosoftADInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateMicrosoftADOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateMicrosoftADInput>
    public typealias MOutput = OperationOutput<CreateMicrosoftADOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateMicrosoftADOutputError>
}

/// <p>Creates an AWS Managed Microsoft AD directory.</p>
public struct CreateMicrosoftADInput: Equatable {
    /// <p>A description for the directory. This label will appear on the AWS console <code>Directory Details</code> page after the directory is created.</p>
    public let description: String?
    /// <p>AWS Managed Microsoft AD is available in two editions: <code>Standard</code> and <code>Enterprise</code>. <code>Enterprise</code> is the default.</p>
    public let edition: DirectoryEdition?
    /// <p>The fully qualified domain name for the AWS Managed Microsoft AD directory, such as
    ///        <code>corp.example.com</code>. This name will resolve inside your VPC only. It does not need
    ///        to be publicly resolvable.</p>
    public let name: String?
    /// <p>The password for the default administrative user named <code>Admin</code>.</p>
    ///          <p>If you need to change the password for the administrator account, you can use the <a>ResetUserPassword</a> API call.</p>
    public let password: String?
    /// <p>The NetBIOS name for your domain, such as <code>CORP</code>. If you don't specify a NetBIOS name, it will default to the first part of your directory DNS. For example, <code>CORP</code> for the directory DNS <code>corp.example.com</code>. </p>
    public let shortName: String?
    /// <p>The tags to be assigned to the AWS Managed Microsoft AD directory.</p>
    public let tags: [Tag]?
    /// <p>Contains VPC information for the <a>CreateDirectory</a> or <a>CreateMicrosoftAD</a> operation.</p>
    public let vpcSettings: DirectoryVpcSettings?

    public init (
        description: String? = nil,
        edition: DirectoryEdition? = nil,
        name: String? = nil,
        password: String? = nil,
        shortName: String? = nil,
        tags: [Tag]? = nil,
        vpcSettings: DirectoryVpcSettings? = nil
    )
    {
        self.description = description
        self.edition = edition
        self.name = name
        self.password = password
        self.shortName = shortName
        self.tags = tags
        self.vpcSettings = vpcSettings
    }
}

struct CreateMicrosoftADInputBody: Equatable {
    public let name: String?
    public let shortName: String?
    public let password: String?
    public let description: String?
    public let vpcSettings: DirectoryVpcSettings?
    public let edition: DirectoryEdition?
    public let tags: [Tag]?
}

extension CreateMicrosoftADInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case edition = "Edition"
        case name = "Name"
        case password = "Password"
        case shortName = "ShortName"
        case tags = "Tags"
        case vpcSettings = "VpcSettings"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let shortNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .shortName)
        shortName = shortNameDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(String.self, forKey: .password)
        password = passwordDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let vpcSettingsDecoded = try containerValues.decodeIfPresent(DirectoryVpcSettings.self, forKey: .vpcSettings)
        vpcSettings = vpcSettingsDecoded
        let editionDecoded = try containerValues.decodeIfPresent(DirectoryEdition.self, forKey: .edition)
        edition = editionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateMicrosoftADOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateMicrosoftADOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryLimitExceededException" : self = .directoryLimitExceededException(try DirectoryLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateMicrosoftADOutputError: Equatable {
    case clientException(ClientException)
    case directoryLimitExceededException(DirectoryLimitExceededException)
    case invalidParameterException(InvalidParameterException)
    case serviceException(ServiceException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateMicrosoftADOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateMicrosoftADOutputResponse(directoryId: \(String(describing: directoryId)))"}
}

extension CreateMicrosoftADOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateMicrosoftADOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.directoryId = output.directoryId
        } else {
            self.directoryId = nil
        }
    }
}

/// <p>Result of a CreateMicrosoftAD request.</p>
public struct CreateMicrosoftADOutputResponse: Equatable {
    /// <p>The identifier of the directory that was created.</p>
    public let directoryId: String?

    public init (
        directoryId: String? = nil
    )
    {
        self.directoryId = directoryId
    }
}

struct CreateMicrosoftADOutputResponseBody: Equatable {
    public let directoryId: String?
}

extension CreateMicrosoftADOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case directoryId = "DirectoryId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
    }
}

public struct CreateSnapshotInputBodyMiddleware: Middleware {
    public let id: String = "CreateSnapshotInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateSnapshotInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateSnapshotInput>
    public typealias MOutput = OperationOutput<CreateSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateSnapshotOutputError>
}

extension CreateSnapshotInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateSnapshotInput(directoryId: \(String(describing: directoryId)), name: \(String(describing: name)))"}
}

extension CreateSnapshotInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case directoryId = "DirectoryId"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryId = directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct CreateSnapshotInputHeadersMiddleware: Middleware {
    public let id: String = "CreateSnapshotInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateSnapshotInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateSnapshotInput>
    public typealias MOutput = OperationOutput<CreateSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateSnapshotOutputError>
}

public struct CreateSnapshotInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateSnapshotInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateSnapshotInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateSnapshotInput>
    public typealias MOutput = OperationOutput<CreateSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateSnapshotOutputError>
}

/// <p>Contains the inputs for the <a>CreateSnapshot</a> operation.</p>
public struct CreateSnapshotInput: Equatable {
    /// <p>The identifier of the directory of which to take a snapshot.</p>
    public let directoryId: String?
    /// <p>The descriptive name to apply to the snapshot.</p>
    public let name: String?

    public init (
        directoryId: String? = nil,
        name: String? = nil
    )
    {
        self.directoryId = directoryId
        self.name = name
    }
}

struct CreateSnapshotInputBody: Equatable {
    public let directoryId: String?
    public let name: String?
}

extension CreateSnapshotInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case directoryId = "DirectoryId"
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension CreateSnapshotOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateSnapshotOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityDoesNotExistException" : self = .entityDoesNotExistException(try EntityDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SnapshotLimitExceededException" : self = .snapshotLimitExceededException(try SnapshotLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateSnapshotOutputError: Equatable {
    case clientException(ClientException)
    case entityDoesNotExistException(EntityDoesNotExistException)
    case invalidParameterException(InvalidParameterException)
    case serviceException(ServiceException)
    case snapshotLimitExceededException(SnapshotLimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateSnapshotOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateSnapshotOutputResponse(snapshotId: \(String(describing: snapshotId)))"}
}

extension CreateSnapshotOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateSnapshotOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.snapshotId = output.snapshotId
        } else {
            self.snapshotId = nil
        }
    }
}

/// <p>Contains the results of the <a>CreateSnapshot</a> operation.</p>
public struct CreateSnapshotOutputResponse: Equatable {
    /// <p>The identifier of the snapshot that was created.</p>
    public let snapshotId: String?

    public init (
        snapshotId: String? = nil
    )
    {
        self.snapshotId = snapshotId
    }
}

struct CreateSnapshotOutputResponseBody: Equatable {
    public let snapshotId: String?
}

extension CreateSnapshotOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case snapshotId = "SnapshotId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snapshotIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .snapshotId)
        snapshotId = snapshotIdDecoded
    }
}

public struct CreateTrustInputBodyMiddleware: Middleware {
    public let id: String = "CreateTrustInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateTrustInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateTrustOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateTrustInput>
    public typealias MOutput = OperationOutput<CreateTrustOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateTrustOutputError>
}

extension CreateTrustInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateTrustInput(conditionalForwarderIpAddrs: \(String(describing: conditionalForwarderIpAddrs)), directoryId: \(String(describing: directoryId)), remoteDomainName: \(String(describing: remoteDomainName)), selectiveAuth: \(String(describing: selectiveAuth)), trustDirection: \(String(describing: trustDirection)), trustPassword: \(String(describing: trustPassword)), trustType: \(String(describing: trustType)))"}
}

extension CreateTrustInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case conditionalForwarderIpAddrs = "ConditionalForwarderIpAddrs"
        case directoryId = "DirectoryId"
        case remoteDomainName = "RemoteDomainName"
        case selectiveAuth = "SelectiveAuth"
        case trustDirection = "TrustDirection"
        case trustPassword = "TrustPassword"
        case trustType = "TrustType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let conditionalForwarderIpAddrs = conditionalForwarderIpAddrs {
            var conditionalForwarderIpAddrsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .conditionalForwarderIpAddrs)
            for dnsipaddrs0 in conditionalForwarderIpAddrs {
                try conditionalForwarderIpAddrsContainer.encode(dnsipaddrs0)
            }
        }
        if let directoryId = directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let remoteDomainName = remoteDomainName {
            try encodeContainer.encode(remoteDomainName, forKey: .remoteDomainName)
        }
        if let selectiveAuth = selectiveAuth {
            try encodeContainer.encode(selectiveAuth.rawValue, forKey: .selectiveAuth)
        }
        if let trustDirection = trustDirection {
            try encodeContainer.encode(trustDirection.rawValue, forKey: .trustDirection)
        }
        if let trustPassword = trustPassword {
            try encodeContainer.encode(trustPassword, forKey: .trustPassword)
        }
        if let trustType = trustType {
            try encodeContainer.encode(trustType.rawValue, forKey: .trustType)
        }
    }
}

public struct CreateTrustInputHeadersMiddleware: Middleware {
    public let id: String = "CreateTrustInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateTrustInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateTrustOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateTrustInput>
    public typealias MOutput = OperationOutput<CreateTrustOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateTrustOutputError>
}

public struct CreateTrustInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateTrustInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateTrustInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateTrustOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateTrustInput>
    public typealias MOutput = OperationOutput<CreateTrustOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateTrustOutputError>
}

/// <p>AWS Directory Service for Microsoft Active Directory allows you to configure trust relationships. For example, you can establish a trust between your AWS Managed Microsoft AD directory, and your existing on-premises Microsoft Active Directory. This would allow you to provide users and groups access to resources in either domain, with a single set of credentials.</p>
///          <p>This action initiates the creation of the AWS side of a trust relationship between an AWS Managed Microsoft AD directory and an external domain.</p>
public struct CreateTrustInput: Equatable {
    /// <p>The IP addresses of the remote DNS server associated with RemoteDomainName.</p>
    public let conditionalForwarderIpAddrs: [String]?
    /// <p>The Directory ID of the AWS Managed Microsoft AD directory for which to establish the trust relationship.</p>
    public let directoryId: String?
    /// <p>The Fully Qualified Domain Name (FQDN) of the external domain for which to create the trust relationship.</p>
    public let remoteDomainName: String?
    /// <p>Optional parameter to enable selective authentication for the trust.</p>
    public let selectiveAuth: SelectiveAuth?
    /// <p>The direction of the trust relationship.</p>
    public let trustDirection: TrustDirection?
    /// <p>The trust password. The must be the same password that was used when creating the trust relationship on the external domain.</p>
    public let trustPassword: String?
    /// <p>The trust relationship type. <code>Forest</code> is the default.</p>
    public let trustType: TrustType?

    public init (
        conditionalForwarderIpAddrs: [String]? = nil,
        directoryId: String? = nil,
        remoteDomainName: String? = nil,
        selectiveAuth: SelectiveAuth? = nil,
        trustDirection: TrustDirection? = nil,
        trustPassword: String? = nil,
        trustType: TrustType? = nil
    )
    {
        self.conditionalForwarderIpAddrs = conditionalForwarderIpAddrs
        self.directoryId = directoryId
        self.remoteDomainName = remoteDomainName
        self.selectiveAuth = selectiveAuth
        self.trustDirection = trustDirection
        self.trustPassword = trustPassword
        self.trustType = trustType
    }
}

struct CreateTrustInputBody: Equatable {
    public let directoryId: String?
    public let remoteDomainName: String?
    public let trustPassword: String?
    public let trustDirection: TrustDirection?
    public let trustType: TrustType?
    public let conditionalForwarderIpAddrs: [String]?
    public let selectiveAuth: SelectiveAuth?
}

extension CreateTrustInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case conditionalForwarderIpAddrs = "ConditionalForwarderIpAddrs"
        case directoryId = "DirectoryId"
        case remoteDomainName = "RemoteDomainName"
        case selectiveAuth = "SelectiveAuth"
        case trustDirection = "TrustDirection"
        case trustPassword = "TrustPassword"
        case trustType = "TrustType"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let remoteDomainNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .remoteDomainName)
        remoteDomainName = remoteDomainNameDecoded
        let trustPasswordDecoded = try containerValues.decodeIfPresent(String.self, forKey: .trustPassword)
        trustPassword = trustPasswordDecoded
        let trustDirectionDecoded = try containerValues.decodeIfPresent(TrustDirection.self, forKey: .trustDirection)
        trustDirection = trustDirectionDecoded
        let trustTypeDecoded = try containerValues.decodeIfPresent(TrustType.self, forKey: .trustType)
        trustType = trustTypeDecoded
        let conditionalForwarderIpAddrsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .conditionalForwarderIpAddrs)
        var conditionalForwarderIpAddrsDecoded0:[String]? = nil
        if let conditionalForwarderIpAddrsContainer = conditionalForwarderIpAddrsContainer {
            conditionalForwarderIpAddrsDecoded0 = [String]()
            for string0 in conditionalForwarderIpAddrsContainer {
                if let string0 = string0 {
                    conditionalForwarderIpAddrsDecoded0?.append(string0)
                }
            }
        }
        conditionalForwarderIpAddrs = conditionalForwarderIpAddrsDecoded0
        let selectiveAuthDecoded = try containerValues.decodeIfPresent(SelectiveAuth.self, forKey: .selectiveAuth)
        selectiveAuth = selectiveAuthDecoded
    }
}

extension CreateTrustOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateTrustOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityAlreadyExistsException" : self = .entityAlreadyExistsException(try EntityAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityDoesNotExistException" : self = .entityDoesNotExistException(try EntityDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateTrustOutputError: Equatable {
    case clientException(ClientException)
    case entityAlreadyExistsException(EntityAlreadyExistsException)
    case entityDoesNotExistException(EntityDoesNotExistException)
    case invalidParameterException(InvalidParameterException)
    case serviceException(ServiceException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateTrustOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateTrustOutputResponse(trustId: \(String(describing: trustId)))"}
}

extension CreateTrustOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateTrustOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.trustId = output.trustId
        } else {
            self.trustId = nil
        }
    }
}

/// <p>The result of a CreateTrust request.</p>
public struct CreateTrustOutputResponse: Equatable {
    /// <p>A unique identifier for the trust relationship that was created.</p>
    public let trustId: String?

    public init (
        trustId: String? = nil
    )
    {
        self.trustId = trustId
    }
}

struct CreateTrustOutputResponseBody: Equatable {
    public let trustId: String?
}

extension CreateTrustOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case trustId = "TrustId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trustIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .trustId)
        trustId = trustIdDecoded
    }
}

public struct DeleteConditionalForwarderInputBodyMiddleware: Middleware {
    public let id: String = "DeleteConditionalForwarderInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteConditionalForwarderInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteConditionalForwarderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteConditionalForwarderInput>
    public typealias MOutput = OperationOutput<DeleteConditionalForwarderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteConditionalForwarderOutputError>
}

extension DeleteConditionalForwarderInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteConditionalForwarderInput(directoryId: \(String(describing: directoryId)), remoteDomainName: \(String(describing: remoteDomainName)))"}
}

extension DeleteConditionalForwarderInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case directoryId = "DirectoryId"
        case remoteDomainName = "RemoteDomainName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryId = directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let remoteDomainName = remoteDomainName {
            try encodeContainer.encode(remoteDomainName, forKey: .remoteDomainName)
        }
    }
}

public struct DeleteConditionalForwarderInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteConditionalForwarderInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteConditionalForwarderInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteConditionalForwarderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteConditionalForwarderInput>
    public typealias MOutput = OperationOutput<DeleteConditionalForwarderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteConditionalForwarderOutputError>
}

public struct DeleteConditionalForwarderInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteConditionalForwarderInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteConditionalForwarderInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteConditionalForwarderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteConditionalForwarderInput>
    public typealias MOutput = OperationOutput<DeleteConditionalForwarderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteConditionalForwarderOutputError>
}

/// <p>Deletes a conditional forwarder.</p>
public struct DeleteConditionalForwarderInput: Equatable {
    /// <p>The directory ID for which you are deleting the conditional forwarder.</p>
    public let directoryId: String?
    /// <p>The fully qualified domain name (FQDN) of the remote domain with which you are deleting the conditional forwarder.</p>
    public let remoteDomainName: String?

    public init (
        directoryId: String? = nil,
        remoteDomainName: String? = nil
    )
    {
        self.directoryId = directoryId
        self.remoteDomainName = remoteDomainName
    }
}

struct DeleteConditionalForwarderInputBody: Equatable {
    public let directoryId: String?
    public let remoteDomainName: String?
}

extension DeleteConditionalForwarderInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case directoryId = "DirectoryId"
        case remoteDomainName = "RemoteDomainName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let remoteDomainNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .remoteDomainName)
        remoteDomainName = remoteDomainNameDecoded
    }
}

extension DeleteConditionalForwarderOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteConditionalForwarderOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryUnavailableException" : self = .directoryUnavailableException(try DirectoryUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityDoesNotExistException" : self = .entityDoesNotExistException(try EntityDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteConditionalForwarderOutputError: Equatable {
    case clientException(ClientException)
    case directoryUnavailableException(DirectoryUnavailableException)
    case entityDoesNotExistException(EntityDoesNotExistException)
    case invalidParameterException(InvalidParameterException)
    case serviceException(ServiceException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteConditionalForwarderOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteConditionalForwarderOutputResponse()"}
}

extension DeleteConditionalForwarderOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>The result of a DeleteConditionalForwarder request.</p>
public struct DeleteConditionalForwarderOutputResponse: Equatable {

    public init() {}
}

struct DeleteConditionalForwarderOutputResponseBody: Equatable {
}

extension DeleteConditionalForwarderOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteDirectoryInputBodyMiddleware: Middleware {
    public let id: String = "DeleteDirectoryInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDirectoryInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDirectoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDirectoryInput>
    public typealias MOutput = OperationOutput<DeleteDirectoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDirectoryOutputError>
}

extension DeleteDirectoryInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDirectoryInput(directoryId: \(String(describing: directoryId)))"}
}

extension DeleteDirectoryInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case directoryId = "DirectoryId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryId = directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
    }
}

public struct DeleteDirectoryInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteDirectoryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDirectoryInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDirectoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDirectoryInput>
    public typealias MOutput = OperationOutput<DeleteDirectoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDirectoryOutputError>
}

public struct DeleteDirectoryInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteDirectoryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDirectoryInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDirectoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDirectoryInput>
    public typealias MOutput = OperationOutput<DeleteDirectoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDirectoryOutputError>
}

/// <p>Contains the inputs for the <a>DeleteDirectory</a> operation.</p>
public struct DeleteDirectoryInput: Equatable {
    /// <p>The identifier of the directory to delete.</p>
    public let directoryId: String?

    public init (
        directoryId: String? = nil
    )
    {
        self.directoryId = directoryId
    }
}

struct DeleteDirectoryInputBody: Equatable {
    public let directoryId: String?
}

extension DeleteDirectoryInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case directoryId = "DirectoryId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
    }
}

extension DeleteDirectoryOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDirectoryOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityDoesNotExistException" : self = .entityDoesNotExistException(try EntityDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDirectoryOutputError: Equatable {
    case clientException(ClientException)
    case entityDoesNotExistException(EntityDoesNotExistException)
    case serviceException(ServiceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDirectoryOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDirectoryOutputResponse(directoryId: \(String(describing: directoryId)))"}
}

extension DeleteDirectoryOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteDirectoryOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.directoryId = output.directoryId
        } else {
            self.directoryId = nil
        }
    }
}

/// <p>Contains the results of the <a>DeleteDirectory</a> operation.</p>
public struct DeleteDirectoryOutputResponse: Equatable {
    /// <p>The directory identifier.</p>
    public let directoryId: String?

    public init (
        directoryId: String? = nil
    )
    {
        self.directoryId = directoryId
    }
}

struct DeleteDirectoryOutputResponseBody: Equatable {
    public let directoryId: String?
}

extension DeleteDirectoryOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case directoryId = "DirectoryId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
    }
}

public struct DeleteLogSubscriptionInputBodyMiddleware: Middleware {
    public let id: String = "DeleteLogSubscriptionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteLogSubscriptionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteLogSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteLogSubscriptionInput>
    public typealias MOutput = OperationOutput<DeleteLogSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteLogSubscriptionOutputError>
}

extension DeleteLogSubscriptionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteLogSubscriptionInput(directoryId: \(String(describing: directoryId)))"}
}

extension DeleteLogSubscriptionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case directoryId = "DirectoryId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryId = directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
    }
}

public struct DeleteLogSubscriptionInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteLogSubscriptionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteLogSubscriptionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteLogSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteLogSubscriptionInput>
    public typealias MOutput = OperationOutput<DeleteLogSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteLogSubscriptionOutputError>
}

public struct DeleteLogSubscriptionInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteLogSubscriptionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteLogSubscriptionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteLogSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteLogSubscriptionInput>
    public typealias MOutput = OperationOutput<DeleteLogSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteLogSubscriptionOutputError>
}

public struct DeleteLogSubscriptionInput: Equatable {
    /// <p>Identifier of the directory whose log subscription you want to delete.</p>
    public let directoryId: String?

    public init (
        directoryId: String? = nil
    )
    {
        self.directoryId = directoryId
    }
}

struct DeleteLogSubscriptionInputBody: Equatable {
    public let directoryId: String?
}

extension DeleteLogSubscriptionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case directoryId = "DirectoryId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
    }
}

extension DeleteLogSubscriptionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteLogSubscriptionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityDoesNotExistException" : self = .entityDoesNotExistException(try EntityDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteLogSubscriptionOutputError: Equatable {
    case clientException(ClientException)
    case entityDoesNotExistException(EntityDoesNotExistException)
    case serviceException(ServiceException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteLogSubscriptionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteLogSubscriptionOutputResponse()"}
}

extension DeleteLogSubscriptionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteLogSubscriptionOutputResponse: Equatable {

    public init() {}
}

struct DeleteLogSubscriptionOutputResponseBody: Equatable {
}

extension DeleteLogSubscriptionOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteSnapshotInputBodyMiddleware: Middleware {
    public let id: String = "DeleteSnapshotInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteSnapshotInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteSnapshotInput>
    public typealias MOutput = OperationOutput<DeleteSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteSnapshotOutputError>
}

extension DeleteSnapshotInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteSnapshotInput(snapshotId: \(String(describing: snapshotId)))"}
}

extension DeleteSnapshotInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case snapshotId = "SnapshotId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let snapshotId = snapshotId {
            try encodeContainer.encode(snapshotId, forKey: .snapshotId)
        }
    }
}

public struct DeleteSnapshotInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteSnapshotInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteSnapshotInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteSnapshotInput>
    public typealias MOutput = OperationOutput<DeleteSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteSnapshotOutputError>
}

public struct DeleteSnapshotInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteSnapshotInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteSnapshotInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteSnapshotInput>
    public typealias MOutput = OperationOutput<DeleteSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteSnapshotOutputError>
}

/// <p>Contains the inputs for the <a>DeleteSnapshot</a> operation.</p>
public struct DeleteSnapshotInput: Equatable {
    /// <p>The identifier of the directory snapshot to be deleted.</p>
    public let snapshotId: String?

    public init (
        snapshotId: String? = nil
    )
    {
        self.snapshotId = snapshotId
    }
}

struct DeleteSnapshotInputBody: Equatable {
    public let snapshotId: String?
}

extension DeleteSnapshotInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case snapshotId = "SnapshotId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snapshotIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .snapshotId)
        snapshotId = snapshotIdDecoded
    }
}

extension DeleteSnapshotOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteSnapshotOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityDoesNotExistException" : self = .entityDoesNotExistException(try EntityDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteSnapshotOutputError: Equatable {
    case clientException(ClientException)
    case entityDoesNotExistException(EntityDoesNotExistException)
    case invalidParameterException(InvalidParameterException)
    case serviceException(ServiceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteSnapshotOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteSnapshotOutputResponse(snapshotId: \(String(describing: snapshotId)))"}
}

extension DeleteSnapshotOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteSnapshotOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.snapshotId = output.snapshotId
        } else {
            self.snapshotId = nil
        }
    }
}

/// <p>Contains the results of the <a>DeleteSnapshot</a> operation.</p>
public struct DeleteSnapshotOutputResponse: Equatable {
    /// <p>The identifier of the directory snapshot that was deleted.</p>
    public let snapshotId: String?

    public init (
        snapshotId: String? = nil
    )
    {
        self.snapshotId = snapshotId
    }
}

struct DeleteSnapshotOutputResponseBody: Equatable {
    public let snapshotId: String?
}

extension DeleteSnapshotOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case snapshotId = "SnapshotId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snapshotIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .snapshotId)
        snapshotId = snapshotIdDecoded
    }
}

public struct DeleteTrustInputBodyMiddleware: Middleware {
    public let id: String = "DeleteTrustInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteTrustInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteTrustOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteTrustInput>
    public typealias MOutput = OperationOutput<DeleteTrustOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteTrustOutputError>
}

extension DeleteTrustInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteTrustInput(deleteAssociatedConditionalForwarder: \(String(describing: deleteAssociatedConditionalForwarder)), trustId: \(String(describing: trustId)))"}
}

extension DeleteTrustInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case deleteAssociatedConditionalForwarder = "DeleteAssociatedConditionalForwarder"
        case trustId = "TrustId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if deleteAssociatedConditionalForwarder != false {
            try encodeContainer.encode(deleteAssociatedConditionalForwarder, forKey: .deleteAssociatedConditionalForwarder)
        }
        if let trustId = trustId {
            try encodeContainer.encode(trustId, forKey: .trustId)
        }
    }
}

public struct DeleteTrustInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteTrustInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteTrustInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteTrustOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteTrustInput>
    public typealias MOutput = OperationOutput<DeleteTrustOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteTrustOutputError>
}

public struct DeleteTrustInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteTrustInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteTrustInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteTrustOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteTrustInput>
    public typealias MOutput = OperationOutput<DeleteTrustOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteTrustOutputError>
}

/// <p>Deletes the local side of an existing trust relationship between the AWS Managed Microsoft AD directory and the external domain.</p>
public struct DeleteTrustInput: Equatable {
    /// <p>Delete a conditional forwarder as part of a DeleteTrustRequest.</p>
    public let deleteAssociatedConditionalForwarder: Bool
    /// <p>The Trust ID of the trust relationship to be deleted.</p>
    public let trustId: String?

    public init (
        deleteAssociatedConditionalForwarder: Bool = false,
        trustId: String? = nil
    )
    {
        self.deleteAssociatedConditionalForwarder = deleteAssociatedConditionalForwarder
        self.trustId = trustId
    }
}

struct DeleteTrustInputBody: Equatable {
    public let trustId: String?
    public let deleteAssociatedConditionalForwarder: Bool
}

extension DeleteTrustInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case deleteAssociatedConditionalForwarder = "DeleteAssociatedConditionalForwarder"
        case trustId = "TrustId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trustIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .trustId)
        trustId = trustIdDecoded
        let deleteAssociatedConditionalForwarderDecoded = try containerValues.decode(Bool.self, forKey: .deleteAssociatedConditionalForwarder)
        deleteAssociatedConditionalForwarder = deleteAssociatedConditionalForwarderDecoded
    }
}

extension DeleteTrustOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteTrustOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityDoesNotExistException" : self = .entityDoesNotExistException(try EntityDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteTrustOutputError: Equatable {
    case clientException(ClientException)
    case entityDoesNotExistException(EntityDoesNotExistException)
    case invalidParameterException(InvalidParameterException)
    case serviceException(ServiceException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteTrustOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteTrustOutputResponse(trustId: \(String(describing: trustId)))"}
}

extension DeleteTrustOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteTrustOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.trustId = output.trustId
        } else {
            self.trustId = nil
        }
    }
}

/// <p>The result of a DeleteTrust request.</p>
public struct DeleteTrustOutputResponse: Equatable {
    /// <p>The Trust ID of the trust relationship that was deleted.</p>
    public let trustId: String?

    public init (
        trustId: String? = nil
    )
    {
        self.trustId = trustId
    }
}

struct DeleteTrustOutputResponseBody: Equatable {
    public let trustId: String?
}

extension DeleteTrustOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case trustId = "TrustId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trustIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .trustId)
        trustId = trustIdDecoded
    }
}

public struct DeregisterCertificateInputBodyMiddleware: Middleware {
    public let id: String = "DeregisterCertificateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeregisterCertificateInput>,
                  next: H) -> Swift.Result<OperationOutput<DeregisterCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeregisterCertificateInput>
    public typealias MOutput = OperationOutput<DeregisterCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeregisterCertificateOutputError>
}

extension DeregisterCertificateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeregisterCertificateInput(certificateId: \(String(describing: certificateId)), directoryId: \(String(describing: directoryId)))"}
}

extension DeregisterCertificateInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case certificateId = "CertificateId"
        case directoryId = "DirectoryId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateId = certificateId {
            try encodeContainer.encode(certificateId, forKey: .certificateId)
        }
        if let directoryId = directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
    }
}

public struct DeregisterCertificateInputHeadersMiddleware: Middleware {
    public let id: String = "DeregisterCertificateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeregisterCertificateInput>,
                  next: H) -> Swift.Result<OperationOutput<DeregisterCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeregisterCertificateInput>
    public typealias MOutput = OperationOutput<DeregisterCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeregisterCertificateOutputError>
}

public struct DeregisterCertificateInputQueryItemMiddleware: Middleware {
    public let id: String = "DeregisterCertificateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeregisterCertificateInput>,
                  next: H) -> Swift.Result<OperationOutput<DeregisterCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeregisterCertificateInput>
    public typealias MOutput = OperationOutput<DeregisterCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeregisterCertificateOutputError>
}

public struct DeregisterCertificateInput: Equatable {
    /// <p>The identifier of the certificate.</p>
    public let certificateId: String?
    /// <p>The identifier of the directory.</p>
    public let directoryId: String?

    public init (
        certificateId: String? = nil,
        directoryId: String? = nil
    )
    {
        self.certificateId = certificateId
        self.directoryId = directoryId
    }
}

struct DeregisterCertificateInputBody: Equatable {
    public let directoryId: String?
    public let certificateId: String?
}

extension DeregisterCertificateInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case certificateId = "CertificateId"
        case directoryId = "DirectoryId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let certificateIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificateId)
        certificateId = certificateIdDecoded
    }
}

extension DeregisterCertificateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeregisterCertificateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CertificateDoesNotExistException" : self = .certificateDoesNotExistException(try CertificateDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CertificateInUseException" : self = .certificateInUseException(try CertificateInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryDoesNotExistException" : self = .directoryDoesNotExistException(try DirectoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryUnavailableException" : self = .directoryUnavailableException(try DirectoryUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeregisterCertificateOutputError: Equatable {
    case certificateDoesNotExistException(CertificateDoesNotExistException)
    case certificateInUseException(CertificateInUseException)
    case clientException(ClientException)
    case directoryDoesNotExistException(DirectoryDoesNotExistException)
    case directoryUnavailableException(DirectoryUnavailableException)
    case invalidParameterException(InvalidParameterException)
    case serviceException(ServiceException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeregisterCertificateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeregisterCertificateOutputResponse()"}
}

extension DeregisterCertificateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeregisterCertificateOutputResponse: Equatable {

    public init() {}
}

struct DeregisterCertificateOutputResponseBody: Equatable {
}

extension DeregisterCertificateOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeregisterEventTopicInputBodyMiddleware: Middleware {
    public let id: String = "DeregisterEventTopicInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeregisterEventTopicInput>,
                  next: H) -> Swift.Result<OperationOutput<DeregisterEventTopicOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeregisterEventTopicInput>
    public typealias MOutput = OperationOutput<DeregisterEventTopicOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeregisterEventTopicOutputError>
}

extension DeregisterEventTopicInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeregisterEventTopicInput(directoryId: \(String(describing: directoryId)), topicName: \(String(describing: topicName)))"}
}

extension DeregisterEventTopicInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case directoryId = "DirectoryId"
        case topicName = "TopicName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryId = directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let topicName = topicName {
            try encodeContainer.encode(topicName, forKey: .topicName)
        }
    }
}

public struct DeregisterEventTopicInputHeadersMiddleware: Middleware {
    public let id: String = "DeregisterEventTopicInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeregisterEventTopicInput>,
                  next: H) -> Swift.Result<OperationOutput<DeregisterEventTopicOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeregisterEventTopicInput>
    public typealias MOutput = OperationOutput<DeregisterEventTopicOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeregisterEventTopicOutputError>
}

public struct DeregisterEventTopicInputQueryItemMiddleware: Middleware {
    public let id: String = "DeregisterEventTopicInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeregisterEventTopicInput>,
                  next: H) -> Swift.Result<OperationOutput<DeregisterEventTopicOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeregisterEventTopicInput>
    public typealias MOutput = OperationOutput<DeregisterEventTopicOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeregisterEventTopicOutputError>
}

/// <p>Removes the specified directory as a publisher to the specified SNS topic.</p>
public struct DeregisterEventTopicInput: Equatable {
    /// <p>The Directory ID to remove as a publisher. This directory will no longer send messages to the specified SNS topic.</p>
    public let directoryId: String?
    /// <p>The name of the SNS topic from which to remove the directory as a publisher.</p>
    public let topicName: String?

    public init (
        directoryId: String? = nil,
        topicName: String? = nil
    )
    {
        self.directoryId = directoryId
        self.topicName = topicName
    }
}

struct DeregisterEventTopicInputBody: Equatable {
    public let directoryId: String?
    public let topicName: String?
}

extension DeregisterEventTopicInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case directoryId = "DirectoryId"
        case topicName = "TopicName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let topicNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .topicName)
        topicName = topicNameDecoded
    }
}

extension DeregisterEventTopicOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeregisterEventTopicOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityDoesNotExistException" : self = .entityDoesNotExistException(try EntityDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeregisterEventTopicOutputError: Equatable {
    case clientException(ClientException)
    case entityDoesNotExistException(EntityDoesNotExistException)
    case invalidParameterException(InvalidParameterException)
    case serviceException(ServiceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeregisterEventTopicOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeregisterEventTopicOutputResponse()"}
}

extension DeregisterEventTopicOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>The result of a DeregisterEventTopic request.</p>
public struct DeregisterEventTopicOutputResponse: Equatable {

    public init() {}
}

struct DeregisterEventTopicOutputResponseBody: Equatable {
}

extension DeregisterEventTopicOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DescribeCertificateInputBodyMiddleware: Middleware {
    public let id: String = "DescribeCertificateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeCertificateInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeCertificateInput>
    public typealias MOutput = OperationOutput<DescribeCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeCertificateOutputError>
}

extension DescribeCertificateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeCertificateInput(certificateId: \(String(describing: certificateId)), directoryId: \(String(describing: directoryId)))"}
}

extension DescribeCertificateInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case certificateId = "CertificateId"
        case directoryId = "DirectoryId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateId = certificateId {
            try encodeContainer.encode(certificateId, forKey: .certificateId)
        }
        if let directoryId = directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
    }
}

public struct DescribeCertificateInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeCertificateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeCertificateInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeCertificateInput>
    public typealias MOutput = OperationOutput<DescribeCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeCertificateOutputError>
}

public struct DescribeCertificateInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeCertificateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeCertificateInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeCertificateInput>
    public typealias MOutput = OperationOutput<DescribeCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeCertificateOutputError>
}

public struct DescribeCertificateInput: Equatable {
    /// <p>The identifier of the certificate.</p>
    public let certificateId: String?
    /// <p>The identifier of the directory.</p>
    public let directoryId: String?

    public init (
        certificateId: String? = nil,
        directoryId: String? = nil
    )
    {
        self.certificateId = certificateId
        self.directoryId = directoryId
    }
}

struct DescribeCertificateInputBody: Equatable {
    public let directoryId: String?
    public let certificateId: String?
}

extension DescribeCertificateInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case certificateId = "CertificateId"
        case directoryId = "DirectoryId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let certificateIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificateId)
        certificateId = certificateIdDecoded
    }
}

extension DescribeCertificateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeCertificateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CertificateDoesNotExistException" : self = .certificateDoesNotExistException(try CertificateDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryDoesNotExistException" : self = .directoryDoesNotExistException(try DirectoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeCertificateOutputError: Equatable {
    case certificateDoesNotExistException(CertificateDoesNotExistException)
    case clientException(ClientException)
    case directoryDoesNotExistException(DirectoryDoesNotExistException)
    case invalidParameterException(InvalidParameterException)
    case serviceException(ServiceException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeCertificateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeCertificateOutputResponse(certificate: \(String(describing: certificate)))"}
}

extension DescribeCertificateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeCertificateOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.certificate = output.certificate
        } else {
            self.certificate = nil
        }
    }
}

public struct DescribeCertificateOutputResponse: Equatable {
    /// <p>Information about the certificate, including registered date time, certificate state, the
    ///       reason for the state, expiration date time, and certificate common name.</p>
    public let certificate: Certificate?

    public init (
        certificate: Certificate? = nil
    )
    {
        self.certificate = certificate
    }
}

struct DescribeCertificateOutputResponseBody: Equatable {
    public let certificate: Certificate?
}

extension DescribeCertificateOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case certificate = "Certificate"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateDecoded = try containerValues.decodeIfPresent(Certificate.self, forKey: .certificate)
        certificate = certificateDecoded
    }
}

public struct DescribeConditionalForwardersInputBodyMiddleware: Middleware {
    public let id: String = "DescribeConditionalForwardersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeConditionalForwardersInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeConditionalForwardersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeConditionalForwardersInput>
    public typealias MOutput = OperationOutput<DescribeConditionalForwardersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeConditionalForwardersOutputError>
}

extension DescribeConditionalForwardersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeConditionalForwardersInput(directoryId: \(String(describing: directoryId)), remoteDomainNames: \(String(describing: remoteDomainNames)))"}
}

extension DescribeConditionalForwardersInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case directoryId = "DirectoryId"
        case remoteDomainNames = "RemoteDomainNames"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryId = directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let remoteDomainNames = remoteDomainNames {
            var remoteDomainNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .remoteDomainNames)
            for remotedomainnames0 in remoteDomainNames {
                try remoteDomainNamesContainer.encode(remotedomainnames0)
            }
        }
    }
}

public struct DescribeConditionalForwardersInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeConditionalForwardersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeConditionalForwardersInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeConditionalForwardersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeConditionalForwardersInput>
    public typealias MOutput = OperationOutput<DescribeConditionalForwardersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeConditionalForwardersOutputError>
}

public struct DescribeConditionalForwardersInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeConditionalForwardersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeConditionalForwardersInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeConditionalForwardersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeConditionalForwardersInput>
    public typealias MOutput = OperationOutput<DescribeConditionalForwardersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeConditionalForwardersOutputError>
}

/// <p>Describes a conditional forwarder.</p>
public struct DescribeConditionalForwardersInput: Equatable {
    /// <p>The directory ID for which to get the list of associated conditional forwarders.</p>
    public let directoryId: String?
    /// <p>The fully qualified domain names (FQDN) of the remote domains for which to get the list of associated conditional forwarders. If this member is null, all conditional forwarders are returned.</p>
    public let remoteDomainNames: [String]?

    public init (
        directoryId: String? = nil,
        remoteDomainNames: [String]? = nil
    )
    {
        self.directoryId = directoryId
        self.remoteDomainNames = remoteDomainNames
    }
}

struct DescribeConditionalForwardersInputBody: Equatable {
    public let directoryId: String?
    public let remoteDomainNames: [String]?
}

extension DescribeConditionalForwardersInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case directoryId = "DirectoryId"
        case remoteDomainNames = "RemoteDomainNames"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let remoteDomainNamesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .remoteDomainNames)
        var remoteDomainNamesDecoded0:[String]? = nil
        if let remoteDomainNamesContainer = remoteDomainNamesContainer {
            remoteDomainNamesDecoded0 = [String]()
            for string0 in remoteDomainNamesContainer {
                if let string0 = string0 {
                    remoteDomainNamesDecoded0?.append(string0)
                }
            }
        }
        remoteDomainNames = remoteDomainNamesDecoded0
    }
}

extension DescribeConditionalForwardersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeConditionalForwardersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryUnavailableException" : self = .directoryUnavailableException(try DirectoryUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityDoesNotExistException" : self = .entityDoesNotExistException(try EntityDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeConditionalForwardersOutputError: Equatable {
    case clientException(ClientException)
    case directoryUnavailableException(DirectoryUnavailableException)
    case entityDoesNotExistException(EntityDoesNotExistException)
    case invalidParameterException(InvalidParameterException)
    case serviceException(ServiceException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeConditionalForwardersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeConditionalForwardersOutputResponse(conditionalForwarders: \(String(describing: conditionalForwarders)))"}
}

extension DescribeConditionalForwardersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeConditionalForwardersOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.conditionalForwarders = output.conditionalForwarders
        } else {
            self.conditionalForwarders = nil
        }
    }
}

/// <p>The result of a DescribeConditionalForwarder request.</p>
public struct DescribeConditionalForwardersOutputResponse: Equatable {
    /// <p>The list of conditional forwarders that have been created.</p>
    public let conditionalForwarders: [ConditionalForwarder]?

    public init (
        conditionalForwarders: [ConditionalForwarder]? = nil
    )
    {
        self.conditionalForwarders = conditionalForwarders
    }
}

struct DescribeConditionalForwardersOutputResponseBody: Equatable {
    public let conditionalForwarders: [ConditionalForwarder]?
}

extension DescribeConditionalForwardersOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case conditionalForwarders = "ConditionalForwarders"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let conditionalForwardersContainer = try containerValues.decodeIfPresent([ConditionalForwarder?].self, forKey: .conditionalForwarders)
        var conditionalForwardersDecoded0:[ConditionalForwarder]? = nil
        if let conditionalForwardersContainer = conditionalForwardersContainer {
            conditionalForwardersDecoded0 = [ConditionalForwarder]()
            for structure0 in conditionalForwardersContainer {
                if let structure0 = structure0 {
                    conditionalForwardersDecoded0?.append(structure0)
                }
            }
        }
        conditionalForwarders = conditionalForwardersDecoded0
    }
}

public struct DescribeDirectoriesInputBodyMiddleware: Middleware {
    public let id: String = "DescribeDirectoriesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDirectoriesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDirectoriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDirectoriesInput>
    public typealias MOutput = OperationOutput<DescribeDirectoriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDirectoriesOutputError>
}

extension DescribeDirectoriesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDirectoriesInput(directoryIds: \(String(describing: directoryIds)), limit: \(String(describing: limit)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeDirectoriesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case directoryIds = "DirectoryIds"
        case limit = "Limit"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryIds = directoryIds {
            var directoryIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .directoryIds)
            for directoryids0 in directoryIds {
                try directoryIdsContainer.encode(directoryids0)
            }
        }
        if let limit = limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct DescribeDirectoriesInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeDirectoriesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDirectoriesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDirectoriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDirectoriesInput>
    public typealias MOutput = OperationOutput<DescribeDirectoriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDirectoriesOutputError>
}

public struct DescribeDirectoriesInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeDirectoriesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDirectoriesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDirectoriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDirectoriesInput>
    public typealias MOutput = OperationOutput<DescribeDirectoriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDirectoriesOutputError>
}

/// <p>Contains the inputs for the <a>DescribeDirectories</a> operation.</p>
public struct DescribeDirectoriesInput: Equatable {
    /// <p>A list of identifiers of the directories for which to obtain the information. If this
    ///       member is null, all directories that belong to the current account are returned.</p>
    ///          <p>An empty list results in an <code>InvalidParameterException</code> being thrown.</p>
    public let directoryIds: [String]?
    /// <p>The maximum number of items to return. If this value is zero, the maximum number of items
    ///       is specified by the limitations of the operation.</p>
    public let limit: Int?
    /// <p>The <code>DescribeDirectoriesResult.NextToken</code> value from a previous call to <a>DescribeDirectories</a>. Pass null if this is the first call.</p>
    public let nextToken: String?

    public init (
        directoryIds: [String]? = nil,
        limit: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.directoryIds = directoryIds
        self.limit = limit
        self.nextToken = nextToken
    }
}

struct DescribeDirectoriesInputBody: Equatable {
    public let directoryIds: [String]?
    public let nextToken: String?
    public let limit: Int?
}

extension DescribeDirectoriesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case directoryIds = "DirectoryIds"
        case limit = "Limit"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .directoryIds)
        var directoryIdsDecoded0:[String]? = nil
        if let directoryIdsContainer = directoryIdsContainer {
            directoryIdsDecoded0 = [String]()
            for string0 in directoryIdsContainer {
                if let string0 = string0 {
                    directoryIdsDecoded0?.append(string0)
                }
            }
        }
        directoryIds = directoryIdsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .limit)
        limit = limitDecoded
    }
}

extension DescribeDirectoriesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDirectoriesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityDoesNotExistException" : self = .entityDoesNotExistException(try EntityDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDirectoriesOutputError: Equatable {
    case clientException(ClientException)
    case entityDoesNotExistException(EntityDoesNotExistException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterException(InvalidParameterException)
    case serviceException(ServiceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDirectoriesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDirectoriesOutputResponse(directoryDescriptions: \(String(describing: directoryDescriptions)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeDirectoriesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeDirectoriesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.directoryDescriptions = output.directoryDescriptions
            self.nextToken = output.nextToken
        } else {
            self.directoryDescriptions = nil
            self.nextToken = nil
        }
    }
}

/// <p>Contains the results of the <a>DescribeDirectories</a> operation.</p>
public struct DescribeDirectoriesOutputResponse: Equatable {
    /// <p>The list of <a>DirectoryDescription</a> objects that were retrieved.</p>
    ///          <p>It is possible that this list contains less than the number of items specified in the
    ///         <code>Limit</code> member of the request. This occurs if there are less than the requested
    ///       number of items left to retrieve, or if the limitations of the operation have been
    ///       exceeded.</p>
    public let directoryDescriptions: [DirectoryDescription]?
    /// <p>If not null, more results are available. Pass this value for the <code>NextToken</code>
    ///       parameter in a subsequent call to <a>DescribeDirectories</a> to retrieve the next
    ///       set of items.</p>
    public let nextToken: String?

    public init (
        directoryDescriptions: [DirectoryDescription]? = nil,
        nextToken: String? = nil
    )
    {
        self.directoryDescriptions = directoryDescriptions
        self.nextToken = nextToken
    }
}

struct DescribeDirectoriesOutputResponseBody: Equatable {
    public let directoryDescriptions: [DirectoryDescription]?
    public let nextToken: String?
}

extension DescribeDirectoriesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case directoryDescriptions = "DirectoryDescriptions"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryDescriptionsContainer = try containerValues.decodeIfPresent([DirectoryDescription?].self, forKey: .directoryDescriptions)
        var directoryDescriptionsDecoded0:[DirectoryDescription]? = nil
        if let directoryDescriptionsContainer = directoryDescriptionsContainer {
            directoryDescriptionsDecoded0 = [DirectoryDescription]()
            for structure0 in directoryDescriptionsContainer {
                if let structure0 = structure0 {
                    directoryDescriptionsDecoded0?.append(structure0)
                }
            }
        }
        directoryDescriptions = directoryDescriptionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeDomainControllersInputBodyMiddleware: Middleware {
    public let id: String = "DescribeDomainControllersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDomainControllersInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDomainControllersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDomainControllersInput>
    public typealias MOutput = OperationOutput<DescribeDomainControllersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDomainControllersOutputError>
}

extension DescribeDomainControllersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDomainControllersInput(directoryId: \(String(describing: directoryId)), domainControllerIds: \(String(describing: domainControllerIds)), limit: \(String(describing: limit)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeDomainControllersInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case directoryId = "DirectoryId"
        case domainControllerIds = "DomainControllerIds"
        case limit = "Limit"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryId = directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let domainControllerIds = domainControllerIds {
            var domainControllerIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .domainControllerIds)
            for domaincontrollerids0 in domainControllerIds {
                try domainControllerIdsContainer.encode(domaincontrollerids0)
            }
        }
        if let limit = limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct DescribeDomainControllersInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeDomainControllersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDomainControllersInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDomainControllersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDomainControllersInput>
    public typealias MOutput = OperationOutput<DescribeDomainControllersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDomainControllersOutputError>
}

public struct DescribeDomainControllersInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeDomainControllersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDomainControllersInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDomainControllersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDomainControllersInput>
    public typealias MOutput = OperationOutput<DescribeDomainControllersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDomainControllersOutputError>
}

public struct DescribeDomainControllersInput: Equatable {
    /// <p>Identifier of the directory for which to retrieve the domain controller information.</p>
    public let directoryId: String?
    /// <p>A list of identifiers for the domain controllers whose information will be provided.</p>
    public let domainControllerIds: [String]?
    /// <p>The maximum number of items to return.</p>
    public let limit: Int?
    /// <p>The <i>DescribeDomainControllers.NextToken</i> value from a previous call to <a>DescribeDomainControllers</a>. Pass null if this is the first call. </p>
    public let nextToken: String?

    public init (
        directoryId: String? = nil,
        domainControllerIds: [String]? = nil,
        limit: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.directoryId = directoryId
        self.domainControllerIds = domainControllerIds
        self.limit = limit
        self.nextToken = nextToken
    }
}

struct DescribeDomainControllersInputBody: Equatable {
    public let directoryId: String?
    public let domainControllerIds: [String]?
    public let nextToken: String?
    public let limit: Int?
}

extension DescribeDomainControllersInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case directoryId = "DirectoryId"
        case domainControllerIds = "DomainControllerIds"
        case limit = "Limit"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let domainControllerIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .domainControllerIds)
        var domainControllerIdsDecoded0:[String]? = nil
        if let domainControllerIdsContainer = domainControllerIdsContainer {
            domainControllerIdsDecoded0 = [String]()
            for string0 in domainControllerIdsContainer {
                if let string0 = string0 {
                    domainControllerIdsDecoded0?.append(string0)
                }
            }
        }
        domainControllerIds = domainControllerIdsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .limit)
        limit = limitDecoded
    }
}

extension DescribeDomainControllersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDomainControllersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityDoesNotExistException" : self = .entityDoesNotExistException(try EntityDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDomainControllersOutputError: Equatable {
    case clientException(ClientException)
    case entityDoesNotExistException(EntityDoesNotExistException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterException(InvalidParameterException)
    case serviceException(ServiceException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDomainControllersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDomainControllersOutputResponse(domainControllers: \(String(describing: domainControllers)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeDomainControllersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeDomainControllersOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.domainControllers = output.domainControllers
            self.nextToken = output.nextToken
        } else {
            self.domainControllers = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeDomainControllersOutputResponse: Equatable {
    /// <p>List of the <a>DomainController</a> objects that were retrieved.</p>
    public let domainControllers: [DomainController]?
    /// <p>If not null, more results are available. Pass this value for the <code>NextToken</code> parameter in a subsequent call to <a>DescribeDomainControllers</a> retrieve the next set of items.</p>
    public let nextToken: String?

    public init (
        domainControllers: [DomainController]? = nil,
        nextToken: String? = nil
    )
    {
        self.domainControllers = domainControllers
        self.nextToken = nextToken
    }
}

struct DescribeDomainControllersOutputResponseBody: Equatable {
    public let domainControllers: [DomainController]?
    public let nextToken: String?
}

extension DescribeDomainControllersOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case domainControllers = "DomainControllers"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainControllersContainer = try containerValues.decodeIfPresent([DomainController?].self, forKey: .domainControllers)
        var domainControllersDecoded0:[DomainController]? = nil
        if let domainControllersContainer = domainControllersContainer {
            domainControllersDecoded0 = [DomainController]()
            for structure0 in domainControllersContainer {
                if let structure0 = structure0 {
                    domainControllersDecoded0?.append(structure0)
                }
            }
        }
        domainControllers = domainControllersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeEventTopicsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeEventTopicsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEventTopicsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEventTopicsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEventTopicsInput>
    public typealias MOutput = OperationOutput<DescribeEventTopicsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEventTopicsOutputError>
}

extension DescribeEventTopicsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeEventTopicsInput(directoryId: \(String(describing: directoryId)), topicNames: \(String(describing: topicNames)))"}
}

extension DescribeEventTopicsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case directoryId = "DirectoryId"
        case topicNames = "TopicNames"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryId = directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let topicNames = topicNames {
            var topicNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .topicNames)
            for topicnames0 in topicNames {
                try topicNamesContainer.encode(topicnames0)
            }
        }
    }
}

public struct DescribeEventTopicsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeEventTopicsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEventTopicsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEventTopicsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEventTopicsInput>
    public typealias MOutput = OperationOutput<DescribeEventTopicsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEventTopicsOutputError>
}

public struct DescribeEventTopicsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeEventTopicsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEventTopicsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEventTopicsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEventTopicsInput>
    public typealias MOutput = OperationOutput<DescribeEventTopicsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEventTopicsOutputError>
}

/// <p>Describes event topics.</p>
public struct DescribeEventTopicsInput: Equatable {
    /// <p>The Directory ID for which to get the list of associated SNS topics. If this member is null, associations for all Directory IDs are returned.</p>
    public let directoryId: String?
    /// <p>A list of SNS topic names for which to obtain the information. If this member is null, all associations for the specified Directory ID are returned.</p>
    ///          <p>An empty list results in an <code>InvalidParameterException</code> being thrown.</p>
    public let topicNames: [String]?

    public init (
        directoryId: String? = nil,
        topicNames: [String]? = nil
    )
    {
        self.directoryId = directoryId
        self.topicNames = topicNames
    }
}

struct DescribeEventTopicsInputBody: Equatable {
    public let directoryId: String?
    public let topicNames: [String]?
}

extension DescribeEventTopicsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case directoryId = "DirectoryId"
        case topicNames = "TopicNames"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let topicNamesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .topicNames)
        var topicNamesDecoded0:[String]? = nil
        if let topicNamesContainer = topicNamesContainer {
            topicNamesDecoded0 = [String]()
            for string0 in topicNamesContainer {
                if let string0 = string0 {
                    topicNamesDecoded0?.append(string0)
                }
            }
        }
        topicNames = topicNamesDecoded0
    }
}

extension DescribeEventTopicsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeEventTopicsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityDoesNotExistException" : self = .entityDoesNotExistException(try EntityDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeEventTopicsOutputError: Equatable {
    case clientException(ClientException)
    case entityDoesNotExistException(EntityDoesNotExistException)
    case invalidParameterException(InvalidParameterException)
    case serviceException(ServiceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeEventTopicsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeEventTopicsOutputResponse(eventTopics: \(String(describing: eventTopics)))"}
}

extension DescribeEventTopicsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeEventTopicsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.eventTopics = output.eventTopics
        } else {
            self.eventTopics = nil
        }
    }
}

/// <p>The result of a DescribeEventTopic request.</p>
public struct DescribeEventTopicsOutputResponse: Equatable {
    /// <p>A list of SNS topic names that receive status messages from the specified Directory ID.</p>
    public let eventTopics: [EventTopic]?

    public init (
        eventTopics: [EventTopic]? = nil
    )
    {
        self.eventTopics = eventTopics
    }
}

struct DescribeEventTopicsOutputResponseBody: Equatable {
    public let eventTopics: [EventTopic]?
}

extension DescribeEventTopicsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case eventTopics = "EventTopics"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventTopicsContainer = try containerValues.decodeIfPresent([EventTopic?].self, forKey: .eventTopics)
        var eventTopicsDecoded0:[EventTopic]? = nil
        if let eventTopicsContainer = eventTopicsContainer {
            eventTopicsDecoded0 = [EventTopic]()
            for structure0 in eventTopicsContainer {
                if let structure0 = structure0 {
                    eventTopicsDecoded0?.append(structure0)
                }
            }
        }
        eventTopics = eventTopicsDecoded0
    }
}

public struct DescribeLDAPSSettingsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeLDAPSSettingsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeLDAPSSettingsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeLDAPSSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeLDAPSSettingsInput>
    public typealias MOutput = OperationOutput<DescribeLDAPSSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeLDAPSSettingsOutputError>
}

extension DescribeLDAPSSettingsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeLDAPSSettingsInput(directoryId: \(String(describing: directoryId)), limit: \(String(describing: limit)), nextToken: \(String(describing: nextToken)), type: \(String(describing: type)))"}
}

extension DescribeLDAPSSettingsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case directoryId = "DirectoryId"
        case limit = "Limit"
        case nextToken = "NextToken"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryId = directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let limit = limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

public struct DescribeLDAPSSettingsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeLDAPSSettingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeLDAPSSettingsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeLDAPSSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeLDAPSSettingsInput>
    public typealias MOutput = OperationOutput<DescribeLDAPSSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeLDAPSSettingsOutputError>
}

public struct DescribeLDAPSSettingsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeLDAPSSettingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeLDAPSSettingsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeLDAPSSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeLDAPSSettingsInput>
    public typealias MOutput = OperationOutput<DescribeLDAPSSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeLDAPSSettingsOutputError>
}

public struct DescribeLDAPSSettingsInput: Equatable {
    /// <p>The identifier of the directory.</p>
    public let directoryId: String?
    /// <p>Specifies the number of items that should be displayed on one page.</p>
    public let limit: Int?
    /// <p>The type of next token used for pagination.</p>
    public let nextToken: String?
    /// <p>The type of LDAP security to enable. Currently only the value <code>Client</code> is
    ///       supported.</p>
    public let type: LDAPSType?

    public init (
        directoryId: String? = nil,
        limit: Int? = nil,
        nextToken: String? = nil,
        type: LDAPSType? = nil
    )
    {
        self.directoryId = directoryId
        self.limit = limit
        self.nextToken = nextToken
        self.type = type
    }
}

struct DescribeLDAPSSettingsInputBody: Equatable {
    public let directoryId: String?
    public let type: LDAPSType?
    public let nextToken: String?
    public let limit: Int?
}

extension DescribeLDAPSSettingsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case directoryId = "DirectoryId"
        case limit = "Limit"
        case nextToken = "NextToken"
        case type = "Type"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let typeDecoded = try containerValues.decodeIfPresent(LDAPSType.self, forKey: .type)
        type = typeDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .limit)
        limit = limitDecoded
    }
}

extension DescribeLDAPSSettingsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeLDAPSSettingsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryDoesNotExistException" : self = .directoryDoesNotExistException(try DirectoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeLDAPSSettingsOutputError: Equatable {
    case clientException(ClientException)
    case directoryDoesNotExistException(DirectoryDoesNotExistException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterException(InvalidParameterException)
    case serviceException(ServiceException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeLDAPSSettingsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeLDAPSSettingsOutputResponse(lDAPSSettingsInfo: \(String(describing: lDAPSSettingsInfo)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeLDAPSSettingsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeLDAPSSettingsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.lDAPSSettingsInfo = output.lDAPSSettingsInfo
            self.nextToken = output.nextToken
        } else {
            self.lDAPSSettingsInfo = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeLDAPSSettingsOutputResponse: Equatable {
    /// <p>Information about LDAP security for the specified directory, including status of
    ///       enablement, state last updated date time, and the reason for the state.</p>
    public let lDAPSSettingsInfo: [LDAPSSettingInfo]?
    /// <p>The next token used to retrieve the LDAPS settings if the number of setting types exceeds
    ///       page limit and there is another page.</p>
    public let nextToken: String?

    public init (
        lDAPSSettingsInfo: [LDAPSSettingInfo]? = nil,
        nextToken: String? = nil
    )
    {
        self.lDAPSSettingsInfo = lDAPSSettingsInfo
        self.nextToken = nextToken
    }
}

struct DescribeLDAPSSettingsOutputResponseBody: Equatable {
    public let lDAPSSettingsInfo: [LDAPSSettingInfo]?
    public let nextToken: String?
}

extension DescribeLDAPSSettingsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case lDAPSSettingsInfo = "LDAPSSettingsInfo"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lDAPSSettingsInfoContainer = try containerValues.decodeIfPresent([LDAPSSettingInfo?].self, forKey: .lDAPSSettingsInfo)
        var lDAPSSettingsInfoDecoded0:[LDAPSSettingInfo]? = nil
        if let lDAPSSettingsInfoContainer = lDAPSSettingsInfoContainer {
            lDAPSSettingsInfoDecoded0 = [LDAPSSettingInfo]()
            for structure0 in lDAPSSettingsInfoContainer {
                if let structure0 = structure0 {
                    lDAPSSettingsInfoDecoded0?.append(structure0)
                }
            }
        }
        lDAPSSettingsInfo = lDAPSSettingsInfoDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeRegionsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeRegionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeRegionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeRegionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeRegionsInput>
    public typealias MOutput = OperationOutput<DescribeRegionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeRegionsOutputError>
}

extension DescribeRegionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeRegionsInput(directoryId: \(String(describing: directoryId)), nextToken: \(String(describing: nextToken)), regionName: \(String(describing: regionName)))"}
}

extension DescribeRegionsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case directoryId = "DirectoryId"
        case nextToken = "NextToken"
        case regionName = "RegionName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryId = directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let regionName = regionName {
            try encodeContainer.encode(regionName, forKey: .regionName)
        }
    }
}

public struct DescribeRegionsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeRegionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeRegionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeRegionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeRegionsInput>
    public typealias MOutput = OperationOutput<DescribeRegionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeRegionsOutputError>
}

public struct DescribeRegionsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeRegionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeRegionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeRegionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeRegionsInput>
    public typealias MOutput = OperationOutput<DescribeRegionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeRegionsOutputError>
}

public struct DescribeRegionsInput: Equatable {
    /// <p>The identifier of the directory.</p>
    public let directoryId: String?
    /// <p>The <code>DescribeRegionsResult.NextToken</code> value from a previous call to <a>DescribeRegions</a>. Pass null if this is the first call.</p>
    public let nextToken: String?
    /// <p>The name of the Region. For example, <code>us-east-1</code>.</p>
    public let regionName: String?

    public init (
        directoryId: String? = nil,
        nextToken: String? = nil,
        regionName: String? = nil
    )
    {
        self.directoryId = directoryId
        self.nextToken = nextToken
        self.regionName = regionName
    }
}

struct DescribeRegionsInputBody: Equatable {
    public let directoryId: String?
    public let regionName: String?
    public let nextToken: String?
}

extension DescribeRegionsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case directoryId = "DirectoryId"
        case nextToken = "NextToken"
        case regionName = "RegionName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let regionNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .regionName)
        regionName = regionNameDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeRegionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeRegionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryDoesNotExistException" : self = .directoryDoesNotExistException(try DirectoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeRegionsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case clientException(ClientException)
    case directoryDoesNotExistException(DirectoryDoesNotExistException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterException(InvalidParameterException)
    case serviceException(ServiceException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeRegionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeRegionsOutputResponse(nextToken: \(String(describing: nextToken)), regionsDescription: \(String(describing: regionsDescription)))"}
}

extension DescribeRegionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeRegionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.regionsDescription = output.regionsDescription
        } else {
            self.nextToken = nil
            self.regionsDescription = nil
        }
    }
}

public struct DescribeRegionsOutputResponse: Equatable {
    /// <p>If not null, more results are available. Pass this value for the <code>NextToken</code>
    ///       parameter in a subsequent call to <a>DescribeRegions</a> to retrieve the next set
    ///       of items.</p>
    public let nextToken: String?
    /// <p>List of Region information related to the directory for each replicated Region.</p>
    public let regionsDescription: [RegionDescription]?

    public init (
        nextToken: String? = nil,
        regionsDescription: [RegionDescription]? = nil
    )
    {
        self.nextToken = nextToken
        self.regionsDescription = regionsDescription
    }
}

struct DescribeRegionsOutputResponseBody: Equatable {
    public let regionsDescription: [RegionDescription]?
    public let nextToken: String?
}

extension DescribeRegionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case regionsDescription = "RegionsDescription"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let regionsDescriptionContainer = try containerValues.decodeIfPresent([RegionDescription?].self, forKey: .regionsDescription)
        var regionsDescriptionDecoded0:[RegionDescription]? = nil
        if let regionsDescriptionContainer = regionsDescriptionContainer {
            regionsDescriptionDecoded0 = [RegionDescription]()
            for structure0 in regionsDescriptionContainer {
                if let structure0 = structure0 {
                    regionsDescriptionDecoded0?.append(structure0)
                }
            }
        }
        regionsDescription = regionsDescriptionDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeSharedDirectoriesInputBodyMiddleware: Middleware {
    public let id: String = "DescribeSharedDirectoriesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeSharedDirectoriesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeSharedDirectoriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeSharedDirectoriesInput>
    public typealias MOutput = OperationOutput<DescribeSharedDirectoriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeSharedDirectoriesOutputError>
}

extension DescribeSharedDirectoriesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeSharedDirectoriesInput(limit: \(String(describing: limit)), nextToken: \(String(describing: nextToken)), ownerDirectoryId: \(String(describing: ownerDirectoryId)), sharedDirectoryIds: \(String(describing: sharedDirectoryIds)))"}
}

extension DescribeSharedDirectoriesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case limit = "Limit"
        case nextToken = "NextToken"
        case ownerDirectoryId = "OwnerDirectoryId"
        case sharedDirectoryIds = "SharedDirectoryIds"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let limit = limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let ownerDirectoryId = ownerDirectoryId {
            try encodeContainer.encode(ownerDirectoryId, forKey: .ownerDirectoryId)
        }
        if let sharedDirectoryIds = sharedDirectoryIds {
            var sharedDirectoryIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sharedDirectoryIds)
            for directoryids0 in sharedDirectoryIds {
                try sharedDirectoryIdsContainer.encode(directoryids0)
            }
        }
    }
}

public struct DescribeSharedDirectoriesInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeSharedDirectoriesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeSharedDirectoriesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeSharedDirectoriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeSharedDirectoriesInput>
    public typealias MOutput = OperationOutput<DescribeSharedDirectoriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeSharedDirectoriesOutputError>
}

public struct DescribeSharedDirectoriesInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeSharedDirectoriesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeSharedDirectoriesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeSharedDirectoriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeSharedDirectoriesInput>
    public typealias MOutput = OperationOutput<DescribeSharedDirectoriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeSharedDirectoriesOutputError>
}

public struct DescribeSharedDirectoriesInput: Equatable {
    /// <p>The number of shared directories to return in the response object.</p>
    public let limit: Int?
    /// <p>The <code>DescribeSharedDirectoriesResult.NextToken</code> value from a previous call to
    ///         <a>DescribeSharedDirectories</a>. Pass null if this is the first call. </p>
    public let nextToken: String?
    /// <p>Returns the identifier of the directory in the directory owner account. </p>
    public let ownerDirectoryId: String?
    /// <p>A list of identifiers of all shared directories in your account. </p>
    public let sharedDirectoryIds: [String]?

    public init (
        limit: Int? = nil,
        nextToken: String? = nil,
        ownerDirectoryId: String? = nil,
        sharedDirectoryIds: [String]? = nil
    )
    {
        self.limit = limit
        self.nextToken = nextToken
        self.ownerDirectoryId = ownerDirectoryId
        self.sharedDirectoryIds = sharedDirectoryIds
    }
}

struct DescribeSharedDirectoriesInputBody: Equatable {
    public let ownerDirectoryId: String?
    public let sharedDirectoryIds: [String]?
    public let nextToken: String?
    public let limit: Int?
}

extension DescribeSharedDirectoriesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case limit = "Limit"
        case nextToken = "NextToken"
        case ownerDirectoryId = "OwnerDirectoryId"
        case sharedDirectoryIds = "SharedDirectoryIds"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ownerDirectoryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ownerDirectoryId)
        ownerDirectoryId = ownerDirectoryIdDecoded
        let sharedDirectoryIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .sharedDirectoryIds)
        var sharedDirectoryIdsDecoded0:[String]? = nil
        if let sharedDirectoryIdsContainer = sharedDirectoryIdsContainer {
            sharedDirectoryIdsDecoded0 = [String]()
            for string0 in sharedDirectoryIdsContainer {
                if let string0 = string0 {
                    sharedDirectoryIdsDecoded0?.append(string0)
                }
            }
        }
        sharedDirectoryIds = sharedDirectoryIdsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .limit)
        limit = limitDecoded
    }
}

extension DescribeSharedDirectoriesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeSharedDirectoriesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityDoesNotExistException" : self = .entityDoesNotExistException(try EntityDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeSharedDirectoriesOutputError: Equatable {
    case clientException(ClientException)
    case entityDoesNotExistException(EntityDoesNotExistException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterException(InvalidParameterException)
    case serviceException(ServiceException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeSharedDirectoriesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeSharedDirectoriesOutputResponse(nextToken: \(String(describing: nextToken)), sharedDirectories: \(String(describing: sharedDirectories)))"}
}

extension DescribeSharedDirectoriesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeSharedDirectoriesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.sharedDirectories = output.sharedDirectories
        } else {
            self.nextToken = nil
            self.sharedDirectories = nil
        }
    }
}

public struct DescribeSharedDirectoriesOutputResponse: Equatable {
    /// <p>If not null, token that indicates that more results are available. Pass this value for the
    ///         <code>NextToken</code> parameter in a subsequent call to <a>DescribeSharedDirectories</a> to retrieve the next set of items.</p>
    public let nextToken: String?
    /// <p>A list of all shared directories in your account.</p>
    public let sharedDirectories: [SharedDirectory]?

    public init (
        nextToken: String? = nil,
        sharedDirectories: [SharedDirectory]? = nil
    )
    {
        self.nextToken = nextToken
        self.sharedDirectories = sharedDirectories
    }
}

struct DescribeSharedDirectoriesOutputResponseBody: Equatable {
    public let sharedDirectories: [SharedDirectory]?
    public let nextToken: String?
}

extension DescribeSharedDirectoriesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case sharedDirectories = "SharedDirectories"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sharedDirectoriesContainer = try containerValues.decodeIfPresent([SharedDirectory?].self, forKey: .sharedDirectories)
        var sharedDirectoriesDecoded0:[SharedDirectory]? = nil
        if let sharedDirectoriesContainer = sharedDirectoriesContainer {
            sharedDirectoriesDecoded0 = [SharedDirectory]()
            for structure0 in sharedDirectoriesContainer {
                if let structure0 = structure0 {
                    sharedDirectoriesDecoded0?.append(structure0)
                }
            }
        }
        sharedDirectories = sharedDirectoriesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeSnapshotsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeSnapshotsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeSnapshotsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeSnapshotsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeSnapshotsInput>
    public typealias MOutput = OperationOutput<DescribeSnapshotsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeSnapshotsOutputError>
}

extension DescribeSnapshotsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeSnapshotsInput(directoryId: \(String(describing: directoryId)), limit: \(String(describing: limit)), nextToken: \(String(describing: nextToken)), snapshotIds: \(String(describing: snapshotIds)))"}
}

extension DescribeSnapshotsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case directoryId = "DirectoryId"
        case limit = "Limit"
        case nextToken = "NextToken"
        case snapshotIds = "SnapshotIds"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryId = directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let limit = limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let snapshotIds = snapshotIds {
            var snapshotIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .snapshotIds)
            for snapshotids0 in snapshotIds {
                try snapshotIdsContainer.encode(snapshotids0)
            }
        }
    }
}

public struct DescribeSnapshotsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeSnapshotsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeSnapshotsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeSnapshotsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeSnapshotsInput>
    public typealias MOutput = OperationOutput<DescribeSnapshotsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeSnapshotsOutputError>
}

public struct DescribeSnapshotsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeSnapshotsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeSnapshotsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeSnapshotsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeSnapshotsInput>
    public typealias MOutput = OperationOutput<DescribeSnapshotsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeSnapshotsOutputError>
}

/// <p>Contains the inputs for the <a>DescribeSnapshots</a> operation.</p>
public struct DescribeSnapshotsInput: Equatable {
    /// <p>The identifier of the directory for which to retrieve snapshot information.</p>
    public let directoryId: String?
    /// <p>The maximum number of objects to return.</p>
    public let limit: Int?
    /// <p>The <i>DescribeSnapshotsResult.NextToken</i> value from a previous call to
    ///             <a>DescribeSnapshots</a>. Pass null if this is the first call.</p>
    public let nextToken: String?
    /// <p>A list of identifiers of the snapshots to obtain the information for. If this member is
    ///          null or empty, all snapshots are returned using the <i>Limit</i> and <i>NextToken</i>
    ///          members.</p>
    public let snapshotIds: [String]?

    public init (
        directoryId: String? = nil,
        limit: Int? = nil,
        nextToken: String? = nil,
        snapshotIds: [String]? = nil
    )
    {
        self.directoryId = directoryId
        self.limit = limit
        self.nextToken = nextToken
        self.snapshotIds = snapshotIds
    }
}

struct DescribeSnapshotsInputBody: Equatable {
    public let directoryId: String?
    public let snapshotIds: [String]?
    public let nextToken: String?
    public let limit: Int?
}

extension DescribeSnapshotsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case directoryId = "DirectoryId"
        case limit = "Limit"
        case nextToken = "NextToken"
        case snapshotIds = "SnapshotIds"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let snapshotIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .snapshotIds)
        var snapshotIdsDecoded0:[String]? = nil
        if let snapshotIdsContainer = snapshotIdsContainer {
            snapshotIdsDecoded0 = [String]()
            for string0 in snapshotIdsContainer {
                if let string0 = string0 {
                    snapshotIdsDecoded0?.append(string0)
                }
            }
        }
        snapshotIds = snapshotIdsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .limit)
        limit = limitDecoded
    }
}

extension DescribeSnapshotsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeSnapshotsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityDoesNotExistException" : self = .entityDoesNotExistException(try EntityDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeSnapshotsOutputError: Equatable {
    case clientException(ClientException)
    case entityDoesNotExistException(EntityDoesNotExistException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterException(InvalidParameterException)
    case serviceException(ServiceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeSnapshotsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeSnapshotsOutputResponse(nextToken: \(String(describing: nextToken)), snapshots: \(String(describing: snapshots)))"}
}

extension DescribeSnapshotsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeSnapshotsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.snapshots = output.snapshots
        } else {
            self.nextToken = nil
            self.snapshots = nil
        }
    }
}

/// <p>Contains the results of the <a>DescribeSnapshots</a> operation.</p>
public struct DescribeSnapshotsOutputResponse: Equatable {
    /// <p>If not null, more results are available. Pass this value in the <i>NextToken</i> member of
    ///          a subsequent call to <a>DescribeSnapshots</a>.</p>
    public let nextToken: String?
    /// <p>The list of <a>Snapshot</a> objects that were retrieved.</p>
    ///          <p>It is possible that this list contains less than the number of items specified in the
    ///             <i>Limit</i> member of the request. This occurs if there are less than the requested
    ///          number of items left to retrieve, or if the limitations of the operation have been
    ///          exceeded.</p>
    public let snapshots: [Snapshot]?

    public init (
        nextToken: String? = nil,
        snapshots: [Snapshot]? = nil
    )
    {
        self.nextToken = nextToken
        self.snapshots = snapshots
    }
}

struct DescribeSnapshotsOutputResponseBody: Equatable {
    public let snapshots: [Snapshot]?
    public let nextToken: String?
}

extension DescribeSnapshotsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case snapshots = "Snapshots"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snapshotsContainer = try containerValues.decodeIfPresent([Snapshot?].self, forKey: .snapshots)
        var snapshotsDecoded0:[Snapshot]? = nil
        if let snapshotsContainer = snapshotsContainer {
            snapshotsDecoded0 = [Snapshot]()
            for structure0 in snapshotsContainer {
                if let structure0 = structure0 {
                    snapshotsDecoded0?.append(structure0)
                }
            }
        }
        snapshots = snapshotsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeTrustsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeTrustsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeTrustsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeTrustsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeTrustsInput>
    public typealias MOutput = OperationOutput<DescribeTrustsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeTrustsOutputError>
}

extension DescribeTrustsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeTrustsInput(directoryId: \(String(describing: directoryId)), limit: \(String(describing: limit)), nextToken: \(String(describing: nextToken)), trustIds: \(String(describing: trustIds)))"}
}

extension DescribeTrustsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case directoryId = "DirectoryId"
        case limit = "Limit"
        case nextToken = "NextToken"
        case trustIds = "TrustIds"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryId = directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let limit = limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let trustIds = trustIds {
            var trustIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .trustIds)
            for trustids0 in trustIds {
                try trustIdsContainer.encode(trustids0)
            }
        }
    }
}

public struct DescribeTrustsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeTrustsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeTrustsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeTrustsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeTrustsInput>
    public typealias MOutput = OperationOutput<DescribeTrustsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeTrustsOutputError>
}

public struct DescribeTrustsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeTrustsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeTrustsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeTrustsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeTrustsInput>
    public typealias MOutput = OperationOutput<DescribeTrustsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeTrustsOutputError>
}

/// <p>Describes the trust relationships for a particular AWS Managed Microsoft AD directory. If no input parameters are are provided, such as directory ID or trust ID, this request describes all the trust relationships.</p>
public struct DescribeTrustsInput: Equatable {
    /// <p>The Directory ID of the AWS directory that is a part of the requested trust relationship.</p>
    public let directoryId: String?
    /// <p>The maximum number of objects to return.</p>
    public let limit: Int?
    /// <p>The <i>DescribeTrustsResult.NextToken</i> value from a previous call to
    ///       <a>DescribeTrusts</a>. Pass null if this is the first call.</p>
    public let nextToken: String?
    /// <p>A list of identifiers of the trust relationships for which to obtain the information. If this member is null, all trust relationships that belong to the current account are returned.</p>
    ///          <p>An empty list results in an <code>InvalidParameterException</code> being thrown.</p>
    public let trustIds: [String]?

    public init (
        directoryId: String? = nil,
        limit: Int? = nil,
        nextToken: String? = nil,
        trustIds: [String]? = nil
    )
    {
        self.directoryId = directoryId
        self.limit = limit
        self.nextToken = nextToken
        self.trustIds = trustIds
    }
}

struct DescribeTrustsInputBody: Equatable {
    public let directoryId: String?
    public let trustIds: [String]?
    public let nextToken: String?
    public let limit: Int?
}

extension DescribeTrustsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case directoryId = "DirectoryId"
        case limit = "Limit"
        case nextToken = "NextToken"
        case trustIds = "TrustIds"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let trustIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .trustIds)
        var trustIdsDecoded0:[String]? = nil
        if let trustIdsContainer = trustIdsContainer {
            trustIdsDecoded0 = [String]()
            for string0 in trustIdsContainer {
                if let string0 = string0 {
                    trustIdsDecoded0?.append(string0)
                }
            }
        }
        trustIds = trustIdsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .limit)
        limit = limitDecoded
    }
}

extension DescribeTrustsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeTrustsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityDoesNotExistException" : self = .entityDoesNotExistException(try EntityDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeTrustsOutputError: Equatable {
    case clientException(ClientException)
    case entityDoesNotExistException(EntityDoesNotExistException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterException(InvalidParameterException)
    case serviceException(ServiceException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeTrustsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeTrustsOutputResponse(nextToken: \(String(describing: nextToken)), trusts: \(String(describing: trusts)))"}
}

extension DescribeTrustsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeTrustsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.trusts = output.trusts
        } else {
            self.nextToken = nil
            self.trusts = nil
        }
    }
}

/// <p>The result of a DescribeTrust request.</p>
public struct DescribeTrustsOutputResponse: Equatable {
    /// <p>If not null, more results are available. Pass this value for the <i>NextToken</i> parameter
    ///       in a subsequent call to <a>DescribeTrusts</a> to retrieve the next set of items.</p>
    public let nextToken: String?
    /// <p>The list of Trust objects that were retrieved.</p>
    ///          <p>It is possible that this list contains less than the number of items specified in the
    ///          <i>Limit</i> member of the request. This occurs if there are less than the requested
    ///          number of items left to retrieve, or if the limitations of the operation have been
    ///          exceeded.</p>
    public let trusts: [Trust]?

    public init (
        nextToken: String? = nil,
        trusts: [Trust]? = nil
    )
    {
        self.nextToken = nextToken
        self.trusts = trusts
    }
}

struct DescribeTrustsOutputResponseBody: Equatable {
    public let trusts: [Trust]?
    public let nextToken: String?
}

extension DescribeTrustsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case trusts = "Trusts"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trustsContainer = try containerValues.decodeIfPresent([Trust?].self, forKey: .trusts)
        var trustsDecoded0:[Trust]? = nil
        if let trustsContainer = trustsContainer {
            trustsDecoded0 = [Trust]()
            for structure0 in trustsContainer {
                if let structure0 = structure0 {
                    trustsDecoded0?.append(structure0)
                }
            }
        }
        trusts = trustsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DirectoryAlreadyInRegionException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DirectoryAlreadyInRegionException(message: \(String(describing: message)), requestId: \(String(describing: requestId)))"}
}

extension DirectoryAlreadyInRegionException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DirectoryAlreadyInRegionExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.requestId = output.requestId
        } else {
            self.message = nil
            self.requestId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The Region you specified is the same Region where the AWS Managed Microsoft AD directory
///       was created. Specify a different Region and try again.</p>
public struct DirectoryAlreadyInRegionException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The descriptive message for the exception.</p>
    public var message: String?
    /// <p>The AWS request identifier.</p>
    public var requestId: String?

    public init (
        message: String? = nil,
        requestId: String? = nil
    )
    {
        self.message = message
        self.requestId = requestId
    }
}

struct DirectoryAlreadyInRegionExceptionBody: Equatable {
    public let message: String?
    public let requestId: String?
}

extension DirectoryAlreadyInRegionExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case requestId = "RequestId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension DirectoryAlreadySharedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DirectoryAlreadySharedException(message: \(String(describing: message)), requestId: \(String(describing: requestId)))"}
}

extension DirectoryAlreadySharedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DirectoryAlreadySharedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.requestId = output.requestId
        } else {
            self.message = nil
            self.requestId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified directory has already been shared with this AWS account.</p>
public struct DirectoryAlreadySharedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The descriptive message for the exception.</p>
    public var message: String?
    /// <p>The AWS request identifier.</p>
    public var requestId: String?

    public init (
        message: String? = nil,
        requestId: String? = nil
    )
    {
        self.message = message
        self.requestId = requestId
    }
}

struct DirectoryAlreadySharedExceptionBody: Equatable {
    public let message: String?
    public let requestId: String?
}

extension DirectoryAlreadySharedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case requestId = "RequestId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension DirectoryConnectSettings: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case customerDnsIps = "CustomerDnsIps"
        case customerUserName = "CustomerUserName"
        case subnetIds = "SubnetIds"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customerDnsIps = customerDnsIps {
            var customerDnsIpsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .customerDnsIps)
            for dnsipaddrs0 in customerDnsIps {
                try customerDnsIpsContainer.encode(dnsipaddrs0)
            }
        }
        if let customerUserName = customerUserName {
            try encodeContainer.encode(customerUserName, forKey: .customerUserName)
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for subnetids0 in subnetIds {
                try subnetIdsContainer.encode(subnetids0)
            }
        }
        if let vpcId = vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpcIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let subnetIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let customerDnsIpsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .customerDnsIps)
        var customerDnsIpsDecoded0:[String]? = nil
        if let customerDnsIpsContainer = customerDnsIpsContainer {
            customerDnsIpsDecoded0 = [String]()
            for string0 in customerDnsIpsContainer {
                if let string0 = string0 {
                    customerDnsIpsDecoded0?.append(string0)
                }
            }
        }
        customerDnsIps = customerDnsIpsDecoded0
        let customerUserNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .customerUserName)
        customerUserName = customerUserNameDecoded
    }
}

extension DirectoryConnectSettings: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DirectoryConnectSettings(customerDnsIps: \(String(describing: customerDnsIps)), customerUserName: \(String(describing: customerUserName)), subnetIds: \(String(describing: subnetIds)), vpcId: \(String(describing: vpcId)))"}
}

/// <p>Contains information for the <a>ConnectDirectory</a> operation when an AD
///       Connector directory is being created.</p>
public struct DirectoryConnectSettings: Equatable {
    /// <p>A list of one or more IP addresses of DNS servers or domain controllers in the on-premises
    ///       directory.</p>
    public let customerDnsIps: [String]?
    /// <p>The user name of an account in the on-premises directory that is used to connect to the
    ///       directory. This account must have the following permissions:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Read users and groups</p>
    ///             </li>
    ///             <li>
    ///                <p>Create computer objects</p>
    ///             </li>
    ///             <li>
    ///                <p>Join computers to the domain</p>
    ///             </li>
    ///          </ul>
    public let customerUserName: String?
    /// <p>A list of subnet identifiers in the VPC in which the AD Connector is created.</p>
    public let subnetIds: [String]?
    /// <p>The identifier of the VPC in which the AD Connector is created.</p>
    public let vpcId: String?

    public init (
        customerDnsIps: [String]? = nil,
        customerUserName: String? = nil,
        subnetIds: [String]? = nil,
        vpcId: String? = nil
    )
    {
        self.customerDnsIps = customerDnsIps
        self.customerUserName = customerUserName
        self.subnetIds = subnetIds
        self.vpcId = vpcId
    }
}

extension DirectoryConnectSettingsDescription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case availabilityZones = "AvailabilityZones"
        case connectIps = "ConnectIps"
        case customerUserName = "CustomerUserName"
        case securityGroupId = "SecurityGroupId"
        case subnetIds = "SubnetIds"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityZones = availabilityZones {
            var availabilityZonesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .availabilityZones)
            for availabilityzones0 in availabilityZones {
                try availabilityZonesContainer.encode(availabilityzones0)
            }
        }
        if let connectIps = connectIps {
            var connectIpsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .connectIps)
            for ipaddrs0 in connectIps {
                try connectIpsContainer.encode(ipaddrs0)
            }
        }
        if let customerUserName = customerUserName {
            try encodeContainer.encode(customerUserName, forKey: .customerUserName)
        }
        if let securityGroupId = securityGroupId {
            try encodeContainer.encode(securityGroupId, forKey: .securityGroupId)
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for subnetids0 in subnetIds {
                try subnetIdsContainer.encode(subnetids0)
            }
        }
        if let vpcId = vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpcIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let subnetIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let customerUserNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .customerUserName)
        customerUserName = customerUserNameDecoded
        let securityGroupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .securityGroupId)
        securityGroupId = securityGroupIdDecoded
        let availabilityZonesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .availabilityZones)
        var availabilityZonesDecoded0:[String]? = nil
        if let availabilityZonesContainer = availabilityZonesContainer {
            availabilityZonesDecoded0 = [String]()
            for string0 in availabilityZonesContainer {
                if let string0 = string0 {
                    availabilityZonesDecoded0?.append(string0)
                }
            }
        }
        availabilityZones = availabilityZonesDecoded0
        let connectIpsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .connectIps)
        var connectIpsDecoded0:[String]? = nil
        if let connectIpsContainer = connectIpsContainer {
            connectIpsDecoded0 = [String]()
            for string0 in connectIpsContainer {
                if let string0 = string0 {
                    connectIpsDecoded0?.append(string0)
                }
            }
        }
        connectIps = connectIpsDecoded0
    }
}

extension DirectoryConnectSettingsDescription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DirectoryConnectSettingsDescription(availabilityZones: \(String(describing: availabilityZones)), connectIps: \(String(describing: connectIps)), customerUserName: \(String(describing: customerUserName)), securityGroupId: \(String(describing: securityGroupId)), subnetIds: \(String(describing: subnetIds)), vpcId: \(String(describing: vpcId)))"}
}

/// <p>Contains information about an AD Connector directory.</p>
public struct DirectoryConnectSettingsDescription: Equatable {
    /// <p>A list of the Availability Zones that the directory is in.</p>
    public let availabilityZones: [String]?
    /// <p>The IP addresses of the AD Connector servers.</p>
    public let connectIps: [String]?
    /// <p>The user name of the service account in the on-premises directory.</p>
    public let customerUserName: String?
    /// <p>The security group identifier for the AD Connector directory.</p>
    public let securityGroupId: String?
    /// <p>A list of subnet identifiers in the VPC that the AD Connector is in.</p>
    public let subnetIds: [String]?
    /// <p>The identifier of the VPC that the AD Connector is in.</p>
    public let vpcId: String?

    public init (
        availabilityZones: [String]? = nil,
        connectIps: [String]? = nil,
        customerUserName: String? = nil,
        securityGroupId: String? = nil,
        subnetIds: [String]? = nil,
        vpcId: String? = nil
    )
    {
        self.availabilityZones = availabilityZones
        self.connectIps = connectIps
        self.customerUserName = customerUserName
        self.securityGroupId = securityGroupId
        self.subnetIds = subnetIds
        self.vpcId = vpcId
    }
}

extension DirectoryDescription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accessUrl = "AccessUrl"
        case alias = "Alias"
        case connectSettings = "ConnectSettings"
        case description = "Description"
        case desiredNumberOfDomainControllers = "DesiredNumberOfDomainControllers"
        case directoryId = "DirectoryId"
        case dnsIpAddrs = "DnsIpAddrs"
        case edition = "Edition"
        case launchTime = "LaunchTime"
        case name = "Name"
        case ownerDirectoryDescription = "OwnerDirectoryDescription"
        case radiusSettings = "RadiusSettings"
        case radiusStatus = "RadiusStatus"
        case regionsInfo = "RegionsInfo"
        case shareMethod = "ShareMethod"
        case shareNotes = "ShareNotes"
        case shareStatus = "ShareStatus"
        case shortName = "ShortName"
        case size = "Size"
        case ssoEnabled = "SsoEnabled"
        case stage = "Stage"
        case stageLastUpdatedDateTime = "StageLastUpdatedDateTime"
        case stageReason = "StageReason"
        case type = "Type"
        case vpcSettings = "VpcSettings"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessUrl = accessUrl {
            try encodeContainer.encode(accessUrl, forKey: .accessUrl)
        }
        if let alias = alias {
            try encodeContainer.encode(alias, forKey: .alias)
        }
        if let connectSettings = connectSettings {
            try encodeContainer.encode(connectSettings, forKey: .connectSettings)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if desiredNumberOfDomainControllers != 0 {
            try encodeContainer.encode(desiredNumberOfDomainControllers, forKey: .desiredNumberOfDomainControllers)
        }
        if let directoryId = directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let dnsIpAddrs = dnsIpAddrs {
            var dnsIpAddrsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dnsIpAddrs)
            for dnsipaddrs0 in dnsIpAddrs {
                try dnsIpAddrsContainer.encode(dnsipaddrs0)
            }
        }
        if let edition = edition {
            try encodeContainer.encode(edition.rawValue, forKey: .edition)
        }
        if let launchTime = launchTime {
            try encodeContainer.encode(launchTime.timeIntervalSince1970, forKey: .launchTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let ownerDirectoryDescription = ownerDirectoryDescription {
            try encodeContainer.encode(ownerDirectoryDescription, forKey: .ownerDirectoryDescription)
        }
        if let radiusSettings = radiusSettings {
            try encodeContainer.encode(radiusSettings, forKey: .radiusSettings)
        }
        if let radiusStatus = radiusStatus {
            try encodeContainer.encode(radiusStatus.rawValue, forKey: .radiusStatus)
        }
        if let regionsInfo = regionsInfo {
            try encodeContainer.encode(regionsInfo, forKey: .regionsInfo)
        }
        if let shareMethod = shareMethod {
            try encodeContainer.encode(shareMethod.rawValue, forKey: .shareMethod)
        }
        if let shareNotes = shareNotes {
            try encodeContainer.encode(shareNotes, forKey: .shareNotes)
        }
        if let shareStatus = shareStatus {
            try encodeContainer.encode(shareStatus.rawValue, forKey: .shareStatus)
        }
        if let shortName = shortName {
            try encodeContainer.encode(shortName, forKey: .shortName)
        }
        if let size = size {
            try encodeContainer.encode(size.rawValue, forKey: .size)
        }
        if ssoEnabled != false {
            try encodeContainer.encode(ssoEnabled, forKey: .ssoEnabled)
        }
        if let stage = stage {
            try encodeContainer.encode(stage.rawValue, forKey: .stage)
        }
        if let stageLastUpdatedDateTime = stageLastUpdatedDateTime {
            try encodeContainer.encode(stageLastUpdatedDateTime.timeIntervalSince1970, forKey: .stageLastUpdatedDateTime)
        }
        if let stageReason = stageReason {
            try encodeContainer.encode(stageReason, forKey: .stageReason)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let vpcSettings = vpcSettings {
            try encodeContainer.encode(vpcSettings, forKey: .vpcSettings)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let shortNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .shortName)
        shortName = shortNameDecoded
        let sizeDecoded = try containerValues.decodeIfPresent(DirectorySize.self, forKey: .size)
        size = sizeDecoded
        let editionDecoded = try containerValues.decodeIfPresent(DirectoryEdition.self, forKey: .edition)
        edition = editionDecoded
        let aliasDecoded = try containerValues.decodeIfPresent(String.self, forKey: .alias)
        alias = aliasDecoded
        let accessUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accessUrl)
        accessUrl = accessUrlDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let dnsIpAddrsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .dnsIpAddrs)
        var dnsIpAddrsDecoded0:[String]? = nil
        if let dnsIpAddrsContainer = dnsIpAddrsContainer {
            dnsIpAddrsDecoded0 = [String]()
            for string0 in dnsIpAddrsContainer {
                if let string0 = string0 {
                    dnsIpAddrsDecoded0?.append(string0)
                }
            }
        }
        dnsIpAddrs = dnsIpAddrsDecoded0
        let stageDecoded = try containerValues.decodeIfPresent(DirectoryStage.self, forKey: .stage)
        stage = stageDecoded
        let shareStatusDecoded = try containerValues.decodeIfPresent(ShareStatus.self, forKey: .shareStatus)
        shareStatus = shareStatusDecoded
        let shareMethodDecoded = try containerValues.decodeIfPresent(ShareMethod.self, forKey: .shareMethod)
        shareMethod = shareMethodDecoded
        let shareNotesDecoded = try containerValues.decodeIfPresent(String.self, forKey: .shareNotes)
        shareNotes = shareNotesDecoded
        let launchTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .launchTime)
        launchTime = launchTimeDecoded
        let stageLastUpdatedDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .stageLastUpdatedDateTime)
        stageLastUpdatedDateTime = stageLastUpdatedDateTimeDecoded
        let typeDecoded = try containerValues.decodeIfPresent(DirectoryType.self, forKey: .type)
        type = typeDecoded
        let vpcSettingsDecoded = try containerValues.decodeIfPresent(DirectoryVpcSettingsDescription.self, forKey: .vpcSettings)
        vpcSettings = vpcSettingsDecoded
        let connectSettingsDecoded = try containerValues.decodeIfPresent(DirectoryConnectSettingsDescription.self, forKey: .connectSettings)
        connectSettings = connectSettingsDecoded
        let radiusSettingsDecoded = try containerValues.decodeIfPresent(RadiusSettings.self, forKey: .radiusSettings)
        radiusSettings = radiusSettingsDecoded
        let radiusStatusDecoded = try containerValues.decodeIfPresent(RadiusStatus.self, forKey: .radiusStatus)
        radiusStatus = radiusStatusDecoded
        let stageReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stageReason)
        stageReason = stageReasonDecoded
        let ssoEnabledDecoded = try containerValues.decode(Bool.self, forKey: .ssoEnabled)
        ssoEnabled = ssoEnabledDecoded
        let desiredNumberOfDomainControllersDecoded = try containerValues.decode(Int.self, forKey: .desiredNumberOfDomainControllers)
        desiredNumberOfDomainControllers = desiredNumberOfDomainControllersDecoded
        let ownerDirectoryDescriptionDecoded = try containerValues.decodeIfPresent(OwnerDirectoryDescription.self, forKey: .ownerDirectoryDescription)
        ownerDirectoryDescription = ownerDirectoryDescriptionDecoded
        let regionsInfoDecoded = try containerValues.decodeIfPresent(RegionsInfo.self, forKey: .regionsInfo)
        regionsInfo = regionsInfoDecoded
    }
}

extension DirectoryDescription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DirectoryDescription(accessUrl: \(String(describing: accessUrl)), alias: \(String(describing: alias)), connectSettings: \(String(describing: connectSettings)), description: \(String(describing: description)), desiredNumberOfDomainControllers: \(String(describing: desiredNumberOfDomainControllers)), directoryId: \(String(describing: directoryId)), dnsIpAddrs: \(String(describing: dnsIpAddrs)), edition: \(String(describing: edition)), launchTime: \(String(describing: launchTime)), name: \(String(describing: name)), ownerDirectoryDescription: \(String(describing: ownerDirectoryDescription)), radiusSettings: \(String(describing: radiusSettings)), radiusStatus: \(String(describing: radiusStatus)), regionsInfo: \(String(describing: regionsInfo)), shareMethod: \(String(describing: shareMethod)), shareNotes: \(String(describing: shareNotes)), shareStatus: \(String(describing: shareStatus)), shortName: \(String(describing: shortName)), size: \(String(describing: size)), ssoEnabled: \(String(describing: ssoEnabled)), stage: \(String(describing: stage)), stageLastUpdatedDateTime: \(String(describing: stageLastUpdatedDateTime)), stageReason: \(String(describing: stageReason)), type: \(String(describing: type)), vpcSettings: \(String(describing: vpcSettings)))"}
}

/// <p>Contains information about an AWS Directory Service directory.</p>
public struct DirectoryDescription: Equatable {
    /// <p>The access URL for the directory, such as
    ///         <code>http://<alias>.awsapps.com</code>. If no alias has been created for the
    ///       directory, <code><alias></code> is the directory identifier, such as
    ///         <code>d-XXXXXXXXXX</code>.</p>
    public let accessUrl: String?
    /// <p>The alias for the directory. If no alias has been created for the directory, the alias is
    ///       the directory identifier, such as <code>d-XXXXXXXXXX</code>.</p>
    public let alias: String?
    /// <p>A <a>DirectoryConnectSettingsDescription</a> object that contains additional
    ///       information about an AD Connector directory. This member is only present if the directory is
    ///       an AD Connector directory.</p>
    public let connectSettings: DirectoryConnectSettingsDescription?
    /// <p>The description for the directory.</p>
    public let description: String?
    /// <p>The desired number of domain controllers in the directory if the directory is Microsoft AD.</p>
    public let desiredNumberOfDomainControllers: Int
    /// <p>The directory identifier.</p>
    public let directoryId: String?
    /// <p>The IP addresses of the DNS servers for the directory. For a Simple AD or Microsoft AD
    ///       directory, these are the IP addresses of the Simple AD or Microsoft AD directory servers. For
    ///       an AD Connector directory, these are the IP addresses of the DNS servers or domain controllers
    ///       in the on-premises directory to which the AD Connector is connected.</p>
    public let dnsIpAddrs: [String]?
    /// <p>The edition associated with this directory.</p>
    public let edition: DirectoryEdition?
    /// <p>Specifies when the directory was created.</p>
    public let launchTime: Date?
    /// <p>The fully qualified name of the directory.</p>
    public let name: String?
    /// <p>Describes the AWS Managed Microsoft AD directory in the directory owner account.</p>
    public let ownerDirectoryDescription: OwnerDirectoryDescription?
    /// <p>A <a>RadiusSettings</a> object that contains information about the RADIUS
    ///       server configured for this directory.</p>
    public let radiusSettings: RadiusSettings?
    /// <p>The status of the RADIUS MFA server connection.</p>
    public let radiusStatus: RadiusStatus?
    /// <p>Lists the Regions where the directory has replicated.</p>
    public let regionsInfo: RegionsInfo?
    /// <p>The method used when sharing a directory to determine whether the directory should be
    ///       shared within your AWS organization (<code>ORGANIZATIONS</code>) or with any AWS account by
    ///       sending a shared directory request (<code>HANDSHAKE</code>).</p>
    public let shareMethod: ShareMethod?
    /// <p>A directory share request that is sent by the directory owner to the directory consumer.
    ///       The request includes a typed message to help the directory consumer administrator determine
    ///       whether to approve or reject the share invitation.</p>
    public let shareNotes: String?
    /// <p>Current directory status of the shared AWS Managed Microsoft AD directory.</p>
    public let shareStatus: ShareStatus?
    /// <p>The short name of the directory.</p>
    public let shortName: String?
    /// <p>The directory size.</p>
    public let size: DirectorySize?
    /// <p>Indicates if single sign-on is enabled for the directory. For more information, see <a>EnableSso</a> and <a>DisableSso</a>.</p>
    public let ssoEnabled: Bool
    /// <p>The current stage of the directory.</p>
    public let stage: DirectoryStage?
    /// <p>The date and time that the stage was last updated.</p>
    public let stageLastUpdatedDateTime: Date?
    /// <p>Additional information about the directory stage.</p>
    public let stageReason: String?
    /// <p>The directory size.</p>
    public let type: DirectoryType?
    /// <p>A <a>DirectoryVpcSettingsDescription</a> object that contains additional
    ///       information about a directory. This member is only present if the directory is a Simple AD or
    ///       Managed AD directory.</p>
    public let vpcSettings: DirectoryVpcSettingsDescription?

    public init (
        accessUrl: String? = nil,
        alias: String? = nil,
        connectSettings: DirectoryConnectSettingsDescription? = nil,
        description: String? = nil,
        desiredNumberOfDomainControllers: Int = 0,
        directoryId: String? = nil,
        dnsIpAddrs: [String]? = nil,
        edition: DirectoryEdition? = nil,
        launchTime: Date? = nil,
        name: String? = nil,
        ownerDirectoryDescription: OwnerDirectoryDescription? = nil,
        radiusSettings: RadiusSettings? = nil,
        radiusStatus: RadiusStatus? = nil,
        regionsInfo: RegionsInfo? = nil,
        shareMethod: ShareMethod? = nil,
        shareNotes: String? = nil,
        shareStatus: ShareStatus? = nil,
        shortName: String? = nil,
        size: DirectorySize? = nil,
        ssoEnabled: Bool = false,
        stage: DirectoryStage? = nil,
        stageLastUpdatedDateTime: Date? = nil,
        stageReason: String? = nil,
        type: DirectoryType? = nil,
        vpcSettings: DirectoryVpcSettingsDescription? = nil
    )
    {
        self.accessUrl = accessUrl
        self.alias = alias
        self.connectSettings = connectSettings
        self.description = description
        self.desiredNumberOfDomainControllers = desiredNumberOfDomainControllers
        self.directoryId = directoryId
        self.dnsIpAddrs = dnsIpAddrs
        self.edition = edition
        self.launchTime = launchTime
        self.name = name
        self.ownerDirectoryDescription = ownerDirectoryDescription
        self.radiusSettings = radiusSettings
        self.radiusStatus = radiusStatus
        self.regionsInfo = regionsInfo
        self.shareMethod = shareMethod
        self.shareNotes = shareNotes
        self.shareStatus = shareStatus
        self.shortName = shortName
        self.size = size
        self.ssoEnabled = ssoEnabled
        self.stage = stage
        self.stageLastUpdatedDateTime = stageLastUpdatedDateTime
        self.stageReason = stageReason
        self.type = type
        self.vpcSettings = vpcSettings
    }
}

extension DirectoryDoesNotExistException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DirectoryDoesNotExistException(message: \(String(describing: message)), requestId: \(String(describing: requestId)))"}
}

extension DirectoryDoesNotExistException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DirectoryDoesNotExistExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.requestId = output.requestId
        } else {
            self.message = nil
            self.requestId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified directory does not exist in the system.</p>
public struct DirectoryDoesNotExistException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The descriptive message for the exception.</p>
    public var message: String?
    /// <p>The AWS request identifier.</p>
    public var requestId: String?

    public init (
        message: String? = nil,
        requestId: String? = nil
    )
    {
        self.message = message
        self.requestId = requestId
    }
}

struct DirectoryDoesNotExistExceptionBody: Equatable {
    public let message: String?
    public let requestId: String?
}

extension DirectoryDoesNotExistExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case requestId = "RequestId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

public enum DirectoryEdition {
    case enterprise
    case standard
    case sdkUnknown(String)
}

extension DirectoryEdition : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DirectoryEdition] {
        return [
            .enterprise,
            .standard,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .enterprise: return "Enterprise"
        case .standard: return "Standard"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DirectoryEdition(rawValue: rawValue) ?? DirectoryEdition.sdkUnknown(rawValue)
    }
}

extension DirectoryLimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DirectoryLimitExceededException(message: \(String(describing: message)), requestId: \(String(describing: requestId)))"}
}

extension DirectoryLimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DirectoryLimitExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.requestId = output.requestId
        } else {
            self.message = nil
            self.requestId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The maximum number of directories in the region has been reached. You can use the
///             <a>GetDirectoryLimits</a> operation to determine your directory limits in the
///             region.</p>
public struct DirectoryLimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The descriptive message for the exception.</p>
    public var message: String?
    /// <p>The AWS request identifier.</p>
    public var requestId: String?

    public init (
        message: String? = nil,
        requestId: String? = nil
    )
    {
        self.message = message
        self.requestId = requestId
    }
}

struct DirectoryLimitExceededExceptionBody: Equatable {
    public let message: String?
    public let requestId: String?
}

extension DirectoryLimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case requestId = "RequestId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension DirectoryLimits: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cloudOnlyDirectoriesCurrentCount = "CloudOnlyDirectoriesCurrentCount"
        case cloudOnlyDirectoriesLimit = "CloudOnlyDirectoriesLimit"
        case cloudOnlyDirectoriesLimitReached = "CloudOnlyDirectoriesLimitReached"
        case cloudOnlyMicrosoftADCurrentCount = "CloudOnlyMicrosoftADCurrentCount"
        case cloudOnlyMicrosoftADLimit = "CloudOnlyMicrosoftADLimit"
        case cloudOnlyMicrosoftADLimitReached = "CloudOnlyMicrosoftADLimitReached"
        case connectedDirectoriesCurrentCount = "ConnectedDirectoriesCurrentCount"
        case connectedDirectoriesLimit = "ConnectedDirectoriesLimit"
        case connectedDirectoriesLimitReached = "ConnectedDirectoriesLimitReached"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudOnlyDirectoriesCurrentCount = cloudOnlyDirectoriesCurrentCount {
            try encodeContainer.encode(cloudOnlyDirectoriesCurrentCount, forKey: .cloudOnlyDirectoriesCurrentCount)
        }
        if let cloudOnlyDirectoriesLimit = cloudOnlyDirectoriesLimit {
            try encodeContainer.encode(cloudOnlyDirectoriesLimit, forKey: .cloudOnlyDirectoriesLimit)
        }
        if cloudOnlyDirectoriesLimitReached != false {
            try encodeContainer.encode(cloudOnlyDirectoriesLimitReached, forKey: .cloudOnlyDirectoriesLimitReached)
        }
        if let cloudOnlyMicrosoftADCurrentCount = cloudOnlyMicrosoftADCurrentCount {
            try encodeContainer.encode(cloudOnlyMicrosoftADCurrentCount, forKey: .cloudOnlyMicrosoftADCurrentCount)
        }
        if let cloudOnlyMicrosoftADLimit = cloudOnlyMicrosoftADLimit {
            try encodeContainer.encode(cloudOnlyMicrosoftADLimit, forKey: .cloudOnlyMicrosoftADLimit)
        }
        if cloudOnlyMicrosoftADLimitReached != false {
            try encodeContainer.encode(cloudOnlyMicrosoftADLimitReached, forKey: .cloudOnlyMicrosoftADLimitReached)
        }
        if let connectedDirectoriesCurrentCount = connectedDirectoriesCurrentCount {
            try encodeContainer.encode(connectedDirectoriesCurrentCount, forKey: .connectedDirectoriesCurrentCount)
        }
        if let connectedDirectoriesLimit = connectedDirectoriesLimit {
            try encodeContainer.encode(connectedDirectoriesLimit, forKey: .connectedDirectoriesLimit)
        }
        if connectedDirectoriesLimitReached != false {
            try encodeContainer.encode(connectedDirectoriesLimitReached, forKey: .connectedDirectoriesLimitReached)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudOnlyDirectoriesLimitDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .cloudOnlyDirectoriesLimit)
        cloudOnlyDirectoriesLimit = cloudOnlyDirectoriesLimitDecoded
        let cloudOnlyDirectoriesCurrentCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .cloudOnlyDirectoriesCurrentCount)
        cloudOnlyDirectoriesCurrentCount = cloudOnlyDirectoriesCurrentCountDecoded
        let cloudOnlyDirectoriesLimitReachedDecoded = try containerValues.decode(Bool.self, forKey: .cloudOnlyDirectoriesLimitReached)
        cloudOnlyDirectoriesLimitReached = cloudOnlyDirectoriesLimitReachedDecoded
        let cloudOnlyMicrosoftADLimitDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .cloudOnlyMicrosoftADLimit)
        cloudOnlyMicrosoftADLimit = cloudOnlyMicrosoftADLimitDecoded
        let cloudOnlyMicrosoftADCurrentCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .cloudOnlyMicrosoftADCurrentCount)
        cloudOnlyMicrosoftADCurrentCount = cloudOnlyMicrosoftADCurrentCountDecoded
        let cloudOnlyMicrosoftADLimitReachedDecoded = try containerValues.decode(Bool.self, forKey: .cloudOnlyMicrosoftADLimitReached)
        cloudOnlyMicrosoftADLimitReached = cloudOnlyMicrosoftADLimitReachedDecoded
        let connectedDirectoriesLimitDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .connectedDirectoriesLimit)
        connectedDirectoriesLimit = connectedDirectoriesLimitDecoded
        let connectedDirectoriesCurrentCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .connectedDirectoriesCurrentCount)
        connectedDirectoriesCurrentCount = connectedDirectoriesCurrentCountDecoded
        let connectedDirectoriesLimitReachedDecoded = try containerValues.decode(Bool.self, forKey: .connectedDirectoriesLimitReached)
        connectedDirectoriesLimitReached = connectedDirectoriesLimitReachedDecoded
    }
}

extension DirectoryLimits: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DirectoryLimits(cloudOnlyDirectoriesCurrentCount: \(String(describing: cloudOnlyDirectoriesCurrentCount)), cloudOnlyDirectoriesLimit: \(String(describing: cloudOnlyDirectoriesLimit)), cloudOnlyDirectoriesLimitReached: \(String(describing: cloudOnlyDirectoriesLimitReached)), cloudOnlyMicrosoftADCurrentCount: \(String(describing: cloudOnlyMicrosoftADCurrentCount)), cloudOnlyMicrosoftADLimit: \(String(describing: cloudOnlyMicrosoftADLimit)), cloudOnlyMicrosoftADLimitReached: \(String(describing: cloudOnlyMicrosoftADLimitReached)), connectedDirectoriesCurrentCount: \(String(describing: connectedDirectoriesCurrentCount)), connectedDirectoriesLimit: \(String(describing: connectedDirectoriesLimit)), connectedDirectoriesLimitReached: \(String(describing: connectedDirectoriesLimitReached)))"}
}

/// <p>Contains directory limit information for a Region.</p>
public struct DirectoryLimits: Equatable {
    /// <p>The current number of cloud directories in the Region.</p>
    public let cloudOnlyDirectoriesCurrentCount: Int?
    /// <p>The maximum number of cloud directories allowed in the Region.</p>
    public let cloudOnlyDirectoriesLimit: Int?
    /// <p>Indicates if the cloud directory limit has been reached.</p>
    public let cloudOnlyDirectoriesLimitReached: Bool
    /// <p>The current number of AWS Managed Microsoft AD directories in the region.</p>
    public let cloudOnlyMicrosoftADCurrentCount: Int?
    /// <p>The maximum number of AWS Managed Microsoft AD directories allowed in the region.</p>
    public let cloudOnlyMicrosoftADLimit: Int?
    /// <p>Indicates if the AWS Managed Microsoft AD directory limit has been reached.</p>
    public let cloudOnlyMicrosoftADLimitReached: Bool
    /// <p>The current number of connected directories in the Region.</p>
    public let connectedDirectoriesCurrentCount: Int?
    /// <p>The maximum number of connected directories allowed in the Region.</p>
    public let connectedDirectoriesLimit: Int?
    /// <p>Indicates if the connected directory limit has been reached.</p>
    public let connectedDirectoriesLimitReached: Bool

    public init (
        cloudOnlyDirectoriesCurrentCount: Int? = nil,
        cloudOnlyDirectoriesLimit: Int? = nil,
        cloudOnlyDirectoriesLimitReached: Bool = false,
        cloudOnlyMicrosoftADCurrentCount: Int? = nil,
        cloudOnlyMicrosoftADLimit: Int? = nil,
        cloudOnlyMicrosoftADLimitReached: Bool = false,
        connectedDirectoriesCurrentCount: Int? = nil,
        connectedDirectoriesLimit: Int? = nil,
        connectedDirectoriesLimitReached: Bool = false
    )
    {
        self.cloudOnlyDirectoriesCurrentCount = cloudOnlyDirectoriesCurrentCount
        self.cloudOnlyDirectoriesLimit = cloudOnlyDirectoriesLimit
        self.cloudOnlyDirectoriesLimitReached = cloudOnlyDirectoriesLimitReached
        self.cloudOnlyMicrosoftADCurrentCount = cloudOnlyMicrosoftADCurrentCount
        self.cloudOnlyMicrosoftADLimit = cloudOnlyMicrosoftADLimit
        self.cloudOnlyMicrosoftADLimitReached = cloudOnlyMicrosoftADLimitReached
        self.connectedDirectoriesCurrentCount = connectedDirectoriesCurrentCount
        self.connectedDirectoriesLimit = connectedDirectoriesLimit
        self.connectedDirectoriesLimitReached = connectedDirectoriesLimitReached
    }
}

extension DirectoryNotSharedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DirectoryNotSharedException(message: \(String(describing: message)), requestId: \(String(describing: requestId)))"}
}

extension DirectoryNotSharedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DirectoryNotSharedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.requestId = output.requestId
        } else {
            self.message = nil
            self.requestId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified directory has not been shared with this AWS account.</p>
public struct DirectoryNotSharedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The descriptive message for the exception.</p>
    public var message: String?
    /// <p>The AWS request identifier.</p>
    public var requestId: String?

    public init (
        message: String? = nil,
        requestId: String? = nil
    )
    {
        self.message = message
        self.requestId = requestId
    }
}

struct DirectoryNotSharedExceptionBody: Equatable {
    public let message: String?
    public let requestId: String?
}

extension DirectoryNotSharedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case requestId = "RequestId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

public enum DirectorySize {
    case large
    case small
    case sdkUnknown(String)
}

extension DirectorySize : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DirectorySize] {
        return [
            .large,
            .small,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .large: return "Large"
        case .small: return "Small"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DirectorySize(rawValue: rawValue) ?? DirectorySize.sdkUnknown(rawValue)
    }
}

public enum DirectoryStage {
    case active
    case created
    case creating
    case deleted
    case deleting
    case failed
    case impaired
    case inoperable
    case requested
    case restorefailed
    case restoring
    case sdkUnknown(String)
}

extension DirectoryStage : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DirectoryStage] {
        return [
            .active,
            .created,
            .creating,
            .deleted,
            .deleting,
            .failed,
            .impaired,
            .inoperable,
            .requested,
            .restorefailed,
            .restoring,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .active: return "Active"
        case .created: return "Created"
        case .creating: return "Creating"
        case .deleted: return "Deleted"
        case .deleting: return "Deleting"
        case .failed: return "Failed"
        case .impaired: return "Impaired"
        case .inoperable: return "Inoperable"
        case .requested: return "Requested"
        case .restorefailed: return "RestoreFailed"
        case .restoring: return "Restoring"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DirectoryStage(rawValue: rawValue) ?? DirectoryStage.sdkUnknown(rawValue)
    }
}

public enum DirectoryType {
    case adConnector
    case microsoftAd
    case sharedMicrosoftAd
    case simpleAd
    case sdkUnknown(String)
}

extension DirectoryType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DirectoryType] {
        return [
            .adConnector,
            .microsoftAd,
            .sharedMicrosoftAd,
            .simpleAd,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .adConnector: return "ADConnector"
        case .microsoftAd: return "MicrosoftAD"
        case .sharedMicrosoftAd: return "SharedMicrosoftAD"
        case .simpleAd: return "SimpleAD"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DirectoryType(rawValue: rawValue) ?? DirectoryType.sdkUnknown(rawValue)
    }
}

extension DirectoryUnavailableException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DirectoryUnavailableException(message: \(String(describing: message)), requestId: \(String(describing: requestId)))"}
}

extension DirectoryUnavailableException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DirectoryUnavailableExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.requestId = output.requestId
        } else {
            self.message = nil
            self.requestId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified directory is unavailable or could not be found.</p>
public struct DirectoryUnavailableException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The descriptive message for the exception.</p>
    public var message: String?
    /// <p>The AWS request identifier.</p>
    public var requestId: String?

    public init (
        message: String? = nil,
        requestId: String? = nil
    )
    {
        self.message = message
        self.requestId = requestId
    }
}

struct DirectoryUnavailableExceptionBody: Equatable {
    public let message: String?
    public let requestId: String?
}

extension DirectoryUnavailableExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case requestId = "RequestId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension DirectoryVpcSettings: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case subnetIds = "SubnetIds"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for subnetids0 in subnetIds {
                try subnetIdsContainer.encode(subnetids0)
            }
        }
        if let vpcId = vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpcIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let subnetIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
    }
}

extension DirectoryVpcSettings: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DirectoryVpcSettings(subnetIds: \(String(describing: subnetIds)), vpcId: \(String(describing: vpcId)))"}
}

/// <p>Contains VPC information for the <a>CreateDirectory</a> or <a>CreateMicrosoftAD</a> operation.</p>
public struct DirectoryVpcSettings: Equatable {
    /// <p>The identifiers of the subnets for the directory servers. The two subnets must be in
    ///       different Availability Zones. AWS Directory Service creates a directory server and a DNS
    ///       server in each of these subnets.</p>
    public let subnetIds: [String]?
    /// <p>The identifier of the VPC in which to create the directory.</p>
    public let vpcId: String?

    public init (
        subnetIds: [String]? = nil,
        vpcId: String? = nil
    )
    {
        self.subnetIds = subnetIds
        self.vpcId = vpcId
    }
}

extension DirectoryVpcSettingsDescription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case availabilityZones = "AvailabilityZones"
        case securityGroupId = "SecurityGroupId"
        case subnetIds = "SubnetIds"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityZones = availabilityZones {
            var availabilityZonesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .availabilityZones)
            for availabilityzones0 in availabilityZones {
                try availabilityZonesContainer.encode(availabilityzones0)
            }
        }
        if let securityGroupId = securityGroupId {
            try encodeContainer.encode(securityGroupId, forKey: .securityGroupId)
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for subnetids0 in subnetIds {
                try subnetIdsContainer.encode(subnetids0)
            }
        }
        if let vpcId = vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpcIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let subnetIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let securityGroupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .securityGroupId)
        securityGroupId = securityGroupIdDecoded
        let availabilityZonesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .availabilityZones)
        var availabilityZonesDecoded0:[String]? = nil
        if let availabilityZonesContainer = availabilityZonesContainer {
            availabilityZonesDecoded0 = [String]()
            for string0 in availabilityZonesContainer {
                if let string0 = string0 {
                    availabilityZonesDecoded0?.append(string0)
                }
            }
        }
        availabilityZones = availabilityZonesDecoded0
    }
}

extension DirectoryVpcSettingsDescription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DirectoryVpcSettingsDescription(availabilityZones: \(String(describing: availabilityZones)), securityGroupId: \(String(describing: securityGroupId)), subnetIds: \(String(describing: subnetIds)), vpcId: \(String(describing: vpcId)))"}
}

/// <p>Contains information about the directory.</p>
public struct DirectoryVpcSettingsDescription: Equatable {
    /// <p>The list of Availability Zones that the directory is in.</p>
    public let availabilityZones: [String]?
    /// <p>The domain controller security group identifier for the directory.</p>
    public let securityGroupId: String?
    /// <p>The identifiers of the subnets for the directory servers.</p>
    public let subnetIds: [String]?
    /// <p>The identifier of the VPC that the directory is in.</p>
    public let vpcId: String?

    public init (
        availabilityZones: [String]? = nil,
        securityGroupId: String? = nil,
        subnetIds: [String]? = nil,
        vpcId: String? = nil
    )
    {
        self.availabilityZones = availabilityZones
        self.securityGroupId = securityGroupId
        self.subnetIds = subnetIds
        self.vpcId = vpcId
    }
}

public struct DisableClientAuthenticationInputBodyMiddleware: Middleware {
    public let id: String = "DisableClientAuthenticationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisableClientAuthenticationInput>,
                  next: H) -> Swift.Result<OperationOutput<DisableClientAuthenticationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisableClientAuthenticationInput>
    public typealias MOutput = OperationOutput<DisableClientAuthenticationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisableClientAuthenticationOutputError>
}

extension DisableClientAuthenticationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisableClientAuthenticationInput(directoryId: \(String(describing: directoryId)), type: \(String(describing: type)))"}
}

extension DisableClientAuthenticationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case directoryId = "DirectoryId"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryId = directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

public struct DisableClientAuthenticationInputHeadersMiddleware: Middleware {
    public let id: String = "DisableClientAuthenticationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisableClientAuthenticationInput>,
                  next: H) -> Swift.Result<OperationOutput<DisableClientAuthenticationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisableClientAuthenticationInput>
    public typealias MOutput = OperationOutput<DisableClientAuthenticationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisableClientAuthenticationOutputError>
}

public struct DisableClientAuthenticationInputQueryItemMiddleware: Middleware {
    public let id: String = "DisableClientAuthenticationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisableClientAuthenticationInput>,
                  next: H) -> Swift.Result<OperationOutput<DisableClientAuthenticationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisableClientAuthenticationInput>
    public typealias MOutput = OperationOutput<DisableClientAuthenticationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisableClientAuthenticationOutputError>
}

public struct DisableClientAuthenticationInput: Equatable {
    /// <p>The identifier of the directory </p>
    public let directoryId: String?
    /// <p>The type of client authentication to disable. Currently, only the parameter, <code>SmartCard</code> is supported.</p>
    public let type: ClientAuthenticationType?

    public init (
        directoryId: String? = nil,
        type: ClientAuthenticationType? = nil
    )
    {
        self.directoryId = directoryId
        self.type = type
    }
}

struct DisableClientAuthenticationInputBody: Equatable {
    public let directoryId: String?
    public let type: ClientAuthenticationType?
}

extension DisableClientAuthenticationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case directoryId = "DirectoryId"
        case type = "Type"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ClientAuthenticationType.self, forKey: .type)
        type = typeDecoded
    }
}

extension DisableClientAuthenticationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisableClientAuthenticationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryDoesNotExistException" : self = .directoryDoesNotExistException(try DirectoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClientAuthStatusException" : self = .invalidClientAuthStatusException(try InvalidClientAuthStatusException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisableClientAuthenticationOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case clientException(ClientException)
    case directoryDoesNotExistException(DirectoryDoesNotExistException)
    case invalidClientAuthStatusException(InvalidClientAuthStatusException)
    case serviceException(ServiceException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisableClientAuthenticationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisableClientAuthenticationOutputResponse()"}
}

extension DisableClientAuthenticationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DisableClientAuthenticationOutputResponse: Equatable {

    public init() {}
}

struct DisableClientAuthenticationOutputResponseBody: Equatable {
}

extension DisableClientAuthenticationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DisableLDAPSInputBodyMiddleware: Middleware {
    public let id: String = "DisableLDAPSInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisableLDAPSInput>,
                  next: H) -> Swift.Result<OperationOutput<DisableLDAPSOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisableLDAPSInput>
    public typealias MOutput = OperationOutput<DisableLDAPSOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisableLDAPSOutputError>
}

extension DisableLDAPSInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisableLDAPSInput(directoryId: \(String(describing: directoryId)), type: \(String(describing: type)))"}
}

extension DisableLDAPSInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case directoryId = "DirectoryId"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryId = directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

public struct DisableLDAPSInputHeadersMiddleware: Middleware {
    public let id: String = "DisableLDAPSInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisableLDAPSInput>,
                  next: H) -> Swift.Result<OperationOutput<DisableLDAPSOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisableLDAPSInput>
    public typealias MOutput = OperationOutput<DisableLDAPSOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisableLDAPSOutputError>
}

public struct DisableLDAPSInputQueryItemMiddleware: Middleware {
    public let id: String = "DisableLDAPSInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisableLDAPSInput>,
                  next: H) -> Swift.Result<OperationOutput<DisableLDAPSOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisableLDAPSInput>
    public typealias MOutput = OperationOutput<DisableLDAPSOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisableLDAPSOutputError>
}

public struct DisableLDAPSInput: Equatable {
    /// <p>The identifier of the directory.</p>
    public let directoryId: String?
    /// <p>The type of LDAP security to enable. Currently only the value <code>Client</code> is
    ///       supported.</p>
    public let type: LDAPSType?

    public init (
        directoryId: String? = nil,
        type: LDAPSType? = nil
    )
    {
        self.directoryId = directoryId
        self.type = type
    }
}

struct DisableLDAPSInputBody: Equatable {
    public let directoryId: String?
    public let type: LDAPSType?
}

extension DisableLDAPSInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case directoryId = "DirectoryId"
        case type = "Type"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let typeDecoded = try containerValues.decodeIfPresent(LDAPSType.self, forKey: .type)
        type = typeDecoded
    }
}

extension DisableLDAPSOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisableLDAPSOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryDoesNotExistException" : self = .directoryDoesNotExistException(try DirectoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryUnavailableException" : self = .directoryUnavailableException(try DirectoryUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidLDAPSStatusException" : self = .invalidLDAPSStatusException(try InvalidLDAPSStatusException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisableLDAPSOutputError: Equatable {
    case clientException(ClientException)
    case directoryDoesNotExistException(DirectoryDoesNotExistException)
    case directoryUnavailableException(DirectoryUnavailableException)
    case invalidLDAPSStatusException(InvalidLDAPSStatusException)
    case invalidParameterException(InvalidParameterException)
    case serviceException(ServiceException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisableLDAPSOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisableLDAPSOutputResponse()"}
}

extension DisableLDAPSOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DisableLDAPSOutputResponse: Equatable {

    public init() {}
}

struct DisableLDAPSOutputResponseBody: Equatable {
}

extension DisableLDAPSOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DisableRadiusInputBodyMiddleware: Middleware {
    public let id: String = "DisableRadiusInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisableRadiusInput>,
                  next: H) -> Swift.Result<OperationOutput<DisableRadiusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisableRadiusInput>
    public typealias MOutput = OperationOutput<DisableRadiusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisableRadiusOutputError>
}

extension DisableRadiusInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisableRadiusInput(directoryId: \(String(describing: directoryId)))"}
}

extension DisableRadiusInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case directoryId = "DirectoryId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryId = directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
    }
}

public struct DisableRadiusInputHeadersMiddleware: Middleware {
    public let id: String = "DisableRadiusInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisableRadiusInput>,
                  next: H) -> Swift.Result<OperationOutput<DisableRadiusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisableRadiusInput>
    public typealias MOutput = OperationOutput<DisableRadiusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisableRadiusOutputError>
}

public struct DisableRadiusInputQueryItemMiddleware: Middleware {
    public let id: String = "DisableRadiusInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisableRadiusInput>,
                  next: H) -> Swift.Result<OperationOutput<DisableRadiusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisableRadiusInput>
    public typealias MOutput = OperationOutput<DisableRadiusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisableRadiusOutputError>
}

/// <p>Contains the inputs for the <a>DisableRadius</a> operation.</p>
public struct DisableRadiusInput: Equatable {
    /// <p>The identifier of the directory for which to disable MFA.</p>
    public let directoryId: String?

    public init (
        directoryId: String? = nil
    )
    {
        self.directoryId = directoryId
    }
}

struct DisableRadiusInputBody: Equatable {
    public let directoryId: String?
}

extension DisableRadiusInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case directoryId = "DirectoryId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
    }
}

extension DisableRadiusOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisableRadiusOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityDoesNotExistException" : self = .entityDoesNotExistException(try EntityDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisableRadiusOutputError: Equatable {
    case clientException(ClientException)
    case entityDoesNotExistException(EntityDoesNotExistException)
    case serviceException(ServiceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisableRadiusOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisableRadiusOutputResponse()"}
}

extension DisableRadiusOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>Contains the results of the <a>DisableRadius</a> operation.</p>
public struct DisableRadiusOutputResponse: Equatable {

    public init() {}
}

struct DisableRadiusOutputResponseBody: Equatable {
}

extension DisableRadiusOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DisableSsoInputBodyMiddleware: Middleware {
    public let id: String = "DisableSsoInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisableSsoInput>,
                  next: H) -> Swift.Result<OperationOutput<DisableSsoOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisableSsoInput>
    public typealias MOutput = OperationOutput<DisableSsoOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisableSsoOutputError>
}

extension DisableSsoInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisableSsoInput(directoryId: \(String(describing: directoryId)), password: \(String(describing: password)), userName: \(String(describing: userName)))"}
}

extension DisableSsoInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case directoryId = "DirectoryId"
        case password = "Password"
        case userName = "UserName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryId = directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let password = password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let userName = userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
    }
}

public struct DisableSsoInputHeadersMiddleware: Middleware {
    public let id: String = "DisableSsoInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisableSsoInput>,
                  next: H) -> Swift.Result<OperationOutput<DisableSsoOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisableSsoInput>
    public typealias MOutput = OperationOutput<DisableSsoOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisableSsoOutputError>
}

public struct DisableSsoInputQueryItemMiddleware: Middleware {
    public let id: String = "DisableSsoInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisableSsoInput>,
                  next: H) -> Swift.Result<OperationOutput<DisableSsoOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisableSsoInput>
    public typealias MOutput = OperationOutput<DisableSsoOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisableSsoOutputError>
}

/// <p>Contains the inputs for the <a>DisableSso</a> operation.</p>
public struct DisableSsoInput: Equatable {
    /// <p>The identifier of the directory for which to disable single-sign on.</p>
    public let directoryId: String?
    /// <p>The password of an alternate account to use to disable single-sign on. This is only used
    ///          for AD Connector directories. For more information, see the <i>UserName</i> parameter.</p>
    public let password: String?
    /// <p>The username of an alternate account to use to disable single-sign on. This is only used for AD Connector directories. This account must have privileges to remove a service principal name.</p>
    ///          <p>If the AD Connector service account does not have privileges to remove a service principal
    ///          name, you can specify an alternate account with the <i>UserName</i> and <i>Password</i>
    ///          parameters. These credentials are only used to disable single sign-on and are not stored by
    ///          the service. The AD Connector service account is not changed.</p>
    public let userName: String?

    public init (
        directoryId: String? = nil,
        password: String? = nil,
        userName: String? = nil
    )
    {
        self.directoryId = directoryId
        self.password = password
        self.userName = userName
    }
}

struct DisableSsoInputBody: Equatable {
    public let directoryId: String?
    public let userName: String?
    public let password: String?
}

extension DisableSsoInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case directoryId = "DirectoryId"
        case password = "Password"
        case userName = "UserName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userName)
        userName = userNameDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(String.self, forKey: .password)
        password = passwordDecoded
    }
}

extension DisableSsoOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisableSsoOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AuthenticationFailedException" : self = .authenticationFailedException(try AuthenticationFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityDoesNotExistException" : self = .entityDoesNotExistException(try EntityDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientPermissionsException" : self = .insufficientPermissionsException(try InsufficientPermissionsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisableSsoOutputError: Equatable {
    case authenticationFailedException(AuthenticationFailedException)
    case clientException(ClientException)
    case entityDoesNotExistException(EntityDoesNotExistException)
    case insufficientPermissionsException(InsufficientPermissionsException)
    case serviceException(ServiceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisableSsoOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisableSsoOutputResponse()"}
}

extension DisableSsoOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>Contains the results of the <a>DisableSso</a> operation.</p>
public struct DisableSsoOutputResponse: Equatable {

    public init() {}
}

struct DisableSsoOutputResponseBody: Equatable {
}

extension DisableSsoOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DomainController: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case availabilityZone = "AvailabilityZone"
        case directoryId = "DirectoryId"
        case dnsIpAddr = "DnsIpAddr"
        case domainControllerId = "DomainControllerId"
        case launchTime = "LaunchTime"
        case status = "Status"
        case statusLastUpdatedDateTime = "StatusLastUpdatedDateTime"
        case statusReason = "StatusReason"
        case subnetId = "SubnetId"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityZone = availabilityZone {
            try encodeContainer.encode(availabilityZone, forKey: .availabilityZone)
        }
        if let directoryId = directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let dnsIpAddr = dnsIpAddr {
            try encodeContainer.encode(dnsIpAddr, forKey: .dnsIpAddr)
        }
        if let domainControllerId = domainControllerId {
            try encodeContainer.encode(domainControllerId, forKey: .domainControllerId)
        }
        if let launchTime = launchTime {
            try encodeContainer.encode(launchTime.timeIntervalSince1970, forKey: .launchTime)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusLastUpdatedDateTime = statusLastUpdatedDateTime {
            try encodeContainer.encode(statusLastUpdatedDateTime.timeIntervalSince1970, forKey: .statusLastUpdatedDateTime)
        }
        if let statusReason = statusReason {
            try encodeContainer.encode(statusReason, forKey: .statusReason)
        }
        if let subnetId = subnetId {
            try encodeContainer.encode(subnetId, forKey: .subnetId)
        }
        if let vpcId = vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let domainControllerIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domainControllerId)
        domainControllerId = domainControllerIdDecoded
        let dnsIpAddrDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dnsIpAddr)
        dnsIpAddr = dnsIpAddrDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let subnetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subnetId)
        subnetId = subnetIdDecoded
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DomainControllerStatus.self, forKey: .status)
        status = statusDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
        let launchTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .launchTime)
        launchTime = launchTimeDecoded
        let statusLastUpdatedDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .statusLastUpdatedDateTime)
        statusLastUpdatedDateTime = statusLastUpdatedDateTimeDecoded
    }
}

extension DomainController: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DomainController(availabilityZone: \(String(describing: availabilityZone)), directoryId: \(String(describing: directoryId)), dnsIpAddr: \(String(describing: dnsIpAddr)), domainControllerId: \(String(describing: domainControllerId)), launchTime: \(String(describing: launchTime)), status: \(String(describing: status)), statusLastUpdatedDateTime: \(String(describing: statusLastUpdatedDateTime)), statusReason: \(String(describing: statusReason)), subnetId: \(String(describing: subnetId)), vpcId: \(String(describing: vpcId)))"}
}

/// <p>Contains information about the domain controllers for a specified directory.</p>
public struct DomainController: Equatable {
    /// <p>The Availability Zone where the domain controller is located.</p>
    public let availabilityZone: String?
    /// <p>Identifier of the directory where the domain controller resides.</p>
    public let directoryId: String?
    /// <p>The IP address of the domain controller.</p>
    public let dnsIpAddr: String?
    /// <p>Identifies a specific domain controller in the directory.</p>
    public let domainControllerId: String?
    /// <p>Specifies when the domain controller was created.</p>
    public let launchTime: Date?
    /// <p>The status of the domain controller.</p>
    public let status: DomainControllerStatus?
    /// <p>The date and time that the status was last updated.</p>
    public let statusLastUpdatedDateTime: Date?
    /// <p>A description of the domain controller state.</p>
    public let statusReason: String?
    /// <p>Identifier of the subnet in the VPC that contains the domain controller.</p>
    public let subnetId: String?
    /// <p>The identifier of the VPC that contains the domain controller.</p>
    public let vpcId: String?

    public init (
        availabilityZone: String? = nil,
        directoryId: String? = nil,
        dnsIpAddr: String? = nil,
        domainControllerId: String? = nil,
        launchTime: Date? = nil,
        status: DomainControllerStatus? = nil,
        statusLastUpdatedDateTime: Date? = nil,
        statusReason: String? = nil,
        subnetId: String? = nil,
        vpcId: String? = nil
    )
    {
        self.availabilityZone = availabilityZone
        self.directoryId = directoryId
        self.dnsIpAddr = dnsIpAddr
        self.domainControllerId = domainControllerId
        self.launchTime = launchTime
        self.status = status
        self.statusLastUpdatedDateTime = statusLastUpdatedDateTime
        self.statusReason = statusReason
        self.subnetId = subnetId
        self.vpcId = vpcId
    }
}

extension DomainControllerLimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DomainControllerLimitExceededException(message: \(String(describing: message)), requestId: \(String(describing: requestId)))"}
}

extension DomainControllerLimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DomainControllerLimitExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.requestId = output.requestId
        } else {
            self.message = nil
            self.requestId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The maximum allowed number of domain controllers per directory was exceeded. The default limit per directory is 20 domain controllers.</p>
public struct DomainControllerLimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The descriptive message for the exception.</p>
    public var message: String?
    /// <p>The AWS request identifier.</p>
    public var requestId: String?

    public init (
        message: String? = nil,
        requestId: String? = nil
    )
    {
        self.message = message
        self.requestId = requestId
    }
}

struct DomainControllerLimitExceededExceptionBody: Equatable {
    public let message: String?
    public let requestId: String?
}

extension DomainControllerLimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case requestId = "RequestId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

public enum DomainControllerStatus {
    case active
    case creating
    case deleted
    case deleting
    case failed
    case impaired
    case restoring
    case sdkUnknown(String)
}

extension DomainControllerStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DomainControllerStatus] {
        return [
            .active,
            .creating,
            .deleted,
            .deleting,
            .failed,
            .impaired,
            .restoring,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .active: return "Active"
        case .creating: return "Creating"
        case .deleted: return "Deleted"
        case .deleting: return "Deleting"
        case .failed: return "Failed"
        case .impaired: return "Impaired"
        case .restoring: return "Restoring"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DomainControllerStatus(rawValue: rawValue) ?? DomainControllerStatus.sdkUnknown(rawValue)
    }
}

public struct EnableClientAuthenticationInputBodyMiddleware: Middleware {
    public let id: String = "EnableClientAuthenticationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<EnableClientAuthenticationInput>,
                  next: H) -> Swift.Result<OperationOutput<EnableClientAuthenticationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<EnableClientAuthenticationInput>
    public typealias MOutput = OperationOutput<EnableClientAuthenticationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<EnableClientAuthenticationOutputError>
}

extension EnableClientAuthenticationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EnableClientAuthenticationInput(directoryId: \(String(describing: directoryId)), type: \(String(describing: type)))"}
}

extension EnableClientAuthenticationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case directoryId = "DirectoryId"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryId = directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

public struct EnableClientAuthenticationInputHeadersMiddleware: Middleware {
    public let id: String = "EnableClientAuthenticationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<EnableClientAuthenticationInput>,
                  next: H) -> Swift.Result<OperationOutput<EnableClientAuthenticationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<EnableClientAuthenticationInput>
    public typealias MOutput = OperationOutput<EnableClientAuthenticationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<EnableClientAuthenticationOutputError>
}

public struct EnableClientAuthenticationInputQueryItemMiddleware: Middleware {
    public let id: String = "EnableClientAuthenticationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<EnableClientAuthenticationInput>,
                  next: H) -> Swift.Result<OperationOutput<EnableClientAuthenticationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<EnableClientAuthenticationInput>
    public typealias MOutput = OperationOutput<EnableClientAuthenticationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<EnableClientAuthenticationOutputError>
}

public struct EnableClientAuthenticationInput: Equatable {
    /// <p>The identifier of the specified directory. </p>
    public let directoryId: String?
    /// <p>The type of client authentication to enable. Currently only the value <code>SmartCard</code> is
    ///       supported. Smart card authentication in AD Connector requires that you enable Kerberos
    ///       Constrained Delegation for the Service User to the LDAP service in the on-premises AD.
    ///     </p>
    public let type: ClientAuthenticationType?

    public init (
        directoryId: String? = nil,
        type: ClientAuthenticationType? = nil
    )
    {
        self.directoryId = directoryId
        self.type = type
    }
}

struct EnableClientAuthenticationInputBody: Equatable {
    public let directoryId: String?
    public let type: ClientAuthenticationType?
}

extension EnableClientAuthenticationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case directoryId = "DirectoryId"
        case type = "Type"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ClientAuthenticationType.self, forKey: .type)
        type = typeDecoded
    }
}

extension EnableClientAuthenticationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension EnableClientAuthenticationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryDoesNotExistException" : self = .directoryDoesNotExistException(try DirectoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClientAuthStatusException" : self = .invalidClientAuthStatusException(try InvalidClientAuthStatusException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoAvailableCertificateException" : self = .noAvailableCertificateException(try NoAvailableCertificateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum EnableClientAuthenticationOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case clientException(ClientException)
    case directoryDoesNotExistException(DirectoryDoesNotExistException)
    case invalidClientAuthStatusException(InvalidClientAuthStatusException)
    case noAvailableCertificateException(NoAvailableCertificateException)
    case serviceException(ServiceException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension EnableClientAuthenticationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EnableClientAuthenticationOutputResponse()"}
}

extension EnableClientAuthenticationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct EnableClientAuthenticationOutputResponse: Equatable {

    public init() {}
}

struct EnableClientAuthenticationOutputResponseBody: Equatable {
}

extension EnableClientAuthenticationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct EnableLDAPSInputBodyMiddleware: Middleware {
    public let id: String = "EnableLDAPSInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<EnableLDAPSInput>,
                  next: H) -> Swift.Result<OperationOutput<EnableLDAPSOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<EnableLDAPSInput>
    public typealias MOutput = OperationOutput<EnableLDAPSOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<EnableLDAPSOutputError>
}

extension EnableLDAPSInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EnableLDAPSInput(directoryId: \(String(describing: directoryId)), type: \(String(describing: type)))"}
}

extension EnableLDAPSInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case directoryId = "DirectoryId"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryId = directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

public struct EnableLDAPSInputHeadersMiddleware: Middleware {
    public let id: String = "EnableLDAPSInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<EnableLDAPSInput>,
                  next: H) -> Swift.Result<OperationOutput<EnableLDAPSOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<EnableLDAPSInput>
    public typealias MOutput = OperationOutput<EnableLDAPSOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<EnableLDAPSOutputError>
}

public struct EnableLDAPSInputQueryItemMiddleware: Middleware {
    public let id: String = "EnableLDAPSInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<EnableLDAPSInput>,
                  next: H) -> Swift.Result<OperationOutput<EnableLDAPSOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<EnableLDAPSInput>
    public typealias MOutput = OperationOutput<EnableLDAPSOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<EnableLDAPSOutputError>
}

public struct EnableLDAPSInput: Equatable {
    /// <p>The identifier of the directory.</p>
    public let directoryId: String?
    /// <p>The type of LDAP security to enable. Currently only the value <code>Client</code> is
    ///       supported.</p>
    public let type: LDAPSType?

    public init (
        directoryId: String? = nil,
        type: LDAPSType? = nil
    )
    {
        self.directoryId = directoryId
        self.type = type
    }
}

struct EnableLDAPSInputBody: Equatable {
    public let directoryId: String?
    public let type: LDAPSType?
}

extension EnableLDAPSInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case directoryId = "DirectoryId"
        case type = "Type"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let typeDecoded = try containerValues.decodeIfPresent(LDAPSType.self, forKey: .type)
        type = typeDecoded
    }
}

extension EnableLDAPSOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension EnableLDAPSOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryDoesNotExistException" : self = .directoryDoesNotExistException(try DirectoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryUnavailableException" : self = .directoryUnavailableException(try DirectoryUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidLDAPSStatusException" : self = .invalidLDAPSStatusException(try InvalidLDAPSStatusException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoAvailableCertificateException" : self = .noAvailableCertificateException(try NoAvailableCertificateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum EnableLDAPSOutputError: Equatable {
    case clientException(ClientException)
    case directoryDoesNotExistException(DirectoryDoesNotExistException)
    case directoryUnavailableException(DirectoryUnavailableException)
    case invalidLDAPSStatusException(InvalidLDAPSStatusException)
    case invalidParameterException(InvalidParameterException)
    case noAvailableCertificateException(NoAvailableCertificateException)
    case serviceException(ServiceException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension EnableLDAPSOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EnableLDAPSOutputResponse()"}
}

extension EnableLDAPSOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct EnableLDAPSOutputResponse: Equatable {

    public init() {}
}

struct EnableLDAPSOutputResponseBody: Equatable {
}

extension EnableLDAPSOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct EnableRadiusInputBodyMiddleware: Middleware {
    public let id: String = "EnableRadiusInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<EnableRadiusInput>,
                  next: H) -> Swift.Result<OperationOutput<EnableRadiusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<EnableRadiusInput>
    public typealias MOutput = OperationOutput<EnableRadiusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<EnableRadiusOutputError>
}

extension EnableRadiusInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EnableRadiusInput(directoryId: \(String(describing: directoryId)), radiusSettings: \(String(describing: radiusSettings)))"}
}

extension EnableRadiusInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case directoryId = "DirectoryId"
        case radiusSettings = "RadiusSettings"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryId = directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let radiusSettings = radiusSettings {
            try encodeContainer.encode(radiusSettings, forKey: .radiusSettings)
        }
    }
}

public struct EnableRadiusInputHeadersMiddleware: Middleware {
    public let id: String = "EnableRadiusInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<EnableRadiusInput>,
                  next: H) -> Swift.Result<OperationOutput<EnableRadiusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<EnableRadiusInput>
    public typealias MOutput = OperationOutput<EnableRadiusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<EnableRadiusOutputError>
}

public struct EnableRadiusInputQueryItemMiddleware: Middleware {
    public let id: String = "EnableRadiusInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<EnableRadiusInput>,
                  next: H) -> Swift.Result<OperationOutput<EnableRadiusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<EnableRadiusInput>
    public typealias MOutput = OperationOutput<EnableRadiusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<EnableRadiusOutputError>
}

/// <p>Contains the inputs for the <a>EnableRadius</a> operation.</p>
public struct EnableRadiusInput: Equatable {
    /// <p>The identifier of the directory for which to enable MFA.</p>
    public let directoryId: String?
    /// <p>A <a>RadiusSettings</a> object that contains information about the RADIUS server.</p>
    public let radiusSettings: RadiusSettings?

    public init (
        directoryId: String? = nil,
        radiusSettings: RadiusSettings? = nil
    )
    {
        self.directoryId = directoryId
        self.radiusSettings = radiusSettings
    }
}

struct EnableRadiusInputBody: Equatable {
    public let directoryId: String?
    public let radiusSettings: RadiusSettings?
}

extension EnableRadiusInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case directoryId = "DirectoryId"
        case radiusSettings = "RadiusSettings"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let radiusSettingsDecoded = try containerValues.decodeIfPresent(RadiusSettings.self, forKey: .radiusSettings)
        radiusSettings = radiusSettingsDecoded
    }
}

extension EnableRadiusOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension EnableRadiusOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityAlreadyExistsException" : self = .entityAlreadyExistsException(try EntityAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityDoesNotExistException" : self = .entityDoesNotExistException(try EntityDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum EnableRadiusOutputError: Equatable {
    case clientException(ClientException)
    case entityAlreadyExistsException(EntityAlreadyExistsException)
    case entityDoesNotExistException(EntityDoesNotExistException)
    case invalidParameterException(InvalidParameterException)
    case serviceException(ServiceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension EnableRadiusOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EnableRadiusOutputResponse()"}
}

extension EnableRadiusOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>Contains the results of the <a>EnableRadius</a> operation.</p>
public struct EnableRadiusOutputResponse: Equatable {

    public init() {}
}

struct EnableRadiusOutputResponseBody: Equatable {
}

extension EnableRadiusOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct EnableSsoInputBodyMiddleware: Middleware {
    public let id: String = "EnableSsoInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<EnableSsoInput>,
                  next: H) -> Swift.Result<OperationOutput<EnableSsoOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<EnableSsoInput>
    public typealias MOutput = OperationOutput<EnableSsoOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<EnableSsoOutputError>
}

extension EnableSsoInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EnableSsoInput(directoryId: \(String(describing: directoryId)), password: \(String(describing: password)), userName: \(String(describing: userName)))"}
}

extension EnableSsoInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case directoryId = "DirectoryId"
        case password = "Password"
        case userName = "UserName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryId = directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let password = password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let userName = userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
    }
}

public struct EnableSsoInputHeadersMiddleware: Middleware {
    public let id: String = "EnableSsoInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<EnableSsoInput>,
                  next: H) -> Swift.Result<OperationOutput<EnableSsoOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<EnableSsoInput>
    public typealias MOutput = OperationOutput<EnableSsoOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<EnableSsoOutputError>
}

public struct EnableSsoInputQueryItemMiddleware: Middleware {
    public let id: String = "EnableSsoInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<EnableSsoInput>,
                  next: H) -> Swift.Result<OperationOutput<EnableSsoOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<EnableSsoInput>
    public typealias MOutput = OperationOutput<EnableSsoOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<EnableSsoOutputError>
}

/// <p>Contains the inputs for the <a>EnableSso</a> operation.</p>
public struct EnableSsoInput: Equatable {
    /// <p>The identifier of the directory for which to enable single-sign on.</p>
    public let directoryId: String?
    /// <p>The password of an alternate account to use to enable single-sign on. This is only used for
    ///          AD Connector directories. For more information, see the <i>UserName</i> parameter.</p>
    public let password: String?
    /// <p>The username of an alternate account to use to enable single-sign on. This is only used for AD Connector directories. This account must have privileges to add a service principal name.</p>
    ///          <p>If the AD Connector service account does not have privileges to add a service principal
    ///          name, you can specify an alternate account with the <i>UserName</i> and <i>Password</i>
    ///          parameters. These credentials are only used to enable single sign-on and are not stored by
    ///          the service. The AD Connector service account is not changed.</p>
    public let userName: String?

    public init (
        directoryId: String? = nil,
        password: String? = nil,
        userName: String? = nil
    )
    {
        self.directoryId = directoryId
        self.password = password
        self.userName = userName
    }
}

struct EnableSsoInputBody: Equatable {
    public let directoryId: String?
    public let userName: String?
    public let password: String?
}

extension EnableSsoInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case directoryId = "DirectoryId"
        case password = "Password"
        case userName = "UserName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userName)
        userName = userNameDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(String.self, forKey: .password)
        password = passwordDecoded
    }
}

extension EnableSsoOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension EnableSsoOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AuthenticationFailedException" : self = .authenticationFailedException(try AuthenticationFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityDoesNotExistException" : self = .entityDoesNotExistException(try EntityDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientPermissionsException" : self = .insufficientPermissionsException(try InsufficientPermissionsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum EnableSsoOutputError: Equatable {
    case authenticationFailedException(AuthenticationFailedException)
    case clientException(ClientException)
    case entityDoesNotExistException(EntityDoesNotExistException)
    case insufficientPermissionsException(InsufficientPermissionsException)
    case serviceException(ServiceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension EnableSsoOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EnableSsoOutputResponse()"}
}

extension EnableSsoOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>Contains the results of the <a>EnableSso</a> operation.</p>
public struct EnableSsoOutputResponse: Equatable {

    public init() {}
}

struct EnableSsoOutputResponseBody: Equatable {
}

extension EnableSsoOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension EntityAlreadyExistsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EntityAlreadyExistsException(message: \(String(describing: message)), requestId: \(String(describing: requestId)))"}
}

extension EntityAlreadyExistsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: EntityAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.requestId = output.requestId
        } else {
            self.message = nil
            self.requestId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified entity already exists.</p>
public struct EntityAlreadyExistsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The descriptive message for the exception.</p>
    public var message: String?
    /// <p>The AWS request identifier.</p>
    public var requestId: String?

    public init (
        message: String? = nil,
        requestId: String? = nil
    )
    {
        self.message = message
        self.requestId = requestId
    }
}

struct EntityAlreadyExistsExceptionBody: Equatable {
    public let message: String?
    public let requestId: String?
}

extension EntityAlreadyExistsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case requestId = "RequestId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension EntityDoesNotExistException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EntityDoesNotExistException(message: \(String(describing: message)), requestId: \(String(describing: requestId)))"}
}

extension EntityDoesNotExistException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: EntityDoesNotExistExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.requestId = output.requestId
        } else {
            self.message = nil
            self.requestId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified entity could not be found.</p>
public struct EntityDoesNotExistException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The descriptive message for the exception.</p>
    public var message: String?
    /// <p>The AWS request identifier.</p>
    public var requestId: String?

    public init (
        message: String? = nil,
        requestId: String? = nil
    )
    {
        self.message = message
        self.requestId = requestId
    }
}

struct EntityDoesNotExistExceptionBody: Equatable {
    public let message: String?
    public let requestId: String?
}

extension EntityDoesNotExistExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case requestId = "RequestId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension EventTopic: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case createdDateTime = "CreatedDateTime"
        case directoryId = "DirectoryId"
        case status = "Status"
        case topicArn = "TopicArn"
        case topicName = "TopicName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdDateTime = createdDateTime {
            try encodeContainer.encode(createdDateTime.timeIntervalSince1970, forKey: .createdDateTime)
        }
        if let directoryId = directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let topicArn = topicArn {
            try encodeContainer.encode(topicArn, forKey: .topicArn)
        }
        if let topicName = topicName {
            try encodeContainer.encode(topicName, forKey: .topicName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let topicNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .topicName)
        topicName = topicNameDecoded
        let topicArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .topicArn)
        topicArn = topicArnDecoded
        let createdDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdDateTime)
        createdDateTime = createdDateTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(TopicStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension EventTopic: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EventTopic(createdDateTime: \(String(describing: createdDateTime)), directoryId: \(String(describing: directoryId)), status: \(String(describing: status)), topicArn: \(String(describing: topicArn)), topicName: \(String(describing: topicName)))"}
}

/// <p>Information about SNS topic and AWS Directory Service directory associations.</p>
public struct EventTopic: Equatable {
    /// <p>The date and time of when you associated your directory with the SNS topic.</p>
    public let createdDateTime: Date?
    /// <p>The Directory ID of an AWS Directory Service directory that will publish status messages to an SNS topic.</p>
    public let directoryId: String?
    /// <p>The topic registration status.</p>
    public let status: TopicStatus?
    /// <p>The SNS topic ARN (Amazon Resource Name).</p>
    public let topicArn: String?
    /// <p>The name of an AWS SNS topic the receives status messages from the directory.</p>
    public let topicName: String?

    public init (
        createdDateTime: Date? = nil,
        directoryId: String? = nil,
        status: TopicStatus? = nil,
        topicArn: String? = nil,
        topicName: String? = nil
    )
    {
        self.createdDateTime = createdDateTime
        self.directoryId = directoryId
        self.status = status
        self.topicArn = topicArn
        self.topicName = topicName
    }
}

extension GetDirectoryLimitsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDirectoryLimitsInput()"}
}

extension GetDirectoryLimitsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetDirectoryLimitsInputHeadersMiddleware: Middleware {
    public let id: String = "GetDirectoryLimitsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDirectoryLimitsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDirectoryLimitsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDirectoryLimitsInput>
    public typealias MOutput = OperationOutput<GetDirectoryLimitsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDirectoryLimitsOutputError>
}

public struct GetDirectoryLimitsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetDirectoryLimitsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDirectoryLimitsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDirectoryLimitsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDirectoryLimitsInput>
    public typealias MOutput = OperationOutput<GetDirectoryLimitsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDirectoryLimitsOutputError>
}

/// <p>Contains the inputs for the <a>GetDirectoryLimits</a> operation.</p>
public struct GetDirectoryLimitsInput: Equatable {

    public init() {}
}

struct GetDirectoryLimitsInputBody: Equatable {
}

extension GetDirectoryLimitsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetDirectoryLimitsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDirectoryLimitsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityDoesNotExistException" : self = .entityDoesNotExistException(try EntityDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDirectoryLimitsOutputError: Equatable {
    case clientException(ClientException)
    case entityDoesNotExistException(EntityDoesNotExistException)
    case serviceException(ServiceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDirectoryLimitsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDirectoryLimitsOutputResponse(directoryLimits: \(String(describing: directoryLimits)))"}
}

extension GetDirectoryLimitsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetDirectoryLimitsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.directoryLimits = output.directoryLimits
        } else {
            self.directoryLimits = nil
        }
    }
}

/// <p>Contains the results of the <a>GetDirectoryLimits</a> operation.</p>
public struct GetDirectoryLimitsOutputResponse: Equatable {
    /// <p>A <a>DirectoryLimits</a> object that contains the directory limits for the
    ///       current rRegion.</p>
    public let directoryLimits: DirectoryLimits?

    public init (
        directoryLimits: DirectoryLimits? = nil
    )
    {
        self.directoryLimits = directoryLimits
    }
}

struct GetDirectoryLimitsOutputResponseBody: Equatable {
    public let directoryLimits: DirectoryLimits?
}

extension GetDirectoryLimitsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case directoryLimits = "DirectoryLimits"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryLimitsDecoded = try containerValues.decodeIfPresent(DirectoryLimits.self, forKey: .directoryLimits)
        directoryLimits = directoryLimitsDecoded
    }
}

public struct GetSnapshotLimitsInputBodyMiddleware: Middleware {
    public let id: String = "GetSnapshotLimitsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSnapshotLimitsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSnapshotLimitsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSnapshotLimitsInput>
    public typealias MOutput = OperationOutput<GetSnapshotLimitsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSnapshotLimitsOutputError>
}

extension GetSnapshotLimitsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSnapshotLimitsInput(directoryId: \(String(describing: directoryId)))"}
}

extension GetSnapshotLimitsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case directoryId = "DirectoryId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryId = directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
    }
}

public struct GetSnapshotLimitsInputHeadersMiddleware: Middleware {
    public let id: String = "GetSnapshotLimitsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSnapshotLimitsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSnapshotLimitsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSnapshotLimitsInput>
    public typealias MOutput = OperationOutput<GetSnapshotLimitsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSnapshotLimitsOutputError>
}

public struct GetSnapshotLimitsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetSnapshotLimitsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSnapshotLimitsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSnapshotLimitsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSnapshotLimitsInput>
    public typealias MOutput = OperationOutput<GetSnapshotLimitsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSnapshotLimitsOutputError>
}

/// <p>Contains the inputs for the <a>GetSnapshotLimits</a> operation.</p>
public struct GetSnapshotLimitsInput: Equatable {
    /// <p>Contains the identifier of the directory to obtain the limits for.</p>
    public let directoryId: String?

    public init (
        directoryId: String? = nil
    )
    {
        self.directoryId = directoryId
    }
}

struct GetSnapshotLimitsInputBody: Equatable {
    public let directoryId: String?
}

extension GetSnapshotLimitsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case directoryId = "DirectoryId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
    }
}

extension GetSnapshotLimitsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSnapshotLimitsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityDoesNotExistException" : self = .entityDoesNotExistException(try EntityDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetSnapshotLimitsOutputError: Equatable {
    case clientException(ClientException)
    case entityDoesNotExistException(EntityDoesNotExistException)
    case serviceException(ServiceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSnapshotLimitsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSnapshotLimitsOutputResponse(snapshotLimits: \(String(describing: snapshotLimits)))"}
}

extension GetSnapshotLimitsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetSnapshotLimitsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.snapshotLimits = output.snapshotLimits
        } else {
            self.snapshotLimits = nil
        }
    }
}

/// <p>Contains the results of the <a>GetSnapshotLimits</a> operation.</p>
public struct GetSnapshotLimitsOutputResponse: Equatable {
    /// <p>A <a>SnapshotLimits</a> object that contains the manual snapshot limits for the specified
    ///          directory.</p>
    public let snapshotLimits: SnapshotLimits?

    public init (
        snapshotLimits: SnapshotLimits? = nil
    )
    {
        self.snapshotLimits = snapshotLimits
    }
}

struct GetSnapshotLimitsOutputResponseBody: Equatable {
    public let snapshotLimits: SnapshotLimits?
}

extension GetSnapshotLimitsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case snapshotLimits = "SnapshotLimits"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snapshotLimitsDecoded = try containerValues.decodeIfPresent(SnapshotLimits.self, forKey: .snapshotLimits)
        snapshotLimits = snapshotLimitsDecoded
    }
}

extension InsufficientPermissionsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InsufficientPermissionsException(message: \(String(describing: message)), requestId: \(String(describing: requestId)))"}
}

extension InsufficientPermissionsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InsufficientPermissionsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.requestId = output.requestId
        } else {
            self.message = nil
            self.requestId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The account does not have sufficient permission to perform the operation.</p>
public struct InsufficientPermissionsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The descriptive message for the exception.</p>
    public var message: String?
    /// <p>The AWS request identifier.</p>
    public var requestId: String?

    public init (
        message: String? = nil,
        requestId: String? = nil
    )
    {
        self.message = message
        self.requestId = requestId
    }
}

struct InsufficientPermissionsExceptionBody: Equatable {
    public let message: String?
    public let requestId: String?
}

extension InsufficientPermissionsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case requestId = "RequestId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension InvalidCertificateException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidCertificateException(message: \(String(describing: message)), requestId: \(String(describing: requestId)))"}
}

extension InvalidCertificateException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidCertificateExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.requestId = output.requestId
        } else {
            self.message = nil
            self.requestId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The certificate PEM that was provided has incorrect encoding.</p>
public struct InvalidCertificateException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The descriptive message for the exception.</p>
    public var message: String?
    /// <p>The AWS request identifier.</p>
    public var requestId: String?

    public init (
        message: String? = nil,
        requestId: String? = nil
    )
    {
        self.message = message
        self.requestId = requestId
    }
}

struct InvalidCertificateExceptionBody: Equatable {
    public let message: String?
    public let requestId: String?
}

extension InvalidCertificateExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case requestId = "RequestId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension InvalidClientAuthStatusException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidClientAuthStatusException(message: \(String(describing: message)), requestId: \(String(describing: requestId)))"}
}

extension InvalidClientAuthStatusException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidClientAuthStatusExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.requestId = output.requestId
        } else {
            self.message = nil
            self.requestId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Client authentication is already enabled.</p>
public struct InvalidClientAuthStatusException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The descriptive message for the exception.</p>
    public var message: String?
    /// <p>The AWS request identifier.</p>
    public var requestId: String?

    public init (
        message: String? = nil,
        requestId: String? = nil
    )
    {
        self.message = message
        self.requestId = requestId
    }
}

struct InvalidClientAuthStatusExceptionBody: Equatable {
    public let message: String?
    public let requestId: String?
}

extension InvalidClientAuthStatusExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case requestId = "RequestId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension InvalidLDAPSStatusException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidLDAPSStatusException(message: \(String(describing: message)), requestId: \(String(describing: requestId)))"}
}

extension InvalidLDAPSStatusException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidLDAPSStatusExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.requestId = output.requestId
        } else {
            self.message = nil
            self.requestId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The LDAP activities could not be performed because they are limited by the LDAPS
///       status.</p>
public struct InvalidLDAPSStatusException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The descriptive message for the exception.</p>
    public var message: String?
    /// <p>The AWS request identifier.</p>
    public var requestId: String?

    public init (
        message: String? = nil,
        requestId: String? = nil
    )
    {
        self.message = message
        self.requestId = requestId
    }
}

struct InvalidLDAPSStatusExceptionBody: Equatable {
    public let message: String?
    public let requestId: String?
}

extension InvalidLDAPSStatusExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case requestId = "RequestId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension InvalidNextTokenException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidNextTokenException(message: \(String(describing: message)), requestId: \(String(describing: requestId)))"}
}

extension InvalidNextTokenException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidNextTokenExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.requestId = output.requestId
        } else {
            self.message = nil
            self.requestId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The <code>NextToken</code> value is not valid.</p>
public struct InvalidNextTokenException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The descriptive message for the exception.</p>
    public var message: String?
    /// <p>The AWS request identifier.</p>
    public var requestId: String?

    public init (
        message: String? = nil,
        requestId: String? = nil
    )
    {
        self.message = message
        self.requestId = requestId
    }
}

struct InvalidNextTokenExceptionBody: Equatable {
    public let message: String?
    public let requestId: String?
}

extension InvalidNextTokenExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case requestId = "RequestId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension InvalidParameterException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidParameterException(message: \(String(describing: message)), requestId: \(String(describing: requestId)))"}
}

extension InvalidParameterException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidParameterExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.requestId = output.requestId
        } else {
            self.message = nil
            self.requestId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>One or more parameters are not valid.</p>
public struct InvalidParameterException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The descriptive message for the exception.</p>
    public var message: String?
    /// <p>The AWS request identifier.</p>
    public var requestId: String?

    public init (
        message: String? = nil,
        requestId: String? = nil
    )
    {
        self.message = message
        self.requestId = requestId
    }
}

struct InvalidParameterExceptionBody: Equatable {
    public let message: String?
    public let requestId: String?
}

extension InvalidParameterExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case requestId = "RequestId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension InvalidPasswordException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidPasswordException(message: \(String(describing: message)), requestId: \(String(describing: requestId)))"}
}

extension InvalidPasswordException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidPasswordExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.requestId = output.requestId
        } else {
            self.message = nil
            self.requestId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The new password provided by the user does not meet the password complexity requirements defined in your directory.</p>
public struct InvalidPasswordException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The descriptive message for the exception.</p>
    public var message: String?
    /// <p>The AWS request identifier.</p>
    public var requestId: String?

    public init (
        message: String? = nil,
        requestId: String? = nil
    )
    {
        self.message = message
        self.requestId = requestId
    }
}

struct InvalidPasswordExceptionBody: Equatable {
    public let message: String?
    public let requestId: String?
}

extension InvalidPasswordExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case requestId = "RequestId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension InvalidTargetException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidTargetException(message: \(String(describing: message)), requestId: \(String(describing: requestId)))"}
}

extension InvalidTargetException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidTargetExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.requestId = output.requestId
        } else {
            self.message = nil
            self.requestId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified shared target is not valid.</p>
public struct InvalidTargetException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The descriptive message for the exception.</p>
    public var message: String?
    /// <p>The AWS request identifier.</p>
    public var requestId: String?

    public init (
        message: String? = nil,
        requestId: String? = nil
    )
    {
        self.message = message
        self.requestId = requestId
    }
}

struct InvalidTargetExceptionBody: Equatable {
    public let message: String?
    public let requestId: String?
}

extension InvalidTargetExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case requestId = "RequestId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension IpRoute: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cidrIp = "CidrIp"
        case description = "Description"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cidrIp = cidrIp {
            try encodeContainer.encode(cidrIp, forKey: .cidrIp)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cidrIpDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cidrIp)
        cidrIp = cidrIpDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension IpRoute: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IpRoute(cidrIp: \(String(describing: cidrIp)), description: \(String(describing: description)))"}
}

/// <p>IP address block. This is often the address block of the DNS server used for your on-premises domain. </p>
public struct IpRoute: Equatable {
    /// <p>IP address block using CIDR format, for example 10.0.0.0/24. This is often the address block of the DNS server used for your on-premises domain. For a single IP address use a CIDR address block with /32. For example 10.0.0.0/32.</p>
    public let cidrIp: String?
    /// <p>Description of the address block.</p>
    public let description: String?

    public init (
        cidrIp: String? = nil,
        description: String? = nil
    )
    {
        self.cidrIp = cidrIp
        self.description = description
    }
}

extension IpRouteInfo: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case addedDateTime = "AddedDateTime"
        case cidrIp = "CidrIp"
        case description = "Description"
        case directoryId = "DirectoryId"
        case ipRouteStatusMsg = "IpRouteStatusMsg"
        case ipRouteStatusReason = "IpRouteStatusReason"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addedDateTime = addedDateTime {
            try encodeContainer.encode(addedDateTime.timeIntervalSince1970, forKey: .addedDateTime)
        }
        if let cidrIp = cidrIp {
            try encodeContainer.encode(cidrIp, forKey: .cidrIp)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let directoryId = directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let ipRouteStatusMsg = ipRouteStatusMsg {
            try encodeContainer.encode(ipRouteStatusMsg.rawValue, forKey: .ipRouteStatusMsg)
        }
        if let ipRouteStatusReason = ipRouteStatusReason {
            try encodeContainer.encode(ipRouteStatusReason, forKey: .ipRouteStatusReason)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let cidrIpDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cidrIp)
        cidrIp = cidrIpDecoded
        let ipRouteStatusMsgDecoded = try containerValues.decodeIfPresent(IpRouteStatusMsg.self, forKey: .ipRouteStatusMsg)
        ipRouteStatusMsg = ipRouteStatusMsgDecoded
        let addedDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .addedDateTime)
        addedDateTime = addedDateTimeDecoded
        let ipRouteStatusReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ipRouteStatusReason)
        ipRouteStatusReason = ipRouteStatusReasonDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension IpRouteInfo: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IpRouteInfo(addedDateTime: \(String(describing: addedDateTime)), cidrIp: \(String(describing: cidrIp)), description: \(String(describing: description)), directoryId: \(String(describing: directoryId)), ipRouteStatusMsg: \(String(describing: ipRouteStatusMsg)), ipRouteStatusReason: \(String(describing: ipRouteStatusReason)))"}
}

/// <p>Information about one or more IP address blocks.</p>
public struct IpRouteInfo: Equatable {
    /// <p>The date and time the address block was added to the directory.</p>
    public let addedDateTime: Date?
    /// <p>IP address block in the <a>IpRoute</a>.</p>
    public let cidrIp: String?
    /// <p>Description of the <a>IpRouteInfo</a>.</p>
    public let description: String?
    /// <p>Identifier (ID) of the directory associated with the IP addresses.</p>
    public let directoryId: String?
    /// <p>The status of the IP address block.</p>
    public let ipRouteStatusMsg: IpRouteStatusMsg?
    /// <p>The reason for the IpRouteStatusMsg.</p>
    public let ipRouteStatusReason: String?

    public init (
        addedDateTime: Date? = nil,
        cidrIp: String? = nil,
        description: String? = nil,
        directoryId: String? = nil,
        ipRouteStatusMsg: IpRouteStatusMsg? = nil,
        ipRouteStatusReason: String? = nil
    )
    {
        self.addedDateTime = addedDateTime
        self.cidrIp = cidrIp
        self.description = description
        self.directoryId = directoryId
        self.ipRouteStatusMsg = ipRouteStatusMsg
        self.ipRouteStatusReason = ipRouteStatusReason
    }
}

extension IpRouteLimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IpRouteLimitExceededException(message: \(String(describing: message)), requestId: \(String(describing: requestId)))"}
}

extension IpRouteLimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: IpRouteLimitExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.requestId = output.requestId
        } else {
            self.message = nil
            self.requestId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The maximum allowed number of IP addresses was exceeded. The default limit is 100 IP address blocks.</p>
public struct IpRouteLimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The descriptive message for the exception.</p>
    public var message: String?
    /// <p>The AWS request identifier.</p>
    public var requestId: String?

    public init (
        message: String? = nil,
        requestId: String? = nil
    )
    {
        self.message = message
        self.requestId = requestId
    }
}

struct IpRouteLimitExceededExceptionBody: Equatable {
    public let message: String?
    public let requestId: String?
}

extension IpRouteLimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case requestId = "RequestId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

public enum IpRouteStatusMsg {
    case added
    case adding
    case addFailed
    case removed
    case removeFailed
    case removing
    case sdkUnknown(String)
}

extension IpRouteStatusMsg : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [IpRouteStatusMsg] {
        return [
            .added,
            .adding,
            .addFailed,
            .removed,
            .removeFailed,
            .removing,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .added: return "Added"
        case .adding: return "Adding"
        case .addFailed: return "AddFailed"
        case .removed: return "Removed"
        case .removeFailed: return "RemoveFailed"
        case .removing: return "Removing"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = IpRouteStatusMsg(rawValue: rawValue) ?? IpRouteStatusMsg.sdkUnknown(rawValue)
    }
}

extension LDAPSSettingInfo: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case lDAPSStatus = "LDAPSStatus"
        case lDAPSStatusReason = "LDAPSStatusReason"
        case lastUpdatedDateTime = "LastUpdatedDateTime"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lDAPSStatus = lDAPSStatus {
            try encodeContainer.encode(lDAPSStatus.rawValue, forKey: .lDAPSStatus)
        }
        if let lDAPSStatusReason = lDAPSStatusReason {
            try encodeContainer.encode(lDAPSStatusReason, forKey: .lDAPSStatusReason)
        }
        if let lastUpdatedDateTime = lastUpdatedDateTime {
            try encodeContainer.encode(lastUpdatedDateTime.timeIntervalSince1970, forKey: .lastUpdatedDateTime)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lDAPSStatusDecoded = try containerValues.decodeIfPresent(LDAPSStatus.self, forKey: .lDAPSStatus)
        lDAPSStatus = lDAPSStatusDecoded
        let lDAPSStatusReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lDAPSStatusReason)
        lDAPSStatusReason = lDAPSStatusReasonDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
    }
}

extension LDAPSSettingInfo: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LDAPSSettingInfo(lDAPSStatus: \(String(describing: lDAPSStatus)), lDAPSStatusReason: \(String(describing: lDAPSStatusReason)), lastUpdatedDateTime: \(String(describing: lastUpdatedDateTime)))"}
}

/// <p>Contains general information about the LDAPS settings.</p>
public struct LDAPSSettingInfo: Equatable {
    /// <p>The state of the LDAPS settings.</p>
    public let lDAPSStatus: LDAPSStatus?
    /// <p>Describes a state change for LDAPS.</p>
    public let lDAPSStatusReason: String?
    /// <p>The date and time when the LDAPS settings were last updated.</p>
    public let lastUpdatedDateTime: Date?

    public init (
        lDAPSStatus: LDAPSStatus? = nil,
        lDAPSStatusReason: String? = nil,
        lastUpdatedDateTime: Date? = nil
    )
    {
        self.lDAPSStatus = lDAPSStatus
        self.lDAPSStatusReason = lDAPSStatusReason
        self.lastUpdatedDateTime = lastUpdatedDateTime
    }
}

public enum LDAPSStatus {
    case disabled
    case enabled
    case enableFailed
    case enabling
    case sdkUnknown(String)
}

extension LDAPSStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [LDAPSStatus] {
        return [
            .disabled,
            .enabled,
            .enableFailed,
            .enabling,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .disabled: return "Disabled"
        case .enabled: return "Enabled"
        case .enableFailed: return "EnableFailed"
        case .enabling: return "Enabling"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = LDAPSStatus(rawValue: rawValue) ?? LDAPSStatus.sdkUnknown(rawValue)
    }
}

public enum LDAPSType {
    case client
    case sdkUnknown(String)
}

extension LDAPSType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [LDAPSType] {
        return [
            .client,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .client: return "Client"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = LDAPSType(rawValue: rawValue) ?? LDAPSType.sdkUnknown(rawValue)
    }
}

public struct ListCertificatesInputBodyMiddleware: Middleware {
    public let id: String = "ListCertificatesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListCertificatesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListCertificatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListCertificatesInput>
    public typealias MOutput = OperationOutput<ListCertificatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListCertificatesOutputError>
}

extension ListCertificatesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListCertificatesInput(directoryId: \(String(describing: directoryId)), limit: \(String(describing: limit)), nextToken: \(String(describing: nextToken)))"}
}

extension ListCertificatesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case directoryId = "DirectoryId"
        case limit = "Limit"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryId = directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let limit = limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListCertificatesInputHeadersMiddleware: Middleware {
    public let id: String = "ListCertificatesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListCertificatesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListCertificatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListCertificatesInput>
    public typealias MOutput = OperationOutput<ListCertificatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListCertificatesOutputError>
}

public struct ListCertificatesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListCertificatesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListCertificatesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListCertificatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListCertificatesInput>
    public typealias MOutput = OperationOutput<ListCertificatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListCertificatesOutputError>
}

public struct ListCertificatesInput: Equatable {
    /// <p>The identifier of the directory.</p>
    public let directoryId: String?
    /// <p>The number of items that should show up on one page</p>
    public let limit: Int?
    /// <p>A token for requesting another page of certificates if the <code>NextToken</code> response
    ///       element indicates that more certificates are available. Use the value of the returned
    ///         <code>NextToken</code> element in your request until the token comes back as
    ///         <code>null</code>. Pass <code>null</code> if this is the first call.</p>
    public let nextToken: String?

    public init (
        directoryId: String? = nil,
        limit: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.directoryId = directoryId
        self.limit = limit
        self.nextToken = nextToken
    }
}

struct ListCertificatesInputBody: Equatable {
    public let directoryId: String?
    public let nextToken: String?
    public let limit: Int?
}

extension ListCertificatesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case directoryId = "DirectoryId"
        case limit = "Limit"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .limit)
        limit = limitDecoded
    }
}

extension ListCertificatesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListCertificatesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryDoesNotExistException" : self = .directoryDoesNotExistException(try DirectoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListCertificatesOutputError: Equatable {
    case clientException(ClientException)
    case directoryDoesNotExistException(DirectoryDoesNotExistException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterException(InvalidParameterException)
    case serviceException(ServiceException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListCertificatesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListCertificatesOutputResponse(certificatesInfo: \(String(describing: certificatesInfo)), nextToken: \(String(describing: nextToken)))"}
}

extension ListCertificatesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListCertificatesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.certificatesInfo = output.certificatesInfo
            self.nextToken = output.nextToken
        } else {
            self.certificatesInfo = nil
            self.nextToken = nil
        }
    }
}

public struct ListCertificatesOutputResponse: Equatable {
    /// <p>A list of certificates with basic details including certificate ID, certificate common
    ///       name, certificate state.</p>
    public let certificatesInfo: [CertificateInfo]?
    /// <p>Indicates whether another page of certificates is available when the number of available
    ///       certificates exceeds the page limit.</p>
    public let nextToken: String?

    public init (
        certificatesInfo: [CertificateInfo]? = nil,
        nextToken: String? = nil
    )
    {
        self.certificatesInfo = certificatesInfo
        self.nextToken = nextToken
    }
}

struct ListCertificatesOutputResponseBody: Equatable {
    public let nextToken: String?
    public let certificatesInfo: [CertificateInfo]?
}

extension ListCertificatesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case certificatesInfo = "CertificatesInfo"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let certificatesInfoContainer = try containerValues.decodeIfPresent([CertificateInfo?].self, forKey: .certificatesInfo)
        var certificatesInfoDecoded0:[CertificateInfo]? = nil
        if let certificatesInfoContainer = certificatesInfoContainer {
            certificatesInfoDecoded0 = [CertificateInfo]()
            for structure0 in certificatesInfoContainer {
                if let structure0 = structure0 {
                    certificatesInfoDecoded0?.append(structure0)
                }
            }
        }
        certificatesInfo = certificatesInfoDecoded0
    }
}

public struct ListIpRoutesInputBodyMiddleware: Middleware {
    public let id: String = "ListIpRoutesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListIpRoutesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListIpRoutesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListIpRoutesInput>
    public typealias MOutput = OperationOutput<ListIpRoutesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListIpRoutesOutputError>
}

extension ListIpRoutesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListIpRoutesInput(directoryId: \(String(describing: directoryId)), limit: \(String(describing: limit)), nextToken: \(String(describing: nextToken)))"}
}

extension ListIpRoutesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case directoryId = "DirectoryId"
        case limit = "Limit"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryId = directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let limit = limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListIpRoutesInputHeadersMiddleware: Middleware {
    public let id: String = "ListIpRoutesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListIpRoutesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListIpRoutesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListIpRoutesInput>
    public typealias MOutput = OperationOutput<ListIpRoutesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListIpRoutesOutputError>
}

public struct ListIpRoutesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListIpRoutesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListIpRoutesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListIpRoutesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListIpRoutesInput>
    public typealias MOutput = OperationOutput<ListIpRoutesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListIpRoutesOutputError>
}

public struct ListIpRoutesInput: Equatable {
    /// <p>Identifier (ID) of the directory for which you want to retrieve the IP addresses.</p>
    public let directoryId: String?
    /// <p>Maximum number of items to return. If this value is zero, the maximum number of items is specified by the limitations of the operation.</p>
    public let limit: Int?
    /// <p>The <i>ListIpRoutes.NextToken</i> value from a previous call to
    ///          <a>ListIpRoutes</a>. Pass null if this is the first call.</p>
    public let nextToken: String?

    public init (
        directoryId: String? = nil,
        limit: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.directoryId = directoryId
        self.limit = limit
        self.nextToken = nextToken
    }
}

struct ListIpRoutesInputBody: Equatable {
    public let directoryId: String?
    public let nextToken: String?
    public let limit: Int?
}

extension ListIpRoutesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case directoryId = "DirectoryId"
        case limit = "Limit"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .limit)
        limit = limitDecoded
    }
}

extension ListIpRoutesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListIpRoutesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityDoesNotExistException" : self = .entityDoesNotExistException(try EntityDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListIpRoutesOutputError: Equatable {
    case clientException(ClientException)
    case entityDoesNotExistException(EntityDoesNotExistException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterException(InvalidParameterException)
    case serviceException(ServiceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListIpRoutesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListIpRoutesOutputResponse(ipRoutesInfo: \(String(describing: ipRoutesInfo)), nextToken: \(String(describing: nextToken)))"}
}

extension ListIpRoutesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListIpRoutesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.ipRoutesInfo = output.ipRoutesInfo
            self.nextToken = output.nextToken
        } else {
            self.ipRoutesInfo = nil
            self.nextToken = nil
        }
    }
}

public struct ListIpRoutesOutputResponse: Equatable {
    /// <p>A list of <a>IpRoute</a>s.</p>
    public let ipRoutesInfo: [IpRouteInfo]?
    /// <p>If not null, more results are available. Pass this value for the <i>NextToken</i> parameter
    ///          in a subsequent call to <a>ListIpRoutes</a> to retrieve the next set of items.</p>
    public let nextToken: String?

    public init (
        ipRoutesInfo: [IpRouteInfo]? = nil,
        nextToken: String? = nil
    )
    {
        self.ipRoutesInfo = ipRoutesInfo
        self.nextToken = nextToken
    }
}

struct ListIpRoutesOutputResponseBody: Equatable {
    public let ipRoutesInfo: [IpRouteInfo]?
    public let nextToken: String?
}

extension ListIpRoutesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case ipRoutesInfo = "IpRoutesInfo"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ipRoutesInfoContainer = try containerValues.decodeIfPresent([IpRouteInfo?].self, forKey: .ipRoutesInfo)
        var ipRoutesInfoDecoded0:[IpRouteInfo]? = nil
        if let ipRoutesInfoContainer = ipRoutesInfoContainer {
            ipRoutesInfoDecoded0 = [IpRouteInfo]()
            for structure0 in ipRoutesInfoContainer {
                if let structure0 = structure0 {
                    ipRoutesInfoDecoded0?.append(structure0)
                }
            }
        }
        ipRoutesInfo = ipRoutesInfoDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListLogSubscriptionsInputBodyMiddleware: Middleware {
    public let id: String = "ListLogSubscriptionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListLogSubscriptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListLogSubscriptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListLogSubscriptionsInput>
    public typealias MOutput = OperationOutput<ListLogSubscriptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListLogSubscriptionsOutputError>
}

extension ListLogSubscriptionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListLogSubscriptionsInput(directoryId: \(String(describing: directoryId)), limit: \(String(describing: limit)), nextToken: \(String(describing: nextToken)))"}
}

extension ListLogSubscriptionsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case directoryId = "DirectoryId"
        case limit = "Limit"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryId = directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let limit = limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListLogSubscriptionsInputHeadersMiddleware: Middleware {
    public let id: String = "ListLogSubscriptionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListLogSubscriptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListLogSubscriptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListLogSubscriptionsInput>
    public typealias MOutput = OperationOutput<ListLogSubscriptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListLogSubscriptionsOutputError>
}

public struct ListLogSubscriptionsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListLogSubscriptionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListLogSubscriptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListLogSubscriptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListLogSubscriptionsInput>
    public typealias MOutput = OperationOutput<ListLogSubscriptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListLogSubscriptionsOutputError>
}

public struct ListLogSubscriptionsInput: Equatable {
    /// <p>If a <i>DirectoryID</i> is provided, lists only the log subscription
    ///       associated with that directory. If no <i>DirectoryId</i> is provided, lists all
    ///       log subscriptions associated with your AWS account. If there are no log subscriptions for the
    ///       AWS account or the directory, an empty list will be returned.</p>
    public let directoryId: String?
    /// <p>The maximum number of items returned.</p>
    public let limit: Int?
    /// <p>The token for the next set of items to return.</p>
    public let nextToken: String?

    public init (
        directoryId: String? = nil,
        limit: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.directoryId = directoryId
        self.limit = limit
        self.nextToken = nextToken
    }
}

struct ListLogSubscriptionsInputBody: Equatable {
    public let directoryId: String?
    public let nextToken: String?
    public let limit: Int?
}

extension ListLogSubscriptionsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case directoryId = "DirectoryId"
        case limit = "Limit"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .limit)
        limit = limitDecoded
    }
}

extension ListLogSubscriptionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListLogSubscriptionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityDoesNotExistException" : self = .entityDoesNotExistException(try EntityDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListLogSubscriptionsOutputError: Equatable {
    case clientException(ClientException)
    case entityDoesNotExistException(EntityDoesNotExistException)
    case invalidNextTokenException(InvalidNextTokenException)
    case serviceException(ServiceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListLogSubscriptionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListLogSubscriptionsOutputResponse(logSubscriptions: \(String(describing: logSubscriptions)), nextToken: \(String(describing: nextToken)))"}
}

extension ListLogSubscriptionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListLogSubscriptionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.logSubscriptions = output.logSubscriptions
            self.nextToken = output.nextToken
        } else {
            self.logSubscriptions = nil
            self.nextToken = nil
        }
    }
}

public struct ListLogSubscriptionsOutputResponse: Equatable {
    /// <p>A list of active <a>LogSubscription</a> objects for calling the AWS
    ///       account.</p>
    public let logSubscriptions: [LogSubscription]?
    /// <p>The token for the next set of items to return.</p>
    public let nextToken: String?

    public init (
        logSubscriptions: [LogSubscription]? = nil,
        nextToken: String? = nil
    )
    {
        self.logSubscriptions = logSubscriptions
        self.nextToken = nextToken
    }
}

struct ListLogSubscriptionsOutputResponseBody: Equatable {
    public let logSubscriptions: [LogSubscription]?
    public let nextToken: String?
}

extension ListLogSubscriptionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case logSubscriptions = "LogSubscriptions"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let logSubscriptionsContainer = try containerValues.decodeIfPresent([LogSubscription?].self, forKey: .logSubscriptions)
        var logSubscriptionsDecoded0:[LogSubscription]? = nil
        if let logSubscriptionsContainer = logSubscriptionsContainer {
            logSubscriptionsDecoded0 = [LogSubscription]()
            for structure0 in logSubscriptionsContainer {
                if let structure0 = structure0 {
                    logSubscriptionsDecoded0?.append(structure0)
                }
            }
        }
        logSubscriptions = logSubscriptionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListSchemaExtensionsInputBodyMiddleware: Middleware {
    public let id: String = "ListSchemaExtensionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSchemaExtensionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSchemaExtensionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSchemaExtensionsInput>
    public typealias MOutput = OperationOutput<ListSchemaExtensionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSchemaExtensionsOutputError>
}

extension ListSchemaExtensionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListSchemaExtensionsInput(directoryId: \(String(describing: directoryId)), limit: \(String(describing: limit)), nextToken: \(String(describing: nextToken)))"}
}

extension ListSchemaExtensionsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case directoryId = "DirectoryId"
        case limit = "Limit"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryId = directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let limit = limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListSchemaExtensionsInputHeadersMiddleware: Middleware {
    public let id: String = "ListSchemaExtensionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSchemaExtensionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSchemaExtensionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSchemaExtensionsInput>
    public typealias MOutput = OperationOutput<ListSchemaExtensionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSchemaExtensionsOutputError>
}

public struct ListSchemaExtensionsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListSchemaExtensionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSchemaExtensionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSchemaExtensionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSchemaExtensionsInput>
    public typealias MOutput = OperationOutput<ListSchemaExtensionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSchemaExtensionsOutputError>
}

public struct ListSchemaExtensionsInput: Equatable {
    /// <p>The identifier of the directory from which to retrieve the schema extension information.</p>
    public let directoryId: String?
    /// <p>The maximum number of items to return.</p>
    public let limit: Int?
    /// <p>The <code>ListSchemaExtensions.NextToken</code> value from a previous call to <code>ListSchemaExtensions</code>. Pass null if this is the first call.</p>
    public let nextToken: String?

    public init (
        directoryId: String? = nil,
        limit: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.directoryId = directoryId
        self.limit = limit
        self.nextToken = nextToken
    }
}

struct ListSchemaExtensionsInputBody: Equatable {
    public let directoryId: String?
    public let nextToken: String?
    public let limit: Int?
}

extension ListSchemaExtensionsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case directoryId = "DirectoryId"
        case limit = "Limit"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .limit)
        limit = limitDecoded
    }
}

extension ListSchemaExtensionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSchemaExtensionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityDoesNotExistException" : self = .entityDoesNotExistException(try EntityDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListSchemaExtensionsOutputError: Equatable {
    case clientException(ClientException)
    case entityDoesNotExistException(EntityDoesNotExistException)
    case invalidNextTokenException(InvalidNextTokenException)
    case serviceException(ServiceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSchemaExtensionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListSchemaExtensionsOutputResponse(nextToken: \(String(describing: nextToken)), schemaExtensionsInfo: \(String(describing: schemaExtensionsInfo)))"}
}

extension ListSchemaExtensionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListSchemaExtensionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.schemaExtensionsInfo = output.schemaExtensionsInfo
        } else {
            self.nextToken = nil
            self.schemaExtensionsInfo = nil
        }
    }
}

public struct ListSchemaExtensionsOutputResponse: Equatable {
    /// <p>If not null, more results are available. Pass this value for the <code>NextToken</code> parameter in a subsequent call to <code>ListSchemaExtensions</code> to retrieve the next set of items.</p>
    public let nextToken: String?
    /// <p>Information about the schema extensions applied to the directory.</p>
    public let schemaExtensionsInfo: [SchemaExtensionInfo]?

    public init (
        nextToken: String? = nil,
        schemaExtensionsInfo: [SchemaExtensionInfo]? = nil
    )
    {
        self.nextToken = nextToken
        self.schemaExtensionsInfo = schemaExtensionsInfo
    }
}

struct ListSchemaExtensionsOutputResponseBody: Equatable {
    public let schemaExtensionsInfo: [SchemaExtensionInfo]?
    public let nextToken: String?
}

extension ListSchemaExtensionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case schemaExtensionsInfo = "SchemaExtensionsInfo"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaExtensionsInfoContainer = try containerValues.decodeIfPresent([SchemaExtensionInfo?].self, forKey: .schemaExtensionsInfo)
        var schemaExtensionsInfoDecoded0:[SchemaExtensionInfo]? = nil
        if let schemaExtensionsInfoContainer = schemaExtensionsInfoContainer {
            schemaExtensionsInfoDecoded0 = [SchemaExtensionInfo]()
            for structure0 in schemaExtensionsInfoContainer {
                if let structure0 = structure0 {
                    schemaExtensionsInfoDecoded0?.append(structure0)
                }
            }
        }
        schemaExtensionsInfo = schemaExtensionsInfoDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListTagsForResourceInputBodyMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

extension ListTagsForResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceInput(limit: \(String(describing: limit)), nextToken: \(String(describing: nextToken)), resourceId: \(String(describing: resourceId)))"}
}

extension ListTagsForResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case limit = "Limit"
        case nextToken = "NextToken"
        case resourceId = "ResourceId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let limit = limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Equatable {
    /// <p>Reserved for future use.</p>
    public let limit: Int?
    /// <p>Reserved for future use.</p>
    public let nextToken: String?
    /// <p>Identifier (ID) of the directory for which you want to retrieve tags.</p>
    public let resourceId: String?

    public init (
        limit: Int? = nil,
        nextToken: String? = nil,
        resourceId: String? = nil
    )
    {
        self.limit = limit
        self.nextToken = nextToken
        self.resourceId = resourceId
    }
}

struct ListTagsForResourceInputBody: Equatable {
    public let resourceId: String?
    public let nextToken: String?
    public let limit: Int?
}

extension ListTagsForResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case limit = "Limit"
        case nextToken = "NextToken"
        case resourceId = "ResourceId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .limit)
        limit = limitDecoded
    }
}

extension ListTagsForResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityDoesNotExistException" : self = .entityDoesNotExistException(try EntityDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Equatable {
    case clientException(ClientException)
    case entityDoesNotExistException(EntityDoesNotExistException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterException(InvalidParameterException)
    case serviceException(ServiceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceOutputResponse(nextToken: \(String(describing: nextToken)), tags: \(String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.tags = output.tags
        } else {
            self.nextToken = nil
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Equatable {
    /// <p>Reserved for future use.</p>
    public let nextToken: String?
    /// <p>List of tags returned by the ListTagsForResource operation.</p>
    public let tags: [Tag]?

    public init (
        nextToken: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.nextToken = nextToken
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Equatable {
    public let tags: [Tag]?
    public let nextToken: String?
}

extension ListTagsForResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension LogSubscription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case directoryId = "DirectoryId"
        case logGroupName = "LogGroupName"
        case subscriptionCreatedDateTime = "SubscriptionCreatedDateTime"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryId = directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let logGroupName = logGroupName {
            try encodeContainer.encode(logGroupName, forKey: .logGroupName)
        }
        if let subscriptionCreatedDateTime = subscriptionCreatedDateTime {
            try encodeContainer.encode(subscriptionCreatedDateTime.timeIntervalSince1970, forKey: .subscriptionCreatedDateTime)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let logGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .logGroupName)
        logGroupName = logGroupNameDecoded
        let subscriptionCreatedDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .subscriptionCreatedDateTime)
        subscriptionCreatedDateTime = subscriptionCreatedDateTimeDecoded
    }
}

extension LogSubscription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LogSubscription(directoryId: \(String(describing: directoryId)), logGroupName: \(String(describing: logGroupName)), subscriptionCreatedDateTime: \(String(describing: subscriptionCreatedDateTime)))"}
}

/// <p>Represents a log subscription, which tracks real-time data from a chosen log group to a
///       specified destination.</p>
public struct LogSubscription: Equatable {
    /// <p>Identifier (ID) of the directory that you want to associate with the log
    ///       subscription.</p>
    public let directoryId: String?
    /// <p>The name of the log group.</p>
    public let logGroupName: String?
    /// <p>The date and time that the log subscription was created.</p>
    public let subscriptionCreatedDateTime: Date?

    public init (
        directoryId: String? = nil,
        logGroupName: String? = nil,
        subscriptionCreatedDateTime: Date? = nil
    )
    {
        self.directoryId = directoryId
        self.logGroupName = logGroupName
        self.subscriptionCreatedDateTime = subscriptionCreatedDateTime
    }
}

extension NoAvailableCertificateException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NoAvailableCertificateException(message: \(String(describing: message)), requestId: \(String(describing: requestId)))"}
}

extension NoAvailableCertificateException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: NoAvailableCertificateExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.requestId = output.requestId
        } else {
            self.message = nil
            self.requestId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Client authentication setup could not be completed because at least one valid certificate must be
///       registered in the system.</p>
public struct NoAvailableCertificateException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The descriptive message for the exception.</p>
    public var message: String?
    /// <p>The AWS request identifier.</p>
    public var requestId: String?

    public init (
        message: String? = nil,
        requestId: String? = nil
    )
    {
        self.message = message
        self.requestId = requestId
    }
}

struct NoAvailableCertificateExceptionBody: Equatable {
    public let message: String?
    public let requestId: String?
}

extension NoAvailableCertificateExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case requestId = "RequestId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension OrganizationsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OrganizationsException(message: \(String(describing: message)), requestId: \(String(describing: requestId)))"}
}

extension OrganizationsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: OrganizationsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.requestId = output.requestId
        } else {
            self.message = nil
            self.requestId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Exception encountered while trying to access your AWS organization.</p>
public struct OrganizationsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The descriptive message for the exception.</p>
    public var message: String?
    /// <p>The AWS request identifier.</p>
    public var requestId: String?

    public init (
        message: String? = nil,
        requestId: String? = nil
    )
    {
        self.message = message
        self.requestId = requestId
    }
}

struct OrganizationsExceptionBody: Equatable {
    public let message: String?
    public let requestId: String?
}

extension OrganizationsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case requestId = "RequestId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension OwnerDirectoryDescription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountId = "AccountId"
        case directoryId = "DirectoryId"
        case dnsIpAddrs = "DnsIpAddrs"
        case radiusSettings = "RadiusSettings"
        case radiusStatus = "RadiusStatus"
        case vpcSettings = "VpcSettings"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let directoryId = directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let dnsIpAddrs = dnsIpAddrs {
            var dnsIpAddrsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dnsIpAddrs)
            for dnsipaddrs0 in dnsIpAddrs {
                try dnsIpAddrsContainer.encode(dnsipaddrs0)
            }
        }
        if let radiusSettings = radiusSettings {
            try encodeContainer.encode(radiusSettings, forKey: .radiusSettings)
        }
        if let radiusStatus = radiusStatus {
            try encodeContainer.encode(radiusStatus.rawValue, forKey: .radiusStatus)
        }
        if let vpcSettings = vpcSettings {
            try encodeContainer.encode(vpcSettings, forKey: .vpcSettings)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let dnsIpAddrsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .dnsIpAddrs)
        var dnsIpAddrsDecoded0:[String]? = nil
        if let dnsIpAddrsContainer = dnsIpAddrsContainer {
            dnsIpAddrsDecoded0 = [String]()
            for string0 in dnsIpAddrsContainer {
                if let string0 = string0 {
                    dnsIpAddrsDecoded0?.append(string0)
                }
            }
        }
        dnsIpAddrs = dnsIpAddrsDecoded0
        let vpcSettingsDecoded = try containerValues.decodeIfPresent(DirectoryVpcSettingsDescription.self, forKey: .vpcSettings)
        vpcSettings = vpcSettingsDecoded
        let radiusSettingsDecoded = try containerValues.decodeIfPresent(RadiusSettings.self, forKey: .radiusSettings)
        radiusSettings = radiusSettingsDecoded
        let radiusStatusDecoded = try containerValues.decodeIfPresent(RadiusStatus.self, forKey: .radiusStatus)
        radiusStatus = radiusStatusDecoded
    }
}

extension OwnerDirectoryDescription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OwnerDirectoryDescription(accountId: \(String(describing: accountId)), directoryId: \(String(describing: directoryId)), dnsIpAddrs: \(String(describing: dnsIpAddrs)), radiusSettings: \(String(describing: radiusSettings)), radiusStatus: \(String(describing: radiusStatus)), vpcSettings: \(String(describing: vpcSettings)))"}
}

/// <p>Describes the directory owner account details that have been shared to the directory
///       consumer account.</p>
public struct OwnerDirectoryDescription: Equatable {
    /// <p>Identifier of the directory owner account.</p>
    public let accountId: String?
    /// <p>Identifier of the AWS Managed Microsoft AD directory in the directory owner
    ///       account.</p>
    public let directoryId: String?
    /// <p>IP address of the directory’s domain controllers.</p>
    public let dnsIpAddrs: [String]?
    /// <p>A <a>RadiusSettings</a> object that contains information about the RADIUS
    ///       server.</p>
    public let radiusSettings: RadiusSettings?
    /// <p>Information about the status of the RADIUS server.</p>
    public let radiusStatus: RadiusStatus?
    /// <p>Information about the VPC settings for the directory.</p>
    public let vpcSettings: DirectoryVpcSettingsDescription?

    public init (
        accountId: String? = nil,
        directoryId: String? = nil,
        dnsIpAddrs: [String]? = nil,
        radiusSettings: RadiusSettings? = nil,
        radiusStatus: RadiusStatus? = nil,
        vpcSettings: DirectoryVpcSettingsDescription? = nil
    )
    {
        self.accountId = accountId
        self.directoryId = directoryId
        self.dnsIpAddrs = dnsIpAddrs
        self.radiusSettings = radiusSettings
        self.radiusStatus = radiusStatus
        self.vpcSettings = vpcSettings
    }
}

public enum RadiusAuthenticationProtocol {
    case chap
    case mschapv1
    case mschapv2
    case pap
    case sdkUnknown(String)
}

extension RadiusAuthenticationProtocol : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [RadiusAuthenticationProtocol] {
        return [
            .chap,
            .mschapv1,
            .mschapv2,
            .pap,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .chap: return "CHAP"
        case .mschapv1: return "MS-CHAPv1"
        case .mschapv2: return "MS-CHAPv2"
        case .pap: return "PAP"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = RadiusAuthenticationProtocol(rawValue: rawValue) ?? RadiusAuthenticationProtocol.sdkUnknown(rawValue)
    }
}

extension RadiusSettings: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case authenticationProtocol = "AuthenticationProtocol"
        case displayLabel = "DisplayLabel"
        case radiusPort = "RadiusPort"
        case radiusRetries = "RadiusRetries"
        case radiusServers = "RadiusServers"
        case radiusTimeout = "RadiusTimeout"
        case sharedSecret = "SharedSecret"
        case useSameUsername = "UseSameUsername"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authenticationProtocol = authenticationProtocol {
            try encodeContainer.encode(authenticationProtocol.rawValue, forKey: .authenticationProtocol)
        }
        if let displayLabel = displayLabel {
            try encodeContainer.encode(displayLabel, forKey: .displayLabel)
        }
        if radiusPort != 0 {
            try encodeContainer.encode(radiusPort, forKey: .radiusPort)
        }
        if radiusRetries != 0 {
            try encodeContainer.encode(radiusRetries, forKey: .radiusRetries)
        }
        if let radiusServers = radiusServers {
            var radiusServersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .radiusServers)
            for servers0 in radiusServers {
                try radiusServersContainer.encode(servers0)
            }
        }
        if radiusTimeout != 0 {
            try encodeContainer.encode(radiusTimeout, forKey: .radiusTimeout)
        }
        if let sharedSecret = sharedSecret {
            try encodeContainer.encode(sharedSecret, forKey: .sharedSecret)
        }
        if useSameUsername != false {
            try encodeContainer.encode(useSameUsername, forKey: .useSameUsername)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let radiusServersContainer = try containerValues.decodeIfPresent([String?].self, forKey: .radiusServers)
        var radiusServersDecoded0:[String]? = nil
        if let radiusServersContainer = radiusServersContainer {
            radiusServersDecoded0 = [String]()
            for string0 in radiusServersContainer {
                if let string0 = string0 {
                    radiusServersDecoded0?.append(string0)
                }
            }
        }
        radiusServers = radiusServersDecoded0
        let radiusPortDecoded = try containerValues.decode(Int.self, forKey: .radiusPort)
        radiusPort = radiusPortDecoded
        let radiusTimeoutDecoded = try containerValues.decode(Int.self, forKey: .radiusTimeout)
        radiusTimeout = radiusTimeoutDecoded
        let radiusRetriesDecoded = try containerValues.decode(Int.self, forKey: .radiusRetries)
        radiusRetries = radiusRetriesDecoded
        let sharedSecretDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sharedSecret)
        sharedSecret = sharedSecretDecoded
        let authenticationProtocolDecoded = try containerValues.decodeIfPresent(RadiusAuthenticationProtocol.self, forKey: .authenticationProtocol)
        authenticationProtocol = authenticationProtocolDecoded
        let displayLabelDecoded = try containerValues.decodeIfPresent(String.self, forKey: .displayLabel)
        displayLabel = displayLabelDecoded
        let useSameUsernameDecoded = try containerValues.decode(Bool.self, forKey: .useSameUsername)
        useSameUsername = useSameUsernameDecoded
    }
}

extension RadiusSettings: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RadiusSettings(authenticationProtocol: \(String(describing: authenticationProtocol)), displayLabel: \(String(describing: displayLabel)), radiusPort: \(String(describing: radiusPort)), radiusRetries: \(String(describing: radiusRetries)), radiusServers: \(String(describing: radiusServers)), radiusTimeout: \(String(describing: radiusTimeout)), sharedSecret: \(String(describing: sharedSecret)), useSameUsername: \(String(describing: useSameUsername)))"}
}

/// <p>Contains information about a Remote Authentication Dial In User Service (RADIUS) server.</p>
public struct RadiusSettings: Equatable {
    /// <p>The protocol specified for your RADIUS endpoints.</p>
    public let authenticationProtocol: RadiusAuthenticationProtocol?
    /// <p>Not currently used.</p>
    public let displayLabel: String?
    /// <p>The port that your RADIUS server is using for communications. Your on-premises network must allow inbound traffic over this port from the AWS Directory Service servers.</p>
    public let radiusPort: Int
    /// <p>The maximum number of times that communication with the RADIUS server is attempted.</p>
    public let radiusRetries: Int
    /// <p>An array of strings that contains the fully qualified domain name (FQDN) or IP addresses of the RADIUS server endpoints, or the FQDN or IP addresses of your RADIUS server load balancer.</p>
    public let radiusServers: [String]?
    /// <p>The amount of time, in seconds, to wait for the RADIUS server to respond.</p>
    public let radiusTimeout: Int
    /// <p>Required for enabling RADIUS on the directory.</p>
    public let sharedSecret: String?
    /// <p>Not currently used.</p>
    public let useSameUsername: Bool

    public init (
        authenticationProtocol: RadiusAuthenticationProtocol? = nil,
        displayLabel: String? = nil,
        radiusPort: Int = 0,
        radiusRetries: Int = 0,
        radiusServers: [String]? = nil,
        radiusTimeout: Int = 0,
        sharedSecret: String? = nil,
        useSameUsername: Bool = false
    )
    {
        self.authenticationProtocol = authenticationProtocol
        self.displayLabel = displayLabel
        self.radiusPort = radiusPort
        self.radiusRetries = radiusRetries
        self.radiusServers = radiusServers
        self.radiusTimeout = radiusTimeout
        self.sharedSecret = sharedSecret
        self.useSameUsername = useSameUsername
    }
}

public enum RadiusStatus {
    case completed
    case creating
    case failed
    case sdkUnknown(String)
}

extension RadiusStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [RadiusStatus] {
        return [
            .completed,
            .creating,
            .failed,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .completed: return "Completed"
        case .creating: return "Creating"
        case .failed: return "Failed"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = RadiusStatus(rawValue: rawValue) ?? RadiusStatus.sdkUnknown(rawValue)
    }
}

extension RegionDescription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case desiredNumberOfDomainControllers = "DesiredNumberOfDomainControllers"
        case directoryId = "DirectoryId"
        case lastUpdatedDateTime = "LastUpdatedDateTime"
        case launchTime = "LaunchTime"
        case regionName = "RegionName"
        case regionType = "RegionType"
        case status = "Status"
        case statusLastUpdatedDateTime = "StatusLastUpdatedDateTime"
        case vpcSettings = "VpcSettings"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if desiredNumberOfDomainControllers != 0 {
            try encodeContainer.encode(desiredNumberOfDomainControllers, forKey: .desiredNumberOfDomainControllers)
        }
        if let directoryId = directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let lastUpdatedDateTime = lastUpdatedDateTime {
            try encodeContainer.encode(lastUpdatedDateTime.timeIntervalSince1970, forKey: .lastUpdatedDateTime)
        }
        if let launchTime = launchTime {
            try encodeContainer.encode(launchTime.timeIntervalSince1970, forKey: .launchTime)
        }
        if let regionName = regionName {
            try encodeContainer.encode(regionName, forKey: .regionName)
        }
        if let regionType = regionType {
            try encodeContainer.encode(regionType.rawValue, forKey: .regionType)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusLastUpdatedDateTime = statusLastUpdatedDateTime {
            try encodeContainer.encode(statusLastUpdatedDateTime.timeIntervalSince1970, forKey: .statusLastUpdatedDateTime)
        }
        if let vpcSettings = vpcSettings {
            try encodeContainer.encode(vpcSettings, forKey: .vpcSettings)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let regionNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .regionName)
        regionName = regionNameDecoded
        let regionTypeDecoded = try containerValues.decodeIfPresent(RegionType.self, forKey: .regionType)
        regionType = regionTypeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DirectoryStage.self, forKey: .status)
        status = statusDecoded
        let vpcSettingsDecoded = try containerValues.decodeIfPresent(DirectoryVpcSettings.self, forKey: .vpcSettings)
        vpcSettings = vpcSettingsDecoded
        let desiredNumberOfDomainControllersDecoded = try containerValues.decode(Int.self, forKey: .desiredNumberOfDomainControllers)
        desiredNumberOfDomainControllers = desiredNumberOfDomainControllersDecoded
        let launchTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .launchTime)
        launchTime = launchTimeDecoded
        let statusLastUpdatedDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .statusLastUpdatedDateTime)
        statusLastUpdatedDateTime = statusLastUpdatedDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
    }
}

extension RegionDescription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RegionDescription(desiredNumberOfDomainControllers: \(String(describing: desiredNumberOfDomainControllers)), directoryId: \(String(describing: directoryId)), lastUpdatedDateTime: \(String(describing: lastUpdatedDateTime)), launchTime: \(String(describing: launchTime)), regionName: \(String(describing: regionName)), regionType: \(String(describing: regionType)), status: \(String(describing: status)), statusLastUpdatedDateTime: \(String(describing: statusLastUpdatedDateTime)), vpcSettings: \(String(describing: vpcSettings)))"}
}

/// <p>The replicated Region information for a directory.</p>
public struct RegionDescription: Equatable {
    /// <p>The desired number of domain controllers in the specified Region for the specified
    ///       directory.</p>
    public let desiredNumberOfDomainControllers: Int
    /// <p>The identifier of the directory.</p>
    public let directoryId: String?
    /// <p>The date and time that the Region description was last updated.</p>
    public let lastUpdatedDateTime: Date?
    /// <p>Specifies when the Region replication began.</p>
    public let launchTime: Date?
    /// <p>The name of the Region. For example, <code>us-east-1</code>.</p>
    public let regionName: String?
    /// <p>Specifies whether the Region is the primary Region or an additional Region.</p>
    public let regionType: RegionType?
    /// <p>The status of the replication process for the specified Region.</p>
    public let status: DirectoryStage?
    /// <p>The date and time that the Region status was last updated.</p>
    public let statusLastUpdatedDateTime: Date?
    /// <p>Contains VPC information for the <a>CreateDirectory</a> or <a>CreateMicrosoftAD</a> operation.</p>
    public let vpcSettings: DirectoryVpcSettings?

    public init (
        desiredNumberOfDomainControllers: Int = 0,
        directoryId: String? = nil,
        lastUpdatedDateTime: Date? = nil,
        launchTime: Date? = nil,
        regionName: String? = nil,
        regionType: RegionType? = nil,
        status: DirectoryStage? = nil,
        statusLastUpdatedDateTime: Date? = nil,
        vpcSettings: DirectoryVpcSettings? = nil
    )
    {
        self.desiredNumberOfDomainControllers = desiredNumberOfDomainControllers
        self.directoryId = directoryId
        self.lastUpdatedDateTime = lastUpdatedDateTime
        self.launchTime = launchTime
        self.regionName = regionName
        self.regionType = regionType
        self.status = status
        self.statusLastUpdatedDateTime = statusLastUpdatedDateTime
        self.vpcSettings = vpcSettings
    }
}

extension RegionLimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RegionLimitExceededException(message: \(String(describing: message)), requestId: \(String(describing: requestId)))"}
}

extension RegionLimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RegionLimitExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.requestId = output.requestId
        } else {
            self.message = nil
            self.requestId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You have reached the limit for maximum number of simultaneous Region replications per
///       directory.</p>
public struct RegionLimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The descriptive message for the exception.</p>
    public var message: String?
    /// <p>The AWS request identifier.</p>
    public var requestId: String?

    public init (
        message: String? = nil,
        requestId: String? = nil
    )
    {
        self.message = message
        self.requestId = requestId
    }
}

struct RegionLimitExceededExceptionBody: Equatable {
    public let message: String?
    public let requestId: String?
}

extension RegionLimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case requestId = "RequestId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

public enum RegionType {
    case additional
    case primary
    case sdkUnknown(String)
}

extension RegionType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [RegionType] {
        return [
            .additional,
            .primary,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .additional: return "Additional"
        case .primary: return "Primary"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = RegionType(rawValue: rawValue) ?? RegionType.sdkUnknown(rawValue)
    }
}

extension RegionsInfo: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case additionalRegions = "AdditionalRegions"
        case primaryRegion = "PrimaryRegion"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalRegions = additionalRegions {
            var additionalRegionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .additionalRegions)
            for additionalregions0 in additionalRegions {
                try additionalRegionsContainer.encode(additionalregions0)
            }
        }
        if let primaryRegion = primaryRegion {
            try encodeContainer.encode(primaryRegion, forKey: .primaryRegion)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let primaryRegionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .primaryRegion)
        primaryRegion = primaryRegionDecoded
        let additionalRegionsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .additionalRegions)
        var additionalRegionsDecoded0:[String]? = nil
        if let additionalRegionsContainer = additionalRegionsContainer {
            additionalRegionsDecoded0 = [String]()
            for string0 in additionalRegionsContainer {
                if let string0 = string0 {
                    additionalRegionsDecoded0?.append(string0)
                }
            }
        }
        additionalRegions = additionalRegionsDecoded0
    }
}

extension RegionsInfo: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RegionsInfo(additionalRegions: \(String(describing: additionalRegions)), primaryRegion: \(String(describing: primaryRegion)))"}
}

/// <p>Provides information about the Regions that are configured for multi-Region
///       replication.</p>
public struct RegionsInfo: Equatable {
    /// <p>Lists the Regions where the directory has been replicated, excluding the primary
    ///       Region.</p>
    public let additionalRegions: [String]?
    /// <p>The Region where the AWS Managed Microsoft AD directory was originally created.</p>
    public let primaryRegion: String?

    public init (
        additionalRegions: [String]? = nil,
        primaryRegion: String? = nil
    )
    {
        self.additionalRegions = additionalRegions
        self.primaryRegion = primaryRegion
    }
}

public struct RegisterCertificateInputBodyMiddleware: Middleware {
    public let id: String = "RegisterCertificateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RegisterCertificateInput>,
                  next: H) -> Swift.Result<OperationOutput<RegisterCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RegisterCertificateInput>
    public typealias MOutput = OperationOutput<RegisterCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RegisterCertificateOutputError>
}

extension RegisterCertificateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RegisterCertificateInput(certificateData: \(String(describing: certificateData)), clientCertAuthSettings: \(String(describing: clientCertAuthSettings)), directoryId: \(String(describing: directoryId)), type: \(String(describing: type)))"}
}

extension RegisterCertificateInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case certificateData = "CertificateData"
        case clientCertAuthSettings = "ClientCertAuthSettings"
        case directoryId = "DirectoryId"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateData = certificateData {
            try encodeContainer.encode(certificateData, forKey: .certificateData)
        }
        if let clientCertAuthSettings = clientCertAuthSettings {
            try encodeContainer.encode(clientCertAuthSettings, forKey: .clientCertAuthSettings)
        }
        if let directoryId = directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

public struct RegisterCertificateInputHeadersMiddleware: Middleware {
    public let id: String = "RegisterCertificateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RegisterCertificateInput>,
                  next: H) -> Swift.Result<OperationOutput<RegisterCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RegisterCertificateInput>
    public typealias MOutput = OperationOutput<RegisterCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RegisterCertificateOutputError>
}

public struct RegisterCertificateInputQueryItemMiddleware: Middleware {
    public let id: String = "RegisterCertificateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RegisterCertificateInput>,
                  next: H) -> Swift.Result<OperationOutput<RegisterCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RegisterCertificateInput>
    public typealias MOutput = OperationOutput<RegisterCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RegisterCertificateOutputError>
}

public struct RegisterCertificateInput: Equatable {
    /// <p>The certificate PEM string that needs to be registered.</p>
    public let certificateData: String?
    /// <p>A <code>ClientCertAuthSettings</code> object that contains client certificate authentication settings.</p>
    public let clientCertAuthSettings: ClientCertAuthSettings?
    /// <p>The identifier of the directory.</p>
    public let directoryId: String?
    /// <p>The function that the registered certificate performs. Valid values include <code>ClientLDAPS</code> or <code>ClientCertAuth</code>. The default value is <code>ClientLDAPS</code>.</p>
    public let type: CertificateType?

    public init (
        certificateData: String? = nil,
        clientCertAuthSettings: ClientCertAuthSettings? = nil,
        directoryId: String? = nil,
        type: CertificateType? = nil
    )
    {
        self.certificateData = certificateData
        self.clientCertAuthSettings = clientCertAuthSettings
        self.directoryId = directoryId
        self.type = type
    }
}

struct RegisterCertificateInputBody: Equatable {
    public let directoryId: String?
    public let certificateData: String?
    public let type: CertificateType?
    public let clientCertAuthSettings: ClientCertAuthSettings?
}

extension RegisterCertificateInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case certificateData = "CertificateData"
        case clientCertAuthSettings = "ClientCertAuthSettings"
        case directoryId = "DirectoryId"
        case type = "Type"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let certificateDataDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificateData)
        certificateData = certificateDataDecoded
        let typeDecoded = try containerValues.decodeIfPresent(CertificateType.self, forKey: .type)
        type = typeDecoded
        let clientCertAuthSettingsDecoded = try containerValues.decodeIfPresent(ClientCertAuthSettings.self, forKey: .clientCertAuthSettings)
        clientCertAuthSettings = clientCertAuthSettingsDecoded
    }
}

extension RegisterCertificateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RegisterCertificateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CertificateAlreadyExistsException" : self = .certificateAlreadyExistsException(try CertificateAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CertificateLimitExceededException" : self = .certificateLimitExceededException(try CertificateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryDoesNotExistException" : self = .directoryDoesNotExistException(try DirectoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryUnavailableException" : self = .directoryUnavailableException(try DirectoryUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidCertificateException" : self = .invalidCertificateException(try InvalidCertificateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RegisterCertificateOutputError: Equatable {
    case certificateAlreadyExistsException(CertificateAlreadyExistsException)
    case certificateLimitExceededException(CertificateLimitExceededException)
    case clientException(ClientException)
    case directoryDoesNotExistException(DirectoryDoesNotExistException)
    case directoryUnavailableException(DirectoryUnavailableException)
    case invalidCertificateException(InvalidCertificateException)
    case invalidParameterException(InvalidParameterException)
    case serviceException(ServiceException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RegisterCertificateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RegisterCertificateOutputResponse(certificateId: \(String(describing: certificateId)))"}
}

extension RegisterCertificateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RegisterCertificateOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.certificateId = output.certificateId
        } else {
            self.certificateId = nil
        }
    }
}

public struct RegisterCertificateOutputResponse: Equatable {
    /// <p>The identifier of the certificate.</p>
    public let certificateId: String?

    public init (
        certificateId: String? = nil
    )
    {
        self.certificateId = certificateId
    }
}

struct RegisterCertificateOutputResponseBody: Equatable {
    public let certificateId: String?
}

extension RegisterCertificateOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case certificateId = "CertificateId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificateId)
        certificateId = certificateIdDecoded
    }
}

public struct RegisterEventTopicInputBodyMiddleware: Middleware {
    public let id: String = "RegisterEventTopicInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RegisterEventTopicInput>,
                  next: H) -> Swift.Result<OperationOutput<RegisterEventTopicOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RegisterEventTopicInput>
    public typealias MOutput = OperationOutput<RegisterEventTopicOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RegisterEventTopicOutputError>
}

extension RegisterEventTopicInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RegisterEventTopicInput(directoryId: \(String(describing: directoryId)), topicName: \(String(describing: topicName)))"}
}

extension RegisterEventTopicInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case directoryId = "DirectoryId"
        case topicName = "TopicName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryId = directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let topicName = topicName {
            try encodeContainer.encode(topicName, forKey: .topicName)
        }
    }
}

public struct RegisterEventTopicInputHeadersMiddleware: Middleware {
    public let id: String = "RegisterEventTopicInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RegisterEventTopicInput>,
                  next: H) -> Swift.Result<OperationOutput<RegisterEventTopicOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RegisterEventTopicInput>
    public typealias MOutput = OperationOutput<RegisterEventTopicOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RegisterEventTopicOutputError>
}

public struct RegisterEventTopicInputQueryItemMiddleware: Middleware {
    public let id: String = "RegisterEventTopicInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RegisterEventTopicInput>,
                  next: H) -> Swift.Result<OperationOutput<RegisterEventTopicOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RegisterEventTopicInput>
    public typealias MOutput = OperationOutput<RegisterEventTopicOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RegisterEventTopicOutputError>
}

/// <p>Registers a new event topic.</p>
public struct RegisterEventTopicInput: Equatable {
    /// <p>The Directory ID that will publish status messages to the SNS topic.</p>
    public let directoryId: String?
    /// <p>The SNS topic name to which the directory will publish status messages. This SNS topic must be in the same region as the specified Directory ID.</p>
    public let topicName: String?

    public init (
        directoryId: String? = nil,
        topicName: String? = nil
    )
    {
        self.directoryId = directoryId
        self.topicName = topicName
    }
}

struct RegisterEventTopicInputBody: Equatable {
    public let directoryId: String?
    public let topicName: String?
}

extension RegisterEventTopicInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case directoryId = "DirectoryId"
        case topicName = "TopicName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let topicNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .topicName)
        topicName = topicNameDecoded
    }
}

extension RegisterEventTopicOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RegisterEventTopicOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityDoesNotExistException" : self = .entityDoesNotExistException(try EntityDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RegisterEventTopicOutputError: Equatable {
    case clientException(ClientException)
    case entityDoesNotExistException(EntityDoesNotExistException)
    case invalidParameterException(InvalidParameterException)
    case serviceException(ServiceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RegisterEventTopicOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RegisterEventTopicOutputResponse()"}
}

extension RegisterEventTopicOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>The result of a RegisterEventTopic request.</p>
public struct RegisterEventTopicOutputResponse: Equatable {

    public init() {}
}

struct RegisterEventTopicOutputResponseBody: Equatable {
}

extension RegisterEventTopicOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct RejectSharedDirectoryInputBodyMiddleware: Middleware {
    public let id: String = "RejectSharedDirectoryInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RejectSharedDirectoryInput>,
                  next: H) -> Swift.Result<OperationOutput<RejectSharedDirectoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RejectSharedDirectoryInput>
    public typealias MOutput = OperationOutput<RejectSharedDirectoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RejectSharedDirectoryOutputError>
}

extension RejectSharedDirectoryInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RejectSharedDirectoryInput(sharedDirectoryId: \(String(describing: sharedDirectoryId)))"}
}

extension RejectSharedDirectoryInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case sharedDirectoryId = "SharedDirectoryId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sharedDirectoryId = sharedDirectoryId {
            try encodeContainer.encode(sharedDirectoryId, forKey: .sharedDirectoryId)
        }
    }
}

public struct RejectSharedDirectoryInputHeadersMiddleware: Middleware {
    public let id: String = "RejectSharedDirectoryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RejectSharedDirectoryInput>,
                  next: H) -> Swift.Result<OperationOutput<RejectSharedDirectoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RejectSharedDirectoryInput>
    public typealias MOutput = OperationOutput<RejectSharedDirectoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RejectSharedDirectoryOutputError>
}

public struct RejectSharedDirectoryInputQueryItemMiddleware: Middleware {
    public let id: String = "RejectSharedDirectoryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RejectSharedDirectoryInput>,
                  next: H) -> Swift.Result<OperationOutput<RejectSharedDirectoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RejectSharedDirectoryInput>
    public typealias MOutput = OperationOutput<RejectSharedDirectoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RejectSharedDirectoryOutputError>
}

public struct RejectSharedDirectoryInput: Equatable {
    /// <p>Identifier of the shared directory in the directory consumer account. This identifier is
    ///       different for each directory owner account.</p>
    public let sharedDirectoryId: String?

    public init (
        sharedDirectoryId: String? = nil
    )
    {
        self.sharedDirectoryId = sharedDirectoryId
    }
}

struct RejectSharedDirectoryInputBody: Equatable {
    public let sharedDirectoryId: String?
}

extension RejectSharedDirectoryInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case sharedDirectoryId = "SharedDirectoryId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sharedDirectoryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sharedDirectoryId)
        sharedDirectoryId = sharedDirectoryIdDecoded
    }
}

extension RejectSharedDirectoryOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RejectSharedDirectoryOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryAlreadySharedException" : self = .directoryAlreadySharedException(try DirectoryAlreadySharedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityDoesNotExistException" : self = .entityDoesNotExistException(try EntityDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RejectSharedDirectoryOutputError: Equatable {
    case clientException(ClientException)
    case directoryAlreadySharedException(DirectoryAlreadySharedException)
    case entityDoesNotExistException(EntityDoesNotExistException)
    case invalidParameterException(InvalidParameterException)
    case serviceException(ServiceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RejectSharedDirectoryOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RejectSharedDirectoryOutputResponse(sharedDirectoryId: \(String(describing: sharedDirectoryId)))"}
}

extension RejectSharedDirectoryOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RejectSharedDirectoryOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.sharedDirectoryId = output.sharedDirectoryId
        } else {
            self.sharedDirectoryId = nil
        }
    }
}

public struct RejectSharedDirectoryOutputResponse: Equatable {
    /// <p>Identifier of the shared directory in the directory consumer account.</p>
    public let sharedDirectoryId: String?

    public init (
        sharedDirectoryId: String? = nil
    )
    {
        self.sharedDirectoryId = sharedDirectoryId
    }
}

struct RejectSharedDirectoryOutputResponseBody: Equatable {
    public let sharedDirectoryId: String?
}

extension RejectSharedDirectoryOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case sharedDirectoryId = "SharedDirectoryId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sharedDirectoryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sharedDirectoryId)
        sharedDirectoryId = sharedDirectoryIdDecoded
    }
}

public struct RemoveIpRoutesInputBodyMiddleware: Middleware {
    public let id: String = "RemoveIpRoutesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemoveIpRoutesInput>,
                  next: H) -> Swift.Result<OperationOutput<RemoveIpRoutesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemoveIpRoutesInput>
    public typealias MOutput = OperationOutput<RemoveIpRoutesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemoveIpRoutesOutputError>
}

extension RemoveIpRoutesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RemoveIpRoutesInput(cidrIps: \(String(describing: cidrIps)), directoryId: \(String(describing: directoryId)))"}
}

extension RemoveIpRoutesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cidrIps = "CidrIps"
        case directoryId = "DirectoryId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cidrIps = cidrIps {
            var cidrIpsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .cidrIps)
            for cidrips0 in cidrIps {
                try cidrIpsContainer.encode(cidrips0)
            }
        }
        if let directoryId = directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
    }
}

public struct RemoveIpRoutesInputHeadersMiddleware: Middleware {
    public let id: String = "RemoveIpRoutesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemoveIpRoutesInput>,
                  next: H) -> Swift.Result<OperationOutput<RemoveIpRoutesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemoveIpRoutesInput>
    public typealias MOutput = OperationOutput<RemoveIpRoutesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemoveIpRoutesOutputError>
}

public struct RemoveIpRoutesInputQueryItemMiddleware: Middleware {
    public let id: String = "RemoveIpRoutesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemoveIpRoutesInput>,
                  next: H) -> Swift.Result<OperationOutput<RemoveIpRoutesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemoveIpRoutesInput>
    public typealias MOutput = OperationOutput<RemoveIpRoutesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemoveIpRoutesOutputError>
}

public struct RemoveIpRoutesInput: Equatable {
    /// <p>IP address blocks that you want to remove.</p>
    public let cidrIps: [String]?
    /// <p>Identifier (ID) of the directory from which you want to remove the IP addresses.</p>
    public let directoryId: String?

    public init (
        cidrIps: [String]? = nil,
        directoryId: String? = nil
    )
    {
        self.cidrIps = cidrIps
        self.directoryId = directoryId
    }
}

struct RemoveIpRoutesInputBody: Equatable {
    public let directoryId: String?
    public let cidrIps: [String]?
}

extension RemoveIpRoutesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case cidrIps = "CidrIps"
        case directoryId = "DirectoryId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let cidrIpsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .cidrIps)
        var cidrIpsDecoded0:[String]? = nil
        if let cidrIpsContainer = cidrIpsContainer {
            cidrIpsDecoded0 = [String]()
            for string0 in cidrIpsContainer {
                if let string0 = string0 {
                    cidrIpsDecoded0?.append(string0)
                }
            }
        }
        cidrIps = cidrIpsDecoded0
    }
}

extension RemoveIpRoutesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RemoveIpRoutesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryUnavailableException" : self = .directoryUnavailableException(try DirectoryUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityDoesNotExistException" : self = .entityDoesNotExistException(try EntityDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RemoveIpRoutesOutputError: Equatable {
    case clientException(ClientException)
    case directoryUnavailableException(DirectoryUnavailableException)
    case entityDoesNotExistException(EntityDoesNotExistException)
    case invalidParameterException(InvalidParameterException)
    case serviceException(ServiceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RemoveIpRoutesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RemoveIpRoutesOutputResponse()"}
}

extension RemoveIpRoutesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct RemoveIpRoutesOutputResponse: Equatable {

    public init() {}
}

struct RemoveIpRoutesOutputResponseBody: Equatable {
}

extension RemoveIpRoutesOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct RemoveRegionInputBodyMiddleware: Middleware {
    public let id: String = "RemoveRegionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemoveRegionInput>,
                  next: H) -> Swift.Result<OperationOutput<RemoveRegionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemoveRegionInput>
    public typealias MOutput = OperationOutput<RemoveRegionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemoveRegionOutputError>
}

extension RemoveRegionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RemoveRegionInput(directoryId: \(String(describing: directoryId)))"}
}

extension RemoveRegionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case directoryId = "DirectoryId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryId = directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
    }
}

public struct RemoveRegionInputHeadersMiddleware: Middleware {
    public let id: String = "RemoveRegionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemoveRegionInput>,
                  next: H) -> Swift.Result<OperationOutput<RemoveRegionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemoveRegionInput>
    public typealias MOutput = OperationOutput<RemoveRegionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemoveRegionOutputError>
}

public struct RemoveRegionInputQueryItemMiddleware: Middleware {
    public let id: String = "RemoveRegionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemoveRegionInput>,
                  next: H) -> Swift.Result<OperationOutput<RemoveRegionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemoveRegionInput>
    public typealias MOutput = OperationOutput<RemoveRegionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemoveRegionOutputError>
}

public struct RemoveRegionInput: Equatable {
    /// <p>The identifier of the directory for which you want to remove Region replication.</p>
    public let directoryId: String?

    public init (
        directoryId: String? = nil
    )
    {
        self.directoryId = directoryId
    }
}

struct RemoveRegionInputBody: Equatable {
    public let directoryId: String?
}

extension RemoveRegionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case directoryId = "DirectoryId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
    }
}

extension RemoveRegionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RemoveRegionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryDoesNotExistException" : self = .directoryDoesNotExistException(try DirectoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryUnavailableException" : self = .directoryUnavailableException(try DirectoryUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RemoveRegionOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case clientException(ClientException)
    case directoryDoesNotExistException(DirectoryDoesNotExistException)
    case directoryUnavailableException(DirectoryUnavailableException)
    case serviceException(ServiceException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RemoveRegionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RemoveRegionOutputResponse()"}
}

extension RemoveRegionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct RemoveRegionOutputResponse: Equatable {

    public init() {}
}

struct RemoveRegionOutputResponseBody: Equatable {
}

extension RemoveRegionOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct RemoveTagsFromResourceInputBodyMiddleware: Middleware {
    public let id: String = "RemoveTagsFromResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemoveTagsFromResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<RemoveTagsFromResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemoveTagsFromResourceInput>
    public typealias MOutput = OperationOutput<RemoveTagsFromResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemoveTagsFromResourceOutputError>
}

extension RemoveTagsFromResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RemoveTagsFromResourceInput(resourceId: \(String(describing: resourceId)), tagKeys: \(String(describing: tagKeys)))"}
}

extension RemoveTagsFromResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceId = "ResourceId"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkeys0 in tagKeys {
                try tagKeysContainer.encode(tagkeys0)
            }
        }
    }
}

public struct RemoveTagsFromResourceInputHeadersMiddleware: Middleware {
    public let id: String = "RemoveTagsFromResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemoveTagsFromResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<RemoveTagsFromResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemoveTagsFromResourceInput>
    public typealias MOutput = OperationOutput<RemoveTagsFromResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemoveTagsFromResourceOutputError>
}

public struct RemoveTagsFromResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "RemoveTagsFromResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemoveTagsFromResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<RemoveTagsFromResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemoveTagsFromResourceInput>
    public typealias MOutput = OperationOutput<RemoveTagsFromResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemoveTagsFromResourceOutputError>
}

public struct RemoveTagsFromResourceInput: Equatable {
    /// <p>Identifier (ID) of the directory from which to remove the tag.</p>
    public let resourceId: String?
    /// <p>The tag key (name) of the tag to be removed.</p>
    public let tagKeys: [String]?

    public init (
        resourceId: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.resourceId = resourceId
        self.tagKeys = tagKeys
    }
}

struct RemoveTagsFromResourceInputBody: Equatable {
    public let resourceId: String?
    public let tagKeys: [String]?
}

extension RemoveTagsFromResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceId = "ResourceId"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension RemoveTagsFromResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RemoveTagsFromResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityDoesNotExistException" : self = .entityDoesNotExistException(try EntityDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RemoveTagsFromResourceOutputError: Equatable {
    case clientException(ClientException)
    case entityDoesNotExistException(EntityDoesNotExistException)
    case invalidParameterException(InvalidParameterException)
    case serviceException(ServiceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RemoveTagsFromResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RemoveTagsFromResourceOutputResponse()"}
}

extension RemoveTagsFromResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct RemoveTagsFromResourceOutputResponse: Equatable {

    public init() {}
}

struct RemoveTagsFromResourceOutputResponseBody: Equatable {
}

extension RemoveTagsFromResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public enum ReplicationScope {
    case domain
    case sdkUnknown(String)
}

extension ReplicationScope : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ReplicationScope] {
        return [
            .domain,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .domain: return "Domain"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ReplicationScope(rawValue: rawValue) ?? ReplicationScope.sdkUnknown(rawValue)
    }
}

public struct ResetUserPasswordInputBodyMiddleware: Middleware {
    public let id: String = "ResetUserPasswordInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ResetUserPasswordInput>,
                  next: H) -> Swift.Result<OperationOutput<ResetUserPasswordOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ResetUserPasswordInput>
    public typealias MOutput = OperationOutput<ResetUserPasswordOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ResetUserPasswordOutputError>
}

extension ResetUserPasswordInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResetUserPasswordInput(directoryId: \(String(describing: directoryId)), newPassword: \(String(describing: newPassword)), userName: \(String(describing: userName)))"}
}

extension ResetUserPasswordInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case directoryId = "DirectoryId"
        case newPassword = "NewPassword"
        case userName = "UserName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryId = directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let newPassword = newPassword {
            try encodeContainer.encode(newPassword, forKey: .newPassword)
        }
        if let userName = userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
    }
}

public struct ResetUserPasswordInputHeadersMiddleware: Middleware {
    public let id: String = "ResetUserPasswordInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ResetUserPasswordInput>,
                  next: H) -> Swift.Result<OperationOutput<ResetUserPasswordOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ResetUserPasswordInput>
    public typealias MOutput = OperationOutput<ResetUserPasswordOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ResetUserPasswordOutputError>
}

public struct ResetUserPasswordInputQueryItemMiddleware: Middleware {
    public let id: String = "ResetUserPasswordInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ResetUserPasswordInput>,
                  next: H) -> Swift.Result<OperationOutput<ResetUserPasswordOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ResetUserPasswordInput>
    public typealias MOutput = OperationOutput<ResetUserPasswordOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ResetUserPasswordOutputError>
}

public struct ResetUserPasswordInput: Equatable {
    /// <p>Identifier of the AWS Managed Microsoft AD or Simple AD directory in which the user
    ///       resides.</p>
    public let directoryId: String?
    /// <p>The new password that will be reset.</p>
    public let newPassword: String?
    /// <p>The user name of the user whose password will be reset.</p>
    public let userName: String?

    public init (
        directoryId: String? = nil,
        newPassword: String? = nil,
        userName: String? = nil
    )
    {
        self.directoryId = directoryId
        self.newPassword = newPassword
        self.userName = userName
    }
}

struct ResetUserPasswordInputBody: Equatable {
    public let directoryId: String?
    public let userName: String?
    public let newPassword: String?
}

extension ResetUserPasswordInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case directoryId = "DirectoryId"
        case newPassword = "NewPassword"
        case userName = "UserName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userName)
        userName = userNameDecoded
        let newPasswordDecoded = try containerValues.decodeIfPresent(String.self, forKey: .newPassword)
        newPassword = newPasswordDecoded
    }
}

extension ResetUserPasswordOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ResetUserPasswordOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryUnavailableException" : self = .directoryUnavailableException(try DirectoryUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityDoesNotExistException" : self = .entityDoesNotExistException(try EntityDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPasswordException" : self = .invalidPasswordException(try InvalidPasswordException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UserDoesNotExistException" : self = .userDoesNotExistException(try UserDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ResetUserPasswordOutputError: Equatable {
    case clientException(ClientException)
    case directoryUnavailableException(DirectoryUnavailableException)
    case entityDoesNotExistException(EntityDoesNotExistException)
    case invalidPasswordException(InvalidPasswordException)
    case serviceException(ServiceException)
    case unsupportedOperationException(UnsupportedOperationException)
    case userDoesNotExistException(UserDoesNotExistException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ResetUserPasswordOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResetUserPasswordOutputResponse()"}
}

extension ResetUserPasswordOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct ResetUserPasswordOutputResponse: Equatable {

    public init() {}
}

struct ResetUserPasswordOutputResponseBody: Equatable {
}

extension ResetUserPasswordOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct RestoreFromSnapshotInputBodyMiddleware: Middleware {
    public let id: String = "RestoreFromSnapshotInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RestoreFromSnapshotInput>,
                  next: H) -> Swift.Result<OperationOutput<RestoreFromSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RestoreFromSnapshotInput>
    public typealias MOutput = OperationOutput<RestoreFromSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RestoreFromSnapshotOutputError>
}

extension RestoreFromSnapshotInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RestoreFromSnapshotInput(snapshotId: \(String(describing: snapshotId)))"}
}

extension RestoreFromSnapshotInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case snapshotId = "SnapshotId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let snapshotId = snapshotId {
            try encodeContainer.encode(snapshotId, forKey: .snapshotId)
        }
    }
}

public struct RestoreFromSnapshotInputHeadersMiddleware: Middleware {
    public let id: String = "RestoreFromSnapshotInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RestoreFromSnapshotInput>,
                  next: H) -> Swift.Result<OperationOutput<RestoreFromSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RestoreFromSnapshotInput>
    public typealias MOutput = OperationOutput<RestoreFromSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RestoreFromSnapshotOutputError>
}

public struct RestoreFromSnapshotInputQueryItemMiddleware: Middleware {
    public let id: String = "RestoreFromSnapshotInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RestoreFromSnapshotInput>,
                  next: H) -> Swift.Result<OperationOutput<RestoreFromSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RestoreFromSnapshotInput>
    public typealias MOutput = OperationOutput<RestoreFromSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RestoreFromSnapshotOutputError>
}

/// <p>An object representing the inputs for the <a>RestoreFromSnapshot</a> operation.</p>
public struct RestoreFromSnapshotInput: Equatable {
    /// <p>The identifier of the snapshot to restore from.</p>
    public let snapshotId: String?

    public init (
        snapshotId: String? = nil
    )
    {
        self.snapshotId = snapshotId
    }
}

struct RestoreFromSnapshotInputBody: Equatable {
    public let snapshotId: String?
}

extension RestoreFromSnapshotInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case snapshotId = "SnapshotId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snapshotIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .snapshotId)
        snapshotId = snapshotIdDecoded
    }
}

extension RestoreFromSnapshotOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RestoreFromSnapshotOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityDoesNotExistException" : self = .entityDoesNotExistException(try EntityDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RestoreFromSnapshotOutputError: Equatable {
    case clientException(ClientException)
    case entityDoesNotExistException(EntityDoesNotExistException)
    case invalidParameterException(InvalidParameterException)
    case serviceException(ServiceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RestoreFromSnapshotOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RestoreFromSnapshotOutputResponse()"}
}

extension RestoreFromSnapshotOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>Contains the results of the <a>RestoreFromSnapshot</a> operation.</p>
public struct RestoreFromSnapshotOutputResponse: Equatable {

    public init() {}
}

struct RestoreFromSnapshotOutputResponseBody: Equatable {
}

extension RestoreFromSnapshotOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension SchemaExtensionInfo: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case directoryId = "DirectoryId"
        case endDateTime = "EndDateTime"
        case schemaExtensionId = "SchemaExtensionId"
        case schemaExtensionStatus = "SchemaExtensionStatus"
        case schemaExtensionStatusReason = "SchemaExtensionStatusReason"
        case startDateTime = "StartDateTime"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let directoryId = directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let endDateTime = endDateTime {
            try encodeContainer.encode(endDateTime.timeIntervalSince1970, forKey: .endDateTime)
        }
        if let schemaExtensionId = schemaExtensionId {
            try encodeContainer.encode(schemaExtensionId, forKey: .schemaExtensionId)
        }
        if let schemaExtensionStatus = schemaExtensionStatus {
            try encodeContainer.encode(schemaExtensionStatus.rawValue, forKey: .schemaExtensionStatus)
        }
        if let schemaExtensionStatusReason = schemaExtensionStatusReason {
            try encodeContainer.encode(schemaExtensionStatusReason, forKey: .schemaExtensionStatusReason)
        }
        if let startDateTime = startDateTime {
            try encodeContainer.encode(startDateTime.timeIntervalSince1970, forKey: .startDateTime)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let schemaExtensionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schemaExtensionId)
        schemaExtensionId = schemaExtensionIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let schemaExtensionStatusDecoded = try containerValues.decodeIfPresent(SchemaExtensionStatus.self, forKey: .schemaExtensionStatus)
        schemaExtensionStatus = schemaExtensionStatusDecoded
        let schemaExtensionStatusReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schemaExtensionStatusReason)
        schemaExtensionStatusReason = schemaExtensionStatusReasonDecoded
        let startDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startDateTime)
        startDateTime = startDateTimeDecoded
        let endDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .endDateTime)
        endDateTime = endDateTimeDecoded
    }
}

extension SchemaExtensionInfo: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SchemaExtensionInfo(description: \(String(describing: description)), directoryId: \(String(describing: directoryId)), endDateTime: \(String(describing: endDateTime)), schemaExtensionId: \(String(describing: schemaExtensionId)), schemaExtensionStatus: \(String(describing: schemaExtensionStatus)), schemaExtensionStatusReason: \(String(describing: schemaExtensionStatusReason)), startDateTime: \(String(describing: startDateTime)))"}
}

/// <p>Information about a schema extension.</p>
public struct SchemaExtensionInfo: Equatable {
    /// <p>A description of the schema extension.</p>
    public let description: String?
    /// <p>The identifier of the directory to which the schema extension is applied.</p>
    public let directoryId: String?
    /// <p>The date and time that the schema extension was completed.</p>
    public let endDateTime: Date?
    /// <p>The identifier of the schema extension.</p>
    public let schemaExtensionId: String?
    /// <p>The current status of the schema extension.</p>
    public let schemaExtensionStatus: SchemaExtensionStatus?
    /// <p>The reason for the <code>SchemaExtensionStatus</code>.</p>
    public let schemaExtensionStatusReason: String?
    /// <p>The date and time that the schema extension started being applied to the directory.</p>
    public let startDateTime: Date?

    public init (
        description: String? = nil,
        directoryId: String? = nil,
        endDateTime: Date? = nil,
        schemaExtensionId: String? = nil,
        schemaExtensionStatus: SchemaExtensionStatus? = nil,
        schemaExtensionStatusReason: String? = nil,
        startDateTime: Date? = nil
    )
    {
        self.description = description
        self.directoryId = directoryId
        self.endDateTime = endDateTime
        self.schemaExtensionId = schemaExtensionId
        self.schemaExtensionStatus = schemaExtensionStatus
        self.schemaExtensionStatusReason = schemaExtensionStatusReason
        self.startDateTime = startDateTime
    }
}

public enum SchemaExtensionStatus {
    case cancelled
    case cancelInProgress
    case completed
    case creatingSnapshot
    case failed
    case initializing
    case replicating
    case rollbackInProgress
    case updatingSchema
    case sdkUnknown(String)
}

extension SchemaExtensionStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SchemaExtensionStatus] {
        return [
            .cancelled,
            .cancelInProgress,
            .completed,
            .creatingSnapshot,
            .failed,
            .initializing,
            .replicating,
            .rollbackInProgress,
            .updatingSchema,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .cancelled: return "Cancelled"
        case .cancelInProgress: return "CancelInProgress"
        case .completed: return "Completed"
        case .creatingSnapshot: return "CreatingSnapshot"
        case .failed: return "Failed"
        case .initializing: return "Initializing"
        case .replicating: return "Replicating"
        case .rollbackInProgress: return "RollbackInProgress"
        case .updatingSchema: return "UpdatingSchema"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SchemaExtensionStatus(rawValue: rawValue) ?? SchemaExtensionStatus.sdkUnknown(rawValue)
    }
}

public enum SelectiveAuth {
    case disabled
    case enabled
    case sdkUnknown(String)
}

extension SelectiveAuth : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SelectiveAuth] {
        return [
            .disabled,
            .enabled,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .disabled: return "Disabled"
        case .enabled: return "Enabled"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SelectiveAuth(rawValue: rawValue) ?? SelectiveAuth.sdkUnknown(rawValue)
    }
}

extension ServiceException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceException(message: \(String(describing: message)), requestId: \(String(describing: requestId)))"}
}

extension ServiceException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ServiceExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.requestId = output.requestId
        } else {
            self.message = nil
            self.requestId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An exception has occurred in AWS Directory Service.</p>
public struct ServiceException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    /// <p>The descriptive message for the exception.</p>
    public var message: String?
    /// <p>The AWS request identifier.</p>
    public var requestId: String?

    public init (
        message: String? = nil,
        requestId: String? = nil
    )
    {
        self.message = message
        self.requestId = requestId
    }
}

struct ServiceExceptionBody: Equatable {
    public let message: String?
    public let requestId: String?
}

extension ServiceExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case requestId = "RequestId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

public struct ShareDirectoryInputBodyMiddleware: Middleware {
    public let id: String = "ShareDirectoryInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ShareDirectoryInput>,
                  next: H) -> Swift.Result<OperationOutput<ShareDirectoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ShareDirectoryInput>
    public typealias MOutput = OperationOutput<ShareDirectoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ShareDirectoryOutputError>
}

extension ShareDirectoryInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ShareDirectoryInput(directoryId: \(String(describing: directoryId)), shareMethod: \(String(describing: shareMethod)), shareNotes: \(String(describing: shareNotes)), shareTarget: \(String(describing: shareTarget)))"}
}

extension ShareDirectoryInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case directoryId = "DirectoryId"
        case shareMethod = "ShareMethod"
        case shareNotes = "ShareNotes"
        case shareTarget = "ShareTarget"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryId = directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let shareMethod = shareMethod {
            try encodeContainer.encode(shareMethod.rawValue, forKey: .shareMethod)
        }
        if let shareNotes = shareNotes {
            try encodeContainer.encode(shareNotes, forKey: .shareNotes)
        }
        if let shareTarget = shareTarget {
            try encodeContainer.encode(shareTarget, forKey: .shareTarget)
        }
    }
}

public struct ShareDirectoryInputHeadersMiddleware: Middleware {
    public let id: String = "ShareDirectoryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ShareDirectoryInput>,
                  next: H) -> Swift.Result<OperationOutput<ShareDirectoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ShareDirectoryInput>
    public typealias MOutput = OperationOutput<ShareDirectoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ShareDirectoryOutputError>
}

public struct ShareDirectoryInputQueryItemMiddleware: Middleware {
    public let id: String = "ShareDirectoryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ShareDirectoryInput>,
                  next: H) -> Swift.Result<OperationOutput<ShareDirectoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ShareDirectoryInput>
    public typealias MOutput = OperationOutput<ShareDirectoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ShareDirectoryOutputError>
}

public struct ShareDirectoryInput: Equatable {
    /// <p>Identifier of the AWS Managed Microsoft AD directory that you want to share with other AWS
    ///       accounts.</p>
    public let directoryId: String?
    /// <p>The method used when sharing a directory to determine whether the directory should be
    ///       shared within your AWS organization (<code>ORGANIZATIONS</code>) or with any AWS account by
    ///       sending a directory sharing request (<code>HANDSHAKE</code>).</p>
    public let shareMethod: ShareMethod?
    /// <p>A directory share request that is sent by the directory owner to the directory consumer.
    ///       The request includes a typed message to help the directory consumer administrator determine
    ///       whether to approve or reject the share invitation.</p>
    public let shareNotes: String?
    /// <p>Identifier for the directory consumer account with whom the directory is to be
    ///       shared.</p>
    public let shareTarget: ShareTarget?

    public init (
        directoryId: String? = nil,
        shareMethod: ShareMethod? = nil,
        shareNotes: String? = nil,
        shareTarget: ShareTarget? = nil
    )
    {
        self.directoryId = directoryId
        self.shareMethod = shareMethod
        self.shareNotes = shareNotes
        self.shareTarget = shareTarget
    }
}

struct ShareDirectoryInputBody: Equatable {
    public let directoryId: String?
    public let shareNotes: String?
    public let shareTarget: ShareTarget?
    public let shareMethod: ShareMethod?
}

extension ShareDirectoryInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case directoryId = "DirectoryId"
        case shareMethod = "ShareMethod"
        case shareNotes = "ShareNotes"
        case shareTarget = "ShareTarget"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let shareNotesDecoded = try containerValues.decodeIfPresent(String.self, forKey: .shareNotes)
        shareNotes = shareNotesDecoded
        let shareTargetDecoded = try containerValues.decodeIfPresent(ShareTarget.self, forKey: .shareTarget)
        shareTarget = shareTargetDecoded
        let shareMethodDecoded = try containerValues.decodeIfPresent(ShareMethod.self, forKey: .shareMethod)
        shareMethod = shareMethodDecoded
    }
}

extension ShareDirectoryOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ShareDirectoryOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryAlreadySharedException" : self = .directoryAlreadySharedException(try DirectoryAlreadySharedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityDoesNotExistException" : self = .entityDoesNotExistException(try EntityDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTargetException" : self = .invalidTargetException(try InvalidTargetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationsException" : self = .organizationsException(try OrganizationsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ShareLimitExceededException" : self = .shareLimitExceededException(try ShareLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ShareDirectoryOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case clientException(ClientException)
    case directoryAlreadySharedException(DirectoryAlreadySharedException)
    case entityDoesNotExistException(EntityDoesNotExistException)
    case invalidParameterException(InvalidParameterException)
    case invalidTargetException(InvalidTargetException)
    case organizationsException(OrganizationsException)
    case serviceException(ServiceException)
    case shareLimitExceededException(ShareLimitExceededException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ShareDirectoryOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ShareDirectoryOutputResponse(sharedDirectoryId: \(String(describing: sharedDirectoryId)))"}
}

extension ShareDirectoryOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ShareDirectoryOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.sharedDirectoryId = output.sharedDirectoryId
        } else {
            self.sharedDirectoryId = nil
        }
    }
}

public struct ShareDirectoryOutputResponse: Equatable {
    /// <p>Identifier of the directory that is stored in the directory consumer account that is
    ///       shared from the specified directory (<code>DirectoryId</code>).</p>
    public let sharedDirectoryId: String?

    public init (
        sharedDirectoryId: String? = nil
    )
    {
        self.sharedDirectoryId = sharedDirectoryId
    }
}

struct ShareDirectoryOutputResponseBody: Equatable {
    public let sharedDirectoryId: String?
}

extension ShareDirectoryOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case sharedDirectoryId = "SharedDirectoryId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sharedDirectoryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sharedDirectoryId)
        sharedDirectoryId = sharedDirectoryIdDecoded
    }
}

extension ShareLimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ShareLimitExceededException(message: \(String(describing: message)), requestId: \(String(describing: requestId)))"}
}

extension ShareLimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ShareLimitExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.requestId = output.requestId
        } else {
            self.message = nil
            self.requestId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The maximum number of AWS accounts that you can share with this directory has been reached.</p>
public struct ShareLimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The descriptive message for the exception.</p>
    public var message: String?
    /// <p>The AWS request identifier.</p>
    public var requestId: String?

    public init (
        message: String? = nil,
        requestId: String? = nil
    )
    {
        self.message = message
        self.requestId = requestId
    }
}

struct ShareLimitExceededExceptionBody: Equatable {
    public let message: String?
    public let requestId: String?
}

extension ShareLimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case requestId = "RequestId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

public enum ShareMethod {
    case handshake
    case organizations
    case sdkUnknown(String)
}

extension ShareMethod : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ShareMethod] {
        return [
            .handshake,
            .organizations,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .handshake: return "HANDSHAKE"
        case .organizations: return "ORGANIZATIONS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ShareMethod(rawValue: rawValue) ?? ShareMethod.sdkUnknown(rawValue)
    }
}

public enum ShareStatus {
    case deleted
    case deleting
    case pendingAcceptance
    case rejected
    case rejecting
    case rejectFailed
    case shared
    case shareFailed
    case sharing
    case sdkUnknown(String)
}

extension ShareStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ShareStatus] {
        return [
            .deleted,
            .deleting,
            .pendingAcceptance,
            .rejected,
            .rejecting,
            .rejectFailed,
            .shared,
            .shareFailed,
            .sharing,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .deleted: return "Deleted"
        case .deleting: return "Deleting"
        case .pendingAcceptance: return "PendingAcceptance"
        case .rejected: return "Rejected"
        case .rejecting: return "Rejecting"
        case .rejectFailed: return "RejectFailed"
        case .shared: return "Shared"
        case .shareFailed: return "ShareFailed"
        case .sharing: return "Sharing"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ShareStatus(rawValue: rawValue) ?? ShareStatus.sdkUnknown(rawValue)
    }
}

extension ShareTarget: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case id = "Id"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let typeDecoded = try containerValues.decodeIfPresent(TargetType.self, forKey: .type)
        type = typeDecoded
    }
}

extension ShareTarget: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ShareTarget(id: \(String(describing: id)), type: \(String(describing: type)))"}
}

/// <p>Identifier that contains details about the directory consumer account.</p>
public struct ShareTarget: Equatable {
    /// <p>Identifier of the directory consumer account.</p>
    public let id: String?
    /// <p>Type of identifier to be used in the <code>Id</code> field.</p>
    public let type: TargetType?

    public init (
        id: String? = nil,
        type: TargetType? = nil
    )
    {
        self.id = id
        self.type = type
    }
}

extension SharedDirectory: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case createdDateTime = "CreatedDateTime"
        case lastUpdatedDateTime = "LastUpdatedDateTime"
        case ownerAccountId = "OwnerAccountId"
        case ownerDirectoryId = "OwnerDirectoryId"
        case shareMethod = "ShareMethod"
        case shareNotes = "ShareNotes"
        case shareStatus = "ShareStatus"
        case sharedAccountId = "SharedAccountId"
        case sharedDirectoryId = "SharedDirectoryId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdDateTime = createdDateTime {
            try encodeContainer.encode(createdDateTime.timeIntervalSince1970, forKey: .createdDateTime)
        }
        if let lastUpdatedDateTime = lastUpdatedDateTime {
            try encodeContainer.encode(lastUpdatedDateTime.timeIntervalSince1970, forKey: .lastUpdatedDateTime)
        }
        if let ownerAccountId = ownerAccountId {
            try encodeContainer.encode(ownerAccountId, forKey: .ownerAccountId)
        }
        if let ownerDirectoryId = ownerDirectoryId {
            try encodeContainer.encode(ownerDirectoryId, forKey: .ownerDirectoryId)
        }
        if let shareMethod = shareMethod {
            try encodeContainer.encode(shareMethod.rawValue, forKey: .shareMethod)
        }
        if let shareNotes = shareNotes {
            try encodeContainer.encode(shareNotes, forKey: .shareNotes)
        }
        if let shareStatus = shareStatus {
            try encodeContainer.encode(shareStatus.rawValue, forKey: .shareStatus)
        }
        if let sharedAccountId = sharedAccountId {
            try encodeContainer.encode(sharedAccountId, forKey: .sharedAccountId)
        }
        if let sharedDirectoryId = sharedDirectoryId {
            try encodeContainer.encode(sharedDirectoryId, forKey: .sharedDirectoryId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ownerAccountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ownerAccountId)
        ownerAccountId = ownerAccountIdDecoded
        let ownerDirectoryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ownerDirectoryId)
        ownerDirectoryId = ownerDirectoryIdDecoded
        let shareMethodDecoded = try containerValues.decodeIfPresent(ShareMethod.self, forKey: .shareMethod)
        shareMethod = shareMethodDecoded
        let sharedAccountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sharedAccountId)
        sharedAccountId = sharedAccountIdDecoded
        let sharedDirectoryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sharedDirectoryId)
        sharedDirectoryId = sharedDirectoryIdDecoded
        let shareStatusDecoded = try containerValues.decodeIfPresent(ShareStatus.self, forKey: .shareStatus)
        shareStatus = shareStatusDecoded
        let shareNotesDecoded = try containerValues.decodeIfPresent(String.self, forKey: .shareNotes)
        shareNotes = shareNotesDecoded
        let createdDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdDateTime)
        createdDateTime = createdDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
    }
}

extension SharedDirectory: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SharedDirectory(createdDateTime: \(String(describing: createdDateTime)), lastUpdatedDateTime: \(String(describing: lastUpdatedDateTime)), ownerAccountId: \(String(describing: ownerAccountId)), ownerDirectoryId: \(String(describing: ownerDirectoryId)), shareMethod: \(String(describing: shareMethod)), shareNotes: \(String(describing: shareNotes)), shareStatus: \(String(describing: shareStatus)), sharedAccountId: \(String(describing: sharedAccountId)), sharedDirectoryId: \(String(describing: sharedDirectoryId)))"}
}

/// <p>Details about the shared directory in the directory owner account for which the share
///       request in the directory consumer account has been accepted.</p>
public struct SharedDirectory: Equatable {
    /// <p>The date and time that the shared directory was created.</p>
    public let createdDateTime: Date?
    /// <p>The date and time that the shared directory was last updated.</p>
    public let lastUpdatedDateTime: Date?
    /// <p>Identifier of the directory owner account, which contains the directory that has been
    ///       shared to the consumer account.</p>
    public let ownerAccountId: String?
    /// <p>Identifier of the directory in the directory owner account. </p>
    public let ownerDirectoryId: String?
    /// <p>The method used when sharing a directory to determine whether the directory should be
    ///       shared within your AWS organization (<code>ORGANIZATIONS</code>) or with any AWS account by
    ///       sending a shared directory request (<code>HANDSHAKE</code>).</p>
    public let shareMethod: ShareMethod?
    /// <p>A directory share request that is sent by the directory owner to the directory consumer.
    ///       The request includes a typed message to help the directory consumer administrator determine
    ///       whether to approve or reject the share invitation.</p>
    public let shareNotes: String?
    /// <p>Current directory status of the shared AWS Managed Microsoft AD directory.</p>
    public let shareStatus: ShareStatus?
    /// <p>Identifier of the directory consumer account that has access to the shared directory
    ///         (<code>OwnerDirectoryId</code>) in the directory owner account.</p>
    public let sharedAccountId: String?
    /// <p>Identifier of the shared directory in the directory consumer account. This identifier is
    ///       different for each directory owner account.</p>
    public let sharedDirectoryId: String?

    public init (
        createdDateTime: Date? = nil,
        lastUpdatedDateTime: Date? = nil,
        ownerAccountId: String? = nil,
        ownerDirectoryId: String? = nil,
        shareMethod: ShareMethod? = nil,
        shareNotes: String? = nil,
        shareStatus: ShareStatus? = nil,
        sharedAccountId: String? = nil,
        sharedDirectoryId: String? = nil
    )
    {
        self.createdDateTime = createdDateTime
        self.lastUpdatedDateTime = lastUpdatedDateTime
        self.ownerAccountId = ownerAccountId
        self.ownerDirectoryId = ownerDirectoryId
        self.shareMethod = shareMethod
        self.shareNotes = shareNotes
        self.shareStatus = shareStatus
        self.sharedAccountId = sharedAccountId
        self.sharedDirectoryId = sharedDirectoryId
    }
}

extension Snapshot: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case directoryId = "DirectoryId"
        case name = "Name"
        case snapshotId = "SnapshotId"
        case startTime = "StartTime"
        case status = "Status"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryId = directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let snapshotId = snapshotId {
            try encodeContainer.encode(snapshotId, forKey: .snapshotId)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let snapshotIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .snapshotId)
        snapshotId = snapshotIdDecoded
        let typeDecoded = try containerValues.decodeIfPresent(SnapshotType.self, forKey: .type)
        type = typeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SnapshotStatus.self, forKey: .status)
        status = statusDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startTime)
        startTime = startTimeDecoded
    }
}

extension Snapshot: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Snapshot(directoryId: \(String(describing: directoryId)), name: \(String(describing: name)), snapshotId: \(String(describing: snapshotId)), startTime: \(String(describing: startTime)), status: \(String(describing: status)), type: \(String(describing: type)))"}
}

/// <p>Describes a directory snapshot.</p>
public struct Snapshot: Equatable {
    /// <p>The directory identifier.</p>
    public let directoryId: String?
    /// <p>The descriptive name of the snapshot.</p>
    public let name: String?
    /// <p>The snapshot identifier.</p>
    public let snapshotId: String?
    /// <p>The date and time that the snapshot was taken.</p>
    public let startTime: Date?
    /// <p>The snapshot status.</p>
    public let status: SnapshotStatus?
    /// <p>The snapshot type.</p>
    public let type: SnapshotType?

    public init (
        directoryId: String? = nil,
        name: String? = nil,
        snapshotId: String? = nil,
        startTime: Date? = nil,
        status: SnapshotStatus? = nil,
        type: SnapshotType? = nil
    )
    {
        self.directoryId = directoryId
        self.name = name
        self.snapshotId = snapshotId
        self.startTime = startTime
        self.status = status
        self.type = type
    }
}

extension SnapshotLimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SnapshotLimitExceededException(message: \(String(describing: message)), requestId: \(String(describing: requestId)))"}
}

extension SnapshotLimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: SnapshotLimitExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.requestId = output.requestId
        } else {
            self.message = nil
            self.requestId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The maximum number of manual snapshots for the directory has been reached. You can
///       use the <a>GetSnapshotLimits</a> operation to determine the snapshot limits for a
///       directory.</p>
public struct SnapshotLimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The descriptive message for the exception.</p>
    public var message: String?
    /// <p>The AWS request identifier.</p>
    public var requestId: String?

    public init (
        message: String? = nil,
        requestId: String? = nil
    )
    {
        self.message = message
        self.requestId = requestId
    }
}

struct SnapshotLimitExceededExceptionBody: Equatable {
    public let message: String?
    public let requestId: String?
}

extension SnapshotLimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case requestId = "RequestId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension SnapshotLimits: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case manualSnapshotsCurrentCount = "ManualSnapshotsCurrentCount"
        case manualSnapshotsLimit = "ManualSnapshotsLimit"
        case manualSnapshotsLimitReached = "ManualSnapshotsLimitReached"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let manualSnapshotsCurrentCount = manualSnapshotsCurrentCount {
            try encodeContainer.encode(manualSnapshotsCurrentCount, forKey: .manualSnapshotsCurrentCount)
        }
        if let manualSnapshotsLimit = manualSnapshotsLimit {
            try encodeContainer.encode(manualSnapshotsLimit, forKey: .manualSnapshotsLimit)
        }
        if manualSnapshotsLimitReached != false {
            try encodeContainer.encode(manualSnapshotsLimitReached, forKey: .manualSnapshotsLimitReached)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let manualSnapshotsLimitDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .manualSnapshotsLimit)
        manualSnapshotsLimit = manualSnapshotsLimitDecoded
        let manualSnapshotsCurrentCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .manualSnapshotsCurrentCount)
        manualSnapshotsCurrentCount = manualSnapshotsCurrentCountDecoded
        let manualSnapshotsLimitReachedDecoded = try containerValues.decode(Bool.self, forKey: .manualSnapshotsLimitReached)
        manualSnapshotsLimitReached = manualSnapshotsLimitReachedDecoded
    }
}

extension SnapshotLimits: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SnapshotLimits(manualSnapshotsCurrentCount: \(String(describing: manualSnapshotsCurrentCount)), manualSnapshotsLimit: \(String(describing: manualSnapshotsLimit)), manualSnapshotsLimitReached: \(String(describing: manualSnapshotsLimitReached)))"}
}

/// <p>Contains manual snapshot limit information for a directory.</p>
public struct SnapshotLimits: Equatable {
    /// <p>The current number of manual snapshots of the directory.</p>
    public let manualSnapshotsCurrentCount: Int?
    /// <p>The maximum number of manual snapshots allowed.</p>
    public let manualSnapshotsLimit: Int?
    /// <p>Indicates if the manual snapshot limit has been reached.</p>
    public let manualSnapshotsLimitReached: Bool

    public init (
        manualSnapshotsCurrentCount: Int? = nil,
        manualSnapshotsLimit: Int? = nil,
        manualSnapshotsLimitReached: Bool = false
    )
    {
        self.manualSnapshotsCurrentCount = manualSnapshotsCurrentCount
        self.manualSnapshotsLimit = manualSnapshotsLimit
        self.manualSnapshotsLimitReached = manualSnapshotsLimitReached
    }
}

public enum SnapshotStatus {
    case completed
    case creating
    case failed
    case sdkUnknown(String)
}

extension SnapshotStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SnapshotStatus] {
        return [
            .completed,
            .creating,
            .failed,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .completed: return "Completed"
        case .creating: return "Creating"
        case .failed: return "Failed"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SnapshotStatus(rawValue: rawValue) ?? SnapshotStatus.sdkUnknown(rawValue)
    }
}

public enum SnapshotType {
    case auto
    case manual
    case sdkUnknown(String)
}

extension SnapshotType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SnapshotType] {
        return [
            .auto,
            .manual,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .auto: return "Auto"
        case .manual: return "Manual"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SnapshotType(rawValue: rawValue) ?? SnapshotType.sdkUnknown(rawValue)
    }
}

public struct StartSchemaExtensionInputBodyMiddleware: Middleware {
    public let id: String = "StartSchemaExtensionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartSchemaExtensionInput>,
                  next: H) -> Swift.Result<OperationOutput<StartSchemaExtensionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartSchemaExtensionInput>
    public typealias MOutput = OperationOutput<StartSchemaExtensionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartSchemaExtensionOutputError>
}

extension StartSchemaExtensionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartSchemaExtensionInput(createSnapshotBeforeSchemaExtension: \(String(describing: createSnapshotBeforeSchemaExtension)), description: \(String(describing: description)), directoryId: \(String(describing: directoryId)), ldifContent: \(String(describing: ldifContent)))"}
}

extension StartSchemaExtensionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case createSnapshotBeforeSchemaExtension = "CreateSnapshotBeforeSchemaExtension"
        case description = "Description"
        case directoryId = "DirectoryId"
        case ldifContent = "LdifContent"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if createSnapshotBeforeSchemaExtension != false {
            try encodeContainer.encode(createSnapshotBeforeSchemaExtension, forKey: .createSnapshotBeforeSchemaExtension)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let directoryId = directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let ldifContent = ldifContent {
            try encodeContainer.encode(ldifContent, forKey: .ldifContent)
        }
    }
}

public struct StartSchemaExtensionInputHeadersMiddleware: Middleware {
    public let id: String = "StartSchemaExtensionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartSchemaExtensionInput>,
                  next: H) -> Swift.Result<OperationOutput<StartSchemaExtensionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartSchemaExtensionInput>
    public typealias MOutput = OperationOutput<StartSchemaExtensionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartSchemaExtensionOutputError>
}

public struct StartSchemaExtensionInputQueryItemMiddleware: Middleware {
    public let id: String = "StartSchemaExtensionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartSchemaExtensionInput>,
                  next: H) -> Swift.Result<OperationOutput<StartSchemaExtensionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartSchemaExtensionInput>
    public typealias MOutput = OperationOutput<StartSchemaExtensionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartSchemaExtensionOutputError>
}

public struct StartSchemaExtensionInput: Equatable {
    /// <p>If true, creates a snapshot of the directory before applying the schema extension.</p>
    public let createSnapshotBeforeSchemaExtension: Bool
    /// <p>A description of the schema extension.</p>
    public let description: String?
    /// <p>The identifier of the directory for which the schema extension will be applied to.</p>
    public let directoryId: String?
    /// <p>The LDIF file represented as a string. To construct the LdifContent string, precede each line as it would be formatted in an ldif file with \n. See the example request below for more details. The file size can be no larger than 1MB.</p>
    public let ldifContent: String?

    public init (
        createSnapshotBeforeSchemaExtension: Bool = false,
        description: String? = nil,
        directoryId: String? = nil,
        ldifContent: String? = nil
    )
    {
        self.createSnapshotBeforeSchemaExtension = createSnapshotBeforeSchemaExtension
        self.description = description
        self.directoryId = directoryId
        self.ldifContent = ldifContent
    }
}

struct StartSchemaExtensionInputBody: Equatable {
    public let directoryId: String?
    public let createSnapshotBeforeSchemaExtension: Bool
    public let ldifContent: String?
    public let description: String?
}

extension StartSchemaExtensionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case createSnapshotBeforeSchemaExtension = "CreateSnapshotBeforeSchemaExtension"
        case description = "Description"
        case directoryId = "DirectoryId"
        case ldifContent = "LdifContent"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let createSnapshotBeforeSchemaExtensionDecoded = try containerValues.decode(Bool.self, forKey: .createSnapshotBeforeSchemaExtension)
        createSnapshotBeforeSchemaExtension = createSnapshotBeforeSchemaExtensionDecoded
        let ldifContentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ldifContent)
        ldifContent = ldifContentDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension StartSchemaExtensionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartSchemaExtensionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryUnavailableException" : self = .directoryUnavailableException(try DirectoryUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityDoesNotExistException" : self = .entityDoesNotExistException(try EntityDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SnapshotLimitExceededException" : self = .snapshotLimitExceededException(try SnapshotLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartSchemaExtensionOutputError: Equatable {
    case clientException(ClientException)
    case directoryUnavailableException(DirectoryUnavailableException)
    case entityDoesNotExistException(EntityDoesNotExistException)
    case invalidParameterException(InvalidParameterException)
    case serviceException(ServiceException)
    case snapshotLimitExceededException(SnapshotLimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartSchemaExtensionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartSchemaExtensionOutputResponse(schemaExtensionId: \(String(describing: schemaExtensionId)))"}
}

extension StartSchemaExtensionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StartSchemaExtensionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.schemaExtensionId = output.schemaExtensionId
        } else {
            self.schemaExtensionId = nil
        }
    }
}

public struct StartSchemaExtensionOutputResponse: Equatable {
    /// <p>The identifier of the schema extension that will be applied.</p>
    public let schemaExtensionId: String?

    public init (
        schemaExtensionId: String? = nil
    )
    {
        self.schemaExtensionId = schemaExtensionId
    }
}

struct StartSchemaExtensionOutputResponseBody: Equatable {
    public let schemaExtensionId: String?
}

extension StartSchemaExtensionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case schemaExtensionId = "SchemaExtensionId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaExtensionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schemaExtensionId)
        schemaExtensionId = schemaExtensionIdDecoded
    }
}

extension Tag: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Tag: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Tag(key: \(String(describing: key)), value: \(String(describing: value)))"}
}

/// <p>Metadata assigned to a directory consisting of a key-value pair.</p>
public struct Tag: Equatable {
    /// <p>Required name of the tag. The string value can be Unicode characters and cannot be prefixed with "aws:". The string can contain only the set of Unicode letters, digits, white-space, '_', '.', '/', '=', '+', '-' (Java regex: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-]*)$").</p>
    public let key: String?
    /// <p>The optional value of the tag. The string value can be Unicode characters. The string can contain only the set of Unicode letters, digits, white-space, '_', '.', '/', '=', '+', '-' (Java regex: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-]*)$").</p>
    public let value: String?

    public init (
        key: String? = nil,
        value: String? = nil
    )
    {
        self.key = key
        self.value = value
    }
}

extension TagLimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagLimitExceededException(message: \(String(describing: message)), requestId: \(String(describing: requestId)))"}
}

extension TagLimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: TagLimitExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.requestId = output.requestId
        } else {
            self.message = nil
            self.requestId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The maximum allowed number of tags was exceeded.</p>
public struct TagLimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The descriptive message for the exception.</p>
    public var message: String?
    /// <p>The AWS request identifier.</p>
    public var requestId: String?

    public init (
        message: String? = nil,
        requestId: String? = nil
    )
    {
        self.message = message
        self.requestId = requestId
    }
}

struct TagLimitExceededExceptionBody: Equatable {
    public let message: String?
    public let requestId: String?
}

extension TagLimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case requestId = "RequestId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

public enum TargetType {
    case account
    case sdkUnknown(String)
}

extension TargetType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [TargetType] {
        return [
            .account,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .account: return "ACCOUNT"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = TargetType(rawValue: rawValue) ?? TargetType.sdkUnknown(rawValue)
    }
}

public enum TopicStatus {
    case deleted
    case failed
    case registered
    case topicNotFound
    case sdkUnknown(String)
}

extension TopicStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [TopicStatus] {
        return [
            .deleted,
            .failed,
            .registered,
            .topicNotFound,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .deleted: return "Deleted"
        case .failed: return "Failed"
        case .registered: return "Registered"
        case .topicNotFound: return "Topic not found"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = TopicStatus(rawValue: rawValue) ?? TopicStatus.sdkUnknown(rawValue)
    }
}

extension Trust: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case createdDateTime = "CreatedDateTime"
        case directoryId = "DirectoryId"
        case lastUpdatedDateTime = "LastUpdatedDateTime"
        case remoteDomainName = "RemoteDomainName"
        case selectiveAuth = "SelectiveAuth"
        case stateLastUpdatedDateTime = "StateLastUpdatedDateTime"
        case trustDirection = "TrustDirection"
        case trustId = "TrustId"
        case trustState = "TrustState"
        case trustStateReason = "TrustStateReason"
        case trustType = "TrustType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdDateTime = createdDateTime {
            try encodeContainer.encode(createdDateTime.timeIntervalSince1970, forKey: .createdDateTime)
        }
        if let directoryId = directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let lastUpdatedDateTime = lastUpdatedDateTime {
            try encodeContainer.encode(lastUpdatedDateTime.timeIntervalSince1970, forKey: .lastUpdatedDateTime)
        }
        if let remoteDomainName = remoteDomainName {
            try encodeContainer.encode(remoteDomainName, forKey: .remoteDomainName)
        }
        if let selectiveAuth = selectiveAuth {
            try encodeContainer.encode(selectiveAuth.rawValue, forKey: .selectiveAuth)
        }
        if let stateLastUpdatedDateTime = stateLastUpdatedDateTime {
            try encodeContainer.encode(stateLastUpdatedDateTime.timeIntervalSince1970, forKey: .stateLastUpdatedDateTime)
        }
        if let trustDirection = trustDirection {
            try encodeContainer.encode(trustDirection.rawValue, forKey: .trustDirection)
        }
        if let trustId = trustId {
            try encodeContainer.encode(trustId, forKey: .trustId)
        }
        if let trustState = trustState {
            try encodeContainer.encode(trustState.rawValue, forKey: .trustState)
        }
        if let trustStateReason = trustStateReason {
            try encodeContainer.encode(trustStateReason, forKey: .trustStateReason)
        }
        if let trustType = trustType {
            try encodeContainer.encode(trustType.rawValue, forKey: .trustType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let trustIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .trustId)
        trustId = trustIdDecoded
        let remoteDomainNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .remoteDomainName)
        remoteDomainName = remoteDomainNameDecoded
        let trustTypeDecoded = try containerValues.decodeIfPresent(TrustType.self, forKey: .trustType)
        trustType = trustTypeDecoded
        let trustDirectionDecoded = try containerValues.decodeIfPresent(TrustDirection.self, forKey: .trustDirection)
        trustDirection = trustDirectionDecoded
        let trustStateDecoded = try containerValues.decodeIfPresent(TrustState.self, forKey: .trustState)
        trustState = trustStateDecoded
        let createdDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdDateTime)
        createdDateTime = createdDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
        let stateLastUpdatedDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .stateLastUpdatedDateTime)
        stateLastUpdatedDateTime = stateLastUpdatedDateTimeDecoded
        let trustStateReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .trustStateReason)
        trustStateReason = trustStateReasonDecoded
        let selectiveAuthDecoded = try containerValues.decodeIfPresent(SelectiveAuth.self, forKey: .selectiveAuth)
        selectiveAuth = selectiveAuthDecoded
    }
}

extension Trust: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Trust(createdDateTime: \(String(describing: createdDateTime)), directoryId: \(String(describing: directoryId)), lastUpdatedDateTime: \(String(describing: lastUpdatedDateTime)), remoteDomainName: \(String(describing: remoteDomainName)), selectiveAuth: \(String(describing: selectiveAuth)), stateLastUpdatedDateTime: \(String(describing: stateLastUpdatedDateTime)), trustDirection: \(String(describing: trustDirection)), trustId: \(String(describing: trustId)), trustState: \(String(describing: trustState)), trustStateReason: \(String(describing: trustStateReason)), trustType: \(String(describing: trustType)))"}
}

/// <p>Describes a trust relationship between an AWS Managed Microsoft AD directory and an external domain.</p>
public struct Trust: Equatable {
    /// <p>The date and time that the trust relationship was created.</p>
    public let createdDateTime: Date?
    /// <p>The Directory ID of the AWS directory involved in the trust relationship.</p>
    public let directoryId: String?
    /// <p>The date and time that the trust relationship was last updated.</p>
    public let lastUpdatedDateTime: Date?
    /// <p>The Fully Qualified Domain Name (FQDN) of the external domain involved in the trust relationship.</p>
    public let remoteDomainName: String?
    /// <p>Current state of selective authentication for the trust.</p>
    public let selectiveAuth: SelectiveAuth?
    /// <p>The date and time that the TrustState was last updated.</p>
    public let stateLastUpdatedDateTime: Date?
    /// <p>The trust relationship direction.</p>
    public let trustDirection: TrustDirection?
    /// <p>The unique ID of the trust relationship.</p>
    public let trustId: String?
    /// <p>The trust relationship state.</p>
    public let trustState: TrustState?
    /// <p>The reason for the TrustState.</p>
    public let trustStateReason: String?
    /// <p>The trust relationship type. <code>Forest</code> is the default.</p>
    public let trustType: TrustType?

    public init (
        createdDateTime: Date? = nil,
        directoryId: String? = nil,
        lastUpdatedDateTime: Date? = nil,
        remoteDomainName: String? = nil,
        selectiveAuth: SelectiveAuth? = nil,
        stateLastUpdatedDateTime: Date? = nil,
        trustDirection: TrustDirection? = nil,
        trustId: String? = nil,
        trustState: TrustState? = nil,
        trustStateReason: String? = nil,
        trustType: TrustType? = nil
    )
    {
        self.createdDateTime = createdDateTime
        self.directoryId = directoryId
        self.lastUpdatedDateTime = lastUpdatedDateTime
        self.remoteDomainName = remoteDomainName
        self.selectiveAuth = selectiveAuth
        self.stateLastUpdatedDateTime = stateLastUpdatedDateTime
        self.trustDirection = trustDirection
        self.trustId = trustId
        self.trustState = trustState
        self.trustStateReason = trustStateReason
        self.trustType = trustType
    }
}

public enum TrustDirection {
    case oneWayIncoming
    case oneWayOutgoing
    case twoWay
    case sdkUnknown(String)
}

extension TrustDirection : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [TrustDirection] {
        return [
            .oneWayIncoming,
            .oneWayOutgoing,
            .twoWay,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .oneWayIncoming: return "One-Way: Incoming"
        case .oneWayOutgoing: return "One-Way: Outgoing"
        case .twoWay: return "Two-Way"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = TrustDirection(rawValue: rawValue) ?? TrustDirection.sdkUnknown(rawValue)
    }
}

public enum TrustState {
    case created
    case creating
    case deleted
    case deleting
    case failed
    case updated
    case updateFailed
    case updating
    case verified
    case verifying
    case verifyFailed
    case sdkUnknown(String)
}

extension TrustState : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [TrustState] {
        return [
            .created,
            .creating,
            .deleted,
            .deleting,
            .failed,
            .updated,
            .updateFailed,
            .updating,
            .verified,
            .verifying,
            .verifyFailed,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .created: return "Created"
        case .creating: return "Creating"
        case .deleted: return "Deleted"
        case .deleting: return "Deleting"
        case .failed: return "Failed"
        case .updated: return "Updated"
        case .updateFailed: return "UpdateFailed"
        case .updating: return "Updating"
        case .verified: return "Verified"
        case .verifying: return "Verifying"
        case .verifyFailed: return "VerifyFailed"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = TrustState(rawValue: rawValue) ?? TrustState.sdkUnknown(rawValue)
    }
}

public enum TrustType {
    case external
    case forest
    case sdkUnknown(String)
}

extension TrustType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [TrustType] {
        return [
            .external,
            .forest,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .external: return "External"
        case .forest: return "Forest"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = TrustType(rawValue: rawValue) ?? TrustType.sdkUnknown(rawValue)
    }
}

public struct UnshareDirectoryInputBodyMiddleware: Middleware {
    public let id: String = "UnshareDirectoryInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UnshareDirectoryInput>,
                  next: H) -> Swift.Result<OperationOutput<UnshareDirectoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UnshareDirectoryInput>
    public typealias MOutput = OperationOutput<UnshareDirectoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UnshareDirectoryOutputError>
}

extension UnshareDirectoryInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UnshareDirectoryInput(directoryId: \(String(describing: directoryId)), unshareTarget: \(String(describing: unshareTarget)))"}
}

extension UnshareDirectoryInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case directoryId = "DirectoryId"
        case unshareTarget = "UnshareTarget"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryId = directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let unshareTarget = unshareTarget {
            try encodeContainer.encode(unshareTarget, forKey: .unshareTarget)
        }
    }
}

public struct UnshareDirectoryInputHeadersMiddleware: Middleware {
    public let id: String = "UnshareDirectoryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UnshareDirectoryInput>,
                  next: H) -> Swift.Result<OperationOutput<UnshareDirectoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UnshareDirectoryInput>
    public typealias MOutput = OperationOutput<UnshareDirectoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UnshareDirectoryOutputError>
}

public struct UnshareDirectoryInputQueryItemMiddleware: Middleware {
    public let id: String = "UnshareDirectoryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UnshareDirectoryInput>,
                  next: H) -> Swift.Result<OperationOutput<UnshareDirectoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UnshareDirectoryInput>
    public typealias MOutput = OperationOutput<UnshareDirectoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UnshareDirectoryOutputError>
}

public struct UnshareDirectoryInput: Equatable {
    /// <p>The identifier of the AWS Managed Microsoft AD directory that you want to stop
    ///       sharing.</p>
    public let directoryId: String?
    /// <p>Identifier for the directory consumer account with whom the directory has to be
    ///       unshared.</p>
    public let unshareTarget: UnshareTarget?

    public init (
        directoryId: String? = nil,
        unshareTarget: UnshareTarget? = nil
    )
    {
        self.directoryId = directoryId
        self.unshareTarget = unshareTarget
    }
}

struct UnshareDirectoryInputBody: Equatable {
    public let directoryId: String?
    public let unshareTarget: UnshareTarget?
}

extension UnshareDirectoryInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case directoryId = "DirectoryId"
        case unshareTarget = "UnshareTarget"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let unshareTargetDecoded = try containerValues.decodeIfPresent(UnshareTarget.self, forKey: .unshareTarget)
        unshareTarget = unshareTargetDecoded
    }
}

extension UnshareDirectoryOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UnshareDirectoryOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryNotSharedException" : self = .directoryNotSharedException(try DirectoryNotSharedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityDoesNotExistException" : self = .entityDoesNotExistException(try EntityDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTargetException" : self = .invalidTargetException(try InvalidTargetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UnshareDirectoryOutputError: Equatable {
    case clientException(ClientException)
    case directoryNotSharedException(DirectoryNotSharedException)
    case entityDoesNotExistException(EntityDoesNotExistException)
    case invalidTargetException(InvalidTargetException)
    case serviceException(ServiceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UnshareDirectoryOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UnshareDirectoryOutputResponse(sharedDirectoryId: \(String(describing: sharedDirectoryId)))"}
}

extension UnshareDirectoryOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UnshareDirectoryOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.sharedDirectoryId = output.sharedDirectoryId
        } else {
            self.sharedDirectoryId = nil
        }
    }
}

public struct UnshareDirectoryOutputResponse: Equatable {
    /// <p>Identifier of the directory stored in the directory consumer account that is to be
    ///       unshared from the specified directory (<code>DirectoryId</code>).</p>
    public let sharedDirectoryId: String?

    public init (
        sharedDirectoryId: String? = nil
    )
    {
        self.sharedDirectoryId = sharedDirectoryId
    }
}

struct UnshareDirectoryOutputResponseBody: Equatable {
    public let sharedDirectoryId: String?
}

extension UnshareDirectoryOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case sharedDirectoryId = "SharedDirectoryId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sharedDirectoryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sharedDirectoryId)
        sharedDirectoryId = sharedDirectoryIdDecoded
    }
}

extension UnshareTarget: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case id = "Id"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let typeDecoded = try containerValues.decodeIfPresent(TargetType.self, forKey: .type)
        type = typeDecoded
    }
}

extension UnshareTarget: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UnshareTarget(id: \(String(describing: id)), type: \(String(describing: type)))"}
}

/// <p>Identifier that contains details about the directory consumer account with whom the
///       directory is being unshared.</p>
public struct UnshareTarget: Equatable {
    /// <p>Identifier of the directory consumer account.</p>
    public let id: String?
    /// <p>Type of identifier to be used in the <i>Id</i> field.</p>
    public let type: TargetType?

    public init (
        id: String? = nil,
        type: TargetType? = nil
    )
    {
        self.id = id
        self.type = type
    }
}

extension UnsupportedOperationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UnsupportedOperationException(message: \(String(describing: message)), requestId: \(String(describing: requestId)))"}
}

extension UnsupportedOperationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UnsupportedOperationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.requestId = output.requestId
        } else {
            self.message = nil
            self.requestId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The operation is not supported.</p>
public struct UnsupportedOperationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The descriptive message for the exception.</p>
    public var message: String?
    /// <p>The AWS request identifier.</p>
    public var requestId: String?

    public init (
        message: String? = nil,
        requestId: String? = nil
    )
    {
        self.message = message
        self.requestId = requestId
    }
}

struct UnsupportedOperationExceptionBody: Equatable {
    public let message: String?
    public let requestId: String?
}

extension UnsupportedOperationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case requestId = "RequestId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

public struct UpdateConditionalForwarderInputBodyMiddleware: Middleware {
    public let id: String = "UpdateConditionalForwarderInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateConditionalForwarderInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateConditionalForwarderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateConditionalForwarderInput>
    public typealias MOutput = OperationOutput<UpdateConditionalForwarderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateConditionalForwarderOutputError>
}

extension UpdateConditionalForwarderInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateConditionalForwarderInput(directoryId: \(String(describing: directoryId)), dnsIpAddrs: \(String(describing: dnsIpAddrs)), remoteDomainName: \(String(describing: remoteDomainName)))"}
}

extension UpdateConditionalForwarderInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case directoryId = "DirectoryId"
        case dnsIpAddrs = "DnsIpAddrs"
        case remoteDomainName = "RemoteDomainName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryId = directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let dnsIpAddrs = dnsIpAddrs {
            var dnsIpAddrsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dnsIpAddrs)
            for dnsipaddrs0 in dnsIpAddrs {
                try dnsIpAddrsContainer.encode(dnsipaddrs0)
            }
        }
        if let remoteDomainName = remoteDomainName {
            try encodeContainer.encode(remoteDomainName, forKey: .remoteDomainName)
        }
    }
}

public struct UpdateConditionalForwarderInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateConditionalForwarderInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateConditionalForwarderInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateConditionalForwarderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateConditionalForwarderInput>
    public typealias MOutput = OperationOutput<UpdateConditionalForwarderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateConditionalForwarderOutputError>
}

public struct UpdateConditionalForwarderInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateConditionalForwarderInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateConditionalForwarderInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateConditionalForwarderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateConditionalForwarderInput>
    public typealias MOutput = OperationOutput<UpdateConditionalForwarderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateConditionalForwarderOutputError>
}

/// <p>Updates a conditional forwarder.</p>
public struct UpdateConditionalForwarderInput: Equatable {
    /// <p>The directory ID of the AWS directory for which to update the conditional forwarder.</p>
    public let directoryId: String?
    /// <p>The updated IP addresses of the remote DNS server associated with the conditional forwarder.</p>
    public let dnsIpAddrs: [String]?
    /// <p>The fully qualified domain name (FQDN) of the remote domain with which you will set up a trust relationship.</p>
    public let remoteDomainName: String?

    public init (
        directoryId: String? = nil,
        dnsIpAddrs: [String]? = nil,
        remoteDomainName: String? = nil
    )
    {
        self.directoryId = directoryId
        self.dnsIpAddrs = dnsIpAddrs
        self.remoteDomainName = remoteDomainName
    }
}

struct UpdateConditionalForwarderInputBody: Equatable {
    public let directoryId: String?
    public let remoteDomainName: String?
    public let dnsIpAddrs: [String]?
}

extension UpdateConditionalForwarderInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case directoryId = "DirectoryId"
        case dnsIpAddrs = "DnsIpAddrs"
        case remoteDomainName = "RemoteDomainName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let remoteDomainNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .remoteDomainName)
        remoteDomainName = remoteDomainNameDecoded
        let dnsIpAddrsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .dnsIpAddrs)
        var dnsIpAddrsDecoded0:[String]? = nil
        if let dnsIpAddrsContainer = dnsIpAddrsContainer {
            dnsIpAddrsDecoded0 = [String]()
            for string0 in dnsIpAddrsContainer {
                if let string0 = string0 {
                    dnsIpAddrsDecoded0?.append(string0)
                }
            }
        }
        dnsIpAddrs = dnsIpAddrsDecoded0
    }
}

extension UpdateConditionalForwarderOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateConditionalForwarderOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryUnavailableException" : self = .directoryUnavailableException(try DirectoryUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityDoesNotExistException" : self = .entityDoesNotExistException(try EntityDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateConditionalForwarderOutputError: Equatable {
    case clientException(ClientException)
    case directoryUnavailableException(DirectoryUnavailableException)
    case entityDoesNotExistException(EntityDoesNotExistException)
    case invalidParameterException(InvalidParameterException)
    case serviceException(ServiceException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateConditionalForwarderOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateConditionalForwarderOutputResponse()"}
}

extension UpdateConditionalForwarderOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>The result of an UpdateConditionalForwarder request.</p>
public struct UpdateConditionalForwarderOutputResponse: Equatable {

    public init() {}
}

struct UpdateConditionalForwarderOutputResponseBody: Equatable {
}

extension UpdateConditionalForwarderOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateNumberOfDomainControllersInputBodyMiddleware: Middleware {
    public let id: String = "UpdateNumberOfDomainControllersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateNumberOfDomainControllersInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateNumberOfDomainControllersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateNumberOfDomainControllersInput>
    public typealias MOutput = OperationOutput<UpdateNumberOfDomainControllersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateNumberOfDomainControllersOutputError>
}

extension UpdateNumberOfDomainControllersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateNumberOfDomainControllersInput(desiredNumber: \(String(describing: desiredNumber)), directoryId: \(String(describing: directoryId)))"}
}

extension UpdateNumberOfDomainControllersInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case desiredNumber = "DesiredNumber"
        case directoryId = "DirectoryId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if desiredNumber != 0 {
            try encodeContainer.encode(desiredNumber, forKey: .desiredNumber)
        }
        if let directoryId = directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
    }
}

public struct UpdateNumberOfDomainControllersInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateNumberOfDomainControllersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateNumberOfDomainControllersInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateNumberOfDomainControllersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateNumberOfDomainControllersInput>
    public typealias MOutput = OperationOutput<UpdateNumberOfDomainControllersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateNumberOfDomainControllersOutputError>
}

public struct UpdateNumberOfDomainControllersInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateNumberOfDomainControllersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateNumberOfDomainControllersInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateNumberOfDomainControllersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateNumberOfDomainControllersInput>
    public typealias MOutput = OperationOutput<UpdateNumberOfDomainControllersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateNumberOfDomainControllersOutputError>
}

public struct UpdateNumberOfDomainControllersInput: Equatable {
    /// <p>The number of domain controllers desired in the directory.</p>
    public let desiredNumber: Int
    /// <p>Identifier of the directory to which the domain controllers will be added or removed.</p>
    public let directoryId: String?

    public init (
        desiredNumber: Int = 0,
        directoryId: String? = nil
    )
    {
        self.desiredNumber = desiredNumber
        self.directoryId = directoryId
    }
}

struct UpdateNumberOfDomainControllersInputBody: Equatable {
    public let directoryId: String?
    public let desiredNumber: Int
}

extension UpdateNumberOfDomainControllersInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case desiredNumber = "DesiredNumber"
        case directoryId = "DirectoryId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let desiredNumberDecoded = try containerValues.decode(Int.self, forKey: .desiredNumber)
        desiredNumber = desiredNumberDecoded
    }
}

extension UpdateNumberOfDomainControllersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateNumberOfDomainControllersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryUnavailableException" : self = .directoryUnavailableException(try DirectoryUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DomainControllerLimitExceededException" : self = .domainControllerLimitExceededException(try DomainControllerLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityDoesNotExistException" : self = .entityDoesNotExistException(try EntityDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateNumberOfDomainControllersOutputError: Equatable {
    case clientException(ClientException)
    case directoryUnavailableException(DirectoryUnavailableException)
    case domainControllerLimitExceededException(DomainControllerLimitExceededException)
    case entityDoesNotExistException(EntityDoesNotExistException)
    case invalidParameterException(InvalidParameterException)
    case serviceException(ServiceException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateNumberOfDomainControllersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateNumberOfDomainControllersOutputResponse()"}
}

extension UpdateNumberOfDomainControllersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateNumberOfDomainControllersOutputResponse: Equatable {

    public init() {}
}

struct UpdateNumberOfDomainControllersOutputResponseBody: Equatable {
}

extension UpdateNumberOfDomainControllersOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateRadiusInputBodyMiddleware: Middleware {
    public let id: String = "UpdateRadiusInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateRadiusInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateRadiusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateRadiusInput>
    public typealias MOutput = OperationOutput<UpdateRadiusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateRadiusOutputError>
}

extension UpdateRadiusInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateRadiusInput(directoryId: \(String(describing: directoryId)), radiusSettings: \(String(describing: radiusSettings)))"}
}

extension UpdateRadiusInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case directoryId = "DirectoryId"
        case radiusSettings = "RadiusSettings"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryId = directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let radiusSettings = radiusSettings {
            try encodeContainer.encode(radiusSettings, forKey: .radiusSettings)
        }
    }
}

public struct UpdateRadiusInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateRadiusInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateRadiusInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateRadiusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateRadiusInput>
    public typealias MOutput = OperationOutput<UpdateRadiusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateRadiusOutputError>
}

public struct UpdateRadiusInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateRadiusInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateRadiusInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateRadiusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateRadiusInput>
    public typealias MOutput = OperationOutput<UpdateRadiusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateRadiusOutputError>
}

/// <p>Contains the inputs for the <a>UpdateRadius</a> operation.</p>
public struct UpdateRadiusInput: Equatable {
    /// <p>The identifier of the directory for which to update the RADIUS server information.</p>
    public let directoryId: String?
    /// <p>A <a>RadiusSettings</a> object that contains information about the RADIUS server.</p>
    public let radiusSettings: RadiusSettings?

    public init (
        directoryId: String? = nil,
        radiusSettings: RadiusSettings? = nil
    )
    {
        self.directoryId = directoryId
        self.radiusSettings = radiusSettings
    }
}

struct UpdateRadiusInputBody: Equatable {
    public let directoryId: String?
    public let radiusSettings: RadiusSettings?
}

extension UpdateRadiusInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case directoryId = "DirectoryId"
        case radiusSettings = "RadiusSettings"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let radiusSettingsDecoded = try containerValues.decodeIfPresent(RadiusSettings.self, forKey: .radiusSettings)
        radiusSettings = radiusSettingsDecoded
    }
}

extension UpdateRadiusOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateRadiusOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityDoesNotExistException" : self = .entityDoesNotExistException(try EntityDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateRadiusOutputError: Equatable {
    case clientException(ClientException)
    case entityDoesNotExistException(EntityDoesNotExistException)
    case invalidParameterException(InvalidParameterException)
    case serviceException(ServiceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateRadiusOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateRadiusOutputResponse()"}
}

extension UpdateRadiusOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>Contains the results of the <a>UpdateRadius</a> operation.</p>
public struct UpdateRadiusOutputResponse: Equatable {

    public init() {}
}

struct UpdateRadiusOutputResponseBody: Equatable {
}

extension UpdateRadiusOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateTrustInputBodyMiddleware: Middleware {
    public let id: String = "UpdateTrustInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateTrustInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateTrustOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateTrustInput>
    public typealias MOutput = OperationOutput<UpdateTrustOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateTrustOutputError>
}

extension UpdateTrustInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateTrustInput(selectiveAuth: \(String(describing: selectiveAuth)), trustId: \(String(describing: trustId)))"}
}

extension UpdateTrustInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case selectiveAuth = "SelectiveAuth"
        case trustId = "TrustId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let selectiveAuth = selectiveAuth {
            try encodeContainer.encode(selectiveAuth.rawValue, forKey: .selectiveAuth)
        }
        if let trustId = trustId {
            try encodeContainer.encode(trustId, forKey: .trustId)
        }
    }
}

public struct UpdateTrustInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateTrustInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateTrustInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateTrustOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateTrustInput>
    public typealias MOutput = OperationOutput<UpdateTrustOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateTrustOutputError>
}

public struct UpdateTrustInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateTrustInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateTrustInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateTrustOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateTrustInput>
    public typealias MOutput = OperationOutput<UpdateTrustOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateTrustOutputError>
}

public struct UpdateTrustInput: Equatable {
    /// <p>Updates selective authentication for the trust.</p>
    public let selectiveAuth: SelectiveAuth?
    /// <p>Identifier of the trust relationship.</p>
    public let trustId: String?

    public init (
        selectiveAuth: SelectiveAuth? = nil,
        trustId: String? = nil
    )
    {
        self.selectiveAuth = selectiveAuth
        self.trustId = trustId
    }
}

struct UpdateTrustInputBody: Equatable {
    public let trustId: String?
    public let selectiveAuth: SelectiveAuth?
}

extension UpdateTrustInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case selectiveAuth = "SelectiveAuth"
        case trustId = "TrustId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trustIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .trustId)
        trustId = trustIdDecoded
        let selectiveAuthDecoded = try containerValues.decodeIfPresent(SelectiveAuth.self, forKey: .selectiveAuth)
        selectiveAuth = selectiveAuthDecoded
    }
}

extension UpdateTrustOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateTrustOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityDoesNotExistException" : self = .entityDoesNotExistException(try EntityDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateTrustOutputError: Equatable {
    case clientException(ClientException)
    case entityDoesNotExistException(EntityDoesNotExistException)
    case invalidParameterException(InvalidParameterException)
    case serviceException(ServiceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateTrustOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateTrustOutputResponse(requestId: \(String(describing: requestId)), trustId: \(String(describing: trustId)))"}
}

extension UpdateTrustOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateTrustOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.requestId = output.requestId
            self.trustId = output.trustId
        } else {
            self.requestId = nil
            self.trustId = nil
        }
    }
}

public struct UpdateTrustOutputResponse: Equatable {
    /// <p>The AWS request identifier.</p>
    public let requestId: String?
    /// <p>Identifier of the trust relationship.</p>
    public let trustId: String?

    public init (
        requestId: String? = nil,
        trustId: String? = nil
    )
    {
        self.requestId = requestId
        self.trustId = trustId
    }
}

struct UpdateTrustOutputResponseBody: Equatable {
    public let requestId: String?
    public let trustId: String?
}

extension UpdateTrustOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case requestId = "RequestId"
        case trustId = "TrustId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let trustIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .trustId)
        trustId = trustIdDecoded
    }
}

extension UserDoesNotExistException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UserDoesNotExistException(message: \(String(describing: message)), requestId: \(String(describing: requestId)))"}
}

extension UserDoesNotExistException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UserDoesNotExistExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.requestId = output.requestId
        } else {
            self.message = nil
            self.requestId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The user provided a username that does not exist in your directory.</p>
public struct UserDoesNotExistException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The descriptive message for the exception.</p>
    public var message: String?
    /// <p>The AWS request identifier.</p>
    public var requestId: String?

    public init (
        message: String? = nil,
        requestId: String? = nil
    )
    {
        self.message = message
        self.requestId = requestId
    }
}

struct UserDoesNotExistExceptionBody: Equatable {
    public let message: String?
    public let requestId: String?
}

extension UserDoesNotExistExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case requestId = "RequestId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

public struct VerifyTrustInputBodyMiddleware: Middleware {
    public let id: String = "VerifyTrustInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<VerifyTrustInput>,
                  next: H) -> Swift.Result<OperationOutput<VerifyTrustOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<VerifyTrustInput>
    public typealias MOutput = OperationOutput<VerifyTrustOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<VerifyTrustOutputError>
}

extension VerifyTrustInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VerifyTrustInput(trustId: \(String(describing: trustId)))"}
}

extension VerifyTrustInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case trustId = "TrustId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let trustId = trustId {
            try encodeContainer.encode(trustId, forKey: .trustId)
        }
    }
}

public struct VerifyTrustInputHeadersMiddleware: Middleware {
    public let id: String = "VerifyTrustInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<VerifyTrustInput>,
                  next: H) -> Swift.Result<OperationOutput<VerifyTrustOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<VerifyTrustInput>
    public typealias MOutput = OperationOutput<VerifyTrustOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<VerifyTrustOutputError>
}

public struct VerifyTrustInputQueryItemMiddleware: Middleware {
    public let id: String = "VerifyTrustInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<VerifyTrustInput>,
                  next: H) -> Swift.Result<OperationOutput<VerifyTrustOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<VerifyTrustInput>
    public typealias MOutput = OperationOutput<VerifyTrustOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<VerifyTrustOutputError>
}

/// <p>Initiates the verification of an existing trust relationship between an AWS Managed Microsoft AD directory and an external domain.</p>
public struct VerifyTrustInput: Equatable {
    /// <p>The unique Trust ID of the trust relationship to verify.</p>
    public let trustId: String?

    public init (
        trustId: String? = nil
    )
    {
        self.trustId = trustId
    }
}

struct VerifyTrustInputBody: Equatable {
    public let trustId: String?
}

extension VerifyTrustInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case trustId = "TrustId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trustIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .trustId)
        trustId = trustIdDecoded
    }
}

extension VerifyTrustOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension VerifyTrustOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityDoesNotExistException" : self = .entityDoesNotExistException(try EntityDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum VerifyTrustOutputError: Equatable {
    case clientException(ClientException)
    case entityDoesNotExistException(EntityDoesNotExistException)
    case invalidParameterException(InvalidParameterException)
    case serviceException(ServiceException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension VerifyTrustOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VerifyTrustOutputResponse(trustId: \(String(describing: trustId)))"}
}

extension VerifyTrustOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: VerifyTrustOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.trustId = output.trustId
        } else {
            self.trustId = nil
        }
    }
}

/// <p>Result of a VerifyTrust request.</p>
public struct VerifyTrustOutputResponse: Equatable {
    /// <p>The unique Trust ID of the trust relationship that was verified.</p>
    public let trustId: String?

    public init (
        trustId: String? = nil
    )
    {
        self.trustId = trustId
    }
}

struct VerifyTrustOutputResponseBody: Equatable {
    public let trustId: String?
}

extension VerifyTrustOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case trustId = "TrustId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trustIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .trustId)
        trustId = trustIdDecoded
    }
}
