// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension WorkMailClientTypes.AccessControlRule: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actions = "Actions"
        case dateCreated = "DateCreated"
        case dateModified = "DateModified"
        case description = "Description"
        case effect = "Effect"
        case impersonationRoleIds = "ImpersonationRoleIds"
        case ipRanges = "IpRanges"
        case name = "Name"
        case notActions = "NotActions"
        case notImpersonationRoleIds = "NotImpersonationRoleIds"
        case notIpRanges = "NotIpRanges"
        case notUserIds = "NotUserIds"
        case userIds = "UserIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actions = actions {
            var actionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .actions)
            for accesscontrolruleaction0 in actions {
                try actionsContainer.encode(accesscontrolruleaction0)
            }
        }
        if let dateCreated = self.dateCreated {
            try encodeContainer.encodeTimestamp(dateCreated, format: .epochSeconds, forKey: .dateCreated)
        }
        if let dateModified = self.dateModified {
            try encodeContainer.encodeTimestamp(dateModified, format: .epochSeconds, forKey: .dateModified)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let effect = self.effect {
            try encodeContainer.encode(effect.rawValue, forKey: .effect)
        }
        if let impersonationRoleIds = impersonationRoleIds {
            var impersonationRoleIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .impersonationRoleIds)
            for impersonationroleid0 in impersonationRoleIds {
                try impersonationRoleIdsContainer.encode(impersonationroleid0)
            }
        }
        if let ipRanges = ipRanges {
            var ipRangesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ipRanges)
            for iprange0 in ipRanges {
                try ipRangesContainer.encode(iprange0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let notActions = notActions {
            var notActionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notActions)
            for accesscontrolruleaction0 in notActions {
                try notActionsContainer.encode(accesscontrolruleaction0)
            }
        }
        if let notImpersonationRoleIds = notImpersonationRoleIds {
            var notImpersonationRoleIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notImpersonationRoleIds)
            for impersonationroleid0 in notImpersonationRoleIds {
                try notImpersonationRoleIdsContainer.encode(impersonationroleid0)
            }
        }
        if let notIpRanges = notIpRanges {
            var notIpRangesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notIpRanges)
            for iprange0 in notIpRanges {
                try notIpRangesContainer.encode(iprange0)
            }
        }
        if let notUserIds = notUserIds {
            var notUserIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notUserIds)
            for workmailidentifier0 in notUserIds {
                try notUserIdsContainer.encode(workmailidentifier0)
            }
        }
        if let userIds = userIds {
            var userIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .userIds)
            for workmailidentifier0 in userIds {
                try userIdsContainer.encode(workmailidentifier0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let effectDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.AccessControlRuleEffect.self, forKey: .effect)
        effect = effectDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let ipRangesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ipRanges)
        var ipRangesDecoded0:[Swift.String]? = nil
        if let ipRangesContainer = ipRangesContainer {
            ipRangesDecoded0 = [Swift.String]()
            for string0 in ipRangesContainer {
                if let string0 = string0 {
                    ipRangesDecoded0?.append(string0)
                }
            }
        }
        ipRanges = ipRangesDecoded0
        let notIpRangesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .notIpRanges)
        var notIpRangesDecoded0:[Swift.String]? = nil
        if let notIpRangesContainer = notIpRangesContainer {
            notIpRangesDecoded0 = [Swift.String]()
            for string0 in notIpRangesContainer {
                if let string0 = string0 {
                    notIpRangesDecoded0?.append(string0)
                }
            }
        }
        notIpRanges = notIpRangesDecoded0
        let actionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .actions)
        var actionsDecoded0:[Swift.String]? = nil
        if let actionsContainer = actionsContainer {
            actionsDecoded0 = [Swift.String]()
            for string0 in actionsContainer {
                if let string0 = string0 {
                    actionsDecoded0?.append(string0)
                }
            }
        }
        actions = actionsDecoded0
        let notActionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .notActions)
        var notActionsDecoded0:[Swift.String]? = nil
        if let notActionsContainer = notActionsContainer {
            notActionsDecoded0 = [Swift.String]()
            for string0 in notActionsContainer {
                if let string0 = string0 {
                    notActionsDecoded0?.append(string0)
                }
            }
        }
        notActions = notActionsDecoded0
        let userIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .userIds)
        var userIdsDecoded0:[Swift.String]? = nil
        if let userIdsContainer = userIdsContainer {
            userIdsDecoded0 = [Swift.String]()
            for string0 in userIdsContainer {
                if let string0 = string0 {
                    userIdsDecoded0?.append(string0)
                }
            }
        }
        userIds = userIdsDecoded0
        let notUserIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .notUserIds)
        var notUserIdsDecoded0:[Swift.String]? = nil
        if let notUserIdsContainer = notUserIdsContainer {
            notUserIdsDecoded0 = [Swift.String]()
            for string0 in notUserIdsContainer {
                if let string0 = string0 {
                    notUserIdsDecoded0?.append(string0)
                }
            }
        }
        notUserIds = notUserIdsDecoded0
        let dateCreatedDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .dateCreated)
        dateCreated = dateCreatedDecoded
        let dateModifiedDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .dateModified)
        dateModified = dateModifiedDecoded
        let impersonationRoleIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .impersonationRoleIds)
        var impersonationRoleIdsDecoded0:[Swift.String]? = nil
        if let impersonationRoleIdsContainer = impersonationRoleIdsContainer {
            impersonationRoleIdsDecoded0 = [Swift.String]()
            for string0 in impersonationRoleIdsContainer {
                if let string0 = string0 {
                    impersonationRoleIdsDecoded0?.append(string0)
                }
            }
        }
        impersonationRoleIds = impersonationRoleIdsDecoded0
        let notImpersonationRoleIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .notImpersonationRoleIds)
        var notImpersonationRoleIdsDecoded0:[Swift.String]? = nil
        if let notImpersonationRoleIdsContainer = notImpersonationRoleIdsContainer {
            notImpersonationRoleIdsDecoded0 = [Swift.String]()
            for string0 in notImpersonationRoleIdsContainer {
                if let string0 = string0 {
                    notImpersonationRoleIdsDecoded0?.append(string0)
                }
            }
        }
        notImpersonationRoleIds = notImpersonationRoleIdsDecoded0
    }
}

extension WorkMailClientTypes {
    /// A rule that controls access to an WorkMail organization.
    public struct AccessControlRule: Swift.Equatable {
        /// Access protocol actions to include in the rule. Valid values include ActiveSync, AutoDiscover, EWS, IMAP, SMTP, WindowsOutlook, and WebMail.
        public var actions: [Swift.String]?
        /// The date that the rule was created.
        public var dateCreated: ClientRuntime.Date?
        /// The date that the rule was modified.
        public var dateModified: ClientRuntime.Date?
        /// The rule description.
        public var description: Swift.String?
        /// The rule effect.
        public var effect: WorkMailClientTypes.AccessControlRuleEffect?
        /// Impersonation role IDs to include in the rule.
        public var impersonationRoleIds: [Swift.String]?
        /// IPv4 CIDR ranges to include in the rule.
        public var ipRanges: [Swift.String]?
        /// The rule name.
        public var name: Swift.String?
        /// Access protocol actions to exclude from the rule. Valid values include ActiveSync, AutoDiscover, EWS, IMAP, SMTP, WindowsOutlook, and WebMail.
        public var notActions: [Swift.String]?
        /// Impersonation role IDs to exclude from the rule.
        public var notImpersonationRoleIds: [Swift.String]?
        /// IPv4 CIDR ranges to exclude from the rule.
        public var notIpRanges: [Swift.String]?
        /// User IDs to exclude from the rule.
        public var notUserIds: [Swift.String]?
        /// User IDs to include in the rule.
        public var userIds: [Swift.String]?

        public init (
            actions: [Swift.String]? = nil,
            dateCreated: ClientRuntime.Date? = nil,
            dateModified: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            effect: WorkMailClientTypes.AccessControlRuleEffect? = nil,
            impersonationRoleIds: [Swift.String]? = nil,
            ipRanges: [Swift.String]? = nil,
            name: Swift.String? = nil,
            notActions: [Swift.String]? = nil,
            notImpersonationRoleIds: [Swift.String]? = nil,
            notIpRanges: [Swift.String]? = nil,
            notUserIds: [Swift.String]? = nil,
            userIds: [Swift.String]? = nil
        )
        {
            self.actions = actions
            self.dateCreated = dateCreated
            self.dateModified = dateModified
            self.description = description
            self.effect = effect
            self.impersonationRoleIds = impersonationRoleIds
            self.ipRanges = ipRanges
            self.name = name
            self.notActions = notActions
            self.notImpersonationRoleIds = notImpersonationRoleIds
            self.notIpRanges = notIpRanges
            self.notUserIds = notUserIds
            self.userIds = userIds
        }
    }

}

extension WorkMailClientTypes {
    public enum AccessControlRuleEffect: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case allow
        case deny
        case sdkUnknown(Swift.String)

        public static var allCases: [AccessControlRuleEffect] {
            return [
                .allow,
                .deny,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .allow: return "ALLOW"
            case .deny: return "DENY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AccessControlRuleEffect(rawValue: rawValue) ?? AccessControlRuleEffect.sdkUnknown(rawValue)
        }
    }
}

extension WorkMailClientTypes {
    public enum AccessEffect: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case allow
        case deny
        case sdkUnknown(Swift.String)

        public static var allCases: [AccessEffect] {
            return [
                .allow,
                .deny,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .allow: return "ALLOW"
            case .deny: return "DENY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AccessEffect(rawValue: rawValue) ?? AccessEffect.sdkUnknown(rawValue)
        }
    }
}

extension AssociateDelegateToResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entityId = "EntityId"
        case organizationId = "OrganizationId"
        case resourceId = "ResourceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entityId = self.entityId {
            try encodeContainer.encode(entityId, forKey: .entityId)
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
    }
}

extension AssociateDelegateToResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AssociateDelegateToResourceInput: Swift.Equatable {
    /// The member (user or group) to associate to the resource.
    /// This member is required.
    public var entityId: Swift.String?
    /// The organization under which the resource exists.
    /// This member is required.
    public var organizationId: Swift.String?
    /// The resource for which members (users or groups) are associated.
    /// This member is required.
    public var resourceId: Swift.String?

    public init (
        entityId: Swift.String? = nil,
        organizationId: Swift.String? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.entityId = entityId
        self.organizationId = organizationId
        self.resourceId = resourceId
    }
}

struct AssociateDelegateToResourceInputBody: Swift.Equatable {
    let organizationId: Swift.String?
    let resourceId: Swift.String?
    let entityId: Swift.String?
}

extension AssociateDelegateToResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entityId = "EntityId"
        case organizationId = "OrganizationId"
        case resourceId = "ResourceId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let entityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityId)
        entityId = entityIdDecoded
    }
}

extension AssociateDelegateToResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateDelegateToResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityStateException" : self = .entityStateException(try EntityStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum AssociateDelegateToResourceOutputError: Swift.Error, Swift.Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case entityStateException(EntityStateException)
    case invalidParameterException(InvalidParameterException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateDelegateToResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct AssociateDelegateToResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension AssociateMemberToGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupId = "GroupId"
        case memberId = "MemberId"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupId = self.groupId {
            try encodeContainer.encode(groupId, forKey: .groupId)
        }
        if let memberId = self.memberId {
            try encodeContainer.encode(memberId, forKey: .memberId)
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

extension AssociateMemberToGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AssociateMemberToGroupInput: Swift.Equatable {
    /// The group to which the member (user or group) is associated.
    /// This member is required.
    public var groupId: Swift.String?
    /// The member (user or group) to associate to the group.
    /// This member is required.
    public var memberId: Swift.String?
    /// The organization under which the group exists.
    /// This member is required.
    public var organizationId: Swift.String?

    public init (
        groupId: Swift.String? = nil,
        memberId: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.groupId = groupId
        self.memberId = memberId
        self.organizationId = organizationId
    }
}

struct AssociateMemberToGroupInputBody: Swift.Equatable {
    let organizationId: Swift.String?
    let groupId: Swift.String?
    let memberId: Swift.String?
}

extension AssociateMemberToGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupId = "GroupId"
        case memberId = "MemberId"
        case organizationId = "OrganizationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let groupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupId)
        groupId = groupIdDecoded
        let memberIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .memberId)
        memberId = memberIdDecoded
    }
}

extension AssociateMemberToGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateMemberToGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DirectoryServiceAuthenticationFailedException" : self = .directoryServiceAuthenticationFailedException(try DirectoryServiceAuthenticationFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryUnavailableException" : self = .directoryUnavailableException(try DirectoryUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityStateException" : self = .entityStateException(try EntityStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum AssociateMemberToGroupOutputError: Swift.Error, Swift.Equatable {
    case directoryServiceAuthenticationFailedException(DirectoryServiceAuthenticationFailedException)
    case directoryUnavailableException(DirectoryUnavailableException)
    case entityNotFoundException(EntityNotFoundException)
    case entityStateException(EntityStateException)
    case invalidParameterException(InvalidParameterException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateMemberToGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct AssociateMemberToGroupOutputResponse: Swift.Equatable {

    public init () { }
}

extension AssumeImpersonationRoleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case impersonationRoleId = "ImpersonationRoleId"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let impersonationRoleId = self.impersonationRoleId {
            try encodeContainer.encode(impersonationRoleId, forKey: .impersonationRoleId)
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

extension AssumeImpersonationRoleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AssumeImpersonationRoleInput: Swift.Equatable {
    /// The impersonation role ID to assume.
    /// This member is required.
    public var impersonationRoleId: Swift.String?
    /// The WorkMail organization under which the impersonation role will be assumed.
    /// This member is required.
    public var organizationId: Swift.String?

    public init (
        impersonationRoleId: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.impersonationRoleId = impersonationRoleId
        self.organizationId = organizationId
    }
}

struct AssumeImpersonationRoleInputBody: Swift.Equatable {
    let organizationId: Swift.String?
    let impersonationRoleId: Swift.String?
}

extension AssumeImpersonationRoleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case impersonationRoleId = "ImpersonationRoleId"
        case organizationId = "OrganizationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let impersonationRoleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .impersonationRoleId)
        impersonationRoleId = impersonationRoleIdDecoded
    }
}

extension AssumeImpersonationRoleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssumeImpersonationRoleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum AssumeImpersonationRoleOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterException(InvalidParameterException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssumeImpersonationRoleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AssumeImpersonationRoleOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.expiresIn = output.expiresIn
            self.token = output.token
        } else {
            self.expiresIn = nil
            self.token = nil
        }
    }
}

public struct AssumeImpersonationRoleOutputResponse: Swift.Equatable {
    /// The authentication token's validity, in seconds.
    public var expiresIn: Swift.Int?
    /// The authentication token for the impersonation role.
    public var token: Swift.String?

    public init (
        expiresIn: Swift.Int? = nil,
        token: Swift.String? = nil
    )
    {
        self.expiresIn = expiresIn
        self.token = token
    }
}

struct AssumeImpersonationRoleOutputResponseBody: Swift.Equatable {
    let token: Swift.String?
    let expiresIn: Swift.Int?
}

extension AssumeImpersonationRoleOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case expiresIn = "ExpiresIn"
        case token = "Token"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .token)
        token = tokenDecoded
        let expiresInDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .expiresIn)
        expiresIn = expiresInDecoded
    }
}

extension WorkMailClientTypes.AvailabilityConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dateCreated = "DateCreated"
        case dateModified = "DateModified"
        case domainName = "DomainName"
        case ewsProvider = "EwsProvider"
        case lambdaProvider = "LambdaProvider"
        case providerType = "ProviderType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dateCreated = self.dateCreated {
            try encodeContainer.encodeTimestamp(dateCreated, format: .epochSeconds, forKey: .dateCreated)
        }
        if let dateModified = self.dateModified {
            try encodeContainer.encodeTimestamp(dateModified, format: .epochSeconds, forKey: .dateModified)
        }
        if let domainName = self.domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let ewsProvider = self.ewsProvider {
            try encodeContainer.encode(ewsProvider, forKey: .ewsProvider)
        }
        if let lambdaProvider = self.lambdaProvider {
            try encodeContainer.encode(lambdaProvider, forKey: .lambdaProvider)
        }
        if let providerType = self.providerType {
            try encodeContainer.encode(providerType.rawValue, forKey: .providerType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let providerTypeDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.AvailabilityProviderType.self, forKey: .providerType)
        providerType = providerTypeDecoded
        let ewsProviderDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.RedactedEwsAvailabilityProvider.self, forKey: .ewsProvider)
        ewsProvider = ewsProviderDecoded
        let lambdaProviderDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.LambdaAvailabilityProvider.self, forKey: .lambdaProvider)
        lambdaProvider = lambdaProviderDecoded
        let dateCreatedDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .dateCreated)
        dateCreated = dateCreatedDecoded
        let dateModifiedDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .dateModified)
        dateModified = dateModifiedDecoded
    }
}

extension WorkMailClientTypes {
    /// List all the AvailabilityConfiguration's for the given WorkMail organization.
    public struct AvailabilityConfiguration: Swift.Equatable {
        /// The date and time at which the availability configuration was created.
        public var dateCreated: ClientRuntime.Date?
        /// The date and time at which the availability configuration was last modified.
        public var dateModified: ClientRuntime.Date?
        /// Displays the domain to which the provider applies.
        public var domainName: Swift.String?
        /// If ProviderType is EWS, then this field contains RedactedEwsAvailabilityProvider. Otherwise, it is not required.
        public var ewsProvider: WorkMailClientTypes.RedactedEwsAvailabilityProvider?
        /// If ProviderType is LAMBDA then this field contains LambdaAvailabilityProvider. Otherwise, it is not required.
        public var lambdaProvider: WorkMailClientTypes.LambdaAvailabilityProvider?
        /// Displays the provider type that applies to this domain.
        public var providerType: WorkMailClientTypes.AvailabilityProviderType?

        public init (
            dateCreated: ClientRuntime.Date? = nil,
            dateModified: ClientRuntime.Date? = nil,
            domainName: Swift.String? = nil,
            ewsProvider: WorkMailClientTypes.RedactedEwsAvailabilityProvider? = nil,
            lambdaProvider: WorkMailClientTypes.LambdaAvailabilityProvider? = nil,
            providerType: WorkMailClientTypes.AvailabilityProviderType? = nil
        )
        {
            self.dateCreated = dateCreated
            self.dateModified = dateModified
            self.domainName = domainName
            self.ewsProvider = ewsProvider
            self.lambdaProvider = lambdaProvider
            self.providerType = providerType
        }
    }

}

extension WorkMailClientTypes {
    public enum AvailabilityProviderType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ews
        case lambda
        case sdkUnknown(Swift.String)

        public static var allCases: [AvailabilityProviderType] {
            return [
                .ews,
                .lambda,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ews: return "EWS"
            case .lambda: return "LAMBDA"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AvailabilityProviderType(rawValue: rawValue) ?? AvailabilityProviderType.sdkUnknown(rawValue)
        }
    }
}

extension WorkMailClientTypes.BookingOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoAcceptRequests = "AutoAcceptRequests"
        case autoDeclineConflictingRequests = "AutoDeclineConflictingRequests"
        case autoDeclineRecurringRequests = "AutoDeclineRecurringRequests"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if autoAcceptRequests != false {
            try encodeContainer.encode(autoAcceptRequests, forKey: .autoAcceptRequests)
        }
        if autoDeclineConflictingRequests != false {
            try encodeContainer.encode(autoDeclineConflictingRequests, forKey: .autoDeclineConflictingRequests)
        }
        if autoDeclineRecurringRequests != false {
            try encodeContainer.encode(autoDeclineRecurringRequests, forKey: .autoDeclineRecurringRequests)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoAcceptRequestsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoAcceptRequests) ?? false
        autoAcceptRequests = autoAcceptRequestsDecoded
        let autoDeclineRecurringRequestsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoDeclineRecurringRequests) ?? false
        autoDeclineRecurringRequests = autoDeclineRecurringRequestsDecoded
        let autoDeclineConflictingRequestsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoDeclineConflictingRequests) ?? false
        autoDeclineConflictingRequests = autoDeclineConflictingRequestsDecoded
    }
}

extension WorkMailClientTypes {
    /// At least one delegate must be associated to the resource to disable automatic replies from the resource.
    public struct BookingOptions: Swift.Equatable {
        /// The resource's ability to automatically reply to requests. If disabled, delegates must be associated to the resource.
        public var autoAcceptRequests: Swift.Bool
        /// The resource's ability to automatically decline any conflicting requests.
        public var autoDeclineConflictingRequests: Swift.Bool
        /// The resource's ability to automatically decline any recurring requests.
        public var autoDeclineRecurringRequests: Swift.Bool

        public init (
            autoAcceptRequests: Swift.Bool = false,
            autoDeclineConflictingRequests: Swift.Bool = false,
            autoDeclineRecurringRequests: Swift.Bool = false
        )
        {
            self.autoAcceptRequests = autoAcceptRequests
            self.autoDeclineConflictingRequests = autoDeclineConflictingRequests
            self.autoDeclineRecurringRequests = autoDeclineRecurringRequests
        }
    }

}

extension CancelMailboxExportJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case jobId = "JobId"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let jobId = self.jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

extension CancelMailboxExportJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CancelMailboxExportJobInput: Swift.Equatable {
    /// The idempotency token for the client request.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The job ID.
    /// This member is required.
    public var jobId: Swift.String?
    /// The organization ID.
    /// This member is required.
    public var organizationId: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        jobId: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.jobId = jobId
        self.organizationId = organizationId
    }
}

struct CancelMailboxExportJobInputBody: Swift.Equatable {
    let clientToken: Swift.String?
    let jobId: Swift.String?
    let organizationId: Swift.String?
}

extension CancelMailboxExportJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case jobId = "JobId"
        case organizationId = "OrganizationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
    }
}

extension CancelMailboxExportJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CancelMailboxExportJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CancelMailboxExportJobOutputError: Swift.Error, Swift.Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case invalidParameterException(InvalidParameterException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CancelMailboxExportJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct CancelMailboxExportJobOutputResponse: Swift.Equatable {

    public init () { }
}

extension CreateAliasInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alias = "Alias"
        case entityId = "EntityId"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alias = self.alias {
            try encodeContainer.encode(alias, forKey: .alias)
        }
        if let entityId = self.entityId {
            try encodeContainer.encode(entityId, forKey: .entityId)
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

extension CreateAliasInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateAliasInput: Swift.Equatable {
    /// The alias to add to the member set.
    /// This member is required.
    public var alias: Swift.String?
    /// The member (user or group) to which this alias is added.
    /// This member is required.
    public var entityId: Swift.String?
    /// The organization under which the member (user or group) exists.
    /// This member is required.
    public var organizationId: Swift.String?

    public init (
        alias: Swift.String? = nil,
        entityId: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.alias = alias
        self.entityId = entityId
        self.organizationId = organizationId
    }
}

struct CreateAliasInputBody: Swift.Equatable {
    let organizationId: Swift.String?
    let entityId: Swift.String?
    let alias: Swift.String?
}

extension CreateAliasInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alias = "Alias"
        case entityId = "EntityId"
        case organizationId = "OrganizationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let entityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityId)
        entityId = entityIdDecoded
        let aliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alias)
        alias = aliasDecoded
    }
}

extension CreateAliasOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateAliasOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EmailAddressInUseException" : self = .emailAddressInUseException(try EmailAddressInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityStateException" : self = .entityStateException(try EntityStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MailDomainNotFoundException" : self = .mailDomainNotFoundException(try MailDomainNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MailDomainStateException" : self = .mailDomainStateException(try MailDomainStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateAliasOutputError: Swift.Error, Swift.Equatable {
    case emailAddressInUseException(EmailAddressInUseException)
    case entityNotFoundException(EntityNotFoundException)
    case entityStateException(EntityStateException)
    case invalidParameterException(InvalidParameterException)
    case limitExceededException(LimitExceededException)
    case mailDomainNotFoundException(MailDomainNotFoundException)
    case mailDomainStateException(MailDomainStateException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAliasOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct CreateAliasOutputResponse: Swift.Equatable {

    public init () { }
}

extension CreateAvailabilityConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case domainName = "DomainName"
        case ewsProvider = "EwsProvider"
        case lambdaProvider = "LambdaProvider"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let domainName = self.domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let ewsProvider = self.ewsProvider {
            try encodeContainer.encode(ewsProvider, forKey: .ewsProvider)
        }
        if let lambdaProvider = self.lambdaProvider {
            try encodeContainer.encode(lambdaProvider, forKey: .lambdaProvider)
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

extension CreateAvailabilityConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateAvailabilityConfigurationInput: Swift.Equatable {
    /// An idempotent token that ensures that an API request is executed only once.
    public var clientToken: Swift.String?
    /// The domain to which the provider applies.
    /// This member is required.
    public var domainName: Swift.String?
    /// Exchange Web Services (EWS) availability provider definition. The request must contain exactly one provider definition, either EwsProvider or LambdaProvider.
    public var ewsProvider: WorkMailClientTypes.EwsAvailabilityProvider?
    /// Lambda availability provider definition. The request must contain exactly one provider definition, either EwsProvider or LambdaProvider.
    public var lambdaProvider: WorkMailClientTypes.LambdaAvailabilityProvider?
    /// The WorkMail organization for which the AvailabilityConfiguration will be created.
    /// This member is required.
    public var organizationId: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        domainName: Swift.String? = nil,
        ewsProvider: WorkMailClientTypes.EwsAvailabilityProvider? = nil,
        lambdaProvider: WorkMailClientTypes.LambdaAvailabilityProvider? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.domainName = domainName
        self.ewsProvider = ewsProvider
        self.lambdaProvider = lambdaProvider
        self.organizationId = organizationId
    }
}

struct CreateAvailabilityConfigurationInputBody: Swift.Equatable {
    let clientToken: Swift.String?
    let organizationId: Swift.String?
    let domainName: Swift.String?
    let ewsProvider: WorkMailClientTypes.EwsAvailabilityProvider?
    let lambdaProvider: WorkMailClientTypes.LambdaAvailabilityProvider?
}

extension CreateAvailabilityConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case domainName = "DomainName"
        case ewsProvider = "EwsProvider"
        case lambdaProvider = "LambdaProvider"
        case organizationId = "OrganizationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let ewsProviderDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.EwsAvailabilityProvider.self, forKey: .ewsProvider)
        ewsProvider = ewsProviderDecoded
        let lambdaProviderDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.LambdaAvailabilityProvider.self, forKey: .lambdaProvider)
        lambdaProvider = lambdaProviderDecoded
    }
}

extension CreateAvailabilityConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateAvailabilityConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NameAvailabilityException" : self = .nameAvailabilityException(try NameAvailabilityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateAvailabilityConfigurationOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterException(InvalidParameterException)
    case limitExceededException(LimitExceededException)
    case nameAvailabilityException(NameAvailabilityException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAvailabilityConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct CreateAvailabilityConfigurationOutputResponse: Swift.Equatable {

    public init () { }
}

extension CreateGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

extension CreateGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateGroupInput: Swift.Equatable {
    /// The name of the group.
    /// This member is required.
    public var name: Swift.String?
    /// The organization under which the group is to be created.
    /// This member is required.
    public var organizationId: Swift.String?

    public init (
        name: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.name = name
        self.organizationId = organizationId
    }
}

struct CreateGroupInputBody: Swift.Equatable {
    let organizationId: Swift.String?
    let name: Swift.String?
}

extension CreateGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case organizationId = "OrganizationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension CreateGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DirectoryServiceAuthenticationFailedException" : self = .directoryServiceAuthenticationFailedException(try DirectoryServiceAuthenticationFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryUnavailableException" : self = .directoryUnavailableException(try DirectoryUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NameAvailabilityException" : self = .nameAvailabilityException(try NameAvailabilityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ReservedNameException" : self = .reservedNameException(try ReservedNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateGroupOutputError: Swift.Error, Swift.Equatable {
    case directoryServiceAuthenticationFailedException(DirectoryServiceAuthenticationFailedException)
    case directoryUnavailableException(DirectoryUnavailableException)
    case invalidParameterException(InvalidParameterException)
    case nameAvailabilityException(NameAvailabilityException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case reservedNameException(ReservedNameException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.groupId = output.groupId
        } else {
            self.groupId = nil
        }
    }
}

public struct CreateGroupOutputResponse: Swift.Equatable {
    /// The identifier of the group.
    public var groupId: Swift.String?

    public init (
        groupId: Swift.String? = nil
    )
    {
        self.groupId = groupId
    }
}

struct CreateGroupOutputResponseBody: Swift.Equatable {
    let groupId: Swift.String?
}

extension CreateGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupId = "GroupId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupId)
        groupId = groupIdDecoded
    }
}

extension CreateImpersonationRoleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case name = "Name"
        case organizationId = "OrganizationId"
        case rules = "Rules"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
        if let rules = rules {
            var rulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rules)
            for impersonationrule0 in rules {
                try rulesContainer.encode(impersonationrule0)
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension CreateImpersonationRoleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateImpersonationRoleInput: Swift.Equatable {
    /// The idempotency token for the client request.
    public var clientToken: Swift.String?
    /// The description of the new impersonation role.
    public var description: Swift.String?
    /// The name of the new impersonation role.
    /// This member is required.
    public var name: Swift.String?
    /// The WorkMail organization to create the new impersonation role within.
    /// This member is required.
    public var organizationId: Swift.String?
    /// The list of rules for the impersonation role.
    /// This member is required.
    public var rules: [WorkMailClientTypes.ImpersonationRule]?
    /// The impersonation role's type. The available impersonation role types are READ_ONLY or FULL_ACCESS.
    /// This member is required.
    public var type: WorkMailClientTypes.ImpersonationRoleType?

    public init (
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        organizationId: Swift.String? = nil,
        rules: [WorkMailClientTypes.ImpersonationRule]? = nil,
        type: WorkMailClientTypes.ImpersonationRoleType? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.name = name
        self.organizationId = organizationId
        self.rules = rules
        self.type = type
    }
}

struct CreateImpersonationRoleInputBody: Swift.Equatable {
    let clientToken: Swift.String?
    let organizationId: Swift.String?
    let name: Swift.String?
    let type: WorkMailClientTypes.ImpersonationRoleType?
    let description: Swift.String?
    let rules: [WorkMailClientTypes.ImpersonationRule]?
}

extension CreateImpersonationRoleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case name = "Name"
        case organizationId = "OrganizationId"
        case rules = "Rules"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.ImpersonationRoleType.self, forKey: .type)
        type = typeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let rulesContainer = try containerValues.decodeIfPresent([WorkMailClientTypes.ImpersonationRule?].self, forKey: .rules)
        var rulesDecoded0:[WorkMailClientTypes.ImpersonationRule]? = nil
        if let rulesContainer = rulesContainer {
            rulesDecoded0 = [WorkMailClientTypes.ImpersonationRule]()
            for structure0 in rulesContainer {
                if let structure0 = structure0 {
                    rulesDecoded0?.append(structure0)
                }
            }
        }
        rules = rulesDecoded0
    }
}

extension CreateImpersonationRoleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateImpersonationRoleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityStateException" : self = .entityStateException(try EntityStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateImpersonationRoleOutputError: Swift.Error, Swift.Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case entityStateException(EntityStateException)
    case invalidParameterException(InvalidParameterException)
    case limitExceededException(LimitExceededException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateImpersonationRoleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateImpersonationRoleOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.impersonationRoleId = output.impersonationRoleId
        } else {
            self.impersonationRoleId = nil
        }
    }
}

public struct CreateImpersonationRoleOutputResponse: Swift.Equatable {
    /// The new impersonation role ID.
    public var impersonationRoleId: Swift.String?

    public init (
        impersonationRoleId: Swift.String? = nil
    )
    {
        self.impersonationRoleId = impersonationRoleId
    }
}

struct CreateImpersonationRoleOutputResponseBody: Swift.Equatable {
    let impersonationRoleId: Swift.String?
}

extension CreateImpersonationRoleOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case impersonationRoleId = "ImpersonationRoleId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let impersonationRoleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .impersonationRoleId)
        impersonationRoleId = impersonationRoleIdDecoded
    }
}

extension CreateMobileDeviceAccessRuleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case deviceModels = "DeviceModels"
        case deviceOperatingSystems = "DeviceOperatingSystems"
        case deviceTypes = "DeviceTypes"
        case deviceUserAgents = "DeviceUserAgents"
        case effect = "Effect"
        case name = "Name"
        case notDeviceModels = "NotDeviceModels"
        case notDeviceOperatingSystems = "NotDeviceOperatingSystems"
        case notDeviceTypes = "NotDeviceTypes"
        case notDeviceUserAgents = "NotDeviceUserAgents"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let deviceModels = deviceModels {
            var deviceModelsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .deviceModels)
            for devicemodel0 in deviceModels {
                try deviceModelsContainer.encode(devicemodel0)
            }
        }
        if let deviceOperatingSystems = deviceOperatingSystems {
            var deviceOperatingSystemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .deviceOperatingSystems)
            for deviceoperatingsystem0 in deviceOperatingSystems {
                try deviceOperatingSystemsContainer.encode(deviceoperatingsystem0)
            }
        }
        if let deviceTypes = deviceTypes {
            var deviceTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .deviceTypes)
            for devicetype0 in deviceTypes {
                try deviceTypesContainer.encode(devicetype0)
            }
        }
        if let deviceUserAgents = deviceUserAgents {
            var deviceUserAgentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .deviceUserAgents)
            for deviceuseragent0 in deviceUserAgents {
                try deviceUserAgentsContainer.encode(deviceuseragent0)
            }
        }
        if let effect = self.effect {
            try encodeContainer.encode(effect.rawValue, forKey: .effect)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let notDeviceModels = notDeviceModels {
            var notDeviceModelsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notDeviceModels)
            for devicemodel0 in notDeviceModels {
                try notDeviceModelsContainer.encode(devicemodel0)
            }
        }
        if let notDeviceOperatingSystems = notDeviceOperatingSystems {
            var notDeviceOperatingSystemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notDeviceOperatingSystems)
            for deviceoperatingsystem0 in notDeviceOperatingSystems {
                try notDeviceOperatingSystemsContainer.encode(deviceoperatingsystem0)
            }
        }
        if let notDeviceTypes = notDeviceTypes {
            var notDeviceTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notDeviceTypes)
            for devicetype0 in notDeviceTypes {
                try notDeviceTypesContainer.encode(devicetype0)
            }
        }
        if let notDeviceUserAgents = notDeviceUserAgents {
            var notDeviceUserAgentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notDeviceUserAgents)
            for deviceuseragent0 in notDeviceUserAgents {
                try notDeviceUserAgentsContainer.encode(deviceuseragent0)
            }
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

extension CreateMobileDeviceAccessRuleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateMobileDeviceAccessRuleInput: Swift.Equatable {
    /// The idempotency token for the client request.
    public var clientToken: Swift.String?
    /// The rule description.
    public var description: Swift.String?
    /// Device models that the rule will match.
    public var deviceModels: [Swift.String]?
    /// Device operating systems that the rule will match.
    public var deviceOperatingSystems: [Swift.String]?
    /// Device types that the rule will match.
    public var deviceTypes: [Swift.String]?
    /// Device user agents that the rule will match.
    public var deviceUserAgents: [Swift.String]?
    /// The effect of the rule when it matches. Allowed values are ALLOW or DENY.
    /// This member is required.
    public var effect: WorkMailClientTypes.MobileDeviceAccessRuleEffect?
    /// The rule name.
    /// This member is required.
    public var name: Swift.String?
    /// Device models that the rule will not match. All other device models will match.
    public var notDeviceModels: [Swift.String]?
    /// Device operating systems that the rule will not match. All other device operating systems will match.
    public var notDeviceOperatingSystems: [Swift.String]?
    /// Device types that the rule will not match. All other device types will match.
    public var notDeviceTypes: [Swift.String]?
    /// Device user agents that the rule will not match. All other device user agents will match.
    public var notDeviceUserAgents: [Swift.String]?
    /// The WorkMail organization under which the rule will be created.
    /// This member is required.
    public var organizationId: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        deviceModels: [Swift.String]? = nil,
        deviceOperatingSystems: [Swift.String]? = nil,
        deviceTypes: [Swift.String]? = nil,
        deviceUserAgents: [Swift.String]? = nil,
        effect: WorkMailClientTypes.MobileDeviceAccessRuleEffect? = nil,
        name: Swift.String? = nil,
        notDeviceModels: [Swift.String]? = nil,
        notDeviceOperatingSystems: [Swift.String]? = nil,
        notDeviceTypes: [Swift.String]? = nil,
        notDeviceUserAgents: [Swift.String]? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.deviceModels = deviceModels
        self.deviceOperatingSystems = deviceOperatingSystems
        self.deviceTypes = deviceTypes
        self.deviceUserAgents = deviceUserAgents
        self.effect = effect
        self.name = name
        self.notDeviceModels = notDeviceModels
        self.notDeviceOperatingSystems = notDeviceOperatingSystems
        self.notDeviceTypes = notDeviceTypes
        self.notDeviceUserAgents = notDeviceUserAgents
        self.organizationId = organizationId
    }
}

struct CreateMobileDeviceAccessRuleInputBody: Swift.Equatable {
    let organizationId: Swift.String?
    let clientToken: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let effect: WorkMailClientTypes.MobileDeviceAccessRuleEffect?
    let deviceTypes: [Swift.String]?
    let notDeviceTypes: [Swift.String]?
    let deviceModels: [Swift.String]?
    let notDeviceModels: [Swift.String]?
    let deviceOperatingSystems: [Swift.String]?
    let notDeviceOperatingSystems: [Swift.String]?
    let deviceUserAgents: [Swift.String]?
    let notDeviceUserAgents: [Swift.String]?
}

extension CreateMobileDeviceAccessRuleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case deviceModels = "DeviceModels"
        case deviceOperatingSystems = "DeviceOperatingSystems"
        case deviceTypes = "DeviceTypes"
        case deviceUserAgents = "DeviceUserAgents"
        case effect = "Effect"
        case name = "Name"
        case notDeviceModels = "NotDeviceModels"
        case notDeviceOperatingSystems = "NotDeviceOperatingSystems"
        case notDeviceTypes = "NotDeviceTypes"
        case notDeviceUserAgents = "NotDeviceUserAgents"
        case organizationId = "OrganizationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let effectDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.MobileDeviceAccessRuleEffect.self, forKey: .effect)
        effect = effectDecoded
        let deviceTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .deviceTypes)
        var deviceTypesDecoded0:[Swift.String]? = nil
        if let deviceTypesContainer = deviceTypesContainer {
            deviceTypesDecoded0 = [Swift.String]()
            for string0 in deviceTypesContainer {
                if let string0 = string0 {
                    deviceTypesDecoded0?.append(string0)
                }
            }
        }
        deviceTypes = deviceTypesDecoded0
        let notDeviceTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .notDeviceTypes)
        var notDeviceTypesDecoded0:[Swift.String]? = nil
        if let notDeviceTypesContainer = notDeviceTypesContainer {
            notDeviceTypesDecoded0 = [Swift.String]()
            for string0 in notDeviceTypesContainer {
                if let string0 = string0 {
                    notDeviceTypesDecoded0?.append(string0)
                }
            }
        }
        notDeviceTypes = notDeviceTypesDecoded0
        let deviceModelsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .deviceModels)
        var deviceModelsDecoded0:[Swift.String]? = nil
        if let deviceModelsContainer = deviceModelsContainer {
            deviceModelsDecoded0 = [Swift.String]()
            for string0 in deviceModelsContainer {
                if let string0 = string0 {
                    deviceModelsDecoded0?.append(string0)
                }
            }
        }
        deviceModels = deviceModelsDecoded0
        let notDeviceModelsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .notDeviceModels)
        var notDeviceModelsDecoded0:[Swift.String]? = nil
        if let notDeviceModelsContainer = notDeviceModelsContainer {
            notDeviceModelsDecoded0 = [Swift.String]()
            for string0 in notDeviceModelsContainer {
                if let string0 = string0 {
                    notDeviceModelsDecoded0?.append(string0)
                }
            }
        }
        notDeviceModels = notDeviceModelsDecoded0
        let deviceOperatingSystemsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .deviceOperatingSystems)
        var deviceOperatingSystemsDecoded0:[Swift.String]? = nil
        if let deviceOperatingSystemsContainer = deviceOperatingSystemsContainer {
            deviceOperatingSystemsDecoded0 = [Swift.String]()
            for string0 in deviceOperatingSystemsContainer {
                if let string0 = string0 {
                    deviceOperatingSystemsDecoded0?.append(string0)
                }
            }
        }
        deviceOperatingSystems = deviceOperatingSystemsDecoded0
        let notDeviceOperatingSystemsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .notDeviceOperatingSystems)
        var notDeviceOperatingSystemsDecoded0:[Swift.String]? = nil
        if let notDeviceOperatingSystemsContainer = notDeviceOperatingSystemsContainer {
            notDeviceOperatingSystemsDecoded0 = [Swift.String]()
            for string0 in notDeviceOperatingSystemsContainer {
                if let string0 = string0 {
                    notDeviceOperatingSystemsDecoded0?.append(string0)
                }
            }
        }
        notDeviceOperatingSystems = notDeviceOperatingSystemsDecoded0
        let deviceUserAgentsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .deviceUserAgents)
        var deviceUserAgentsDecoded0:[Swift.String]? = nil
        if let deviceUserAgentsContainer = deviceUserAgentsContainer {
            deviceUserAgentsDecoded0 = [Swift.String]()
            for string0 in deviceUserAgentsContainer {
                if let string0 = string0 {
                    deviceUserAgentsDecoded0?.append(string0)
                }
            }
        }
        deviceUserAgents = deviceUserAgentsDecoded0
        let notDeviceUserAgentsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .notDeviceUserAgents)
        var notDeviceUserAgentsDecoded0:[Swift.String]? = nil
        if let notDeviceUserAgentsContainer = notDeviceUserAgentsContainer {
            notDeviceUserAgentsDecoded0 = [Swift.String]()
            for string0 in notDeviceUserAgentsContainer {
                if let string0 = string0 {
                    notDeviceUserAgentsDecoded0?.append(string0)
                }
            }
        }
        notDeviceUserAgents = notDeviceUserAgentsDecoded0
    }
}

extension CreateMobileDeviceAccessRuleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateMobileDeviceAccessRuleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateMobileDeviceAccessRuleOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterException(InvalidParameterException)
    case limitExceededException(LimitExceededException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateMobileDeviceAccessRuleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateMobileDeviceAccessRuleOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.mobileDeviceAccessRuleId = output.mobileDeviceAccessRuleId
        } else {
            self.mobileDeviceAccessRuleId = nil
        }
    }
}

public struct CreateMobileDeviceAccessRuleOutputResponse: Swift.Equatable {
    /// The identifier for the newly created mobile device access rule.
    public var mobileDeviceAccessRuleId: Swift.String?

    public init (
        mobileDeviceAccessRuleId: Swift.String? = nil
    )
    {
        self.mobileDeviceAccessRuleId = mobileDeviceAccessRuleId
    }
}

struct CreateMobileDeviceAccessRuleOutputResponseBody: Swift.Equatable {
    let mobileDeviceAccessRuleId: Swift.String?
}

extension CreateMobileDeviceAccessRuleOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mobileDeviceAccessRuleId = "MobileDeviceAccessRuleId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mobileDeviceAccessRuleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mobileDeviceAccessRuleId)
        mobileDeviceAccessRuleId = mobileDeviceAccessRuleIdDecoded
    }
}

extension CreateOrganizationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alias = "Alias"
        case clientToken = "ClientToken"
        case directoryId = "DirectoryId"
        case domains = "Domains"
        case enableInteroperability = "EnableInteroperability"
        case kmsKeyArn = "KmsKeyArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alias = self.alias {
            try encodeContainer.encode(alias, forKey: .alias)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let directoryId = self.directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let domains = domains {
            var domainsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .domains)
            for domain0 in domains {
                try domainsContainer.encode(domain0)
            }
        }
        if enableInteroperability != false {
            try encodeContainer.encode(enableInteroperability, forKey: .enableInteroperability)
        }
        if let kmsKeyArn = self.kmsKeyArn {
            try encodeContainer.encode(kmsKeyArn, forKey: .kmsKeyArn)
        }
    }
}

extension CreateOrganizationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateOrganizationInput: Swift.Equatable {
    /// The organization alias.
    /// This member is required.
    public var alias: Swift.String?
    /// The idempotency token associated with the request.
    public var clientToken: Swift.String?
    /// The AWS Directory Service directory ID.
    public var directoryId: Swift.String?
    /// The email domains to associate with the organization.
    public var domains: [WorkMailClientTypes.Domain]?
    /// When true, allows organization interoperability between WorkMail and Microsoft Exchange. If true, you must include a AD Connector directory ID in the request.
    public var enableInteroperability: Swift.Bool
    /// The Amazon Resource Name (ARN) of a customer managed key from AWS KMS.
    public var kmsKeyArn: Swift.String?

    public init (
        alias: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        directoryId: Swift.String? = nil,
        domains: [WorkMailClientTypes.Domain]? = nil,
        enableInteroperability: Swift.Bool = false,
        kmsKeyArn: Swift.String? = nil
    )
    {
        self.alias = alias
        self.clientToken = clientToken
        self.directoryId = directoryId
        self.domains = domains
        self.enableInteroperability = enableInteroperability
        self.kmsKeyArn = kmsKeyArn
    }
}

struct CreateOrganizationInputBody: Swift.Equatable {
    let directoryId: Swift.String?
    let alias: Swift.String?
    let clientToken: Swift.String?
    let domains: [WorkMailClientTypes.Domain]?
    let kmsKeyArn: Swift.String?
    let enableInteroperability: Swift.Bool
}

extension CreateOrganizationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alias = "Alias"
        case clientToken = "ClientToken"
        case directoryId = "DirectoryId"
        case domains = "Domains"
        case enableInteroperability = "EnableInteroperability"
        case kmsKeyArn = "KmsKeyArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let aliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alias)
        alias = aliasDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let domainsContainer = try containerValues.decodeIfPresent([WorkMailClientTypes.Domain?].self, forKey: .domains)
        var domainsDecoded0:[WorkMailClientTypes.Domain]? = nil
        if let domainsContainer = domainsContainer {
            domainsDecoded0 = [WorkMailClientTypes.Domain]()
            for structure0 in domainsContainer {
                if let structure0 = structure0 {
                    domainsDecoded0?.append(structure0)
                }
            }
        }
        domains = domainsDecoded0
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
        let enableInteroperabilityDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableInteroperability) ?? false
        enableInteroperability = enableInteroperabilityDecoded
    }
}

extension CreateOrganizationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateOrganizationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DirectoryInUseException" : self = .directoryInUseException(try DirectoryInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryUnavailableException" : self = .directoryUnavailableException(try DirectoryUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NameAvailabilityException" : self = .nameAvailabilityException(try NameAvailabilityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateOrganizationOutputError: Swift.Error, Swift.Equatable {
    case directoryInUseException(DirectoryInUseException)
    case directoryUnavailableException(DirectoryUnavailableException)
    case invalidParameterException(InvalidParameterException)
    case limitExceededException(LimitExceededException)
    case nameAvailabilityException(NameAvailabilityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateOrganizationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateOrganizationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.organizationId = output.organizationId
        } else {
            self.organizationId = nil
        }
    }
}

public struct CreateOrganizationOutputResponse: Swift.Equatable {
    /// The organization ID.
    public var organizationId: Swift.String?

    public init (
        organizationId: Swift.String? = nil
    )
    {
        self.organizationId = organizationId
    }
}

struct CreateOrganizationOutputResponseBody: Swift.Equatable {
    let organizationId: Swift.String?
}

extension CreateOrganizationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case organizationId = "OrganizationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
    }
}

extension CreateResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case organizationId = "OrganizationId"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension CreateResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateResourceInput: Swift.Equatable {
    /// The name of the new resource.
    /// This member is required.
    public var name: Swift.String?
    /// The identifier associated with the organization for which the resource is created.
    /// This member is required.
    public var organizationId: Swift.String?
    /// The type of the new resource. The available types are equipment and room.
    /// This member is required.
    public var type: WorkMailClientTypes.ResourceType?

    public init (
        name: Swift.String? = nil,
        organizationId: Swift.String? = nil,
        type: WorkMailClientTypes.ResourceType? = nil
    )
    {
        self.name = name
        self.organizationId = organizationId
        self.type = type
    }
}

struct CreateResourceInputBody: Swift.Equatable {
    let organizationId: Swift.String?
    let name: Swift.String?
    let type: WorkMailClientTypes.ResourceType?
}

extension CreateResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case organizationId = "OrganizationId"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.ResourceType.self, forKey: .type)
        type = typeDecoded
    }
}

extension CreateResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DirectoryServiceAuthenticationFailedException" : self = .directoryServiceAuthenticationFailedException(try DirectoryServiceAuthenticationFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryUnavailableException" : self = .directoryUnavailableException(try DirectoryUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NameAvailabilityException" : self = .nameAvailabilityException(try NameAvailabilityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ReservedNameException" : self = .reservedNameException(try ReservedNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateResourceOutputError: Swift.Error, Swift.Equatable {
    case directoryServiceAuthenticationFailedException(DirectoryServiceAuthenticationFailedException)
    case directoryUnavailableException(DirectoryUnavailableException)
    case invalidParameterException(InvalidParameterException)
    case nameAvailabilityException(NameAvailabilityException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case reservedNameException(ReservedNameException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.resourceId = output.resourceId
        } else {
            self.resourceId = nil
        }
    }
}

public struct CreateResourceOutputResponse: Swift.Equatable {
    /// The identifier of the new resource.
    public var resourceId: Swift.String?

    public init (
        resourceId: Swift.String? = nil
    )
    {
        self.resourceId = resourceId
    }
}

struct CreateResourceOutputResponseBody: Swift.Equatable {
    let resourceId: Swift.String?
}

extension CreateResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceId = "ResourceId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
    }
}

extension CreateUserInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateUserInput(displayName: \(Swift.String(describing: displayName)), name: \(Swift.String(describing: name)), organizationId: \(Swift.String(describing: organizationId)), password: \"CONTENT_REDACTED\")"}
}

extension CreateUserInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case displayName = "DisplayName"
        case name = "Name"
        case organizationId = "OrganizationId"
        case password = "Password"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
        if let password = self.password {
            try encodeContainer.encode(password, forKey: .password)
        }
    }
}

extension CreateUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateUserInput: Swift.Equatable {
    /// The display name for the new user.
    /// This member is required.
    public var displayName: Swift.String?
    /// The name for the new user. WorkMail directory user names have a maximum length of 64. All others have a maximum length of 20.
    /// This member is required.
    public var name: Swift.String?
    /// The identifier of the organization for which the user is created.
    /// This member is required.
    public var organizationId: Swift.String?
    /// The password for the new user.
    /// This member is required.
    public var password: Swift.String?

    public init (
        displayName: Swift.String? = nil,
        name: Swift.String? = nil,
        organizationId: Swift.String? = nil,
        password: Swift.String? = nil
    )
    {
        self.displayName = displayName
        self.name = name
        self.organizationId = organizationId
        self.password = password
    }
}

struct CreateUserInputBody: Swift.Equatable {
    let organizationId: Swift.String?
    let name: Swift.String?
    let displayName: Swift.String?
    let password: Swift.String?
}

extension CreateUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case displayName = "DisplayName"
        case name = "Name"
        case organizationId = "OrganizationId"
        case password = "Password"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .password)
        password = passwordDecoded
    }
}

extension CreateUserOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateUserOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DirectoryServiceAuthenticationFailedException" : self = .directoryServiceAuthenticationFailedException(try DirectoryServiceAuthenticationFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryUnavailableException" : self = .directoryUnavailableException(try DirectoryUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPasswordException" : self = .invalidPasswordException(try InvalidPasswordException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NameAvailabilityException" : self = .nameAvailabilityException(try NameAvailabilityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ReservedNameException" : self = .reservedNameException(try ReservedNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateUserOutputError: Swift.Error, Swift.Equatable {
    case directoryServiceAuthenticationFailedException(DirectoryServiceAuthenticationFailedException)
    case directoryUnavailableException(DirectoryUnavailableException)
    case invalidParameterException(InvalidParameterException)
    case invalidPasswordException(InvalidPasswordException)
    case nameAvailabilityException(NameAvailabilityException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case reservedNameException(ReservedNameException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateUserOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateUserOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.userId = output.userId
        } else {
            self.userId = nil
        }
    }
}

public struct CreateUserOutputResponse: Swift.Equatable {
    /// The identifier for the new user.
    public var userId: Swift.String?

    public init (
        userId: Swift.String? = nil
    )
    {
        self.userId = userId
    }
}

struct CreateUserOutputResponseBody: Swift.Equatable {
    let userId: Swift.String?
}

extension CreateUserOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userId = "UserId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
    }
}

extension WorkMailClientTypes.Delegate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let typeDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.MemberType.self, forKey: .type)
        type = typeDecoded
    }
}

extension WorkMailClientTypes {
    /// The name of the attribute, which is one of the values defined in the UserAttribute enumeration.
    public struct Delegate: Swift.Equatable {
        /// The identifier for the user or group associated as the resource's delegate.
        /// This member is required.
        public var id: Swift.String?
        /// The type of the delegate: user or group.
        /// This member is required.
        public var type: WorkMailClientTypes.MemberType?

        public init (
            id: Swift.String? = nil,
            type: WorkMailClientTypes.MemberType? = nil
        )
        {
            self.id = id
            self.type = type
        }
    }

}

extension DeleteAccessControlRuleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

extension DeleteAccessControlRuleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteAccessControlRuleInput: Swift.Equatable {
    /// The name of the access control rule.
    /// This member is required.
    public var name: Swift.String?
    /// The identifier for the organization.
    /// This member is required.
    public var organizationId: Swift.String?

    public init (
        name: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.name = name
        self.organizationId = organizationId
    }
}

struct DeleteAccessControlRuleInputBody: Swift.Equatable {
    let organizationId: Swift.String?
    let name: Swift.String?
}

extension DeleteAccessControlRuleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case organizationId = "OrganizationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DeleteAccessControlRuleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAccessControlRuleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteAccessControlRuleOutputError: Swift.Error, Swift.Equatable {
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAccessControlRuleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteAccessControlRuleOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteAliasInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alias = "Alias"
        case entityId = "EntityId"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alias = self.alias {
            try encodeContainer.encode(alias, forKey: .alias)
        }
        if let entityId = self.entityId {
            try encodeContainer.encode(entityId, forKey: .entityId)
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

extension DeleteAliasInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteAliasInput: Swift.Equatable {
    /// The aliases to be removed from the user's set of aliases. Duplicate entries in the list are collapsed into single entries (the list is transformed into a set).
    /// This member is required.
    public var alias: Swift.String?
    /// The identifier for the member (user or group) from which to have the aliases removed.
    /// This member is required.
    public var entityId: Swift.String?
    /// The identifier for the organization under which the user exists.
    /// This member is required.
    public var organizationId: Swift.String?

    public init (
        alias: Swift.String? = nil,
        entityId: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.alias = alias
        self.entityId = entityId
        self.organizationId = organizationId
    }
}

struct DeleteAliasInputBody: Swift.Equatable {
    let organizationId: Swift.String?
    let entityId: Swift.String?
    let alias: Swift.String?
}

extension DeleteAliasInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alias = "Alias"
        case entityId = "EntityId"
        case organizationId = "OrganizationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let entityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityId)
        entityId = entityIdDecoded
        let aliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alias)
        alias = aliasDecoded
    }
}

extension DeleteAliasOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAliasOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityStateException" : self = .entityStateException(try EntityStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteAliasOutputError: Swift.Error, Swift.Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case entityStateException(EntityStateException)
    case invalidParameterException(InvalidParameterException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAliasOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteAliasOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteAvailabilityConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainName = self.domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

extension DeleteAvailabilityConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteAvailabilityConfigurationInput: Swift.Equatable {
    /// The domain for which the AvailabilityConfiguration will be deleted.
    /// This member is required.
    public var domainName: Swift.String?
    /// The WorkMail organization for which the AvailabilityConfiguration will be deleted.
    /// This member is required.
    public var organizationId: Swift.String?

    public init (
        domainName: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.organizationId = organizationId
    }
}

struct DeleteAvailabilityConfigurationInputBody: Swift.Equatable {
    let organizationId: Swift.String?
    let domainName: Swift.String?
}

extension DeleteAvailabilityConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
        case organizationId = "OrganizationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
    }
}

extension DeleteAvailabilityConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAvailabilityConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteAvailabilityConfigurationOutputError: Swift.Error, Swift.Equatable {
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAvailabilityConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteAvailabilityConfigurationOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteEmailMonitoringConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

extension DeleteEmailMonitoringConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteEmailMonitoringConfigurationInput: Swift.Equatable {
    /// The ID of the organization from which the email monitoring configuration is deleted.
    /// This member is required.
    public var organizationId: Swift.String?

    public init (
        organizationId: Swift.String? = nil
    )
    {
        self.organizationId = organizationId
    }
}

struct DeleteEmailMonitoringConfigurationInputBody: Swift.Equatable {
    let organizationId: Swift.String?
}

extension DeleteEmailMonitoringConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case organizationId = "OrganizationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
    }
}

extension DeleteEmailMonitoringConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteEmailMonitoringConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteEmailMonitoringConfigurationOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterException(InvalidParameterException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteEmailMonitoringConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteEmailMonitoringConfigurationOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupId = "GroupId"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupId = self.groupId {
            try encodeContainer.encode(groupId, forKey: .groupId)
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

extension DeleteGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteGroupInput: Swift.Equatable {
    /// The identifier of the group to be deleted.
    /// This member is required.
    public var groupId: Swift.String?
    /// The organization that contains the group.
    /// This member is required.
    public var organizationId: Swift.String?

    public init (
        groupId: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.groupId = groupId
        self.organizationId = organizationId
    }
}

struct DeleteGroupInputBody: Swift.Equatable {
    let organizationId: Swift.String?
    let groupId: Swift.String?
}

extension DeleteGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupId = "GroupId"
        case organizationId = "OrganizationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let groupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupId)
        groupId = groupIdDecoded
    }
}

extension DeleteGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DirectoryServiceAuthenticationFailedException" : self = .directoryServiceAuthenticationFailedException(try DirectoryServiceAuthenticationFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryUnavailableException" : self = .directoryUnavailableException(try DirectoryUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityStateException" : self = .entityStateException(try EntityStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteGroupOutputError: Swift.Error, Swift.Equatable {
    case directoryServiceAuthenticationFailedException(DirectoryServiceAuthenticationFailedException)
    case directoryUnavailableException(DirectoryUnavailableException)
    case entityStateException(EntityStateException)
    case invalidParameterException(InvalidParameterException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteGroupOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteImpersonationRoleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case impersonationRoleId = "ImpersonationRoleId"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let impersonationRoleId = self.impersonationRoleId {
            try encodeContainer.encode(impersonationRoleId, forKey: .impersonationRoleId)
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

extension DeleteImpersonationRoleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteImpersonationRoleInput: Swift.Equatable {
    /// The ID of the impersonation role to delete.
    /// This member is required.
    public var impersonationRoleId: Swift.String?
    /// The WorkMail organization from which to delete the impersonation role.
    /// This member is required.
    public var organizationId: Swift.String?

    public init (
        impersonationRoleId: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.impersonationRoleId = impersonationRoleId
        self.organizationId = organizationId
    }
}

struct DeleteImpersonationRoleInputBody: Swift.Equatable {
    let organizationId: Swift.String?
    let impersonationRoleId: Swift.String?
}

extension DeleteImpersonationRoleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case impersonationRoleId = "ImpersonationRoleId"
        case organizationId = "OrganizationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let impersonationRoleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .impersonationRoleId)
        impersonationRoleId = impersonationRoleIdDecoded
    }
}

extension DeleteImpersonationRoleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteImpersonationRoleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteImpersonationRoleOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterException(InvalidParameterException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteImpersonationRoleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteImpersonationRoleOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteMailboxPermissionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entityId = "EntityId"
        case granteeId = "GranteeId"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entityId = self.entityId {
            try encodeContainer.encode(entityId, forKey: .entityId)
        }
        if let granteeId = self.granteeId {
            try encodeContainer.encode(granteeId, forKey: .granteeId)
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

extension DeleteMailboxPermissionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteMailboxPermissionsInput: Swift.Equatable {
    /// The identifier of the member (user or group) that owns the mailbox.
    /// This member is required.
    public var entityId: Swift.String?
    /// The identifier of the member (user or group) for which to delete granted permissions.
    /// This member is required.
    public var granteeId: Swift.String?
    /// The identifier of the organization under which the member (user or group) exists.
    /// This member is required.
    public var organizationId: Swift.String?

    public init (
        entityId: Swift.String? = nil,
        granteeId: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.entityId = entityId
        self.granteeId = granteeId
        self.organizationId = organizationId
    }
}

struct DeleteMailboxPermissionsInputBody: Swift.Equatable {
    let organizationId: Swift.String?
    let entityId: Swift.String?
    let granteeId: Swift.String?
}

extension DeleteMailboxPermissionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entityId = "EntityId"
        case granteeId = "GranteeId"
        case organizationId = "OrganizationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let entityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityId)
        entityId = entityIdDecoded
        let granteeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .granteeId)
        granteeId = granteeIdDecoded
    }
}

extension DeleteMailboxPermissionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteMailboxPermissionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityStateException" : self = .entityStateException(try EntityStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteMailboxPermissionsOutputError: Swift.Error, Swift.Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case entityStateException(EntityStateException)
    case invalidParameterException(InvalidParameterException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteMailboxPermissionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteMailboxPermissionsOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteMobileDeviceAccessOverrideInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceId = "DeviceId"
        case organizationId = "OrganizationId"
        case userId = "UserId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceId = self.deviceId {
            try encodeContainer.encode(deviceId, forKey: .deviceId)
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
        if let userId = self.userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
    }
}

extension DeleteMobileDeviceAccessOverrideInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteMobileDeviceAccessOverrideInput: Swift.Equatable {
    /// The mobile device for which you delete the override. DeviceId is case insensitive.
    /// This member is required.
    public var deviceId: Swift.String?
    /// The WorkMail organization for which the access override will be deleted.
    /// This member is required.
    public var organizationId: Swift.String?
    /// The WorkMail user for which you want to delete the override. Accepts the following types of user identities:
    ///
    /// * User ID: 12345678-1234-1234-1234-123456789012 or S-1-1-12-1234567890-123456789-123456789-1234
    ///
    /// * Email address: user@domain.tld
    ///
    /// * User name: user
    /// This member is required.
    public var userId: Swift.String?

    public init (
        deviceId: Swift.String? = nil,
        organizationId: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.deviceId = deviceId
        self.organizationId = organizationId
        self.userId = userId
    }
}

struct DeleteMobileDeviceAccessOverrideInputBody: Swift.Equatable {
    let organizationId: Swift.String?
    let userId: Swift.String?
    let deviceId: Swift.String?
}

extension DeleteMobileDeviceAccessOverrideInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceId = "DeviceId"
        case organizationId = "OrganizationId"
        case userId = "UserId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
        let deviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceId)
        deviceId = deviceIdDecoded
    }
}

extension DeleteMobileDeviceAccessOverrideOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteMobileDeviceAccessOverrideOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteMobileDeviceAccessOverrideOutputError: Swift.Error, Swift.Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case invalidParameterException(InvalidParameterException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteMobileDeviceAccessOverrideOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteMobileDeviceAccessOverrideOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteMobileDeviceAccessRuleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mobileDeviceAccessRuleId = "MobileDeviceAccessRuleId"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let mobileDeviceAccessRuleId = self.mobileDeviceAccessRuleId {
            try encodeContainer.encode(mobileDeviceAccessRuleId, forKey: .mobileDeviceAccessRuleId)
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

extension DeleteMobileDeviceAccessRuleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteMobileDeviceAccessRuleInput: Swift.Equatable {
    /// The identifier of the rule to be deleted.
    /// This member is required.
    public var mobileDeviceAccessRuleId: Swift.String?
    /// The WorkMail organization under which the rule will be deleted.
    /// This member is required.
    public var organizationId: Swift.String?

    public init (
        mobileDeviceAccessRuleId: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.mobileDeviceAccessRuleId = mobileDeviceAccessRuleId
        self.organizationId = organizationId
    }
}

struct DeleteMobileDeviceAccessRuleInputBody: Swift.Equatable {
    let organizationId: Swift.String?
    let mobileDeviceAccessRuleId: Swift.String?
}

extension DeleteMobileDeviceAccessRuleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mobileDeviceAccessRuleId = "MobileDeviceAccessRuleId"
        case organizationId = "OrganizationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let mobileDeviceAccessRuleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mobileDeviceAccessRuleId)
        mobileDeviceAccessRuleId = mobileDeviceAccessRuleIdDecoded
    }
}

extension DeleteMobileDeviceAccessRuleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteMobileDeviceAccessRuleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteMobileDeviceAccessRuleOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterException(InvalidParameterException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteMobileDeviceAccessRuleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteMobileDeviceAccessRuleOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteOrganizationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case deleteDirectory = "DeleteDirectory"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if deleteDirectory != false {
            try encodeContainer.encode(deleteDirectory, forKey: .deleteDirectory)
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

extension DeleteOrganizationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteOrganizationInput: Swift.Equatable {
    /// The idempotency token associated with the request.
    public var clientToken: Swift.String?
    /// If true, deletes the AWS Directory Service directory associated with the organization.
    /// This member is required.
    public var deleteDirectory: Swift.Bool
    /// The organization ID.
    /// This member is required.
    public var organizationId: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        deleteDirectory: Swift.Bool = false,
        organizationId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.deleteDirectory = deleteDirectory
        self.organizationId = organizationId
    }
}

struct DeleteOrganizationInputBody: Swift.Equatable {
    let clientToken: Swift.String?
    let organizationId: Swift.String?
    let deleteDirectory: Swift.Bool
}

extension DeleteOrganizationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case deleteDirectory = "DeleteDirectory"
        case organizationId = "OrganizationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let deleteDirectoryDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deleteDirectory) ?? false
        deleteDirectory = deleteDirectoryDecoded
    }
}

extension DeleteOrganizationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteOrganizationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteOrganizationOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterException(InvalidParameterException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteOrganizationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteOrganizationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.organizationId = output.organizationId
            self.state = output.state
        } else {
            self.organizationId = nil
            self.state = nil
        }
    }
}

public struct DeleteOrganizationOutputResponse: Swift.Equatable {
    /// The organization ID.
    public var organizationId: Swift.String?
    /// The state of the organization.
    public var state: Swift.String?

    public init (
        organizationId: Swift.String? = nil,
        state: Swift.String? = nil
    )
    {
        self.organizationId = organizationId
        self.state = state
    }
}

struct DeleteOrganizationOutputResponseBody: Swift.Equatable {
    let organizationId: Swift.String?
    let state: Swift.String?
}

extension DeleteOrganizationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case organizationId = "OrganizationId"
        case state = "State"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .state)
        state = stateDecoded
    }
}

extension DeleteResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case organizationId = "OrganizationId"
        case resourceId = "ResourceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
    }
}

extension DeleteResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteResourceInput: Swift.Equatable {
    /// The identifier associated with the organization from which the resource is deleted.
    /// This member is required.
    public var organizationId: Swift.String?
    /// The identifier of the resource to be deleted.
    /// This member is required.
    public var resourceId: Swift.String?

    public init (
        organizationId: Swift.String? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.organizationId = organizationId
        self.resourceId = resourceId
    }
}

struct DeleteResourceInputBody: Swift.Equatable {
    let organizationId: Swift.String?
    let resourceId: Swift.String?
}

extension DeleteResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case organizationId = "OrganizationId"
        case resourceId = "ResourceId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
    }
}

extension DeleteResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EntityStateException" : self = .entityStateException(try EntityStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteResourceOutputError: Swift.Error, Swift.Equatable {
    case entityStateException(EntityStateException)
    case invalidParameterException(InvalidParameterException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteRetentionPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

extension DeleteRetentionPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteRetentionPolicyInput: Swift.Equatable {
    /// The retention policy ID.
    /// This member is required.
    public var id: Swift.String?
    /// The organization ID.
    /// This member is required.
    public var organizationId: Swift.String?

    public init (
        id: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.id = id
        self.organizationId = organizationId
    }
}

struct DeleteRetentionPolicyInputBody: Swift.Equatable {
    let organizationId: Swift.String?
    let id: Swift.String?
}

extension DeleteRetentionPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
        case organizationId = "OrganizationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension DeleteRetentionPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteRetentionPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteRetentionPolicyOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterException(InvalidParameterException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteRetentionPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteRetentionPolicyOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteUserInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case organizationId = "OrganizationId"
        case userId = "UserId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
        if let userId = self.userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
    }
}

extension DeleteUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteUserInput: Swift.Equatable {
    /// The organization that contains the user to be deleted.
    /// This member is required.
    public var organizationId: Swift.String?
    /// The identifier of the user to be deleted.
    /// This member is required.
    public var userId: Swift.String?

    public init (
        organizationId: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.organizationId = organizationId
        self.userId = userId
    }
}

struct DeleteUserInputBody: Swift.Equatable {
    let organizationId: Swift.String?
    let userId: Swift.String?
}

extension DeleteUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case organizationId = "OrganizationId"
        case userId = "UserId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
    }
}

extension DeleteUserOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteUserOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DirectoryServiceAuthenticationFailedException" : self = .directoryServiceAuthenticationFailedException(try DirectoryServiceAuthenticationFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryUnavailableException" : self = .directoryUnavailableException(try DirectoryUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityStateException" : self = .entityStateException(try EntityStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteUserOutputError: Swift.Error, Swift.Equatable {
    case directoryServiceAuthenticationFailedException(DirectoryServiceAuthenticationFailedException)
    case directoryUnavailableException(DirectoryUnavailableException)
    case entityStateException(EntityStateException)
    case invalidParameterException(InvalidParameterException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteUserOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteUserOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeregisterFromWorkMailInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entityId = "EntityId"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entityId = self.entityId {
            try encodeContainer.encode(entityId, forKey: .entityId)
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

extension DeregisterFromWorkMailInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeregisterFromWorkMailInput: Swift.Equatable {
    /// The identifier for the member (user or group) to be updated.
    /// This member is required.
    public var entityId: Swift.String?
    /// The identifier for the organization under which the WorkMail entity exists.
    /// This member is required.
    public var organizationId: Swift.String?

    public init (
        entityId: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.entityId = entityId
        self.organizationId = organizationId
    }
}

struct DeregisterFromWorkMailInputBody: Swift.Equatable {
    let organizationId: Swift.String?
    let entityId: Swift.String?
}

extension DeregisterFromWorkMailInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entityId = "EntityId"
        case organizationId = "OrganizationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let entityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityId)
        entityId = entityIdDecoded
    }
}

extension DeregisterFromWorkMailOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeregisterFromWorkMailOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityStateException" : self = .entityStateException(try EntityStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeregisterFromWorkMailOutputError: Swift.Error, Swift.Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case entityStateException(EntityStateException)
    case invalidParameterException(InvalidParameterException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeregisterFromWorkMailOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeregisterFromWorkMailOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeregisterMailDomainInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainName = self.domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

extension DeregisterMailDomainInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeregisterMailDomainInput: Swift.Equatable {
    /// The domain to deregister in WorkMail and SES.
    /// This member is required.
    public var domainName: Swift.String?
    /// The WorkMail organization for which the domain will be deregistered.
    /// This member is required.
    public var organizationId: Swift.String?

    public init (
        domainName: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.organizationId = organizationId
    }
}

struct DeregisterMailDomainInputBody: Swift.Equatable {
    let organizationId: Swift.String?
    let domainName: Swift.String?
}

extension DeregisterMailDomainInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
        case organizationId = "OrganizationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
    }
}

extension DeregisterMailDomainOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeregisterMailDomainOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidCustomSesConfigurationException" : self = .invalidCustomSesConfigurationException(try InvalidCustomSesConfigurationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MailDomainInUseException" : self = .mailDomainInUseException(try MailDomainInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeregisterMailDomainOutputError: Swift.Error, Swift.Equatable {
    case invalidCustomSesConfigurationException(InvalidCustomSesConfigurationException)
    case invalidParameterException(InvalidParameterException)
    case mailDomainInUseException(MailDomainInUseException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeregisterMailDomainOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeregisterMailDomainOutputResponse: Swift.Equatable {

    public init () { }
}

extension DescribeEmailMonitoringConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

extension DescribeEmailMonitoringConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeEmailMonitoringConfigurationInput: Swift.Equatable {
    /// The ID of the organization for which the email monitoring configuration is described.
    /// This member is required.
    public var organizationId: Swift.String?

    public init (
        organizationId: Swift.String? = nil
    )
    {
        self.organizationId = organizationId
    }
}

struct DescribeEmailMonitoringConfigurationInputBody: Swift.Equatable {
    let organizationId: Swift.String?
}

extension DescribeEmailMonitoringConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case organizationId = "OrganizationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
    }
}

extension DescribeEmailMonitoringConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeEmailMonitoringConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeEmailMonitoringConfigurationOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterException(InvalidParameterException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeEmailMonitoringConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeEmailMonitoringConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.logGroupArn = output.logGroupArn
            self.roleArn = output.roleArn
        } else {
            self.logGroupArn = nil
            self.roleArn = nil
        }
    }
}

public struct DescribeEmailMonitoringConfigurationOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the CloudWatch Log group associated with the email monitoring configuration.
    public var logGroupArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the IAM Role associated with the email monitoring configuration.
    public var roleArn: Swift.String?

    public init (
        logGroupArn: Swift.String? = nil,
        roleArn: Swift.String? = nil
    )
    {
        self.logGroupArn = logGroupArn
        self.roleArn = roleArn
    }
}

struct DescribeEmailMonitoringConfigurationOutputResponseBody: Swift.Equatable {
    let roleArn: Swift.String?
    let logGroupArn: Swift.String?
}

extension DescribeEmailMonitoringConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case logGroupArn = "LogGroupArn"
        case roleArn = "RoleArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let logGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logGroupArn)
        logGroupArn = logGroupArnDecoded
    }
}

extension DescribeGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupId = "GroupId"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupId = self.groupId {
            try encodeContainer.encode(groupId, forKey: .groupId)
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

extension DescribeGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeGroupInput: Swift.Equatable {
    /// The identifier for the group to be described.
    /// This member is required.
    public var groupId: Swift.String?
    /// The identifier for the organization under which the group exists.
    /// This member is required.
    public var organizationId: Swift.String?

    public init (
        groupId: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.groupId = groupId
        self.organizationId = organizationId
    }
}

struct DescribeGroupInputBody: Swift.Equatable {
    let organizationId: Swift.String?
    let groupId: Swift.String?
}

extension DescribeGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupId = "GroupId"
        case organizationId = "OrganizationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let groupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupId)
        groupId = groupIdDecoded
    }
}

extension DescribeGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeGroupOutputError: Swift.Error, Swift.Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case invalidParameterException(InvalidParameterException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.disabledDate = output.disabledDate
            self.email = output.email
            self.enabledDate = output.enabledDate
            self.groupId = output.groupId
            self.name = output.name
            self.state = output.state
        } else {
            self.disabledDate = nil
            self.email = nil
            self.enabledDate = nil
            self.groupId = nil
            self.name = nil
            self.state = nil
        }
    }
}

public struct DescribeGroupOutputResponse: Swift.Equatable {
    /// The date and time when a user was deregistered from WorkMail, in UNIX epoch time format.
    public var disabledDate: ClientRuntime.Date?
    /// The email of the described group.
    public var email: Swift.String?
    /// The date and time when a user was registered to WorkMail, in UNIX epoch time format.
    public var enabledDate: ClientRuntime.Date?
    /// The identifier of the described group.
    public var groupId: Swift.String?
    /// The name of the described group.
    public var name: Swift.String?
    /// The state of the user: enabled (registered to WorkMail) or disabled (deregistered or never registered to WorkMail).
    public var state: WorkMailClientTypes.EntityState?

    public init (
        disabledDate: ClientRuntime.Date? = nil,
        email: Swift.String? = nil,
        enabledDate: ClientRuntime.Date? = nil,
        groupId: Swift.String? = nil,
        name: Swift.String? = nil,
        state: WorkMailClientTypes.EntityState? = nil
    )
    {
        self.disabledDate = disabledDate
        self.email = email
        self.enabledDate = enabledDate
        self.groupId = groupId
        self.name = name
        self.state = state
    }
}

struct DescribeGroupOutputResponseBody: Swift.Equatable {
    let groupId: Swift.String?
    let name: Swift.String?
    let email: Swift.String?
    let state: WorkMailClientTypes.EntityState?
    let enabledDate: ClientRuntime.Date?
    let disabledDate: ClientRuntime.Date?
}

extension DescribeGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case disabledDate = "DisabledDate"
        case email = "Email"
        case enabledDate = "EnabledDate"
        case groupId = "GroupId"
        case name = "Name"
        case state = "State"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupId)
        groupId = groupIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let emailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .email)
        email = emailDecoded
        let stateDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.EntityState.self, forKey: .state)
        state = stateDecoded
        let enabledDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .enabledDate)
        enabledDate = enabledDateDecoded
        let disabledDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .disabledDate)
        disabledDate = disabledDateDecoded
    }
}

extension DescribeInboundDmarcSettingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

extension DescribeInboundDmarcSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeInboundDmarcSettingsInput: Swift.Equatable {
    /// Lists the ID of the given organization.
    /// This member is required.
    public var organizationId: Swift.String?

    public init (
        organizationId: Swift.String? = nil
    )
    {
        self.organizationId = organizationId
    }
}

struct DescribeInboundDmarcSettingsInputBody: Swift.Equatable {
    let organizationId: Swift.String?
}

extension DescribeInboundDmarcSettingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case organizationId = "OrganizationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
    }
}

extension DescribeInboundDmarcSettingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeInboundDmarcSettingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeInboundDmarcSettingsOutputError: Swift.Error, Swift.Equatable {
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeInboundDmarcSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeInboundDmarcSettingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.enforced = output.enforced
        } else {
            self.enforced = false
        }
    }
}

public struct DescribeInboundDmarcSettingsOutputResponse: Swift.Equatable {
    /// Lists the enforcement setting of the applied policy.
    public var enforced: Swift.Bool

    public init (
        enforced: Swift.Bool = false
    )
    {
        self.enforced = enforced
    }
}

struct DescribeInboundDmarcSettingsOutputResponseBody: Swift.Equatable {
    let enforced: Swift.Bool
}

extension DescribeInboundDmarcSettingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enforced = "Enforced"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enforcedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enforced) ?? false
        enforced = enforcedDecoded
    }
}

extension DescribeMailboxExportJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobId = self.jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

extension DescribeMailboxExportJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeMailboxExportJobInput: Swift.Equatable {
    /// The mailbox export job ID.
    /// This member is required.
    public var jobId: Swift.String?
    /// The organization ID.
    /// This member is required.
    public var organizationId: Swift.String?

    public init (
        jobId: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.jobId = jobId
        self.organizationId = organizationId
    }
}

struct DescribeMailboxExportJobInputBody: Swift.Equatable {
    let jobId: Swift.String?
    let organizationId: Swift.String?
}

extension DescribeMailboxExportJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
        case organizationId = "OrganizationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
    }
}

extension DescribeMailboxExportJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeMailboxExportJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeMailboxExportJobOutputError: Swift.Error, Swift.Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case invalidParameterException(InvalidParameterException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeMailboxExportJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeMailboxExportJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.description = output.description
            self.endTime = output.endTime
            self.entityId = output.entityId
            self.errorInfo = output.errorInfo
            self.estimatedProgress = output.estimatedProgress
            self.kmsKeyArn = output.kmsKeyArn
            self.roleArn = output.roleArn
            self.s3BucketName = output.s3BucketName
            self.s3Path = output.s3Path
            self.s3Prefix = output.s3Prefix
            self.startTime = output.startTime
            self.state = output.state
        } else {
            self.description = nil
            self.endTime = nil
            self.entityId = nil
            self.errorInfo = nil
            self.estimatedProgress = 0
            self.kmsKeyArn = nil
            self.roleArn = nil
            self.s3BucketName = nil
            self.s3Path = nil
            self.s3Prefix = nil
            self.startTime = nil
            self.state = nil
        }
    }
}

public struct DescribeMailboxExportJobOutputResponse: Swift.Equatable {
    /// The mailbox export job description.
    public var description: Swift.String?
    /// The mailbox export job end timestamp.
    public var endTime: ClientRuntime.Date?
    /// The identifier of the user or resource associated with the mailbox.
    public var entityId: Swift.String?
    /// Error information for failed mailbox export jobs.
    public var errorInfo: Swift.String?
    /// The estimated progress of the mailbox export job, in percentage points.
    public var estimatedProgress: Swift.Int
    /// The Amazon Resource Name (ARN) of the symmetric AWS Key Management Service (AWS KMS) key that encrypts the exported mailbox content.
    public var kmsKeyArn: Swift.String?
    /// The ARN of the AWS Identity and Access Management (IAM) role that grants write permission to the Amazon Simple Storage Service (Amazon S3) bucket.
    public var roleArn: Swift.String?
    /// The name of the S3 bucket.
    public var s3BucketName: Swift.String?
    /// The path to the S3 bucket and file that the mailbox export job is exporting to.
    public var s3Path: Swift.String?
    /// The S3 bucket prefix.
    public var s3Prefix: Swift.String?
    /// The mailbox export job start timestamp.
    public var startTime: ClientRuntime.Date?
    /// The state of the mailbox export job.
    public var state: WorkMailClientTypes.MailboxExportJobState?

    public init (
        description: Swift.String? = nil,
        endTime: ClientRuntime.Date? = nil,
        entityId: Swift.String? = nil,
        errorInfo: Swift.String? = nil,
        estimatedProgress: Swift.Int = 0,
        kmsKeyArn: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        s3BucketName: Swift.String? = nil,
        s3Path: Swift.String? = nil,
        s3Prefix: Swift.String? = nil,
        startTime: ClientRuntime.Date? = nil,
        state: WorkMailClientTypes.MailboxExportJobState? = nil
    )
    {
        self.description = description
        self.endTime = endTime
        self.entityId = entityId
        self.errorInfo = errorInfo
        self.estimatedProgress = estimatedProgress
        self.kmsKeyArn = kmsKeyArn
        self.roleArn = roleArn
        self.s3BucketName = s3BucketName
        self.s3Path = s3Path
        self.s3Prefix = s3Prefix
        self.startTime = startTime
        self.state = state
    }
}

struct DescribeMailboxExportJobOutputResponseBody: Swift.Equatable {
    let entityId: Swift.String?
    let description: Swift.String?
    let roleArn: Swift.String?
    let kmsKeyArn: Swift.String?
    let s3BucketName: Swift.String?
    let s3Prefix: Swift.String?
    let s3Path: Swift.String?
    let estimatedProgress: Swift.Int
    let state: WorkMailClientTypes.MailboxExportJobState?
    let errorInfo: Swift.String?
    let startTime: ClientRuntime.Date?
    let endTime: ClientRuntime.Date?
}

extension DescribeMailboxExportJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case endTime = "EndTime"
        case entityId = "EntityId"
        case errorInfo = "ErrorInfo"
        case estimatedProgress = "EstimatedProgress"
        case kmsKeyArn = "KmsKeyArn"
        case roleArn = "RoleArn"
        case s3BucketName = "S3BucketName"
        case s3Path = "S3Path"
        case s3Prefix = "S3Prefix"
        case startTime = "StartTime"
        case state = "State"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityId)
        entityId = entityIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
        let s3BucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3BucketName)
        s3BucketName = s3BucketNameDecoded
        let s3PrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Prefix)
        s3Prefix = s3PrefixDecoded
        let s3PathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Path)
        s3Path = s3PathDecoded
        let estimatedProgressDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .estimatedProgress) ?? 0
        estimatedProgress = estimatedProgressDecoded
        let stateDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.MailboxExportJobState.self, forKey: .state)
        state = stateDecoded
        let errorInfoDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorInfo)
        errorInfo = errorInfoDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
    }
}

extension DescribeOrganizationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

extension DescribeOrganizationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeOrganizationInput: Swift.Equatable {
    /// The identifier for the organization to be described.
    /// This member is required.
    public var organizationId: Swift.String?

    public init (
        organizationId: Swift.String? = nil
    )
    {
        self.organizationId = organizationId
    }
}

struct DescribeOrganizationInputBody: Swift.Equatable {
    let organizationId: Swift.String?
}

extension DescribeOrganizationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case organizationId = "OrganizationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
    }
}

extension DescribeOrganizationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeOrganizationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeOrganizationOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterException(InvalidParameterException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeOrganizationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeOrganizationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.alias = output.alias
            self.arn = output.arn
            self.completedDate = output.completedDate
            self.defaultMailDomain = output.defaultMailDomain
            self.directoryId = output.directoryId
            self.directoryType = output.directoryType
            self.errorMessage = output.errorMessage
            self.organizationId = output.organizationId
            self.state = output.state
        } else {
            self.arn = nil
            self.alias = nil
            self.completedDate = nil
            self.defaultMailDomain = nil
            self.directoryId = nil
            self.directoryType = nil
            self.errorMessage = nil
            self.organizationId = nil
            self.state = nil
        }
    }
}

public struct DescribeOrganizationOutputResponse: Swift.Equatable {
    /// The alias for an organization.
    public var alias: Swift.String?
    /// The Amazon Resource Name (ARN) of the organization.
    public var arn: Swift.String?
    /// The date at which the organization became usable in the WorkMail context, in UNIX epoch time format.
    public var completedDate: ClientRuntime.Date?
    /// The default mail domain associated with the organization.
    public var defaultMailDomain: Swift.String?
    /// The identifier for the directory associated with an WorkMail organization.
    public var directoryId: Swift.String?
    /// The type of directory associated with the WorkMail organization.
    public var directoryType: Swift.String?
    /// (Optional) The error message indicating if unexpected behavior was encountered with regards to the organization.
    public var errorMessage: Swift.String?
    /// The identifier of an organization.
    public var organizationId: Swift.String?
    /// The state of an organization.
    public var state: Swift.String?

    public init (
        alias: Swift.String? = nil,
        arn: Swift.String? = nil,
        completedDate: ClientRuntime.Date? = nil,
        defaultMailDomain: Swift.String? = nil,
        directoryId: Swift.String? = nil,
        directoryType: Swift.String? = nil,
        errorMessage: Swift.String? = nil,
        organizationId: Swift.String? = nil,
        state: Swift.String? = nil
    )
    {
        self.alias = alias
        self.arn = arn
        self.completedDate = completedDate
        self.defaultMailDomain = defaultMailDomain
        self.directoryId = directoryId
        self.directoryType = directoryType
        self.errorMessage = errorMessage
        self.organizationId = organizationId
        self.state = state
    }
}

struct DescribeOrganizationOutputResponseBody: Swift.Equatable {
    let organizationId: Swift.String?
    let alias: Swift.String?
    let state: Swift.String?
    let directoryId: Swift.String?
    let directoryType: Swift.String?
    let defaultMailDomain: Swift.String?
    let completedDate: ClientRuntime.Date?
    let errorMessage: Swift.String?
    let arn: Swift.String?
}

extension DescribeOrganizationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "ARN"
        case alias = "Alias"
        case completedDate = "CompletedDate"
        case defaultMailDomain = "DefaultMailDomain"
        case directoryId = "DirectoryId"
        case directoryType = "DirectoryType"
        case errorMessage = "ErrorMessage"
        case organizationId = "OrganizationId"
        case state = "State"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let aliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alias)
        alias = aliasDecoded
        let stateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .state)
        state = stateDecoded
        let directoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let directoryTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryType)
        directoryType = directoryTypeDecoded
        let defaultMailDomainDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultMailDomain)
        defaultMailDomain = defaultMailDomainDecoded
        let completedDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .completedDate)
        completedDate = completedDateDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension DescribeResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case organizationId = "OrganizationId"
        case resourceId = "ResourceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
    }
}

extension DescribeResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeResourceInput: Swift.Equatable {
    /// The identifier associated with the organization for which the resource is described.
    /// This member is required.
    public var organizationId: Swift.String?
    /// The identifier of the resource to be described.
    /// This member is required.
    public var resourceId: Swift.String?

    public init (
        organizationId: Swift.String? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.organizationId = organizationId
        self.resourceId = resourceId
    }
}

struct DescribeResourceInputBody: Swift.Equatable {
    let organizationId: Swift.String?
    let resourceId: Swift.String?
}

extension DescribeResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case organizationId = "OrganizationId"
        case resourceId = "ResourceId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
    }
}

extension DescribeResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeResourceOutputError: Swift.Error, Swift.Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case invalidParameterException(InvalidParameterException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.bookingOptions = output.bookingOptions
            self.disabledDate = output.disabledDate
            self.email = output.email
            self.enabledDate = output.enabledDate
            self.name = output.name
            self.resourceId = output.resourceId
            self.state = output.state
            self.type = output.type
        } else {
            self.bookingOptions = nil
            self.disabledDate = nil
            self.email = nil
            self.enabledDate = nil
            self.name = nil
            self.resourceId = nil
            self.state = nil
            self.type = nil
        }
    }
}

public struct DescribeResourceOutputResponse: Swift.Equatable {
    /// The booking options for the described resource.
    public var bookingOptions: WorkMailClientTypes.BookingOptions?
    /// The date and time when a resource was disabled from WorkMail, in UNIX epoch time format.
    public var disabledDate: ClientRuntime.Date?
    /// The email of the described resource.
    public var email: Swift.String?
    /// The date and time when a resource was enabled for WorkMail, in UNIX epoch time format.
    public var enabledDate: ClientRuntime.Date?
    /// The name of the described resource.
    public var name: Swift.String?
    /// The identifier of the described resource.
    public var resourceId: Swift.String?
    /// The state of the resource: enabled (registered to WorkMail), disabled (deregistered or never registered to WorkMail), or deleted.
    public var state: WorkMailClientTypes.EntityState?
    /// The type of the described resource.
    public var type: WorkMailClientTypes.ResourceType?

    public init (
        bookingOptions: WorkMailClientTypes.BookingOptions? = nil,
        disabledDate: ClientRuntime.Date? = nil,
        email: Swift.String? = nil,
        enabledDate: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        state: WorkMailClientTypes.EntityState? = nil,
        type: WorkMailClientTypes.ResourceType? = nil
    )
    {
        self.bookingOptions = bookingOptions
        self.disabledDate = disabledDate
        self.email = email
        self.enabledDate = enabledDate
        self.name = name
        self.resourceId = resourceId
        self.state = state
        self.type = type
    }
}

struct DescribeResourceOutputResponseBody: Swift.Equatable {
    let resourceId: Swift.String?
    let email: Swift.String?
    let name: Swift.String?
    let type: WorkMailClientTypes.ResourceType?
    let bookingOptions: WorkMailClientTypes.BookingOptions?
    let state: WorkMailClientTypes.EntityState?
    let enabledDate: ClientRuntime.Date?
    let disabledDate: ClientRuntime.Date?
}

extension DescribeResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bookingOptions = "BookingOptions"
        case disabledDate = "DisabledDate"
        case email = "Email"
        case enabledDate = "EnabledDate"
        case name = "Name"
        case resourceId = "ResourceId"
        case state = "State"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let emailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .email)
        email = emailDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.ResourceType.self, forKey: .type)
        type = typeDecoded
        let bookingOptionsDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.BookingOptions.self, forKey: .bookingOptions)
        bookingOptions = bookingOptionsDecoded
        let stateDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.EntityState.self, forKey: .state)
        state = stateDecoded
        let enabledDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .enabledDate)
        enabledDate = enabledDateDecoded
        let disabledDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .disabledDate)
        disabledDate = disabledDateDecoded
    }
}

extension DescribeUserInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case organizationId = "OrganizationId"
        case userId = "UserId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
        if let userId = self.userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
    }
}

extension DescribeUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeUserInput: Swift.Equatable {
    /// The identifier for the organization under which the user exists.
    /// This member is required.
    public var organizationId: Swift.String?
    /// The identifier for the user to be described.
    /// This member is required.
    public var userId: Swift.String?

    public init (
        organizationId: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.organizationId = organizationId
        self.userId = userId
    }
}

struct DescribeUserInputBody: Swift.Equatable {
    let organizationId: Swift.String?
    let userId: Swift.String?
}

extension DescribeUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case organizationId = "OrganizationId"
        case userId = "UserId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
    }
}

extension DescribeUserOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeUserOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeUserOutputError: Swift.Error, Swift.Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case invalidParameterException(InvalidParameterException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeUserOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeUserOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.disabledDate = output.disabledDate
            self.displayName = output.displayName
            self.email = output.email
            self.enabledDate = output.enabledDate
            self.name = output.name
            self.state = output.state
            self.userId = output.userId
            self.userRole = output.userRole
        } else {
            self.disabledDate = nil
            self.displayName = nil
            self.email = nil
            self.enabledDate = nil
            self.name = nil
            self.state = nil
            self.userId = nil
            self.userRole = nil
        }
    }
}

public struct DescribeUserOutputResponse: Swift.Equatable {
    /// The date and time at which the user was disabled for WorkMail usage, in UNIX epoch time format.
    public var disabledDate: ClientRuntime.Date?
    /// The display name of the user.
    public var displayName: Swift.String?
    /// The email of the user.
    public var email: Swift.String?
    /// The date and time at which the user was enabled for WorkMailusage, in UNIX epoch time format.
    public var enabledDate: ClientRuntime.Date?
    /// The name for the user.
    public var name: Swift.String?
    /// The state of a user: enabled (registered to WorkMail) or disabled (deregistered or never registered to WorkMail).
    public var state: WorkMailClientTypes.EntityState?
    /// The identifier for the described user.
    public var userId: Swift.String?
    /// In certain cases, other entities are modeled as users. If interoperability is enabled, resources are imported into WorkMail as users. Because different WorkMail organizations rely on different directory types, administrators can distinguish between an unregistered user (account is disabled and has a user role) and the directory administrators. The values are USER, RESOURCE, and SYSTEM_USER.
    public var userRole: WorkMailClientTypes.UserRole?

    public init (
        disabledDate: ClientRuntime.Date? = nil,
        displayName: Swift.String? = nil,
        email: Swift.String? = nil,
        enabledDate: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        state: WorkMailClientTypes.EntityState? = nil,
        userId: Swift.String? = nil,
        userRole: WorkMailClientTypes.UserRole? = nil
    )
    {
        self.disabledDate = disabledDate
        self.displayName = displayName
        self.email = email
        self.enabledDate = enabledDate
        self.name = name
        self.state = state
        self.userId = userId
        self.userRole = userRole
    }
}

struct DescribeUserOutputResponseBody: Swift.Equatable {
    let userId: Swift.String?
    let name: Swift.String?
    let email: Swift.String?
    let displayName: Swift.String?
    let state: WorkMailClientTypes.EntityState?
    let userRole: WorkMailClientTypes.UserRole?
    let enabledDate: ClientRuntime.Date?
    let disabledDate: ClientRuntime.Date?
}

extension DescribeUserOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case disabledDate = "DisabledDate"
        case displayName = "DisplayName"
        case email = "Email"
        case enabledDate = "EnabledDate"
        case name = "Name"
        case state = "State"
        case userId = "UserId"
        case userRole = "UserRole"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let emailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .email)
        email = emailDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let stateDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.EntityState.self, forKey: .state)
        state = stateDecoded
        let userRoleDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.UserRole.self, forKey: .userRole)
        userRole = userRoleDecoded
        let enabledDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .enabledDate)
        enabledDate = enabledDateDecoded
        let disabledDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .disabledDate)
        disabledDate = disabledDateDecoded
    }
}

extension DirectoryInUseException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DirectoryInUseExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The directory is already in use by another WorkMail organization in the same account and Region.
public struct DirectoryInUseException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DirectoryInUseExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension DirectoryInUseExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DirectoryServiceAuthenticationFailedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DirectoryServiceAuthenticationFailedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The directory service doesn't recognize the credentials supplied by WorkMail.
public struct DirectoryServiceAuthenticationFailedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DirectoryServiceAuthenticationFailedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension DirectoryServiceAuthenticationFailedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DirectoryUnavailableException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DirectoryUnavailableExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The directory is unavailable. It might be located in another Region or deleted.
public struct DirectoryUnavailableException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DirectoryUnavailableExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension DirectoryUnavailableExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DisassociateDelegateFromResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entityId = "EntityId"
        case organizationId = "OrganizationId"
        case resourceId = "ResourceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entityId = self.entityId {
            try encodeContainer.encode(entityId, forKey: .entityId)
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
    }
}

extension DisassociateDelegateFromResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DisassociateDelegateFromResourceInput: Swift.Equatable {
    /// The identifier for the member (user, group) to be removed from the resource's delegates.
    /// This member is required.
    public var entityId: Swift.String?
    /// The identifier for the organization under which the resource exists.
    /// This member is required.
    public var organizationId: Swift.String?
    /// The identifier of the resource from which delegates' set members are removed.
    /// This member is required.
    public var resourceId: Swift.String?

    public init (
        entityId: Swift.String? = nil,
        organizationId: Swift.String? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.entityId = entityId
        self.organizationId = organizationId
        self.resourceId = resourceId
    }
}

struct DisassociateDelegateFromResourceInputBody: Swift.Equatable {
    let organizationId: Swift.String?
    let resourceId: Swift.String?
    let entityId: Swift.String?
}

extension DisassociateDelegateFromResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entityId = "EntityId"
        case organizationId = "OrganizationId"
        case resourceId = "ResourceId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let entityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityId)
        entityId = entityIdDecoded
    }
}

extension DisassociateDelegateFromResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateDelegateFromResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityStateException" : self = .entityStateException(try EntityStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DisassociateDelegateFromResourceOutputError: Swift.Error, Swift.Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case entityStateException(EntityStateException)
    case invalidParameterException(InvalidParameterException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateDelegateFromResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateDelegateFromResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension DisassociateMemberFromGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupId = "GroupId"
        case memberId = "MemberId"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupId = self.groupId {
            try encodeContainer.encode(groupId, forKey: .groupId)
        }
        if let memberId = self.memberId {
            try encodeContainer.encode(memberId, forKey: .memberId)
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

extension DisassociateMemberFromGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DisassociateMemberFromGroupInput: Swift.Equatable {
    /// The identifier for the group from which members are removed.
    /// This member is required.
    public var groupId: Swift.String?
    /// The identifier for the member to be removed to the group.
    /// This member is required.
    public var memberId: Swift.String?
    /// The identifier for the organization under which the group exists.
    /// This member is required.
    public var organizationId: Swift.String?

    public init (
        groupId: Swift.String? = nil,
        memberId: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.groupId = groupId
        self.memberId = memberId
        self.organizationId = organizationId
    }
}

struct DisassociateMemberFromGroupInputBody: Swift.Equatable {
    let organizationId: Swift.String?
    let groupId: Swift.String?
    let memberId: Swift.String?
}

extension DisassociateMemberFromGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupId = "GroupId"
        case memberId = "MemberId"
        case organizationId = "OrganizationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let groupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupId)
        groupId = groupIdDecoded
        let memberIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .memberId)
        memberId = memberIdDecoded
    }
}

extension DisassociateMemberFromGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateMemberFromGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DirectoryServiceAuthenticationFailedException" : self = .directoryServiceAuthenticationFailedException(try DirectoryServiceAuthenticationFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryUnavailableException" : self = .directoryUnavailableException(try DirectoryUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityStateException" : self = .entityStateException(try EntityStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DisassociateMemberFromGroupOutputError: Swift.Error, Swift.Equatable {
    case directoryServiceAuthenticationFailedException(DirectoryServiceAuthenticationFailedException)
    case directoryUnavailableException(DirectoryUnavailableException)
    case entityNotFoundException(EntityNotFoundException)
    case entityStateException(EntityStateException)
    case invalidParameterException(InvalidParameterException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateMemberFromGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateMemberFromGroupOutputResponse: Swift.Equatable {

    public init () { }
}

extension WorkMailClientTypes.DnsRecord: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hostname = "Hostname"
        case type = "Type"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hostname = self.hostname {
            try encodeContainer.encode(hostname, forKey: .hostname)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let hostnameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostname)
        hostname = hostnameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension WorkMailClientTypes {
    /// A DNS record uploaded to your DNS provider.
    public struct DnsRecord: Swift.Equatable {
        /// The DNS hostname.- For example, domain.example.com.
        public var hostname: Swift.String?
        /// The RFC 1035 record type. Possible values: CNAME, A, MX.
        public var type: Swift.String?
        /// The value returned by the DNS for a query to that hostname and record type.
        public var value: Swift.String?

        public init (
            hostname: Swift.String? = nil,
            type: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.hostname = hostname
            self.type = type
            self.value = value
        }
    }

}

extension WorkMailClientTypes {
    public enum DnsRecordVerificationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case pending
        case verified
        case sdkUnknown(Swift.String)

        public static var allCases: [DnsRecordVerificationStatus] {
            return [
                .failed,
                .pending,
                .verified,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .pending: return "PENDING"
            case .verified: return "VERIFIED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DnsRecordVerificationStatus(rawValue: rawValue) ?? DnsRecordVerificationStatus.sdkUnknown(rawValue)
        }
    }
}

extension WorkMailClientTypes.Domain: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
        case hostedZoneId = "HostedZoneId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainName = self.domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let hostedZoneId = self.hostedZoneId {
            try encodeContainer.encode(hostedZoneId, forKey: .hostedZoneId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let hostedZoneIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostedZoneId)
        hostedZoneId = hostedZoneIdDecoded
    }
}

extension WorkMailClientTypes {
    /// The domain to associate with an WorkMail organization. When you configure a domain hosted in Amazon Route 53 (Route 53), all recommended DNS records are added to the organization when you create it. For more information, see [Adding a domain](https://docs.aws.amazon.com/workmail/latest/adminguide/add_domain.html) in the WorkMail Administrator Guide.
    public struct Domain: Swift.Equatable {
        /// The fully qualified domain name.
        public var domainName: Swift.String?
        /// The hosted zone ID for a domain hosted in Route 53. Required when configuring a domain hosted in Route 53.
        public var hostedZoneId: Swift.String?

        public init (
            domainName: Swift.String? = nil,
            hostedZoneId: Swift.String? = nil
        )
        {
            self.domainName = domainName
            self.hostedZoneId = hostedZoneId
        }
    }

}

extension EmailAddressInUseException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: EmailAddressInUseExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The email address that you're trying to assign is already created for a different user, group, or resource.
public struct EmailAddressInUseException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct EmailAddressInUseExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension EmailAddressInUseExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EntityAlreadyRegisteredException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: EntityAlreadyRegisteredExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The user, group, or resource that you're trying to register is already registered.
public struct EntityAlreadyRegisteredException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct EntityAlreadyRegisteredExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension EntityAlreadyRegisteredExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EntityNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: EntityNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The identifier supplied for the user, group, or resource does not exist in your organization.
public struct EntityNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct EntityNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension EntityNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension WorkMailClientTypes {
    public enum EntityState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deleted
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [EntityState] {
            return [
                .deleted,
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deleted: return "DELETED"
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EntityState(rawValue: rawValue) ?? EntityState.sdkUnknown(rawValue)
        }
    }
}

extension EntityStateException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: EntityStateExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You are performing an operation on a user, group, or resource that isn't in the expected state, such as trying to delete an active user.
public struct EntityStateException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct EntityStateExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension EntityStateExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension WorkMailClientTypes.EwsAvailabilityProvider: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ewsEndpoint = "EwsEndpoint"
        case ewsPassword = "EwsPassword"
        case ewsUsername = "EwsUsername"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ewsEndpoint = self.ewsEndpoint {
            try encodeContainer.encode(ewsEndpoint, forKey: .ewsEndpoint)
        }
        if let ewsPassword = self.ewsPassword {
            try encodeContainer.encode(ewsPassword, forKey: .ewsPassword)
        }
        if let ewsUsername = self.ewsUsername {
            try encodeContainer.encode(ewsUsername, forKey: .ewsUsername)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ewsEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ewsEndpoint)
        ewsEndpoint = ewsEndpointDecoded
        let ewsUsernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ewsUsername)
        ewsUsername = ewsUsernameDecoded
        let ewsPasswordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ewsPassword)
        ewsPassword = ewsPasswordDecoded
    }
}

extension WorkMailClientTypes.EwsAvailabilityProvider: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EwsAvailabilityProvider(ewsEndpoint: \(Swift.String(describing: ewsEndpoint)), ewsUsername: \(Swift.String(describing: ewsUsername)), ewsPassword: \"CONTENT_REDACTED\")"}
}

extension WorkMailClientTypes {
    /// Describes an EWS based availability provider. This is only used as input to the service.
    public struct EwsAvailabilityProvider: Swift.Equatable {
        /// The endpoint of the remote EWS server.
        /// This member is required.
        public var ewsEndpoint: Swift.String?
        /// The password used to authenticate the remote EWS server.
        /// This member is required.
        public var ewsPassword: Swift.String?
        /// The username used to authenticate the remote EWS server.
        /// This member is required.
        public var ewsUsername: Swift.String?

        public init (
            ewsEndpoint: Swift.String? = nil,
            ewsPassword: Swift.String? = nil,
            ewsUsername: Swift.String? = nil
        )
        {
            self.ewsEndpoint = ewsEndpoint
            self.ewsPassword = ewsPassword
            self.ewsUsername = ewsUsername
        }
    }

}

extension WorkMailClientTypes.FolderConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "Action"
        case name = "Name"
        case period = "Period"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = self.action {
            try encodeContainer.encode(action.rawValue, forKey: .action)
        }
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let period = self.period {
            try encodeContainer.encode(period, forKey: .period)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.FolderName.self, forKey: .name)
        name = nameDecoded
        let actionDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.RetentionAction.self, forKey: .action)
        action = actionDecoded
        let periodDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .period)
        period = periodDecoded
    }
}

extension WorkMailClientTypes {
    /// The configuration applied to an organization's folders by its retention policy.
    public struct FolderConfiguration: Swift.Equatable {
        /// The action to take on the folder contents at the end of the folder configuration period.
        /// This member is required.
        public var action: WorkMailClientTypes.RetentionAction?
        /// The folder name.
        /// This member is required.
        public var name: WorkMailClientTypes.FolderName?
        /// The number of days for which the folder-configuration action applies.
        public var period: Swift.Int?

        public init (
            action: WorkMailClientTypes.RetentionAction? = nil,
            name: WorkMailClientTypes.FolderName? = nil,
            period: Swift.Int? = nil
        )
        {
            self.action = action
            self.name = name
            self.period = period
        }
    }

}

extension WorkMailClientTypes {
    public enum FolderName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deletedItems
        case drafts
        case inbox
        case junkEmail
        case sentItems
        case sdkUnknown(Swift.String)

        public static var allCases: [FolderName] {
            return [
                .deletedItems,
                .drafts,
                .inbox,
                .junkEmail,
                .sentItems,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deletedItems: return "DELETED_ITEMS"
            case .drafts: return "DRAFTS"
            case .inbox: return "INBOX"
            case .junkEmail: return "JUNK_EMAIL"
            case .sentItems: return "SENT_ITEMS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FolderName(rawValue: rawValue) ?? FolderName.sdkUnknown(rawValue)
        }
    }
}

extension GetAccessControlEffectInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "Action"
        case impersonationRoleId = "ImpersonationRoleId"
        case ipAddress = "IpAddress"
        case organizationId = "OrganizationId"
        case userId = "UserId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = self.action {
            try encodeContainer.encode(action, forKey: .action)
        }
        if let impersonationRoleId = self.impersonationRoleId {
            try encodeContainer.encode(impersonationRoleId, forKey: .impersonationRoleId)
        }
        if let ipAddress = self.ipAddress {
            try encodeContainer.encode(ipAddress, forKey: .ipAddress)
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
        if let userId = self.userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
    }
}

extension GetAccessControlEffectInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetAccessControlEffectInput: Swift.Equatable {
    /// The access protocol action. Valid values include ActiveSync, AutoDiscover, EWS, IMAP, SMTP, WindowsOutlook, and WebMail.
    /// This member is required.
    public var action: Swift.String?
    /// The impersonation role ID.
    public var impersonationRoleId: Swift.String?
    /// The IPv4 address.
    /// This member is required.
    public var ipAddress: Swift.String?
    /// The identifier for the organization.
    /// This member is required.
    public var organizationId: Swift.String?
    /// The user ID.
    public var userId: Swift.String?

    public init (
        action: Swift.String? = nil,
        impersonationRoleId: Swift.String? = nil,
        ipAddress: Swift.String? = nil,
        organizationId: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.action = action
        self.impersonationRoleId = impersonationRoleId
        self.ipAddress = ipAddress
        self.organizationId = organizationId
        self.userId = userId
    }
}

struct GetAccessControlEffectInputBody: Swift.Equatable {
    let organizationId: Swift.String?
    let ipAddress: Swift.String?
    let action: Swift.String?
    let userId: Swift.String?
    let impersonationRoleId: Swift.String?
}

extension GetAccessControlEffectInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "Action"
        case impersonationRoleId = "ImpersonationRoleId"
        case ipAddress = "IpAddress"
        case organizationId = "OrganizationId"
        case userId = "UserId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let ipAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ipAddress)
        ipAddress = ipAddressDecoded
        let actionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .action)
        action = actionDecoded
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
        let impersonationRoleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .impersonationRoleId)
        impersonationRoleId = impersonationRoleIdDecoded
    }
}

extension GetAccessControlEffectOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAccessControlEffectOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetAccessControlEffectOutputError: Swift.Error, Swift.Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case invalidParameterException(InvalidParameterException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAccessControlEffectOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetAccessControlEffectOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.effect = output.effect
            self.matchedRules = output.matchedRules
        } else {
            self.effect = nil
            self.matchedRules = nil
        }
    }
}

public struct GetAccessControlEffectOutputResponse: Swift.Equatable {
    /// The rule effect.
    public var effect: WorkMailClientTypes.AccessControlRuleEffect?
    /// The rules that match the given parameters, resulting in an effect.
    public var matchedRules: [Swift.String]?

    public init (
        effect: WorkMailClientTypes.AccessControlRuleEffect? = nil,
        matchedRules: [Swift.String]? = nil
    )
    {
        self.effect = effect
        self.matchedRules = matchedRules
    }
}

struct GetAccessControlEffectOutputResponseBody: Swift.Equatable {
    let effect: WorkMailClientTypes.AccessControlRuleEffect?
    let matchedRules: [Swift.String]?
}

extension GetAccessControlEffectOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case effect = "Effect"
        case matchedRules = "MatchedRules"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let effectDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.AccessControlRuleEffect.self, forKey: .effect)
        effect = effectDecoded
        let matchedRulesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .matchedRules)
        var matchedRulesDecoded0:[Swift.String]? = nil
        if let matchedRulesContainer = matchedRulesContainer {
            matchedRulesDecoded0 = [Swift.String]()
            for string0 in matchedRulesContainer {
                if let string0 = string0 {
                    matchedRulesDecoded0?.append(string0)
                }
            }
        }
        matchedRules = matchedRulesDecoded0
    }
}

extension GetDefaultRetentionPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

extension GetDefaultRetentionPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetDefaultRetentionPolicyInput: Swift.Equatable {
    /// The organization ID.
    /// This member is required.
    public var organizationId: Swift.String?

    public init (
        organizationId: Swift.String? = nil
    )
    {
        self.organizationId = organizationId
    }
}

struct GetDefaultRetentionPolicyInputBody: Swift.Equatable {
    let organizationId: Swift.String?
}

extension GetDefaultRetentionPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case organizationId = "OrganizationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
    }
}

extension GetDefaultRetentionPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDefaultRetentionPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetDefaultRetentionPolicyOutputError: Swift.Error, Swift.Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case invalidParameterException(InvalidParameterException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDefaultRetentionPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetDefaultRetentionPolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.description = output.description
            self.folderConfigurations = output.folderConfigurations
            self.id = output.id
            self.name = output.name
        } else {
            self.description = nil
            self.folderConfigurations = nil
            self.id = nil
            self.name = nil
        }
    }
}

public struct GetDefaultRetentionPolicyOutputResponse: Swift.Equatable {
    /// The retention policy description.
    public var description: Swift.String?
    /// The retention policy folder configurations.
    public var folderConfigurations: [WorkMailClientTypes.FolderConfiguration]?
    /// The retention policy ID.
    public var id: Swift.String?
    /// The retention policy name.
    public var name: Swift.String?

    public init (
        description: Swift.String? = nil,
        folderConfigurations: [WorkMailClientTypes.FolderConfiguration]? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.description = description
        self.folderConfigurations = folderConfigurations
        self.id = id
        self.name = name
    }
}

struct GetDefaultRetentionPolicyOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let folderConfigurations: [WorkMailClientTypes.FolderConfiguration]?
}

extension GetDefaultRetentionPolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case folderConfigurations = "FolderConfigurations"
        case id = "Id"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let folderConfigurationsContainer = try containerValues.decodeIfPresent([WorkMailClientTypes.FolderConfiguration?].self, forKey: .folderConfigurations)
        var folderConfigurationsDecoded0:[WorkMailClientTypes.FolderConfiguration]? = nil
        if let folderConfigurationsContainer = folderConfigurationsContainer {
            folderConfigurationsDecoded0 = [WorkMailClientTypes.FolderConfiguration]()
            for structure0 in folderConfigurationsContainer {
                if let structure0 = structure0 {
                    folderConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        folderConfigurations = folderConfigurationsDecoded0
    }
}

extension GetImpersonationRoleEffectInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case impersonationRoleId = "ImpersonationRoleId"
        case organizationId = "OrganizationId"
        case targetUser = "TargetUser"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let impersonationRoleId = self.impersonationRoleId {
            try encodeContainer.encode(impersonationRoleId, forKey: .impersonationRoleId)
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
        if let targetUser = self.targetUser {
            try encodeContainer.encode(targetUser, forKey: .targetUser)
        }
    }
}

extension GetImpersonationRoleEffectInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetImpersonationRoleEffectInput: Swift.Equatable {
    /// The impersonation role ID to test.
    /// This member is required.
    public var impersonationRoleId: Swift.String?
    /// The WorkMail organization where the impersonation role is defined.
    /// This member is required.
    public var organizationId: Swift.String?
    /// The WorkMail organization user chosen to test the impersonation role. The following identity formats are available:
    ///
    /// * User ID: 12345678-1234-1234-1234-123456789012 or S-1-1-12-1234567890-123456789-123456789-1234
    ///
    /// * Email address: user@domain.tld
    ///
    /// * User name: user
    /// This member is required.
    public var targetUser: Swift.String?

    public init (
        impersonationRoleId: Swift.String? = nil,
        organizationId: Swift.String? = nil,
        targetUser: Swift.String? = nil
    )
    {
        self.impersonationRoleId = impersonationRoleId
        self.organizationId = organizationId
        self.targetUser = targetUser
    }
}

struct GetImpersonationRoleEffectInputBody: Swift.Equatable {
    let organizationId: Swift.String?
    let impersonationRoleId: Swift.String?
    let targetUser: Swift.String?
}

extension GetImpersonationRoleEffectInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case impersonationRoleId = "ImpersonationRoleId"
        case organizationId = "OrganizationId"
        case targetUser = "TargetUser"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let impersonationRoleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .impersonationRoleId)
        impersonationRoleId = impersonationRoleIdDecoded
        let targetUserDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetUser)
        targetUser = targetUserDecoded
    }
}

extension GetImpersonationRoleEffectOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetImpersonationRoleEffectOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityStateException" : self = .entityStateException(try EntityStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetImpersonationRoleEffectOutputError: Swift.Error, Swift.Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case entityStateException(EntityStateException)
    case invalidParameterException(InvalidParameterException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetImpersonationRoleEffectOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetImpersonationRoleEffectOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.effect = output.effect
            self.matchedRules = output.matchedRules
            self.type = output.type
        } else {
            self.effect = nil
            self.matchedRules = nil
            self.type = nil
        }
    }
}

public struct GetImpersonationRoleEffectOutputResponse: Swift.Equatable {
    /// Effect of the impersonation role on the target user based on its rules. Available effects are ALLOW or DENY.
    public var effect: WorkMailClientTypes.AccessEffect?
    /// A list of the rules that match the input and produce the configured effect.
    public var matchedRules: [WorkMailClientTypes.ImpersonationMatchedRule]?
    /// The impersonation role type.
    public var type: WorkMailClientTypes.ImpersonationRoleType?

    public init (
        effect: WorkMailClientTypes.AccessEffect? = nil,
        matchedRules: [WorkMailClientTypes.ImpersonationMatchedRule]? = nil,
        type: WorkMailClientTypes.ImpersonationRoleType? = nil
    )
    {
        self.effect = effect
        self.matchedRules = matchedRules
        self.type = type
    }
}

struct GetImpersonationRoleEffectOutputResponseBody: Swift.Equatable {
    let type: WorkMailClientTypes.ImpersonationRoleType?
    let effect: WorkMailClientTypes.AccessEffect?
    let matchedRules: [WorkMailClientTypes.ImpersonationMatchedRule]?
}

extension GetImpersonationRoleEffectOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case effect = "Effect"
        case matchedRules = "MatchedRules"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.ImpersonationRoleType.self, forKey: .type)
        type = typeDecoded
        let effectDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.AccessEffect.self, forKey: .effect)
        effect = effectDecoded
        let matchedRulesContainer = try containerValues.decodeIfPresent([WorkMailClientTypes.ImpersonationMatchedRule?].self, forKey: .matchedRules)
        var matchedRulesDecoded0:[WorkMailClientTypes.ImpersonationMatchedRule]? = nil
        if let matchedRulesContainer = matchedRulesContainer {
            matchedRulesDecoded0 = [WorkMailClientTypes.ImpersonationMatchedRule]()
            for structure0 in matchedRulesContainer {
                if let structure0 = structure0 {
                    matchedRulesDecoded0?.append(structure0)
                }
            }
        }
        matchedRules = matchedRulesDecoded0
    }
}

extension GetImpersonationRoleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case impersonationRoleId = "ImpersonationRoleId"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let impersonationRoleId = self.impersonationRoleId {
            try encodeContainer.encode(impersonationRoleId, forKey: .impersonationRoleId)
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

extension GetImpersonationRoleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetImpersonationRoleInput: Swift.Equatable {
    /// The impersonation role ID to retrieve.
    /// This member is required.
    public var impersonationRoleId: Swift.String?
    /// The WorkMail organization from which to retrieve the impersonation role.
    /// This member is required.
    public var organizationId: Swift.String?

    public init (
        impersonationRoleId: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.impersonationRoleId = impersonationRoleId
        self.organizationId = organizationId
    }
}

struct GetImpersonationRoleInputBody: Swift.Equatable {
    let organizationId: Swift.String?
    let impersonationRoleId: Swift.String?
}

extension GetImpersonationRoleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case impersonationRoleId = "ImpersonationRoleId"
        case organizationId = "OrganizationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let impersonationRoleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .impersonationRoleId)
        impersonationRoleId = impersonationRoleIdDecoded
    }
}

extension GetImpersonationRoleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetImpersonationRoleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetImpersonationRoleOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterException(InvalidParameterException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetImpersonationRoleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetImpersonationRoleOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dateCreated = output.dateCreated
            self.dateModified = output.dateModified
            self.description = output.description
            self.impersonationRoleId = output.impersonationRoleId
            self.name = output.name
            self.rules = output.rules
            self.type = output.type
        } else {
            self.dateCreated = nil
            self.dateModified = nil
            self.description = nil
            self.impersonationRoleId = nil
            self.name = nil
            self.rules = nil
            self.type = nil
        }
    }
}

public struct GetImpersonationRoleOutputResponse: Swift.Equatable {
    /// The date when the impersonation role was created.
    public var dateCreated: ClientRuntime.Date?
    /// The date when the impersonation role was last modified.
    public var dateModified: ClientRuntime.Date?
    /// The impersonation role description.
    public var description: Swift.String?
    /// The impersonation role ID.
    public var impersonationRoleId: Swift.String?
    /// The impersonation role name.
    public var name: Swift.String?
    /// The list of rules for the given impersonation role.
    public var rules: [WorkMailClientTypes.ImpersonationRule]?
    /// The impersonation role type.
    public var type: WorkMailClientTypes.ImpersonationRoleType?

    public init (
        dateCreated: ClientRuntime.Date? = nil,
        dateModified: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        impersonationRoleId: Swift.String? = nil,
        name: Swift.String? = nil,
        rules: [WorkMailClientTypes.ImpersonationRule]? = nil,
        type: WorkMailClientTypes.ImpersonationRoleType? = nil
    )
    {
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.description = description
        self.impersonationRoleId = impersonationRoleId
        self.name = name
        self.rules = rules
        self.type = type
    }
}

struct GetImpersonationRoleOutputResponseBody: Swift.Equatable {
    let impersonationRoleId: Swift.String?
    let name: Swift.String?
    let type: WorkMailClientTypes.ImpersonationRoleType?
    let description: Swift.String?
    let rules: [WorkMailClientTypes.ImpersonationRule]?
    let dateCreated: ClientRuntime.Date?
    let dateModified: ClientRuntime.Date?
}

extension GetImpersonationRoleOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dateCreated = "DateCreated"
        case dateModified = "DateModified"
        case description = "Description"
        case impersonationRoleId = "ImpersonationRoleId"
        case name = "Name"
        case rules = "Rules"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let impersonationRoleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .impersonationRoleId)
        impersonationRoleId = impersonationRoleIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.ImpersonationRoleType.self, forKey: .type)
        type = typeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let rulesContainer = try containerValues.decodeIfPresent([WorkMailClientTypes.ImpersonationRule?].self, forKey: .rules)
        var rulesDecoded0:[WorkMailClientTypes.ImpersonationRule]? = nil
        if let rulesContainer = rulesContainer {
            rulesDecoded0 = [WorkMailClientTypes.ImpersonationRule]()
            for structure0 in rulesContainer {
                if let structure0 = structure0 {
                    rulesDecoded0?.append(structure0)
                }
            }
        }
        rules = rulesDecoded0
        let dateCreatedDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .dateCreated)
        dateCreated = dateCreatedDecoded
        let dateModifiedDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .dateModified)
        dateModified = dateModifiedDecoded
    }
}

extension GetMailDomainInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainName = self.domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

extension GetMailDomainInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetMailDomainInput: Swift.Equatable {
    /// The domain from which you want to retrieve details.
    /// This member is required.
    public var domainName: Swift.String?
    /// The WorkMail organization for which the domain is retrieved.
    /// This member is required.
    public var organizationId: Swift.String?

    public init (
        domainName: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.organizationId = organizationId
    }
}

struct GetMailDomainInputBody: Swift.Equatable {
    let organizationId: Swift.String?
    let domainName: Swift.String?
}

extension GetMailDomainInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
        case organizationId = "OrganizationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
    }
}

extension GetMailDomainOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetMailDomainOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MailDomainNotFoundException" : self = .mailDomainNotFoundException(try MailDomainNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetMailDomainOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterException(InvalidParameterException)
    case mailDomainNotFoundException(MailDomainNotFoundException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetMailDomainOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetMailDomainOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dkimVerificationStatus = output.dkimVerificationStatus
            self.isDefault = output.isDefault
            self.isTestDomain = output.isTestDomain
            self.ownershipVerificationStatus = output.ownershipVerificationStatus
            self.records = output.records
        } else {
            self.dkimVerificationStatus = nil
            self.isDefault = false
            self.isTestDomain = false
            self.ownershipVerificationStatus = nil
            self.records = nil
        }
    }
}

public struct GetMailDomainOutputResponse: Swift.Equatable {
    /// Indicates the status of a DKIM verification.
    public var dkimVerificationStatus: WorkMailClientTypes.DnsRecordVerificationStatus?
    /// Specifies whether the domain is the default domain for your organization.
    public var isDefault: Swift.Bool
    /// Specifies whether the domain is a test domain provided by WorkMail, or a custom domain.
    public var isTestDomain: Swift.Bool
    /// Indicates the status of the domain ownership verification.
    public var ownershipVerificationStatus: WorkMailClientTypes.DnsRecordVerificationStatus?
    /// A list of the DNS records that WorkMail recommends adding in your DNS provider for the best user experience. The records configure your domain with DMARC, SPF, DKIM, and direct incoming email traffic to SES. See admin guide for more details.
    public var records: [WorkMailClientTypes.DnsRecord]?

    public init (
        dkimVerificationStatus: WorkMailClientTypes.DnsRecordVerificationStatus? = nil,
        isDefault: Swift.Bool = false,
        isTestDomain: Swift.Bool = false,
        ownershipVerificationStatus: WorkMailClientTypes.DnsRecordVerificationStatus? = nil,
        records: [WorkMailClientTypes.DnsRecord]? = nil
    )
    {
        self.dkimVerificationStatus = dkimVerificationStatus
        self.isDefault = isDefault
        self.isTestDomain = isTestDomain
        self.ownershipVerificationStatus = ownershipVerificationStatus
        self.records = records
    }
}

struct GetMailDomainOutputResponseBody: Swift.Equatable {
    let records: [WorkMailClientTypes.DnsRecord]?
    let isTestDomain: Swift.Bool
    let isDefault: Swift.Bool
    let ownershipVerificationStatus: WorkMailClientTypes.DnsRecordVerificationStatus?
    let dkimVerificationStatus: WorkMailClientTypes.DnsRecordVerificationStatus?
}

extension GetMailDomainOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dkimVerificationStatus = "DkimVerificationStatus"
        case isDefault = "IsDefault"
        case isTestDomain = "IsTestDomain"
        case ownershipVerificationStatus = "OwnershipVerificationStatus"
        case records = "Records"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recordsContainer = try containerValues.decodeIfPresent([WorkMailClientTypes.DnsRecord?].self, forKey: .records)
        var recordsDecoded0:[WorkMailClientTypes.DnsRecord]? = nil
        if let recordsContainer = recordsContainer {
            recordsDecoded0 = [WorkMailClientTypes.DnsRecord]()
            for structure0 in recordsContainer {
                if let structure0 = structure0 {
                    recordsDecoded0?.append(structure0)
                }
            }
        }
        records = recordsDecoded0
        let isTestDomainDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isTestDomain) ?? false
        isTestDomain = isTestDomainDecoded
        let isDefaultDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isDefault) ?? false
        isDefault = isDefaultDecoded
        let ownershipVerificationStatusDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.DnsRecordVerificationStatus.self, forKey: .ownershipVerificationStatus)
        ownershipVerificationStatus = ownershipVerificationStatusDecoded
        let dkimVerificationStatusDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.DnsRecordVerificationStatus.self, forKey: .dkimVerificationStatus)
        dkimVerificationStatus = dkimVerificationStatusDecoded
    }
}

extension GetMailboxDetailsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case organizationId = "OrganizationId"
        case userId = "UserId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
        if let userId = self.userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
    }
}

extension GetMailboxDetailsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetMailboxDetailsInput: Swift.Equatable {
    /// The identifier for the organization that contains the user whose mailbox details are being requested.
    /// This member is required.
    public var organizationId: Swift.String?
    /// The identifier for the user whose mailbox details are being requested.
    /// This member is required.
    public var userId: Swift.String?

    public init (
        organizationId: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.organizationId = organizationId
        self.userId = userId
    }
}

struct GetMailboxDetailsInputBody: Swift.Equatable {
    let organizationId: Swift.String?
    let userId: Swift.String?
}

extension GetMailboxDetailsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case organizationId = "OrganizationId"
        case userId = "UserId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
    }
}

extension GetMailboxDetailsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetMailboxDetailsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetMailboxDetailsOutputError: Swift.Error, Swift.Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetMailboxDetailsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetMailboxDetailsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.mailboxQuota = output.mailboxQuota
            self.mailboxSize = output.mailboxSize
        } else {
            self.mailboxQuota = nil
            self.mailboxSize = 0.0
        }
    }
}

public struct GetMailboxDetailsOutputResponse: Swift.Equatable {
    /// The maximum allowed mailbox size, in MB, for the specified user.
    public var mailboxQuota: Swift.Int?
    /// The current mailbox size, in MB, for the specified user.
    public var mailboxSize: Swift.Double

    public init (
        mailboxQuota: Swift.Int? = nil,
        mailboxSize: Swift.Double = 0.0
    )
    {
        self.mailboxQuota = mailboxQuota
        self.mailboxSize = mailboxSize
    }
}

struct GetMailboxDetailsOutputResponseBody: Swift.Equatable {
    let mailboxQuota: Swift.Int?
    let mailboxSize: Swift.Double
}

extension GetMailboxDetailsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mailboxQuota = "MailboxQuota"
        case mailboxSize = "MailboxSize"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mailboxQuotaDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .mailboxQuota)
        mailboxQuota = mailboxQuotaDecoded
        let mailboxSizeDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .mailboxSize) ?? 0.0
        mailboxSize = mailboxSizeDecoded
    }
}

extension GetMobileDeviceAccessEffectInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceModel = "DeviceModel"
        case deviceOperatingSystem = "DeviceOperatingSystem"
        case deviceType = "DeviceType"
        case deviceUserAgent = "DeviceUserAgent"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceModel = self.deviceModel {
            try encodeContainer.encode(deviceModel, forKey: .deviceModel)
        }
        if let deviceOperatingSystem = self.deviceOperatingSystem {
            try encodeContainer.encode(deviceOperatingSystem, forKey: .deviceOperatingSystem)
        }
        if let deviceType = self.deviceType {
            try encodeContainer.encode(deviceType, forKey: .deviceType)
        }
        if let deviceUserAgent = self.deviceUserAgent {
            try encodeContainer.encode(deviceUserAgent, forKey: .deviceUserAgent)
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

extension GetMobileDeviceAccessEffectInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetMobileDeviceAccessEffectInput: Swift.Equatable {
    /// Device model the simulated user will report.
    public var deviceModel: Swift.String?
    /// Device operating system the simulated user will report.
    public var deviceOperatingSystem: Swift.String?
    /// Device type the simulated user will report.
    public var deviceType: Swift.String?
    /// Device user agent the simulated user will report.
    public var deviceUserAgent: Swift.String?
    /// The WorkMail organization to simulate the access effect for.
    /// This member is required.
    public var organizationId: Swift.String?

    public init (
        deviceModel: Swift.String? = nil,
        deviceOperatingSystem: Swift.String? = nil,
        deviceType: Swift.String? = nil,
        deviceUserAgent: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.deviceModel = deviceModel
        self.deviceOperatingSystem = deviceOperatingSystem
        self.deviceType = deviceType
        self.deviceUserAgent = deviceUserAgent
        self.organizationId = organizationId
    }
}

struct GetMobileDeviceAccessEffectInputBody: Swift.Equatable {
    let organizationId: Swift.String?
    let deviceType: Swift.String?
    let deviceModel: Swift.String?
    let deviceOperatingSystem: Swift.String?
    let deviceUserAgent: Swift.String?
}

extension GetMobileDeviceAccessEffectInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceModel = "DeviceModel"
        case deviceOperatingSystem = "DeviceOperatingSystem"
        case deviceType = "DeviceType"
        case deviceUserAgent = "DeviceUserAgent"
        case organizationId = "OrganizationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let deviceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceType)
        deviceType = deviceTypeDecoded
        let deviceModelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceModel)
        deviceModel = deviceModelDecoded
        let deviceOperatingSystemDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceOperatingSystem)
        deviceOperatingSystem = deviceOperatingSystemDecoded
        let deviceUserAgentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceUserAgent)
        deviceUserAgent = deviceUserAgentDecoded
    }
}

extension GetMobileDeviceAccessEffectOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetMobileDeviceAccessEffectOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetMobileDeviceAccessEffectOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterException(InvalidParameterException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetMobileDeviceAccessEffectOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetMobileDeviceAccessEffectOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.effect = output.effect
            self.matchedRules = output.matchedRules
        } else {
            self.effect = nil
            self.matchedRules = nil
        }
    }
}

public struct GetMobileDeviceAccessEffectOutputResponse: Swift.Equatable {
    /// The effect of the simulated access, ALLOW or DENY, after evaluating mobile device access rules in the WorkMail organization for the simulated user parameters.
    public var effect: WorkMailClientTypes.MobileDeviceAccessRuleEffect?
    /// A list of the rules which matched the simulated user input and produced the effect.
    public var matchedRules: [WorkMailClientTypes.MobileDeviceAccessMatchedRule]?

    public init (
        effect: WorkMailClientTypes.MobileDeviceAccessRuleEffect? = nil,
        matchedRules: [WorkMailClientTypes.MobileDeviceAccessMatchedRule]? = nil
    )
    {
        self.effect = effect
        self.matchedRules = matchedRules
    }
}

struct GetMobileDeviceAccessEffectOutputResponseBody: Swift.Equatable {
    let effect: WorkMailClientTypes.MobileDeviceAccessRuleEffect?
    let matchedRules: [WorkMailClientTypes.MobileDeviceAccessMatchedRule]?
}

extension GetMobileDeviceAccessEffectOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case effect = "Effect"
        case matchedRules = "MatchedRules"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let effectDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.MobileDeviceAccessRuleEffect.self, forKey: .effect)
        effect = effectDecoded
        let matchedRulesContainer = try containerValues.decodeIfPresent([WorkMailClientTypes.MobileDeviceAccessMatchedRule?].self, forKey: .matchedRules)
        var matchedRulesDecoded0:[WorkMailClientTypes.MobileDeviceAccessMatchedRule]? = nil
        if let matchedRulesContainer = matchedRulesContainer {
            matchedRulesDecoded0 = [WorkMailClientTypes.MobileDeviceAccessMatchedRule]()
            for structure0 in matchedRulesContainer {
                if let structure0 = structure0 {
                    matchedRulesDecoded0?.append(structure0)
                }
            }
        }
        matchedRules = matchedRulesDecoded0
    }
}

extension GetMobileDeviceAccessOverrideInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceId = "DeviceId"
        case organizationId = "OrganizationId"
        case userId = "UserId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceId = self.deviceId {
            try encodeContainer.encode(deviceId, forKey: .deviceId)
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
        if let userId = self.userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
    }
}

extension GetMobileDeviceAccessOverrideInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetMobileDeviceAccessOverrideInput: Swift.Equatable {
    /// The mobile device to which the override applies. DeviceId is case insensitive.
    /// This member is required.
    public var deviceId: Swift.String?
    /// The WorkMail organization to which you want to apply the override.
    /// This member is required.
    public var organizationId: Swift.String?
    /// Identifies the WorkMail user for the override. Accepts the following types of user identities:
    ///
    /// * User ID: 12345678-1234-1234-1234-123456789012 or S-1-1-12-1234567890-123456789-123456789-1234
    ///
    /// * Email address: user@domain.tld
    ///
    /// * User name: user
    /// This member is required.
    public var userId: Swift.String?

    public init (
        deviceId: Swift.String? = nil,
        organizationId: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.deviceId = deviceId
        self.organizationId = organizationId
        self.userId = userId
    }
}

struct GetMobileDeviceAccessOverrideInputBody: Swift.Equatable {
    let organizationId: Swift.String?
    let userId: Swift.String?
    let deviceId: Swift.String?
}

extension GetMobileDeviceAccessOverrideInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceId = "DeviceId"
        case organizationId = "OrganizationId"
        case userId = "UserId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
        let deviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceId)
        deviceId = deviceIdDecoded
    }
}

extension GetMobileDeviceAccessOverrideOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetMobileDeviceAccessOverrideOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetMobileDeviceAccessOverrideOutputError: Swift.Error, Swift.Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case invalidParameterException(InvalidParameterException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetMobileDeviceAccessOverrideOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetMobileDeviceAccessOverrideOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dateCreated = output.dateCreated
            self.dateModified = output.dateModified
            self.description = output.description
            self.deviceId = output.deviceId
            self.effect = output.effect
            self.userId = output.userId
        } else {
            self.dateCreated = nil
            self.dateModified = nil
            self.description = nil
            self.deviceId = nil
            self.effect = nil
            self.userId = nil
        }
    }
}

public struct GetMobileDeviceAccessOverrideOutputResponse: Swift.Equatable {
    /// The date the override was first created.
    public var dateCreated: ClientRuntime.Date?
    /// The date the description was last modified.
    public var dateModified: ClientRuntime.Date?
    /// A description of the override.
    public var description: Swift.String?
    /// The device to which the access override applies.
    public var deviceId: Swift.String?
    /// The effect of the override, ALLOW or DENY.
    public var effect: WorkMailClientTypes.MobileDeviceAccessRuleEffect?
    /// The WorkMail user to which the access override applies.
    public var userId: Swift.String?

    public init (
        dateCreated: ClientRuntime.Date? = nil,
        dateModified: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        deviceId: Swift.String? = nil,
        effect: WorkMailClientTypes.MobileDeviceAccessRuleEffect? = nil,
        userId: Swift.String? = nil
    )
    {
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.description = description
        self.deviceId = deviceId
        self.effect = effect
        self.userId = userId
    }
}

struct GetMobileDeviceAccessOverrideOutputResponseBody: Swift.Equatable {
    let userId: Swift.String?
    let deviceId: Swift.String?
    let effect: WorkMailClientTypes.MobileDeviceAccessRuleEffect?
    let description: Swift.String?
    let dateCreated: ClientRuntime.Date?
    let dateModified: ClientRuntime.Date?
}

extension GetMobileDeviceAccessOverrideOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dateCreated = "DateCreated"
        case dateModified = "DateModified"
        case description = "Description"
        case deviceId = "DeviceId"
        case effect = "Effect"
        case userId = "UserId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
        let deviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceId)
        deviceId = deviceIdDecoded
        let effectDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.MobileDeviceAccessRuleEffect.self, forKey: .effect)
        effect = effectDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let dateCreatedDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .dateCreated)
        dateCreated = dateCreatedDecoded
        let dateModifiedDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .dateModified)
        dateModified = dateModifiedDecoded
    }
}

extension WorkMailClientTypes.Group: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case disabledDate = "DisabledDate"
        case email = "Email"
        case enabledDate = "EnabledDate"
        case id = "Id"
        case name = "Name"
        case state = "State"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let disabledDate = self.disabledDate {
            try encodeContainer.encodeTimestamp(disabledDate, format: .epochSeconds, forKey: .disabledDate)
        }
        if let email = self.email {
            try encodeContainer.encode(email, forKey: .email)
        }
        if let enabledDate = self.enabledDate {
            try encodeContainer.encodeTimestamp(enabledDate, format: .epochSeconds, forKey: .enabledDate)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let emailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .email)
        email = emailDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let stateDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.EntityState.self, forKey: .state)
        state = stateDecoded
        let enabledDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .enabledDate)
        enabledDate = enabledDateDecoded
        let disabledDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .disabledDate)
        disabledDate = disabledDateDecoded
    }
}

extension WorkMailClientTypes {
    /// The representation of an WorkMail group.
    public struct Group: Swift.Equatable {
        /// The date indicating when the group was disabled from WorkMail use.
        public var disabledDate: ClientRuntime.Date?
        /// The email of the group.
        public var email: Swift.String?
        /// The date indicating when the group was enabled for WorkMail use.
        public var enabledDate: ClientRuntime.Date?
        /// The identifier of the group.
        public var id: Swift.String?
        /// The name of the group.
        public var name: Swift.String?
        /// The state of the group, which can be ENABLED, DISABLED, or DELETED.
        public var state: WorkMailClientTypes.EntityState?

        public init (
            disabledDate: ClientRuntime.Date? = nil,
            email: Swift.String? = nil,
            enabledDate: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            state: WorkMailClientTypes.EntityState? = nil
        )
        {
            self.disabledDate = disabledDate
            self.email = email
            self.enabledDate = enabledDate
            self.id = id
            self.name = name
            self.state = state
        }
    }

}

extension WorkMailClientTypes.ImpersonationMatchedRule: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case impersonationRuleId = "ImpersonationRuleId"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let impersonationRuleId = self.impersonationRuleId {
            try encodeContainer.encode(impersonationRuleId, forKey: .impersonationRuleId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let impersonationRuleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .impersonationRuleId)
        impersonationRuleId = impersonationRuleIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension WorkMailClientTypes {
    /// The impersonation rule that matched the input.
    public struct ImpersonationMatchedRule: Swift.Equatable {
        /// The ID of the rule that matched the input
        public var impersonationRuleId: Swift.String?
        /// The name of the rule that matched the input.
        public var name: Swift.String?

        public init (
            impersonationRuleId: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.impersonationRuleId = impersonationRuleId
            self.name = name
        }
    }

}

extension WorkMailClientTypes.ImpersonationRole: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dateCreated = "DateCreated"
        case dateModified = "DateModified"
        case impersonationRoleId = "ImpersonationRoleId"
        case name = "Name"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dateCreated = self.dateCreated {
            try encodeContainer.encodeTimestamp(dateCreated, format: .epochSeconds, forKey: .dateCreated)
        }
        if let dateModified = self.dateModified {
            try encodeContainer.encodeTimestamp(dateModified, format: .epochSeconds, forKey: .dateModified)
        }
        if let impersonationRoleId = self.impersonationRoleId {
            try encodeContainer.encode(impersonationRoleId, forKey: .impersonationRoleId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let impersonationRoleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .impersonationRoleId)
        impersonationRoleId = impersonationRoleIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.ImpersonationRoleType.self, forKey: .type)
        type = typeDecoded
        let dateCreatedDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .dateCreated)
        dateCreated = dateCreatedDecoded
        let dateModifiedDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .dateModified)
        dateModified = dateModifiedDecoded
    }
}

extension WorkMailClientTypes {
    /// An impersonation role for the given WorkMail organization.
    public struct ImpersonationRole: Swift.Equatable {
        /// The date when the impersonation role was created.
        public var dateCreated: ClientRuntime.Date?
        /// The date when the impersonation role was last modified.
        public var dateModified: ClientRuntime.Date?
        /// The identifier of the impersonation role.
        public var impersonationRoleId: Swift.String?
        /// The impersonation role name.
        public var name: Swift.String?
        /// The impersonation role type.
        public var type: WorkMailClientTypes.ImpersonationRoleType?

        public init (
            dateCreated: ClientRuntime.Date? = nil,
            dateModified: ClientRuntime.Date? = nil,
            impersonationRoleId: Swift.String? = nil,
            name: Swift.String? = nil,
            type: WorkMailClientTypes.ImpersonationRoleType? = nil
        )
        {
            self.dateCreated = dateCreated
            self.dateModified = dateModified
            self.impersonationRoleId = impersonationRoleId
            self.name = name
            self.type = type
        }
    }

}

extension WorkMailClientTypes {
    public enum ImpersonationRoleType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case fullAccess
        case readOnly
        case sdkUnknown(Swift.String)

        public static var allCases: [ImpersonationRoleType] {
            return [
                .fullAccess,
                .readOnly,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .fullAccess: return "FULL_ACCESS"
            case .readOnly: return "READ_ONLY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ImpersonationRoleType(rawValue: rawValue) ?? ImpersonationRoleType.sdkUnknown(rawValue)
        }
    }
}

extension WorkMailClientTypes.ImpersonationRule: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case effect = "Effect"
        case impersonationRuleId = "ImpersonationRuleId"
        case name = "Name"
        case notTargetUsers = "NotTargetUsers"
        case targetUsers = "TargetUsers"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let effect = self.effect {
            try encodeContainer.encode(effect.rawValue, forKey: .effect)
        }
        if let impersonationRuleId = self.impersonationRuleId {
            try encodeContainer.encode(impersonationRuleId, forKey: .impersonationRuleId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let notTargetUsers = notTargetUsers {
            var notTargetUsersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notTargetUsers)
            for entityidentifier0 in notTargetUsers {
                try notTargetUsersContainer.encode(entityidentifier0)
            }
        }
        if let targetUsers = targetUsers {
            var targetUsersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetUsers)
            for entityidentifier0 in targetUsers {
                try targetUsersContainer.encode(entityidentifier0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let impersonationRuleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .impersonationRuleId)
        impersonationRuleId = impersonationRuleIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let effectDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.AccessEffect.self, forKey: .effect)
        effect = effectDecoded
        let targetUsersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .targetUsers)
        var targetUsersDecoded0:[Swift.String]? = nil
        if let targetUsersContainer = targetUsersContainer {
            targetUsersDecoded0 = [Swift.String]()
            for string0 in targetUsersContainer {
                if let string0 = string0 {
                    targetUsersDecoded0?.append(string0)
                }
            }
        }
        targetUsers = targetUsersDecoded0
        let notTargetUsersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .notTargetUsers)
        var notTargetUsersDecoded0:[Swift.String]? = nil
        if let notTargetUsersContainer = notTargetUsersContainer {
            notTargetUsersDecoded0 = [Swift.String]()
            for string0 in notTargetUsersContainer {
                if let string0 = string0 {
                    notTargetUsersDecoded0?.append(string0)
                }
            }
        }
        notTargetUsers = notTargetUsersDecoded0
    }
}

extension WorkMailClientTypes {
    /// The rules for the given impersonation role.
    public struct ImpersonationRule: Swift.Equatable {
        /// The rule description.
        public var description: Swift.String?
        /// The effect of the rule when it matches the input. Allowed effect values are ALLOW or DENY.
        /// This member is required.
        public var effect: WorkMailClientTypes.AccessEffect?
        /// The identifier of the rule.
        /// This member is required.
        public var impersonationRuleId: Swift.String?
        /// The rule name.
        public var name: Swift.String?
        /// A list of user IDs that don't match the rule.
        public var notTargetUsers: [Swift.String]?
        /// A list of user IDs that match the rule.
        public var targetUsers: [Swift.String]?

        public init (
            description: Swift.String? = nil,
            effect: WorkMailClientTypes.AccessEffect? = nil,
            impersonationRuleId: Swift.String? = nil,
            name: Swift.String? = nil,
            notTargetUsers: [Swift.String]? = nil,
            targetUsers: [Swift.String]? = nil
        )
        {
            self.description = description
            self.effect = effect
            self.impersonationRuleId = impersonationRuleId
            self.name = name
            self.notTargetUsers = notTargetUsers
            self.targetUsers = targetUsers
        }
    }

}

extension InvalidConfigurationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidConfigurationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The configuration for a resource isn't valid. A resource must either be able to auto-respond to requests or have at least one delegate associated that can do so on its behalf.
public struct InvalidConfigurationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidConfigurationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidConfigurationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidCustomSesConfigurationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidCustomSesConfigurationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You SES configuration has customizations that WorkMail cannot save. The error message lists the invalid setting. For examples of invalid settings, refer to [CreateReceiptRule](https://docs.aws.amazon.com/ses/latest/APIReference/API_CreateReceiptRule.html).
public struct InvalidCustomSesConfigurationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidCustomSesConfigurationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidCustomSesConfigurationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidParameterException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidParameterExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// One or more of the input parameters don't match the service's restrictions.
public struct InvalidParameterException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidParameterExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidParameterExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidPasswordException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidPasswordExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The supplied password doesn't match the minimum security constraints, such as length or use of special characters.
public struct InvalidPasswordException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidPasswordExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidPasswordExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension WorkMailClientTypes.LambdaAvailabilityProvider: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lambdaArn = "LambdaArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lambdaArn = self.lambdaArn {
            try encodeContainer.encode(lambdaArn, forKey: .lambdaArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lambdaArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lambdaArn)
        lambdaArn = lambdaArnDecoded
    }
}

extension WorkMailClientTypes {
    /// Describes a Lambda based availability provider.
    public struct LambdaAvailabilityProvider: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the Lambda that acts as the availability provider.
        /// This member is required.
        public var lambdaArn: Swift.String?

        public init (
            lambdaArn: Swift.String? = nil
        )
        {
            self.lambdaArn = lambdaArn
        }
    }

}

extension LimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request exceeds the limit of the resource.
public struct LimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListAccessControlRulesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

extension ListAccessControlRulesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListAccessControlRulesInput: Swift.Equatable {
    /// The identifier for the organization.
    /// This member is required.
    public var organizationId: Swift.String?

    public init (
        organizationId: Swift.String? = nil
    )
    {
        self.organizationId = organizationId
    }
}

struct ListAccessControlRulesInputBody: Swift.Equatable {
    let organizationId: Swift.String?
}

extension ListAccessControlRulesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case organizationId = "OrganizationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
    }
}

extension ListAccessControlRulesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAccessControlRulesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListAccessControlRulesOutputError: Swift.Error, Swift.Equatable {
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAccessControlRulesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListAccessControlRulesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.rules = output.rules
        } else {
            self.rules = nil
        }
    }
}

public struct ListAccessControlRulesOutputResponse: Swift.Equatable {
    /// The access control rules.
    public var rules: [WorkMailClientTypes.AccessControlRule]?

    public init (
        rules: [WorkMailClientTypes.AccessControlRule]? = nil
    )
    {
        self.rules = rules
    }
}

struct ListAccessControlRulesOutputResponseBody: Swift.Equatable {
    let rules: [WorkMailClientTypes.AccessControlRule]?
}

extension ListAccessControlRulesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case rules = "Rules"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rulesContainer = try containerValues.decodeIfPresent([WorkMailClientTypes.AccessControlRule?].self, forKey: .rules)
        var rulesDecoded0:[WorkMailClientTypes.AccessControlRule]? = nil
        if let rulesContainer = rulesContainer {
            rulesDecoded0 = [WorkMailClientTypes.AccessControlRule]()
            for structure0 in rulesContainer {
                if let structure0 = structure0 {
                    rulesDecoded0?.append(structure0)
                }
            }
        }
        rules = rulesDecoded0
    }
}

extension ListAliasesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entityId = "EntityId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entityId = self.entityId {
            try encodeContainer.encode(entityId, forKey: .entityId)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

extension ListAliasesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListAliasesInput: Swift.Equatable {
    /// The identifier for the entity for which to list the aliases.
    /// This member is required.
    public var entityId: Swift.String?
    /// The maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// The token to use to retrieve the next page of results. The first call does not contain any tokens.
    public var nextToken: Swift.String?
    /// The identifier for the organization under which the entity exists.
    /// This member is required.
    public var organizationId: Swift.String?

    public init (
        entityId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.entityId = entityId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.organizationId = organizationId
    }
}

struct ListAliasesInputBody: Swift.Equatable {
    let organizationId: Swift.String?
    let entityId: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListAliasesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entityId = "EntityId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case organizationId = "OrganizationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let entityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityId)
        entityId = entityIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListAliasesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAliasesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityStateException" : self = .entityStateException(try EntityStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListAliasesOutputError: Swift.Error, Swift.Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case entityStateException(EntityStateException)
    case invalidParameterException(InvalidParameterException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAliasesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListAliasesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.aliases = output.aliases
            self.nextToken = output.nextToken
        } else {
            self.aliases = nil
            self.nextToken = nil
        }
    }
}

public struct ListAliasesOutputResponse: Swift.Equatable {
    /// The entity's paginated aliases.
    public var aliases: [Swift.String]?
    /// The token to use to retrieve the next page of results. The value is "null" when there are no more results to return.
    public var nextToken: Swift.String?

    public init (
        aliases: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.aliases = aliases
        self.nextToken = nextToken
    }
}

struct ListAliasesOutputResponseBody: Swift.Equatable {
    let aliases: [Swift.String]?
    let nextToken: Swift.String?
}

extension ListAliasesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aliases = "Aliases"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aliasesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .aliases)
        var aliasesDecoded0:[Swift.String]? = nil
        if let aliasesContainer = aliasesContainer {
            aliasesDecoded0 = [Swift.String]()
            for string0 in aliasesContainer {
                if let string0 = string0 {
                    aliasesDecoded0?.append(string0)
                }
            }
        }
        aliases = aliasesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAvailabilityConfigurationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

extension ListAvailabilityConfigurationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListAvailabilityConfigurationsInput: Swift.Equatable {
    /// The maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// The token to use to retrieve the next page of results. The first call does not require a token.
    public var nextToken: Swift.String?
    /// The WorkMail organization for which the AvailabilityConfiguration's will be listed.
    /// This member is required.
    public var organizationId: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.organizationId = organizationId
    }
}

struct ListAvailabilityConfigurationsInputBody: Swift.Equatable {
    let organizationId: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListAvailabilityConfigurationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case organizationId = "OrganizationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAvailabilityConfigurationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAvailabilityConfigurationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListAvailabilityConfigurationsOutputError: Swift.Error, Swift.Equatable {
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAvailabilityConfigurationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListAvailabilityConfigurationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.availabilityConfigurations = output.availabilityConfigurations
            self.nextToken = output.nextToken
        } else {
            self.availabilityConfigurations = nil
            self.nextToken = nil
        }
    }
}

public struct ListAvailabilityConfigurationsOutputResponse: Swift.Equatable {
    /// The list of AvailabilityConfiguration's that exist for the specified WorkMail organization.
    public var availabilityConfigurations: [WorkMailClientTypes.AvailabilityConfiguration]?
    /// The token to use to retrieve the next page of results. The value is null when there are no further results to return.
    public var nextToken: Swift.String?

    public init (
        availabilityConfigurations: [WorkMailClientTypes.AvailabilityConfiguration]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.availabilityConfigurations = availabilityConfigurations
        self.nextToken = nextToken
    }
}

struct ListAvailabilityConfigurationsOutputResponseBody: Swift.Equatable {
    let availabilityConfigurations: [WorkMailClientTypes.AvailabilityConfiguration]?
    let nextToken: Swift.String?
}

extension ListAvailabilityConfigurationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityConfigurations = "AvailabilityConfigurations"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let availabilityConfigurationsContainer = try containerValues.decodeIfPresent([WorkMailClientTypes.AvailabilityConfiguration?].self, forKey: .availabilityConfigurations)
        var availabilityConfigurationsDecoded0:[WorkMailClientTypes.AvailabilityConfiguration]? = nil
        if let availabilityConfigurationsContainer = availabilityConfigurationsContainer {
            availabilityConfigurationsDecoded0 = [WorkMailClientTypes.AvailabilityConfiguration]()
            for structure0 in availabilityConfigurationsContainer {
                if let structure0 = structure0 {
                    availabilityConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        availabilityConfigurations = availabilityConfigurationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListGroupMembersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupId = "GroupId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupId = self.groupId {
            try encodeContainer.encode(groupId, forKey: .groupId)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

extension ListGroupMembersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListGroupMembersInput: Swift.Equatable {
    /// The identifier for the group to which the members (users or groups) are associated.
    /// This member is required.
    public var groupId: Swift.String?
    /// The maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// The token to use to retrieve the next page of results. The first call does not contain any tokens.
    public var nextToken: Swift.String?
    /// The identifier for the organization under which the group exists.
    /// This member is required.
    public var organizationId: Swift.String?

    public init (
        groupId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.groupId = groupId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.organizationId = organizationId
    }
}

struct ListGroupMembersInputBody: Swift.Equatable {
    let organizationId: Swift.String?
    let groupId: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListGroupMembersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupId = "GroupId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case organizationId = "OrganizationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let groupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupId)
        groupId = groupIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListGroupMembersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListGroupMembersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityStateException" : self = .entityStateException(try EntityStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListGroupMembersOutputError: Swift.Error, Swift.Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case entityStateException(EntityStateException)
    case invalidParameterException(InvalidParameterException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListGroupMembersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListGroupMembersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.members = output.members
            self.nextToken = output.nextToken
        } else {
            self.members = nil
            self.nextToken = nil
        }
    }
}

public struct ListGroupMembersOutputResponse: Swift.Equatable {
    /// The members associated to the group.
    public var members: [WorkMailClientTypes.Member]?
    /// The token to use to retrieve the next page of results. The first call does not contain any tokens.
    public var nextToken: Swift.String?

    public init (
        members: [WorkMailClientTypes.Member]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.members = members
        self.nextToken = nextToken
    }
}

struct ListGroupMembersOutputResponseBody: Swift.Equatable {
    let members: [WorkMailClientTypes.Member]?
    let nextToken: Swift.String?
}

extension ListGroupMembersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case members = "Members"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let membersContainer = try containerValues.decodeIfPresent([WorkMailClientTypes.Member?].self, forKey: .members)
        var membersDecoded0:[WorkMailClientTypes.Member]? = nil
        if let membersContainer = membersContainer {
            membersDecoded0 = [WorkMailClientTypes.Member]()
            for structure0 in membersContainer {
                if let structure0 = structure0 {
                    membersDecoded0?.append(structure0)
                }
            }
        }
        members = membersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListGroupsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

extension ListGroupsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListGroupsInput: Swift.Equatable {
    /// The maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// The token to use to retrieve the next page of results. The first call does not contain any tokens.
    public var nextToken: Swift.String?
    /// The identifier for the organization under which the groups exist.
    /// This member is required.
    public var organizationId: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.organizationId = organizationId
    }
}

struct ListGroupsInputBody: Swift.Equatable {
    let organizationId: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListGroupsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case organizationId = "OrganizationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListGroupsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListGroupsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListGroupsOutputError: Swift.Error, Swift.Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case invalidParameterException(InvalidParameterException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListGroupsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListGroupsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.groups = output.groups
            self.nextToken = output.nextToken
        } else {
            self.groups = nil
            self.nextToken = nil
        }
    }
}

public struct ListGroupsOutputResponse: Swift.Equatable {
    /// The overview of groups for an organization.
    public var groups: [WorkMailClientTypes.Group]?
    /// The token to use to retrieve the next page of results. The value is "null" when there are no more results to return.
    public var nextToken: Swift.String?

    public init (
        groups: [WorkMailClientTypes.Group]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.groups = groups
        self.nextToken = nextToken
    }
}

struct ListGroupsOutputResponseBody: Swift.Equatable {
    let groups: [WorkMailClientTypes.Group]?
    let nextToken: Swift.String?
}

extension ListGroupsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groups = "Groups"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupsContainer = try containerValues.decodeIfPresent([WorkMailClientTypes.Group?].self, forKey: .groups)
        var groupsDecoded0:[WorkMailClientTypes.Group]? = nil
        if let groupsContainer = groupsContainer {
            groupsDecoded0 = [WorkMailClientTypes.Group]()
            for structure0 in groupsContainer {
                if let structure0 = structure0 {
                    groupsDecoded0?.append(structure0)
                }
            }
        }
        groups = groupsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListImpersonationRolesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

extension ListImpersonationRolesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListImpersonationRolesInput: Swift.Equatable {
    /// The maximum number of results returned in a single call.
    public var maxResults: Swift.Int?
    /// The token used to retrieve the next page of results. The first call doesn't require a token.
    public var nextToken: Swift.String?
    /// The WorkMail organization to which the listed impersonation roles belong.
    /// This member is required.
    public var organizationId: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.organizationId = organizationId
    }
}

struct ListImpersonationRolesInputBody: Swift.Equatable {
    let organizationId: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListImpersonationRolesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case organizationId = "OrganizationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListImpersonationRolesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListImpersonationRolesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListImpersonationRolesOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterException(InvalidParameterException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListImpersonationRolesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListImpersonationRolesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.roles = output.roles
        } else {
            self.nextToken = nil
            self.roles = nil
        }
    }
}

public struct ListImpersonationRolesOutputResponse: Swift.Equatable {
    /// The token to retrieve the next page of results. The value is null when there are no results to return.
    public var nextToken: Swift.String?
    /// The list of impersonation roles under the given WorkMail organization.
    public var roles: [WorkMailClientTypes.ImpersonationRole]?

    public init (
        nextToken: Swift.String? = nil,
        roles: [WorkMailClientTypes.ImpersonationRole]? = nil
    )
    {
        self.nextToken = nextToken
        self.roles = roles
    }
}

struct ListImpersonationRolesOutputResponseBody: Swift.Equatable {
    let roles: [WorkMailClientTypes.ImpersonationRole]?
    let nextToken: Swift.String?
}

extension ListImpersonationRolesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case roles = "Roles"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rolesContainer = try containerValues.decodeIfPresent([WorkMailClientTypes.ImpersonationRole?].self, forKey: .roles)
        var rolesDecoded0:[WorkMailClientTypes.ImpersonationRole]? = nil
        if let rolesContainer = rolesContainer {
            rolesDecoded0 = [WorkMailClientTypes.ImpersonationRole]()
            for structure0 in rolesContainer {
                if let structure0 = structure0 {
                    rolesDecoded0?.append(structure0)
                }
            }
        }
        roles = rolesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListMailDomainsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

extension ListMailDomainsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListMailDomainsInput: Swift.Equatable {
    /// The maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// The token to use to retrieve the next page of results. The first call does not require a token.
    public var nextToken: Swift.String?
    /// The WorkMail organization for which to list domains.
    /// This member is required.
    public var organizationId: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.organizationId = organizationId
    }
}

struct ListMailDomainsInputBody: Swift.Equatable {
    let organizationId: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListMailDomainsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case organizationId = "OrganizationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListMailDomainsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListMailDomainsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListMailDomainsOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterException(InvalidParameterException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListMailDomainsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListMailDomainsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.mailDomains = output.mailDomains
            self.nextToken = output.nextToken
        } else {
            self.mailDomains = nil
            self.nextToken = nil
        }
    }
}

public struct ListMailDomainsOutputResponse: Swift.Equatable {
    /// The list of mail domain summaries, specifying domains that exist in the specified WorkMail organization, along with the information about whether the domain is or isn't the default.
    public var mailDomains: [WorkMailClientTypes.MailDomainSummary]?
    /// The token to use to retrieve the next page of results. The value becomes null when there are no more results to return.
    public var nextToken: Swift.String?

    public init (
        mailDomains: [WorkMailClientTypes.MailDomainSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.mailDomains = mailDomains
        self.nextToken = nextToken
    }
}

struct ListMailDomainsOutputResponseBody: Swift.Equatable {
    let mailDomains: [WorkMailClientTypes.MailDomainSummary]?
    let nextToken: Swift.String?
}

extension ListMailDomainsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mailDomains = "MailDomains"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mailDomainsContainer = try containerValues.decodeIfPresent([WorkMailClientTypes.MailDomainSummary?].self, forKey: .mailDomains)
        var mailDomainsDecoded0:[WorkMailClientTypes.MailDomainSummary]? = nil
        if let mailDomainsContainer = mailDomainsContainer {
            mailDomainsDecoded0 = [WorkMailClientTypes.MailDomainSummary]()
            for structure0 in mailDomainsContainer {
                if let structure0 = structure0 {
                    mailDomainsDecoded0?.append(structure0)
                }
            }
        }
        mailDomains = mailDomainsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListMailboxExportJobsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

extension ListMailboxExportJobsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListMailboxExportJobsInput: Swift.Equatable {
    /// The maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// The token to use to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// The organization ID.
    /// This member is required.
    public var organizationId: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.organizationId = organizationId
    }
}

struct ListMailboxExportJobsInputBody: Swift.Equatable {
    let organizationId: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListMailboxExportJobsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case organizationId = "OrganizationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListMailboxExportJobsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListMailboxExportJobsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListMailboxExportJobsOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterException(InvalidParameterException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListMailboxExportJobsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListMailboxExportJobsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.jobs = output.jobs
            self.nextToken = output.nextToken
        } else {
            self.jobs = nil
            self.nextToken = nil
        }
    }
}

public struct ListMailboxExportJobsOutputResponse: Swift.Equatable {
    /// The mailbox export job details.
    public var jobs: [WorkMailClientTypes.MailboxExportJob]?
    /// The token to use to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init (
        jobs: [WorkMailClientTypes.MailboxExportJob]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.jobs = jobs
        self.nextToken = nextToken
    }
}

struct ListMailboxExportJobsOutputResponseBody: Swift.Equatable {
    let jobs: [WorkMailClientTypes.MailboxExportJob]?
    let nextToken: Swift.String?
}

extension ListMailboxExportJobsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobs = "Jobs"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobsContainer = try containerValues.decodeIfPresent([WorkMailClientTypes.MailboxExportJob?].self, forKey: .jobs)
        var jobsDecoded0:[WorkMailClientTypes.MailboxExportJob]? = nil
        if let jobsContainer = jobsContainer {
            jobsDecoded0 = [WorkMailClientTypes.MailboxExportJob]()
            for structure0 in jobsContainer {
                if let structure0 = structure0 {
                    jobsDecoded0?.append(structure0)
                }
            }
        }
        jobs = jobsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListMailboxPermissionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entityId = "EntityId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entityId = self.entityId {
            try encodeContainer.encode(entityId, forKey: .entityId)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

extension ListMailboxPermissionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListMailboxPermissionsInput: Swift.Equatable {
    /// The identifier of the user, group, or resource for which to list mailbox permissions.
    /// This member is required.
    public var entityId: Swift.String?
    /// The maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// The token to use to retrieve the next page of results. The first call does not contain any tokens.
    public var nextToken: Swift.String?
    /// The identifier of the organization under which the user, group, or resource exists.
    /// This member is required.
    public var organizationId: Swift.String?

    public init (
        entityId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.entityId = entityId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.organizationId = organizationId
    }
}

struct ListMailboxPermissionsInputBody: Swift.Equatable {
    let organizationId: Swift.String?
    let entityId: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListMailboxPermissionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entityId = "EntityId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case organizationId = "OrganizationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let entityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityId)
        entityId = entityIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListMailboxPermissionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListMailboxPermissionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListMailboxPermissionsOutputError: Swift.Error, Swift.Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case invalidParameterException(InvalidParameterException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListMailboxPermissionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListMailboxPermissionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.permissions = output.permissions
        } else {
            self.nextToken = nil
            self.permissions = nil
        }
    }
}

public struct ListMailboxPermissionsOutputResponse: Swift.Equatable {
    /// The token to use to retrieve the next page of results. The value is "null" when there are no more results to return.
    public var nextToken: Swift.String?
    /// One page of the user, group, or resource mailbox permissions.
    public var permissions: [WorkMailClientTypes.Permission]?

    public init (
        nextToken: Swift.String? = nil,
        permissions: [WorkMailClientTypes.Permission]? = nil
    )
    {
        self.nextToken = nextToken
        self.permissions = permissions
    }
}

struct ListMailboxPermissionsOutputResponseBody: Swift.Equatable {
    let permissions: [WorkMailClientTypes.Permission]?
    let nextToken: Swift.String?
}

extension ListMailboxPermissionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case permissions = "Permissions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let permissionsContainer = try containerValues.decodeIfPresent([WorkMailClientTypes.Permission?].self, forKey: .permissions)
        var permissionsDecoded0:[WorkMailClientTypes.Permission]? = nil
        if let permissionsContainer = permissionsContainer {
            permissionsDecoded0 = [WorkMailClientTypes.Permission]()
            for structure0 in permissionsContainer {
                if let structure0 = structure0 {
                    permissionsDecoded0?.append(structure0)
                }
            }
        }
        permissions = permissionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListMobileDeviceAccessOverridesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceId = "DeviceId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case organizationId = "OrganizationId"
        case userId = "UserId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceId = self.deviceId {
            try encodeContainer.encode(deviceId, forKey: .deviceId)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
        if let userId = self.userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
    }
}

extension ListMobileDeviceAccessOverridesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListMobileDeviceAccessOverridesInput: Swift.Equatable {
    /// The mobile device to which the access override applies.
    public var deviceId: Swift.String?
    /// The maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// The token to use to retrieve the next page of results. The first call does not require a token.
    public var nextToken: Swift.String?
    /// The WorkMail organization under which to list mobile device access overrides.
    /// This member is required.
    public var organizationId: Swift.String?
    /// The WorkMail user under which you list the mobile device access overrides. Accepts the following types of user identities:
    ///
    /// * User ID: 12345678-1234-1234-1234-123456789012 or S-1-1-12-1234567890-123456789-123456789-1234
    ///
    /// * Email address: user@domain.tld
    ///
    /// * User name: user
    public var userId: Swift.String?

    public init (
        deviceId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        organizationId: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.deviceId = deviceId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.organizationId = organizationId
        self.userId = userId
    }
}

struct ListMobileDeviceAccessOverridesInputBody: Swift.Equatable {
    let organizationId: Swift.String?
    let userId: Swift.String?
    let deviceId: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListMobileDeviceAccessOverridesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceId = "DeviceId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case organizationId = "OrganizationId"
        case userId = "UserId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
        let deviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceId)
        deviceId = deviceIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListMobileDeviceAccessOverridesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListMobileDeviceAccessOverridesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListMobileDeviceAccessOverridesOutputError: Swift.Error, Swift.Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case invalidParameterException(InvalidParameterException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListMobileDeviceAccessOverridesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListMobileDeviceAccessOverridesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.overrides = output.overrides
        } else {
            self.nextToken = nil
            self.overrides = nil
        }
    }
}

public struct ListMobileDeviceAccessOverridesOutputResponse: Swift.Equatable {
    /// The token to use to retrieve the next page of results. The value is “null” when there are no more results to return.
    public var nextToken: Swift.String?
    /// The list of mobile device access overrides that exist for the specified WorkMail organization and user.
    public var overrides: [WorkMailClientTypes.MobileDeviceAccessOverride]?

    public init (
        nextToken: Swift.String? = nil,
        overrides: [WorkMailClientTypes.MobileDeviceAccessOverride]? = nil
    )
    {
        self.nextToken = nextToken
        self.overrides = overrides
    }
}

struct ListMobileDeviceAccessOverridesOutputResponseBody: Swift.Equatable {
    let overrides: [WorkMailClientTypes.MobileDeviceAccessOverride]?
    let nextToken: Swift.String?
}

extension ListMobileDeviceAccessOverridesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case overrides = "Overrides"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let overridesContainer = try containerValues.decodeIfPresent([WorkMailClientTypes.MobileDeviceAccessOverride?].self, forKey: .overrides)
        var overridesDecoded0:[WorkMailClientTypes.MobileDeviceAccessOverride]? = nil
        if let overridesContainer = overridesContainer {
            overridesDecoded0 = [WorkMailClientTypes.MobileDeviceAccessOverride]()
            for structure0 in overridesContainer {
                if let structure0 = structure0 {
                    overridesDecoded0?.append(structure0)
                }
            }
        }
        overrides = overridesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListMobileDeviceAccessRulesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

extension ListMobileDeviceAccessRulesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListMobileDeviceAccessRulesInput: Swift.Equatable {
    /// The WorkMail organization for which to list the rules.
    /// This member is required.
    public var organizationId: Swift.String?

    public init (
        organizationId: Swift.String? = nil
    )
    {
        self.organizationId = organizationId
    }
}

struct ListMobileDeviceAccessRulesInputBody: Swift.Equatable {
    let organizationId: Swift.String?
}

extension ListMobileDeviceAccessRulesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case organizationId = "OrganizationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
    }
}

extension ListMobileDeviceAccessRulesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListMobileDeviceAccessRulesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListMobileDeviceAccessRulesOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterException(InvalidParameterException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListMobileDeviceAccessRulesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListMobileDeviceAccessRulesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.rules = output.rules
        } else {
            self.rules = nil
        }
    }
}

public struct ListMobileDeviceAccessRulesOutputResponse: Swift.Equatable {
    /// The list of mobile device access rules that exist under the specified WorkMail organization.
    public var rules: [WorkMailClientTypes.MobileDeviceAccessRule]?

    public init (
        rules: [WorkMailClientTypes.MobileDeviceAccessRule]? = nil
    )
    {
        self.rules = rules
    }
}

struct ListMobileDeviceAccessRulesOutputResponseBody: Swift.Equatable {
    let rules: [WorkMailClientTypes.MobileDeviceAccessRule]?
}

extension ListMobileDeviceAccessRulesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case rules = "Rules"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rulesContainer = try containerValues.decodeIfPresent([WorkMailClientTypes.MobileDeviceAccessRule?].self, forKey: .rules)
        var rulesDecoded0:[WorkMailClientTypes.MobileDeviceAccessRule]? = nil
        if let rulesContainer = rulesContainer {
            rulesDecoded0 = [WorkMailClientTypes.MobileDeviceAccessRule]()
            for structure0 in rulesContainer {
                if let structure0 = structure0 {
                    rulesDecoded0?.append(structure0)
                }
            }
        }
        rules = rulesDecoded0
    }
}

extension ListOrganizationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListOrganizationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListOrganizationsInput: Swift.Equatable {
    /// The maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// The token to use to retrieve the next page of results. The first call does not contain any tokens.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListOrganizationsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListOrganizationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListOrganizationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListOrganizationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListOrganizationsOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterException(InvalidParameterException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListOrganizationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListOrganizationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.organizationSummaries = output.organizationSummaries
        } else {
            self.nextToken = nil
            self.organizationSummaries = nil
        }
    }
}

public struct ListOrganizationsOutputResponse: Swift.Equatable {
    /// The token to use to retrieve the next page of results. The value is "null" when there are no more results to return.
    public var nextToken: Swift.String?
    /// The overview of owned organizations presented as a list of organization summaries.
    public var organizationSummaries: [WorkMailClientTypes.OrganizationSummary]?

    public init (
        nextToken: Swift.String? = nil,
        organizationSummaries: [WorkMailClientTypes.OrganizationSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.organizationSummaries = organizationSummaries
    }
}

struct ListOrganizationsOutputResponseBody: Swift.Equatable {
    let organizationSummaries: [WorkMailClientTypes.OrganizationSummary]?
    let nextToken: Swift.String?
}

extension ListOrganizationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case organizationSummaries = "OrganizationSummaries"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationSummariesContainer = try containerValues.decodeIfPresent([WorkMailClientTypes.OrganizationSummary?].self, forKey: .organizationSummaries)
        var organizationSummariesDecoded0:[WorkMailClientTypes.OrganizationSummary]? = nil
        if let organizationSummariesContainer = organizationSummariesContainer {
            organizationSummariesDecoded0 = [WorkMailClientTypes.OrganizationSummary]()
            for structure0 in organizationSummariesContainer {
                if let structure0 = structure0 {
                    organizationSummariesDecoded0?.append(structure0)
                }
            }
        }
        organizationSummaries = organizationSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListResourceDelegatesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case organizationId = "OrganizationId"
        case resourceId = "ResourceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
    }
}

extension ListResourceDelegatesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListResourceDelegatesInput: Swift.Equatable {
    /// The number of maximum results in a page.
    public var maxResults: Swift.Int?
    /// The token used to paginate through the delegates associated with a resource.
    public var nextToken: Swift.String?
    /// The identifier for the organization that contains the resource for which delegates are listed.
    /// This member is required.
    public var organizationId: Swift.String?
    /// The identifier for the resource whose delegates are listed.
    /// This member is required.
    public var resourceId: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        organizationId: Swift.String? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.organizationId = organizationId
        self.resourceId = resourceId
    }
}

struct ListResourceDelegatesInputBody: Swift.Equatable {
    let organizationId: Swift.String?
    let resourceId: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListResourceDelegatesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case organizationId = "OrganizationId"
        case resourceId = "ResourceId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListResourceDelegatesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListResourceDelegatesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityStateException" : self = .entityStateException(try EntityStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListResourceDelegatesOutputError: Swift.Error, Swift.Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case entityStateException(EntityStateException)
    case invalidParameterException(InvalidParameterException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListResourceDelegatesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListResourceDelegatesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.delegates = output.delegates
            self.nextToken = output.nextToken
        } else {
            self.delegates = nil
            self.nextToken = nil
        }
    }
}

public struct ListResourceDelegatesOutputResponse: Swift.Equatable {
    /// One page of the resource's delegates.
    public var delegates: [WorkMailClientTypes.Delegate]?
    /// The token used to paginate through the delegates associated with a resource. While results are still available, it has an associated value. When the last page is reached, the token is empty.
    public var nextToken: Swift.String?

    public init (
        delegates: [WorkMailClientTypes.Delegate]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.delegates = delegates
        self.nextToken = nextToken
    }
}

struct ListResourceDelegatesOutputResponseBody: Swift.Equatable {
    let delegates: [WorkMailClientTypes.Delegate]?
    let nextToken: Swift.String?
}

extension ListResourceDelegatesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case delegates = "Delegates"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let delegatesContainer = try containerValues.decodeIfPresent([WorkMailClientTypes.Delegate?].self, forKey: .delegates)
        var delegatesDecoded0:[WorkMailClientTypes.Delegate]? = nil
        if let delegatesContainer = delegatesContainer {
            delegatesDecoded0 = [WorkMailClientTypes.Delegate]()
            for structure0 in delegatesContainer {
                if let structure0 = structure0 {
                    delegatesDecoded0?.append(structure0)
                }
            }
        }
        delegates = delegatesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListResourcesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

extension ListResourcesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListResourcesInput: Swift.Equatable {
    /// The maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// The token to use to retrieve the next page of results. The first call does not contain any tokens.
    public var nextToken: Swift.String?
    /// The identifier for the organization under which the resources exist.
    /// This member is required.
    public var organizationId: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.organizationId = organizationId
    }
}

struct ListResourcesInputBody: Swift.Equatable {
    let organizationId: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListResourcesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case organizationId = "OrganizationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListResourcesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListResourcesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListResourcesOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterException(InvalidParameterException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListResourcesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListResourcesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.resources = output.resources
        } else {
            self.nextToken = nil
            self.resources = nil
        }
    }
}

public struct ListResourcesOutputResponse: Swift.Equatable {
    /// The token used to paginate through all the organization's resources. While results are still available, it has an associated value. When the last page is reached, the token is empty.
    public var nextToken: Swift.String?
    /// One page of the organization's resource representation.
    public var resources: [WorkMailClientTypes.Resource]?

    public init (
        nextToken: Swift.String? = nil,
        resources: [WorkMailClientTypes.Resource]? = nil
    )
    {
        self.nextToken = nextToken
        self.resources = resources
    }
}

struct ListResourcesOutputResponseBody: Swift.Equatable {
    let resources: [WorkMailClientTypes.Resource]?
    let nextToken: Swift.String?
}

extension ListResourcesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case resources = "Resources"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourcesContainer = try containerValues.decodeIfPresent([WorkMailClientTypes.Resource?].self, forKey: .resources)
        var resourcesDecoded0:[WorkMailClientTypes.Resource]? = nil
        if let resourcesContainer = resourcesContainer {
            resourcesDecoded0 = [WorkMailClientTypes.Resource]()
            for structure0 in resourcesContainer {
                if let structure0 = structure0 {
                    resourcesDecoded0?.append(structure0)
                }
            }
        }
        resources = resourcesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The resource ARN.
    /// This member is required.
    public var resourceARN: Swift.String?

    public init (
        resourceARN: Swift.String? = nil
    )
    {
        self.resourceARN = resourceARN
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
    let resourceARN: Swift.String?
}

extension ListTagsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// A list of tag key-value pairs.
    public var tags: [WorkMailClientTypes.Tag]?

    public init (
        tags: [WorkMailClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let tags: [WorkMailClientTypes.Tag]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([WorkMailClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[WorkMailClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [WorkMailClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ListUsersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

extension ListUsersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListUsersInput: Swift.Equatable {
    /// The maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// The token to use to retrieve the next page of results. The first call does not contain any tokens.
    public var nextToken: Swift.String?
    /// The identifier for the organization under which the users exist.
    /// This member is required.
    public var organizationId: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.organizationId = organizationId
    }
}

struct ListUsersInputBody: Swift.Equatable {
    let organizationId: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListUsersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case organizationId = "OrganizationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListUsersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListUsersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListUsersOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterException(InvalidParameterException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListUsersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListUsersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.users = output.users
        } else {
            self.nextToken = nil
            self.users = nil
        }
    }
}

public struct ListUsersOutputResponse: Swift.Equatable {
    /// The token to use to retrieve the next page of results. This value is `null` when there are no more results to return.
    public var nextToken: Swift.String?
    /// The overview of users for an organization.
    public var users: [WorkMailClientTypes.User]?

    public init (
        nextToken: Swift.String? = nil,
        users: [WorkMailClientTypes.User]? = nil
    )
    {
        self.nextToken = nextToken
        self.users = users
    }
}

struct ListUsersOutputResponseBody: Swift.Equatable {
    let users: [WorkMailClientTypes.User]?
    let nextToken: Swift.String?
}

extension ListUsersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case users = "Users"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usersContainer = try containerValues.decodeIfPresent([WorkMailClientTypes.User?].self, forKey: .users)
        var usersDecoded0:[WorkMailClientTypes.User]? = nil
        if let usersContainer = usersContainer {
            usersDecoded0 = [WorkMailClientTypes.User]()
            for structure0 in usersContainer {
                if let structure0 = structure0 {
                    usersDecoded0?.append(structure0)
                }
            }
        }
        users = usersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension MailDomainInUseException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: MailDomainInUseExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The domain you're trying to change is in use by another user or organization in your account. See the error message for details.
public struct MailDomainInUseException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct MailDomainInUseExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension MailDomainInUseExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MailDomainNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: MailDomainNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The domain specified is not found in your organization.
public struct MailDomainNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct MailDomainNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension MailDomainNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MailDomainStateException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: MailDomainStateExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// After a domain has been added to the organization, it must be verified. The domain is not yet verified.
public struct MailDomainStateException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct MailDomainStateExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension MailDomainStateExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension WorkMailClientTypes.MailDomainSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultDomain = "DefaultDomain"
        case domainName = "DomainName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if defaultDomain != false {
            try encodeContainer.encode(defaultDomain, forKey: .defaultDomain)
        }
        if let domainName = self.domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let defaultDomainDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .defaultDomain) ?? false
        defaultDomain = defaultDomainDecoded
    }
}

extension WorkMailClientTypes {
    /// The data for a given domain.
    public struct MailDomainSummary: Swift.Equatable {
        /// Whether the domain is default or not.
        public var defaultDomain: Swift.Bool
        /// The domain name.
        public var domainName: Swift.String?

        public init (
            defaultDomain: Swift.Bool = false,
            domainName: Swift.String? = nil
        )
        {
            self.defaultDomain = defaultDomain
            self.domainName = domainName
        }
    }

}

extension WorkMailClientTypes.MailboxExportJob: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case endTime = "EndTime"
        case entityId = "EntityId"
        case estimatedProgress = "EstimatedProgress"
        case jobId = "JobId"
        case s3BucketName = "S3BucketName"
        case s3Path = "S3Path"
        case startTime = "StartTime"
        case state = "State"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .epochSeconds, forKey: .endTime)
        }
        if let entityId = self.entityId {
            try encodeContainer.encode(entityId, forKey: .entityId)
        }
        if estimatedProgress != 0 {
            try encodeContainer.encode(estimatedProgress, forKey: .estimatedProgress)
        }
        if let jobId = self.jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let s3BucketName = self.s3BucketName {
            try encodeContainer.encode(s3BucketName, forKey: .s3BucketName)
        }
        if let s3Path = self.s3Path {
            try encodeContainer.encode(s3Path, forKey: .s3Path)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let entityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityId)
        entityId = entityIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let s3BucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3BucketName)
        s3BucketName = s3BucketNameDecoded
        let s3PathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Path)
        s3Path = s3PathDecoded
        let estimatedProgressDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .estimatedProgress) ?? 0
        estimatedProgress = estimatedProgressDecoded
        let stateDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.MailboxExportJobState.self, forKey: .state)
        state = stateDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
    }
}

extension WorkMailClientTypes {
    /// The details of a mailbox export job, including the user or resource ID associated with the mailbox and the S3 bucket that the mailbox contents are exported to.
    public struct MailboxExportJob: Swift.Equatable {
        /// The mailbox export job description.
        public var description: Swift.String?
        /// The mailbox export job end timestamp.
        public var endTime: ClientRuntime.Date?
        /// The identifier of the user or resource associated with the mailbox.
        public var entityId: Swift.String?
        /// The estimated progress of the mailbox export job, in percentage points.
        public var estimatedProgress: Swift.Int
        /// The identifier of the mailbox export job.
        public var jobId: Swift.String?
        /// The name of the S3 bucket.
        public var s3BucketName: Swift.String?
        /// The path to the S3 bucket and file that the mailbox export job exports to.
        public var s3Path: Swift.String?
        /// The mailbox export job start timestamp.
        public var startTime: ClientRuntime.Date?
        /// The state of the mailbox export job.
        public var state: WorkMailClientTypes.MailboxExportJobState?

        public init (
            description: Swift.String? = nil,
            endTime: ClientRuntime.Date? = nil,
            entityId: Swift.String? = nil,
            estimatedProgress: Swift.Int = 0,
            jobId: Swift.String? = nil,
            s3BucketName: Swift.String? = nil,
            s3Path: Swift.String? = nil,
            startTime: ClientRuntime.Date? = nil,
            state: WorkMailClientTypes.MailboxExportJobState? = nil
        )
        {
            self.description = description
            self.endTime = endTime
            self.entityId = entityId
            self.estimatedProgress = estimatedProgress
            self.jobId = jobId
            self.s3BucketName = s3BucketName
            self.s3Path = s3Path
            self.startTime = startTime
            self.state = state
        }
    }

}

extension WorkMailClientTypes {
    public enum MailboxExportJobState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cancelled
        case completed
        case failed
        case running
        case sdkUnknown(Swift.String)

        public static var allCases: [MailboxExportJobState] {
            return [
                .cancelled,
                .completed,
                .failed,
                .running,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "CANCELLED"
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .running: return "RUNNING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MailboxExportJobState(rawValue: rawValue) ?? MailboxExportJobState.sdkUnknown(rawValue)
        }
    }
}

extension WorkMailClientTypes.Member: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case disabledDate = "DisabledDate"
        case enabledDate = "EnabledDate"
        case id = "Id"
        case name = "Name"
        case state = "State"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let disabledDate = self.disabledDate {
            try encodeContainer.encodeTimestamp(disabledDate, format: .epochSeconds, forKey: .disabledDate)
        }
        if let enabledDate = self.enabledDate {
            try encodeContainer.encodeTimestamp(enabledDate, format: .epochSeconds, forKey: .enabledDate)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.MemberType.self, forKey: .type)
        type = typeDecoded
        let stateDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.EntityState.self, forKey: .state)
        state = stateDecoded
        let enabledDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .enabledDate)
        enabledDate = enabledDateDecoded
        let disabledDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .disabledDate)
        disabledDate = disabledDateDecoded
    }
}

extension WorkMailClientTypes {
    /// The representation of a user or group.
    public struct Member: Swift.Equatable {
        /// The date indicating when the member was disabled from WorkMail use.
        public var disabledDate: ClientRuntime.Date?
        /// The date indicating when the member was enabled for WorkMail use.
        public var enabledDate: ClientRuntime.Date?
        /// The identifier of the member.
        public var id: Swift.String?
        /// The name of the member.
        public var name: Swift.String?
        /// The state of the member, which can be ENABLED, DISABLED, or DELETED.
        public var state: WorkMailClientTypes.EntityState?
        /// A member can be a user or group.
        public var type: WorkMailClientTypes.MemberType?

        public init (
            disabledDate: ClientRuntime.Date? = nil,
            enabledDate: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            state: WorkMailClientTypes.EntityState? = nil,
            type: WorkMailClientTypes.MemberType? = nil
        )
        {
            self.disabledDate = disabledDate
            self.enabledDate = enabledDate
            self.id = id
            self.name = name
            self.state = state
            self.type = type
        }
    }

}

extension WorkMailClientTypes {
    public enum MemberType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case group
        case user
        case sdkUnknown(Swift.String)

        public static var allCases: [MemberType] {
            return [
                .group,
                .user,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .group: return "GROUP"
            case .user: return "USER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MemberType(rawValue: rawValue) ?? MemberType.sdkUnknown(rawValue)
        }
    }
}

extension WorkMailClientTypes.MobileDeviceAccessMatchedRule: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mobileDeviceAccessRuleId = "MobileDeviceAccessRuleId"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let mobileDeviceAccessRuleId = self.mobileDeviceAccessRuleId {
            try encodeContainer.encode(mobileDeviceAccessRuleId, forKey: .mobileDeviceAccessRuleId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mobileDeviceAccessRuleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mobileDeviceAccessRuleId)
        mobileDeviceAccessRuleId = mobileDeviceAccessRuleIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension WorkMailClientTypes {
    /// The rule that a simulated user matches.
    public struct MobileDeviceAccessMatchedRule: Swift.Equatable {
        /// Identifier of the rule that a simulated user matches.
        public var mobileDeviceAccessRuleId: Swift.String?
        /// Name of a rule that a simulated user matches.
        public var name: Swift.String?

        public init (
            mobileDeviceAccessRuleId: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.mobileDeviceAccessRuleId = mobileDeviceAccessRuleId
            self.name = name
        }
    }

}

extension WorkMailClientTypes.MobileDeviceAccessOverride: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dateCreated = "DateCreated"
        case dateModified = "DateModified"
        case description = "Description"
        case deviceId = "DeviceId"
        case effect = "Effect"
        case userId = "UserId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dateCreated = self.dateCreated {
            try encodeContainer.encodeTimestamp(dateCreated, format: .epochSeconds, forKey: .dateCreated)
        }
        if let dateModified = self.dateModified {
            try encodeContainer.encodeTimestamp(dateModified, format: .epochSeconds, forKey: .dateModified)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let deviceId = self.deviceId {
            try encodeContainer.encode(deviceId, forKey: .deviceId)
        }
        if let effect = self.effect {
            try encodeContainer.encode(effect.rawValue, forKey: .effect)
        }
        if let userId = self.userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
        let deviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceId)
        deviceId = deviceIdDecoded
        let effectDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.MobileDeviceAccessRuleEffect.self, forKey: .effect)
        effect = effectDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let dateCreatedDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .dateCreated)
        dateCreated = dateCreatedDecoded
        let dateModifiedDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .dateModified)
        dateModified = dateModifiedDecoded
    }
}

extension WorkMailClientTypes {
    /// The override object.
    public struct MobileDeviceAccessOverride: Swift.Equatable {
        /// The date the override was first created.
        public var dateCreated: ClientRuntime.Date?
        /// The date the override was last modified.
        public var dateModified: ClientRuntime.Date?
        /// A description of the override.
        public var description: Swift.String?
        /// The device to which the override applies.
        public var deviceId: Swift.String?
        /// The effect of the override, ALLOW or DENY.
        public var effect: WorkMailClientTypes.MobileDeviceAccessRuleEffect?
        /// The WorkMail user to which the access override applies.
        public var userId: Swift.String?

        public init (
            dateCreated: ClientRuntime.Date? = nil,
            dateModified: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            deviceId: Swift.String? = nil,
            effect: WorkMailClientTypes.MobileDeviceAccessRuleEffect? = nil,
            userId: Swift.String? = nil
        )
        {
            self.dateCreated = dateCreated
            self.dateModified = dateModified
            self.description = description
            self.deviceId = deviceId
            self.effect = effect
            self.userId = userId
        }
    }

}

extension WorkMailClientTypes.MobileDeviceAccessRule: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dateCreated = "DateCreated"
        case dateModified = "DateModified"
        case description = "Description"
        case deviceModels = "DeviceModels"
        case deviceOperatingSystems = "DeviceOperatingSystems"
        case deviceTypes = "DeviceTypes"
        case deviceUserAgents = "DeviceUserAgents"
        case effect = "Effect"
        case mobileDeviceAccessRuleId = "MobileDeviceAccessRuleId"
        case name = "Name"
        case notDeviceModels = "NotDeviceModels"
        case notDeviceOperatingSystems = "NotDeviceOperatingSystems"
        case notDeviceTypes = "NotDeviceTypes"
        case notDeviceUserAgents = "NotDeviceUserAgents"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dateCreated = self.dateCreated {
            try encodeContainer.encodeTimestamp(dateCreated, format: .epochSeconds, forKey: .dateCreated)
        }
        if let dateModified = self.dateModified {
            try encodeContainer.encodeTimestamp(dateModified, format: .epochSeconds, forKey: .dateModified)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let deviceModels = deviceModels {
            var deviceModelsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .deviceModels)
            for devicemodel0 in deviceModels {
                try deviceModelsContainer.encode(devicemodel0)
            }
        }
        if let deviceOperatingSystems = deviceOperatingSystems {
            var deviceOperatingSystemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .deviceOperatingSystems)
            for deviceoperatingsystem0 in deviceOperatingSystems {
                try deviceOperatingSystemsContainer.encode(deviceoperatingsystem0)
            }
        }
        if let deviceTypes = deviceTypes {
            var deviceTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .deviceTypes)
            for devicetype0 in deviceTypes {
                try deviceTypesContainer.encode(devicetype0)
            }
        }
        if let deviceUserAgents = deviceUserAgents {
            var deviceUserAgentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .deviceUserAgents)
            for deviceuseragent0 in deviceUserAgents {
                try deviceUserAgentsContainer.encode(deviceuseragent0)
            }
        }
        if let effect = self.effect {
            try encodeContainer.encode(effect.rawValue, forKey: .effect)
        }
        if let mobileDeviceAccessRuleId = self.mobileDeviceAccessRuleId {
            try encodeContainer.encode(mobileDeviceAccessRuleId, forKey: .mobileDeviceAccessRuleId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let notDeviceModels = notDeviceModels {
            var notDeviceModelsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notDeviceModels)
            for devicemodel0 in notDeviceModels {
                try notDeviceModelsContainer.encode(devicemodel0)
            }
        }
        if let notDeviceOperatingSystems = notDeviceOperatingSystems {
            var notDeviceOperatingSystemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notDeviceOperatingSystems)
            for deviceoperatingsystem0 in notDeviceOperatingSystems {
                try notDeviceOperatingSystemsContainer.encode(deviceoperatingsystem0)
            }
        }
        if let notDeviceTypes = notDeviceTypes {
            var notDeviceTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notDeviceTypes)
            for devicetype0 in notDeviceTypes {
                try notDeviceTypesContainer.encode(devicetype0)
            }
        }
        if let notDeviceUserAgents = notDeviceUserAgents {
            var notDeviceUserAgentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notDeviceUserAgents)
            for deviceuseragent0 in notDeviceUserAgents {
                try notDeviceUserAgentsContainer.encode(deviceuseragent0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mobileDeviceAccessRuleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mobileDeviceAccessRuleId)
        mobileDeviceAccessRuleId = mobileDeviceAccessRuleIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let effectDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.MobileDeviceAccessRuleEffect.self, forKey: .effect)
        effect = effectDecoded
        let deviceTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .deviceTypes)
        var deviceTypesDecoded0:[Swift.String]? = nil
        if let deviceTypesContainer = deviceTypesContainer {
            deviceTypesDecoded0 = [Swift.String]()
            for string0 in deviceTypesContainer {
                if let string0 = string0 {
                    deviceTypesDecoded0?.append(string0)
                }
            }
        }
        deviceTypes = deviceTypesDecoded0
        let notDeviceTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .notDeviceTypes)
        var notDeviceTypesDecoded0:[Swift.String]? = nil
        if let notDeviceTypesContainer = notDeviceTypesContainer {
            notDeviceTypesDecoded0 = [Swift.String]()
            for string0 in notDeviceTypesContainer {
                if let string0 = string0 {
                    notDeviceTypesDecoded0?.append(string0)
                }
            }
        }
        notDeviceTypes = notDeviceTypesDecoded0
        let deviceModelsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .deviceModels)
        var deviceModelsDecoded0:[Swift.String]? = nil
        if let deviceModelsContainer = deviceModelsContainer {
            deviceModelsDecoded0 = [Swift.String]()
            for string0 in deviceModelsContainer {
                if let string0 = string0 {
                    deviceModelsDecoded0?.append(string0)
                }
            }
        }
        deviceModels = deviceModelsDecoded0
        let notDeviceModelsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .notDeviceModels)
        var notDeviceModelsDecoded0:[Swift.String]? = nil
        if let notDeviceModelsContainer = notDeviceModelsContainer {
            notDeviceModelsDecoded0 = [Swift.String]()
            for string0 in notDeviceModelsContainer {
                if let string0 = string0 {
                    notDeviceModelsDecoded0?.append(string0)
                }
            }
        }
        notDeviceModels = notDeviceModelsDecoded0
        let deviceOperatingSystemsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .deviceOperatingSystems)
        var deviceOperatingSystemsDecoded0:[Swift.String]? = nil
        if let deviceOperatingSystemsContainer = deviceOperatingSystemsContainer {
            deviceOperatingSystemsDecoded0 = [Swift.String]()
            for string0 in deviceOperatingSystemsContainer {
                if let string0 = string0 {
                    deviceOperatingSystemsDecoded0?.append(string0)
                }
            }
        }
        deviceOperatingSystems = deviceOperatingSystemsDecoded0
        let notDeviceOperatingSystemsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .notDeviceOperatingSystems)
        var notDeviceOperatingSystemsDecoded0:[Swift.String]? = nil
        if let notDeviceOperatingSystemsContainer = notDeviceOperatingSystemsContainer {
            notDeviceOperatingSystemsDecoded0 = [Swift.String]()
            for string0 in notDeviceOperatingSystemsContainer {
                if let string0 = string0 {
                    notDeviceOperatingSystemsDecoded0?.append(string0)
                }
            }
        }
        notDeviceOperatingSystems = notDeviceOperatingSystemsDecoded0
        let deviceUserAgentsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .deviceUserAgents)
        var deviceUserAgentsDecoded0:[Swift.String]? = nil
        if let deviceUserAgentsContainer = deviceUserAgentsContainer {
            deviceUserAgentsDecoded0 = [Swift.String]()
            for string0 in deviceUserAgentsContainer {
                if let string0 = string0 {
                    deviceUserAgentsDecoded0?.append(string0)
                }
            }
        }
        deviceUserAgents = deviceUserAgentsDecoded0
        let notDeviceUserAgentsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .notDeviceUserAgents)
        var notDeviceUserAgentsDecoded0:[Swift.String]? = nil
        if let notDeviceUserAgentsContainer = notDeviceUserAgentsContainer {
            notDeviceUserAgentsDecoded0 = [Swift.String]()
            for string0 in notDeviceUserAgentsContainer {
                if let string0 = string0 {
                    notDeviceUserAgentsDecoded0?.append(string0)
                }
            }
        }
        notDeviceUserAgents = notDeviceUserAgentsDecoded0
        let dateCreatedDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .dateCreated)
        dateCreated = dateCreatedDecoded
        let dateModifiedDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .dateModified)
        dateModified = dateModifiedDecoded
    }
}

extension WorkMailClientTypes {
    /// A rule that controls access to mobile devices for an WorkMail group.
    public struct MobileDeviceAccessRule: Swift.Equatable {
        /// The date and time at which an access rule was created.
        public var dateCreated: ClientRuntime.Date?
        /// The date and time at which an access rule was modified.
        public var dateModified: ClientRuntime.Date?
        /// The description of a mobile access rule.
        public var description: Swift.String?
        /// Device models that a rule will match.
        public var deviceModels: [Swift.String]?
        /// Device operating systems that a rule will match.
        public var deviceOperatingSystems: [Swift.String]?
        /// Device types that a rule will match.
        public var deviceTypes: [Swift.String]?
        /// Device user agents that a rule will match.
        public var deviceUserAgents: [Swift.String]?
        /// The effect of the rule when it matches. Allowed values are ALLOW or DENY.
        public var effect: WorkMailClientTypes.MobileDeviceAccessRuleEffect?
        /// The ID assigned to a mobile access rule.
        public var mobileDeviceAccessRuleId: Swift.String?
        /// The name of a mobile access rule.
        public var name: Swift.String?
        /// Device models that a rule will not match. All other device models will match.
        public var notDeviceModels: [Swift.String]?
        /// Device operating systems that a rule will not match. All other device types will match.
        public var notDeviceOperatingSystems: [Swift.String]?
        /// Device types that a rule will not match. All other device types will match.
        public var notDeviceTypes: [Swift.String]?
        /// Device user agents that a rule will not match. All other device user agents will match.
        public var notDeviceUserAgents: [Swift.String]?

        public init (
            dateCreated: ClientRuntime.Date? = nil,
            dateModified: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            deviceModels: [Swift.String]? = nil,
            deviceOperatingSystems: [Swift.String]? = nil,
            deviceTypes: [Swift.String]? = nil,
            deviceUserAgents: [Swift.String]? = nil,
            effect: WorkMailClientTypes.MobileDeviceAccessRuleEffect? = nil,
            mobileDeviceAccessRuleId: Swift.String? = nil,
            name: Swift.String? = nil,
            notDeviceModels: [Swift.String]? = nil,
            notDeviceOperatingSystems: [Swift.String]? = nil,
            notDeviceTypes: [Swift.String]? = nil,
            notDeviceUserAgents: [Swift.String]? = nil
        )
        {
            self.dateCreated = dateCreated
            self.dateModified = dateModified
            self.description = description
            self.deviceModels = deviceModels
            self.deviceOperatingSystems = deviceOperatingSystems
            self.deviceTypes = deviceTypes
            self.deviceUserAgents = deviceUserAgents
            self.effect = effect
            self.mobileDeviceAccessRuleId = mobileDeviceAccessRuleId
            self.name = name
            self.notDeviceModels = notDeviceModels
            self.notDeviceOperatingSystems = notDeviceOperatingSystems
            self.notDeviceTypes = notDeviceTypes
            self.notDeviceUserAgents = notDeviceUserAgents
        }
    }

}

extension WorkMailClientTypes {
    public enum MobileDeviceAccessRuleEffect: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case allow
        case deny
        case sdkUnknown(Swift.String)

        public static var allCases: [MobileDeviceAccessRuleEffect] {
            return [
                .allow,
                .deny,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .allow: return "ALLOW"
            case .deny: return "DENY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MobileDeviceAccessRuleEffect(rawValue: rawValue) ?? MobileDeviceAccessRuleEffect.sdkUnknown(rawValue)
        }
    }
}

extension NameAvailabilityException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: NameAvailabilityExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The user, group, or resource name isn't unique in WorkMail.
public struct NameAvailabilityException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NameAvailabilityExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension NameAvailabilityExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OrganizationNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: OrganizationNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An operation received a valid organization identifier that either doesn't belong or exist in the system.
public struct OrganizationNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct OrganizationNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension OrganizationNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OrganizationStateException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: OrganizationStateExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The organization must have a valid state to perform certain operations on the organization or its members.
public struct OrganizationStateException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct OrganizationStateExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension OrganizationStateExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension WorkMailClientTypes.OrganizationSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alias = "Alias"
        case defaultMailDomain = "DefaultMailDomain"
        case errorMessage = "ErrorMessage"
        case organizationId = "OrganizationId"
        case state = "State"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alias = self.alias {
            try encodeContainer.encode(alias, forKey: .alias)
        }
        if let defaultMailDomain = self.defaultMailDomain {
            try encodeContainer.encode(defaultMailDomain, forKey: .defaultMailDomain)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
        if let state = self.state {
            try encodeContainer.encode(state, forKey: .state)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let aliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alias)
        alias = aliasDecoded
        let defaultMailDomainDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultMailDomain)
        defaultMailDomain = defaultMailDomainDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let stateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .state)
        state = stateDecoded
    }
}

extension WorkMailClientTypes {
    /// The representation of an organization.
    public struct OrganizationSummary: Swift.Equatable {
        /// The alias associated with the organization.
        public var alias: Swift.String?
        /// The default email domain associated with the organization.
        public var defaultMailDomain: Swift.String?
        /// The error message associated with the organization. It is only present if unexpected behavior has occurred with regards to the organization. It provides insight or solutions regarding unexpected behavior.
        public var errorMessage: Swift.String?
        /// The identifier associated with the organization.
        public var organizationId: Swift.String?
        /// The state associated with the organization.
        public var state: Swift.String?

        public init (
            alias: Swift.String? = nil,
            defaultMailDomain: Swift.String? = nil,
            errorMessage: Swift.String? = nil,
            organizationId: Swift.String? = nil,
            state: Swift.String? = nil
        )
        {
            self.alias = alias
            self.defaultMailDomain = defaultMailDomain
            self.errorMessage = errorMessage
            self.organizationId = organizationId
            self.state = state
        }
    }

}

extension WorkMailClientTypes.Permission: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case granteeId = "GranteeId"
        case granteeType = "GranteeType"
        case permissionValues = "PermissionValues"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let granteeId = self.granteeId {
            try encodeContainer.encode(granteeId, forKey: .granteeId)
        }
        if let granteeType = self.granteeType {
            try encodeContainer.encode(granteeType.rawValue, forKey: .granteeType)
        }
        if let permissionValues = permissionValues {
            var permissionValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .permissionValues)
            for permissiontype0 in permissionValues {
                try permissionValuesContainer.encode(permissiontype0.rawValue)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let granteeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .granteeId)
        granteeId = granteeIdDecoded
        let granteeTypeDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.MemberType.self, forKey: .granteeType)
        granteeType = granteeTypeDecoded
        let permissionValuesContainer = try containerValues.decodeIfPresent([WorkMailClientTypes.PermissionType?].self, forKey: .permissionValues)
        var permissionValuesDecoded0:[WorkMailClientTypes.PermissionType]? = nil
        if let permissionValuesContainer = permissionValuesContainer {
            permissionValuesDecoded0 = [WorkMailClientTypes.PermissionType]()
            for enum0 in permissionValuesContainer {
                if let enum0 = enum0 {
                    permissionValuesDecoded0?.append(enum0)
                }
            }
        }
        permissionValues = permissionValuesDecoded0
    }
}

extension WorkMailClientTypes {
    /// Permission granted to a user, group, or resource to access a certain aspect of another user, group, or resource mailbox.
    public struct Permission: Swift.Equatable {
        /// The identifier of the user, group, or resource to which the permissions are granted.
        /// This member is required.
        public var granteeId: Swift.String?
        /// The type of user, group, or resource referred to in GranteeId.
        /// This member is required.
        public var granteeType: WorkMailClientTypes.MemberType?
        /// The permissions granted to the grantee. SEND_AS allows the grantee to send email as the owner of the mailbox (the grantee is not mentioned on these emails). SEND_ON_BEHALF allows the grantee to send email on behalf of the owner of the mailbox (the grantee is not mentioned as the physical sender of these emails). FULL_ACCESS allows the grantee full access to the mailbox, irrespective of other folder-level permissions set on the mailbox.
        /// This member is required.
        public var permissionValues: [WorkMailClientTypes.PermissionType]?

        public init (
            granteeId: Swift.String? = nil,
            granteeType: WorkMailClientTypes.MemberType? = nil,
            permissionValues: [WorkMailClientTypes.PermissionType]? = nil
        )
        {
            self.granteeId = granteeId
            self.granteeType = granteeType
            self.permissionValues = permissionValues
        }
    }

}

extension WorkMailClientTypes {
    public enum PermissionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case fullAccess
        case sendAs
        case sendOnBehalf
        case sdkUnknown(Swift.String)

        public static var allCases: [PermissionType] {
            return [
                .fullAccess,
                .sendAs,
                .sendOnBehalf,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .fullAccess: return "FULL_ACCESS"
            case .sendAs: return "SEND_AS"
            case .sendOnBehalf: return "SEND_ON_BEHALF"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PermissionType(rawValue: rawValue) ?? PermissionType.sdkUnknown(rawValue)
        }
    }
}

extension PutAccessControlRuleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actions = "Actions"
        case description = "Description"
        case effect = "Effect"
        case impersonationRoleIds = "ImpersonationRoleIds"
        case ipRanges = "IpRanges"
        case name = "Name"
        case notActions = "NotActions"
        case notImpersonationRoleIds = "NotImpersonationRoleIds"
        case notIpRanges = "NotIpRanges"
        case notUserIds = "NotUserIds"
        case organizationId = "OrganizationId"
        case userIds = "UserIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actions = actions {
            var actionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .actions)
            for accesscontrolruleaction0 in actions {
                try actionsContainer.encode(accesscontrolruleaction0)
            }
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let effect = self.effect {
            try encodeContainer.encode(effect.rawValue, forKey: .effect)
        }
        if let impersonationRoleIds = impersonationRoleIds {
            var impersonationRoleIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .impersonationRoleIds)
            for impersonationroleid0 in impersonationRoleIds {
                try impersonationRoleIdsContainer.encode(impersonationroleid0)
            }
        }
        if let ipRanges = ipRanges {
            var ipRangesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ipRanges)
            for iprange0 in ipRanges {
                try ipRangesContainer.encode(iprange0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let notActions = notActions {
            var notActionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notActions)
            for accesscontrolruleaction0 in notActions {
                try notActionsContainer.encode(accesscontrolruleaction0)
            }
        }
        if let notImpersonationRoleIds = notImpersonationRoleIds {
            var notImpersonationRoleIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notImpersonationRoleIds)
            for impersonationroleid0 in notImpersonationRoleIds {
                try notImpersonationRoleIdsContainer.encode(impersonationroleid0)
            }
        }
        if let notIpRanges = notIpRanges {
            var notIpRangesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notIpRanges)
            for iprange0 in notIpRanges {
                try notIpRangesContainer.encode(iprange0)
            }
        }
        if let notUserIds = notUserIds {
            var notUserIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notUserIds)
            for workmailidentifier0 in notUserIds {
                try notUserIdsContainer.encode(workmailidentifier0)
            }
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
        if let userIds = userIds {
            var userIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .userIds)
            for workmailidentifier0 in userIds {
                try userIdsContainer.encode(workmailidentifier0)
            }
        }
    }
}

extension PutAccessControlRuleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutAccessControlRuleInput: Swift.Equatable {
    /// Access protocol actions to include in the rule. Valid values include ActiveSync, AutoDiscover, EWS, IMAP, SMTP, WindowsOutlook, and WebMail.
    public var actions: [Swift.String]?
    /// The rule description.
    /// This member is required.
    public var description: Swift.String?
    /// The rule effect.
    /// This member is required.
    public var effect: WorkMailClientTypes.AccessControlRuleEffect?
    /// Impersonation role IDs to include in the rule.
    public var impersonationRoleIds: [Swift.String]?
    /// IPv4 CIDR ranges to include in the rule.
    public var ipRanges: [Swift.String]?
    /// The rule name.
    /// This member is required.
    public var name: Swift.String?
    /// Access protocol actions to exclude from the rule. Valid values include ActiveSync, AutoDiscover, EWS, IMAP, SMTP, WindowsOutlook, and WebMail.
    public var notActions: [Swift.String]?
    /// Impersonation role IDs to exclude from the rule.
    public var notImpersonationRoleIds: [Swift.String]?
    /// IPv4 CIDR ranges to exclude from the rule.
    public var notIpRanges: [Swift.String]?
    /// User IDs to exclude from the rule.
    public var notUserIds: [Swift.String]?
    /// The identifier of the organization.
    /// This member is required.
    public var organizationId: Swift.String?
    /// User IDs to include in the rule.
    public var userIds: [Swift.String]?

    public init (
        actions: [Swift.String]? = nil,
        description: Swift.String? = nil,
        effect: WorkMailClientTypes.AccessControlRuleEffect? = nil,
        impersonationRoleIds: [Swift.String]? = nil,
        ipRanges: [Swift.String]? = nil,
        name: Swift.String? = nil,
        notActions: [Swift.String]? = nil,
        notImpersonationRoleIds: [Swift.String]? = nil,
        notIpRanges: [Swift.String]? = nil,
        notUserIds: [Swift.String]? = nil,
        organizationId: Swift.String? = nil,
        userIds: [Swift.String]? = nil
    )
    {
        self.actions = actions
        self.description = description
        self.effect = effect
        self.impersonationRoleIds = impersonationRoleIds
        self.ipRanges = ipRanges
        self.name = name
        self.notActions = notActions
        self.notImpersonationRoleIds = notImpersonationRoleIds
        self.notIpRanges = notIpRanges
        self.notUserIds = notUserIds
        self.organizationId = organizationId
        self.userIds = userIds
    }
}

struct PutAccessControlRuleInputBody: Swift.Equatable {
    let name: Swift.String?
    let effect: WorkMailClientTypes.AccessControlRuleEffect?
    let description: Swift.String?
    let ipRanges: [Swift.String]?
    let notIpRanges: [Swift.String]?
    let actions: [Swift.String]?
    let notActions: [Swift.String]?
    let userIds: [Swift.String]?
    let notUserIds: [Swift.String]?
    let organizationId: Swift.String?
    let impersonationRoleIds: [Swift.String]?
    let notImpersonationRoleIds: [Swift.String]?
}

extension PutAccessControlRuleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actions = "Actions"
        case description = "Description"
        case effect = "Effect"
        case impersonationRoleIds = "ImpersonationRoleIds"
        case ipRanges = "IpRanges"
        case name = "Name"
        case notActions = "NotActions"
        case notImpersonationRoleIds = "NotImpersonationRoleIds"
        case notIpRanges = "NotIpRanges"
        case notUserIds = "NotUserIds"
        case organizationId = "OrganizationId"
        case userIds = "UserIds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let effectDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.AccessControlRuleEffect.self, forKey: .effect)
        effect = effectDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let ipRangesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ipRanges)
        var ipRangesDecoded0:[Swift.String]? = nil
        if let ipRangesContainer = ipRangesContainer {
            ipRangesDecoded0 = [Swift.String]()
            for string0 in ipRangesContainer {
                if let string0 = string0 {
                    ipRangesDecoded0?.append(string0)
                }
            }
        }
        ipRanges = ipRangesDecoded0
        let notIpRangesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .notIpRanges)
        var notIpRangesDecoded0:[Swift.String]? = nil
        if let notIpRangesContainer = notIpRangesContainer {
            notIpRangesDecoded0 = [Swift.String]()
            for string0 in notIpRangesContainer {
                if let string0 = string0 {
                    notIpRangesDecoded0?.append(string0)
                }
            }
        }
        notIpRanges = notIpRangesDecoded0
        let actionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .actions)
        var actionsDecoded0:[Swift.String]? = nil
        if let actionsContainer = actionsContainer {
            actionsDecoded0 = [Swift.String]()
            for string0 in actionsContainer {
                if let string0 = string0 {
                    actionsDecoded0?.append(string0)
                }
            }
        }
        actions = actionsDecoded0
        let notActionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .notActions)
        var notActionsDecoded0:[Swift.String]? = nil
        if let notActionsContainer = notActionsContainer {
            notActionsDecoded0 = [Swift.String]()
            for string0 in notActionsContainer {
                if let string0 = string0 {
                    notActionsDecoded0?.append(string0)
                }
            }
        }
        notActions = notActionsDecoded0
        let userIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .userIds)
        var userIdsDecoded0:[Swift.String]? = nil
        if let userIdsContainer = userIdsContainer {
            userIdsDecoded0 = [Swift.String]()
            for string0 in userIdsContainer {
                if let string0 = string0 {
                    userIdsDecoded0?.append(string0)
                }
            }
        }
        userIds = userIdsDecoded0
        let notUserIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .notUserIds)
        var notUserIdsDecoded0:[Swift.String]? = nil
        if let notUserIdsContainer = notUserIdsContainer {
            notUserIdsDecoded0 = [Swift.String]()
            for string0 in notUserIdsContainer {
                if let string0 = string0 {
                    notUserIdsDecoded0?.append(string0)
                }
            }
        }
        notUserIds = notUserIdsDecoded0
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let impersonationRoleIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .impersonationRoleIds)
        var impersonationRoleIdsDecoded0:[Swift.String]? = nil
        if let impersonationRoleIdsContainer = impersonationRoleIdsContainer {
            impersonationRoleIdsDecoded0 = [Swift.String]()
            for string0 in impersonationRoleIdsContainer {
                if let string0 = string0 {
                    impersonationRoleIdsDecoded0?.append(string0)
                }
            }
        }
        impersonationRoleIds = impersonationRoleIdsDecoded0
        let notImpersonationRoleIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .notImpersonationRoleIds)
        var notImpersonationRoleIdsDecoded0:[Swift.String]? = nil
        if let notImpersonationRoleIdsContainer = notImpersonationRoleIdsContainer {
            notImpersonationRoleIdsDecoded0 = [Swift.String]()
            for string0 in notImpersonationRoleIdsContainer {
                if let string0 = string0 {
                    notImpersonationRoleIdsDecoded0?.append(string0)
                }
            }
        }
        notImpersonationRoleIds = notImpersonationRoleIdsDecoded0
    }
}

extension PutAccessControlRuleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutAccessControlRuleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum PutAccessControlRuleOutputError: Swift.Error, Swift.Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case invalidParameterException(InvalidParameterException)
    case limitExceededException(LimitExceededException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutAccessControlRuleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct PutAccessControlRuleOutputResponse: Swift.Equatable {

    public init () { }
}

extension PutEmailMonitoringConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case logGroupArn = "LogGroupArn"
        case organizationId = "OrganizationId"
        case roleArn = "RoleArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let logGroupArn = self.logGroupArn {
            try encodeContainer.encode(logGroupArn, forKey: .logGroupArn)
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }
}

extension PutEmailMonitoringConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutEmailMonitoringConfigurationInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the CloudWatch Log group associated with the email monitoring configuration.
    /// This member is required.
    public var logGroupArn: Swift.String?
    /// The ID of the organization for which the email monitoring configuration is set.
    /// This member is required.
    public var organizationId: Swift.String?
    /// The Amazon Resource Name (ARN) of the IAM Role associated with the email monitoring configuration.
    /// This member is required.
    public var roleArn: Swift.String?

    public init (
        logGroupArn: Swift.String? = nil,
        organizationId: Swift.String? = nil,
        roleArn: Swift.String? = nil
    )
    {
        self.logGroupArn = logGroupArn
        self.organizationId = organizationId
        self.roleArn = roleArn
    }
}

struct PutEmailMonitoringConfigurationInputBody: Swift.Equatable {
    let organizationId: Swift.String?
    let roleArn: Swift.String?
    let logGroupArn: Swift.String?
}

extension PutEmailMonitoringConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case logGroupArn = "LogGroupArn"
        case organizationId = "OrganizationId"
        case roleArn = "RoleArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let logGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logGroupArn)
        logGroupArn = logGroupArnDecoded
    }
}

extension PutEmailMonitoringConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutEmailMonitoringConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum PutEmailMonitoringConfigurationOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterException(InvalidParameterException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutEmailMonitoringConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct PutEmailMonitoringConfigurationOutputResponse: Swift.Equatable {

    public init () { }
}

extension PutInboundDmarcSettingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enforced = "Enforced"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enforced = self.enforced {
            try encodeContainer.encode(enforced, forKey: .enforced)
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

extension PutInboundDmarcSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutInboundDmarcSettingsInput: Swift.Equatable {
    /// Enforces or suspends a policy after it's applied.
    /// This member is required.
    public var enforced: Swift.Bool?
    /// The ID of the organization that you are applying the DMARC policy to.
    /// This member is required.
    public var organizationId: Swift.String?

    public init (
        enforced: Swift.Bool? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.enforced = enforced
        self.organizationId = organizationId
    }
}

struct PutInboundDmarcSettingsInputBody: Swift.Equatable {
    let organizationId: Swift.String?
    let enforced: Swift.Bool?
}

extension PutInboundDmarcSettingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enforced = "Enforced"
        case organizationId = "OrganizationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let enforcedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enforced)
        enforced = enforcedDecoded
    }
}

extension PutInboundDmarcSettingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutInboundDmarcSettingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum PutInboundDmarcSettingsOutputError: Swift.Error, Swift.Equatable {
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutInboundDmarcSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct PutInboundDmarcSettingsOutputResponse: Swift.Equatable {

    public init () { }
}

extension PutMailboxPermissionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entityId = "EntityId"
        case granteeId = "GranteeId"
        case organizationId = "OrganizationId"
        case permissionValues = "PermissionValues"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entityId = self.entityId {
            try encodeContainer.encode(entityId, forKey: .entityId)
        }
        if let granteeId = self.granteeId {
            try encodeContainer.encode(granteeId, forKey: .granteeId)
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
        if let permissionValues = permissionValues {
            var permissionValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .permissionValues)
            for permissiontype0 in permissionValues {
                try permissionValuesContainer.encode(permissiontype0.rawValue)
            }
        }
    }
}

extension PutMailboxPermissionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutMailboxPermissionsInput: Swift.Equatable {
    /// The identifier of the user, group, or resource for which to update mailbox permissions.
    /// This member is required.
    public var entityId: Swift.String?
    /// The identifier of the user, group, or resource to which to grant the permissions.
    /// This member is required.
    public var granteeId: Swift.String?
    /// The identifier of the organization under which the user, group, or resource exists.
    /// This member is required.
    public var organizationId: Swift.String?
    /// The permissions granted to the grantee. SEND_AS allows the grantee to send email as the owner of the mailbox (the grantee is not mentioned on these emails). SEND_ON_BEHALF allows the grantee to send email on behalf of the owner of the mailbox (the grantee is not mentioned as the physical sender of these emails). FULL_ACCESS allows the grantee full access to the mailbox, irrespective of other folder-level permissions set on the mailbox.
    /// This member is required.
    public var permissionValues: [WorkMailClientTypes.PermissionType]?

    public init (
        entityId: Swift.String? = nil,
        granteeId: Swift.String? = nil,
        organizationId: Swift.String? = nil,
        permissionValues: [WorkMailClientTypes.PermissionType]? = nil
    )
    {
        self.entityId = entityId
        self.granteeId = granteeId
        self.organizationId = organizationId
        self.permissionValues = permissionValues
    }
}

struct PutMailboxPermissionsInputBody: Swift.Equatable {
    let organizationId: Swift.String?
    let entityId: Swift.String?
    let granteeId: Swift.String?
    let permissionValues: [WorkMailClientTypes.PermissionType]?
}

extension PutMailboxPermissionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entityId = "EntityId"
        case granteeId = "GranteeId"
        case organizationId = "OrganizationId"
        case permissionValues = "PermissionValues"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let entityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityId)
        entityId = entityIdDecoded
        let granteeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .granteeId)
        granteeId = granteeIdDecoded
        let permissionValuesContainer = try containerValues.decodeIfPresent([WorkMailClientTypes.PermissionType?].self, forKey: .permissionValues)
        var permissionValuesDecoded0:[WorkMailClientTypes.PermissionType]? = nil
        if let permissionValuesContainer = permissionValuesContainer {
            permissionValuesDecoded0 = [WorkMailClientTypes.PermissionType]()
            for enum0 in permissionValuesContainer {
                if let enum0 = enum0 {
                    permissionValuesDecoded0?.append(enum0)
                }
            }
        }
        permissionValues = permissionValuesDecoded0
    }
}

extension PutMailboxPermissionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutMailboxPermissionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityStateException" : self = .entityStateException(try EntityStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum PutMailboxPermissionsOutputError: Swift.Error, Swift.Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case entityStateException(EntityStateException)
    case invalidParameterException(InvalidParameterException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutMailboxPermissionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct PutMailboxPermissionsOutputResponse: Swift.Equatable {

    public init () { }
}

extension PutMobileDeviceAccessOverrideInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case deviceId = "DeviceId"
        case effect = "Effect"
        case organizationId = "OrganizationId"
        case userId = "UserId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let deviceId = self.deviceId {
            try encodeContainer.encode(deviceId, forKey: .deviceId)
        }
        if let effect = self.effect {
            try encodeContainer.encode(effect.rawValue, forKey: .effect)
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
        if let userId = self.userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
    }
}

extension PutMobileDeviceAccessOverrideInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutMobileDeviceAccessOverrideInput: Swift.Equatable {
    /// A description of the override.
    public var description: Swift.String?
    /// The mobile device for which you create the override. DeviceId is case insensitive.
    /// This member is required.
    public var deviceId: Swift.String?
    /// The effect of the override, ALLOW or DENY.
    /// This member is required.
    public var effect: WorkMailClientTypes.MobileDeviceAccessRuleEffect?
    /// Identifies the WorkMail organization for which you create the override.
    /// This member is required.
    public var organizationId: Swift.String?
    /// The WorkMail user for which you create the override. Accepts the following types of user identities:
    ///
    /// * User ID: 12345678-1234-1234-1234-123456789012 or S-1-1-12-1234567890-123456789-123456789-1234
    ///
    /// * Email address: user@domain.tld
    ///
    /// * User name: user
    /// This member is required.
    public var userId: Swift.String?

    public init (
        description: Swift.String? = nil,
        deviceId: Swift.String? = nil,
        effect: WorkMailClientTypes.MobileDeviceAccessRuleEffect? = nil,
        organizationId: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.description = description
        self.deviceId = deviceId
        self.effect = effect
        self.organizationId = organizationId
        self.userId = userId
    }
}

struct PutMobileDeviceAccessOverrideInputBody: Swift.Equatable {
    let organizationId: Swift.String?
    let userId: Swift.String?
    let deviceId: Swift.String?
    let effect: WorkMailClientTypes.MobileDeviceAccessRuleEffect?
    let description: Swift.String?
}

extension PutMobileDeviceAccessOverrideInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case deviceId = "DeviceId"
        case effect = "Effect"
        case organizationId = "OrganizationId"
        case userId = "UserId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
        let deviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceId)
        deviceId = deviceIdDecoded
        let effectDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.MobileDeviceAccessRuleEffect.self, forKey: .effect)
        effect = effectDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension PutMobileDeviceAccessOverrideOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutMobileDeviceAccessOverrideOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityStateException" : self = .entityStateException(try EntityStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum PutMobileDeviceAccessOverrideOutputError: Swift.Error, Swift.Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case entityStateException(EntityStateException)
    case invalidParameterException(InvalidParameterException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutMobileDeviceAccessOverrideOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct PutMobileDeviceAccessOverrideOutputResponse: Swift.Equatable {

    public init () { }
}

extension PutRetentionPolicyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutRetentionPolicyInput(folderConfigurations: \(Swift.String(describing: folderConfigurations)), id: \(Swift.String(describing: id)), name: \(Swift.String(describing: name)), organizationId: \(Swift.String(describing: organizationId)), description: \"CONTENT_REDACTED\")"}
}

extension PutRetentionPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case folderConfigurations = "FolderConfigurations"
        case id = "Id"
        case name = "Name"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let folderConfigurations = folderConfigurations {
            var folderConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .folderConfigurations)
            for folderconfiguration0 in folderConfigurations {
                try folderConfigurationsContainer.encode(folderconfiguration0)
            }
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

extension PutRetentionPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutRetentionPolicyInput: Swift.Equatable {
    /// The retention policy description.
    public var description: Swift.String?
    /// The retention policy folder configurations.
    /// This member is required.
    public var folderConfigurations: [WorkMailClientTypes.FolderConfiguration]?
    /// The retention policy ID.
    public var id: Swift.String?
    /// The retention policy name.
    /// This member is required.
    public var name: Swift.String?
    /// The organization ID.
    /// This member is required.
    public var organizationId: Swift.String?

    public init (
        description: Swift.String? = nil,
        folderConfigurations: [WorkMailClientTypes.FolderConfiguration]? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.description = description
        self.folderConfigurations = folderConfigurations
        self.id = id
        self.name = name
        self.organizationId = organizationId
    }
}

struct PutRetentionPolicyInputBody: Swift.Equatable {
    let organizationId: Swift.String?
    let id: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let folderConfigurations: [WorkMailClientTypes.FolderConfiguration]?
}

extension PutRetentionPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case folderConfigurations = "FolderConfigurations"
        case id = "Id"
        case name = "Name"
        case organizationId = "OrganizationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let folderConfigurationsContainer = try containerValues.decodeIfPresent([WorkMailClientTypes.FolderConfiguration?].self, forKey: .folderConfigurations)
        var folderConfigurationsDecoded0:[WorkMailClientTypes.FolderConfiguration]? = nil
        if let folderConfigurationsContainer = folderConfigurationsContainer {
            folderConfigurationsDecoded0 = [WorkMailClientTypes.FolderConfiguration]()
            for structure0 in folderConfigurationsContainer {
                if let structure0 = structure0 {
                    folderConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        folderConfigurations = folderConfigurationsDecoded0
    }
}

extension PutRetentionPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutRetentionPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum PutRetentionPolicyOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterException(InvalidParameterException)
    case limitExceededException(LimitExceededException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutRetentionPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct PutRetentionPolicyOutputResponse: Swift.Equatable {

    public init () { }
}

extension WorkMailClientTypes.RedactedEwsAvailabilityProvider: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ewsEndpoint = "EwsEndpoint"
        case ewsUsername = "EwsUsername"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ewsEndpoint = self.ewsEndpoint {
            try encodeContainer.encode(ewsEndpoint, forKey: .ewsEndpoint)
        }
        if let ewsUsername = self.ewsUsername {
            try encodeContainer.encode(ewsUsername, forKey: .ewsUsername)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ewsEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ewsEndpoint)
        ewsEndpoint = ewsEndpointDecoded
        let ewsUsernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ewsUsername)
        ewsUsername = ewsUsernameDecoded
    }
}

extension WorkMailClientTypes {
    /// Describes an EWS based availability provider when returned from the service. It does not contain the password of the endpoint.
    public struct RedactedEwsAvailabilityProvider: Swift.Equatable {
        /// The endpoint of the remote EWS server.
        public var ewsEndpoint: Swift.String?
        /// The username used to authenticate the remote EWS server.
        public var ewsUsername: Swift.String?

        public init (
            ewsEndpoint: Swift.String? = nil,
            ewsUsername: Swift.String? = nil
        )
        {
            self.ewsEndpoint = ewsEndpoint
            self.ewsUsername = ewsUsername
        }
    }

}

extension RegisterMailDomainInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case domainName = "DomainName"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let domainName = self.domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

extension RegisterMailDomainInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct RegisterMailDomainInput: Swift.Equatable {
    /// Idempotency token used when retrying requests.
    public var clientToken: Swift.String?
    /// The name of the mail domain to create in WorkMail and SES.
    /// This member is required.
    public var domainName: Swift.String?
    /// The WorkMail organization under which you're creating the domain.
    /// This member is required.
    public var organizationId: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        domainName: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.domainName = domainName
        self.organizationId = organizationId
    }
}

struct RegisterMailDomainInputBody: Swift.Equatable {
    let clientToken: Swift.String?
    let organizationId: Swift.String?
    let domainName: Swift.String?
}

extension RegisterMailDomainInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case domainName = "DomainName"
        case organizationId = "OrganizationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
    }
}

extension RegisterMailDomainOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RegisterMailDomainOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MailDomainInUseException" : self = .mailDomainInUseException(try MailDomainInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum RegisterMailDomainOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterException(InvalidParameterException)
    case limitExceededException(LimitExceededException)
    case mailDomainInUseException(MailDomainInUseException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RegisterMailDomainOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct RegisterMailDomainOutputResponse: Swift.Equatable {

    public init () { }
}

extension RegisterToWorkMailInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case email = "Email"
        case entityId = "EntityId"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let email = self.email {
            try encodeContainer.encode(email, forKey: .email)
        }
        if let entityId = self.entityId {
            try encodeContainer.encode(entityId, forKey: .entityId)
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

extension RegisterToWorkMailInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct RegisterToWorkMailInput: Swift.Equatable {
    /// The email for the user, group, or resource to be updated.
    /// This member is required.
    public var email: Swift.String?
    /// The identifier for the user, group, or resource to be updated.
    /// This member is required.
    public var entityId: Swift.String?
    /// The identifier for the organization under which the user, group, or resource exists.
    /// This member is required.
    public var organizationId: Swift.String?

    public init (
        email: Swift.String? = nil,
        entityId: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.email = email
        self.entityId = entityId
        self.organizationId = organizationId
    }
}

struct RegisterToWorkMailInputBody: Swift.Equatable {
    let organizationId: Swift.String?
    let entityId: Swift.String?
    let email: Swift.String?
}

extension RegisterToWorkMailInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case email = "Email"
        case entityId = "EntityId"
        case organizationId = "OrganizationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let entityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityId)
        entityId = entityIdDecoded
        let emailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .email)
        email = emailDecoded
    }
}

extension RegisterToWorkMailOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RegisterToWorkMailOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DirectoryServiceAuthenticationFailedException" : self = .directoryServiceAuthenticationFailedException(try DirectoryServiceAuthenticationFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryUnavailableException" : self = .directoryUnavailableException(try DirectoryUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EmailAddressInUseException" : self = .emailAddressInUseException(try EmailAddressInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityAlreadyRegisteredException" : self = .entityAlreadyRegisteredException(try EntityAlreadyRegisteredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityStateException" : self = .entityStateException(try EntityStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MailDomainNotFoundException" : self = .mailDomainNotFoundException(try MailDomainNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MailDomainStateException" : self = .mailDomainStateException(try MailDomainStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum RegisterToWorkMailOutputError: Swift.Error, Swift.Equatable {
    case directoryServiceAuthenticationFailedException(DirectoryServiceAuthenticationFailedException)
    case directoryUnavailableException(DirectoryUnavailableException)
    case emailAddressInUseException(EmailAddressInUseException)
    case entityAlreadyRegisteredException(EntityAlreadyRegisteredException)
    case entityNotFoundException(EntityNotFoundException)
    case entityStateException(EntityStateException)
    case invalidParameterException(InvalidParameterException)
    case mailDomainNotFoundException(MailDomainNotFoundException)
    case mailDomainStateException(MailDomainStateException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RegisterToWorkMailOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct RegisterToWorkMailOutputResponse: Swift.Equatable {

    public init () { }
}

extension ReservedNameException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ReservedNameExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This user, group, or resource name is not allowed in WorkMail.
public struct ReservedNameException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ReservedNameExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ReservedNameExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResetPasswordInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResetPasswordInput(organizationId: \(Swift.String(describing: organizationId)), userId: \(Swift.String(describing: userId)), password: \"CONTENT_REDACTED\")"}
}

extension ResetPasswordInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case organizationId = "OrganizationId"
        case password = "Password"
        case userId = "UserId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
        if let password = self.password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let userId = self.userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
    }
}

extension ResetPasswordInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ResetPasswordInput: Swift.Equatable {
    /// The identifier of the organization that contains the user for which the password is reset.
    /// This member is required.
    public var organizationId: Swift.String?
    /// The new password for the user.
    /// This member is required.
    public var password: Swift.String?
    /// The identifier of the user for whom the password is reset.
    /// This member is required.
    public var userId: Swift.String?

    public init (
        organizationId: Swift.String? = nil,
        password: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.organizationId = organizationId
        self.password = password
        self.userId = userId
    }
}

struct ResetPasswordInputBody: Swift.Equatable {
    let organizationId: Swift.String?
    let userId: Swift.String?
    let password: Swift.String?
}

extension ResetPasswordInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case organizationId = "OrganizationId"
        case password = "Password"
        case userId = "UserId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .password)
        password = passwordDecoded
    }
}

extension ResetPasswordOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ResetPasswordOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DirectoryServiceAuthenticationFailedException" : self = .directoryServiceAuthenticationFailedException(try DirectoryServiceAuthenticationFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryUnavailableException" : self = .directoryUnavailableException(try DirectoryUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityStateException" : self = .entityStateException(try EntityStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPasswordException" : self = .invalidPasswordException(try InvalidPasswordException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ResetPasswordOutputError: Swift.Error, Swift.Equatable {
    case directoryServiceAuthenticationFailedException(DirectoryServiceAuthenticationFailedException)
    case directoryUnavailableException(DirectoryUnavailableException)
    case entityNotFoundException(EntityNotFoundException)
    case entityStateException(EntityStateException)
    case invalidParameterException(InvalidParameterException)
    case invalidPasswordException(InvalidPasswordException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ResetPasswordOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct ResetPasswordOutputResponse: Swift.Equatable {

    public init () { }
}

extension WorkMailClientTypes.Resource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case disabledDate = "DisabledDate"
        case email = "Email"
        case enabledDate = "EnabledDate"
        case id = "Id"
        case name = "Name"
        case state = "State"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let disabledDate = self.disabledDate {
            try encodeContainer.encodeTimestamp(disabledDate, format: .epochSeconds, forKey: .disabledDate)
        }
        if let email = self.email {
            try encodeContainer.encode(email, forKey: .email)
        }
        if let enabledDate = self.enabledDate {
            try encodeContainer.encodeTimestamp(enabledDate, format: .epochSeconds, forKey: .enabledDate)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let emailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .email)
        email = emailDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.ResourceType.self, forKey: .type)
        type = typeDecoded
        let stateDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.EntityState.self, forKey: .state)
        state = stateDecoded
        let enabledDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .enabledDate)
        enabledDate = enabledDateDecoded
        let disabledDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .disabledDate)
        disabledDate = disabledDateDecoded
    }
}

extension WorkMailClientTypes {
    /// The representation of a resource.
    public struct Resource: Swift.Equatable {
        /// The date indicating when the resource was disabled from WorkMail use.
        public var disabledDate: ClientRuntime.Date?
        /// The email of the resource.
        public var email: Swift.String?
        /// The date indicating when the resource was enabled for WorkMail use.
        public var enabledDate: ClientRuntime.Date?
        /// The identifier of the resource.
        public var id: Swift.String?
        /// The name of the resource.
        public var name: Swift.String?
        /// The state of the resource, which can be ENABLED, DISABLED, or DELETED.
        public var state: WorkMailClientTypes.EntityState?
        /// The type of the resource: equipment or room.
        public var type: WorkMailClientTypes.ResourceType?

        public init (
            disabledDate: ClientRuntime.Date? = nil,
            email: Swift.String? = nil,
            enabledDate: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            state: WorkMailClientTypes.EntityState? = nil,
            type: WorkMailClientTypes.ResourceType? = nil
        )
        {
            self.disabledDate = disabledDate
            self.email = email
            self.enabledDate = enabledDate
            self.id = id
            self.name = name
            self.state = state
            self.type = type
        }
    }

}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The resource cannot be found.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension WorkMailClientTypes {
    public enum ResourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case equipment
        case room
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceType] {
            return [
                .equipment,
                .room,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .equipment: return "EQUIPMENT"
            case .room: return "ROOM"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceType(rawValue: rawValue) ?? ResourceType.sdkUnknown(rawValue)
        }
    }
}

extension WorkMailClientTypes {
    public enum RetentionAction: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case delete
        case `none`
        case permanentlyDelete
        case sdkUnknown(Swift.String)

        public static var allCases: [RetentionAction] {
            return [
                .delete,
                .none,
                .permanentlyDelete,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .delete: return "DELETE"
            case .none: return "NONE"
            case .permanentlyDelete: return "PERMANENTLY_DELETE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RetentionAction(rawValue: rawValue) ?? RetentionAction.sdkUnknown(rawValue)
        }
    }
}

extension StartMailboxExportJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case entityId = "EntityId"
        case kmsKeyArn = "KmsKeyArn"
        case organizationId = "OrganizationId"
        case roleArn = "RoleArn"
        case s3BucketName = "S3BucketName"
        case s3Prefix = "S3Prefix"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let entityId = self.entityId {
            try encodeContainer.encode(entityId, forKey: .entityId)
        }
        if let kmsKeyArn = self.kmsKeyArn {
            try encodeContainer.encode(kmsKeyArn, forKey: .kmsKeyArn)
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let s3BucketName = self.s3BucketName {
            try encodeContainer.encode(s3BucketName, forKey: .s3BucketName)
        }
        if let s3Prefix = self.s3Prefix {
            try encodeContainer.encode(s3Prefix, forKey: .s3Prefix)
        }
    }
}

extension StartMailboxExportJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StartMailboxExportJobInput: Swift.Equatable {
    /// The idempotency token for the client request.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The mailbox export job description.
    public var description: Swift.String?
    /// The identifier of the user or resource associated with the mailbox.
    /// This member is required.
    public var entityId: Swift.String?
    /// The Amazon Resource Name (ARN) of the symmetric AWS Key Management Service (AWS KMS) key that encrypts the exported mailbox content.
    /// This member is required.
    public var kmsKeyArn: Swift.String?
    /// The identifier associated with the organization.
    /// This member is required.
    public var organizationId: Swift.String?
    /// The ARN of the AWS Identity and Access Management (IAM) role that grants write permission to the S3 bucket.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The name of the S3 bucket.
    /// This member is required.
    public var s3BucketName: Swift.String?
    /// The S3 bucket prefix.
    /// This member is required.
    public var s3Prefix: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        entityId: Swift.String? = nil,
        kmsKeyArn: Swift.String? = nil,
        organizationId: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        s3BucketName: Swift.String? = nil,
        s3Prefix: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.entityId = entityId
        self.kmsKeyArn = kmsKeyArn
        self.organizationId = organizationId
        self.roleArn = roleArn
        self.s3BucketName = s3BucketName
        self.s3Prefix = s3Prefix
    }
}

struct StartMailboxExportJobInputBody: Swift.Equatable {
    let clientToken: Swift.String?
    let organizationId: Swift.String?
    let entityId: Swift.String?
    let description: Swift.String?
    let roleArn: Swift.String?
    let kmsKeyArn: Swift.String?
    let s3BucketName: Swift.String?
    let s3Prefix: Swift.String?
}

extension StartMailboxExportJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case entityId = "EntityId"
        case kmsKeyArn = "KmsKeyArn"
        case organizationId = "OrganizationId"
        case roleArn = "RoleArn"
        case s3BucketName = "S3BucketName"
        case s3Prefix = "S3Prefix"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let entityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityId)
        entityId = entityIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
        let s3BucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3BucketName)
        s3BucketName = s3BucketNameDecoded
        let s3PrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Prefix)
        s3Prefix = s3PrefixDecoded
    }
}

extension StartMailboxExportJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartMailboxExportJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum StartMailboxExportJobOutputError: Swift.Error, Swift.Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case invalidParameterException(InvalidParameterException)
    case limitExceededException(LimitExceededException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartMailboxExportJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: StartMailboxExportJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.jobId = output.jobId
        } else {
            self.jobId = nil
        }
    }
}

public struct StartMailboxExportJobOutputResponse: Swift.Equatable {
    /// The job ID.
    public var jobId: Swift.String?

    public init (
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct StartMailboxExportJobOutputResponseBody: Swift.Equatable {
    let jobId: Swift.String?
}

extension StartMailboxExportJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension WorkMailClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension WorkMailClientTypes {
    /// Describes a tag applied to a resource.
    public struct Tag: Swift.Equatable {
        /// The key of the tag.
        /// This member is required.
        public var key: Swift.String?
        /// The value of the tag.
        /// This member is required.
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The resource ARN.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// The tag key-value pairs.
    /// This member is required.
    public var tags: [WorkMailClientTypes.Tag]?

    public init (
        resourceARN: Swift.String? = nil,
        tags: [WorkMailClientTypes.Tag]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let resourceARN: Swift.String?
    let tags: [WorkMailClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagsContainer = try containerValues.decodeIfPresent([WorkMailClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[WorkMailClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [WorkMailClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case organizationStateException(OrganizationStateException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyTagsException(TooManyTagsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension TestAvailabilityConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
        case ewsProvider = "EwsProvider"
        case lambdaProvider = "LambdaProvider"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainName = self.domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let ewsProvider = self.ewsProvider {
            try encodeContainer.encode(ewsProvider, forKey: .ewsProvider)
        }
        if let lambdaProvider = self.lambdaProvider {
            try encodeContainer.encode(lambdaProvider, forKey: .lambdaProvider)
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

extension TestAvailabilityConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct TestAvailabilityConfigurationInput: Swift.Equatable {
    /// The domain to which the provider applies. If this field is provided, a stored availability provider associated to this domain name will be tested.
    public var domainName: Swift.String?
    /// Describes an EWS based availability provider. This is only used as input to the service.
    public var ewsProvider: WorkMailClientTypes.EwsAvailabilityProvider?
    /// Describes a Lambda based availability provider.
    public var lambdaProvider: WorkMailClientTypes.LambdaAvailabilityProvider?
    /// The WorkMail organization where the availability provider will be tested.
    /// This member is required.
    public var organizationId: Swift.String?

    public init (
        domainName: Swift.String? = nil,
        ewsProvider: WorkMailClientTypes.EwsAvailabilityProvider? = nil,
        lambdaProvider: WorkMailClientTypes.LambdaAvailabilityProvider? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.ewsProvider = ewsProvider
        self.lambdaProvider = lambdaProvider
        self.organizationId = organizationId
    }
}

struct TestAvailabilityConfigurationInputBody: Swift.Equatable {
    let organizationId: Swift.String?
    let domainName: Swift.String?
    let ewsProvider: WorkMailClientTypes.EwsAvailabilityProvider?
    let lambdaProvider: WorkMailClientTypes.LambdaAvailabilityProvider?
}

extension TestAvailabilityConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
        case ewsProvider = "EwsProvider"
        case lambdaProvider = "LambdaProvider"
        case organizationId = "OrganizationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let ewsProviderDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.EwsAvailabilityProvider.self, forKey: .ewsProvider)
        ewsProvider = ewsProviderDecoded
        let lambdaProviderDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.LambdaAvailabilityProvider.self, forKey: .lambdaProvider)
        lambdaProvider = lambdaProviderDecoded
    }
}

extension TestAvailabilityConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TestAvailabilityConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum TestAvailabilityConfigurationOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterException(InvalidParameterException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TestAvailabilityConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: TestAvailabilityConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.failureReason = output.failureReason
            self.testPassed = output.testPassed
        } else {
            self.failureReason = nil
            self.testPassed = false
        }
    }
}

public struct TestAvailabilityConfigurationOutputResponse: Swift.Equatable {
    /// String containing the reason for a failed test if TestPassed is false.
    public var failureReason: Swift.String?
    /// Boolean indicating whether the test passed or failed.
    public var testPassed: Swift.Bool

    public init (
        failureReason: Swift.String? = nil,
        testPassed: Swift.Bool = false
    )
    {
        self.failureReason = failureReason
        self.testPassed = testPassed
    }
}

struct TestAvailabilityConfigurationOutputResponseBody: Swift.Equatable {
    let testPassed: Swift.Bool
    let failureReason: Swift.String?
}

extension TestAvailabilityConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failureReason = "FailureReason"
        case testPassed = "TestPassed"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let testPassedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .testPassed) ?? false
        testPassed = testPassedDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
    }
}

extension TooManyTagsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: TooManyTagsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The resource can have up to 50 user-applied tags.
public struct TooManyTagsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyTagsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyTagsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UnsupportedOperationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UnsupportedOperationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You can't perform a write operation against a read-only directory.
public struct UnsupportedOperationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct UnsupportedOperationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension UnsupportedOperationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkey0 in tagKeys {
                try tagKeysContainer.encode(tagkey0)
            }
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The resource ARN.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// The tag keys.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceARN: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    let resourceARN: Swift.String?
    let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateAvailabilityConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
        case ewsProvider = "EwsProvider"
        case lambdaProvider = "LambdaProvider"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainName = self.domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let ewsProvider = self.ewsProvider {
            try encodeContainer.encode(ewsProvider, forKey: .ewsProvider)
        }
        if let lambdaProvider = self.lambdaProvider {
            try encodeContainer.encode(lambdaProvider, forKey: .lambdaProvider)
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

extension UpdateAvailabilityConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateAvailabilityConfigurationInput: Swift.Equatable {
    /// The domain to which the provider applies the availability configuration.
    /// This member is required.
    public var domainName: Swift.String?
    /// The EWS availability provider definition. The request must contain exactly one provider definition, either EwsProvider or LambdaProvider. The previously stored provider will be overridden by the one provided.
    public var ewsProvider: WorkMailClientTypes.EwsAvailabilityProvider?
    /// The Lambda availability provider definition. The request must contain exactly one provider definition, either EwsProvider or LambdaProvider. The previously stored provider will be overridden by the one provided.
    public var lambdaProvider: WorkMailClientTypes.LambdaAvailabilityProvider?
    /// The WorkMail organization for which the AvailabilityConfiguration will be updated.
    /// This member is required.
    public var organizationId: Swift.String?

    public init (
        domainName: Swift.String? = nil,
        ewsProvider: WorkMailClientTypes.EwsAvailabilityProvider? = nil,
        lambdaProvider: WorkMailClientTypes.LambdaAvailabilityProvider? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.ewsProvider = ewsProvider
        self.lambdaProvider = lambdaProvider
        self.organizationId = organizationId
    }
}

struct UpdateAvailabilityConfigurationInputBody: Swift.Equatable {
    let organizationId: Swift.String?
    let domainName: Swift.String?
    let ewsProvider: WorkMailClientTypes.EwsAvailabilityProvider?
    let lambdaProvider: WorkMailClientTypes.LambdaAvailabilityProvider?
}

extension UpdateAvailabilityConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
        case ewsProvider = "EwsProvider"
        case lambdaProvider = "LambdaProvider"
        case organizationId = "OrganizationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let ewsProviderDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.EwsAvailabilityProvider.self, forKey: .ewsProvider)
        ewsProvider = ewsProviderDecoded
        let lambdaProviderDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.LambdaAvailabilityProvider.self, forKey: .lambdaProvider)
        lambdaProvider = lambdaProviderDecoded
    }
}

extension UpdateAvailabilityConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateAvailabilityConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateAvailabilityConfigurationOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterException(InvalidParameterException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateAvailabilityConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateAvailabilityConfigurationOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateDefaultMailDomainInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainName = self.domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

extension UpdateDefaultMailDomainInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateDefaultMailDomainInput: Swift.Equatable {
    /// The domain name that will become the default domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The WorkMail organization for which to list domains.
    /// This member is required.
    public var organizationId: Swift.String?

    public init (
        domainName: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.organizationId = organizationId
    }
}

struct UpdateDefaultMailDomainInputBody: Swift.Equatable {
    let organizationId: Swift.String?
    let domainName: Swift.String?
}

extension UpdateDefaultMailDomainInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
        case organizationId = "OrganizationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
    }
}

extension UpdateDefaultMailDomainOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDefaultMailDomainOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MailDomainNotFoundException" : self = .mailDomainNotFoundException(try MailDomainNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MailDomainStateException" : self = .mailDomainStateException(try MailDomainStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateDefaultMailDomainOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterException(InvalidParameterException)
    case mailDomainNotFoundException(MailDomainNotFoundException)
    case mailDomainStateException(MailDomainStateException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDefaultMailDomainOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateDefaultMailDomainOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateImpersonationRoleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case impersonationRoleId = "ImpersonationRoleId"
        case name = "Name"
        case organizationId = "OrganizationId"
        case rules = "Rules"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let impersonationRoleId = self.impersonationRoleId {
            try encodeContainer.encode(impersonationRoleId, forKey: .impersonationRoleId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
        if let rules = rules {
            var rulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rules)
            for impersonationrule0 in rules {
                try rulesContainer.encode(impersonationrule0)
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension UpdateImpersonationRoleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateImpersonationRoleInput: Swift.Equatable {
    /// The updated impersonation role description.
    public var description: Swift.String?
    /// The ID of the impersonation role to update.
    /// This member is required.
    public var impersonationRoleId: Swift.String?
    /// The updated impersonation role name.
    /// This member is required.
    public var name: Swift.String?
    /// The WorkMail organization that contains the impersonation role to update.
    /// This member is required.
    public var organizationId: Swift.String?
    /// The updated list of rules.
    /// This member is required.
    public var rules: [WorkMailClientTypes.ImpersonationRule]?
    /// The updated impersonation role type.
    /// This member is required.
    public var type: WorkMailClientTypes.ImpersonationRoleType?

    public init (
        description: Swift.String? = nil,
        impersonationRoleId: Swift.String? = nil,
        name: Swift.String? = nil,
        organizationId: Swift.String? = nil,
        rules: [WorkMailClientTypes.ImpersonationRule]? = nil,
        type: WorkMailClientTypes.ImpersonationRoleType? = nil
    )
    {
        self.description = description
        self.impersonationRoleId = impersonationRoleId
        self.name = name
        self.organizationId = organizationId
        self.rules = rules
        self.type = type
    }
}

struct UpdateImpersonationRoleInputBody: Swift.Equatable {
    let organizationId: Swift.String?
    let impersonationRoleId: Swift.String?
    let name: Swift.String?
    let type: WorkMailClientTypes.ImpersonationRoleType?
    let description: Swift.String?
    let rules: [WorkMailClientTypes.ImpersonationRule]?
}

extension UpdateImpersonationRoleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case impersonationRoleId = "ImpersonationRoleId"
        case name = "Name"
        case organizationId = "OrganizationId"
        case rules = "Rules"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let impersonationRoleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .impersonationRoleId)
        impersonationRoleId = impersonationRoleIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.ImpersonationRoleType.self, forKey: .type)
        type = typeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let rulesContainer = try containerValues.decodeIfPresent([WorkMailClientTypes.ImpersonationRule?].self, forKey: .rules)
        var rulesDecoded0:[WorkMailClientTypes.ImpersonationRule]? = nil
        if let rulesContainer = rulesContainer {
            rulesDecoded0 = [WorkMailClientTypes.ImpersonationRule]()
            for structure0 in rulesContainer {
                if let structure0 = structure0 {
                    rulesDecoded0?.append(structure0)
                }
            }
        }
        rules = rulesDecoded0
    }
}

extension UpdateImpersonationRoleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateImpersonationRoleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityStateException" : self = .entityStateException(try EntityStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateImpersonationRoleOutputError: Swift.Error, Swift.Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case entityStateException(EntityStateException)
    case invalidParameterException(InvalidParameterException)
    case limitExceededException(LimitExceededException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateImpersonationRoleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateImpersonationRoleOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateMailboxQuotaInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mailboxQuota = "MailboxQuota"
        case organizationId = "OrganizationId"
        case userId = "UserId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let mailboxQuota = self.mailboxQuota {
            try encodeContainer.encode(mailboxQuota, forKey: .mailboxQuota)
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
        if let userId = self.userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
    }
}

extension UpdateMailboxQuotaInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateMailboxQuotaInput: Swift.Equatable {
    /// The updated mailbox quota, in MB, for the specified user.
    /// This member is required.
    public var mailboxQuota: Swift.Int?
    /// The identifier for the organization that contains the user for whom to update the mailbox quota.
    /// This member is required.
    public var organizationId: Swift.String?
    /// The identifer for the user for whom to update the mailbox quota.
    /// This member is required.
    public var userId: Swift.String?

    public init (
        mailboxQuota: Swift.Int? = nil,
        organizationId: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.mailboxQuota = mailboxQuota
        self.organizationId = organizationId
        self.userId = userId
    }
}

struct UpdateMailboxQuotaInputBody: Swift.Equatable {
    let organizationId: Swift.String?
    let userId: Swift.String?
    let mailboxQuota: Swift.Int?
}

extension UpdateMailboxQuotaInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mailboxQuota = "MailboxQuota"
        case organizationId = "OrganizationId"
        case userId = "UserId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
        let mailboxQuotaDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .mailboxQuota)
        mailboxQuota = mailboxQuotaDecoded
    }
}

extension UpdateMailboxQuotaOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateMailboxQuotaOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityStateException" : self = .entityStateException(try EntityStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateMailboxQuotaOutputError: Swift.Error, Swift.Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case entityStateException(EntityStateException)
    case invalidParameterException(InvalidParameterException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateMailboxQuotaOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateMailboxQuotaOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateMobileDeviceAccessRuleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case deviceModels = "DeviceModels"
        case deviceOperatingSystems = "DeviceOperatingSystems"
        case deviceTypes = "DeviceTypes"
        case deviceUserAgents = "DeviceUserAgents"
        case effect = "Effect"
        case mobileDeviceAccessRuleId = "MobileDeviceAccessRuleId"
        case name = "Name"
        case notDeviceModels = "NotDeviceModels"
        case notDeviceOperatingSystems = "NotDeviceOperatingSystems"
        case notDeviceTypes = "NotDeviceTypes"
        case notDeviceUserAgents = "NotDeviceUserAgents"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let deviceModels = deviceModels {
            var deviceModelsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .deviceModels)
            for devicemodel0 in deviceModels {
                try deviceModelsContainer.encode(devicemodel0)
            }
        }
        if let deviceOperatingSystems = deviceOperatingSystems {
            var deviceOperatingSystemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .deviceOperatingSystems)
            for deviceoperatingsystem0 in deviceOperatingSystems {
                try deviceOperatingSystemsContainer.encode(deviceoperatingsystem0)
            }
        }
        if let deviceTypes = deviceTypes {
            var deviceTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .deviceTypes)
            for devicetype0 in deviceTypes {
                try deviceTypesContainer.encode(devicetype0)
            }
        }
        if let deviceUserAgents = deviceUserAgents {
            var deviceUserAgentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .deviceUserAgents)
            for deviceuseragent0 in deviceUserAgents {
                try deviceUserAgentsContainer.encode(deviceuseragent0)
            }
        }
        if let effect = self.effect {
            try encodeContainer.encode(effect.rawValue, forKey: .effect)
        }
        if let mobileDeviceAccessRuleId = self.mobileDeviceAccessRuleId {
            try encodeContainer.encode(mobileDeviceAccessRuleId, forKey: .mobileDeviceAccessRuleId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let notDeviceModels = notDeviceModels {
            var notDeviceModelsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notDeviceModels)
            for devicemodel0 in notDeviceModels {
                try notDeviceModelsContainer.encode(devicemodel0)
            }
        }
        if let notDeviceOperatingSystems = notDeviceOperatingSystems {
            var notDeviceOperatingSystemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notDeviceOperatingSystems)
            for deviceoperatingsystem0 in notDeviceOperatingSystems {
                try notDeviceOperatingSystemsContainer.encode(deviceoperatingsystem0)
            }
        }
        if let notDeviceTypes = notDeviceTypes {
            var notDeviceTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notDeviceTypes)
            for devicetype0 in notDeviceTypes {
                try notDeviceTypesContainer.encode(devicetype0)
            }
        }
        if let notDeviceUserAgents = notDeviceUserAgents {
            var notDeviceUserAgentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notDeviceUserAgents)
            for deviceuseragent0 in notDeviceUserAgents {
                try notDeviceUserAgentsContainer.encode(deviceuseragent0)
            }
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

extension UpdateMobileDeviceAccessRuleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateMobileDeviceAccessRuleInput: Swift.Equatable {
    /// The updated rule description.
    public var description: Swift.String?
    /// Device models that the updated rule will match.
    public var deviceModels: [Swift.String]?
    /// Device operating systems that the updated rule will match.
    public var deviceOperatingSystems: [Swift.String]?
    /// Device types that the updated rule will match.
    public var deviceTypes: [Swift.String]?
    /// User agents that the updated rule will match.
    public var deviceUserAgents: [Swift.String]?
    /// The effect of the rule when it matches. Allowed values are ALLOW or DENY.
    /// This member is required.
    public var effect: WorkMailClientTypes.MobileDeviceAccessRuleEffect?
    /// The identifier of the rule to be updated.
    /// This member is required.
    public var mobileDeviceAccessRuleId: Swift.String?
    /// The updated rule name.
    /// This member is required.
    public var name: Swift.String?
    /// Device models that the updated rule will not match. All other device models will match.
    public var notDeviceModels: [Swift.String]?
    /// Device operating systems that the updated rule will not match. All other device operating systems will match.
    public var notDeviceOperatingSystems: [Swift.String]?
    /// Device types that the updated rule will not match. All other device types will match.
    public var notDeviceTypes: [Swift.String]?
    /// User agents that the updated rule will not match. All other user agents will match.
    public var notDeviceUserAgents: [Swift.String]?
    /// The WorkMail organization under which the rule will be updated.
    /// This member is required.
    public var organizationId: Swift.String?

    public init (
        description: Swift.String? = nil,
        deviceModels: [Swift.String]? = nil,
        deviceOperatingSystems: [Swift.String]? = nil,
        deviceTypes: [Swift.String]? = nil,
        deviceUserAgents: [Swift.String]? = nil,
        effect: WorkMailClientTypes.MobileDeviceAccessRuleEffect? = nil,
        mobileDeviceAccessRuleId: Swift.String? = nil,
        name: Swift.String? = nil,
        notDeviceModels: [Swift.String]? = nil,
        notDeviceOperatingSystems: [Swift.String]? = nil,
        notDeviceTypes: [Swift.String]? = nil,
        notDeviceUserAgents: [Swift.String]? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.description = description
        self.deviceModels = deviceModels
        self.deviceOperatingSystems = deviceOperatingSystems
        self.deviceTypes = deviceTypes
        self.deviceUserAgents = deviceUserAgents
        self.effect = effect
        self.mobileDeviceAccessRuleId = mobileDeviceAccessRuleId
        self.name = name
        self.notDeviceModels = notDeviceModels
        self.notDeviceOperatingSystems = notDeviceOperatingSystems
        self.notDeviceTypes = notDeviceTypes
        self.notDeviceUserAgents = notDeviceUserAgents
        self.organizationId = organizationId
    }
}

struct UpdateMobileDeviceAccessRuleInputBody: Swift.Equatable {
    let organizationId: Swift.String?
    let mobileDeviceAccessRuleId: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let effect: WorkMailClientTypes.MobileDeviceAccessRuleEffect?
    let deviceTypes: [Swift.String]?
    let notDeviceTypes: [Swift.String]?
    let deviceModels: [Swift.String]?
    let notDeviceModels: [Swift.String]?
    let deviceOperatingSystems: [Swift.String]?
    let notDeviceOperatingSystems: [Swift.String]?
    let deviceUserAgents: [Swift.String]?
    let notDeviceUserAgents: [Swift.String]?
}

extension UpdateMobileDeviceAccessRuleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case deviceModels = "DeviceModels"
        case deviceOperatingSystems = "DeviceOperatingSystems"
        case deviceTypes = "DeviceTypes"
        case deviceUserAgents = "DeviceUserAgents"
        case effect = "Effect"
        case mobileDeviceAccessRuleId = "MobileDeviceAccessRuleId"
        case name = "Name"
        case notDeviceModels = "NotDeviceModels"
        case notDeviceOperatingSystems = "NotDeviceOperatingSystems"
        case notDeviceTypes = "NotDeviceTypes"
        case notDeviceUserAgents = "NotDeviceUserAgents"
        case organizationId = "OrganizationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let mobileDeviceAccessRuleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mobileDeviceAccessRuleId)
        mobileDeviceAccessRuleId = mobileDeviceAccessRuleIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let effectDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.MobileDeviceAccessRuleEffect.self, forKey: .effect)
        effect = effectDecoded
        let deviceTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .deviceTypes)
        var deviceTypesDecoded0:[Swift.String]? = nil
        if let deviceTypesContainer = deviceTypesContainer {
            deviceTypesDecoded0 = [Swift.String]()
            for string0 in deviceTypesContainer {
                if let string0 = string0 {
                    deviceTypesDecoded0?.append(string0)
                }
            }
        }
        deviceTypes = deviceTypesDecoded0
        let notDeviceTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .notDeviceTypes)
        var notDeviceTypesDecoded0:[Swift.String]? = nil
        if let notDeviceTypesContainer = notDeviceTypesContainer {
            notDeviceTypesDecoded0 = [Swift.String]()
            for string0 in notDeviceTypesContainer {
                if let string0 = string0 {
                    notDeviceTypesDecoded0?.append(string0)
                }
            }
        }
        notDeviceTypes = notDeviceTypesDecoded0
        let deviceModelsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .deviceModels)
        var deviceModelsDecoded0:[Swift.String]? = nil
        if let deviceModelsContainer = deviceModelsContainer {
            deviceModelsDecoded0 = [Swift.String]()
            for string0 in deviceModelsContainer {
                if let string0 = string0 {
                    deviceModelsDecoded0?.append(string0)
                }
            }
        }
        deviceModels = deviceModelsDecoded0
        let notDeviceModelsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .notDeviceModels)
        var notDeviceModelsDecoded0:[Swift.String]? = nil
        if let notDeviceModelsContainer = notDeviceModelsContainer {
            notDeviceModelsDecoded0 = [Swift.String]()
            for string0 in notDeviceModelsContainer {
                if let string0 = string0 {
                    notDeviceModelsDecoded0?.append(string0)
                }
            }
        }
        notDeviceModels = notDeviceModelsDecoded0
        let deviceOperatingSystemsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .deviceOperatingSystems)
        var deviceOperatingSystemsDecoded0:[Swift.String]? = nil
        if let deviceOperatingSystemsContainer = deviceOperatingSystemsContainer {
            deviceOperatingSystemsDecoded0 = [Swift.String]()
            for string0 in deviceOperatingSystemsContainer {
                if let string0 = string0 {
                    deviceOperatingSystemsDecoded0?.append(string0)
                }
            }
        }
        deviceOperatingSystems = deviceOperatingSystemsDecoded0
        let notDeviceOperatingSystemsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .notDeviceOperatingSystems)
        var notDeviceOperatingSystemsDecoded0:[Swift.String]? = nil
        if let notDeviceOperatingSystemsContainer = notDeviceOperatingSystemsContainer {
            notDeviceOperatingSystemsDecoded0 = [Swift.String]()
            for string0 in notDeviceOperatingSystemsContainer {
                if let string0 = string0 {
                    notDeviceOperatingSystemsDecoded0?.append(string0)
                }
            }
        }
        notDeviceOperatingSystems = notDeviceOperatingSystemsDecoded0
        let deviceUserAgentsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .deviceUserAgents)
        var deviceUserAgentsDecoded0:[Swift.String]? = nil
        if let deviceUserAgentsContainer = deviceUserAgentsContainer {
            deviceUserAgentsDecoded0 = [Swift.String]()
            for string0 in deviceUserAgentsContainer {
                if let string0 = string0 {
                    deviceUserAgentsDecoded0?.append(string0)
                }
            }
        }
        deviceUserAgents = deviceUserAgentsDecoded0
        let notDeviceUserAgentsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .notDeviceUserAgents)
        var notDeviceUserAgentsDecoded0:[Swift.String]? = nil
        if let notDeviceUserAgentsContainer = notDeviceUserAgentsContainer {
            notDeviceUserAgentsDecoded0 = [Swift.String]()
            for string0 in notDeviceUserAgentsContainer {
                if let string0 = string0 {
                    notDeviceUserAgentsDecoded0?.append(string0)
                }
            }
        }
        notDeviceUserAgents = notDeviceUserAgentsDecoded0
    }
}

extension UpdateMobileDeviceAccessRuleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateMobileDeviceAccessRuleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateMobileDeviceAccessRuleOutputError: Swift.Error, Swift.Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case invalidParameterException(InvalidParameterException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateMobileDeviceAccessRuleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateMobileDeviceAccessRuleOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdatePrimaryEmailAddressInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case email = "Email"
        case entityId = "EntityId"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let email = self.email {
            try encodeContainer.encode(email, forKey: .email)
        }
        if let entityId = self.entityId {
            try encodeContainer.encode(entityId, forKey: .entityId)
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

extension UpdatePrimaryEmailAddressInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdatePrimaryEmailAddressInput: Swift.Equatable {
    /// The value of the email to be updated as primary.
    /// This member is required.
    public var email: Swift.String?
    /// The user, group, or resource to update.
    /// This member is required.
    public var entityId: Swift.String?
    /// The organization that contains the user, group, or resource to update.
    /// This member is required.
    public var organizationId: Swift.String?

    public init (
        email: Swift.String? = nil,
        entityId: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.email = email
        self.entityId = entityId
        self.organizationId = organizationId
    }
}

struct UpdatePrimaryEmailAddressInputBody: Swift.Equatable {
    let organizationId: Swift.String?
    let entityId: Swift.String?
    let email: Swift.String?
}

extension UpdatePrimaryEmailAddressInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case email = "Email"
        case entityId = "EntityId"
        case organizationId = "OrganizationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let entityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityId)
        entityId = entityIdDecoded
        let emailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .email)
        email = emailDecoded
    }
}

extension UpdatePrimaryEmailAddressOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdatePrimaryEmailAddressOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DirectoryServiceAuthenticationFailedException" : self = .directoryServiceAuthenticationFailedException(try DirectoryServiceAuthenticationFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryUnavailableException" : self = .directoryUnavailableException(try DirectoryUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EmailAddressInUseException" : self = .emailAddressInUseException(try EmailAddressInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityStateException" : self = .entityStateException(try EntityStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MailDomainNotFoundException" : self = .mailDomainNotFoundException(try MailDomainNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MailDomainStateException" : self = .mailDomainStateException(try MailDomainStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdatePrimaryEmailAddressOutputError: Swift.Error, Swift.Equatable {
    case directoryServiceAuthenticationFailedException(DirectoryServiceAuthenticationFailedException)
    case directoryUnavailableException(DirectoryUnavailableException)
    case emailAddressInUseException(EmailAddressInUseException)
    case entityNotFoundException(EntityNotFoundException)
    case entityStateException(EntityStateException)
    case invalidParameterException(InvalidParameterException)
    case mailDomainNotFoundException(MailDomainNotFoundException)
    case mailDomainStateException(MailDomainStateException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdatePrimaryEmailAddressOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdatePrimaryEmailAddressOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bookingOptions = "BookingOptions"
        case name = "Name"
        case organizationId = "OrganizationId"
        case resourceId = "ResourceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bookingOptions = self.bookingOptions {
            try encodeContainer.encode(bookingOptions, forKey: .bookingOptions)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
    }
}

extension UpdateResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateResourceInput: Swift.Equatable {
    /// The resource's booking options to be updated.
    public var bookingOptions: WorkMailClientTypes.BookingOptions?
    /// The name of the resource to be updated.
    public var name: Swift.String?
    /// The identifier associated with the organization for which the resource is updated.
    /// This member is required.
    public var organizationId: Swift.String?
    /// The identifier of the resource to be updated.
    /// This member is required.
    public var resourceId: Swift.String?

    public init (
        bookingOptions: WorkMailClientTypes.BookingOptions? = nil,
        name: Swift.String? = nil,
        organizationId: Swift.String? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.bookingOptions = bookingOptions
        self.name = name
        self.organizationId = organizationId
        self.resourceId = resourceId
    }
}

struct UpdateResourceInputBody: Swift.Equatable {
    let organizationId: Swift.String?
    let resourceId: Swift.String?
    let name: Swift.String?
    let bookingOptions: WorkMailClientTypes.BookingOptions?
}

extension UpdateResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bookingOptions = "BookingOptions"
        case name = "Name"
        case organizationId = "OrganizationId"
        case resourceId = "ResourceId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let bookingOptionsDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.BookingOptions.self, forKey: .bookingOptions)
        bookingOptions = bookingOptionsDecoded
    }
}

extension UpdateResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DirectoryUnavailableException" : self = .directoryUnavailableException(try DirectoryUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EmailAddressInUseException" : self = .emailAddressInUseException(try EmailAddressInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityStateException" : self = .entityStateException(try EntityStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidConfigurationException" : self = .invalidConfigurationException(try InvalidConfigurationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MailDomainNotFoundException" : self = .mailDomainNotFoundException(try MailDomainNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MailDomainStateException" : self = .mailDomainStateException(try MailDomainStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NameAvailabilityException" : self = .nameAvailabilityException(try NameAvailabilityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateResourceOutputError: Swift.Error, Swift.Equatable {
    case directoryUnavailableException(DirectoryUnavailableException)
    case emailAddressInUseException(EmailAddressInUseException)
    case entityNotFoundException(EntityNotFoundException)
    case entityStateException(EntityStateException)
    case invalidConfigurationException(InvalidConfigurationException)
    case mailDomainNotFoundException(MailDomainNotFoundException)
    case mailDomainStateException(MailDomainStateException)
    case nameAvailabilityException(NameAvailabilityException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension WorkMailClientTypes.User: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case disabledDate = "DisabledDate"
        case displayName = "DisplayName"
        case email = "Email"
        case enabledDate = "EnabledDate"
        case id = "Id"
        case name = "Name"
        case state = "State"
        case userRole = "UserRole"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let disabledDate = self.disabledDate {
            try encodeContainer.encodeTimestamp(disabledDate, format: .epochSeconds, forKey: .disabledDate)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let email = self.email {
            try encodeContainer.encode(email, forKey: .email)
        }
        if let enabledDate = self.enabledDate {
            try encodeContainer.encodeTimestamp(enabledDate, format: .epochSeconds, forKey: .enabledDate)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let userRole = self.userRole {
            try encodeContainer.encode(userRole.rawValue, forKey: .userRole)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let emailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .email)
        email = emailDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let stateDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.EntityState.self, forKey: .state)
        state = stateDecoded
        let userRoleDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.UserRole.self, forKey: .userRole)
        userRole = userRoleDecoded
        let enabledDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .enabledDate)
        enabledDate = enabledDateDecoded
        let disabledDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .disabledDate)
        disabledDate = disabledDateDecoded
    }
}

extension WorkMailClientTypes {
    /// The representation of an WorkMail user.
    public struct User: Swift.Equatable {
        /// The date indicating when the user was disabled from WorkMail use.
        public var disabledDate: ClientRuntime.Date?
        /// The display name of the user.
        public var displayName: Swift.String?
        /// The email of the user.
        public var email: Swift.String?
        /// The date indicating when the user was enabled for WorkMail use.
        public var enabledDate: ClientRuntime.Date?
        /// The identifier of the user.
        public var id: Swift.String?
        /// The name of the user.
        public var name: Swift.String?
        /// The state of the user, which can be ENABLED, DISABLED, or DELETED.
        public var state: WorkMailClientTypes.EntityState?
        /// The role of the user.
        public var userRole: WorkMailClientTypes.UserRole?

        public init (
            disabledDate: ClientRuntime.Date? = nil,
            displayName: Swift.String? = nil,
            email: Swift.String? = nil,
            enabledDate: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            state: WorkMailClientTypes.EntityState? = nil,
            userRole: WorkMailClientTypes.UserRole? = nil
        )
        {
            self.disabledDate = disabledDate
            self.displayName = displayName
            self.email = email
            self.enabledDate = enabledDate
            self.id = id
            self.name = name
            self.state = state
            self.userRole = userRole
        }
    }

}

extension WorkMailClientTypes {
    public enum UserRole: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case resource
        case systemUser
        case user
        case sdkUnknown(Swift.String)

        public static var allCases: [UserRole] {
            return [
                .resource,
                .systemUser,
                .user,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .resource: return "RESOURCE"
            case .systemUser: return "SYSTEM_USER"
            case .user: return "USER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UserRole(rawValue: rawValue) ?? UserRole.sdkUnknown(rawValue)
        }
    }
}
